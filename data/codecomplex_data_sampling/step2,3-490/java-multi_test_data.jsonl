{"src": "import java.util.*;\nimport java.io.*;\n\npublic class MotherOfDragons {\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out, false);\n        int n = scanner.nextInt();\n        double k = scanner.nextInt();\n        long[] graph = new long[n];\n        for(int i = 0; i < n; i++) {\n            for(int j =0; j < n; j++) {\n                int val = scanner.nextInt();\n                if (val == 1 || i == j) graph[i] |= 1L << j;\n            }\n        }\n        //meet in the middle approach\n        int szLeft = n/2;\n        int szRight = n - szLeft;\n        //max size of clique\n        int[] dp = new int[1 << szLeft];\n        int maxMask = 1 << szLeft;\n        //iterate over every left mask\n        for(int mask = 1; mask <maxMask; mask++) {\n            int curMask = mask;\n            //go over every bit in the mask\n            for(int j = 0; j < szLeft; j++) {\n                if (((1 << j) & mask) > 0) {\n                    //update the union of reachability\n                    curMask &= graph[j + szRight] >> szRight;\n                    //can also attempt to pull from prev mask for max size\n                    //will not be optimal if end update happens, but otherwise is useful for dp\n                    dp[mask] = Math.max(dp[mask], dp[mask ^ (1 << j)]);\n                }\n            }\n            //if the union of connectedness is the starting mask then we have a clique\n            if (mask == curMask) {\n                dp[mask] = Math.max(dp[mask],Integer.bitCount(mask));\n            }\n        }\n        int ans = 0;\n        int rmaxMask = 1 << szRight;\n        for(int mask = 0; mask < rmaxMask; mask++) {\n            //mask to track if the current creates its own clique\n            int curMask = mask;\n            //mask to track the connection between the halves\n            int oMask = maxMask -1;\n            for(int j = 0; j < szRight; j++) {\n                if (((1 << j) & mask) > 0) {\n                    //need to mask out the left side bits\n                    curMask &= (graph[j] & (rmaxMask-1));\n                    //update corresp avail in the left side\n                    oMask &= graph[j] >> szRight;\n                }\n            }\n            //not a clique portion\n            if (curMask != mask) continue;\n            //update answer\n            ans = Math.max(ans, Integer.bitCount(mask) + dp[oMask]);\n        }\n        k/=ans;\n        out.println(k * k * (ans * (ans-1))/2);\n        out.flush();\n    }\n    \n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "np", "problem": "0839_E", "from": "CODEFORCES", "tags": "brute force,graphs,math,meet-in-the-middle"}
{"src": "import java.util.Scanner;\n\npublic class first {\n\tstatic int max = 1000000000;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] tab = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ttab[i] = sc.nextInt();\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tif(i!=j)\n\t\t\t\tif(tab[i]>=tab[j] && tab[i]%tab[j]==0) {\n\t\t\t\t\ttab[i] = max;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(tab[i]!=max) res++;\n\t\t}\n\t\tSystem.out.println(res);\n\t\t//System.out.println(4%-1);\n\t}\n\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.Scanner;\n\n\n\npublic class Pipeline {\n\n\n\n\tpublic static void main(String[] args) {\n\n\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tLong n = sc.nextLong(), k = sc.nextLong();\n\n\t\tsc.close();\n\n\n\n\t\tk--;\n\n\t\tn--;\n\n\t\t\n\n\t\tLong limit = (k * (k + 1)) / 2 ;\n\n\n\n\t\tif (n > limit) {\n\n\t\t\tSystem.out.println(-1);\n\n\t\t\t\n\n\t\t} else if ( n == 0 ) {\n\n\t\t\tSystem.out.println(0);\n\n\t\t\t\n\n\t\t} else if (n <= k) {\n\n\t\t\tSystem.out.println(1);\n\n\t\t\t\n\n\t\t} else {\n\n\n\n\t\t\tLong count = 0L;\n\n\t\t\tLong end = k;\n\n\t\t\t\n\n\t\t\tLong sk = BS(end,n); //findMaxRange(n,end);\n\n\t\t\t\t\t\t\n\n\t\t\tcount += end - sk + 1 ;\n\n\n\n\t\t\tLong cur = ( end * (end+1) / 2 ) -  ( sk * (sk-1) / 2 ) ;\n\n\n\n\t\t\tn = n - cur ;\n\n\t\t\t\n\n\t\t\tif ( n != 0 ) {\n\n\t\t\t\tcount++;\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tSystem.out.println(count);\n\n\t\t}\n\n\n\n\t\t// erke\n\n\n\n\t}\n\n\t\n\n\tpublic static Boolean valid(Long mid,Long e,Long n){\n\n\t\t\n\n\t\tLong cur = ( e * (e+1) / 2 ) -  ( mid * (mid-1) / 2 ) ;\n\n\t\t\n\n\t\tif (cur <= n )\n\n\t\t\treturn true;\n\n\t\treturn false;\n\n\t}\n\n\t\n\n\tpublic static Long BS(Long x, Long n){\n\n\t\tLong s=1L,e=x,m=0L;\n\n\t\twhile(s<e){\n\n\t\t\tm=(s+e+1)/2-1;\n\n\t\t\tif(!valid(m,x,n))\n\n\t\t\t\ts=m+1;\n\n\t\t\telse \n\n\t\t\t\te=m;\n\n\t\t}\n\n\t\treturn s;\n\n\t}\n\n\t\n\n\n\n}", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class MainC {\n\n    private FastScanner in;\n    private PrintWriter out;\n\n    private int N;\n    private Dist[] dists;\n    private int countDists;\n    private int[][] minLeft;// startsFrom, count\n\n    private int[] minOrder;\n    private int minOrderCount = 10000000;\n\n    public void solve() throws IOException {\n        int xb = in.nextInt();\n        int yb = in.nextInt();\n        N = in.nextInt();\n        int[] x, y;\n        boolean isOdd;\n        if (N % 2 == 0) {\n            x = new int[N];\n            y = new int[N];\n            isOdd = false;\n        }\n        else {\n            x = new int[N + 1];\n            y = new int[N + 1];\n            isOdd = true;\n        }\n        for (int i = 0; i < N; i++) {\n            x[i] = in.nextInt() - xb;\n            y[i] = in.nextInt() - yb;\n        }\n        if (N % 2 == 1) {\n            N++;\n            x[N - 1] = 0;\n            y[N - 1] = 0;\n        }\n\n        countDists = N * (N - 1) / 2;\n        dists = new Dist[countDists];\n        int c = 0;\n        int commonSum = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                dists[c] = new Dist();\n                dists[c].from = i;\n                dists[c].to = j;\n                dists[c].dist = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])\n                                * (y[i] - y[j]);\n                dists[c].dist = Math.min(dists[c].dist, x[i] * x[i] + y[i]\n                                * y[i] + x[j] * x[j] + y[j] * y[j]);\n                c++;\n            }\n            commonSum += x[i] * x[i] + y[i] * y[i];\n        }\n\n        Arrays.sort(dists);\n\n        minLeft = new int[countDists][N + 1];\n        for (int i = 0; i < countDists; i++) {\n            int sum = 0;\n            for (int j = 1; j <= N; j++) {\n                if (i + j - 1 < countDists) {\n                    sum = sum + dists[i + j - 1].dist;\n                    minLeft[i][j] = sum;\n                }\n                else {\n                    minLeft[i][j] = 100000000;\n                }\n            }\n        }\n\n        order(0, new int[N], 0, 0);\n\n        out.println(minOrderCount + commonSum);\n        for (int i = 1; i <= N / 2; i++) {\n            int first = -1;\n            int second = -1;\n            for (int j = 0; j < N; j++) {\n                if (minOrder[j] == i) {\n                    if (first == -1) {\n                        first = j;\n                    }\n                    else {\n                        second = j;\n                    }\n                }\n            }\n\n            if (isOdd && (first == N - 1 || second == N - 1)) {\n                first++;\n                second++;\n                out.print(\"0 \" + (first + second - N) + \" \");\n            }\n            else if (x[first] * x[first] + y[first] * y[first] + x[second]\n                            * x[second] + y[second] * y[second] < (x[first] - x[second])\n                            * (x[first] - x[second])\n                            + (y[first] - y[second])\n                            * (y[first] - y[second])) {\n                first++;\n                second++;\n                out.print(\"0 \" + first + \" 0 \" + second + \" \");\n            }\n            else {\n                first++;\n                second++;\n                out.print(\"0 \" + first + \" \" + second + \" \");\n            }\n        }\n\n        out.println(\"0\");\n    }\n\n    private void order(int countOrdered, int[] order, int startsFrom, int sum) {\n        if (countOrdered == N) {\n            if (sum < minOrderCount) {\n                minOrder = Arrays.copyOf(order, N);\n                minOrderCount = sum;\n            }\n            return;\n        }\n\n        while (startsFrom < countDists) {\n            if (order[dists[startsFrom].from] == 0\n                            && order[dists[startsFrom].to] == 0) {\n                if (minLeft[startsFrom][(N - countOrdered) / 2] + sum >= minOrderCount) {\n                    break;\n                }\n                order[dists[startsFrom].from] = countOrdered / 2 + 1;\n                order[dists[startsFrom].to] = countOrdered / 2 + 1;\n                order(countOrdered + 2, order, startsFrom + 1, sum\n                                + dists[startsFrom].dist);\n                order[dists[startsFrom].from] = 0;\n                order[dists[startsFrom].to] = 0;\n            }\n            startsFrom++;\n        }\n    }\n\n    private class Dist implements Comparable<Dist> {\n\n        int from;\n        int to;\n        int dist;\n\n        @Override\n        public int compareTo(Dist o) {\n            if (dist < o.dist) {\n                return -1;\n            }\n            if (dist == o.dist) {\n                return 0;\n            }\n            return 1;\n        }\n    }\n\n    public void run() {\n        try {\n            in = new FastScanner(System.in);\n            out = new PrintWriter(System.out);\n            solve();\n            out.close();\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    class FastScanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] arg) {\n        new MainC().run();\n    }\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\n\npublic class Main20 {\n\n    static ArrayList<Integer> primes = new ArrayList<Integer>();\n    static boolean[] prime = new boolean[1001];\n    public static void gen(){\n        Arrays.fill(prime, true);\n        prime[0] = prime[1]  = false; \n        for (int i = 2; i < 1001; i++) {\n            if (prime[i]){\n                primes.add(i);\n                for (int j = i*2; j < 1001; j+=i)\n                    prime[j] = false;\n            }\n        }\n    }\n    public static boolean isVowel(char c){\n        Character r = Character.toLowerCase(c);\n        return (r == 'e' || r == 'a' || r == 'i' || r == 'o' ||  r == 'u'||  r == 'y');\n    }\n    public static void main(String[] args) throws IOException {\n        Scanner s = new Scanner(new InputStreamReader(System.in));\n        String str = s.next();\n        int x;\n        int max= 0;\n        \n        for (int i = 0; i < str.length()-1; i++) {\n            for (int j = i+1; j < str.length(); j++) {\n                x = str.indexOf(str.substring(i,j),i+1) ;\n                if (x != -1){\n                    if (j-i > max) max = j-i;\n                }\n            }\n        }\n        System.out.println(max);\n    }\n\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "\nimport java.util.*;\n\n\npublic class E\n{\n   public static void main(String[] args)\n   {\n      new E(new Scanner(System.in));\n   }\n\n   int N, M;\n   int[][][] memo;\n\n   int go(int i, int j, int mask)\n   {\n      if (i == N)\n         return go(0, j+1, mask);\n      if (j == M)\n      {\n         int mm = mask%(1<<N);\n         //System.out.println(Integer.toBinaryString(mm)+\" \"+Integer.toBinaryString(mask));\n         if (mm != ((1<<N)-1))\n            return N*M;\n         return 0;\n      }\n\n      if (memo[i][j][mask] != -1)\n         return memo[i][j][mask];\n\n      // Now place a spider cluster here\n      int nMask = mask;\n      int prevMask = 0;\n      if (i > 0)\n         prevMask = 1 << (N-1);\n      int nextMask = 0;\n      if (i < (N-1))\n         nextMask = 1 << (N+1);\n      int curMask = 1 << N;\n      int nextRowMask = 1 << (N+N);\n      nMask = nMask|prevMask|nextMask|curMask|nextRowMask;\n      nMask = nMask/2;\n      int res = 1+go(i+1, j, nMask);\n      \n      int pr = mask%2;\n      if (pr == 1)\n      {\n         // We have the option to skip here\n         int rr = go(i+1, j, mask/2);\n         if (rr < res)\n            res = rr;\n      }\n\n   \n      //System.out.printf(\"%d %d %s = %d%n\", i, j, Integer.toBinaryString(mask), res);\n      memo[i][j][mask] = res;\n      return res;\n   }\n\n   public E(Scanner in)\n   {\n      int[] vals = new int[2];\n      vals[0] = in.nextInt();\n      vals[1] = in.nextInt();\n      Arrays.sort(vals);\n\n      N = vals[0];\n      M = vals[1];\n      memo = new int[N][M][1<<(N+N+1)];\n      fill3(memo, -1);\n      \n      int r1 = go(0, 0, (1<<N)-1);\n      int res = N*M-r1;\n      System.out.printf(\"%d%n\", res);\n   \n   }\n\n   void fill3(int[][][] vvv, int val)\n   {\n      for (int[][] vv : vvv)\n         for (int[] v : vv)\n            Arrays.fill(v, val);\n   }\n}\n", "complexity": "np", "problem": "0112_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class CottageVillage {\n\n\tstatic BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));\n\tstatic StringTokenizer st;\n\n\tstatic String LINE() throws Exception { return stdin.readLine(); }\n\tstatic String TOKEN() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens())st = new StringTokenizer(LINE());\n\t\treturn st.nextToken();\n\t}\n\tstatic int INT() throws Exception {return Integer.parseInt(TOKEN());}\n\tstatic long LONG() throws Exception {return Long.parseLong(TOKEN());}\n\tstatic double DOUBLE() throws Exception {return Double.parseDouble(TOKEN());}\n\n\tstatic DecimalFormat DF = new DecimalFormat(\"0.000\",new DecimalFormatSymbols(Locale.ENGLISH));\n\t\n\tpublic static final double EPSILON = 1E-9;\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tint N = INT(), T = INT();\n\t\tHouse[] list = new House[N];\n\t\tfor(int i = 0;i<N;i++) {\n\t\t\tlist[i] = new House(INT(),INT());\n\t\t}\n\t\tArrays.sort(list);\n\t\tint cnt = 2;\n\t\tfor(int i = 1;i<N;i++) {\n\t\t\tint room = list[i].center-list[i-1].center;\n\t\t\tif(2*T<2*room-list[i].side-list[i-1].side)cnt += 2;\n\t\t\telse if(2*T==2*room-list[i].side-list[i-1].side)cnt++;\n\t\t}\n\t\tSystem.out.println(cnt);\n\t\t\n\t}\n\t\n\tprivate static class House implements Comparable<House> {\n\t\tint center, side;\n\t\tHouse(int c, int s) {\n\t\t\tthis.center = c;\n\t\t\tthis.side = s;\n\t\t}\n\t\tpublic int compareTo(House h) {\n\t\t\treturn this.center-h.center;\n\t\t}\n\t}\n\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.TreeSet;\n\n\npublic class Main {\n    public static StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\n    public static int read() throws IOException {\n        tokenizer.nextToken();\n        return (int) tokenizer.nval;\n    }\n\n    public static void main(String[] args) throws IOException {\n        Scanner scanner=new Scanner(System.in);\n        int n=scanner.nextInt();\n        ArrayList<String> list1=new ArrayList<String>();\n        ArrayList<String> list2=new ArrayList<String>();\n        for (int i=0; i<n; i++){\n            String s=scanner.next();\n            list1.add(s);\n        }\n        for (int i=0; i<n; i++){\n            String s=scanner.next();\n            list2.add(s);\n        }\n        for (int i=0; i<list1.size(); i++){\n            for (int j=0; j<list2.size(); j++){\n                if (list1.get(i).equals(list2.get(j))){\n                    list1.remove(i);\n                    list2.remove(j);\n                    i--;\n                    break;\n                }\n            }\n        }\n        System.out.println(list1.size());\n    }\n}", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class A {\n\tpublic static void main(String[] args) throws Exception{\n\t\tString str = new Scanner(System.in).next();\n\t\tSet<String> set = new HashSet<String>();\n\t\tString max = \"\";\n\t\tfor(int l = 1; l < str.length(); ++l){\n\t\t\tfor(int i = 0; i < str.length()-l; ++i){\n\t\t\t\tString substr = str.substring(i, i+l);\n\t\t\t\tif(!set.contains(substr) && str.indexOf(substr) != str.lastIndexOf(substr)){\n\t\t\t\t\tset.add(substr);\n\t\t\t\t\tif(substr.length() > max.length()){\n\t\t\t\t\t\tmax = substr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max.length());\n\t}\n\t\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class A {\n\tBufferedReader br;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tint[] b = a.clone();\n\t\tArrays.sort(b);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tif (k <= 2) {\n\t\t\tout.println(\"YES\");\n\t\t} else {\n\t\t\tout.println(\"NO\");\n\t\t}\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\t// br = new BufferedReader(new FileReader(\"G.in\"));\n\t\t\t// out = new PrintWriter(\"G.out\");\n\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A().run();\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\twhile ((st == null) || (!st.hasMoreTokens()))\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n}", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class F {\n\n\tpublic static void main(String[] args) {\n        FastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int t = 1;//in.nextInt();\n        while(t-->0) { \n        \tint n = in.nextInt();    \n        \tint a[] = in.readArray(n);\n\t\t\tint parity = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(a[i]==-1) continue;\n\t\t\t\tparity ^= 1;\n\t\t\t\tint x = i;\n\t\t\t\twhile(a[x]!=-1){\n\t\t\t\t\tint y = a[x];\n\t\t\t\t\ta[x] = -1;\n\t\t\t\t\tx = y-1;\n\t\t\t\t}\n  \t \t\t}\n  \t \t\tif(parity==1) out.println(\"Um_nik\");\n  \t \t\telse out.println(\"Petr\");\n        }\n        out.flush();\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t\ttry { st = new StringTokenizer(br.readLine()); }\n\t\t\t\tcatch(IOException e) {}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString nextLine(){\n\t\t\ttry{ return br.readLine(); } \n\t\t\tcatch(IOException e) { } return \"\";\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n\n\tstatic final Random random = new Random();\n\n\tstatic void ruffleSort(int[] a){\n\t\tint n = a.length;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint j = random.nextInt(n), temp = a[j];\n\t\t\ta[j] = a[i]; a[i] = temp;\n\t\t}\n\t\tArrays.sort(a); \t\n\t}\n}\n", "complexity": "nlogn", "problem": "0986_B", "from": "CODEFORCES", "tags": "combinatorics,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n/**\n * @author abashkin\n */\npublic class Solution implements Runnable {\n\n    public static void main(String[] args) {\n        new Thread(new Solution()).start();\n    }\n\n    public void run() {\n        try{\n            br = new BufferedReader(new InputStreamReader(System.in));\n            pw = new PrintWriter(new OutputStreamWriter(System.out));\n            solve();\n            pw.close();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    private void solve() throws Exception {\n        int n = nextInt();\n        pw.print(n + n / 2);\n    }\n\n    private BufferedReader br;\n    private PrintWriter pw;\n    private StringTokenizer tok;\n\n    private String next() throws Exception {\n        while (tok == null || !tok.hasMoreElements()) tok = new StringTokenizer(br.readLine());\n        return tok.nextToken();\n    }\n\n    private int nextInt() throws Exception {\n        return Integer.parseInt(next());\n    }\n\n\n\n}", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class Round313A {\n\tprivate static final int LOCAL_ENV = 0;\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\ttry {\n\t\t\tif (LOCAL_ENV == 1) {\n\t\t\t\tin = new Scanner(new File(\"input.txt\"));\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\tin = new Scanner(System.in);\n\t\t}\n\n\t\tlong n = in.nextLong();\n\n\t\tif (n >= -9) {\n\t\t\tSystem.out.println(n);\n\t\t} else {\n\t\t\tlong absN = Math.abs(n);\n\t\t\tlong m1 = -(absN / 10);\n\t\t\tlong last = absN % 10;\n\t\t\tlong m2 = -((absN / 100) * 10 + last);\n\t\t\tSystem.out.println(Math.max(m1, m2));\n\t\t}\n\t}\n}\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt(), k = sc.nextInt();\n        long rhs = 2l * (n + k);\n        for (int x = 1; ; x++) {\n            long lhs = 1l * x * x + 3l * x;\n            if (rhs == lhs) {\n                out.println(n - x);\n                break;\n            }\n        }\n        out.flush();\n        out.close();\n    }\n\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextDouble();\n            return ans;\n        }\n\n        public short nextShort() throws IOException {\n            return Short.parseShort(next());\n        }\n\n    }\n}", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.util.regex.*;\n\n/**\n *\n * @author jon\n */\npublic class Fish {\n    double memo[] = new double[(1<<18)];\n    int N, FULL;\n    double prob[][] = new double[18][18];\n    Fish() {\n        Scanner in = new Scanner(System.in);\n        Arrays.fill(memo, -1);\n\n        N = in.nextInt();\n        FULL = (1<<N) - 1;\n\n        for(int i = 0; i < N; i++) {\n            for(int j = 0; j < N; j++) {\n                prob[i][j] = in.nextDouble();\n            }\n        }\n\n        for(int i = 0; i < N; i++) {\n            System.out.printf(\"%.6f \", go((1<<i)));\n        }\n        System.out.println();\n\n\n\n    }\n    public double go(int mask) {\n        if(mask == FULL) return 1.0;\n        if(memo[mask] >= 0) return memo[mask];\n        double ret = 0;\n        double mult = Integer.bitCount(mask) + 1;\n        mult *= (mult-1)/2.0;\n\n\n        for(int i = 0; i < N; i++) {\n            if(((1<<i) & mask) != 0) {\n                for(int j = 0; j < N; j++) {\n                    if(((1<<j) & mask) == 0) {\n                        ret += go(mask | (1<<j)) * prob[i][j];\n                    }\n                }\n            }\n        }\n        ret /= mult;\n\n        memo[mask] = ret;\n        return ret;\n    }\n    public static void main(String args[]) {\n        new Fish();\n    }\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class A {\n\tpublic static void main(String[] args) throws Exception{\n\t\tString str = new Scanner(System.in).next();\n\t\tSet<String> set = new HashSet<String>();\n\t\tString max = \"\";\n\t\tfor(int l = 1; l < str.length(); ++l){\n\t\t\tfor(int i = 0; i < str.length()-l; ++i){\n\t\t\t\tString substr = str.substring(i, i+l);\n\t\t\t\tif(!set.contains(substr) && str.indexOf(substr) != str.lastIndexOf(substr)){\n\t\t\t\t\tset.add(substr);\n\t\t\t\t\tif(substr.length() > max.length()){\n\t\t\t\t\t\tmax = substr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max.length());\n\t}\n\t\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport java.math.BigInteger;\n\npublic class stacks {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tFastIO sc = new FastIO(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tlong remove = 0;\n\t\t\n\t\tint[] heights = new int[n+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\theights[i] = sc.nextInt();\n\t\t\tremove += heights[i];\n\t\t}\n\t\t\n\t\tArrays.sort(heights);\n\t\t//System.out.println(Arrays.toString(heights));\n\t\tlong keep = 0;\n\t\tfor(int i = n; i> 0; i--) {\n\t\t\tif(heights[i-1] >= heights[i]) {\n\t\t\t\theights[i-1] = heights[i]-1;\n\t\t\t}\n\t\t\tkeep += heights[i] - heights[i-1];\n\t\t}\n\t\t//System.out.println(Arrays.toString(heights));\n\t\t\n\t\tpw.println(remove - keep);\n\t\tpw.close();\n\t}\n\n\tstatic class FastIO {\n\n\t\t//Is your Fast I/O being bad?\n\n\t\tInputStream dis;\n\t\tbyte[] buffer = new byte[1 << 17];\n\t\tint pointer = 0;\n\n\t\tpublic FastIO(String fileName) throws Exception {\n\t\t\tdis = new FileInputStream(fileName);\n\t\t}\n\n\t\tpublic FastIO(InputStream is) throws Exception {\n\t\t\tdis = is;\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\tint ret = 0;\n\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\tboolean negative = false;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = nextByte();\n\t\t\t}\n\t\t\twhile (b >= '0' && b <= '9') {\n\t\t\t\tret = 10 * ret + b - '0';\n\t\t\t\tb = nextByte();\n\t\t\t}\n\n\t\t\treturn (negative) ? -ret : ret;\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\tlong ret = 0;\n\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\tboolean negative = false;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = nextByte();\n\t\t\t}\n\t\t\twhile (b >= '0' && b <= '9') {\n\t\t\t\tret = 10 * ret + b - '0';\n\t\t\t\tb = nextByte();\n\t\t\t}\n\n\t\t\treturn (negative) ? -ret : ret;\n\t\t}\n\n\t\tbyte nextByte() throws Exception {\n\t\t\tif (pointer == buffer.length) {\n\t\t\t\tdis.read(buffer, 0, buffer.length);\n\t\t\t\tpointer = 0;\n\t\t\t}\n\t\t\treturn buffer[pointer++];\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\tStringBuffer ret = new StringBuffer();\n\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\twhile (b > ' ') {\n\t\t\t\tret.appendCodePoint(b);\n\t\t\t\tb = nextByte();\n\t\t\t}\n\n\t\t\treturn ret.toString();\n\t\t}\n\n\t}\n}\n", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long MOD = 1_000_000_007;\n    int inf = Integer.MAX_VALUE;\n\n    void solve()\n    {\n        int n = ni();\n        int[] a = new int[n];\n        for(int i = 0; i < n; i++){\n            a[i] = ni();\n        }\n        long ans = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                if(a[j]<a[i]) ans++;\n            }\n        }\n        if(ans%2==0) ans = 0;\n        else ans = 1;\n        int m = ni();\n        for(int i = 0; i < m; i++){\n            long s = nl();\n            long g = nl();\n            long sub = g-s;\n            long res = sub*(sub+1)/2;\n            if(res%2==1) ans = 1 - ans;\n            if(ans==0) out.println(\"even\");\n            else out.println(\"odd\");\n        }\n\n    }\n\n     \n        \n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        \n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n//        System.err.println(f(1));\n\n\n//        System.err.println(f(4));\n        int tc = sc.nextInt();\n        out: while(tc-->0){\n            long n = sc.nextInt();\n\n            long k = sc.nextLong();\n            if(n >= 32){\n                pw.println(\"YES \" + (n-1));\n                continue;\n            }\n\n            long steps = 0;\n            for (int i = 1;; i++) {\n                long cnt = ((1l<<(i+1))-1);\n                steps += ((1l<<(i))-1);\n                if(steps > k)\n                    break;\n                if(steps > f(n))\n                    break;\n//                long rem = k-((1<<i)-1);\n                long rem = k-steps;\n//                System.err.println(\"steps:\" + steps + \" cnt:\" + cnt + \" f:\"  + f(n-i));\n//                System.err.println(\"rem: \" + (f(n) - steps - cnt*f(n-i)));\n                if(rem <= f(n) - steps - cnt*f(n-i)){\n                    pw.println(\"YES \" + (n-i));\n                    continue out;\n                }\n            }\n\n            pw.println(\"NO\");\n        }\n\n\n        pw.flush();\n        pw.close();\n    }\n\n\n    static long f(long n){\n        if(n == 0)\n            return 0;\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans += 1l<<(2*i);\n        }\n        return ans;\n    }\n\n    static int[][] matMul(int[][] A, int[][] B, int p, int q, int r)\t//C(p x r) = A(p x q) x (q x r) -- O(p x q x r)\n    {\n        int[][] C = new int[p][r];\n        for(int i = 0; i < p; ++i)\n            for(int j = 0; j < r; ++j)\n                for(int k = 0; k < q; ++k)\n                    C[i][j] += A[i][k] * B[k][j];\n        return C;\n    }\n\n    /*\n     * 4. Square Matrix Exponentiation\n     */\n    static int[][] matPow(int[][] base, int p)\n    {\n        int n = base.length;\n        int[][] ans = new int[n][n];\n        for(int i = 0; i < n; i++)\n            ans[i][i] = 1;\n        while(p != 0)\n        {\n            if((p & 1) == 1)\n                ans = matMul(ans, base, n, n, n);\n            base = matMul(base, base, n, n, n);\n            p >>= 1;\n        }\n\n        return ans;\n    }\n\n\n    static int[][] packU(int n, int[] from, int[] to) {\n        int[][] g = new int[n][];\n        int[] p = new int[n];\n        for (int f : from)\n            p[f]++;\n        for (int t : to)\n            p[t]++;\n        for (int i = 0; i < n; i++)\n            g[i] = new int[p[i]];\n        for (int i = 0; i < from.length; i++) {\n            g[from[i]][--p[from[i]]] = to[i];\n            g[to[i]][--p[to[i]]] = from[i];\n        }\n        return g;\n    }\n    static int pow(int n, int p){\n        int ans = 1;\n        for (int i = 0; i < p; i++) {\n            ans *= n;\n        }\n        return ans;\n    }\n\n    static int[][] packD(int n, int[] from, int[] to) {\n        int[][] g = new int[n][];\n        int[] p = new int[n];\n        for (int f : from) if(f != -1) p[f]++;\n        for (int i = 0; i < n; i++) g[i] = new int[p[i]];\n        for (int i = 0; i < from.length; i++) if(from[i] != -1) {g[from[i]][--p[from[i]]] = to[i];}\n        return g;\n    }\n\n    static void shuffle(int[] a)\n    {\n        int n = a.length;\n        for(int i = 0; i < n; i++)\n        {\n            int r = i + (int)(Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n    static class Scanner\n    {\n        StringTokenizer st; BufferedReader br;\n        public Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n        public Scanner(String s) throws FileNotFoundException {\tbr = new BufferedReader(new FileReader(new File(s)));}\n        public String next() throws IOException {while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());return st.nextToken();}\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n        public long nextLong() throws IOException {return Long.parseLong(next());}\n        public String nextLine() throws IOException {return br.readLine();}\n        public boolean ready() throws IOException {return br.ready();}\n    }\n}\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class Main2 {\n\n    static int mod = 1000000007;\n    static FastScanner scanner;\n\n\n    public static void main(String[] args) {\n        scanner = new FastScanner();\n        int n = scanner.nextInt();\n        int T = scanner.nextInt();\n\n        int[][] songs = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            songs[i][0] = scanner.nextInt();\n            songs[i][1] = scanner.nextInt() - 1;\n        }\n\n        int[] mapping = new int[65536];\n        int mask = 1;\n        for (int k = 0; k < n; k++) {\n            for (int i = 1; i < mapping.length; i++) {\n                if ((i & mask) != 0) mapping[i] += songs[k][0];\n            }\n            mask <<= 1;\n        }\n\n        int[][][] dp = new int[17][65536][3];\n        mask = 1;\n\n        for (int i = 0; i < n; i++) {\n            dp[1][mask][songs[i][1]] = 1;\n            mask <<= 1;\n        }\n\n        for (int i = 1; i < n; i++) {\n            mask = 1;\n            for (int k = 0; k < n; k++) {\n                int cg = songs[k][1];\n\n                int g1,g2;\n                if (cg == 0) {g1 = 1; g2 = 2;}\n                else if (cg == 1) {g1 = 0; g2 = 2;}\n                else {g1 = 0; g2 = 1;}\n\n                for (int j = 1; j < 65536; j++) {\n                    if ((j & mask) != 0) continue;\n                    dp[i + 1][j | mask][cg] = (dp[i + 1][j | mask][cg] + (dp[i][j][g1] + dp[i][j][g2]) % mod) % mod;\n                }\n                mask <<= 1;\n            }\n        }\n        int res = 0;\n        for (int k = 0; k < 17; k++)\n        for (int i = 1; i < 65536; i++) {\n            if (mapping[i] == T) res = (res + dp[k][i][0] + dp[k][i][1] + dp[k][i][2]) % mod;\n        }\n        System.out.println(res);\n    }\n\n    static long test(long[] b, long c, int maxSkipped, int startWith) {\n        int skipped = 0;\n        long lastSkipped = b[0];\n        for (int i = startWith; i < b.length; i++) {\n            long expected = b[0] + c * (i - skipped);\n            if (b[i] != expected) {\n                skipped++;\n                lastSkipped = b[i];\n                if (skipped > maxSkipped) {\n                    return Long.MAX_VALUE;\n                }\n            }\n        }\n        return lastSkipped;\n    }\n\n    static boolean test2(long[] b, long c) {\n        for (int i = 1; i < b.length; i++) {\n            long expected = b[1] + c * (i - 1);\n            if (b[i] != expected) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n//    5 5\n//    1 1 5 2 3\n\n\n    static class WithIdx implements Comparable<WithIdx> {\n        int val;\n        int idx;\n\n        public WithIdx(int val, int idx) {\n            this.val = val;\n            this.idx = idx;\n        }\n\n        @Override\n        public int compareTo(WithIdx o) {\n            if (val == o.val) {\n                return Integer.compare(idx, o.idx);\n            }\n            return -Integer.compare(val, o.val);\n        }\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                e.printStackTrace();\n                throw new RuntimeException();\n            }\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) res[i] = nextInt();\n            return res;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) res[i] = nextLong();\n            return res;\n        }\n\n        String[] nextStringArray(int n) {\n            String[] res = new String[n];\n            for (int i = 0; i < n; i++) res[i] = nextToken();\n            return res;\n        }\n    }\n\n    static class PrefixSums {\n        long[] sums;\n\n        public PrefixSums(long[] sums) {\n            this.sums = sums;\n        }\n\n        public long sum(int fromInclusive, int toExclusive) {\n            if (fromInclusive > toExclusive) throw new IllegalArgumentException(\"Wrong value\");\n            return sums[toExclusive] - sums[fromInclusive];\n        }\n\n        public static PrefixSums of(int[] ar) {\n            long[] sums = new long[ar.length + 1];\n            for (int i = 1; i <= ar.length; i++) {\n                sums[i] = sums[i - 1] + ar[i - 1];\n            }\n            return new PrefixSums(sums);\n        }\n\n        public static PrefixSums of(long[] ar) {\n            long[] sums = new long[ar.length + 1];\n            for (int i = 1; i <= ar.length; i++) {\n                sums[i] = sums[i - 1] + ar[i - 1];\n            }\n            return new PrefixSums(sums);\n        }\n    }\n\n    static class ADUtils {\n        static void sort(int[] ar) {\n            Random rnd = ThreadLocalRandom.current();\n            for (int i = ar.length - 1; i > 0; i--)\n            {\n                int index = rnd.nextInt(i + 1);\n                // Simple swap\n                int a = ar[index];\n                ar[index] = ar[i];\n                ar[i] = a;\n            }\n            Arrays.sort(ar);\n        }\n\n        static void reverse(int[] arr) {\n            int last = arr.length / 2;\n            for (int i = 0; i < last; i++) {\n                int tmp = arr[i];\n                arr[i] = arr[arr.length - 1 - i];\n                arr[arr.length - 1 - i] = tmp;\n            }\n        }\n\n        static void sort(long[] ar) {\n            Random rnd = ThreadLocalRandom.current();\n            for (int i = ar.length - 1; i > 0; i--)\n            {\n                int index = rnd.nextInt(i + 1);\n                // Simple swap\n                long a = ar[index];\n                ar[index] = ar[i];\n                ar[i] = a;\n            }\n            Arrays.sort(ar);\n        }\n    }\n\n    static class MathUtils {\n        static long[] FIRST_PRIMES = {\n                2,     3,      5,      7,     11,     13,     17,     19,     23,     29,\n                31,     37,     41,     43,     47,     53,     59,     61,     67,     71,\n                73,     79,     83,     89  ,   97 ,    101,    103,    107,    109,    113,\n                127,    131,    137,    139,    149,    151,    157,    163,    167,    173,\n                179,    181,    191,    193,    197,    199,    211,    223,    227,    229,\n                233,    239,    241,    251,    257,    263,    269,    271,    277,    281,\n                283,    293,    307,    311,    313,    317,    331,    337,    347,    349,\n                353,    359,    367,    373,    379,    383,    389,    397,    401,    409,\n                419,    421,    431,    433,    439,    443,    449,    457,    461,    463,\n                467,    479,    487,    491,    499,    503,    509,    521,    523,    541,\n                547,    557,    563,    569,    571,    577,    587,    593,    599,    601,\n                607,    613,    617,    619,    631,    641,    643,    647,    653,    659,\n                661,    673,    677,    683,    691,    701,    709,    719,    727,    733,\n                739,    743,    751,    757,    761,    769,    773,    787,    797,    809,\n                811,    821,    823,    827,    829,    839,    853,    857,    859,    863,\n                877,    881,    883,    887,    907,    911,    919,    929,    937,    941,\n                947,    953,    967,    971,    977,    983,    991,    997,   1009,   1013,\n                1019,   1021,   1031,   1033,   1039,   1049,   1051};\n\n        static long[] primes(int to) {\n            long[] all = new long[to + 1];\n            long[] primes = new long[to + 1];\n            all[1] = 1;\n            int primesLength = 0;\n            for (int i = 2; i <= to; i ++) {\n                if (all[i] == 0) {\n                    primes[primesLength++] = i;\n                    all[i] = i;\n                }\n                for (int j = 0; j < primesLength && i * primes[j] <= to && all[i] >= primes[j]; j++) {\n                    all[(int) (i * primes[j])] = primes[j];\n                }\n            }\n            return Arrays.copyOf(primes, primesLength);\n        }\n\n        static long modpow(long b, long e, long m) {\n            long result = 1;\n\n            while (e > 0) {\n                if ((e & 1) == 1) {\n                    /* multiply in this bit's contribution while using modulus to keep\n                     * result small */\n                    result = (result * b) % m;\n                }\n                b = (b * b) % m;\n                e >>= 1;\n            }\n\n            return result;\n        }\n\n        static long submod(long x, long y, long m) {\n            return (x - y + m) % m;\n        }\n    }\n}\n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner reader = new Scanner(System.in);\n\t\tint a = reader.nextInt();\n\t\tint b = reader.nextInt();\n\t\tint c = reader.nextInt();\n\t\tint n = reader.nextInt();\n\t\t\n\t\tif (c >= n||c>a||c>b)\n\t\t\tSystem.out.println(\"-1\");\n\t\telse {\n\t\t\ta = a - c;\n\t\t\tb -= c;\n\t\t\tn = n - (a + b + c);\n\t\t\tif (n > 0) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t} else\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t}\n\t\t\n\t}\n}", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class A {\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\n\t\t\tString[] s = in.readLine().split(\" \");\n\t\t\tint n = Integer.parseInt(s[0]);\n\t\t\tint t = Integer.parseInt(s[1]) * 2;\n\t\t\t\n\t\t\tint[] walls = new int[n*2]; \n\t\t\t\n\t\t\tfor (int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ts = in.readLine().split(\" \");\n\t\t\t\tint x = Integer.parseInt(s[0]) * 2;\n\t\t\t\tint a = Integer.parseInt(s[1]);\n\t\t\t\twalls[i*2] = x-a;\n\t\t\t\twalls[i*2+1] = x+a;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(walls);\n\t\t\t\n\t\t\tint count = 2;\n\t\t\t\n\t\t\tfor (int i=1; i<n*2-2; i+=2) {\n\t\t\t\tint space = walls[i+1] - walls[i]; \n\t\t\t\tif ( space == t)\n\t\t\t\t\tcount += 1;\n\t\t\t\telse if ( space > t)\n\t\t\t\t\tcount += 2;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println (count);\n\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t}\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\n \n\n public class SolutionC{\n       public static void main(String[] args) throws Exception{\n               Scanner sc=new Scanner(System.in);\n        PrintWriter out=new PrintWriter(System.out);\n       int t=sc.nextInt();\n       int[] arr=new int[10000002];\n       for(int i=0;i<arr.length;i++){\n           arr[i]=i;\n       }\n       for(int i=2;i*i<arr.length;i++){\n           int b=i*i;\n          for(int j=b;j<arr.length;j+=b){\n              arr[j]=j/b;\n          }\n       }\n      int[] pp = new int[10000001]; Arrays.fill(pp, -1);\n       while(t-->0){\n           \n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        int[] aa=new int[n];\n         for(int i=0;i<n;i++){\n             int a=sc.nextInt();\n             aa[i]=arr[a];\n         }\n        \n         int[] mp = new int[k + 1];\n\t\t\tint[] ip = new int[k + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = aa[i];\n\t\t\t\tfor (int h = k; h >= 0; h--) {\n\t\t\t\t\tif (pp[a] >= ip[h]) {\n\t\t\t\t\t\tmp[h]++;\n\t\t\t\t\t\tip[h] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (h > 0 && (mp[h - 1] < mp[h] || mp[h - 1] == mp[h] && ip[h - 1] > ip[h])) {\n\t\t\t\t\t\tmp[h] = mp[h - 1];\n\t\t\t\t\t\tip[h] = ip[h - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpp[a] = i;\n\t\t\t}\n         \n       \n        out.println(mp[k]+1);\n        \n       for (int i = 0; i < n; i++) {\n\t\t\t\tpp[aa[i]] = -1;\n\t\t\t}\n        \n       }\n           \n           out.close();\n}\n\n}", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\n\npublic class JavaApplication2 {\n\n    \n    public static void main(String[] args) throws IOException {\n     \n        BufferedReader sc= new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(sc.readLine().split(\" \")[0]);\n        ArrayList<String> tshr = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            tshr.add(sc.readLine());\n        }\n        for (int i = 0; i < n; i++) {\n            tshr.remove(sc.readLine());\n        }\n        System.out.println(tshr.size());\n        \n        \n        \n        \n        \n        \n    }\n    \n}", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.util.*;\n\nimport java.math.*;\n\npublic class Main {\n\npublic static void main(String arg[])\n\n{\n\n\tScanner s=new Scanner(System.in);\n\n\t\tint n=s.nextInt();\n\n\t\tint m=s.nextInt();\n\n\t\tBigInteger pow,div,md;\n\n\t\tdiv = new BigInteger(\"2\");\n\n\t\tpow = div.pow(n);\n\n\t\tmd = BigInteger.valueOf(m).mod(pow);\n\n\t\tSystem.out.println(md);\n\n\t}\n\n}\n\n\n\n", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.Scanner;\nimport java.util.ArrayList;\n import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n       \n        Scanner sc = new Scanner(System.in);\n        int ar[] = new int[26];\n        int n = sc.nextInt(), k = sc.nextInt();\n        String s = sc.next();\n        for(char c : s.toCharArray()){\n            int z = c - 'A';\n            ar[z]++;\n        }\n        int m = n;\n        for(int i = 0;i<k;i++){\n            m = Math.min(m,ar[i]);\n        }\n        System.out.println(m*k);\n       \n        \n        \n        \n    }\n}\n    \n\n\n\t \t \t  \t  \t\t\t\t   \t  \t \t\t   \t  \t", "complexity": "linear", "problem": "1038_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "import java.util.*;\n\nimport java.io.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\n\tlong mod1 = (long) 1e9 + 7;\n\tint mod2 = 998244353;\n\n\tpublic void solve() throws Exception {\n\t\tint n=sc.nextInt();\n\t\tint t=sc.nextInt();\n\t\tPair arr[]=new Pair[n];\n\t\tint another[]=new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint ai=sc.nextInt();\n\t\t\tint time=sc.nextInt();\n\t\t\tarr[i]=new Pair(ai, time, i+1);\n\t\t}\n\t\tsort(arr);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tanother[i]=arr[i].a;\n\t\t}\n\t\tint maxscore=0;\n\t\tint maxai=n+1;\n\t\tint start=1;\n\t\tint end=n;\n\t\twhile(start<=end) {\n\t\t\tint mid=start+(end-start)/2;\n\t\t\tint index=LowerBound(another, mid);\n\t\t\tPriorityQueue<Integer> pq=new PriorityQueue<Integer>((a,b)->(a-b));\n\t\t\tfor(int i=index;i<n;i++) {\n\t\t\t\tpq.add(arr[i].time);\n\t\t\t}\n\t\t\tint maxtime=t;\n\t\t\tint score=0;\n\t\t\twhile(maxtime>0 && !pq.isEmpty()) {\n\t\t\t\tmaxtime -= pq.poll();\n\t\t\t\tif(maxtime>=0) score++;\n\t\t\t}\n\t\t\tif(score>=mid) {\n\t\t\t\tif(mid>=maxscore) {\n\t\t\t\t\tmaxscore=mid;\n\t\t\t\t\tmaxai=mid;\n\t\t\t\t}\n\t\t\t\tstart=mid+1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tend=mid-1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tint index=LowerBound(another, maxai);\n\t\tPriorityQueue<Integer> pq=new PriorityQueue<Integer>((a,b)->(arr[a].time-arr[b].time));\n\t\tfor(int i=index;i<n;i++) {\n\t\t\tpq.add(i);\n\t\t}\n\t\tint maxtime=t;\n\t\tout.println(maxscore);\n\t\tout.println(maxscore);\n\t\twhile(maxscore!=0 && !pq.isEmpty()) {\n\t\t\tout.print(arr[pq.poll()].index+\" \");\n\t\t\tmaxscore--;\n\t\t}\n\t\tout.println();\n\t\t\n\t\t\n\t\t\n\t\t\n\n\t}\n\t\n\tclass Pair implements Comparable<Pair>{\n\t\tint a;\n\t\tint time;\n\t\tint index;\n\t\tPair(int a, int time, int index) {\n\t\t\tthis.a=a;\n\t\t\tthis.time=time;\n\t\t\tthis.index=index;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Pair x) {\n\t\t\treturn this.a-x.a;\n\t\t}\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic void sort(Pair[] a) {\n\t\tArrayList<Pair> l = new ArrayList<>();\n\t\tfor (Pair i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n\t}\n\n\tstatic long ncr(int n, int r, long p) {\n\t\tif (r > n)\n\t\t\treturn 0l;\n\t\tif (r > n - r)\n\t\t\tr = n - r;\n\n\t\tlong C[] = new long[r + 1];\n\n\t\tC[0] = 1;\n\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\tfor (int j = Math.min(i, r); j > 0; j--)\n\t\t\t\tC[j] = (C[j] + C[j - 1]) % p;\n\t\t}\n\t\treturn C[r] % p;\n\t}\n\n\tvoid sieveOfEratosthenes(boolean prime[], int size) {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tprime[i] = true;\n\n\t\tfor (int p = 2; p * p < size; p++) {\n\t\t\tif (prime[p] == true) {\n\t\t\t\tfor (int i = p * p; i < size; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int LowerBound(int a[], int x) { // smallest index having value >= x; returns 0-based index\n\t\tint l = -1, r = a.length;\n\t\twhile (l + 1 < r) {\n\t\t\tint m = (l + r) >>> 1;\n\t\t\tif (a[m] >= x)\n\t\t\t\tr = m;\n\t\t\telse\n\t\t\t\tl = m;\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int UpperBound(int a[], int x) {// biggest index having value <= x; returns 1-based index\n\t\tint l = -1, r = a.length;\n\t\twhile (l + 1 < r) {\n\t\t\tint m = (l + r) >>> 1;\n\t\t\tif (a[m] <= x)\n\t\t\t\tl = m;\n\t\t\telse\n\t\t\t\tr = m;\n\t\t}\n\t\treturn l + 1;\n\t}\n\n\tpublic long power(long x, long y, long p) {\n\t\tlong res = 1;\n\t\t// out.println(x+\" \"+y);\n\t\tx = x % p;\n\t\tif (x == 0)\n\t\t\treturn 0;\n\n\t\twhile (y > 0) {\n\t\t\tif ((y & 1) == 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\ty = y >> 1;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic Throwable uncaught;\n\n\tBufferedReader in;\n\tFastScanner sc;\n\tPrintWriter out;\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsc = new FastScanner(in);\n\t\t\tsolve();\n\t\t} catch (Throwable uncaught) {\n\t\t\tSolution.uncaught = uncaught;\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Throwable {\n\t\tThread thread = new Thread(null, new Solution(), \"\", (1 << 26));\n\t\tthread.start();\n\t\tthread.join();\n\t\tif (Solution.uncaught != null) {\n\t\t\tthrow Solution.uncaught;\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\n\tpublic FastScanner(BufferedReader in) {\n\t\tthis.in = in;\n\t}\n\n\tpublic String nextToken() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic int[] readArray(int n) throws Exception {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n}", "complexity": "nlogn", "problem": "0913_D", "from": "CODEFORCES", "tags": "binary search,brute force,data structures,greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport static java.lang.Math.*;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class CFC23A implements Runnable {\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new CFC23A()).start();\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint res = 0;\n\t\tString str = nextToken();\n\t\tfor(int i = 0; i < str.length(); ++i)\n\t\t\tfor(int j = i + 1; j <= str.length(); ++j)\n\t\t\t\tif(isOk(str.substring(i, j), str))\n\t\t\t\t\tres = max(res, j - i);\n\t\tout.println(res);\n\t}\n\n\tprivate boolean isOk(String substring, String str) {\n\t\tint from = 0, kol = 0;\n\t\twhile(str.indexOf(substring, from) != -1 && kol < 2) {\n\t\t\t++kol;\n\t\t\tfrom = str.indexOf(substring, from) + 1;\n\t\t}\n\t\treturn kol >= 2;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t// in = new BufferedReader(new FileReader(new File(\"input.txt\")));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\t//out = new PrintWriter(new File(\"output.txt\"));\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tString nextLine() throws IOException {\n\t\ttok = null;\n\t\treturn in.readLine();\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\n\n/**\n * @author khokharnikunj8\n */\npublic class Main {\n    public static void main(String[] args) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                new Main().solve();\n            }\n        }, \"1\", 1 << 26).start();\n    }\n\n    void solve() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DLittleGirlAndMaximumXOR solver = new DLittleGirlAndMaximumXOR();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DLittleGirlAndMaximumXOR {\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            long l = in.scanLong();\n            long r = in.scanLong();\n            for (int i = 63; i >= 0; i--) {\n                if (((l & (1l << i)) ^ ((r & (1l << i)))) != 0) {\n                    out.println(((long) Math.pow(2, i + 1) - 1));\n                    return;\n                }\n            }\n            out.println(0);\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int index;\n        private BufferedInputStream in;\n        private int total;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (index >= total) {\n                index = 0;\n                try {\n                    total = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (total <= 0) return -1;\n            }\n            return buf[index++];\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n        public long scanLong() {\n            long integer = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    integer *= 10;\n                    integer += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * integer;\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class A implements Runnable {\n\n\tfinal boolean LOCAL = System.getProperty(\"ONLINE_JUDGE\") == null;\n\t\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tok;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new A(), \"\", 256*1024*1024).start();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tlong t1 = 0, t2 = 0, m1 = 0, m2 = 0;\n\t\t\tif (LOCAL) {\n\t\t\t\tt1 = System.currentTimeMillis();\n\t\t\t\tm1 = Runtime.getRuntime().freeMemory();\n\t\t\t}\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\tif (LOCAL) {\n\t\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t\t} else {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t}\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t\tif (LOCAL) {\n\t\t\t\tt2 = System.currentTimeMillis();\n\t\t\t\tm2 = Runtime.getRuntime().freeMemory();\n\t\t\t\tSystem.err.println(\"Time = \" + (t2 - t1) + \" ms.\");\n\t\t\t\tSystem.err.println(\"Memory = \" + ((m1 - m2) / 1024) + \" KB.\");\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace(System.err);\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tString readString() throws IOException {\n\t\twhile (!tok.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\t\t\tif (line == null) return null;\n\t\t\ttok = new StringTokenizer(line);\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\t\n\tint readInt() throws IOException {\n\t\treturn Integer.parseInt(readString());\n\t}\n\t\n\tlong readLong() throws IOException {\n\t\treturn Long.parseLong(readString());\n\t}\n\t\n\tdouble readDouble() throws IOException {\n\t\treturn Double.parseDouble(readString());\n\t}\n\t\n\tstatic class Mergesort {\n\n\t\tprivate Mergesort() {}\n\n\t\tpublic static void sort(int[] a) {\n\t\t\tmergesort(a, 0, a.length - 1);\n\t\t}\n\n\t\tpublic static void sort(long[] a) {\n\t\t\tmergesort(a, 0, a.length - 1);\n\t\t}\n\n\t\tpublic static void sort(double[] a) {\n\t\t\tmergesort(a, 0, a.length - 1);\n\t\t}\n\n\t\tprivate static final int MAGIC_VALUE = 42;\n\n\t\tprivate static void mergesort(int[] a, int leftIndex, int rightIndex) {\n\t\t\tif (leftIndex < rightIndex) {\n\t\t\t\tif (rightIndex - leftIndex <= MAGIC_VALUE) {\n\t\t\t\t\tinsertionSort(a, leftIndex, rightIndex);\n\t\t\t\t} else {\n\t\t\t\t\tint middleIndex = (leftIndex + rightIndex) / 2;\n\t\t\t\t\tmergesort(a, leftIndex, middleIndex);\n\t\t\t\t\tmergesort(a, middleIndex + 1, rightIndex);\n\t\t\t\t\tmerge(a, leftIndex, middleIndex, rightIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void mergesort(long[] a, int leftIndex, int rightIndex) {\n\t\t\tif (leftIndex < rightIndex) {\n\t\t\t\tif (rightIndex - leftIndex <= MAGIC_VALUE) {\n\t\t\t\t\tinsertionSort(a, leftIndex, rightIndex);\n\t\t\t\t} else {\n\t\t\t\t\tint middleIndex = (leftIndex + rightIndex) / 2;\n\t\t\t\t\tmergesort(a, leftIndex, middleIndex);\n\t\t\t\t\tmergesort(a, middleIndex + 1, rightIndex);\n\t\t\t\t\tmerge(a, leftIndex, middleIndex, rightIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void mergesort(double[] a, int leftIndex, int rightIndex) {\n\t\t\tif (leftIndex < rightIndex) {\n\t\t\t\tif (rightIndex - leftIndex <= MAGIC_VALUE) {\n\t\t\t\t\tinsertionSort(a, leftIndex, rightIndex);\n\t\t\t\t} else {\n\t\t\t\t\tint middleIndex = (leftIndex + rightIndex) / 2;\n\t\t\t\t\tmergesort(a, leftIndex, middleIndex);\n\t\t\t\t\tmergesort(a, middleIndex + 1, rightIndex);\n\t\t\t\t\tmerge(a, leftIndex, middleIndex, rightIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {\n\t\t\tint length1 = middleIndex - leftIndex + 1;\n\t\t\tint length2 = rightIndex - middleIndex;\n\t\t\tint[] leftArray = new int[length1];\n\t\t\tint[] rightArray = new int[length2];\n\t\t\tSystem.arraycopy(a, leftIndex, leftArray, 0, length1);\n\t\t\tSystem.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n\t\t\tfor (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n\t\t\t\tif (i == length1) {\n\t\t\t\t\ta[k] = rightArray[j++];\n\t\t\t\t} else if (j == length2) {\n\t\t\t\t\ta[k] = leftArray[i++];\n\t\t\t\t} else {\n\t\t\t\t\ta[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void merge(long[] a, int leftIndex, int middleIndex, int rightIndex) {\n\t\t\tint length1 = middleIndex - leftIndex + 1;\n\t\t\tint length2 = rightIndex - middleIndex;\n\t\t\tlong[] leftArray = new long[length1];\n\t\t\tlong[] rightArray = new long[length2];\n\t\t\tSystem.arraycopy(a, leftIndex, leftArray, 0, length1);\n\t\t\tSystem.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n\t\t\tfor (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n\t\t\t\tif (i == length1) {\n\t\t\t\t\ta[k] = rightArray[j++];\n\t\t\t\t} else if (j == length2) {\n\t\t\t\t\ta[k] = leftArray[i++];\n\t\t\t\t} else {\n\t\t\t\t\ta[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void merge(double[] a, int leftIndex, int middleIndex, int rightIndex) {\n\t\t\tint length1 = middleIndex - leftIndex + 1;\n\t\t\tint length2 = rightIndex - middleIndex;\n\t\t\tdouble[] leftArray = new double[length1];\n\t\t\tdouble[] rightArray = new double[length2];\n\t\t\tSystem.arraycopy(a, leftIndex, leftArray, 0, length1);\n\t\t\tSystem.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n\t\t\tfor (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n\t\t\t\tif (i == length1) {\n\t\t\t\t\ta[k] = rightArray[j++];\n\t\t\t\t} else if (j == length2) {\n\t\t\t\t\ta[k] = leftArray[i++];\n\t\t\t\t} else {\n\t\t\t\t\ta[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void insertionSort(int[] a, int leftIndex, int rightIndex) {\n\t\t\tfor (int i = leftIndex + 1; i <= rightIndex; i++) {\n\t\t\t\tint current = a[i];\n\t\t\t\tint j = i - 1;\n\t\t\t\twhile (j >= leftIndex && a[j] > current) {\n\t\t\t\t\ta[j + 1] = a[j];\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\ta[j + 1] = current;\n\t\t\t}\n\t\t}\n\n\t\tprivate static void insertionSort(long[] a, int leftIndex, int rightIndex) {\n\t\t\tfor (int i = leftIndex + 1; i <= rightIndex; i++) {\n\t\t\t\tlong current = a[i];\n\t\t\t\tint j = i - 1;\n\t\t\t\twhile (j >= leftIndex && a[j] > current) {\n\t\t\t\t\ta[j + 1] = a[j];\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\ta[j + 1] = current;\n\t\t\t}\n\t\t}\n\n\t\tprivate static void insertionSort(double[] a, int leftIndex, int rightIndex) {\n\t\t\tfor (int i = leftIndex + 1; i <= rightIndex; i++) {\n\t\t\t\tdouble current = a[i];\n\t\t\t\tint j = i - 1;\n\t\t\t\twhile (j >= leftIndex && a[j] > current) {\n\t\t\t\t\ta[j + 1] = a[j];\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\ta[j + 1] = current;\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\tvoid debug(Object... o) {\n\t\tif (LOCAL) {\n\t\t\tSystem.err.println(Arrays.deepToString(o));\n\t\t}\n\t}\n\t\n//------------------------------------------------------------------------------\n\t\n\tvoid solve() throws IOException {\n\t\tint n = readInt();\n\t\tint m = readInt();\n\t\tint k = readInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = readInt();\n\t\t}\n\t\tMergesort.sort(a);\n\t\tfor (int need = 0; need <= n; need++) {\n\t\t\tint cnt = k;\n\t\t\tfor (int i = 0; i < need; i++) {\n\t\t\t\tcnt += a[n - i - 1] - 1;\n\t\t\t}\n\t\t\tif (cnt >= m) {\n\t\t\t\tout.println(need);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(-1);\n\t}\n\t\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\n@SuppressWarnings(\"unused\")\npublic class A {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tSystem.out.println(\"0 0 \" + n);\n\t}\n}", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Practice {\n\tpublic static long mod = (long) Math.pow(10, 9) + 7;\n\tpublic static long[][][]dp;\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\t// int t = Integer.parseInt(br.readLine());\n//\t\twhile (t-- > 0) {\n\t\tString[] s2 = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(s2[0]);\n\t\tint m = Integer.parseInt(s2[1]);\n\t\tint k = Integer.parseInt(s2[2]);\n\t\tdp=new long[n][m][k+1];\n\t\tint[][] hori = new int[n][m - 1];\n\t\tint[][] verti = new int[n - 1][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString str = (br.readLine());\n\t\t\tString[] s1 = str.split(\" \");\n\t\t\tfor (int j = 0; j < m - 1; j++) {\n\t\t\t\thori[i][j] = Integer.parseInt(s1[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tString str = (br.readLine());\n\t\t\tString[] s1 = str.split(\" \");\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tverti[i][j] = Integer.parseInt(s1[j]);\n\t\t\t}\n\t\t}\n\t\tlong[][]ans=new long[n][m];\n\t\tif(k%2!=0) {\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tans[i][j]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}else {\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tans[i][j]=findAns(i,j,k,hori,verti,n,m,Integer.MAX_VALUE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tStringBuilder str=new StringBuilder();\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tstr.append(ans[i][j]+\" \");\n\t\t\t}pw.println(str.toString());\n\t\t}\n\t\t// }\n\n\t\tpw.close();\n\t}\n\n\tprivate static long findAns(int i, int j, int k, int[][] hori, int[][] verti, int n, int m, int last) {\n\t\t// TODO Auto-generated method stub\n\t\tif(k==0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif(i<n&&j<m&&i>=0&&j>=0) {\n\t\t\t\n\t\t}else {\n\t\t\treturn 100000000;\n\t\t}\n\t//\tSystem.out.println(i+\" \"+j+\" \"+k);\n\t\tif(dp[i][j][k]!=0) {\n\t\t\treturn dp[i][j][k];\n\t\t}\n\t\tlong ans=k*((long)last);\n\t\tif(j>0) {\n\t\t\tlong curr=2*hori[i][j-1];\n\t\t\tcurr+=findAns(i, j-1, k-2, hori, verti, n, m, hori[i][j-1]);\n\t\t\tans=Math.min(ans, curr);\n\t\t}\n\t//\tSystem.out.println(ans+\" 0\");\n\t\tif(j<m-1) {\n\t\t\tlong curr=2*hori[i][j];\n\t\t\tcurr+=findAns(i, j+1, k-2, hori, verti, n, m, hori[i][j]);\n\t\t\tans=Math.min(ans, curr);\n\t\t}\n\t//\tSystem.out.println(ans+\" 1\");\n\t\tif(i>0) {\n\t\t\tlong curr=2*verti[i-1][j];\n\t\t\tcurr+=findAns(i-1, j, k-2, hori, verti, n, m, verti[i-1][j]);\n\t\t\tans=Math.min(ans, curr);\n\t\t}\n\t//\tSystem.out.println(ans+\" 2\");\n\t\tif(i<n-1) {\n\t\t\tlong curr=2*verti[i][j];\n\t\t\tcurr+=findAns(i+1, j, k-2, hori, verti, n, m, verti[i][j]);\n\t\t\tans=Math.min(ans, curr);\n\t\t}\n\t//\tSystem.out.println(ans+\" 3\");\n\t\tdp[i][j][k]=ans;\n\t\treturn ans;\n\t}\n}\n\n//private static long getGCD(long l, long m) {\n//// TODO Auto-generated method stub\n//\n//long t1 = Math.min(l, m);\n//long t2 = Math.max(l, m);\n//while (true) {\n//\tlong temp = t2 % t1;\n//\tif (temp == 0) {\n//\t\treturn t1;\n//\t}\n//\tt2 = t1;\n//\tt1 = temp;\n//}\n//}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.PrintStream;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Nipuna Samarasekara\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    /////////////////////////////////////////////////////////////\n\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n    int n=in.nextInt();\n        if(n==1||n==2){\n            out.println(n);\n            return;\n        }\n        if(n==4){\n            out.println(12);\n            return;\n        }\n     long nn=n;\n        if(n%2==1){\n        long ans=nn*(nn-1)*(nn-2);\n            out.println(ans);\n        }\n        else if(n%3==0){\n            nn--;\n            long ans=nn*(nn-1)*(nn-2);\n            out.println(ans);\n\n        }\n        else {\n            long ans=nn*(nn-1)*(nn-3);\n            out.println(ans);\n            \n        }\n\n    }\n    }\n\nclass FastScanner extends BufferedReader {\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= 0 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (c >= 0 && !isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    public String readLine() {\n        try {\n            return super.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tboolean eof;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tpublic String nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn \"-1\";\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tBufferedReader br;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tvoid run() throws IOException {\n\t\tInputStream input = System.in;\n\t\tPrintStream output = System.out;\n\t\ttry {\n\t\t\tFile f = new File(\"trips.in\");\n\t\t\tif (f.exists() && f.canRead()) {\n\t\t\t\tinput = new FileInputStream(f);\n\t\t\t\toutput = new PrintStream(\"trips.out\");\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t}\n\t\tbr = new BufferedReader(new InputStreamReader(input));\n\t\tout = new PrintWriter(output);\n\t\tsolve();\n\t\tbr.close();\n\t\tout.close();\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint x, y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic int compareTo(Pair p) {\n\t\t\tif (x > p.x) {\n\t\t\t\treturn 1;\n\t\t\t} else if (x < p.x) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tlong ans;\n\t\n\tvoid nod(long a, long b){\n\t\tif (a == 0 || b == 0){\n\t\t\t\n\t\t} else if (a > b){\n\t\t\tans += a / b;\n\t\t\tnod(a % b, b);\n\t\t} else {\n\t\t\tans += b / a;\n\t\t\tnod(a, b % a);\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\tlong a = nextLong(), b = nextLong();\n\t\tans = 0;\n\t\tnod(a, b);\n\t\tout.println(ans);\n\t}\n\n}", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.Scanner;\n\nimport java.io.*;\n\nimport java.util.*;\n\npublic class ReallyBigNumbers817c {\n\n     static long sd(String s) {\n\n        long c = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n\n            c += s.charAt(i);\n\n        }\n\n        return c - s.length() * 0x30;\n\n    }\n\n     \n\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n\n        long n = in.nextLong();\n\n        long s = in.nextLong(); // number\n\n         // level -- > (n + 8) / 9 * 9; --- > s\n\n        long i = (s/10+1)*10 ;\n\n        if (n<10||n-sd(n+\"\")<s) {\n\n            System.out.println(0);\n\n            return;\n\n        }\n\n        while(!(i-sd(i+\"\")>=s)){\n\n        i+=10;\n\n        \n\n        }\n\n        System.out.println(n-i+1);\n\n       \n\n    }\n\n    \n\n\t}\n\n\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class CF125A {\n\n\tprivate void work() throws IOException {\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in)));\n\t\tint n = sc.nextInt();\n\t\tSystem.out.printf(\"%d %d %d\\n\", 0, 0, n);\n\t\tSystem.out.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew CF125A().work();\n\t}\n\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.PrintStream;\nimport static java.lang.Math.*;\n\npublic class Task275A {\n\n    public static Scanner in = new Scanner(System.in);\n    public static PrintStream out = System.out;\n\n    public static void main(String[] args) {\n        long l = in.nextLong();\n        long r = in.nextLong();\n\n        if (l % 2 == 1) {\n            l++;\n        }\n\n        if (r - l < 2) {\n            out.print(-1);\n        }\n        else {\n            out.print(l + \" \" + (l + 1) + \" \" + (l + 2));\n        }\n    }\n\n}", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "//package C;\n\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Fire_Again {\n    static int N;\n    static int M;\n    static int K;\n    private class Pos {\n        public int r;\n        public int c;\n        int last;\n        public Pos(int r,int c, int last) {\n            this.r = r;\n            this.c = c;\n            this.last = last;\n        }\n    }\n    static ArrayList<Pos> pos = new ArrayList<>();\n\n    static boolean[][] used;// = new boolean[2001][2001];\n    static int[] rows = {-1,1,0,0};\n    static int[] cols = {0,0,-1,1};\n    int LAST = 0;\n    int lastRow = 1;\n    int lastCol = 1;\n    public static void main(String[] args) throws IOException {\n        Fire_Again fire_again = new Fire_Again();\n        BufferedReader bufferedReader =\n                new BufferedReader(new FileReader(\"input.txt\"));\n        String[] nm = bufferedReader.readLine().split(\" \");\n        N = Integer.parseInt(nm[0]) + 1;\n        M = Integer.parseInt(nm[1]) + 1;\n        K = Integer.parseInt(bufferedReader.readLine());\n        used = new boolean[N][M];\n        String[] rc = bufferedReader.readLine().split(\" \");\n        for(int k = 0;k < rc.length;k+=2) {\n            int r = Integer.parseInt(rc[k]);\n            int c = Integer.parseInt(rc[k+1]);\n            pos.add(fire_again.new Pos(r,c,0));\n        }\n        fire_again.bfs();\n        PrintStream ps = new PrintStream(\"output.txt\");\n        ps.printf(\"%d %d\\n\",fire_again.lastRow,fire_again.lastCol);\n        ps.flush();\n        ps.close();\n    }\n     Queue<Pos> queue = new LinkedList<>();\n    private void bfs() {\n      queue.addAll(pos);\n      for(Pos p : pos) {\n          used[p.r][p.c] = true;\n        //  System.out.println(\"r = \"+(p.r) + \" c = \" + (p.c));\n      }\n      while(!queue.isEmpty()) {\n          Pos p = queue.poll();\n          if(p.last > LAST) {\n              LAST = p.last;\n              lastRow = p.r;\n              lastCol = p.c;\n          }\n          for(int i = 0;i < rows.length;i++) {\n              int currR = p.r;\n              int currC = p.c;\n              if(currR + rows[i] >= 1 && currR + rows[i] < N &&\n              currC + cols[i] >= 1 && currC + cols[i] < M &&\n              !used[currR + rows[i] ] [currC + cols[i] ] ) {\n              //    System.out.println(\"r = \"+(currR+rows[i]) + \" c = \" + (currC+cols[i]));\n                  queue.add(new Pos(currR+rows[i],currC+cols[i],p.last+1));\n                  used[currR + rows[i] ] [currC + cols[i] ] = true;\n              }\n          }\n      }\n\n    }\n\n}\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        long maxk = (long) 1e18;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int t = in.nextInt();\n\n            long maxn = 1;\n            long val = 0;\n            for (long i = 1; ; i++) {\n                val = 1 + 4 * val;\n                if (val >= maxk) {\n                    maxn = i;\n                    break;\n                }\n            }\n\n            long[] vala = new long[(int) maxn + 1];\n\n            vala[1] = 1;\n\n            for (int i = 2; i <= maxn; i++) {\n                vala[i] = 1 + 4 * vala[i - 1];\n            }\n\n            o:\n            while (t-- > 0) {\n                long n = in.nextInt();\n                long k = in.nextLong();\n\n                if (n - 1 >= maxn) {\n                    out.println(\"YES \" + (n - 1));\n                    continue;\n                }\n\n                k--;\n\n                if (k <= vala[(int) n - 1]) {\n                    out.println(\"YES \" + (n - 1));\n                    continue;\n                }\n\n                long cs = n - 1;\n                long cc = 3;\n                int ind = 2;\n\n                long end = -1;\n                while (k > 0) {\n                    if (k >= cc && cs > 0) {\n                        k -= cc;\n                        cc += (1l << ind);\n                        cs--;\n                        ind++;\n                    } else {\n//                    if (cs > 0 && k < cc) {\n//                        out.println(\"YES \" + cs);\n//                        continue o;\n//                    }\n                        end = ind;\n                        break;\n                    }\n                }\n\n                long fcs = cs;\n\n                if (k == 0) {\n                    out.println(\"YES \" + cs);\n                    continue;\n                }\n\n                k -= vala[(int) n - 1];\n\n                cs = n - 1;\n                cc = 3;\n                ind = 2;\n\n                long rv = 5;\n\n                long sind = 3;\n\n                while (k > 0 && ind < end) {\n                    k -= rv * vala[(int) cs - 1];\n                    rv += (1l << sind);\n                    sind++;\n                    cs--;\n                    ind++;\n                }\n\n                if (k <= 0) {\n                    out.println(\"YES \" + fcs);\n                } else {\n                    out.println(\"NO\");\n                }\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\npublic class A {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s = new String(in.readLine());\n        String[] t=s.split(\" \");\n        int n = Integer.parseInt(t[0]);\n        int k = Integer.parseInt(t[1]);\n        boolean[] prime=new boolean[n+1];\n        for (int i=2;i<Math.sqrt(n);i++) {\n        \tfor (int j=i+i;j<=n;j=j+i) {\n        \t\tprime[j]=true;\n        \t}\n        }\n        int size=0;\n        for (int i=2;i<=n;i++) {\n        \tif (!prime[i]) {\n        \t\tsize++;\n        \t}\n        }\n        int[] pn=new int[size];\n        int index=0;\n        for (int i=2;i<=n;i++) {\n        \tif (!prime[i]) {\n        \t\tpn[index]=i;\n        \t\tindex++;\n        \t}        \t\n        }\n        for (int i=2;i<size;i++) {\n        \tfor (int j=0;j<i;j++) {\n        \t\tif (pn[i]==pn[j]+pn[j+1]+1) {\n//       \t\t\tSystem.out.println(pn[i]+\"=\"+pn[j]+\"+\"+pn[j+1]+\"+1\");\n        \t\t\tk--;\n        \t\t}\n        \t}\n        }\n        if (k<=0) {\n        \tSystem.out.println(\"YES\");\n        } else {\n        \tSystem.out.println(\"NO\");\n        }\n\t}\n\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\tpublic A () throws IOException {\n\t\tint N = sc.nextInt();\n\t\tint [] A = new int [N];\n\t\tfor (int n = 0; n < N; ++n)\n\t\t\tA[n] = sc.nextInt();\n\t\tsolve(N, A);\n\t}\n\t\n\tpublic void solve (int N, int [] A) {\n\t\t//start();\n\t\tArrays.sort(A);\n\t\tint S1 = 0;\n\t\tfor (int n = 0; n < N; ++n)\n\t\t\tS1 += A[n];\n\t\t\n\t\tint S2 = 0;\n\t\tfor (int n = N - 1; n >= 0; --n) {\n\t\t\tS2 += A[n];\n\t\t\tif (S2 > S1 - S2)\n\t\t\t\texit(N - n);\n\t\t}\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////////\n\t\n\tstatic MyScanner sc;\n\tstatic long t;\n\t\n\tstatic void print (Object o) {\n\t\tSystem.out.println(o);\n\t}\n\t\n\tstatic void exit (Object o) {\n\t\tprint(o);\n\t\t//print2((millis() - t) / 1000.0);\n\t\tSystem.exit(0);\n\t}\n\t\n\tstatic void run () throws IOException {\n\t\tsc = new MyScanner ();\n\t\tnew A();\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\trun();\n\t}\n\t\n\tstatic long millis() {\n\t\treturn System.currentTimeMillis();\n\t}\n\t\n\tstatic void start() {\n\t\tt = millis();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tString next() throws IOException {\n\t\t\tnewLine();\n\t\t\treturn line[index++];\n\t\t}\n\t\t\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tString nextLine() throws IOException {\n\t\t\tline = null;\n\t\t\treturn r.readLine();\n\t\t}\n\n\t\t//////////////////////////////////////////////\n\t\t\n\t\tprivate final BufferedReader r;\n\n\t\tMyScanner () throws IOException {\n\t\t\tthis(new BufferedReader(new InputStreamReader(System.in)));\n\t\t}\n\t\t\n\t\tMyScanner(BufferedReader r) throws IOException { \n\t\t\tthis.r = r;\n\t\t\tnewLine();\n\t\t}\n\t\t\n\t\tprivate String [] line;\n\t\tprivate int index;\n\n\t\tprivate void newLine() throws IOException {\n\t\t\tif (line == null || index == line.length) {\n\t\t\t\tline = r.readLine().split(\" \");\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t}\t\t\n\t}\t\n}\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class codeforces {\n\n    public static long cnt = 0;\n\n    public static void f(int g1, int g2, int g3, int last) {\n        if (g1 == 0 && g2 == 0 && g3 == 0) cnt++;\n        if (g1 > 0 && last != 1) f(g1 - 1, g2, g3, 1);\n        if (g2 > 0 && last != 2) f(g1, g2 - 1, g3, 2);\n        if (g3 > 0 && last != 3) f(g1, g2, g3 - 1, 3);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader scan = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(scan.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int t = Integer.parseInt(st.nextToken());\n        int T[] = new int[n];\n        int G[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            st = new StringTokenizer(scan.readLine());\n            T[i] = Integer.parseInt(st.nextToken());\n            G[i] = Integer.parseInt(st.nextToken());\n        }\n        long ans = 0;\n        for (int mask = 1; mask < (1 << n); mask++) {\n            int sum = 0;\n            int g1 = 0;\n            int g2 = 0;\n            int g3 = 0;\n\n            for (int i = 0; i < n; i++) {\n                if (((1 << i) & mask) > 0) {\n                    sum += T[i];\n                    if (G[i] == 1) g1++;\n                    if (G[i] == 2) g2++;\n                    if (G[i] == 3) g3++;\n                }\n            }\n            cnt = 0;\n            if (sum == t) f(g1, g2, g3, -1);\n            for (long i = 1; i <= g1; i++) cnt *= i;\n            for (long i = 1; i <= g2; i++) cnt *= i;\n            for (long i = 1; i <= g3; i++) cnt *= i;\n            ans += cnt;\n        }\n        System.out.println(ans % 1000000007);\n    }\n}", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "//stan hu tao\n//join nct ridin by first year culture reps\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class x1497E\n{\n    static final int MAX = 10000000;\n    public static void main(String hi[]) throws Exception\n    {\n        int[] prime = new int[MAX+1];\n        for(int d=2; d <= MAX; d++)\n            if(prime[d] == 0)\n                for(int v=d; v <= MAX; v+=d)\n                    if(prime[v] == 0)\n                        prime[v] = d;\n        FastScanner infile = new FastScanner();\n        int T = infile.nextInt();\n        StringBuilder sb = new StringBuilder();\n        int[] freq = new int[MAX+1];\n        int[] ts = new int[MAX+1];\n        int time = 0;\n        while(T-->0)\n        {\n            int N = infile.nextInt();\n            int K = infile.nextInt();\n            int[] arr = infile.nextInts(N);\n            for(int i=0; i < N; i++)\n            {\n                int key = 1;\n                while(arr[i] > 1)\n                {\n                    int p = prime[arr[i]];\n                    int cnt = 0;\n                    while(arr[i]%p == 0)\n                    {\n                        arr[i] /= p;\n                        cnt ^= 1;\n                    }\n                    if(cnt == 1)\n                        key *= p;\n                }\n                arr[i] = key;\n            }\n            int[][] right = new int[N][K+1];\n            for(int k=0; k <= K; k++)\n            {\n                int dex = 0;\n                int cnt = 0;\n                for(int i=0; i < N; i++)\n                {\n                    while(dex < N && cnt <= k)\n                    {\n                        if(ts[arr[dex]] == time && freq[arr[dex]] >= 1 && cnt+1 > k)\n                            break;\n                        if(ts[arr[dex]] == time && freq[arr[dex]] >= 1)\n                            cnt++;\n                        if(ts[arr[dex]] < time)\n                        {\n                            ts[arr[dex]] = time;\n                            freq[arr[dex]] = 0;\n                        }\n                        freq[arr[dex]]++;\n                        dex++;\n                    }\n                    right[i][k] = dex;\n                    if(freq[arr[i]] >= 2)\n                        cnt--;\n                    freq[arr[i]]--;\n                }\n                time++;\n            }\n            int[][] dp = new int[N+1][K+1];\n            for(int i=1; i <= N; i++)\n                Arrays.fill(dp[i], N);\n            for(int i=0; i < N; i++)\n                for(int a=0; a <= K; a++)\n                {\n                    dp[i+1][a] = min(dp[i+1][a], dp[i][a]+1);\n                    for(int b=0; b <= K-a; b++)\n                        dp[right[i][b]][a+b] = min(dp[right[i][b]][a+b], dp[i][a]+1);\n                }\n            int res = dp[N][0];\n            for(int k=1; k <= K; k++)\n                res = min(res, dp[N][k]);\n            sb.append(res+\"\\n\");\n        }\n        System.out.print(sb);\n    }\n}\nclass FastScanner\n{\n    private int BS = 1 << 16;\n    private char NC = (char) 0;\n    private byte[] buf = new byte[BS];\n    private int bId = 0, size = 0;\n    private char c = NC;\n    private double cnt = 1;\n    private BufferedInputStream in;\n\n    public FastScanner() {\n        in = new BufferedInputStream(System.in, BS);\n    }\n\n    public FastScanner(String s) {\n        try {\n            in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n        } catch (Exception e) {\n            in = new BufferedInputStream(System.in, BS);\n        }\n    }\n\n    private char getChar() {\n        while (bId == size) {\n            try {\n                size = in.read(buf);\n            } catch (Exception e) {\n                return NC;\n            }\n            if (size == -1) return NC;\n            bId = 0;\n        }\n        return (char) buf[bId++];\n    }\n\n    public int nextInt() {\n        return (int) nextLong();\n    }\n\n    public int[] nextInts(int N) {\n        int[] res = new int[N];\n        for (int i = 0; i < N; i++) {\n            res[i] = (int) nextLong();\n        }\n        return res;\n    }\n\n    public long[] nextLongs(int N) {\n        long[] res = new long[N];\n        for (int i = 0; i < N; i++) {\n            res[i] = nextLong();\n        }\n        return res;\n    }\n\n    public long nextLong() {\n        cnt = 1;\n        boolean neg = false;\n        if (c == NC) c = getChar();\n        for (; (c < '0' || c > '9'); c = getChar()) {\n            if (c == '-') neg = true;\n        }\n        long res = 0;\n        for (; c >= '0' && c <= '9'; c = getChar()) {\n            res = (res << 3) + (res << 1) + c - '0';\n            cnt *= 10;\n        }\n        return neg ? -res : res;\n    }\n\n    public double nextDouble() {\n        double cur = nextLong();\n        return c != '.' ? cur : cur + nextLong() / cnt;\n    }\n\n    public double[] nextDoubles(int N) {\n        double[] res = new double[N];\n        for (int i = 0; i < N; i++) {\n            res[i] = nextDouble();\n        }\n        return res;\n    }\n\n    public String next() {\n        StringBuilder res = new StringBuilder();\n        while (c <= 32) c = getChar();\n        while (c > 32) {\n            res.append(c);\n            c = getChar();\n        }\n        return res.toString();\n    }\n\n    public String nextLine() {\n        StringBuilder res = new StringBuilder();\n        while (c <= 32) c = getChar();\n        while (c != '\\n') {\n            res.append(c);\n            c = getChar();\n        }\n        return res.toString();\n    }\n\n    public boolean hasNext() {\n        if (c > 32) return true;\n        while (true) {\n            c = getChar();\n            if (c == NC) return false;\n            else if (c > 32) return true;\n        }\n    }\n}", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class Main {\n\t\n\tScanner in;\n\tstatic PrintWriter out;\n\t\n\t\n\tstatic class Scanner {\n\t\tStreamTokenizer in;\n\t\t\n\t\tScanner(InputStream is) {\n\t\t\tin = new StreamTokenizer(new BufferedReader(new InputStreamReader(is)));\n\t\t\tin.resetSyntax();\n\t\t\tin.whitespaceChars(0, 32);\n\t\t\tin.wordChars(33, 255);\n\t\t}\n\t\t\n\t\tString readLine() {\n\t\t\ttry {\n\t\t\t\tin.nextToken();\n\t\t\t\tasserT(in.ttype == StreamTokenizer.TT_WORD);\n\t\t\t\treturn in.sval;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(readLine());\t\t\t\n\t\t}\n\t}\n\t\n\t\n\t\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tlong k = in.nextInt();\n\t\tint ar[] = new int[n];\n\t\tTreeMap <Integer, Integer> nums = new TreeMap<Integer, Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tar[i] = in.nextInt();\n\t\t\tnums.put(ar[i], i);\n\t\t}\n\t\t\n\t\tif (k == 1) {\n\t\t\tout.println(n);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint next[] = new int[n];\n\t\tArrays.fill(next, -1);\n\t\t\n\t\tint count = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong val = ar[i] * k;\n\t\t\tint intVal = (int)val;\n\t\t\tif (intVal == val) {\n\t\t\t\tif (nums.containsKey(intVal)) {\n\t\t\t\t\tint idx = nums.get(intVal);\n\t\t\t\t\tnext[i] = idx;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ar[i] % k == 0) {\n\t\t\t\tintVal = ar[i] / (int)k;\n\t\t\t\t\n\t\t\t\tif (nums.containsKey(intVal)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint curr = nums.pollFirstEntry().getValue();\n\t\t\tboolean odd = false;\n\t\t\twhile (next[curr] != -1) {\n\t\t\t\tif (!odd) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tint to = next[curr];\n\t\t\t\tnext[curr] = -1;\n\t\t\t\tcurr = to;\n\t\t\t\todd = !odd;\n\t\t\t\t\n\t\t\t\tif (next[curr] == -1) {\n\t\t\t\t\tif (!odd) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(count);\n\t}\n\t\n\tstatic void asserT(boolean e) {\n\t\tif (!e) {\n\t\t\tthrow new Error();\n\t\t}\n\t}\n\t\n\t\n\tpublic void run() {\n\t\tin = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\ttry {\n\t\t\tsolve();\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n} ", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class TaskB {\n\n    void run() {\n        FastReader in = new FastReader(System.in);\n//        FastReader in = new FastReader(new FileInputStream(\"input.txt\"));\n        PrintWriter out = new PrintWriter(System.out);\n//        PrintWriter out = new PrintWriter(new FileOutputStream(\"output.txt\"));\n\n\n        long n = in.nextLong();\n        long k = in.nextLong();\n\n        long a = 1;\n        long b = -(2 * n + 3);\n        long c = n * n + n - 2 * k;\n\n        long d = b * b - 4 * a * c;\n        long ans1 = (-b + (long) Math.sqrt(d)) / 2;\n        long ans2 = (-b - (long) Math.sqrt(d)) / 2;\n\n        if (ans1 >= 0 && ans1 <= n) {\n            out.println(ans1);\n        } else {\n            out.println(ans2);\n        }\n\n\n        out.close();\n    }\n\n    class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        Integer nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        Double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(nextLine());\n\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            String s = \"\";\n            try {\n                s = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return s;\n        }\n    }\n\n\n    public static void main(String[] args) {\n        new TaskB().run();\n    }\n}\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n    BufferedReader in;\n    StringTokenizer st;\n    PrintWriter out;\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(in.readLine());\n        return st.nextToken();\n    }\n\n    int nextInt() throws Exception {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() throws Exception {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() throws Exception {\n        return Double.parseDouble(next());\n    }\n\n    void solve() throws Exception {\n        // int min = 1;\n        // int max = 1000000000;\n        int n = nextInt();\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextInt();\n\n        Arrays.sort(a);\n\n        if (a[n - 1] == 1) {\n            for (int i = 1; i < n; i++)\n                out.print(\"1 \");\n            out.print(2);\n            return;\n        }\n\n        // a[0]=max;\n\n        Arrays.sort(a);\n        out.print(1);\n        for (int i = 1; i < n; i++)\n            out.print(\" \" + a[i-1]);\n\n    }\n\n    void run() {\n        try {\n            Locale.setDefault(Locale.US);\n            boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n            Reader reader = oj ? new InputStreamReader(System.in)\n                    : new FileReader(\"input.txt\");\n            Writer writer = oj ? new OutputStreamWriter(System.out)\n                    : new FileWriter(\"output.txt\");\n            in = new BufferedReader(reader);\n            out = new PrintWriter(writer);\n\n            solve();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static void main(String[] args) {\n        new A().run();\n\n    }\n\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class EdC {\n\tstatic long[] mods = {1000000007, 998244353, 1000000009};\n\tstatic long mod = mods[0];\n\tpublic static MyScanner sc;\n    public static PrintWriter out;\n    static char[][] grid;\n    static int n;\n    static int t;\n    static int[][] dp;\n    static int[] times;\n    static int[] genre;\n\tpublic static void main(String[] omkar) throws Exception{\n\t\t// TODO Auto-generated method stub\n \t\tsc = new MyScanner();\n \t\tout = new PrintWriter(System.out);\n \t\tn = sc.nextInt();\n \t\tt = sc.nextInt();\n \t\ttimes = new int[n];\n \t\tgenre = new int[n];\n \t\tfor(int j =0 ;j<n;j++){\n \t\t\ttimes[j] = sc.nextInt();\n \t\t\tgenre[j] = sc.nextInt();\t\t\n \t\t}\n \t\tdp = new int[1<<n][4];\n \t\tfor(int j = 0;j<1<<n;j++)\n \t\t\tArrays.fill(dp[j],  -1);\n \t\tint ans = 0;\n \t\tfor(int j=0;j<1<<n;j++){\n \t\t\tint time = 0;\n \t\t\tfor(int k = 0;k<n;k++){\n \t\t\t\tif (((1<<k) & j) != 0){\n \t\t\t\t\ttime+=times[k];\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (time == t){\n \t\t\t\tletsgodp(j, 1);\n \t\t\t\tletsgodp(j, 2);\n \t\t\t\tletsgodp(j, 3);\n \t\t\t\tans+=dp[j][1];\n \t\t\t\tans%=mod;\n \t\t\t\tans+=dp[j][2];\n \t\t\t\tans%=mod;\n \t\t\t\tans+=dp[j][3];\n \t\t\t\tans%=mod;\n \t\t\t}\n \t\t}\n \t\tout.println(ans);\n \t\tout.close();\t\n \t}\n\tpublic static void letsgodp(int mask, int dg){\n\t\tif (dp[mask][dg] != -1)\n\t\t\treturn;\n\t\tdp[mask][dg] = 0;\n\t\tfor(int j = 0;j<n;j++){\n\t\t\tif (((1<<j) & mask) != 0 && genre[j] == dg){\n\t\t\t\tint submask = mask - (1<<j);\n\t\t\t\tint og1 = genre[j]+1 > 3 ? genre[j]-2 : genre[j]+1;\n\t\t\t\tint og2 = genre[j]+2 > 3 ? genre[j]-1 : genre[j]+2;\n\t\t\t\tif (submask != 0){\n\t\t\t\t\tletsgodp(submask, og1);\n\t\t\t\t\tletsgodp(submask, og2);\n\t\t\t\t\tdp[mask][dg] +=(dp[submask][og1] + dp[submask][og2]);\n\t\t\t\t\tdp[mask][dg] %=mod;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[mask][dg] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void sort(int[] array){\n\t\tArrayList<Integer> copy = new ArrayList<Integer>();\n\t\tfor (int i : array)\n\t\t\tcopy.add(i);\n\t\tCollections.sort(copy);\n\t\tfor(int i = 0;i<array.length;i++)\n\t\t\tarray[i] = copy.get(i);\n\t}\n\tstatic String[] readArrayString(int n){\n\t\tString[] array = new String[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.next();\n\t\treturn array;\n\t}\n\tstatic int[] readArrayInt(int n){\n    \tint[] array = new int[n];\n    \tfor(int j = 0;j<n;j++)\n    \t\tarray[j] = sc.nextInt();\n    \treturn array;\n    }\n\tstatic int[] readArrayInt1(int n){\n\t\tint[] array = new int[n+1];\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tarray[j] = sc.nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\tstatic long[] readArrayLong(int n){\n\t\tlong[] array = new long[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextLong();\n\t\treturn array;\n\t}\n\tstatic double[] readArrayDouble(int n){\n\t\tdouble[] array = new double[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextDouble();\n\t\treturn array;\n\t}\n\tstatic int minIndex(int[] array){\n\t\tint minValue = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(long[] array){\n\t\tlong minValue = Long.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(double[] array){\n\t\tdouble minValue = Double.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic long power(long x, long y){\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y%2 == 1)\n\t\t\treturn (x*power(x, y-1))%mod;\n\t\treturn power((x*x)%mod, y/2)%mod;\n\t}\n\tstatic void verdict(boolean a){\n        out.println(a ? \"YES\" : \"NO\");\n    }\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try{\n                str = br.readLine();\n            } \n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n    }\t\n}\n\n//StringJoiner sj = new StringJoiner(\" \"); \n//sj.add(strings)\n//sj.toString() gives string of those stuff w spaces or whatever that sequence is", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "// https://codeforces.com/gym/307122\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport static java.lang.Math.PI;\nimport static java.lang.System.in;\nimport static java.lang.System.out;\nimport static java.lang.System.err;\n\npublic class B {\n    public static void main(String[] args) throws Exception {   \n        Foster sc = new Foster();\n        PrintWriter p = new PrintWriter(out);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        StringBuilder a = new StringBuilder(\"\");\n        StringBuilder b = new StringBuilder(\"\");\n        for(int i = 0; i < 290; i++){\n            a.append(\"5\");\n        }\n        for(int i = 0; i < 289; i++){\n            b.append(\"4\");\n        }\n        b.append(\"5\");\n        m--;\n        for(int i = 0; i < m; i++){\n            a.append(\"1\");\n        }\n        p.println(a.reverse().toString() + \" \" + b.toString());\n        p.close();\n    }\n\n    static int[] sort(int a[]){\n        ArrayList<Integer> arr = new ArrayList<>();\n        for(int i : a){\n            arr.add(i);\n        }\n        Collections.sort(arr);\n        for(int i = 0; i < arr.size(); i++){\n            a[i] = arr.get(i);\n        }\n        return a;\n    }\n    \n/* \n*/    \n/*\n1. Check overflow in pow function or in general\n2. Check indices of read array function\n3. Think of an easier solution because the problems you solve are always easy\n4. Check iterator of loop\n5. If still doesn't work, then jump from the 729th floor 'coz \"beta tumse na ho paayega\"\n\n    Move to top!!\n*/\n    static class Foster {\n        BufferedReader br = new BufferedReader(new InputStreamReader(in));\n        StringTokenizer st = new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        int[] intArray(int n) {                   // Check indices\n            int arr[] = new int[n];\n            for(int i = 0; i < n; i++) {\n                arr[i] = nextInt();\n            }\n            return arr;\n        }\n        long[] longArray(int n) {                 // Check indices\n            long arr[] = new long[n];\n            for(int i = 0; i < n; i++) {\n                arr[i] = nextLong();\n            }\n            return arr;\n        }\n        int[] getBits(int n) {                   //in Reverse Order\n            int a[] = new int[31];\n            for(int i = 0; i < 31; i++) {\n                if(((1<<i) & n) != 0)\n                    a[i] = 1;\n            }\n            return a;\n        }\n        static String reverse(String s){\n            String temp = \"\";\n            for(int i = s.length()-1; i >= 0; i--){\n                temp += s.charAt(i);\n            }\n            return temp;\n        }\n        static long pow(long... a) {\n            long mod = Long.MAX_VALUE;\n            if(a.length == 3)   mod = a[2];\n            long res = 1;\n            while(a[1] > 0) {\n                if((a[1] & 1) == 1)\n                    res = (res * a[0]) % mod;\n                a[1] /= 2;\n                a[0] = (a[0] * a[0]) % mod;\n            }\n            return res;\n        }\n        static void print(Object... o) {\n            for(Object next : o) {\n                System.err.print(next + \" \");\n            }\n        }\n        static void println(Object... o) {\n            for(Object next : o) {\n                System.err.print(next + \" \");\n            }\n            System.err.println();\n        }\n        static void watch(Object...a) throws Exception {\n            int i = 1;\n            for (Object o: a) {\n                boolean found = false;\n                if (o.getClass().isArray()) {\n                    String type = o.getClass().getName().toString();\n                    switch (type) {\n                        case \"[I\": {\n                            int[] test = (int[]) o;\n                            println(i + \" : \" + Arrays.toString(test));\n                            break;\n                        }\n                        case \"[[I\": {\n                            int[][] obj = (int[][]) o;\n                            println(i + \" : \" + Arrays.deepToString(obj));\n                            break;\n                        }\n                        case \"[J\": {\n                            long[] obj = (long[]) o;\n                            println(i + \" : \" + Arrays.toString(obj));\n                            break;\n                        }\n                        case \"[[J\": {\n                            long[][] obj = (long[][]) o;\n                            println(i + \" : \" + Arrays.deepToString(obj));\n                            break;\n                        }\n                        case \"[D\": {\n                            double[] obj = (double[]) o;\n                            println(i + \" : \" + Arrays.toString(obj));\n                            break;\n                        }\n                        case \"[[D\": {\n                            double[][] obj = (double[][]) o;\n                            println(i + \" : \" + Arrays.deepToString(obj));\n                            break;\n                        }\n                        case \"[Ljava.lang.String\": {\n                            String[] obj = (String[]) o;\n                            println(i + \" : \" + Arrays.toString(obj));\n                            break;\n                        }\n                        case \"[[Ljava.lang.String\": {\n                            String[][] obj = (String[][]) o;\n                            println(i + \" : \" + Arrays.deepToString(obj));\n                            break;\n                        }\n                        case \"[C\": {\n                            char[] obj = (char[]) o;\n                            println(i + \" : \" + Arrays.toString(obj));\n                            break;\n                        }\n                        case \"[[C\": {\n                            char[][] obj = (char[][]) o;\n                            println(i + \" : \" + Arrays.deepToString(obj));\n                            break;\n                        }\n                        default: {\n                            println(i + \" : type not identified\");\n                            break;\n                        }\n                    }\n                    found = true;\n                }\n                if (o.getClass() == ArrayList.class) {\n                    println(i + \" : LIST = \" + o);\n                    found = true;\n                }\n                if (o.getClass() == TreeSet.class) {\n                    println(i + \" : SET = \" + o);\n                    found = true;\n                }\n                if (o.getClass() == TreeMap.class) {\n                    println(i + \" : MAP = \" + o);\n                    found = true;\n                }\n                if (o.getClass() == HashMap.class) {\n                    println(i + \" : MAP = \" + o);\n                    found = true;\n                }\n                if (o.getClass() == LinkedList.class) {\n                    println(i + \" : LIST = \" + o);\n                    found = true;\n                }\n                if (o.getClass() == PriorityQueue.class) {\n                    println(i + \" : PQ = \" + o);\n                    found = true;\n                }\n                if (!found) {\n                    println(i + \" = \" + o);\n                }\n                i++;\n            }\n        }\n    }\n}", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class C {\n\tpublic static void main(String[] args) {\n\t\tnew C().run();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tboolean eof;\n\t\tString buf;\n\n\t\tpublic FastScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t\tnextToken();\n\t\t}\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(stream));\n\t\t\tnextToken();\n\t\t}\n\n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\teof = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString ret = buf;\n\t\t\tbuf = eof ? \"-1\" : st.nextToken();\n\t\t\treturn ret;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (Exception e) {\n\n\t\t\t}\n\t\t}\n\n\t\tboolean isEOF() {\n\t\t\treturn eof;\n\t\t}\n\t}\n\n\tFastScanner sc;\n\tPrintWriter out;\n\n\tpublic void run() {\n\t\tLocale.setDefault(Locale.US);\n\t\ttry {\n\t\t\tsc = new FastScanner(System.in);\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tsc.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\treturn sc.nextLong();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn sc.nextDouble();\n\t}\n\n\tint nextInt() {\n\t\treturn sc.nextInt();\n\t}\n\n\tString nextToken() {\n\t\treturn sc.nextToken();\n\t}\n\n\tstatic class Point {\n\t\tint x, y;\n\n\t\tpublic Point(int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tint dist(Point p) {\n\t\t\treturn (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tPoint p0 = new Point(nextInt(), nextInt());\n\t\tint n = nextInt();\n\t\tPoint[] p = new Point[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[i] = new Point(nextInt(), nextInt());\n\t\t}\n\t\tint[][] d = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\td[i][j] = p[i].dist(p[j]);\n\t\t\t}\n\t\t}\n\t\tint[] d0 = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td0[i] = p0.dist(p[i]);\n\t\t}\n\t\tint[] dp = new int[1 << n];\n\t\tArrays.fill(dp, 1 << 30);\n\t\tdp[0] = 0;\n\t\tint[] from = new int[1 << n];\n\t\tfor (int i = 0; i + 1 < 1 << n; i++) {\n\t\t\tint j = Integer.numberOfTrailingZeros(Integer.lowestOneBit(~i));\n\t\t\tint cnt = dp[i] + 2 * d0[j];\n\t\t\tif (dp[i ^ (1 << j)] > cnt) {\n\t\t\t\tdp[i ^ (1 << j)] = cnt;\n\t\t\t\tfrom[i ^ (1 << j)] = i;\n\t\t\t}\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\tif (((i >> k) & 1) == 0) {\n\t\t\t\t\tcnt = dp[i] + d0[j] + d0[k] + d[j][k];\n\t\t\t\t\tif (dp[i ^ (1 << j) ^ (1 << k)] > cnt) {\n\t\t\t\t\t\tdp[i ^ (1 << j) ^ (1 << k)] = cnt;\n\t\t\t\t\t\tfrom[i ^ (1 << j) ^ (1 << k)] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> ans = new ArrayList<Integer>();\n\t\tans.add(0);\n\t\tint mask = (1 << n) - 1;\n\t\twhile (mask > 0) {\n\t\t\tint xor = mask ^ from[mask];\n\t\t\twhile (xor > 0) {\n\t\t\t\tans.add(Integer\n\t\t\t\t\t\t.numberOfTrailingZeros(Integer.lowestOneBit(xor)) + 1);\n\t\t\t\txor = xor & (xor - 1);\n\t\t\t}\n\t\t\tans.add(0);\n\t\t\tmask = from[mask];\n\t\t}\n\t\tout.println(dp[(1 << n) - 1]);\n\t\tfor (int i : ans) {\n\t\t\tout.print(i + \" \");\n\t\t}\n\t}\n}", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic Main() {\n\t\tsuper();\n\t}\n\t\n\tpublic static void main(String... args) {\n\t\tMain main = new Main();\n\t\tmain.start();\n\t}\n\t\n\t\n\tpublic void start() {\n\t\tScanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint n = in.nextInt();\n\t\tint t = in.nextInt();\n\t\tHouse list[] = new House[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = in.nextInt();\n\t\t\tint a = in.nextInt();\n\t\t\tlist[i] = new House(x, a);\n\t\t}\n\t\tArrays.sort(list);\n\t\tint c = 2;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfloat d = list[i].left - list[i - 1].right;\n\t\t\tif (d == t) c++;\n\t\t\telse if (d > t) c += 2;\n\t\t}\n\t\tSystem.out.println(c);\n\t}\n}\n\n\nclass House implements Comparable<House> {\n\tpublic int x;\n\tpublic float left, right;\n\tpublic House(int x, int a) {\n\t\tthis.x = x;\n\t\tfloat h = a / 2f;\n\t\tthis.left = x - h;\n\t\tthis.right = x + h;\n\t}\n\t\n\tpublic int compareTo(House h) {\n\t\treturn this.x == h.x ? 0 : this.x < h.x ? -1 : 1;\n\t}\n\t\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\n\nimport java.io.*;\n\n\n\npublic class Spreadsheets {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint n = in.nextInt();\n\n\t\tin.nextLine();\n\n\n\n\t\twhile (n-- > 0) {\n\n\t\t\tString coord = in.nextLine();\n\n\t\t\tif (coord.matches(\"R[0-9]+C[0-9]+\")) {\n\n\t\t\t\tint c = Integer\n\n\t\t\t\t\t\t.parseInt(coord.substring(coord.indexOf('C') + 1));\n\n\t\t\t\tSystem.out.println(numToCharCoord(c)\n\n\t\t\t\t\t\t+ coord.substring(1, coord.indexOf('C')));\n\n\t\t\t} else {\n\n\t\t\t\tSystem.out.println(\"R\" + coord.replaceAll(\"\\\\D\", \"\") + \"C\"\n\n\t\t\t\t\t\t+ charToNumCoord(coord.replaceAll(\"\\\\d\", \"\")));\n\n\t\t\t}\n\n\t\t}\n\n\t\tin.close();\n\n\t}\n\n\n\n\tpublic static String numToCharCoord(int num) {\n\n\t\tString out = \"\";\n\n\t\twhile (num > 0) {\n\n\t\t\tnum--;\n\n\t\t\tout = (char) (num % 26 + 'A') + out;\n\n\t\t\tnum /= 26;\n\n\t\t}\n\n\t\treturn out;\n\n\t}\n\n\n\n\tpublic static int charToNumCoord(String str) {\n\n\t\tint num = 0;\n\n\t\tfor (int i = 0; i < str.length(); i++) {\n\n\t\t\tnum = num * 26 + (str.charAt(i) - 'A' + 1);\n\n\t\t}\n\n\t\treturn num;\n\n\t}\n\n}", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "\n\nimport java.io.*;\n\nimport java.util.*;\n\n\n\npublic class B1_2 {\n\n\tpublic static void main(String args[]) throws IOException {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\n\t\tfor (int i = 0; i < n; i ++) {\n\n\t\t\tString s = sc.next();\n\n\t\t\tif (s.matches(\"R[0-9]+C[0-9]+\")) {\n\n\t\t\t\tString ss[] = s.replaceAll(\"[R|C]\", \" \").trim().split(\" \"), r = \"\";\n\n\t\t\t\tint c = Integer.parseInt(ss[1]);\n\n\t\t\t\twhile (c > 0) {\n\n\t\t\t\t\tc --;\n\n\t\t\t\t\tr = (char) (c % 26 + 'A') + r;\n\n\t\t\t\t\tc = c / 26;\n\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(r.concat(ss[0]));\n\n\t\t\t} else {\n\n\t\t\t\tString r = s.replaceAll(\"[A-Z]\", \"\"), c = s.replaceAll(\"[0-9]\", \"\");\n\n\t\t\t\tint k = 0;\n\n\t\t\t\tfor (int j = 0; j < c.length(); j ++) {\n\n\t\t\t\t\tk = k*26 + (c.charAt(j) - 'A' + 1);\n\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(\"R\" + r + \"C\" + k);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n \n/**\n * A simple template for competitive programming problems.\n */\npublic class Solution {\n    //InputReader in = new InputReader(\"input.txt\");\n    final InputReader in = new InputReader(System.in);\n \n    final PrintWriter out = new PrintWriter(System.out);\n\n    int n,m;\n\n    void solve() {\n        n = in.nextInt();\n        m = in.nextInt();\n        int k = in.nextInt();\n\n        int[][] hor = new int[n][m-1];\n        int[][] ver = new int[n-1][m];\n\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m-1; j++) {\n                hor[i][j] = in.nextInt(); //hor[i][j]=mat[i][j] -> mat[i][j+1]\n            }\n        }\n\n        for(int i=0; i<n-1; i++) {\n            for(int j=0; j<m; j++) {\n                ver[i][j] = in.nextInt(); //ver[i][j]= mat[i][j] -> mat[i+1][j]\n            }\n        }\n\n        int[][] ans = new int[n][m];\n\n        if(k%2==1) {\n            for(int i=0; i<n; i++)\n                Arrays.fill(ans[i], -1);\n        } else {\n            for(int dummy=0; dummy<k>>1; dummy++) {\n                int[][] newAns = new int[n][m];\n                for(int i=0; i<n; i++) {\n                    Arrays.fill(newAns[i], Integer.MAX_VALUE);\n                    for(int j=0; j<m; j++) {\n                        if(isGood(i+1, j)) {\n                            newAns[i][j] = Math.min(newAns[i][j], 2*ver[i][j] + ans[i+1][j]);\n                        }\n                        if(isGood(i, j+1)) {\n                            newAns[i][j] = Math.min(newAns[i][j], 2*hor[i][j] + ans[i][j+1]);\n                        }\n                        if(isGood(i, j-1)) {\n                            newAns[i][j] = Math.min(newAns[i][j], 2*hor[i][j-1] + ans[i][j-1]);\n                        }\n                        if(isGood(i-1, j)) {\n                            newAns[i][j] = Math.min(newAns[i][j], 2*ver[i-1][j] + ans[i-1][j]);\n                        }\n                    }\n                }\n                ans = newAns;\n            }\n        }\n\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                out.print(ans[i][j] + \" \");\n            }\n            out.println();\n        }\n    }\n\n    boolean isGood(int i, int j) {\n        return i>=0 && i<n && j>=0 && j<m;\n    }\n\n    private void shuffle(int[] a) {\n        int n = a.length;\n        Random random = new Random();\n        random.nextInt();\n        for (int i = 0; i < n; i++) {\n            int change = i + random.nextInt(n - i);\n            swap(a, i, change);\n        }\n    }\n\n    private static void swap(int[] a, int i, int change) {\n        int helper = a[i];\n        a[i] = a[change];\n        a[change] = helper;\n    }\n\n    public static void main(final String[] args) throws FileNotFoundException {\n        final Solution s = new Solution();\n        final Long t1 = System.currentTimeMillis();\n        s.solve();\n        System.err.println(System.currentTimeMillis() - t1 + \" ms\");\n        s.out.close();\n    }\n\n    public Solution() throws FileNotFoundException {\n    }\n\n    private static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        Random r = new Random();\n        InputReader(final InputStream stream) {\n            this.stream = stream;\n        }\n\n        InputReader(final String fileName) {\n            InputStream stream = null;\n            try {\n                stream = new FileInputStream(fileName);\n            } catch (final FileNotFoundException e) {\n                e.printStackTrace();\n            }\n            this.stream = stream;\n        }\n\n        int[] nextArray(final int n) {\n            final int[] arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n\n        int[][] nextMatrix(final int n, final int m) {\n            final int[][] matrix = new int[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    matrix[i][j] = nextInt();\n            return matrix;\n        }\n\n        String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            final StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        String nextString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            final StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextString());\n        }\n\n        private int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (final IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        private boolean isSpaceChar(final int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(final int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n    }\n \n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "//    A Computer is Like a mischievous genie.\n//    It will give you exactly what you ask for,\n//    but not always what you want\n//    A code by Rahul Verma\n\n\nimport java.util.*;\nimport java.io.*;\n\n\npublic class Main {\n\n\n    static class Clock {\n\n        protected long start, stop;\n\n        public void start() {\n            start = System.currentTimeMillis();\n        }\n\n        public void stop() {\n            stop = System.currentTimeMillis();\n        }\n\n        public String getTime() {\n            return ((stop - start) + \" ms\");\n        }\n    }\n\n\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n    static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String[] nextSArray() {\n            String sr[] = null;\n            try {\n                sr = br.readLine().trim().split(\" \");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return sr;\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            return str;\n        }\n    }\n\n\n    static long powmodulo(long a, long p) {\n        if (p == 0) {\n            return 1 % mod;\n        }\n        if (p == 1) {\n            return a % mod;\n        }\n        long ans = 1;\n        while (p > 0) {\n            if ((p & 1) > 0) {\n                ans = (ans * a) % mod;\n            }\n            a = (a * a) % mod;\n            p = p >> 1;\n        }\n        return ans % mod;\n    }\n\n\n    static long mod = 1000000007;\n\n    static long gcd(long a, long b) {\n        if (a == 0) {\n            return b;\n        }\n        return gcd(b % a, a);\n    }\n\n    static long fast_powerNumbers(long a, long n) {\n        if (n == 1) {\n            return a;\n        }\n        long ans = fast_powerNumbers(a, n / 2);\n        if (n % 2 == 0) {\n            return (ans * ans);\n        } else {\n            return ((ans * ans) * (a));\n        }\n    }\n\n\n    static void dfs_helper(int[][] arr, int i, int j, int team, int n, int m) {\n        arr[i][j] = team;\n        if (i - 1 >= 0 && arr[i - 1][j] == 1) {\n            dfs(arr, i - 1, j, team, n, m);\n        }\n        if (j - 1 >= 0 && arr[i][j - 1] == 1) {\n            dfs(arr, i, j - 1, team, n, m);\n        }\n        if (i + 1 < n && arr[i + 1][j] == 1) {\n            dfs(arr, i + 1, j, team, n, m);\n        }\n        if (j + 1 < m && arr[i][j + 1] == 1) {\n            dfs(arr, i, j + 1, team, n, m);\n        }\n\n    }\n\n    static void dfs(int[][] arr, int i, int j, int team, int n, int m) {\n        dfs_helper(arr, i, j, team, n, m);\n\n    }\n\n\n\n    static int arr[];\n\n    static void seive(int n) {\n        arr = new int[n + 1];\n        arr[0] = arr[1] = 1;\n        for (int i = 4; i <= n; i = i + 2) {\n            arr[i] = 1;\n        }\n        for (int i = 3; i * i <= n; i = i + 2) {\n            if (arr[i] == 0) {\n                for (int j = i * i; j <= n; j = j + i) {\n                    arr[j] = 1;\n                }\n\n            }\n        }\n\n\n    }\n    static HashMap<Integer, ArrayList<Integer>>hm;\n    static int vis[];\n    static boolean cycle;\n    static ArrayList<Integer>all=new ArrayList<>();\n    static ArrayList<Integer>bll=new ArrayList<>();\n    static ArrayList<Integer>cll=new ArrayList<>();\n\n    public static void main(String[] args) throws Exception {\n        FastReader sc = new FastReader();\n\n        Clock clock = new Clock();\n        clock.start();\n\n        String s=sc.nextLine();\n        int n=s.length();\n        StringBuilder k=new StringBuilder();\n        //String k=\"\";\n        int one=0;\n        int zero=0;\n        int firstTwo=-1;\n\n        for (int i = 0; i <n ; i++) {\n            if(s.charAt(i)=='1')\n                ++one;\n            if(s.charAt(i)=='0')\n                ++zero;\n\n            if(firstTwo==-1&&s.charAt(i)=='2')\n            {\n                firstTwo=i;\n            }\n        }\n        if(firstTwo!=-1)\n        {\n           int oo=0,zz=0;\n\n            for (int i = 0; i <firstTwo ; i++) {\n                if(s.charAt(i)=='0')\n                    ++zz;\n                else\n                    ++oo;\n            }\n            StringBuilder first=new StringBuilder();\n            while(zz!=0)\n            {\n                first.append('0');\n                --zz;\n            }\n            while(oo!=0)\n            {\n                first.append('1');\n                --oo;\n            }\n            oo=0;\n            for (int i = firstTwo+1; i <n ; i++) {\n                if(s.charAt(i)=='1')\n                    ++oo;\n            }\n            StringBuilder mid=new StringBuilder();\n            while(oo!=0)\n            {\n                mid.append('1');\n                --oo;\n            }\n            for (int i = firstTwo; i <n ; i++) {\n\n                if(s.charAt(i)=='1')\n                    continue;\n                mid.append(s.charAt(i));\n            }\n            System.out.println(first.toString()+mid.toString());\n        }\n        else\n        {\n            while(zero!=0)\n            {\n                k.append('0');\n                --zero;\n            }\n            while(one!=0)\n            {\n                k.append('1');\n                --one;\n            }\n            System.out.println(k);\n\n        }\n\n\n\n    }\n}\n\n\nclass Pair {\n\n    int a;\n    int b;\n\n    Pair(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n}\n\n\nclass Graph {\n\n    HashMap<Integer, ArrayList<Integer>> hm;\n\n    Graph() {\n        hm = new HashMap<>();\n    }\n\n    Graph(int n) {\n\n        hm = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            hm.put(i, new ArrayList<Integer>());\n        }\n    }\n\n    // function for adding an edge.................................................\n    public void addEdge(int a, int b, boolean isDir) {\n        if (isDir) {\n            if (hm.containsKey(a)) {\n                hm.get(a).add(b);\n            } else {\n                hm.put(a, new ArrayList<>(Arrays.asList(b)));\n            }\n        } else {\n            if (hm.containsKey(a)) {\n                hm.get(a).add(b);\n            } else if (!hm.containsKey(a)) {\n                hm.put(a, new ArrayList<>(Arrays.asList(b)));\n            }\n\n            if (hm.containsKey(b)) {\n                hm.get(b).add(a);\n            } else if (!hm.containsKey(b)) {\n                hm.put(b, new ArrayList<>(Arrays.asList(a)));\n            }\n        }\n    }\n\n\n}\n\n\nclass DSU\n{\n    int parent[], rank[];\n    DSU(int n)\n    {\n        parent=new int[n];\n        rank=new int[n];\n        for (int i = 0; i <n ; i++) {\n            parent[i]=-1;\n            rank[i]=1;\n        }\n    }\n\n   int find(int s1)\n    {\n        if(parent[s1]==-1)\n            return s1;\n\n        parent[s1]=find(parent[s1]);\n        return parent[s1];\n    }\n\n    void unite(int s1,int s2)\n    {\n        int p1 =find(s1);\n        int p2 =find(s2);\n\n        if(p1!=p2)\n        {\n           if(rank[p1]>rank[p2])\n           {\n               parent[p2] = find(p1);\n               rank[p1]+=rank[p2];\n           }\n           else\n           {\n               parent[p1] =find(p2);\n               rank[p2]+=rank[p1];\n           }\n        }\n    }\n}\n\n// out.println(al.toString().replaceAll(\"[\\\\[|\\\\]|,]\",\"\"));\n\n", "complexity": "linear", "problem": "1009_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n    MyScanner in;\n    PrintWriter out;\n\n    public static void main(String[] args) throws Exception {\n        new C().run();\n    }\n\n    public void run() throws Exception {\n        in = new MyScanner();\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    public void solve() throws Exception {\n        int n = in.nextInt();\n        char[] a = in.next().toCharArray();\n        int h = 0;\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] == 'H') h++;\n        }\n        char[] b = new char[2 * a.length - 1];\n        for (int i = 0; i < b.length; i++) {\n            b[i] = a[i % a.length];\n        }\n        int maxh = 0;\n        int hh = 0;\n        for (int i = 0; i < b.length - h; i++) {\n            hh = 0;\n            for (int j = 0; j < h; j++) {\n                if (b[i + j] == 'H') hh++;\n            }\n            maxh = Math.max(maxh, hh);\n        }\n        /*for (int i = 0; i < b.length; i++) {\n            out.print(b[i]);\n        }\n        out.println();*/\n        //out.println(h + \" \" + maxh);\n        out.println(h - maxh);\n    }\n    class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() throws Exception {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() throws Exception {\n            if ((st == null) || (!st.hasMoreTokens())) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() throws Exception {\n            return Integer.parseInt(next());\n        }\n\n        double nextDouble() throws Exception {\n            return Double.parseDouble(next());\n        }\n\n        boolean nextBoolean() throws Exception {\n            return Boolean.parseBoolean(next());\n        }\n\n        long nextLong() throws Exception {\n            return Long.parseLong(next());\n        }\n    }\n}\n\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\n  public class Codechef\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tScanner s =new Scanner(System.in);\n\t\tint n=s.nextInt();\n\t\tint k=s.nextInt();\n\t    int r=0;\n\t    int g=0;\n\t    int b=0;\n\t    while(k*r<2*n)\n\t    r=r+1;\n\t    while(k*b<8*n)\n\t    b=b+1;\n\t    while(k*g<5*n)\n\t    g=g+1;\n\t    System.out.println(r+b+g);\n\t}\n}\n", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Lcm\n{\npublic static void main(String args[])throws Exception\n{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\nlong n=Long.parseLong(br.readLine());\nif(n<=2)\nSystem.out.println(n);\nelse\n{\n\n if(n%6==0)\n{\n System.out.println(((n-1)*(n-2)*(n-3)));\n}\n else if(n%2==0)\n{\n  System.out.println((n*(n-1)*(n-3)));\n}\nelse\n{\n  System.out.println((n*(n-1)*(n-2)));\n}\n}\n\n}\n}", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.*;\npublic class Contests {\n\n\tpublic static void main(String[] args) {\n\t\tScanner clavier=new Scanner(System.in);\n\t\tlong a=clavier.nextLong();\n\t\tclavier.close();\n\t\tif(a==1)\n\t\t\tSystem.out.println(5);\n\t\telse\n\t\t\tSystem.out.println(25);\n\t}\n\n}\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\n\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n//basically tried to understand ping's greedy alg\npublic class kMultRedo {\n\tstatic int n;\n\tstatic int k;\n\tpublic static void main(String[] args){\n\t\t\n\t\t//lol what?? If use HashSet timeout, but if use tree set, not?\n\t\t//even with super high initialize capacty = 100,000,where max 100000\n\t\tSet<Integer> set = new HashSet<Integer>(1000000);\n\t\tFastScanner s = new FastScanner();\n\t\tn = s.nextInt();\n\t\tk = s.nextInt();\n\t\t\n\t\tint[] a = new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\ta[i] = s.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\t\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(a[i]%k !=0){\n\t\t\t\tset.add(a[i]);\n\t\t\t}else{\n\t\t\t\tif(!set.contains(a[i]/k)){\n\t\t\t\t\tset.add(a[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(set.size());\n\t}\n\t\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n}\n", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Subtractions {\n    public static void main(String[] args) {\n        InputReader r = new InputReader(System.in);\n        int n = r.nextInt();\n        while (n-- > 0) {\n            int a = r.nextInt();\n            int b = r.nextInt();\n            int res = 0;\n            while (a > 0 && b > 0) {\n                if (a > b) {\n                    int div = a / b;\n                    a -= div * b;\n                    res += div;\n                } else {\n                    int div = b / a;\n                    b -= div * a;\n                    res += div;\n                }\n            }\n            System.out.println(res);\n        }\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Primes\n{\n\tstatic Scanner in = new Scanner( new BufferedReader( new InputStreamReader( System.in ) ) );\n\n\tpublic static void main( String[] args )\n\t{\n\t\tint n = in.nextInt(), k = in.nextInt(), count = 0;\n\t\tboolean[] isP = new boolean[n+1];\n\t\tfor( int i = 2; i <= n; i++ ) isP[i] = true;\n\t\tArrayList<Integer> primes = new ArrayList<Integer>();\n\t\tfor( int i = 2; i <= n; i++ ) if( isP[i] )\n\t\t{\n\t\t\tprimes.add(i);\n\t\t\tif( i <= Math.sqrt(n) ) for( int j = 2*i; j <= n; j += i ) isP[j] = false;\n\t\t}\n\t\tfor( int i = 0; i < primes.size()-1; i++ )\n\t\t{\n\t\t\tint sum = primes.get(i)+primes.get(i+1)+1;\n\t\t\tif( sum<=n && isP[sum] ) count++;\n\t\t}\n\t\tif( count>=k ) System.out.println( \"YES\" );\n\t\telse System.out.println( \"NO\" );\n\t}\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\npublic class naloga1{\n\tstatic BufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out=new PrintWriter(System.out);\n\tpublic static void main(String[] args) throws Exception{\n\t\tStringTokenizer st=new StringTokenizer(in.readLine());\n\t\tint n=Integer.parseInt(st.nextToken());\n\t\tint r=Integer.parseInt(st.nextToken());\n\t\tint[] x=new int[n];\n\t\tst=new StringTokenizer(in.readLine());\n\t\tfor(int i=0;i < n;i++){\n\t\t\tx[i]=Integer.parseInt(st.nextToken());\n\t\t}\n\t\tsim a=new sim(n,r);\n\t\tfor(int i:x) {\n\t\t\ta.add(i);\n\t\t}\n\t\tfor(double d:a.cy) {\n\t\t\tout.print(d+\" \");\n\t\t}\n\t\tout.println();\n\t\tout.close();\n\t}\n}\nclass sim{\n\tdouble[]cx;\n\tint[]ccx;\n\tdouble[]cy;\n\tint count;\n\tint n;\n\tint r;\n\tsim(int nn,int rr){\n\t\tr=rr;\n\t\tn=nn;\n\t\tcx=new double[n];\n\t\tccx=new int[n];\n\t\tcy=new double[n];\n\t\tcount=0;\n\t}\n\tvoid add(int x) {\n\t\tdouble lowest=r;\n\t\tfor(int i=0;i<count;i++) {\n\t\t\tif(Math.abs(ccx[i]-x)<=2*r) {\n\t\t\t\tdouble dy=Math.sqrt(4*r*r-(ccx[i]-x)*(ccx[i]-x));\n\t\t\t\tlowest=Math.max(lowest,cy[i]+dy);\n\t\t\t}\n\t\t}\n\t\tccx[count]=x;\n\t\tcy[count]=lowest;\n\t\tcx[count++]=x;\n\t}\n}", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Berland implements Runnable {\n    private void solve() throws IOException {\n        double a = nextInt();\n        double v = nextInt();\n        double l = nextInt();\n        double d = nextInt();\n        double w = nextInt();\n        double res;\n        if (v <= w) {                                                         \n            res = simpleCase(a, v, l, 0);\n        } else {\n            double vMax = Math.sqrt(2 * d * a);\n            if (vMax <= w) {\n                res = simpleCase(a, v, l, 0);\n            } else {\n                double tFullSpeed = v / a;\n                double tSlowdown = (v - w) / a;\n                if (a * tFullSpeed * tFullSpeed / 2 + v * tSlowdown - a * tSlowdown * tSlowdown / 2 <= d) {\n                    res = tFullSpeed + tSlowdown + (d - (a * tFullSpeed * tFullSpeed / 2 + v * tSlowdown - a * tSlowdown * tSlowdown / 2)) / v + simpleCase(a, v, l - d, w);\n                } else {\n                    double min = w;\n                    double max = v;\n                    for (int i = 0; i < 1000; ++i) {\n                        double cur = (min + max) / 2;\n                        double cFullSpeed = cur / a;\n                        double cSlowdown = (cur - w) / a;\n                        if (a * cFullSpeed * cFullSpeed / 2 + cur * cSlowdown - a * cSlowdown * cSlowdown / 2 <= d)\n                            min = cur;\n                        else\n                            max = cur;\n                    }\n                    res = min / a + (min - w) / a + simpleCase(a, v, l - d, w);\n                }\n            }\n        }\n        writer.printf(\"%.20f\\n\", res);\n    }\n\n    private double simpleCase(double a, double v, double l, double v0) {\n        double tFullSpeed = (v - v0) / a;\n        if (v0 * tFullSpeed + a * tFullSpeed * tFullSpeed / 2 <= l) {\n            return tFullSpeed + (l - (v0 * tFullSpeed + a * tFullSpeed * tFullSpeed / 2)) / v; \n        } else {\n            double min = 0;\n            double max = tFullSpeed;\n            for (int i = 0; i < 1000; ++i) {\n                double cur = (min + max) / 2;\n                if (v0 * cur + a * cur * cur / 2 <= l)\n                    min = cur;\n                else\n                    max = cur;\n            }\n            return min;\n        }\n    }\n\n\n    public static void main(String[] args) {\n        new Berland().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n}", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF387D {\n\tstatic class A {\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tint u, v, d;\n\t}\n\tstatic int INF = Integer.MAX_VALUE;\n\tstatic boolean bfs(A[] aa, int n) {\n\t\tLinkedList<Integer> q = new LinkedList<>();\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tif (aa[u].v > 0)\n\t\t\t\taa[u].d = INF;\n\t\t\telse {\n\t\t\t\taa[u].d = 0;\n\t\t\t\tq.addLast(u);\n\t\t\t}\n\t\taa[0].d = INF;\n\t\twhile (!q.isEmpty()) {\n\t\t\tint u = q.removeFirst();\n\t\t\tfor (int v : aa[u].list) {\n\t\t\t\tint w = aa[v].u;\n\t\t\t\tif (aa[w].d == INF) {\n\t\t\t\t\taa[w].d = aa[u].d + 1;\n\t\t\t\t\tif (w == 0)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tq.addLast(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic boolean dfs(A[] aa, int n, int u) {\n\t\tif (u == 0)\n\t\t\treturn true;\n\t\tfor (int v : aa[u].list) {\n\t\t\tint w = aa[v].u;\n\t\t\tif (aa[w].d == aa[u].d + 1 && dfs(aa, n, w)) {\n\t\t\t\taa[u].v = v;\n\t\t\t\taa[v].u = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\taa[u].d = INF;\n\t\treturn false;\n\t}\n\tstatic int matchings(A[] aa, int n) {\n\t\tint cnt = 0;\n\t\twhile (bfs(aa, n))\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (aa[u].v == 0 && dfs(aa, n, u))\n\t\t\t\t\tcnt++;\n\t\treturn cnt;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint m = Integer.parseInt(st.nextToken());\n\t\tint[] eu = new int[m];\n\t\tint[] ev = new int[m];\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\teu[j] = Integer.parseInt(st.nextToken());\n\t\t\tev[j] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tA[] aa = new A[n + 1];\n\t\tint min = m + n * 3;\n\t\tfor (int ctr = 1; ctr <= n; ctr++) {\n\t\t\tboolean loop = false;\n\t\t\tboolean[] ci = new boolean[n + 1];\n\t\t\tboolean[] co = new boolean[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\taa[i] = new A();\n\t\t\tint m_ = 0;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tint u = eu[j];\n\t\t\t\tint v = ev[j];\n\t\t\t\tif (u == ctr && v == ctr)\n\t\t\t\t\tloop = true;\n\t\t\t\telse if (u == ctr && v != ctr)\n\t\t\t\t\tci[v] = true;\n\t\t\t\telse if (u != ctr && v == ctr)\n\t\t\t\t\tco[u] = true;\n\t\t\t\telse {\n\t\t\t\t\taa[u].list.add(v);\n\t\t\t\t\tm_++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = loop ? 0 : 1;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tif (i != ctr) {\n\t\t\t\t\tif (!ci[i])\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\tif (!co[i])\n\t\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\tint m2 = matchings(aa, n);\n\t\t\tcnt += (m_ - m2) + (n - 1 - m2);\n\t\t\tif (min > cnt)\n\t\t\t\tmin = cnt;\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}\n", "complexity": "cubic", "problem": "0387_D", "from": "CODEFORCES", "tags": "graph matchings"}
{"src": "import java.util.*;\n \npublic class Main{\n    private static final int MAX_SIZE = 100005;\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        if(((m + 1) / 60 < a) || ((m + 1) / 60 == a && (m + 1) % 60 <= b)) {\n            out(0, 0);\n            System.exit(0);\n        }\n        for(int i = 2; i <= n; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n\n            int bb = b + 2 * m + 2;\n            int aa = a + bb / 60;\n            bb %= 60;\n\n            if((aa < x) || (aa == x && bb <= y)) {\n                b = b + m + 1;\n                a = a + b / 60;\n                b %= 60;\n                out(a, b);\n                System.exit(0);\n            }\n            a = x;\n            b = y;\n        }\n        b = b + m + 1;\n        a = a + b / 60;\n        b = b % 60;        \n        out(a, b);\n    }\n\n    private static void out(int a, int b) {\n        cout(a);\n        cout(\" \");\n        cout(b);\n    }\n\n    private static void cout(Object a) {\n        System.out.print(a);\n    }\n}", "complexity": "linear", "problem": "0967_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.*;\n\npublic class House {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint t = sc.nextInt();\n\t\tArrayList<HS> list = new ArrayList<HS>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlist.add(new HS(sc.nextInt(),sc.nextInt()));\n\t\t}\n\t\t\n\t\tCollections.sort(list);\n\t\t\n\t\tint count = 0;\n\t\t\n\t\tif(n >= 1)\n\t\t\tcount = 2;\n\t\t\n\t\tfor(int i = 0; i < list.size() - 1; i++){\n\t\t\tdouble d = Math.abs(list.get(i + 1).x - list.get(i).x);\n\t\t\td -= ((1.0*list.get(i).a/2.0) + (1.0*list.get(i + 1).a/2.0));\n\t\t\tif ((d >= t)&& ((d-t) <= 0.00000001)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse if(d > t){\n\t\t\t\tcount+= 2;\n\t\t\t} \n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}\n\nclass HS implements Comparable<HS> {\n\tpublic int x;\n\tpublic int a;\n\n\tpublic HS(int x, int a) {\n\t\tthis.x = x;\n\t\tthis.a = a;\n\t}\n\n\tpublic int compareTo(HS o) {\n\t\treturn x - o.x;\n\t}\n\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n        Scanner t=new Scanner(System.in);\n        long l=t.nextLong();\n        long r=t.nextLong();\n        if(r-l<2) System.out.println(-1);\n        else if(r-l<3 && l%2!=0){\n            if(l%3!=0) System.out.println(-1);\n            else if ((l+3)%2==0) System.out.println(-1);\n                else System.out.println(l+\" \"+(l+1)+\" \"+(l+3));\n        } else{\n            while (l%2!=0) l++;\n            System.out.println(l+\" \"+(l+1)+\" \"+(l+2));\n        }\n    }\n}", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class HamstersAndTigers\n{\n\tScanner in;\n\tPrintWriter out;\n\t\n\tHamstersAndTigers()\n\t{\n\t\tin = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t}\n\t\n\tHamstersAndTigers(String i, String o) throws FileNotFoundException\n\t{\n\t\tin = new Scanner(new File(i));\n\t\tout = new PrintWriter(new File(o));\n\t}\n\t\n\tpublic void finalize()\n\t{\n\t\tout.flush();\n\t\tin.close();\n\t\tout.close();\n\t}\n\t\n\tvoid solve()\n\t{\n\t\tint i = 0,\n\t\t\th = 0,\n\t\t\tn = in.nextInt();\n\t\t\n\t\tString buf = \"\";\n\t\tchar[] ht = in.next().toCharArray();\n\t\t\n\t\tfor(i = 0; i < n; ++i)\n\t\t\tif(ht[i] == 'H')\n\t\t\t\t++h;\n\t\t\n\t\tfor(i = 0; i < h; ++i)\n\t\t\tbuf += 'H';\n\t\t\n\t\tfor(i = 0; i < n - h; ++i)\n\t\t\tbuf += 'T';\n\t\t\n\t\tint diff = (1 << 28);\n\t\tfor(i = 0; i < n; ++i)\n\t\t{\n\t\t\tint tmp = 0;\n\t\t\t\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tif(buf.charAt(j) != ht[(i + j) % n])\n\t\t\t\t\t++tmp;\n\t\t\t\n\t\t\tdiff = Math.min(tmp, diff);\n\t\t}\n\t\t\n\t\tout.println(diff / 2);\n\t}\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException\n\t{\n\t\tHamstersAndTigers t = new HamstersAndTigers();\n\t\tt.solve();\n\t\tt.finalize();\n\t}\n}\n\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\n/**\n *\n * @author Prateep\n */\npublic class JavaApplication1 {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskB solver = new TaskB();\n    solver.solve(1, in, out);\n    out.close();\n    }\n}\n\nclass TaskB{\n    public void solve(int testNumber, InputReader in, PrintWriter out){\n        String base = in.next();\n    for (int len=base.length()-1;len>=1;len--)\n            for (int i=0;i<base.length()-len+1;i++)\n                for (int j=i+1;j<base.length()-len+1;j++)\n                    if (base.substring(i,i+len).equals(base.substring(j,j+len))){\n                        out.println(len);\n            return;\n                    }\n    out.println(0);\n    \n    }\n    \n}\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong(){\n        return Long.parseLong(next());\n    }\n    public double nextDouble(){\n        return Double.parseDouble(next());\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int d = in.nextInt();\n            int[] x = new int[n + 1];\n\n            int ans = 2;\n\n            for (int i = 1; i <= n; i++) x[i] = in.nextInt();\n\n            for (int i = 1; i < n; i++) {\n                ans += (x[i + 1] - x[i] >= 2 * d) ? (x[i + 1] - x[i] == 2 * d ? 1 : 2) : 0;\n            }\n            out.print(ans);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.*;\npublic class subtractionn {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n\t\tint t;\n\t\tt=in.nextInt();\n\t\twhile(t!=0)\n\t\t{\n\t\t\tint a=in.nextInt();\n\t\t\tint b=in.nextInt();\n\t\t\tint total=0,neww=0;\n\t\t\tif(a%b==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(a/b);\n\t\t\t}\n\t\t\telse if(b%a==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(b/a);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\twhile(a!=0 && b!=0)\n\t\t\t{\n\t\t\t\tif(a>b)\n\t\t\t\t{\n\t\t\t\t\ttotal=total+(a/b);\n\t\t\t\t\ta=a%b;\n\t\t\t\t\tif(a==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(b>a)\n\t\t\t\t{\n\t\t\t\t\ttotal=total+(b/a);\n\t\t\t\t\tb=b%a;\n\t\t\t\t\tif(b==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(total);\n\t\t\t}\n\t\tt--;\n\t\t}\n\t}\n}", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class A {\n    static int[] parent;\n\n    public static int find(int x) {\n        if (x == parent[x])\n            return x;\n        return parent[x] = find(parent[x]);\n    }\n\n    public static void union(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n        if (px != py) {\n            parent[py] = px;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int numCnt = (int) nextLong();\n        long k = nextLong();\n        parent = new int[numCnt];\n        for (int i = 0; i < parent.length; i++) {\n            parent[i] = i;\n        }\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\n        long[] ar = new long[numCnt];\n        for (int i = 0; i < numCnt; i++) {\n            ar[i] = nextLong();\n            map.put(ar[i] * 10007 + ar[i] / 13, i);\n        }\n        for (int i = 0; i < ar.length; i++) {\n            long req = ar[i] * k;\n            Integer idx=map.get(req * 10007 + req / 13);\n            if (idx!=null) {\n                union(i, idx);\n            }\n        }\n        int[] count = new int[numCnt];\n        for (int i = 0; i < parent.length; i++) {\n            count[find(i)]++;\n        }\n        int res = 0;\n        for (int i = 0; i < numCnt; i++) {\n            res += (int) ((count[i] + 1) / 2.0);\n        }\n        System.out.println(res);\n    }\n\n    static BufferedReader br = new BufferedReader(new InputStreamReader(\n            System.in));\n    static StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n    static long nextLong() throws Exception {\n        return Long.parseLong(next());\n    }\n\n    static double nextDouble() throws Exception {\n        return Double.parseDouble(next());\n    }\n\n    static String next() throws Exception {\n        while (true) {\n            if (tokenizer.hasMoreTokens()) {\n                return tokenizer.nextToken();\n            }\n            String s = br.readLine();\n            if (s == null) {\n                return null;\n            }\n            tokenizer = new StringTokenizer(s);\n        }\n    }\n}", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "import java.util.*;\nimport java.util.regex.*;\nimport java.text.*;\nimport java.math.*;\npublic class Main\n{\n    Scanner cin;\n    int []prime;\n    int top;\n    void work()\n    {\n        cin=new Scanner(System.in); \n        int n=cin.nextInt();\n        int k=cin.nextInt();\n        top=0;\n        prime=new int[2000];\n        for(int i=2;i<=n;i++)\n        {\n        \tif(isprime(i))\n        \t\tprime[top++]=i;\n        }\n        int cnt=0;\n        for(int i=0;i<top;i++)\n        {\n        \tif(cando(prime[i]))\n        \t\tcnt++;\n        }\n        if(cnt>=k) System.out.println(\"YES\");\n        else System.out.println(\"NO\");\n    }\n    boolean cando(int n)\n    {\n    \tfor(int i=0;i<top-1;i++)\n    \t{\n    \t\tif(prime[i]+prime[i+1]+1==n) return true;\n    \t}\n    \treturn false;\n    }\n    boolean isprime(int n)\n    {\n    \tfor(int i=2;i*i<=n;i++)\n    \t\tif(n%i==0)return false;\n    \treturn true;\n    }\n  public static void main(String args[]) throws Exception \n  { \n   \n   new Main().work();\n  } \n\n\n}  \n\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    private static final double EPS = 1e-11;\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer st = new StringTokenizer(\"\");\n    \n    void run() throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        \n        double a = nextDouble();\n        double v = nextDouble();\n        double l = nextDouble();\n        double d = nextDouble();\n        double w = nextDouble();\n        \n        double ans = 0.0;\n        \n        if (v < w + EPS || sqr(w) / 2 / a > d - EPS) {\n            double t1 = sqrt(2 * l / a);\n            double t2 = v / a;\n            \n            if (t1 < t2 + EPS) {\n                ans = t1;\n            } else {\n                ans = t2 + (l - a * sqr(t2) / 2) / v;\n            }\n        } else {\n            double t1 = v / a;\n            double t2 = (v - w) / a;\n            double s12 = a * sqr(t1) / 2 + w * t2 + a * sqr(t2) / 2;\n            \n            if (s12 < d + EPS) {\n                ans += t1 + t2 + (d - s12) / v;\n            } else {\n                double ta = sqrt(d / a + sqr(w / a) / 2);\n                double tb = ta - w / a;\n                ans += ta + tb;\n            }\n            \n            double r = l - d;\n            double tm = (v - w) / a;\n            double tx = (sqrt(sqr(w) + 2 * a * r) - w) / a;\n            \n            if (tx < tm + EPS) {\n                ans += tx;\n            } else {\n                ans += tm + (r - w * tm - a * sqr(tm) / 2) / v;\n            }\n        }           \n        \n        out.printf(Locale.US, \"%.12f%n\", ans);\n        out.close();\n    }\n    \n    double sqr(double x) { \n        return x * x;\n    }\n    \n    String nextToken() throws IOException {\n        while (!st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        \n        return st.nextToken();\n    }\n    \n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}\n", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.*;\n\nimport java.io.*;\nimport java.lang.reflect.Array;\n\npublic class C {\n\tFastScanner in;\n\tPrintWriter out;\n\tboolean systemIO = true;\n\n\tpublic static class Pair {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tint r = 2 * in.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor (int i = 0; i < x.length; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t}\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < y.length; i++) {\n\t\t\ty[i] = r / 2;\n\t\t}\n\t\tfor (int i = 0; i < y.length; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (Math.abs(x[i] - x[j]) == r) {\n\t\t\t\t\ty[i] = Math.max(y[i], y[j]);\n\t\t\t\t} else if (Math.abs(x[i] - x[j]) < r) {\n\t\t\t\t\ty[i] = Math.max(y[i], y[j] + Math.sqrt(r * r - (x[j] - x[i]) * (x[j] - x[i])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < y.length; i++) {\n\t\t\tout.print(y[i] + \" \");\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tif (systemIO) {\n\t\t\t\tin = new FastScanner(System.in);\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t} else {\n\t\t\t\tin = new FastScanner(new File(\"segments.in\"));\n\t\t\t\tout = new PrintWriter(new File(\"segments.out\"));\n\t\t\t}\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tFastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\treturn br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\t// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\tpublic static void main(String[] arg) {\n\t\tnew C().run();\n\t}\n}", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.SplittableRandom;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        final static int SAMPLES = 100;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            SplittableRandom splittableRandom = new SplittableRandom(System.currentTimeMillis());\n            int n = in.readInt();\n            int numQueries = in.readInt();\n            int[] a = IOUtils.readIntArray(in, n);\n            MiscUtils.decreaseByOne(a);\n            int aMax = ArrayUtils.maxElement(a);\n            Query[] queries = new Query[numQueries];\n            for (int i = 0; i < queries.length; i++) {\n                queries[i] = new Query(in.readInt() - 1, in.readInt() - 1, in.readInt(), i);\n            }\n            int blockSize = (int) Math.sqrt(n);\n            for (Query query : queries) {\n                query.BLOCK = query.left / blockSize;\n            }\n            Query[] originalQueries = queries.clone();\n            Arrays.sort(queries, new Comparator<Query>() {\n                public int compare(Query o1, Query o2) {\n                    if (o1.BLOCK != o2.BLOCK) {\n                        return Integer.compare(o1.BLOCK, o2.BLOCK);\n                    }\n                    return o1.BLOCK % 2 == 0 ? Integer.compare(o1.right, o2.right) : -Integer.compare(o1.right, o2.right);\n                }\n            });\n            int[] counts = new int[aMax + 1];\n            int leftPtr = 0, rightPtr = -1;\n            for (Query query : queries) {\n                while (leftPtr < query.left) {\n                    counts[a[leftPtr++]]--;\n                }\n                while (leftPtr > query.left) {\n                    counts[a[--leftPtr]]++;\n                }\n                while (rightPtr < query.right) {\n                    counts[a[++rightPtr]]++;\n                }\n                while (rightPtr > query.right) {\n                    counts[a[rightPtr--]]--;\n                }\n                // count * k > r - l + 1\n                int res = 1000 * 1000 * 1000;\n                for (int SAMPLE = 0; SAMPLE < SAMPLES; SAMPLE++) {\n                    int val = a[query.left + splittableRandom.nextInt(query.right - query.left + 1)];\n                    int count = counts[val];\n                    if (count * query.k > query.right - query.left + 1) {\n                        res = Math.min(res, val);\n                    }\n                }\n                if (res >= 1000 * 1000 * 1000) {\n                    query.res = -1;\n                } else {\n                    query.res = res + 1;\n                }\n            }\n            for (Query query : originalQueries) {\n                out.printLine(query.res);\n            }\n        }\n\n        class Query {\n            int left;\n            int right;\n            int k;\n            int index;\n            int BLOCK;\n            int res;\n\n            public Query(int left, int right, int k, int index) {\n                this.left = left;\n                this.right = right;\n                this.k = k;\n                this.index = index;\n            }\n        }\n    }\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n    }\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n    }\n    static interface IntReversableCollection extends IntCollection {\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public int get(int at) {\n            return data[at];\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n    }\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n        public boolean advance();\n        public boolean isValid();\n    }\n    static class ArrayUtils {\n        public static int maxElement(int[] array) {\n            return new IntArray(array).max();\n        }\n    }\n    static class MiscUtils {\n        public static void decreaseByOne(int[]... arrays) {\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i]--;\n                }\n            }\n        }\n    }\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n        public abstract void removeAt(int index);\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n    }\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n        default public int max() {\n            int result = Integer.MIN_VALUE;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                int current = it.value();\n                if (current > result) {\n                    result = current;\n                }\n            }\n            return result;\n        }\n    }\n    static interface IntCollection extends IntStream {\n        public int size();\n    }\n    static class IOUtils {\n        public static int[] readIntArray(InputReader in, int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = in.readInt();\n            }\n            return array;\n        }\n    }\n}\n\n", "complexity": "cubic", "problem": "0840_D", "from": "CODEFORCES", "tags": "data structures,probabilities"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class cf337c {\n  static long mod,n,m,k;\n  public static void main(String[] args) {\n    FastIO in = new FastIO(), out = in;\n    n = in.nextLong();\n    m = in.nextLong();\n    k = in.nextLong();\n    mod = (long)1e9 + 9;\n    long x = m - (n-n%k)/k * (k-1) - n%k;\n    if(x < 0) x = 0;\n    long ans = (pow(2,x+1)-2)*k + m-x*k;\n    ans = ((ans%mod)+mod)%mod;\n    out.println(ans);\n    out.close();\n  }\n  static long pow(long x, long p) {\n    if(p == 0) return 1%mod;\n    long ans = pow(x,p/2);\n    ans = (ans*ans)%mod;\n    if(p%2 == 1) ans = (ans*x)%mod;\n    return ans;\n  }\n  static class FastIO extends PrintWriter {\n    BufferedReader br;\n    StringTokenizer st;\n    \n    public FastIO() {\n      this(System.in,System.out);\n    }\n    public FastIO(InputStream in, OutputStream out) {\n      super(new BufferedWriter(new OutputStreamWriter(out)));\n      br = new BufferedReader(new InputStreamReader(in));\n      scanLine();\n    }\n    public void scanLine() {\n      try {\n        st = new StringTokenizer(br.readLine().trim());\n      } catch(Exception e) {\n        throw new RuntimeException(e.getMessage());\n      }\n    }\n    public int numTokens() {\n      if(!st.hasMoreTokens()) {\n        scanLine();\n        return numTokens();\n      }\n      return st.countTokens();\n    }\n    public String next() {\n      if(!st.hasMoreTokens()) {\n        scanLine();\n        return next();\n      }\n      return st.nextToken();\n    }\n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n}\n", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.util.*;\npublic class A456 {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong a = scan.nextLong();\n\t\tlong b = scan.nextLong();\n\t\tlong yel = scan.nextLong();\n\t\tlong gr = scan.nextLong();\n\t\tlong bl = scan.nextLong();\n\t\tlong sum1 = 0L, sum2 = 0L;\n\t\t\n\t\tif((long)2 * yel + gr > a)\n\t\t\tsum1 = 2 * yel + gr - a;\n\t\telse sum1 = 0;\n\t\tif((long)3 * bl + gr > b)\n\t\t\tsum2 = 3 * bl + gr - b;\n\t\telse \n\t\t\tsum2 = 0;\n\t\tSystem.out.println(sum1+sum2);\n\t}\n}", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.BigInteger;\nimport java.util.Map.Entry;\n\nimport static java.lang.Math.*;\n\npublic class C extends PrintWriter {\n\n    void run() {\n\n        int n = nextInt();\n        int r = nextInt();\n        int[] x = nextArray(n);\n\n        double[] y = new double[n];\n        Arrays.fill(y, r);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                int dx = abs(x[i] - x[j]);\n                int sdy = 4 * r * r - dx * dx;\n\n                if (sdy >= 0) {\n                    double dy = sqrt(sdy);\n                    y[i] = max(y[i], y[j] + dy);\n                }\n            }\n        }\n\n        for (double v : y) {\n            printf(Locale.ENGLISH, \"%.10f \", v);\n        }\n\n    }\n\n    boolean skip() {\n        while (hasNext()) {\n            next();\n        }\n        return true;\n    }\n\n    int[][] nextMatrix(int n, int m) {\n        int[][] matrix = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                matrix[i][j] = nextInt();\n        return matrix;\n    }\n\n    String next() {\n        while (!tokenizer.hasMoreTokens())\n            tokenizer = new StringTokenizer(nextLine());\n        return tokenizer.nextToken();\n    }\n\n    boolean hasNext() {\n        while (!tokenizer.hasMoreTokens()) {\n            String line = nextLine();\n            if (line == null) {\n                return false;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return true;\n    }\n\n    int[] nextArray(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = nextInt();\n        }\n        return array;\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException err) {\n            return null;\n        }\n    }\n\n    public C(OutputStream outputStream) {\n        super(outputStream);\n    }\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer = new StringTokenizer(\"\");\n    static Random rnd = new Random();\n    static boolean OJ;\n\n    public static void main(String[] args) throws IOException {\n        OJ = System.getProperty(\"ONLINE_JUDGE\") != null;\n        C solution = new C(System.out);\n        if (OJ) {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            solution.run();\n        } else {\n            reader = new BufferedReader(new FileReader(new File(C.class.getName() + \".txt\")));\n            long timeout = System.currentTimeMillis();\n            while (solution.hasNext()) {\n                solution.run();\n                solution.println();\n                solution.println(\"----------------------------------\");\n            }\n            solution.println(\"time: \" + (System.currentTimeMillis() - timeout));\n        }\n        solution.close();\n        reader.close();\n    }\n}", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.*;\n\nimport java.awt.geom.Point2D;\nimport java.text.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n    \n    final String filename=\"\";\n    \n    public void solve() throws Exception {\n        int n = iread(), k = iread();\n        boolean[] f = new boolean[10000];\n        int prev = -1;\n        cycle:for (int i=2; i<=n; i++)\n        {\n            for (int j=2; j*j<=i; j++)\n                if (i%j==0)\n                    continue cycle;\n            if (prev!=-1)\n                f[i+prev+1] = true;\n            if (f[i])\n                k--;\n            prev = i;\n        }\n        if (k<=0)\n            out.write(\"YES\\n\");\n        else out.write(\"NO\\n\");\n    }\n    \n    public void run() {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new BufferedWriter(new OutputStreamWriter(System.out));\n//          in = new BufferedReader(new FileReader(filename+\".in\"));\n//          out = new BufferedWriter(new FileWriter(filename+\".out\"));\n            solve();\n            out.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n    \n    public int iread() throws Exception {\n        return Integer.parseInt(readword());\n    }\n\n    public double dread() throws Exception {\n        return Double.parseDouble(readword());\n    }\n\n    public long lread() throws Exception {\n        return Long.parseLong(readword());\n    }\n\n    BufferedReader in;\n\n    BufferedWriter out;\n\n    public String readword() throws IOException {\n        StringBuilder b = new StringBuilder();\n        int c;\n        c = in.read();\n        while (c >= 0 && c <= ' ')\n            c = in.read();\n        if (c < 0)\n            return \"\";\n        while (c > ' ') {\n            b.append((char) c);\n            c = in.read();\n        }\n        return b.toString();\n    }\n    public static void main(String[] args) {\n        try{\n            Locale.setDefault(Locale.US);\n        } catch (Exception e)\n        {\n            \n        }\n        new Thread(new Main()).start();\n        //new Thread(null, new Main(), \"1\", 1<<25).start();\n    }\n}", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tstatic int[][][]memo;\n\tstatic int inf=(int)1e9;\n\tstatic int n,m,down[][],right[][];\n\tstatic int dp(int i,int j,int k) {\n\t\tif(k<=0)return 0;\n\t\tif(memo[i][j][k]!=-1)return memo[i][j][k];\n\t\tint ans=inf;\n\t\tif(i+1<n) {\n\t\t\tans=Math.min(ans, down[i][j]+dp(i+1, j, k-1));\n\t\t}\n\n\t\tif(i-1>=0) {\n\t\t\tans=Math.min(ans, down[i-1][j]+dp(i-1, j, k-1));\n\t\t}\n\n\t\tif(j+1<m) {\n\t\t\tans=Math.min(ans, right[i][j]+dp(i, j+1, k-1));\n\t\t}\n\n\t\tif(j-1>=0) {\n\t\t\tans=Math.min(ans, right[i][j-1]+dp(i, j-1, k-1));\n\t\t}\n\t\treturn memo[i][j][k]=ans;\n\t}\n\tstatic void main() throws Exception{\n\t\tn=sc.nextInt();m=sc.nextInt();int k=sc.nextInt();\n\t\tif((k&1)==1) {\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tpw.print((-1)+\" \");\n\t\t\t\t}\n\t\t\t\tpw.println();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tk>>=1;\n\t\tright=new int[n][];\n\t\tdown=new int[n-1][];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tright[i]=sc.intArr(m-1);\n\t\t}\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tdown[i]=sc.intArr(m);\n\t\t}\n\t\tmemo = new int[n][m][k+1];\n\t\tint inf=(int)1e9;\n\t\tfor(int i=0;i<=k;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tfor(int o=0;o<m;o++) {\n\t\t\t\t\tmemo[j][o][i]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tpw.print((dp(i, j, k)<<1)+\" \");\n\t\t\t}\n\t\t\tpw.println();\n\t\t}\n    }\n    public static void main(String[] args) throws Exception{\n    \tsc=new MScanner(System.in);\n    \tpw = new PrintWriter(System.out);\n        int tc=1;\n//        tc=sc.nextInt();\n        for(int i=1;i<=tc;i++) {\n//            pw.printf(\"Case #%d:\", i);\n            main();\n        }\n        pw.flush();\n    }\n    static PrintWriter pw;\n    static MScanner sc;\n    static class MScanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public MScanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n     \n        public MScanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n     \n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        public int[] intArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public long[] longArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public int[] intSortedArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public long[] longSortedArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public Integer[] IntegerArr(int n) throws IOException {\n            Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public Long[] LongArr(int n) throws IOException {\n            Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n     \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n     \n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n     \n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n     \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n     \n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n     \n        public void waitForInput() throws InterruptedException {\n            Thread.sleep(3000);\n        }\n        \n    }\n    static void sort(int[]in) {\n    \tshuffle(in);\n        Arrays.sort(in);\n    }\n    static void sort(long[]in) {\n    \tshuffle(in);\n        Arrays.sort(in);\n    }\n    static void shuffle(int[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            int tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n    static void shuffle(long[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            long tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\nimport java.math.*;\n\npublic class Main {        \n\n    void run() throws IOException {\n        int n = nint();\n        char[] s = token().toCharArray();\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == 'H') h++;\n        }\n        int r = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            int t = 0;\n            for (int j = i; j < i + h; j++) {\n                if (s[j % n] == 'T') t++;\n            }\n            r = min(r, t);\n        }\n        out.println(r);\n    }\n\n    class pair implements Comparable <pair> {\n        int x, y;\n        pair(int x, int y) {\n            this.x = x;\n            this.y = y;            \n        }\n        public int compareTo (pair p) {\n            if (x != p.x) {\n                return x - p.x;\n            } else {\n                return y - p.y;\n            }\n        }\n    }\n\n//    static PrintWriter out;\n  //  static Scanner in;\n\n    public static void main(String[] args) throws IOException {\n        Locale.setDefault(Locale.US);\n        //final String FILENAME = \"jury\"; in = new Scanner (new File (FILENAME + \".in\")); out = new PrintWriter (new File(FILENAME + \".out\"));\n    //    in = new Scanner (System.in); out = new PrintWriter (System.out);\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        st = new StringTokenizer(\" \");\n        new Main().run();\n        /*out = new PrintWriter (System.out);\n        final int NUMBER_OF_TESTS = 35;\n        for (int i = 1; i <= NUMBER_OF_TESTS; i++) {\n            Scanner test = new Scanner (new File (\"tests/\" + i + \".in\"));\n            Scanner right = new Scanner (new File (\"tests/\" + i + \".out\"));\n            String get_right = right.nextLine();\n            String get_test = new Main().run(test);\n            if (get_right.equals(get_test)) {\n                out.println(\"Test #\" + i + \": \" + \"OK!\");                \n            } else {\n                out.println(\"Test #\" + i + \": \" + \"ERROR!\");\n                out.println(\"Expected: \" + get_right);\n                out.println(\"Received: \" + get_test);\n                break;\n            }\n        }*/\n        out.close();\n    }\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer st;\n\n    String token() throws IOException {\n        while (!st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nint() throws IOException {\n        return Integer.parseInt(token());\n    }\n\n    long nlong() throws IOException {\n        return Long.parseLong(token());\n    }\n\n    double ndouble() throws IOException {\n        return Double.parseDouble(token());\n    }\n}", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int k = scanner.nextInt();\n        if (k % 2 == 1) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    System.out.print(\"-1 \");\n                }\n                System.out.println();\n            }\n            return;\n        }\n        k /= 2;\n        int[][][] dp = new int[n][m][2];\n        int[][] h = new int[n][m];\n        int[][] v = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m - 1; j++) {\n                h[i][j] = scanner.nextInt();\n            }\n        }\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < m; j++) {\n                v[i][j] = scanner.nextInt();\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            for (int a = 0; a < n; a++) {\n                for (int b = 0; b < m; b++) {\n                    int t = Integer.MAX_VALUE;\n                    if (a != n - 1) t = Math.min(t, dp[a + 1][b][1 - i % 2] + v[a][b] * 2);\n                    if (a != 0) t = Math.min(t, dp[a - 1][b][1 - i % 2] + v[a - 1][b] * 2);\n                    if (b != m - 1) t = Math.min(t, dp[a][b + 1][1 - i % 2] + h[a][b] * 2);\n                    if (b != 0) t = Math.min(t, dp[a][b - 1][1 - i % 2] + h[a][b - 1] * 2);\n                    dp[a][b][i % 2] = t;\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                System.out.print(dp[i][j][1 - k % 2] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\n\npublic class IQTest\n{\n    public static void main(String[] args)\n    {\n        try\n        {\n            BufferedReader in = new BufferedReader(\n                new InputStreamReader(System.in));\n            String str = in.readLine();\n            int n = Integer.parseInt(str);\n            int odd = -1, even = -1, odds = 0, evens = 0;\n            //while (n-- > 0)\n            //{\n                str = in.readLine();\n                String[] numbers = str.split(\" \");\n                int index = 1;\n                for (String number: numbers)\n                {\n                    int i = Integer.parseInt(number);\n                    if (i % 2 == 0)\n                    {\n                        ++evens;\n                        if (even == -1)\n                            even = index;\n                    }\n                    else\n                    {\n                        ++odds;\n                        if (odd == -1)\n                            odd = index;\n                    }\n                    ++index;\n                }\n            //}\n            \n            System.out.println((evens > odds ? odd : even));\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n}", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author John Martin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        ASubtractions solver = new ASubtractions();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ASubtractions {\n        public void solve(int testNumber, InputReader c, OutputWriter w) {\n            int tc = c.readInt();\n            while (tc-- > 0) {\n                int a = c.readInt(), b = c.readInt();\n                int res = 0;\n                while (a != 0 && b != 0) {\n                    res += b / a;\n                    b = b % a;\n                    int t = b;\n                    b = a;\n                    a = t;\n                }\n                w.printLine(res);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class IfAtFirst {\n    void solve() {\n        int a = in.nextInt(), b = in.nextInt(), c = in.nextInt(), n = in.nextInt();\n        \n        if (c > a || c > b || a + b - c + 1 > n) {\n            out.println(-1);\n            return;\n        }\n        \n        out.println(n - (a + b - c));\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new IfAtFirst().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "/**\n * Created by IntelliJ IDEA.\n * User: Taras_Brzezinsky\n * Date: 8/14/11\n * Time: 9:53 PM\n * To change this template use File | Settings | File Templates.\n */\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.FileReader;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class Fish extends Thread {\n\n    public Fish() {\n        this.input = new BufferedReader(new InputStreamReader(System.in));\n        this.output = new PrintWriter(System.out);\n        this.setPriority(Thread.MAX_PRIORITY);\n    }\n\n    static int getOnes(int mask) {\n        int result = 0;\n        while (mask != 0) {\n            mask &= mask - 1;\n            ++result;\n        }\n        return result;\n    }\n\n    private void solve() throws Throwable {\n        int n = nextInt();\n        double[][] a = new double[n][n];\n        double[] dp = new double[(1 << n)];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                a[i][j] = nextDouble();\n            }\n        }\n        int limit = (1 << n) - 1;\n        //dp[mask] = probability of current subset (mask) to remain in the end\n        dp[limit] = 1.0;\n        for (int mask = limit; mask > 0; --mask) {\n            int cardinality = getOnes(mask);\n            int probability = cardinality * (cardinality - 1) / 2;\n            for (int first = 0; first < n; ++first) {\n                if ((mask & powers[first]) != 0) {\n                    for (int second = first + 1; second < n; ++second) {\n                        if ((mask & powers[second]) != 0) {\n                            dp[mask - powers[first]] += dp[mask] * a[second][first] / probability;\n                            dp[mask - powers[second]] += dp[mask] * a[first][second] / probability;\n                        }\n\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            output.printf(\"%.10f \", dp[powers[i]]);\n        }\n    }\n\n    public void run() {\n        try {\n            solve();\n        } catch (Throwable e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace();\n            System.exit(666);\n        } finally {\n            output.flush();\n            output.close();\n        }\n    }\n\n\n    public static void main(String[] args) {\n        new Fish().start();\n    }\n\n    private String nextToken() throws IOException {\n        while (tokens == null || !tokens.hasMoreTokens()) {\n            tokens = new StringTokenizer(input.readLine());\n        }\n        return tokens.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    static final int powers[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144};\n    private BufferedReader input;\n    private PrintWriter output;\n    private StringTokenizer tokens = null;\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.*;\n\npublic class ed817Q3 {\n\tpublic static void main(String[] args){\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = 1;\n\t\tfor(int zxz=0;zxz<t;zxz++){\n\t\t\t// my code starts here\n\t\t\tlong n = in.nextLong();\n\t\t\tlong s = in.nextLong();\n\t\t\tlong start=s,end=n;\n\t\t\tlong ans=n+1;\n\t\t\twhile(start<=end){\n\t\t\t\tlong mid = start+(end-start)/2;\n\t\t\t\tif(mid-digitSum(mid)>=s){\n\t\t\t\t\tans = mid;\n\t\t\t\t\tend = mid-1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstart=mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(n-ans+1);\n\t\t\t// my code ends here\n\t\t}\n\t}\n\tstatic int digitSum(long n){\n\t\tint sum=0;\n\t\twhile(n>0){\n\t\t\tsum+=n%10;\n\t\t\tn=n/10;\n\t\t}\n\t\treturn sum;\n\t}\n\tstatic class InputReader {\n\t\t \n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n \n        public int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public long nextLong() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n \n        public String readString() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n\npublic class Main {\n    static int bit[];\n    static int array[];\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        bit = new int[1505];\n        array = new int[n + 1];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for(int i = 1;i <= n;i++)\n            array[i] = Integer.parseInt(st.nextToken());\n        long ans = 0;\n        for(int i = n;i >= 1;i--){\n            ans += read(array[i]);\n            update(array[i]);\n        }\n        long val = (ans & 1) + 1000_000;\n        int m = Integer.parseInt(br.readLine());\n        StringBuilder sb = new StringBuilder();\n        for(int i = 1;i <= m;i++){\n            st = new StringTokenizer(br.readLine());\n            int l = Integer.parseInt(st.nextToken());\n            int r = Integer.parseInt(st.nextToken());\n            long temp = (r - l + 1);\n            temp = temp*(temp - 1) / 2;\n            if((temp & 1) == 1)--val;\n            if((val & 1) == 1)sb.append(\"odd\");\n            else sb.append(\"even\");\n            sb.append('\\n');\n        }\n        System.out.print(sb);\n    }\n    static int update(int idx){\n        int sum = 0;\n        while(idx < 1501){\n            bit[idx] += 1;\n            idx += idx & (-idx);\n        }\n        return sum;\n    }\n    static int read(int idx){\n        int sum = 0;\n        while(idx > 0){\n            sum += bit[idx];\n            idx -= idx & (-idx);\n        }\n        return sum;\n    }\n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Main\n{\n\tpublic static void main(String args[]) throws IOException\n\t{\n\t\tScanner sc = new Scanner(System.in);\n                int n = sc.nextInt(), k = sc.nextInt(), kol = 0, prev;\n                boolean ok;\n                ArrayList<Integer> al = new ArrayList<Integer>();\n                al.add(2);\n                prev = 2;\n                for(int i=3;i<=n;i+=2)\n                {\n                \tok = true;\n                \tfor(Integer x: al) \n                \tif (i%x == 0)\n                \t{\n                \t\tok = false;\n                \t\tbreak;\n                \t}\n                \tif (ok) \n                \t{\n                \t\tfor(Integer x: al)\n                \t\tif (ok) \n                \t\t{\n                \t\t\tprev = x; \n                \t\t\tok = false;\n                \t\t} else\n                \t\t{\n\t                \t\tif (x + prev + 1 == i) \n\t                \t\t{\n\t                \t\t\tkol++;\n\t                \t\t\tbreak;\n\t                \t\t}\n\t                \t\tif (x + prev + 1 > i) break;\n\t                \t\tprev = x;\n                \t\t}\n                \t\tal.add(i);\n                \t}\n                }\n                if (kol >= k) System.out.print(\"YES\"); else System.out.print(\"NO\");\n\t}\n}", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class r584p5 {\n    private static BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n    private static PrintWriter pw = new PrintWriter(System.out);\n    private static int n, m, arr[][];\n    private static ArrayList<HashSet<Integer>> chls;\n\n    private static void gench(){\n        chls.add(new HashSet<>());\n        chls.get(0).add(0);\n\n        for(int i=1; i<(1<<n); i++){\n            int des = i^Integer.highestOneBit(i);\n            HashSet<Integer> st = new HashSet<>();\n            for(int z : chls.get(des)){\n                st.add(z);\n                st.add(z|Integer.highestOneBit(i));\n            }\n            chls.add(st);\n        }\n    }\n\n    private static void cal(){\n        int val[][] = new int[(1<<n)][m];\n\n        for(int j=0; j<m; j++){\n            val[0][j] = 0;\n            for(int mask=1; mask<(1<<n); mask++){\n                int max = 0;\n                for(int begin=0; begin<n; begin++){\n                    int sum = 0;\n                    for(int ptr=begin, pos=0; pos<n; ptr=(ptr+1)%n, pos++){\n                        if((mask&(1<<pos)) > 0)\n                            sum += arr[ptr][j];\n                    }\n                    max = Math.max(max, sum);\n                }\n                val[mask][j] = max;\n            }\n        }\n\n        int dp[][] = new int[(1<<n)][m];\n\n        for(int mask=0; mask<(1<<n); mask++)\n            dp[mask][0] = val[mask][0];\n\n        for(int j=1; j<m; j++){\n            dp[0][j] = 0;\n            for(int mask=1; mask<(1<<n); mask++){\n\n                dp[mask][j] = 0;\n                for(int ch1 : chls.get(mask)){\n                    int ch2 = mask^ch1;\n\n                    dp[mask][j] = Math.max(dp[mask][j], val[ch1][j]+dp[ch2][j-1]);\n                }\n            }\n        }\n\n        pw.println(dp[(1<<n)-1][m-1]);\n    }\n\n    private static void run()throws IOException{\n        StringTokenizer tk = new StringTokenizer(r.readLine());\n        n = Integer.parseInt(tk.nextToken());\n        m = Integer.parseInt(tk.nextToken());\n        arr = new int[n][m];\n        chls = new ArrayList<>();\n\n        for(int i=0; i<n; i++){\n            tk = new StringTokenizer(r.readLine());\n            for(int j=0; j<m; j++)\n                arr[i][j] = Integer.parseInt(tk.nextToken());\n        }\n\n        gench();\n        cal();\n    }\n\n    public static void main(String args[])throws IOException{\n        int t = Integer.parseInt(r.readLine());\n\n        while(t-->0)\n            run();\n\n        pw.flush();\n        pw.close();\n    }\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n    private static int MOD = 1000000007;\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String s = reader.readLine();\n        char[] arr = s.toCharArray();\n        int k = Integer.parseInt(reader.readLine());\n        if (k==0) {\n            System.out.println(1);\n            System.exit(0);\n        }\n        int[] operations = new int[1001];\n        for (int i=2; i<=1000; i++) {\n            int ones = 0;\n            char[] a = Integer.toBinaryString(i).toCharArray();\n            for (char elem:a) {\n                if (elem=='1') ones++;\n            }\n            operations[i] = operations[ones] + 1;\n        }\n        int n = arr.length;\n        if (n<=10 && Integer.parseInt(s, 2)<=1000) {\n            int x = Integer.parseInt(s, 2);\n            int res = 0;\n            for (int i=0; i<=x; i++) {\n                if (operations[i]==k) res++;\n            }\n            System.out.println(res);\n        } else {\n            ArrayList<Integer> list = new ArrayList<>();\n            for (int i=1; i<=1000; i++) {\n                if (operations[i]==k-1) list.add(i);\n            }\n            int[][] matr = new int[n+1][n+1];\n            for (int i=0; i<=n; i++) {\n                matr[i][0] = matr[i][i] = 1;\n                if (i==0) continue;\n                for (int j=1; j<=n; j++) {\n                    matr[i][j] = (matr[i-1][j-1] + matr[i-1][j]) % MOD;\n                }\n            }\n            int res = 0;\n            for (int y=1; y<n; y++) {\n                for (int x:list) {\n                    if (x>y) break;\n                    if (y==1 && x==1) continue;\n                    res = (res + matr[y-1][x-1]) % MOD;\n                }\n            }\n            int amount = 1;\n            for (int i=1; i<n; i++) {\n                if (arr[i]=='1') {\n                    int y = n - i - 1;\n                    for (int x:list) {\n                        if (x-amount>y) break;\n                        if (x-amount<0) continue;\n                        res = (res + matr[y][x-amount]) % MOD;\n                    }\n                    amount++;\n                }\n            }\n            if (list.contains(amount)) res = (res + 1) % MOD;\n            System.out.println(res);\n        }\n    }\n}", "complexity": "linear", "problem": "0914_C", "from": "CODEFORCES", "tags": "brute force,combinatorics,dp"}
{"src": "/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.text.*;\n\npublic class cf287b {\n\n    static BufferedReader br;\n    static Scanner sc;\n    static PrintWriter out;\n\n    public static void initA() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            //br = new BufferedReader(new FileReader(\"input.txt\"));\n            sc = new Scanner(System.in);\n            //out = new PrintWriter(\"output.txt\");\n            out = new PrintWriter(System.out);\n        } catch (Exception e) {\n        }\n    }\n\n    static boolean next_permutation(Integer[] p) {\n        for (int a = p.length - 2; a >= 0; --a) {\n            if (p[a] < p[a + 1]) {\n                for (int b = p.length - 1;; --b) {\n                    if (p[b] > p[a]) {\n                        int t = p[a];\n                        p[a] = p[b];\n                        p[b] = t;\n                        for (++a, b = p.length - 1; a < b; ++a, --b) {\n                            t = p[a];\n                            p[a] = p[b];\n                            p[b] = t;\n                        }\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void initB() {\n        try {\n\n            br = new BufferedReader(new FileReader(\"input.txt\"));\n            sc = new Scanner(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n\n        } catch (Exception e) {\n        }\n    }\n\n    public static String getString() {\n        try {\n            return br.readLine();\n        } catch (Exception e) {\n        }\n        return \"\";\n    }\n\n    public static Integer getInt() {\n        try {\n            return Integer.parseInt(br.readLine());\n        } catch (Exception e) {\n        }\n        return 0;\n    }\n\n    public static Integer[] getIntArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            Integer temp2[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = Integer.parseInt(temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static Long[] getLongArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            Long temp2[] = new Long[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = Long.parseLong(temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static String[] getStringArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            String temp2[] = new String[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = (temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static int getMax(Integer[] ar) {\n        int t = ar[0];\n        for (int i = 0; i < ar.length; i++) {\n            if (ar[i] > t) {\n                t = ar[i];\n            }\n        }\n        return t;\n    }\n\n    public static void print(Object a) {\n        out.println(a);\n    }\n\n    public static void print(String s, Object... a) {\n        out.printf(s, a);\n    }\n\n    public static int nextInt() {\n        return sc.nextInt();\n    }\n\n    public static double nextDouble() {\n        return sc.nextDouble();\n    }\n\n    public static void main(String[] ar) {\n        initA();\n        solve();\n        out.flush();\n    }\n\n    public static void solve() {\n        Long xx[] = getLongArr();\n        long n = xx[0];\n        long k = xx[1];\n        \n        if(n==1){\n            print(0);\n            return;\n        }\n\n        long nah = k - 2;\n        if ( getSum(k,2) - nah < n) {\n            print(-1);\n            return;\n        }\n        \n        long l=2, r=k;\n        while(l!=r){\n            long mid = (l+r+1)/2;\n            long jml_output =getSum(k,mid)- (k-mid);\n            //print(mid+\"=\"+getSum(k,mid)+\"-\"+(k-mid)+\"=\"+jml_output);\n            if(jml_output>=n){\n                l= mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        print(k-l+1);\n    }\n    static long getSum(long n,long k){\n        long nah = n-k+1;\n      \n        /*\n        if(nah%2==0){\n            return (k+2)*(nah/2);\n        }else{\n            \n            return (k+2)*(nah/2) + (k+2)/2;\n        }\n         * \n         */\n       return ((n + k) * (nah / 2)) + (nah % 2 > 0 ? (n + k) / 2 : 0);\n    }\n}\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.OutputStream;\n\nimport java.io.FileOutputStream;\n\nimport java.io.IOException;\n\nimport java.io.FileInputStream;\n\nimport java.io.InputStream;\n\nimport java.io.PrintWriter;\n\nimport java.io.OutputStream;\n\nimport java.util.Arrays;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.io.File;\n\nimport java.io.FileNotFoundException;\n\nimport java.util.StringTokenizer;\n\nimport java.io.Writer;\n\nimport java.io.BufferedReader;\n\nimport java.io.FileReader;\n\nimport java.io.InputStream;\n\n\n\n/**\n\n * Built using CHelper plug-in\n\n * Actual solution is at the top\n\n * @author zodiacLeo\n\n */\n\npublic class Main\n\n{\n\n    public static void main(String[] args)\n\n    {\n\n        InputStream inputStream;\n\n        try\n\n        {\n\n            inputStream = new FileInputStream(\"input.txt\");\n\n        } catch (IOException e)\n\n        {\n\n            throw new RuntimeException(e);\n\n        }\n\n        OutputStream outputStream;\n\n        try\n\n        {\n\n            outputStream = new FileOutputStream(\"output.txt\");\n\n        } catch (IOException e)\n\n        {\n\n            throw new RuntimeException(e);\n\n        }\n\n        FastScanner in = new FastScanner(inputStream);\n\n        FastPrinter out = new FastPrinter(outputStream);\n\n        TaskC solver = new TaskC();\n\n        solver.solve(1, in, out);\n\n        out.close();\n\n    }\n\n\n\n    static class TaskC\n\n    {\n\n        private final static int[] dx = {-1, 0, +1, 0};\n\n        private final static int[] dy = {0, +1, 0, -1};\n\n        private final static int WHITE = 123456789;\n\n\n\n        public void solve(int testNumber, FastScanner in, FastPrinter out)\n\n        {\n\n            int n = in.nextInt();\n\n            int m = in.nextInt();\n\n\n\n            int[][] map = new int[n][m];\n\n            for (int i = 0; i < n; i++)\n\n            {\n\n                Arrays.fill(map[i], WHITE);\n\n            }\n\n\n\n            int k = in.nextInt();\n\n\n\n            int qh = 0;\n\n            int qt = 0;\n\n            int[] q = new int[((int) 7e6)];\n\n            for (int i = 0; i < k; i++)\n\n            {\n\n                int x = in.nextInt() - 1;\n\n                int y = in.nextInt() - 1;\n\n                map[x][y] = 0;\n\n                q[qh++] = x * m + y;\n\n            }\n\n\n\n            int d = 0;\n\n            int X = q[0] / m;\n\n            int Y = q[0] % m;\n\n            while (qt < qh)\n\n            {\n\n                int pos = q[qt++];\n\n                int x = pos / m;\n\n                int y = pos % m;\n\n                for (int i = 0; i < 4; i++)\n\n                {\n\n                    int xx = x + dx[i];\n\n                    int yy = y + dy[i];\n\n                    if (isValid(xx, n) && isValid(yy, m) && map[xx][yy] == WHITE)\n\n                    {\n\n                        map[xx][yy] = map[x][y] + 1;\n\n                        q[qh++] = (xx * m) + yy;\n\n                        if (d < map[xx][yy])\n\n                        {\n\n                            d = map[xx][yy];\n\n                            X = xx;\n\n                            Y = yy;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n//        for (int i = 0; i < n; i++)\n\n//        {\n\n//            for (int j = 0; j < m; j++)\n\n//            {\n\n//                out.print(map[i][j] + \" \");\n\n//            }\n\n//            out.println();\n\n//        }\n\n            out.println((X + 1) + \" \" + (Y + 1));\n\n        }\n\n\n\n        private boolean isValid(int x, int X)\n\n        {\n\n            return x >= 0 && x < X;\n\n        }\n\n\n\n    }\n\n\n\n    static class FastScanner\n\n    {\n\n        public BufferedReader br;\n\n        public StringTokenizer st;\n\n\n\n        public FastScanner(InputStream is)\n\n        {\n\n            br = new BufferedReader(new InputStreamReader(is));\n\n        }\n\n\n\n        public FastScanner(File f)\n\n        {\n\n            try\n\n            {\n\n                br = new BufferedReader(new FileReader(f));\n\n            } catch (FileNotFoundException e)\n\n            {\n\n                e.printStackTrace();\n\n            }\n\n        }\n\n\n\n        public String next()\n\n        {\n\n            while (st == null || !st.hasMoreElements())\n\n            {\n\n                String s = null;\n\n                try\n\n                {\n\n                    s = br.readLine();\n\n                } catch (IOException e)\n\n                {\n\n                    e.printStackTrace();\n\n                }\n\n                if (s == null)\n\n                    return null;\n\n                st = new StringTokenizer(s);\n\n            }\n\n            return st.nextToken();\n\n        }\n\n\n\n        public int nextInt()\n\n        {\n\n            return Integer.parseInt(next());\n\n        }\n\n\n\n    }\n\n\n\n    static class FastPrinter extends PrintWriter\n\n    {\n\n        public FastPrinter(OutputStream out)\n\n        {\n\n            super(out);\n\n        }\n\n\n\n        public FastPrinter(Writer out)\n\n        {\n\n            super(out);\n\n        }\n\n\n\n    }\n\n}\n\n\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class test3 {\n\tstatic class point{\n\t\tint i;int j;\n\t\tpoint(int i,int  j){\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t}\n\t}\nstatic long mod = (int)10e9 +7;\n\tpublic static void main(String[] args) throws  IOException {\n\t\tFastReader f = new FastReader();\n\t\tint n = f.nextInt();\n\t\tint u = f.nextInt();\n\t\tint e[] = new int[n];\n\t\tTreeSet<Integer> ts = new TreeSet<Integer>();\n\t\tfor(int i =0;i<n;i++) {\n\t\t\te[i] =f.nextInt();\n\t\t\tts.add(e[i]);\n\t\t}\n\t\tdouble max = -1;\n\t\tfor(int i = 0;i<n-2;i++) {\n\t\t\tint k = ts.lower(e[i]+u+1);\n\t\t\tif(e[i]==k||e[i+1]==k)continue;\n\t\t\tmax =Math.max(max, (k-e[i+1])/(double)(k-e[i]));\n\t\t}\n\t\tSystem.out.println(max);\n    }\n\n\tstatic boolean isPrime(int n)\n    {\n \n        // Check if number is less than\n        // equal to 1\n        if (n <= 1)\n            return false;\n \n        // Check if number is 2\n        else if (n == 2)\n            return true;\n \n        // Check if n is a multiple of 2\n        else if (n % 2 == 0)\n            return false;\n \n        // If not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\t\n\tstatic void print(int x,int y,int d,int n) {\n\t\tint i = 0;\n\t\tSystem.out.print(x+\" \"+y+\" \");\n\t\t\tfor(int j = x+d;j<y;j+=d) {\n\t\t\t\tSystem.out.print(j+\" \");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor(int j = x-d;j>0;j-=d) {\n\t\t\t\tif(i==n)return;\n\t\t\t\tSystem.out.print(j+\" \");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor(int j = y+d;j<1000000000;j+=d) {\n\t\t\t\tif(i==n)return;\n\t\t\t\tSystem.out.print(j+\" \");\n\t\t\t\ti++;\n\t\t\t}\n\t}\n\n\tstatic int prime(int n){\n\t    int ret = 0;\n\t    while(n%2==0){\n\t        ret++;\n\t        n/=2;\n\t    }\n\t    for(int i=3;i<=Math.sqrt(n);i+=2){\n\t        while(n%i==0){\n\t            ret++;\n\t            n/=i;\n\t        }\n\t    }\n\t    if(n>2)ret++;\n\t    return ret;\n\t}\n\tstatic long nCr(int n, int r) \n\t{ if(n<r) {\n\t\treturn 0;\n\t} \n\t    long[] C=new long[r+1]; \n\t    C[0] = 1; \n\t    for (int i = 1; i <= n; i++) \n\t    {  \n\t        for (int j = Math.min(i, r); j > 0; j--) \n\t            C[j] = (C[j] + C[j-1]); \n\t    } \n\t    return C[r]; \n\t}\n\tstatic int power(int a,int n, int p)\n    {\n        int res = 1;\n        a = a % p; \n        while (n > 0)\n        {\n            if ((n & 1) == 1)\n                res = (res * a) % p;\n            n = n >> 1; \n            a = (a * a) % p;\n        }\n        return res;\n    }\n    static boolean isPrime(int n, int k)\n    {\n    if (n <= 1 || n == 4) return false;\n    if (n <= 3) return true;\n    while (k > 0)\n    {\n        int a = 2 + (int)(Math.random() % (n - 4)); \n        if (power(a, n - 1, n) != 1)\n            return false;\n     \n        k--;\n        }\n     \n        return true;\n    }\n\t  static long GCD(long a,long b) {\n\t\t  if(a%b==0)return b;\n\t\t  else return GCD(b,a%b);\n\t  }\n\t\tstatic ArrayList<Integer> readArray(FastReader f,int size){\n\t\t\tArrayList<Integer> ret = new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<size;i++) {\n\t\t\t\tret.add(f.nextInt());\n\t\t\t}return ret;\n\t\t}\n\t static class FastReader \n\t    { \n\t        BufferedReader br; \n\t        StringTokenizer st; \n\t        public FastReader() \n\t        { \n\t            br = new BufferedReader(new\n\t                     InputStreamReader(System.in)); \n\t        } \n\t        String next() \n\t        { \n\t            while (st == null || !st.hasMoreElements()) \n\t            { \n\t                try\n\t                { \n\t                    st = new StringTokenizer(br.readLine()); \n\t                } \n\t                catch (IOException  e) \n\t                { \n\t                    e.printStackTrace(); \n\t                } \n\t            } \n\t            return st.nextToken(); \n\t        } \n\t        int nextInt() \n\t        { \n\t            return Integer.parseInt(next()); \n\t        } \t  \n\t        long nextLong() \n\t        { \n\t            return Long.parseLong(next()); \n\t        } \n\t        double nextDouble() \n\t        { \n\t            return Double.parseDouble(next()); \n\t        } \n\t        String nextLine() \n\t        { \n\t            String str = \"\"; \n\t            try\n\t            { \n\t                str = br.readLine(); \n\t            } \n\t            catch (IOException e) \n\t            { \n\t                e.printStackTrace(); \n\t            } \n\t            return str; \n\t        } \n\t    }\n\t \n\n }\n\n\n\n", "complexity": "nlogn", "problem": "0957_C", "from": "CODEFORCES", "tags": "binary search,greedy,math,two pointers"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class B {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FS in;\n\t\n\tstatic int N;\n\tstatic final boolean debug = false;\n\tstatic int inp[] = new int[] {1,2,3,2,1,0};\n\tpublic static void main(String[] args) {\n\t\tin = new FS();\n\t\tif(!debug) N = in.nextInt();\n\t\telse N = inp.length;\n\t\tint x = solve(0, N/2-1, N/2, N-1);\n\t\tout.println(\"! \"+(x+1));\n\t\tout.flush();\n\t\tout.close();\n\t}\n\t\n\tstatic int solve(int l1, int r1, int l2, int r2) {\n\t\tint sz = r1-l1+1;\n\t\tif(sz <= 0) return -2;\n\t\tint a1 = query(l1);\n\t\tint a2 = query(l2);\n\t\tif(a1 == a2) return l1;\n\t\t\n\t\tif(sz == 1) return -2;\n\t\t\n\t\tint b1 = query(l1+sz/2);\n\t\tint b2 = query(l2+sz/2);\n\t\tif(b1 == b2) return l1 + sz/2;\n\t\t\n\t\tif(sz == 2) return -2;\n\t\t\n\t\tint d1 = a2-a1;\n\t\tint d2 =  b2-b1;\n\t\tif((d1 < 0 && d2 > 0) || (d1 > 0 && d2 < 0)) {\n\t\t\treturn solve(l1+1, l1 + sz/2 - 1, l2+1, l2 + sz/2 - 1);\n\t\t}\n\t\telse {\n\t\t\treturn solve(l1 + sz/2 + 1, r1, l2 + sz/2 + 1, r2);\n\t\t}\n\t}\n\t\n\tstatic int query(int a) {\n\t\tout.println(\"? \"+(a+1));\n\t\tout.flush();\n\t\tif(debug) return inp[a];\n\t\telse return in.nextInt();\n\t}\n\t\n\tstatic class FS{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FS() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {\n\t\t\twhile(st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\t\tcatch(Exception e) { throw null;}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() { return Integer.parseInt(next());}\n\t\tdouble nextDouble() { return Double.parseDouble(next());}\n\t\tlong nextLong() { return Long.parseLong(next());}\n\t\tint[] NIA(int n) {\n\t\t\tint r[] = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) r[i] = nextInt();\n\t\t\treturn r;\n\t\t}\n\t\tlong[] NLA(int n) {\n\t\t\tlong r[] = new long[n];\n\t\t\tfor(int i = 0; i < n; i++) r[i] = nextLong();\n\t\t\treturn r;\n\t\t}\n\t\tchar[][] grid(int r, int c){\n\t\t\tchar res[][] = new char[r][c];\n\t\t\tfor(int i = 0; i < r; i++) {\n\t\t\t\tchar l[] = next().toCharArray();\n\t\t\t\tfor(int j = 0; j < c; j++) {\n\t\t\t\t\tres[i][j] = l[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n}\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "import java.io.*;\nimport java.util.*;\n \nimport java.math.*;\nimport java.awt.Point;\n \npublic class Main {\n    static final long MOD = 1000000007L;\n    //static final long MOD2 = 1000000009L;\n    //static final long MOD = 998244353L;\n    //static final long INF = 500000000000L;\n    static final int INF =   1000000005;\n    static final int NINF = -1000000005;\n    //static final long NINF = -1000000000000000000L;\n    static FastScanner sc;\n    static PrintWriter pw;\n    static final int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};\n \n \n    static final int MO = 1200;\n    \n    public static void main(String[] args) {\n        sc = new FastScanner();\n        pw = new PrintWriter(System.out);\n\n        int N = sc.ni();\n        int M = sc.ni();\n        int K = sc.ni();\n        int[][] LR = new int[N][M-1];\n        for (int i = 0; i < N; i++) {\n            LR[i] = sc.intArray(M-1,0);\n        }\n        int[][] UD = new int[N-1][M];\n        for (int i = 0; i < N-1; i++) {\n            UD[i] = sc.intArray(M,0);\n        }\n\n        if (K%2==0) {\n            int T = K/2;\n            int[][] dist = new int[N][M];\n\n            for (int step = 1; step <= T; step++) {\n                int[][] newDist = new int[N][M];\n                for (int i = 0; i < N; i++) {\n                    for (int j = 0; j < M; j++) {\n                        newDist[i][j] = INF;\n\n                        //up\n                        if (i > 0) {\n                            newDist[i][j] = Math.min(newDist[i][j],UD[i-1][j]+dist[i-1][j]);\n                        }\n\n                        //down\n                        if (i < N-1) {\n                            newDist[i][j] = Math.min(newDist[i][j],UD[i][j]+dist[i+1][j]);\n                        }\n\n                        //left\n                        if (j > 0) {\n                            newDist[i][j] = Math.min(newDist[i][j],LR[i][j-1]+dist[i][j-1]);\n                        }\n\n                        //right\n                        if (j < M-1) {\n                            newDist[i][j] = Math.min(newDist[i][j],LR[i][j]+dist[i][j+1]);\n                        }\n                    }\n                }\n                dist = newDist;\n            }\n            \n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < M; j++) {\n                    pw.print((2*dist[i][j]) + \" \");\n                }\n                pw.println();\n            }\n        } else {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < M; j++) {\n                    pw.print(\"-1 \");\n                }\n                pw.println();\n            }\n        }\n        pw.close();\n    }\n \n    public static void sort(int[] arr) {\n        Random rgen = new Random();\n        for (int i = 0; i < arr.length; i++) {\n            int r = rgen.nextInt(arr.length);\n            int temp = arr[i];\n            arr[i] = arr[r];\n            arr[r] = temp;\n        }\n        Arrays.sort(arr);\n    }\n \n    public static void sort(long[] arr) {\n        Random rgen = new Random();\n        for (int i = 0; i < arr.length; i++) {\n            int r = rgen.nextInt(arr.length);\n            long temp = arr[i];\n            arr[i] = arr[r];\n            arr[r] = temp;\n        }\n        Arrays.sort(arr);\n    }\n \n    //Sort an array (immune to quicksort TLE)\n    public static void sort(int[][] arr) {\n        Random rgen = new Random();\n        for (int i = 0; i < arr.length; i++) {\n            int r = rgen.nextInt(arr.length);\n            int[] temp = arr[i];\n            arr[i] = arr[r];\n            arr[r] = temp;\n        }\n        Arrays.sort(arr, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] a, int[] b) {\n                int ablock = a[0]/MO;\n                int bblock = b[0]/MO;\n                if (ablock != bblock)\n                    return ablock-bblock;\n                else\n                    return a[1]-b[1];\n            }\n        });\n    }\n    \n    public static void sort(long[][] arr) {\n        Random rgen = new Random();\n        for (int i = 0; i < arr.length; i++) {\n            int r = rgen.nextInt(arr.length);\n            long[] temp = arr[i];\n            arr[i] = arr[r];\n            arr[r] = temp;\n        }\n        Arrays.sort(arr, new Comparator<long[]>() {\n            @Override\n            public int compare(long[] a, long[] b) {\n                if (a[0] > b[0])\n                    return 1;\n                else if (a[0] < b[0])\n                    return -1;\n                else\n                    return 0;\n                //Ascending order.\n            }\n        });\n    }\n \n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in), 32768);\n            st = null;\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int ni() {\n            return Integer.parseInt(next());\n        }\n \n        int[][] graph(int N, int[][] edges) {\n            int[][] graph = new int[N][];\n            int[] sz = new int[N];\n            for (int[] e: edges) {\n                sz[e[0]] += 1;\n                sz[e[1]] += 1;\n            }\n            for (int i = 0; i < N; i++) {\n                graph[i] = new int[sz[i]];\n            }\n            int[] cur = new int[N];\n            for (int[] e: edges) {\n                graph[e[0]][cur[e[0]]] = e[1];\n                graph[e[1]][cur[e[1]]] = e[0];\n                cur[e[0]] += 1;\n                cur[e[1]] += 1;\n            }\n            return graph;\n        }\n \n        int[] intArray(int N, int mod) {\n            int[] ret = new int[N];\n            for (int i = 0; i < N; i++)\n                ret[i] = ni()+mod;\n            return ret;\n        }\n \n        long nl() {\n            return Long.parseLong(next());\n        }\n \n        long[] longArray(int N, long mod) {\n            long[] ret = new long[N];\n            for (int i = 0; i < N; i++)\n                ret[i] = nl()+mod;\n            return ret;\n        }\n \n        double nd() {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.function.BiFunction;\n\npublic class Main{\n\tstatic Scanner scn = new Scanner(System.in);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Mathplus mp = new Mathplus();\n\tstatic PrintWriter ot = new PrintWriter(System.out);\n\tstatic Random rand = new Random();\n\tstatic int mod = 1000000007;\n\tstatic long inf = (long)1e17;\n\tstatic int[] dx = {0,1,0,-1};\n\tstatic int[] dy = {1,0,-1,0};\n\tstatic int max;\n\tpublic static void main(String[] args) {\t\n\t\t\n\t\tint N = sc.nextInt();\n\t\tArrayList<Integer>[] l = new ArrayList[N];\n\t\tHashMap<Long,Integer> map = new HashMap<Long,Integer>();\n\t\tlong sum = 0;\n\t\tlong[] s = new long[N];\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tl[i] = new ArrayList<Integer>();\n\t\t\tint n = sc.nextInt();\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tmap.put((long)a, i);\n\t\t\t\ts[i] += a;\n\t\t\t\tsum += a;\n\t\t\t\tl[i].add(a);\n\t\t\t}\n\t\t}\n\t\tif(Math.abs(sum)%N!=0) {\n\t\t\tSystem.out.println(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tlong make = sum/N;\n\t\tboolean[] dp = new boolean[(1<<N)];\n\t\tint[] first = new int[(1<<N)];\n\t\tint[] bef = new int[(1<<N)];\n\n\t\tArrays.fill(first,mod);\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tfor(int a:l[i]) {\n\t\t\t\tint used = 0;\n\t\t\t\tboolean f = true;\n\t\t\t\tlong now = a;\n\t\t\t\tint see = i;\n\t\t\t\twhile(true) {\n\t\t\t\t\tlong next = make-(s[see]-now);\n\t\t\t\t\t\n\t\t\t\t\tif(next==a) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!map.containsKey(next)) {\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tint k = map.get(next);\n\t\t\t\t\t\tif(mp.contains(used,k)&&k!=i) {\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tused = mp.bitadd(used,k);\n\t\t\t\t\t\t\tnow = next;\n\t\t\t\t\t\t\tsee = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f) {\n\t\t\t\t\tdp[mp.bitadd(used,i)] = true;\n\t\t\t\t\tfirst[mp.bitadd(used,i)] = a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[0] = true;\n\t\tfor(int i=1;i<(1<<N);i++) {\n\t\t\tfor(int j=i;j>0;j=(j-1)&i) {\n\t\t\t\tif(dp[i^j]&&dp[j]) {\n\t\t\t\t\tdp[i]=true;\n\t\t\t\t\tbef[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!dp[(1<<N)-1]) {\n\t\t\tSystem.out.println(\"NO\");\n\t\t}else {\n\t\t\tSystem.out.println(\"YES\");\n\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\tint[] ans1 = new int[N];\n\t\t\tint[] ans2 = new int[N];\n\t\t\tq.add((1<<N)-1);\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tint Q = q.poll();\n\t\t\t\tif(first[Q]==mod) {\n\t\t\t\t\tq.add(bef[Q]);\n\t\t\t\t\tq.add(Q^bef[Q]);\n\t\t\t\t}else {\n\t\t\t\t\t\n\t\t\t\t\tint a = first[Q];\n\t\t\t\t\tlong now = a;\n\t\t\t\t\tint befo = map.get((long)a);\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tlong next = make-(s[befo]-now);\n\t\t\t\t\t\tif(next==a) {\n\t\t\t\t\t\t\tint k = map.get(next);\n\t\t\t\t\t\t\tans1[k] = (int)next;\n\t\t\t\t\t\t\tans2[k] = befo;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint k = map.get(next);\n\t\t\t\t\t\tans1[k] = (int)next;\n\t\t\t\t\t\tans2[k] = befo;\n\t\t\t\t\t\tnow = next;\n\t\t\t\t\t\tbefo = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<N;i++) {\n\t\t\t\tSystem.out.println(ans1[i]+\" \"+(ans2[i]+1));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\n\t\n\t}\n\t\n}\nclass GridGraph extends Graph{\n\t\n\tint N;\n\tint M;\n\tString[] S;\n\tHashMap<Character,Integer> map;\n\tGridGraph(int n,int m,String[] s,char[] c){\n\t\tsuper(n*m);\n\t\tN = n;\n\t\tM = m;\n\t\tS = s;\n\t\tmap = new HashMap<Character,Integer>();\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tif(S[i].charAt(j)!='#'&&S[i+1].charAt(j)!='#') {\n\t\t\t\t\taddEdge(toint(i,j),toint(i+1,j));\n\t\t\t\t\taddEdge(toint(i+1,j),toint(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m-1;j++) {\n\t\t\t\tif(S[i].charAt(j)!='#'&&S[i].charAt(j+1)!='#') {\n\t\t\t\t\taddEdge(toint(i,j),toint(i,j+1));\n\t\t\t\t\taddEdge(toint(i,j+1),toint(i,j));\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tfor(int k=0;k<c.length;k++) {\n\t\t\t\t\tif(S[i].charAt(j)==c[k])map.put(c[k],toint(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint toint(int i,int j) {\n\t\treturn i*M+j;\n\t}\n\t\n}\n\nclass BetterGridGraph{\n\tint N;\n\tint M;\n\tchar[][] S;\n\tHashMap<Character,Integer> map;\n\tint[] dx = {0,1,0,-1};\n\tint[] dy = {1,0,-1,0};\n\tchar w;\n\tchar b = '#';\n\tBetterGridGraph(int n,int m,String[] s,char[] c){\n\t\t\n\t\tN = n;\n\t\tM = m;\n\t\tfor(int i=0;i<s.length;i++) {\n\t\t\tS[i] = s[i].toCharArray();\n\t\t}\n\t\tmap = new HashMap<Character,Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tfor(int k=0;k<c.length;k++) {\n\t\t\t\t\tif(S[i][j]==c[k])map.put(c[k],toint(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tBetterGridGraph(int n,int m,char[][] s,char[] c){\n\t\t\n\t\tN = n;\n\t\tM = m;\n\t\tS = s;\n\t\tmap = new HashMap<Character,Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tfor(int k=0;k<c.length;k++) {\n\t\t\t\t\tif(S[i][j]==c[k])map.put(c[k],toint(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tBetterGridGraph(int n,int m,String[] s,char[] c,char W,char B){\n\t\t\n\t\tN = n;\n\t\tM = m;\n\t\tfor(int i=0;i<s.length;i++) {\n\t\t\tS[i] = s[i].toCharArray();\n\t\t}\n\t\tw = W;\n\t\tb = B;\n\t\tmap = new HashMap<Character,Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tfor(int k=0;k<c.length;k++) {\n\t\t\t\t\tif(S[i][j]==c[k])map.put(c[k],toint(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tBetterGridGraph(int n,int m,char[][] s,char[] c,char W,char B){\n\t\t\n\t\tN = n;\n\t\tM = m;\n\t\tS = s;\n\t\tw = W;\n\t\tb = B;\n\t\tmap = new HashMap<Character,Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tfor(int k=0;k<c.length;k++) {\n\t\t\t\t\tif(S[i][j]==c[k])map.put(c[k],toint(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint toint(int i,int j) {\n\t\treturn i*M+j;\n\t}\n\t\n\tint[] bfs(char C) {\n\t\tint s = map.get(C);\n\t\tint[] L = new int[N*M];\n\t\tfor(int i=0;i<N*M;i++){\n\t\t\tL[i] = -1;\n\t\t}\n\t\tL[s] = 0;\n\t\tArrayDeque<Integer> Q = new ArrayDeque<Integer>();\n\t\tQ.add(s);\n\t\tRange X = new Range(0,N-1);\n\t\tRange Y = new Range(0,M-1);\n\t\twhile(!Q.isEmpty()){\n\t\t\tint v = Q.poll();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint x = v/M;\n\t\t\t\tint y = v%M;\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(X.isIn(nx)&&Y.isIn(ny)&&S[nx][ny]!=b) {\n\t\t\t\t\tint w = toint(nx,ny);\n\t\t\t\t\tif(L[w]==-1){\n\t\t\t\t\t\tL[w] = L[v] + 1;\n\t\t\t\t\t\tQ.add(w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn L;\n\t}\n\t\n\tint[][] bfs2(char C,int K){\n\t\tint s = map.get(C);\n\t\tint[][] L = new int[N*M][K+1];\n\t\tfor(int i=0;i<N*M;i++){\n\t\t\tfor(int j=0;j<=K;j++)\n\t\t\tL[i][j] = 1000000007;\n\t\t}\n\t\tL[s][0] = 0;\n\t\tArrayDeque<IntIntPair> Q = new ArrayDeque<IntIntPair>();\n\t\tQ.add(new IntIntPair(s,0));\n\t\tRange X = new Range(0,N-1);\n\t\tRange Y = new Range(0,M-1);\n\t\twhile(!Q.isEmpty()){\n\t\t\tIntIntPair v = Q.poll();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint x = v.a/M;\n\t\t\t\tint y = v.a%M;\n\t\t\t\tint h = v.b;\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(X.isIn(nx)&&Y.isIn(ny)&&S[nx][ny]!=b) {\n\t\t\t\t\tint ni = toint(nx,ny);\n\t\t\t\t\tint nh = S[nx][ny]==w?h+1:h;\n\t\t\t\t\tif(nh>K) continue;\n\t\t\t\t\tif(L[ni][nh]==1000000007){\n\t\t\t\t\t\tL[ni][nh] = L[v.a][h] + 1;\n\t\t\t\t\t\tQ.add(new IntIntPair(ni,nh));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N*M;i++) {\n\t\t\tfor(int j=1;j<=K;j++) {\n\t\t\t\tL[i][j] = Math.min(L[i][j],L[i][j-1]);\n\t\t\t}\n\t\t}\n\t\treturn L;\n\t}\n}\n\nclass StringManager{\n\tArrayList<Character> S;\n\tstatic Mathplus mp;\n\tstatic boolean calced;\n\tstatic int base;\n\tstatic long baserev;\n\tArrayList<Long> l;\n\tStringManager(String s){\n\t\tS = new ArrayList<Character>();\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tS.add(s.charAt(i));\n\t\t}\n\t\tif(!calced) {\n\t\t\tcalced = true;\n\t\t\tmp = new Mathplus();\n\t\t\tbase = 1000003;\n\t\t\tbaserev = mp.rev(base);\n\t\t\tmp.buildpow(base,1000050);\n\t\t\tmp.buildrevpow((int) baserev,1000050);\n\n\t\t}\n\t\tl = new ArrayList<Long>();\n\n\t\tl.add((long)S.get(0));\n\n\t\tfor(int i=1;i<S.size();i++) {\n\t\t\tchar c = S.get(i);\n\t\t\tl.add((l.get(i-1) + mp.pow[i] * c)%mp.mod);\n\n\t\t}\n\t}\n\tvoid add(char C){\n\t\tint i = S.size();\n\t\tS.add(C);\n\t\tl.add((l.get(i-1) + mp.pow[i] * C)%mp.mod);\n\t}\n\tlong gethash(int le,int ri) {\n\t\tlong res = l.get(ri);\n\t\tif(le!=0) {\n\t\t\tres -= l.get(le-1);\n\t\t\tres += mp.mod;\n\t\t\tres %= mp.mod;\n\t\t\tres *= mp.revpow[le];\n\t\t\tres %= mp.mod;\n\t\t}\n\t\treturn res;\n\t}\n\n\n}\n\n\nclass Trie{\n\tint nodenumber = 1;\n\tArrayList<TrieNode> l;\n\tTrie(){\n\t\tl = new ArrayList<TrieNode>();\n\t\tl.add(new TrieNode());\n\t}\n\n\tvoid add(String S,int W){\n\t\tint now = 0;\n\t\tfor(int i=0;i<S.length();i++) {\n\t\t\tTrieNode n = l.get(now);\n\t\t\tchar c = S.charAt(i);\n\t\t\tif(n.Exist[c-'a']!=-1) {\n\t\t\t\tnow = n.Exist[c-'a'];\n\t\t\t}else {\n\t\t\t\tl.add(new TrieNode());\n\t\t\t\tn.Exist[c-'a'] = nodenumber;\n\t\t\t\tnow = nodenumber;\n\t\t\t\tnodenumber++;\n\t\t\t}\n\t\t}\n\t\tl.get(now).weight = W;\n\t}\n\n\tvoid find(String S,int i,int[] dp) {\n\t\tint now = 0;\n\t\tdp[i+1] = Math.max(dp[i],dp[i+1]);\n\t\tfor(int j=0;;j++) {\n\t\t\tTrieNode n = l.get(now);\n\t\t\tdp[i+j] = Math.max(dp[i+j],dp[i]+n.weight);\n\t\t\tint slook = i+j;\n\t\t\tif(slook>=S.length())return;\n\t\t\tchar c = S.charAt(slook);\n\t\t\tif(n.Exist[c-'a']==-1)return;\n\t\t\tnow = n.Exist[c-'a'];\n\t\t}\n\t}\n}\n\nclass TrieNode{\n\n\tint[] Exist = new int[26];\n\tint weight = 0;\n\tTrieNode(){\n\t\tfor(int i=0;i<26;i++) {\n\t\t\tExist[i] = -1;\n\t\t}\n\t}\n}\n\nclass SizeComparator implements Comparator<Edge>{\n\tint[] size;\n\tSizeComparator(int[] s) {\n\t\tsize = s;\n\t}\n\n\tpublic int compare(Edge o1, Edge o2) {\n\t\treturn size[o1.to]-size[o2.to];\n\n\t}\n\n}\n\nclass ConvexHullTrick {\n\tlong[] A, B;\n\tint len;\n\n\tpublic ConvexHullTrick(int n) {\n\t\tA = new long[n];\n\t\tB = new long[n];\n\t}\n\n\tprivate boolean check(long a, long b) {\n\t\treturn (B[len - 2] - B[len - 1]) * (a - A[len - 1]) >= (B[len - 1] - b) * (A[len - 1] - A[len - 2]);\n\t}\n\n\tpublic void add(long a, long b) {\n\t\twhile (len >= 2 && check(a, b)) {\n\t\t\tlen--;\n\t\t}\n\t\tA[len] = a;\n\t\tB[len] = b;\n\t\tlen++;\n\t}\n\n\tpublic long query(long x) {\n\t\tint l = -1, r = len - 1;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (r + l) / 2;\n\t\t\tif (get(mid,x)>=get(mid+1,x)) {\n\t\t\t\tl = mid;\n\t\t\t} else {\n\t\t\t\tr = mid;\n\t\t\t}\n\t\t}\n\t\treturn get(r,x);\n\t}\n\n\tprivate long get(int k, long x) {\n\t\treturn A[k] * x + B[k];\n\t}\n}\n\nclass Range{\n\tint l;\n\tint r;\n\tint length;\n\tRange(int L,int R){\n\t\tl = L;\n\t\tr = R;\n\t\tlength = R-L+1;\n\t}\n\n\tboolean isIn(int x) {\n\t\treturn (l<=x&&x<=r);\n\n\t}\n}\nclass LeftComparator implements Comparator<Range>{\n\tpublic int compare(Range P, Range Q) {\n\t\treturn P.l-Q.l;\n\t}\n}\nclass RightComparator implements Comparator<Range>{\n\tpublic int compare(Range P, Range Q) {\n\t\treturn P.r-Q.r;\n\t}\n}\nclass LengthComparator implements Comparator<Range>{\n\tpublic int compare(Range P, Range Q) {\n\t\treturn P.length-Q.length;\n\t}\n}\nclass SegmentTree<T,E>{\n\tint N;\n\tBiFunction<T,T,T> f;\n\tBiFunction<T,E,T> g;\n\tT d1;\n\tArrayList<T> dat;\n\tSegmentTree(BiFunction<T,T,T> F,BiFunction<T,E,T> G,T D1,T[] v){\n\t\tint n = v.length;\n\t\tf = F;\n\t\tg = G;\n\t\td1 = D1;\n\t\tinit(n);\n\t\tbuild(v);\n\t}\n\n\n\tvoid init(int n) {\n\t\tN = 1;\n\t\twhile(N<n)N*=2;\n\t\tdat = new ArrayList<T>();\n\t}\n\n\tvoid build(T[] v) {\n\t\tfor(int i=0;i<2*N;i++) {\n\t\t\tdat.add(d1);\n\t\t}\n\t\tfor(int i=0;i<v.length;i++) {\n\t\t\tdat.set(N+i-1,v[i]);\n\t\t}\n\t\tfor(int i=N-2;i>=0;i--) {\n\t\t\tdat.set(i,f.apply(dat.get(i*2+1),dat.get(i*2+2)));\n\t\t}\n\t}\n\n\tvoid update(int k,E a) {\n\t\tk += N-1;\n\t\tdat.set(k,g.apply(dat.get(k),a));\n\t\twhile(k>0){\n\t\t\tk = (k-1)/2;\n\t\t\tdat.set(k,f.apply(dat.get(k*2+1),dat.get(k*2+2)));\n\t\t}\n\t}\n\n\tT query(int a,int b, int k, int l ,int r) {\n\t\tif(r<=a||b<=l) return d1;\n\t\tif(a<=l&&r<=b) return dat.get(k);\n\t\tT vl = query(a,b,k*2+1,l,(l+r)/2);\n\t\tT vr = query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn f.apply(vl, vr);\n\t}\n\tT query(int a,int b){\n\t\treturn query(a,b,0,0,N);\n\t}\n\n}\n\nclass LazySegmentTree<T,E> extends SegmentTree<T,E>{\n\tBiFunction<E,E,E> h;\n\tBiFunction<E,Integer,E> p = (E a,Integer b) ->{return a;};\n\tE d0;\n\tArrayList<E> laz;\n\tLazySegmentTree(BiFunction<T,T,T> F,BiFunction<T,E,T> G,BiFunction<E,E,E> H,T D1,E D0,T[] v){\n\t\tsuper(F,G,D1,v);\n\t\tint n = v.length;\n\t\th = H;\n\t\td0 = D0;\n\t\tInit(n);\n\t}\n\tvoid build() {\n\n\t}\n\tvoid Init(int n){\n\t\tlaz = new ArrayList<E>();\n\t\tfor(int i=0;i<2*N;i++) {\n\t\t\tlaz.add(d0);\n\t\t}\n\t}\n\n\tvoid eval(int len,int k) {\n\t\tif(laz.get(k).equals(d0)) return;\n\t\tif(k*2+1<N*2-1) {\n\t\t\tlaz.set(k*2+1,h.apply(laz.get(k*2+1),laz.get(k)));\n\t\t\tlaz.set(k*2+2,h.apply(laz.get(k*2+2),laz.get(k)));\n\t\t}\n\t\tdat.set(k,g.apply(dat.get(k), p.apply(laz.get(k), len)));\n\t\tlaz.set(k,d0);\n\t}\n\n\tT update(int a,int b,E x,int k,int l,int r) {\n\t\teval(r-l,k);\n\t\tif(r<=a||b<=l) {\n\t\t\treturn dat.get(k);\n\t\t}\n\t\tif(a<=l&&r<=b) {\n\t\t\tlaz.set(k,h.apply(laz.get(k),x));\n\t\t\treturn g.apply(dat.get(k),p.apply(laz.get(k),r-l));\n\t\t}\n\t\tT vl = update(a,b,x,k*2+1,l,(l+r)/2);\n\t\tT vr = update(a,b,x,k*2+2,(l+r)/2,r);\n\t\tdat.set(k,f.apply(vl,vr));\n\t\treturn dat.get(k);\n\n\t}\n\n\tT update(int a,int b,E x) {\n\t\treturn update(a,b,x,0,0,N);\n\t}\n\n\tT query(int a,int b,int k,int l,int r) {\n\t\teval(r-l,k);\n\t\tif(r<=a||b<=l) return d1;\n\t\tif(a<=l&&r<=b) return dat.get(k);\n\n\t\tT vl = query(a,b,k*2+1,l,(l+r)/2);\n\t\tT vr = query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn f.apply(vl, vr);\n\t}\n\n\tT query(int a,int b){\n\t\treturn query(a,b,0,0,N);\n\t}\n\n}\n\nclass AddSumSegmentTree{\n\tint N;\n\tint d1;\n\tArrayList<Integer> dat;\n\tAddSumSegmentTree(int[] v){\n\t\tint n = v.length;\n\t\tinit(n);\n\t\tbuild(v);\n\t}\n\n\tvoid init(int n) {\n\t\tN = 1;\n\t\twhile(N<n)N*=2;\n\t\tdat = new ArrayList<Integer>();\n\t}\n\n\tvoid build(int[] v) {\n\t\tfor(int i=0;i<2*N;i++) {\n\t\t\tdat.add(d1);\n\t\t}\n\t\tfor(int i=0;i<v.length;i++) {\n\t\t\tdat.set(N+i-1,v[i]);\n\t\t}\n\t\tfor(int i=N-2;i>=0;i--) {\n\t\t\tdat.set(i,dat.get(i*2+1)+dat.get(i*2+2));\n\t\t}\n\t}\n\n\tvoid update(int k,int a) {\n\t\tk += N-1;\n\t\tdat.set(k,dat.get(k)+a);\n\t\twhile(k>0){\n\t\t\tk = (k-1)/2;\n\t\t\tdat.set(k,dat.get(k*2+1)+dat.get(k*2+2));\n\t\t}\n\t}\n\n\tint query(int a,int b, int k, int l ,int r) {\n\t\tif(r<=a||b<=l) return d1;\n\t\tif(a<=l&&r<=b) return dat.get(k);\n\t\tint vl = query(a,b,k*2+1,l,(l+r)/2);\n\t\tint vr = query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn vl+vr;\n\t}\n\tint query(int a,int b){\n\t\treturn query(a,b,0,0,N);\n\t}\n}\nclass AddSumLazySegmentTree {\n\tint N;\n\tlong[] dat;\n\tlong[] laz;\n\tAddSumLazySegmentTree(long[] v){\n\t\tinit(v.length);\n\n\t\tfor(int i=0;i<v.length;i++) {\n\t\t\tdat[N+i-1]=v[i];\n\t\t}\n\t\tfor(int i=N-2;i>=0;i--) {\n\t\t\tdat[i]=dat[i*2+1]+dat[i*2+2];\n\t\t}\n\t}\n\n\tvoid init(int n) {\n\t\tN = 1;\n\t\twhile(N<n)N*=2;\n\t\tdat = new long[2*N];\n\t\tlaz = new long[2*N];\n\t}\n\n\n\tvoid eval(int len,int k) {\n\t\tif(laz[k]==0) return;\n\t\tif(k*2+1<N*2-1) {\n\t\t\tlaz[k*2+1] += laz[k];\n\t\t\tlaz[k*2+2] += laz[k];\n\t\t}\n\t\tdat[k] += laz[k] * len;\n\t\tlaz[k] = 0;\n\t}\n\n\tlong update(int a,int b,long x,int k,int l,int r) {\n\t\teval(r-l,k);\n\t\tif(r<=a||b<=l) {\n\t\t\treturn dat[k];\n\t\t}\n\t\tif(a<=l&&r<=b) {\n\t\t\tlaz[k] += x;\n\t\t\treturn dat[k]+laz[k]*(r-l);\n\t\t}\n\t\tlong vl = update(a,b,x,k*2+1,l,(l+r)/2);\n\t\tlong vr = update(a,b,x,k*2+2,(l+r)/2,r);\n\t\treturn dat[k] = vl+vr;\n\n\n\t}\n\n\tlong update(int a,int b,long x) {\n\t\treturn update(a,b,x,0,0,N);\n\t}\n\n\tlong query(int a,int b,int k,int l,int r) {\n\t\teval(r-l,k);\n\t\tif(r<=a||b<=l) return 0;\n\t\tif(a<=l&&r<=b) return dat[k];\n\n\t\tlong vl = query(a,b,k*2+1,l,(l+r)/2);\n\t\tlong vr = query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn vl+vr;\n\t}\n\n\tlong query(int a,int b){\n\t\treturn query(a,b,0,0,N);\n\t}\n\n}\n\nclass BinaryIndexedTree{\n\tint[] val;\n\tBinaryIndexedTree(int N){\n\t\tval = new int[N+1];\n\t}\n\tlong sum(int i) {\n\t\tif(i==0)return 0;\n\t\tlong s = 0;\n\t\twhile(i>0) {\n\t\t\ts += val[i];\n\t\t\ti -= i & (-i);\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int x,int i) {\n\t\tif(i==0)return;\n\t\twhile(i<val.length){\n\t\t\tval[i] += x;\n\t\t\ti += i & (-i);\n\t\t}\n\t}\n}\n\nclass UnionFindTree {\n\tint[] root;\n\tint[] rank;\n\tint[] size;\n\tint[] edge;\n\tint num;\n\tUnionFindTree(int N){\n\t\troot = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tedge = new int[N];\n\t\tnum = N;\n\t\tfor(int i=0;i<N;i++){\n\t\t\troot[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\tpublic boolean isRoot(int x) {\n\t\treturn x==find(x);\n\t}\n\tpublic int extraEdge(int x) {\n\t\tint r = find(x);\n\t\treturn edge[r] - size[r] + 1;\n\t}\n\tpublic int find(int x){\n\t\tif(root[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn find(root[x]);\n\t\t}\n\t}\n\n\tpublic void unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y){\n\t\t\tedge[x]++;\n\t\t\treturn;\n\t\t}else{\n\t\t\tnum--;\n\t\t\tif(rank[x]<rank[y]){\n\t\t\t\troot[x] = y;\n\t\t\t\tsize[y] += size[x];\n\t\t\t\tedge[y] += edge[x]+1;\n\t\t\t}else{\n\t\t\t\troot[y] = x;\n\t\t\t\tsize[x] += size[y];\n\t\t\t\tedge[x] += edge[y]+1;\n\t\t\t\tif(rank[x]==rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\n}\n\nclass ParticalEternalLastingUnionFindTree extends UnionFindTree{\n\tint[] time;\n\tint now;\n\tParticalEternalLastingUnionFindTree(int N){\n\t\tsuper(N);\n\t\ttime = new int[N];\n\t\tfor(int i=0;i<N;i++) {\n\t\t\ttime[i] = 1000000007;\n\t\t}\n\t}\n\n\tpublic int find(int t,int i) {\n\t\tif(time[i]>t) {\n\t\t\treturn i;\n\t\t}else {\n\t\t\treturn find(t,root[i]);\n\t\t}\n\t}\n\n\tpublic void unite(int x,int y,int t) {\n\t\tnow = t;\n\t\tx = find(t,x);\n\t\ty = find(t,y);\n\t\tif(x==y)return;\n\t\tif(rank[x]<rank[y]){\n\t\t\troot[x] = y;\n\t\t\tsize[y] += size[x];\n\t\t\ttime[x] = t;\n\t\t}else{\n\t\t\troot[y] = x;\n\t\t\tsize[x] += size[y];\n\t\t\tif(rank[x]==rank[y]){\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t\ttime[y] = t;\n\t\t}\n\t}\n\n\tpublic int sametime(int x,int y) {\n\t\tif(find(now,x)!=find(now,y)) return -1;\n\t\tint ok = now;\n\t\tint ng = 0;\n\t\twhile(ok-ng>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(find(mid,x)==find(mid,y)) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\n\n}\nclass Graph {\n\tArrayList<Edge>[] list;\n\tint size;\n\tTreeSet<LinkEdge> Edges = new TreeSet<LinkEdge>(new LinkEdgeComparator());\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tGraph(int N){\n\t\tsize = N;\n\t\tlist = new ArrayList[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tlist[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tvoid addEdge(int a,int b){\n\t\tlist[a].add(new Edge(b,1));\n\t}\n\n\tvoid addWeightedEdge(int a,int b,long c){\n\t\tlist[a].add(new Edge(b,c));\n\t}\n\n\tvoid addEgdes(int[] a,int[] b){\n\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tlist[a[i]].add(new Edge(b[i],1));\n\t\t}\n\t}\n\n\tvoid addWeighterEdges(int[] a ,int[] b ,int[] c){\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tlist[a[i]].add(new Edge(b[i],c[i]));\n\t\t}\n\t}\n\n\tlong[][] bfs(int s){\n\t\tlong[][] L = new long[2][size];\n\t\tfor(int i=0;i<size;i++){\n\t\t\tL[0][i] = -1;\n\t\t\tL[1][i] = -1;\n\t\t}\n\t\tL[0][s] = 0;\n\t\tArrayDeque<Integer> Q = new ArrayDeque<Integer>();\n\t\tQ.add(s);\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint v = Q.poll();\n\t\t\tfor(Edge e:list[v]){\n\t\t\t\tint w = e.to;\n\t\t\t\tlong c = e.cost;\n\t\t\t\tif(L[0][w]==-1){\n\t\t\t\t\tL[0][w] = L[0][v] + c;\n\t\t\t\t\tL[1][w] = v; \n\t\t\t\t\tQ.add(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn L;\n\t}\n\tlong[] bfs2(int[] d,int s){\n\t\tlong[] L = new long[size];\n\t\tfor(int i=0;i<size;i++){\n\t\t\tL[i] = -1;\n\t\t}\n\t\tint p = 0;\n\t\tL[s] = 0;\n\t\td[s] = p;\n\t\tp++;\n\t\tArrayDeque<Integer> Q = new ArrayDeque<Integer>();\n\t\tQ.add(s);\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint v = Q.poll();\n\t\t\tfor(Edge e:list[v]){\n\t\t\t\tint w = e.to;\n\t\t\t\tlong c = e.cost;\n\t\t\t\tif(L[w]==-1){\n\t\t\t\t\td[w] = p;\n\t\t\t\t\tp++;\n\t\t\t\t\tL[w] = L[v] + c;\n\t\t\t\t\tQ.add(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn L;\n\t}\n\n\tint[] isTwoColor(){\n\t\tint[] L = new int[size];\n\t\tfor(int i=0;i<size;i++){\n\t\t\tL[i] = -1;\n\t\t}\n\t\tL[0] = 0;\n\t\tArrayDeque<Integer> Q = new ArrayDeque<Integer>();\n\t\tQ.add(0);\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint v = Q.poll();\n\t\t\tfor(Edge e:list[v]){\n\t\t\t\tint w = e.to;\n\t\t\t\tif(L[w]==-1){\n\t\t\t\t\tL[w] = 1-L[v];\n\t\t\t\t\tQ.add(w);\n\t\t\t\t}else{\n\t\t\t\t\tif(L[v]+L[w]!=1){\n\t\t\t\t\t\tL[0] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn L;\n\t}\n\n\tlong[] dijkstra(int s){\n\t\tlong[] L = new long[size];\n\t\tfor(int i=0;i<size;i++){\n\t\t\tL[i] = -1;\n\t\t}\n\t\tint[] v = new int[size];\n\t\tL[s] = 0;\n\t\tPriorityQueue<LongIntPair> Q = new PriorityQueue<LongIntPair>(new LongIntSampleComparator());\n\t\tQ.add(new LongIntPair(0,s));\n\n\t\twhile(!Q.isEmpty()){\n\n\t\t\tLongIntPair C = Q.poll();\n\t\t\t\n\t\t\tif(v[C.b]==0){\n\t\t\t\tL[C.b] = C.a;\n\t\t\t\tv[C.b] = 1;\n\t\t\t\tfor(Edge D:list[C.b]) {\n\t\t\t\t\tif(L[D.to]==-1||L[D.to]>L[C.b]+D.cost) {\n\t\t\t\t\t\tL[D.to]=L[C.b]+D.cost;\n\t\t\t\t\t\tQ.add(new LongIntPair(L[C.b]+D.cost,D.to));\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn L;\n\t}\n\n\tArrayList<Graph> makeapart(){\n\t\tArrayList<Graph> ans = new ArrayList<Graph>();\n\t\tboolean[] b = new boolean[size];\n\t\tint[] num = new int[size];\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(b[i])continue;\n\t\t\tint sz = 0;\n\t\t\tArrayList<Integer> l = new ArrayList<Integer>();\n\t\t\tArrayDeque<Integer> Q = new ArrayDeque<Integer>();\n\t\t\tQ.add(i);\n\t\t\tb[i] = true;\n\t\t\twhile(!Q.isEmpty()){\n\t\t\t\tint v = Q.poll();\n\t\t\t\tnum[v] = sz;\n\t\t\t\tsz++;\n\t\t\t\tl.add(v);\n\t\t\t\tfor(Edge e:list[v]){\n\t\t\t\t\tif(!b[e.to]){\n\t\t\t\t\t\tQ.add(e.to);\n\t\t\t\t\t\tb[e.to] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tGraph H = new Graph(sz);\n\t\t\tfor(int e:l){\n\t\t\t\tfor(Edge E:list[e]){\n\t\t\t\t\tH.addWeightedEdge(num[e],num[E.to],E.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans.add(H);\n\n\t\t}\n\t\treturn ans;\n\t}\n\n\tlong[] bellmanFord(int s) {\n\t\tlong inf = 1000000000;\n\t\tinf *= inf;\n\t\tlong[] d = new long[size];\n\t\tboolean[] n = new boolean[size];\n\t\td[s] = 0;\n\t\tfor(int i=1;i<size;i++){\n\t\t\td[i] = inf;\n\t\t\td[i] *= d[i];\n\t\t}\n\t\tfor(int i=0;i<size-1;i++){\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tfor(Edge E:list[j]){\n\t\t\t\t\tif(d[j]!=inf&&d[E.to]>d[j]+E.cost){\n\t\t\t\t\t\td[E.to]=d[j]+E.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<size;i++){\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tfor(Edge e:list[j]){\n\t\t\t\t\tif(d[j]==inf) continue;\n\t\t\t\t\tif(d[e.to]>d[j]+e.cost) {\n\t\t\t\t\t\td[e.to]=d[j]+e.cost;\n\t\t\t\t\t\tn[e.to] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(n[j])n[e.to] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tif(n[i])d[i] = inf;\n\t\t}\n\t\treturn d;\n\t}\n\t\n\tlong[][] WarshallFloyd(long[][] a){\n\t\tint n = a.length;\n\t\tlong[][] ans = new long[n][n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tans[i][j] = a[i][j]==0?(long)1e16:a[i][j];\n\t\t\t\tif(i==j)ans[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++) {\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\t\tans[i][j] = Math.min(ans[i][j],ans[i][k]+ans[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tlong[] maxtra(int s,long l){\n\t\tlong[] L = new long[size];\n\t\tfor(int i=0;i<size;i++){\n\t\t\tL[i] = -1;\n\t\t}\n\t\tint[] v = new int[size];\n\t\tL[s] = -1;\n\n\t\tPriorityQueue<Pair> Q = new PriorityQueue<Pair>(new SampleComparator());\n\t\tQ.add(new Pair(l,s));\n\n\t\twhile(!Q.isEmpty()){\n\n\t\t\tPair C = Q.poll();\n\t\t\tif(v[(int)C.b]==0){\n\t\t\t\tL[(int)C.b] = C.a;\n\t\t\t\tv[(int) C.b] = 1;\n\t\t\t\tfor(Edge D:list[(int) C.b])Q.add(new Pair(Math.max(L[(int)C.b],D.cost),D.to));\n\t\t\t}\n\t\t}\n\n\t\treturn L;\n\t}\n\tlong[] mintra(int s){\n\t\tlong[] L = new long[size];\n\t\tfor(int i=0;i<size;i++){\n\t\t\tL[i] = -1;\n\t\t}\n\t\tint[] v = new int[size];\n\t\tL[s] = s;\n\n\t\tPriorityQueue<Pair> Q = new PriorityQueue<Pair>(new SampleComparator().reversed());\n\t\tQ.add(new Pair(s,s));\n\n\t\twhile(!Q.isEmpty()){\n\n\t\t\tPair C = Q.poll();\n\t\t\tif(v[(int)C.b]==0){\n\t\t\t\tL[(int)C.b] = C.a;\n\t\t\t\tv[(int) C.b] = 1;\n\t\t\t\tfor(Edge D:list[(int) C.b])Q.add(new Pair(Math.min(L[(int)C.b],D.cost),D.to));\n\t\t\t}\n\t\t}\n\n\t\treturn L;\n\t}\n\tlong Kruskal(){\n\t\tlong r = 0;\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tfor(Edge e:list[i]) {\n\t\t\t\tEdges.add(new LinkEdge(e.cost,i,e.to));\n\t\t\t}\n\t\t}\n\t\tUnionFindTree UF = new UnionFindTree(size);\n\t\tfor(LinkEdge e:Edges){\n\t\t\tif(e.a>=0&&e.b>=0) {\n\t\t\t\tif(!UF.same(e.a,e.b)){\n\t\t\t\t\tr += e.L;\n\t\t\t\t\tUF.unite(e.a,e.b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tArrayList<Integer> Kahntsort(){\n\n\t\tArrayList<Integer> ans = new ArrayList<Integer>();\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\tint[] in = new int[size];\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tfor(Edge e:list[i])in[e.to]++;\n\t\t}\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tif(in[i]==0)q.add(i);\n\t\t}\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.poll();\n\t\t\tans.add(v);\n\t\t\tfor(Edge e:list[v]) {\n\t\t\t\tin[e.to]--;\n\t\t\t\tif(in[e.to]==0)q.add(e.to);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tif(in[i]>0)return new ArrayList<Integer>();\n\t\t}\n\t\treturn ans;\n\t}\n\n\tRootedTree dfsTree(int i) {\n\t\tint[] u = new int[size];\n\t\tRootedTree r = new RootedTree(size);\n\t\tdfsTree(i,u,r);\n\t\treturn r;\n\n\t}\n\n\tprivate void dfsTree(int i, int[] u, RootedTree r) {\n\t\tu[i] = 1;\n\t\tfor(Edge e:list[i]) {\n\t\t\tif(u[e.to]==0) {\n\t\t\t\tr.list[i].add(e);\n\t\t\t\tu[e.to] = 1;\n\t\t\t\tdfsTree(e.to,u,r);\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n\nclass Tree extends Graph{\n\n\tpublic Tree(int N) {\n\t\tsuper(N);\n\t}\n\n\tlong[] tyokkei(){\n\t\tlong[][] a = bfs(0);\n\n\t\tSystem.out.println();\n\t\tint md = -1;\n\t\tlong m = 0;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(m<a[0][i]){\n\t\t\t\tm = a[0][i];\n\t\t\t\tmd = i;\n\t\t\t}\n\t\t}\n\n\t\tlong[][] b = bfs(md);\n\t\tint md2 = -1;\n\t\tlong m2 = 0;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(m2<b[0][i]){\n\t\t\t\tm2 = b[0][i];\n\t\t\t\tmd2 = i;\n\t\t\t}\n\t\t}\n\t\tlong[] r = {m2,md,md2};\n\t\treturn r;\n\t}\n\n}\n\nclass RootedTree extends Graph{\n\tRootedTree(int N){\n\t\tsuper(N);\n\t}\n}\nclass LinkEdge{\n\tlong L;\n\tint a ;\n\tint b;\n\tLinkEdge(long l,int A,int B){\n\t\tL = l;\n\t\ta = A;\n\t\tb = B;\n\t}\n\tpublic boolean equals(Object o){\n\t\tLinkEdge O = (LinkEdge) o;\n\t\treturn O.a==this.a&&O.b==this.b&&O.L==this.L;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(L,a,b);\n\t}\n}\n\nclass Edge{\n\tint to;\n\tlong cost;\n\n\tEdge(int a,long b){\n\t\tto = a;\n\t\tcost = b;\n\t}\n}\nclass LinkEdgeComparator implements Comparator<LinkEdge>{\n\tpublic int compare(LinkEdge P, LinkEdge Q) {\n\t\tlong t = P.L-Q.L;\n\t\tif(t==0){\n\t\t\tif(P.a>Q.a){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn P.b>Q.b?1:-1;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn t>=0?1:-1;\n\t}\n}\n\nclass Triplet{\n\tlong a;\n\tlong b;\n\tlong c;\n\tTriplet(long p,long q,long r){\n\t\ta = p;\n\t\tb = q;\n\t\tc = r;\n\t}\n\tpublic boolean equals(Object o){\n\t\tTriplet O = (Triplet) o;\n\t\treturn O.a==this.a&&O.b==this.b&&O.c==this.c?true:false;\n\t\t\t\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(a,b,c);\n\t}\n}\n\nclass TripletComparator implements Comparator<Triplet>{\n\tpublic int compare(Triplet P, Triplet Q) {\n\t\tlong t = P.a-Q.a;\n\t\tif(t==0){\n\t\t\tlong tt = P.b-Q.b;\n\t\t\tif(tt==0) {\n\t\t\t\tif(P.c>Q.c) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}else if(P.c<Q.c){\n\t\t\t\t\treturn -1;\n\t\t\t\t}else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tt>0?1:-1;\n\t\t}\n\t\treturn t>=0?1:-1;\n\t}\n}\nclass Pair{\n\tlong a;\n\tlong b;\n\n\tPair(long p,long q){\n\t\tthis.a = p;\n\t\tthis.b = q;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tPair O = (Pair) o;\n\t\treturn O.a==this.a&&O.b==this.b;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(a,b);\n\t}\n}\n\nclass SampleComparator implements Comparator<Pair>{\n\tpublic int compare(Pair P, Pair Q) {\n\t\tlong t = P.a-Q.a;\n\t\tif(t==0){\n\t\t\treturn P.b>=Q.b?1:-1;\n\n\t\t}\n\t\treturn t>=0?1:-1;\n\t}\n}\n\n\nclass LongIntPair{\n\tlong a;\n\tint b;\n\n\tLongIntPair(long p,int q){\n\t\tthis.a = p;\n\t\tthis.b = q;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tPair O = (Pair) o;\n\t\treturn O.a==this.a&&O.b==this.b;\n\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(a,b);\n\t}\n}\n\nclass LongIntSampleComparator implements Comparator<LongIntPair>{\n\tpublic int compare(LongIntPair P, LongIntPair Q) {\n\t\tlong t = P.a-Q.a;\n\t\tif(t==0){\n\t\t\tif(P.b>Q.b){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn t>=0?1:-1;\n\t}\n}\n\n\nclass IntIntPair{\n\tint a;\n\tint b;\n\n\tIntIntPair(int p,int q){\n\t\tthis.a = p;\n\t\tthis.b = q;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tPair O = (Pair) o;\n\t\treturn O.a==this.a&&O.b==this.b;\n\t\t\t\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(a,b);\n\t}\n}\n\n\n\nclass IntIntSampleComparator implements Comparator<IntIntPair>{\n\tpublic int compare(IntIntPair P, IntIntPair Q) {\n\t\tint t = P.a-Q.a;\n\t\tif(t==0){\n\t\t\treturn P.b-Q.b;\n\t\t}\n\t\treturn t;\n\t}\n}\n\n\n\n\nclass DoublePair{\n\tdouble a;\n\tdouble b;\n\n\tDoublePair(double p,double q){\n\t\tthis.a = p;\n\t\tthis.b = q;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tPair O = (Pair) o;\n\t\treturn O.a==this.a&&O.b==this.b;\n\t\t\t\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(a,b);\n\t}\n}\n\nclass DDSampleComparator implements Comparator<DoublePair>{\n\tpublic int compare(DoublePair P, DoublePair Q) {\n\t\treturn P.b-Q.b>=0?1:-1;\n\t}\n}\n\nclass DoubleTriplet{\n\tdouble a;\n\tdouble b;\n\tdouble c;\n\n\tDoubleTriplet(double p,double q,double r){\n\t\tthis.a = p;\n\t\tthis.b = q;\n\t\tthis.c = r;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tDoubleTriplet O = (DoubleTriplet) o;\n\t\treturn O.a==this.a&&O.b==this.b&&O.c==this.c;\n\t\t\t\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(a,b,c);\n\t}\n}\n\n\nclass FastScanner {\n    private final java.io.InputStream in = System.in;\n    private final byte[] b = new byte[1024];\n    private int p = 0;\n    private int bl = 0;\n    private boolean hNB() {\n        if (p<bl) {\n            return true;\n        }else{\n            p = 0;\n            try {\n                bl = in.read(b);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (bl<=0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int rB() { if (hNB()) return b[p++]; else return -1;}\n    private static boolean iPC(int c) { return 33 <= c && c <= 126;}\n    private void sU() { while(hNB() && !iPC(b[p])) p++;}\n    public boolean hN() { sU(); return hNB();}\n    public String next() {\n        if (!hN()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = rB();\n        while(iPC(b)) {\n            sb.appendCodePoint(b);\n            b = rB();\n        }\n        return sb.toString();\n    }\n    public char nextChar() {\n    \treturn next().charAt(0);\n    }\n    public long nextLong() {\n        if (!hN()) throw new NoSuchElementException();\n        long n = 0;\n        boolean m = false;\n        int b = rB();\n        if (b=='-') {\n            m=true;\n            b=rB();\n        }\n        if (b<'0'||'9'<b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0'<=b&&b<='9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1||!iPC(b)){\n                return (m?-n:n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = rB();\n        }\n    }\n    public int nextInt() {\n        if (!hN()) throw new NoSuchElementException();\n        long n = 0;\n        boolean m = false;\n        int b = rB();\n        if (b == '-') {\n            m = true;\n            b = rB();\n        }\n        if (b<'0'||'9'<b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0'<=b&&b<='9') {\n                n *= 10;\n                n += b-'0';\n            }else if(b==-1||!iPC(b)){\n                return (int) (m?-n:n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = rB();\n        }\n    }\n    public int[] nextInts(int n) {\n    \tint[] a = new int[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = nextInt();\n    \t}\n    \treturn a;\n    }\n    public long[] nextLongs(int n) {\n    \tlong[] a = new long[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = nextLong();\n    \t}\n    \treturn a;\n    }\n    public int[][] nextIntses(int n,int m){\n    \tint[][] a = new int[n][m];\n    \tfor(int i=0;i<n;i++) {\n    \t\tfor(int j=0;j<m;j++) {\n    \t\t\ta[i][j] = nextInt();\n    \t\t}\n    \t}\n    \treturn a;\n    }\n}\n\n\nclass Mathplus{\n\tint mod = 1000000007;\n\tlong[] fac;\n\tlong[] revfac;\n\tlong[][] comb;\n\tlong[] pow;\n\tlong[] revpow;\n\tboolean isBuild = false;\n\tboolean isBuildc = false;\n\tboolean isBuildp = false;\n\tint mindex = -1;\n\tint maxdex = -1;\n\t\n\tint color(int[][] diff,int N) {\n\t\t\n\t\tint[] val = new int[1<<N];\n\t\tval[0] = 1;\n\t\tfor(int i=0;i<(1<<N);i++) {\t\t\n\t\t\tfor(int j=0;j<N;j++) {\n\t\t\t\tif(contains(i,j)) {\n\t\t\t\t\tif(val[bitremove(i,j)]==1) {\n\t\t\t\t\t\tboolean b = true;\n\t\t\t\t\t\tfor(int k=0;k<N;k++) {\n\t\t\t\t\t\t\tif(contains(i,k)&&diff[j][k]==1) {\n\t\t\t\t\t\t\t\tb = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b)val[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] dp = new int[1<<N];\n\t\tArrays.fill(dp,mod);;\n\t\tdp[0] = 0;\n\t\tfor(int i=0;i<(1<<N);i++) {\n\t\t\tfor(int j=i;j>0;j=(j-1)&i) {\n\t\t\t\tif(val[j]==1)dp[i]=Math.min(dp[i],dp[i^j]+1);\n\t\t\t}\n\t\t}\n\t\treturn dp[(1<<N)-1];\n\t}\n\t\n\tpublic DoubleTriplet Line(double x1,double y1,double x2,double y2) {\n\t\tdouble a = y1-y2;\n\t\tdouble b = x2-x1;\n\t\tdouble c = x1*y2-x2*y1;\n\t\treturn new DoubleTriplet(a,b,c);\n\t}\n\tpublic double putx(DoubleTriplet T,double x) {\n\t\treturn -(T.a*x+T.c)/T.b;\n\t}\n\tpublic double puty(DoubleTriplet T,double y) {\n\t\treturn -(T.b*y+T.c)/T.a;\n\t}\n\tpublic double DistanceofPointandLine(DoublePair P,Triplet T) {\n\t\treturn Math.abs(P.a*T.a+P.b*T.b+T.c) / Math.sqrt(T.a*T.a+T.b*T.b);\n\t}\n\tpublic boolean cross(long ax, long ay, long bx, long by, long cx, long cy, long dx, long dy) {\n\t\t long ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\t\t long tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\t\t long tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\t\t long td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\t\t return((tc>=0&&td<=0)||(tc<=0&&td>=0))&&((ta>=0&&tb<=0)||(ta<=0&&tb>=0));\n\t}\n\tpublic boolean dcross(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy) {\n\t\t double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\t\t double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\t\t double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\t\t double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\t\t return((tc>=0&&td<=0)||(tc<=0&&td>=0))&&((ta>=0&&tb<=0)||(ta<=0&&tb>=0));\n\t}\n\t\n\tvoid buildFac(){\n\t\tfac = new long[10000003];\n\t\trevfac = new long[10000003];\n\t\tfac[0] = 1;\n\t\tfor(int i=1;i<=10000002;i++){\n\t\t\tfac[i] = (fac[i-1] * i)%mod;\n\t\t}\n\t\trevfac[10000002] = rev(fac[10000002])%mod;\n\t\tfor(int i=10000001;i>=0;i--) {\n\t\t\trevfac[i] = (revfac[i+1] * (i+1))%mod;\n\t\t}\n\t\tisBuild = true;\n\t}\n\tpublic long[] buildrui(int[] a) {\n\t\tint n = a.length;\n\t\tlong[] ans = new long[n];\n\t\tans[0] = a[0];\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tans[i] = ans[i-1] + a[i];\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic long[][] buildrui(int[][] a) {\n\t\tint n = a.length;\n\t\tint m = a[0].length;\n\t\tlong[][] ans = new long[n][m];\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tfor(int j=1;j<m;j++) {\n\t\t\t\tans[i][j] = a[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tfor(int j=1;j<m;j++) {\n\t\t\t\tans[i][j] += ans[i][j-1] + ans[i-1][j] - ans[i-1][j-1];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tlong divroundup(long n,long d) {\n\t\tif(n==0)return 0;\n\t\treturn (n-1)/d+1;\n\t}\n\tpublic long sigma(long i) {\n\t\treturn i*(i+1)/2;\n\t}\n\tpublic int digit(long i) {\n\t\tint ans = 1;\n\t\twhile(i>=10) {\n\t\t\ti /= 10;\n\t\t\tans++;\n\t\t}\n\t\treturn ans;\n\n\t}\n\tpublic int popcount(int i) {\n\t\tint ans = 0;\n\t\twhile(i>0) {\n\t\t\tans += i%2;\n\t\t\ti /= 2;\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic boolean contains(int S,int i) {return (S>>i&1)==1;}\n\tpublic int bitremove(int S,int i) {return S&(~(1<<i));}\n\tpublic int bitadd(int S,int i) {return S|(1<<i);}\n\tpublic boolean isSubSet(int S,int T) {return (S-T)==(S^T);}\n\tpublic boolean isDisjoint(int S,int T) {return (S+T)==(S^T);}\n\tpublic int isBigger(int[] d, int i) {\n\t\tint ok = d.length;\n\t\tint ng = -1;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d[mid]>i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isSmaller(int[] d, int i) {\n\t\tint ok = -1;\n\t\tint ng = d.length;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d[mid]<i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isBigger(long[] d, long i) {\n\t\tint ok = d.length;\n\t\tint ng = -1;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d[mid]>i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isSmaller(long[] d, long i) {\n\t\tint ok = -1;\n\t\tint ng = d.length;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d[mid]<i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isBigger(ArrayList<Long> d, long i) {\n\t\tint ok = d.size();\n\t\tint ng = -1;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d.get(mid)>i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isSmaller(ArrayList<Long> d, long i) {\n\t\tint ok = -1;\n\t\tint ng = d.size();\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d.get(mid)<i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic HashSet<Integer> primetable(int m) {\n\t\tHashSet<Integer> pt = new HashSet<Integer>();\n\t\tfor(int i=2;i<=m;i++) {\n\t\t\tboolean b = true;\n\t\t\tfor(int d:pt) {\n\t\t\t\tif(i%d==0) {\n\t\t\t\t\tb = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b) {\n\t\t\t\tpt.add(i);\n\t\t\t}\n\t\t}\n\t\treturn pt;\n\t}\n\tpublic ArrayList<Integer> primetablearray(int m) {\n\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\tQueue<Integer> q = new ArrayDeque<Integer>();\n\t\tfor(int i=2;i<=m;i++) {\n\t\t\tq.add(i);\n\t\t\t\n\t\t}\n\t\tboolean[] b = new boolean[m+1];\n\t\twhile(!q.isEmpty()) {\n\t\t\tint e = q.poll();\n\t\t\tif(!b[e]) {\n\t\t\t\tal.add(e);\n\t\t\t\tfor(int j=1;e*j<=1000000;j++) {\n\t\t\t\t\tb[e*j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn al;\n\t}\n\tpublic HashMap<Integer,Integer> hipPush(ArrayList<Integer> l){\n\t\tHashMap<Integer,Integer> r = new HashMap<Integer,Integer>();\n\t\tTreeSet<Integer> s = new TreeSet<Integer>();\n\t\tfor(int e:l)s.add(e);\n\t\tint p = 0;\n\t\tfor(int e:s) {\n\t\t\tr.put(e,p);\n\t\t\tp++;\n\t\t}\n\t\treturn r;\n\t}\n\tpublic TreeMap<Integer,Integer> thipPush(ArrayList<Integer> l){\n\t\tTreeMap<Integer,Integer> r = new TreeMap<Integer,Integer>();\n\t\tCollections.sort(l);\n\t\tint b = -(mod+9393);\n\t\tint p = 0;\n\t\tfor(int e:l) {\n\t\t\tif(b!=e) {\n\t\t\t\tr.put(e,p);\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tb=e;\n\t\t}\n\t\treturn r;\n\t}\n\n\tlong max(long[] a){\n\t\tlong M = 0;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(M<a[i]){\n\t\t\t\tM =a[i];\n\t\t\t\tmaxdex = i;\n\t\t\t}\n\t\t}\n\t\treturn M;\n\t}\n\tint max(int[] a){\n\t\tint M = 0;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(M<a[i]){\n\t\t\t\tM =a[i];\n\t\t\t\tmaxdex = i;\n\t\t\t}\n\t\t}\n\t\treturn M;\n\t}\n\tlong min(long[] a){\n\t\tlong m = Long.MAX_VALUE;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(m>a[i]){\n\t\t\t\tm =a[i];\n\t\t\t\tmindex = i;\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tint min(int[] a){\n\t\tint m = Integer.MAX_VALUE;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(m>a[i]){\n\t\t\t\tm =a[i];\n\t\t\t\tmindex = i;\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tlong sum(long[] a){\n\t\tlong s = 0;\n\t\tfor(int i=0;i<a.length;i++)s += a[i];\n\t\treturn s;\n\t}\n\tlong sum(int[] a){\n\t\tlong s = 0;\n\t\tfor(int i=0;i<a.length;i++)s += a[i];\n\t\treturn s;\n\t}\n\tlong gcd(long a, long b){\n\t\ta = Math.abs(a);\n\t\tb = Math.abs(b);\n\t\tif(a==0)return b;\n\t\tif(b==0)return a;\n\t\tif(a%b==0) return b;\n\t\telse return gcd(b,a%b);\n\t}\n\tint igcd(int a, int b) {\n\t\tif(a%b==0) return b;\n\t\telse return igcd(b,a%b);\n\t}\n\tlong lcm(long a, long b) {return a / gcd(a,b) * b;}\n\tpublic long perm(int a,int num) {\n\t\tif(!isBuild)buildFac();\n\t\treturn fac[a]*(rev(fac[a-num]))%mod;\n\t}\n\tvoid buildComb(int N) {\n\t\tcomb = new long[N+1][N+1];\n\t\tcomb[0][0] = 1;\n\t\tfor(int i=1;i<=N;i++) {\n\t\t\tcomb[i][0] = 1;\n\t\t\tfor(int j=1;j<N;j++) {\n\t\t\t\tcomb[i][j] = comb[i-1][j-1]+comb[i-1][j];\n\t\t\t\tif(comb[i][j]>mod)comb[i][j]-=mod;\n\t\t\t}\n\t\t\tcomb[i][i] = 1;\n\t\t}\n\t}\n\tpublic long comb(int a,int num){\n\t\tif(a-num<0)return 0;\n\t\tif(num<0)return 0;\n\t\tif(!isBuild)buildFac();\n\t\treturn fac[a] * ((revfac[num]*revfac[a-num])%mod)%mod;\n\t}\n\tlong mulchoose(int n,int k) {\n\t\tif(k==0) return 1;\n\t\treturn comb(n+k-1,k);\n\t}\n\tlong rev(long l) {return pow(l,mod-2);}\n\t\n\tvoid buildpow(int l,int i) {\n\t\tpow = new long[i+1];\n\t\tpow[0] = 1;\n\t\tfor(int j=1;j<=i;j++) {\n\t\t\tpow[j] = pow[j-1]*l;\n\t\t\tif(pow[j]>mod)pow[j] %= mod;\n\t\t}\n\t}\n\tvoid buildrevpow(int l,int i) {\n\t\trevpow = new long[i+1];\n\t\trevpow[0] = 1;\n\t\tfor(int j=1;j<=i;j++) {\n\t\t\trevpow[j] = revpow[j-1]*l;\n\t\t\tif(revpow[j]>mod) revpow[j] %= mod;\t\t\n\t\t}\n\t}\n\tlong pow(long l, long i) {\n\t\tif(i==0)return 1;\n\t\telse{\n\t\t\tif(i%2==0){\n\t\t\t\tlong val = pow(l,i/2);\n\t\t\t\treturn val * val % mod;\n\t\t\t}\n\t\t\telse return pow(l,i-1) * l % mod;\n\t\t}\n\t}\n}\n", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\n\n/**\n * Works good for CF\n * \n * @author cykeltillsalu\n */\npublic class A111_div2 {\n\n\t// some local config\n\tstatic boolean test = false;\n\tstatic String testDataFile = \"testdata.txt\";\n\tstatic String feedFile = \"feed.txt\";\n\tCompetitionType type = CompetitionType.CF;\n\tprivate static String ENDL = \"\\n\";\n\n\t// solution\n\tprivate void solve() throws Throwable {\n\n\t\tint n = iread();\n\t\t\n\t\tint[] vals = new int[n];\n\t\tdouble tot = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint value = iread();\n\t\t\tvals[i] = value;\n\t\t\ttot += value;\n\t\t}\n\t\t\n\t\tArrays.sort(vals);\n\t\tint pick = 0;\n\t\tint worth = 0;\n\t\tfor (int i = vals.length - 1; i >= 0; i--) {\n\t\t\tworth += vals[i];\n\t\t\tpick ++;\n\t\t\tif(worth > tot/2.0d){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.write(pick + ENDL);\n\t\tout.flush();\n\t}\n\n\tpublic int iread() throws Exception {\n\t\treturn Integer.parseInt(wread());\n\t}\n\n\tpublic double dread() throws Exception {\n\t\treturn Double.parseDouble(wread());\n\t}\n\n\tpublic long lread() throws Exception {\n\t\treturn Long.parseLong(wread());\n\t}\n\n\tpublic String wread() throws IOException {\n\t\tStringBuilder b = new StringBuilder();\n\t\tint c;\n\t\tc = in.read();\n\t\twhile (c >= 0 && c <= ' ')\n\t\t\tc = in.read();\n\t\tif (c < 0)\n\t\t\treturn \"\";\n\t\twhile (c > ' ') {\n\t\t\tb.append((char) c);\n\t\t\tc = in.read();\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tpublic static void main(String[] args) throws Throwable {\n\n\t\tif (test) { // run all cases from testfile:\n\t\t\tBufferedReader testdataReader = new BufferedReader(new FileReader(testDataFile));\n\t\t\tString readLine = testdataReader.readLine();\n\t\t\tint casenr = 0;\n\t\t\tout: while (true) {\n\t\t\t\tBufferedWriter w = new BufferedWriter(new FileWriter(feedFile));\n\t\t\t\tif (!readLine.equals(\"input\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (true) {\n\t\t\t\t\treadLine = testdataReader.readLine();\n\t\t\t\t\tif (readLine.equals(\"output\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tw.write(readLine + \"\\n\");\n\t\t\t\t}\n\t\t\t\tw.close();\n\t\t\t\tSystem.out.println(\"Answer on case \" + (++casenr) + \": \");\n\n\t\t\t\tnew A111_div2().solve();\n\t\t\t\tSystem.out.println(\"Expected answer: \");\n\n\t\t\t\twhile (true) {\n\t\t\t\t\treadLine = testdataReader.readLine();\n\n\t\t\t\t\tif (readLine == null) {\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\tif (readLine.equals(\"input\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(readLine);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"----------------\");\n\t\t\t}\n\t\t\ttestdataReader.close();\n\t\t} else { // run on server\n\t\t\tnew A111_div2().solve();\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic A111_div2() throws Throwable {\n\t\tif (test) {\n\t\t\tin = new BufferedReader(new FileReader(new File(feedFile)));\n\t\t}\n\t}\n\n\tInputStreamReader inp = new InputStreamReader(System.in);\n\tBufferedReader in = new BufferedReader(inp);\n\tstatic BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n\n\tenum CompetitionType {\n\t\tCF, OTHER\n\t};\n}", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Locale;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Solution implements Runnable {\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\t\n\tint fu(int[] a, int l) {\n\t\tfor (int i = l; i < a.length - 1; i++) {\n\t\t\tif (a[i] > a[i + 1]) return i;\n\t\t}\n\t\treturn a.length;\n\t}\n\t\n\tvoid swap(int[] a, int q, int w) {\n\t\tint t = a[q]; a[q] = a[w]; a[w] = t;\n\t}\n\t\n\tvoid solve() throws Exception {\n\t\tint n = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\tint q = fu(a, 0);\n\t\tif (q == n) out.println(\"YES\"); else {\n\t\t\tint w = fu(a, q + 1);\n\t\t\tif (w < n) {\n\t\t\t\tboolean ans = false;\n\t\t\t\tswap(a, q, w);\n\t\t\t\tans |= fu(a, 0) == n;\n\t\t\t\tswap(a, q, w);\n\t\t\t\tif (q < n - 1) {\n\t\t\t\t\tswap(a, q + 1, w);\n\t\t\t\t\tans |= fu(a, 0) == n;\n\t\t\t\t\tswap(a, q + 1, w);\n\t\t\t\t}\n\t\t\t\tif (w < n - 1) {\n\t\t\t\t\tswap(a, q, w + 1);\n\t\t\t\t\tans |= fu(a, 0) == n;\n\t\t\t\t\tswap(a, q, w + 1);\n\t\t\t\t}\n\t\t\t\tif (q < n - 1 && w < n - 1) {\n\t\t\t\t\tswap(a, q + 1, w + 1);\n\t\t\t\t\tans |= fu(a, 0) == n;\n\t\t\t\t\tswap(a, q + 1, w + 1);\n\t\t\t\t}\n\t\t\t\tif (ans) out.println(\"YES\"); else out.println(\"NO\");\n\t\t\t} else {\n\t\t\t\tint j = q + 1;\n\t\t\t\twhile (j < n && a[j] == a[q + 1]) j++;\n\t\t\t\tj--;\n\t\t\t\tswap(a, q, j);\n\t\t\t\tif (fu(a, 0) == n) out.println(\"YES\"); else {\n\t\t\t\t\tswap(a, q, j);\n\t\t\t\t\tq++;\n\t\t\t\t\tj = q - 1;\n\t\t\t\t\twhile (j >= 0 && a[j] == a[q - 1]) j--;\n\t\t\t\t\tj++;\n\t\t\t\t\tswap(a, q, j);\n\t\t\t\t\tif (fu(a, 0) == n) out.println(\"YES\"); else out.println(\"NO\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.UK);\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\t// out = new PrintWriter(\"output.txt\");\n\t\t\tsolve();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// new Thread(null, new Solution(), \"1\", 1 << 28).start();\n\t\t(new Solution()).run();\n\t}\n\n}", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\npublic class inversions {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] values = new int[N];\n        for(int i=0;i<N;i++){\n            values[i] = sc.nextInt();\n        }\n        int query = sc.nextInt();\n        int[][] tasks = new int[query][2];\n        for(int i=0;i<query;i++){\n            tasks[i][0] = sc.nextInt();\n            tasks[i][1] = sc.nextInt();\n        }\n        int startinversions = 0;\n        for(int i=1;i<values.length;i++){\n            for(int j=i-1;j>=0;j--){\n                if(values[i]<values[j]){\n                    startinversions++;\n                }\n            }\n        }\n        int value = startinversions%2;\n        for(int[] task : tasks){\n            int n = task[1]-task[0];\n            if(n*(n+1)/2 % 2 != 0){\n                value = (value+1)%2;\n            }\n            if(value==1){\n                System.out.println(\"odd\");\n            }\n            else{\n                System.out.println(\"even\");\n            }\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class G {\n\n\tstatic final int MOD = 1000000007;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic int sub(int a, int b) {\n\t\tint res = a - b;\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % MOD);\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int pow(int a, int e) {\n\t\tif (e == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint r = a;\n\t\tfor (int i = 30 - Integer.numberOfLeadingZeros(e); i >= 0; i--) {\n\t\t\tr = mul(r, r);\n\t\t\tif ((e & (1 << i)) != 0) {\n\t\t\t\tr = mul(r, a);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int inv(int a) {\n\t\treturn pow(a, MOD - 2);\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tString x = scanString();\n//\t\tchar xx[] = new char[700];\n//\t\tfill(xx, '9');\n//\t\tString x = new String(xx);\n\t\tint n = x.length();\n\t\tint pows[][] = new int[10][n];\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tpows[i][0] = 1;\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tpows[i][j] = mul(pows[i][j - 1], i);\n\t\t\t}\n\t\t}\n\t\tint ru[] = new int[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tru[i] = add(1, mul(10, ru[i - 1]));\n\t\t}\n\t\tint facts[] = new int[n];\n\t\tfacts[0] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfacts[i] = mul(facts[i - 1], i);\n\t\t}\n\t\tint factsInv[] = new int[n];\n\t\tfactsInv[n - 1] = inv(facts[n - 1]);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfactsInv[i - 1] = mul(factsInv[i], i);\n\t\t}\n\t\tint ans = 0;\n\t\tint off[] = new int[10];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint cd = x.charAt(i) - '0';\n\t\t\tint l = n - i - 1;\n\t\t\tfor (int d = 1; d < 10; d++) {\n\t\t\t\tfor (int p = 0; p <= l; p++) {\n\t\t\t\t\tint mul = d < cd ? add(mul(d, ru[p + off[d]]), mul(cd - d, ru[p + off[d] + 1])) : mul(cd, ru[p + off[d]]);\n\t\t\t\t\tans = add(ans, mul(mul, mul(mul(pows[d][l - p], pows[10 - d][p]), mul(facts[l], mul(factsInv[p], factsInv[l - p])))));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int d = 0; d <= cd; d++) {\n\t\t\t\t++off[d];\n\t\t\t}\n\t\t}\n\t\tfor (int d = 1; d < 10; d++) {\n\t\t\tans = add(ans, ru[off[d]]);\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}", "complexity": "quadratic", "problem": "0908_G", "from": "CODEFORCES", "tags": "dp,math"}
{"src": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in =new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tarr[i] = in.nextInt();\n\t\tfor(int i = n-1; i > 0; i--)\n\t\t\tarr[i] -= arr[i-1];\n\t\tarr[0] = 0;\n\t\tArrays.sort(arr);\n\t\tlong sum = 0;\n\t\tfor(int i = n-k; i >= 0; i--)\n\t\t\tsum += arr[i];\n\t\tSystem.out.println(sum);\n\t}\n}", "complexity": "nlogn", "problem": "1197_C", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.io.IOException;\nimport java.util.Locale;\nimport java.util.Scanner;\n\npublic class A {\n\n    public void processInput() throws IOException {\n        Scanner in = new Scanner(System.in);\n\n        long n = in.nextLong();\n        long res = go(n);\n\n        System.out.printf(Locale.ENGLISH, \"%d\\n\", res);\n\n        in.close();\n    }\n\n    public long go(long n) {\n\n        long res = n;\n\n        String str = String.valueOf(n);\n        \n        StringBuilder sb = new StringBuilder(str);\n        sb.deleteCharAt(str.length() - 1);\n        if (sb.length() > 0 && !sb.toString().equals(\"-\")) {\n            res = Math.max(res, Long.valueOf(sb.toString()));\n        }\n        \n        if (str.length() > 1) {\n            if (str.charAt(str.length() - 2) != '-') {\n                sb = new StringBuilder(str);\n                sb.deleteCharAt(str.length() - 2);\n                res = Math.max(res, Long.valueOf(sb.toString()));\n            }\n        }\n        \n        return res;\n    }\n\n    public static void main(String[] args) throws Exception {\n        A a = new A();\n        a.processInput();\n    }\n}", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "\nimport java.util.*;\n\n\npublic class C\n{\n   public static void main(String[] args)\n   {\n      new C(new Scanner(System.in));\n   }\n\n   vect[] vs;\n   int N;\n   int oo = 987654321;\n\n   ArrayList<choice> cs;\n   choice[][] cg;\n\n   int MF;\n\n   int[] memo;\n   int[] next;\n\n   int go(int m)\n   {\n      if (m == MF)\n         return 0;\n      if (memo[m] != -1)\n         return memo[m];\n\n      // Try a new place\n      int res = oo;\n      int nxt = -1;\n\n      int i=0;\n      for (i=0; i<N; i++)\n      {\n         if (((1<<i)&m) == 0)\n            break;\n      }\n\n      for (int j=0; j<N; j++)\n      {\n         choice cc = cg[i][j];\n         if ((m&cc.m) > 0)\n            continue;\n\n         int r2 = cc.cost+go(m|cc.m);\n         if (r2 < res)\n         {\n            res = r2;\n            nxt = cc.index;\n         }\n      }\n\n      memo[m] = res;\n      next[m] = nxt;\n      return res;\n   }\n\n   public C(Scanner in)\n   {\n      vect vt = new vect(in.nextInt(), in.nextInt());\n      N = in.nextInt();\n      vs = new vect[N+1];\n      vs[N] = vt;\n      for (int i=0; i<N; i++)\n         vs[i] = new vect(in.nextInt(), in.nextInt());\n  \n      // Precompute all choices and masks\n      cs = new ArrayList<choice>();\n      cg = new choice[N][N];\n      for (int i=0; i<N; i++)\n      {\n         choice cc = new choice(cs.size(), 2*vs[i].dist(vt), 1<<i);\n         cc.add(i);\n         cs.add(cc);\n         cg[i][i] = cc;\n      }\n\n      for (int i=0; i<N; i++)\n      {\n         for (int j=i+1; j<N; j++)\n         {\n            int dist = vs[i].dist(vt);\n            dist += vs[i].dist(vs[j]);\n            dist += vs[j].dist(vt);\n            choice cc = new choice(cs.size(), dist, (1<<i)|(1<<j));\n            cc.add(i); cc.add(j);\n            cs.add(cc);\n            cg[i][j] = cc;\n            cg[j][i] = cc;\n         }\n      }\n\n      MF = (1<<N)-1;\n      next = new int[MF+1];\n      memo = new int[MF+1];\n\n      Arrays.fill(next, -1);\n      Arrays.fill(memo, -1);\n\n      int res = go(0);\n      System.out.println(res);\n\n      int m = 0;\n      StringBuilder sb = new StringBuilder();\n      while (m != -1)\n      {\n         //System.out.println(Integer.toBinaryString(m));\n         sb.append(0);\n         sb.append(' ');\n         int i = next[m];\n         if (i == -1)\n            break;\n         choice cc = cs.get(i);\n         for (int j : cc.iv)\n         {\n            sb.append(f(j));\n            sb.append(' ');\n         }\n         m = m|cc.m;\n      }\n      System.out.println(sb.toString().trim());\n   }\n\n   int f(int i)\n   {\n      if (i == N)\n         return 0;\n      return i+1;\n   }\n}\n\n\nclass choice\n{\n   int cost;\n   int m;\n   int index;\n   ArrayList<Integer> iv;\n\n   public choice(int ii, int c, int mm)\n   {\n      index = ii;\n      cost = c;\n      m = mm;\n      iv = new ArrayList<Integer>(2);\n   }\n\n   void add(int i)\n   {\n      iv.add(i);\n   }\n}\n\n\nclass vect\n{\n   int x, y;\n\n   public vect(int i, int j)\n   {\n      x=i; y=j;\n   }\n\n   int dist(vect rhs)\n   {\n      int xx = x-rhs.x;\n      int yy = y-rhs.y;\n      return xx*xx+yy*yy;\n   }\n}\n\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "//package round23;\n\nimport java.io.PrintWriter;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class A {\n\tprivate Scanner in;\n\tprivate PrintWriter out;\n//\tprivate String INPUT = add(\"a\", 100);\n\tprivate String INPUT = \"\";\n\t\n\tpublic void solve()\n\t{\n\t\tString str = in.next();\n\t\tint n = str.length();\n\t\tfor(int k = n - 1;k >= 1;k--){\n\t\t\tHashSet<String> set = new HashSet<String>();\n\t\t\tfor(int i = 0;i < str.length() - k + 1;i++){\n\t\t\t\tif(!set.add(str.substring(i, i + k))){\n\t\t\t\t\tout.println(k);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(0);\n\t}\n\t\n\tpublic void run() throws Exception\n\t{\n\t\tin = INPUT.isEmpty() ? new Scanner(System.in) : new Scanner(new StringReader(INPUT));\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t}\n\t\n\tpublic static String add(String str, int k)\n\t{\n\t\tStringBuilder mul = new StringBuilder(str);\n\t\tStringBuilder ret = new StringBuilder();\n\t\tfor(int i = k;i > 0;i >>= 1){\n\t\t\tif((i & 1) == 1)ret.append(mul);\n\t\t\tmul.append(mul);\n\t\t}\n\t\treturn ret.toString();\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew A().run();\n\t}\n\t\n\tprivate int ni() { return Integer.parseInt(in.next()); }\n\tprivate static void tr(Object... o) { System.out.println(o.length == 1 ? o[0] : Arrays.toString(o)); }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Rb_wahid\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        ASubtractions solver = new ASubtractions();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ASubtractions {\n        int sub(int a, int b) {\n            if (a % b == 0)\n                return a / b;\n            else return a / b + sub(b, a % b);\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int t = in.nextInt();\n            int a, b;\n\n            while (t-- > 0) {\n                a = in.nextInt();\n                b = in.nextInt();\n\n                out.println(sub(a, b));\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tprivate int n;\n\tprivate int m;\n\tprivate boolean[][] g;\n\tprivate long[][] dp;\n\tprivate int[] count;\n\tprivate int[] first;\n\n\tprivate void solve() throws IOException {\n\t\tn = nextInt();\n\t\tm = nextInt();\n\n\t\tg = new boolean[n][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = nextInt() - 1;\n\t\t\tint b = nextInt() - 1;\n\t\t\tg[a][b] = true;\n\t\t\tg[b][a] = true;\n\t\t}\n\n\t\tcount = new int[1 << n];\n\t\tfirst = new int[1 << n];\n\t\tdp = new long[1 << n][n];\n\t\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t\tcount[mask] = bitCount(mask);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (bit(i, mask) == 1) {\n\t\t\t\t\tfirst[mask] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif ((count[mask] == 1) && (bit(i, mask) == 1)) {\n\t\t\t\t\tdp[mask][i] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (g[j][i] && (count[mask] > 1) && (bit(i, mask) == 1)\n\t\t\t\t\t\t\t\t&& (first[mask] != i)) {\n\t\t\t\t\t\t\tdp[mask][i] += dp[mask ^ (1 << i)][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t\t\tif ((count[mask] >= 3) && (first[mask] != i)\n\t\t\t\t\t\t&& (g[i][first[mask]])) {\n\t\t\t\t\tans += dp[mask][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ans % 2 != 0) {\n\t\t\tthrow new RuntimeException(\"SHIT!!!\");\n\t\t}\n\t\tout.println(ans / 2);\n\t}\n\n\tprivate final int bit(int i, int mask) {\n\t\treturn (mask & (1 << i)) != 0 ? 1 : 0;\n\t}\n\n\tprivate final int bitCount(int mask) {\n\t\tint ret = 0;\n\t\twhile (mask != 0) {\n\t\t\tret++;\n\t\t\tmask -= mask & (-mask);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate BufferedReader in;\n\tprivate PrintWriter out;\n\tprivate StringTokenizer st;\n\n\tprivate Main() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\teat(\"\");\n\t\tsolve();\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tprivate void eat(String s) {\n\t\tst = new StringTokenizer(s);\n\t}\n\n\tString next() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\teat(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tfinal static int mod = 1_000_000_007;\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tSTDIN scan = new STDIN();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tint n = scan.nextInt();\n\t\tboolean even = true;\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ta[i] = scan.nextInt();\n\t\t\tfor(int j = 0; j < i; j++)\n\t\t\t\tif(a[i] < a[j]) even = !even;\n\t\t}\n\t\tint q = scan.nextInt();\n\t\twhile(q-- > 0) {\n\t\t\tint l = scan.nextInt(), r = scan.nextInt();\n\t\t\tint len = r - l + 1;\n\t\t\tint permutations = len * (len - 1) / 2;\n\t\t\tif(permutations % 2 != 0) even = !even;\n\t\t\tpw.println(even ? \"even\" : \"odd\");\n\t\t}\n\t\t\n\t\tpw.flush();\n\t}\n\t\t\n\tstatic class STDIN {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic STDIN() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tst = null;\n\t\t}\n\n\t\tboolean hasNext() throws Exception {\n\t\t\tif (!st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.hasMoreTokens();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws Exception {\n\t\t\treturn br.readLine();\n\t\t}\n\t}\n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.PrintWriter;\nimport java.util.*;\n\npublic class D {\n\n    static Scanner sc;\n    static PrintWriter out;\n\n    public static void main(String[] args) throws Exception {\n\n        sc = new Scanner(System.in);\n        out = new PrintWriter(System.out);\n        //int t = sc.nextInt();\n        for(int i=0; i<1; i++) {\n            solve();\n        }\n        out.flush();\n    }\n\n    static void solve() {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int k = sc.nextInt();\n        int[][] a = new int[n][m-1];\n        int[][] b = new int[n-1][m];\n        for(int i=0 ;i<n; i++) {\n            for(int j=0; j<m-1; j++) {\n                a[i][j] = sc.nextInt();\n            }\n        }\n        for(int i=0 ;i<n-1; i++) {\n            for(int j=0; j<m; j++) {\n                b[i][j] = sc.nextInt();\n            }\n        }\n\n        if(k % 2 == 1) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    if (j > 0)\n                        out.print(\" \");\n                    out.print(\"-1\");\n                }\n                out.println();\n            }\n            return;\n        }\n\n\n        int[][] prev = new int[n][m];\n        k /= 2;\n        for(int l=0; l<k; l++) {\n            int[][] next = new int[n][m];\n            for(int i=0; i<n; i++) {\n                for(int j=0; j<m; j++) {\n                    next[i][j] = Integer.MAX_VALUE;\n                    if(i>0) {\n                        next[i][j] = Math.min(next[i][j], prev[i-1][j] + b[i-1][j]);\n                    }\n                    if(i+1<n) {\n                        next[i][j] = Math.min(next[i][j], prev[i+1][j] + b[i][j]);\n                    }\n                    if(j>0) {\n                        next[i][j] = Math.min(next[i][j], prev[i][j-1] + a[i][j-1]);\n                    }\n                    if(j+1<m) {\n                        next[i][j] = Math.min(next[i][j], prev[i][j+1] + a[i][j]);\n                    }\n                }\n            }\n            prev = next;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (j > 0)\n                    out.print(\" \");\n                out.print(prev[i][j] * 2);\n            }\n            out.println();\n        }\n\n\n    }\n\n\n\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Sol122A {\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tString next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws Exception {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() throws Exception {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() throws Exception {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tvoid solve() throws Exception {\n\t\tlong x = nextLong();\n\t\tout.println((x % 4) * (x % 7) * (x % 74) * (x % 47) * (x % 44) * (x % 77) * (x % 444) * (x % 447) * (x % 474) * (x % 477) * (x % 744) * (x % 747) * (x % 774) * (x % 777) == 0 ? \"YES\" : \"NO\");\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Sol122A().run();\n\t}\n\n}\n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "\nimport java.util.Scanner;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author Madi\n */\npublic class A630 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        String s = sc.nextLine();\n        System.out.println(\"25\");\n    }\n}\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class R035CRetry {\n    public void debug(Object... objects) { System.err.println(Arrays.deepToString(objects)); }\n    public static final int INF = 987654321;\n    public static final long LINF = 987654321987654321L;\n    public static final double EPS = 1e-9;\n    \n    Scanner scanner;\n    PrintWriter out;\n    boolean[][] bss;\n    \n    public R035CRetry() {\n        try {\n            this.scanner = new Scanner(new File(\"input.txt\"));\n            this.out = new PrintWriter(\"output.txt\");\n        } catch(FileNotFoundException ex) { ex.printStackTrace(); }\n    }\n    \n    class Point implements Comparable<Point> {\n        int x, y, count;\n        Point(int x, int y) { this.x = x; this.y = y; }\n        public int hashCode() { return x * 17 + y; }\n        public boolean equals(Object o) {\n            if(!(o instanceof Point)) return false;\n            Point that = (Point)o;\n            return this.x == that.x && this.y == that.y;\n        }\n        public int compareTo(Point that) { return this.count - that.count; }\n        public String toString()  { return \"(\" + x + \", \" + y + \":\" + count + \")\"; }\n    }\n\n    \n    int[] dx = new int[] {  0, 0, -1, 1 };\n    int[] dy= new int[] { -1, 1,  0, 0 };\n    int n, m;\n    \n    Queue<Point> q;\n    \n    Point bfs() {\n        int max = -INF;\n        Point p = null;\n        while(!q.isEmpty()) {\n            Point cur = q.remove();\n            if(max < cur.count) { max = cur.count; p = cur; } \n            for(int i=0; i<dx.length; i++) {\n                int nx = cur.x + dx[i];\n                int ny = cur.y + dy[i];\n                if(nx < 0 || nx >= n) { continue; }\n                if(ny < 0 || ny >= m) { continue; }\n                Point np = new Point(nx, ny);\n                if(bss[nx][ny] ) { continue; } \n                np.count = cur.count+1;\n                bss[nx][ny] = true;\n                q.add(np);\n            }\n        }\n        return p;\n    }\n    \n    private void solve() {\n        this.n = scanner.nextInt();\n        this.m = scanner.nextInt();\n        this.bss = new boolean[n][m];\n        int k = scanner.nextInt();\n        q = new LinkedList<Point>();\n        for(int i=0; i<k; i++) {\n            int x = scanner.nextInt() - 1;\n            int y = scanner.nextInt() - 1;\n            Point init = new Point(x, y);\n            init.count = 1;\n            q.add(init);\n            bss[x][y] = true;\n        }\n        Point p = bfs();\n        out.println((p.x+1) + \" \" + (p.y+1));\n    }\n    \n    private void finish() { this.out.close(); }\n    \n    public static void main(String[] args) { \n        R035CRetry obj = new R035CRetry();\n        obj.solve();\n        obj.finish();\n    }\n}\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.*;\npublic class Ex{\n\tpublic static void main(String[] args) {\n       Scanner sc=new Scanner(System.in);       \n       int n=sc.nextInt();\n       int k=n;\n       int r=k;\n       int c=0;\n       while(n>0){\n       \t int rem=n%10;\n       \t if(rem==4 || rem==7){\n       \t \tc++;\n       \t \tn/=10;\n       \t }\n       \t else{\n       \t \tbreak;\n       \t }\n       }\n       int co=0;\n       while(k>0){\n       \tk/=10;\n       \tco++;\n       }\n       if(c==co){\n       \tSystem.out.println(\"YES\");\n       }\n       else if(r%4==0 || r%7==0 || r%47==0 || r%74==0 || r%477==0 || r%774==0 || r%747==0 || r%447==0 || r%474==0 || r%744==0){\n       \tSystem.out.println(\"YES\");\n       }\n       else{\n       \tSystem.out.println(\"NO\");\n       }\n\t}\n}", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.text.*;\nimport java.util.*;\n\npublic class A {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint t = scan.nextInt();\n\t\tList<Double> coords = new ArrayList<Double>();\n\t\twhile (n-- > 0) {\n\t\t\tdouble x = scan.nextDouble();\n\t\t\tdouble a = scan.nextDouble() / 2;\n\t\t\tcoords.add(x - a);\n\t\t\tcoords.add(x + a);\n\t\t}\n\t\tCollections.sort(coords);\n\t\tint count = 2;\n\t\tChoiceFormat f = new ChoiceFormat(\"-1#0|0#1|0<2\");\n\t\tfor (int i = 1; i < coords.size()-2; i+=2) {\n\t\t\tcount += new Integer(f.format(coords.get(i+1)-coords.get(i)-t));\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class mainA {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n    public static void main(String[] args) throws IOException {\n        solve();\n        out.close();\n    }\n    public static boolean[] was;\n    private static void solve() throws IOException{\n        int n=enter.nextInt();\n        int[] arr=new int[n];\n        was=new boolean[n];\n        for (int i = 0; i <n ; i++) {\n            arr[i]=enter.nextInt();\n        }\n        Arrays.sort(arr);\n        int ans=0;\n        for (int i = 0; i <n ; i++) {\n            if(was[i]) continue;\n            find(i, arr);\n            ans++;\n        }\n        out.println(ans);\n    }\n\n    public static void find (int num, int[] arr){\n        for (int i = num+1; i <arr.length ; i++) {\n            if(arr[i]%arr[num]==0) was[i]=true;\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import javafx.util.Pair;\n\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] arr = new int[n];\n        int chet = 0;\n        for (int i = 0; i < n; i++) {\n            arr[i]=scanner.nextInt();\n            for (int j = 0; j < i; j++) {\n                if (arr[j]>arr[i]) chet^=1;\n            }\n        }\n        n = scanner.nextInt();\n        for (int i = 0; i < n; i++) {\n            int l = scanner.nextInt();\n            int r = scanner.nextInt();\n            if ((((r-l+1)/2)&1)!=0){\n                chet^=1;\n            }\n            if (chet==1){\n                System.out.println(\"odd\");\n            }else{\n                System.out.println(\"even\");\n            }\n        }\n\n    }\n\n\n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n//****Use Integer Wrapper Class for Arrays.sort()****\npublic class AG1 {\n    public static void main(String[] Args){\n        FastReader scan=new FastReader();\n        int n=scan.nextInt();\n        int[] arr=new int[n];\n        for (int i = 0; i <n ; i++) {\n            arr[i]=scan.nextInt();\n        }\n        Arrays.sort(arr);\n        boolean[] done=new boolean[n];\n        int ans=0;\n        for(int i=0;i<n;i++){\n            if(!done[i]){\n                done[i]=true;\n                ans++;\n                for(int j=i+1;j<n;j++){\n                    if(arr[j]%arr[i]==0){\n                        done[j]=true;\n                    }\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\npublic class A\n{\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        long n=sc.nextLong();\n        if(n==0)\n        System.out.println(0);\n        else if(n%2==1)\n        System.out.println((n+1)/2);\n        else\n        System.out.println(n+1);\n    }\n}", "complexity": "constant", "problem": "0979_A", "from": "CODEFORCES", "tags": "math"}
{"src": "\n\nimport java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport java.math.BigInteger;\n\nimport static java.lang.Math.*;\n\n// Solution is at the bottom of code\n\npublic class ProblemC_008 implements Runnable{\n\t\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tBufferedReader in;\n\tOutputWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\t\n\tpublic static void main(String[] args){\n\t\tnew Thread(null, new ProblemC_008(), \"\", 128 * (1L << 20)).start();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid init() throws FileNotFoundException{\n\t\tLocale.setDefault(Locale.US);\n\t\t\n\t\tif (ONLINE_JUDGE){\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new OutputWriter(System.out);\n\t\t}else{\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new OutputWriter(\"output.txt\");\n\t\t}\n\t}\n\t\n\t////////////////////////////////////////////////////////////////\n\t\n\tlong timeBegin, timeEnd;\n\n\tvoid time(){\n\t\ttimeEnd = System.currentTimeMillis();\n\t\tSystem.err.println(\"Time = \" + (timeEnd - timeBegin));\n\t}\n\t\n\tvoid debug(Object... objects){\n\t\tif (ONLINE_JUDGE){\n\t\t\tfor (Object o: objects){\n\t\t\t\tSystem.err.println(o.toString());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tpublic void run(){\n\t\ttry{\n\t\t\ttimeBegin = System.currentTimeMillis();\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\t\n\t\t\tinit();\n\t\t\tsolve();\n\t\t\t\n\t\t\tout.close();\n\t\t\ttime();\n\t\t}catch (Exception e){\n\t\t\te.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tString delim = \" \";\n\t\n\tString readString() throws IOException{\n\t\twhile(!tok.hasMoreTokens()){\n\t\t\ttry{\n\t\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t\t}catch (Exception e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn tok.nextToken(delim);\n\t}\n\t\n\tString readLine() throws IOException{\n\t\treturn in.readLine();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tfinal char NOT_A_SYMBOL = '\\0';\n\t\n\tchar readChar() throws IOException{\n\t\tint intValue = in.read();\n\t\t\n\t\tif (intValue == -1){\n\t\t\treturn NOT_A_SYMBOL;\n\t\t}\n\t\t\n\t\treturn (char) intValue;\n\t}\n\t\n\tchar[] readCharArray() throws IOException{\n\t\treturn readLine().toCharArray();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tint readInt() throws IOException{\n\t\treturn Integer.parseInt(readString());\n\t}\n\t\n\tint[] readIntArray(int size) throws IOException{\n\t\tint[] array = new int[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readInt();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tlong readLong() throws IOException{\n\t\treturn Long.parseLong(readString());\n\t}\n\t\n\tlong[] readLongArray(int size) throws IOException{\n\t\tlong[] array = new long[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readLong();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\n\tdouble readDouble() throws IOException{\n\t\treturn Double.parseDouble(readString());\n\t}\n\t\n\tdouble[] readDoubleArray(int size) throws IOException{\n\t\tdouble[] array = new double[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readDouble();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tPoint readPoint() throws IOException{\n\t\treturn new Point(readInt(), readInt());\n\t}\n\t\n\tPoint[] readPointArray(int size) throws IOException{\n\t\tPoint[] array = new Point[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readPoint();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tclass OutputWriter extends PrintWriter{\n\n\t\tfinal int DEFAULT_PRECISION = 12;\n\t\t\n\t\tint precision;\n\t\tString format, formatWithSpace;\n\t\t\n\t\t{\n\t\t\tprecision = DEFAULT_PRECISION;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tpublic OutputWriter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\n\t\tpublic OutputWriter(String fileName) throws FileNotFoundException {\n\t\t\tsuper(fileName);\n\t\t}\n\t\t\n\t\tpublic int getPrecision() {\n\t\t\treturn precision;\n\t\t}\n\n\t\tpublic void setPrecision(int precision) {\n\t\t\tthis.precision = precision;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tprivate String createFormat(int precision){\n\t\t\treturn \"%.\" + precision + \"f\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void print(double d){\n\t\t\tprintf(format, d);\n\t\t}\n\t\t\n\t\tpublic void printWithSpace(double d){\n\t\t\tprintf(formatWithSpace, d);\n\t\t}\n\n\t\tpublic void printAll(double...d){\n\t\t\tfor (int i = 0; i < d.length - 1; ++i){\n\t\t\t\tprintWithSpace(d[i]);\n\t\t\t}\n\t\t\t\n\t\t\tprint(d[d.length - 1]);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void println(double d){\n\t\t\tprintlnAll(d);\n\t\t}\n\t\t\n\t\tpublic void printlnAll(double... d){\n\t\t\tprintAll(d);\n\t\t\tprintln();\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tint[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; \n\t\n\tboolean check(int index, int lim){\n\t\treturn (0 <= index && index < lim);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid solve() throws IOException{\n\t\tPoint bag = readPoint();\n\t\t\n\t\tint n = readInt();\n\t\t\n\t\tPoint[] points = new Point[n];\n\t\t\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tpoints[i] = readPoint();\n\t\t}\n\t\t\n\t\tint[] dist = new int[n];\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tint dx = points[i].x - bag.x;\n\t\t\tint dy = points[i].y - bag.y;\n\t\t\t\n\t\t\tdist[i] = dx * dx + dy * dy;\n\t\t}\n\t\t\n\t\tint[][] d = new int[n][n];\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tfor (int j = 0; j < n; ++j){\n\t\t\t\tint dx = points[i].x - points[j].x;\n\t\t\t\tint dy = points[i].y - points[j].y;\n\t\t\t\t\n\t\t\t\td[i][j] = dx * dx + dy * dy;\n\t\t\t\td[i][j] += dist[i] + dist[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] singleMasks = new int[n];\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tsingleMasks[i] = (1 << i);\n\t\t}\n\t\t\n\t\tint[][] doubleMasks = new int[n][n];\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tfor (int j = 0; j < n; ++j){\n\t\t\t\tdoubleMasks[i][j] = (singleMasks[i] | singleMasks[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint lim = (1 << n);\n\t\tint[] dp = new int[lim];\n\t\t\n\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\t\tdp[0] = 0;\n\t\t\n\t\tint[] p = new int[lim];\n\t\tArrays.fill(p, -1);\n\t\t\n\t\tfor (int mask = 0; mask < lim; ++mask){\n\t\t\tif (dp[mask] == Integer.MAX_VALUE){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint minBit = -1;\n\t\t\t\n\t\t\tfor (int bit = 0; bit < n; ++bit){\n\t\t\t\tif (checkBit(mask, bit)) continue;\n\t\t\t\t\n\t\t\t\tif (minBit == -1 || (dist[minBit] > dist[bit])){\n\t\t\t\t\tminBit = bit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (minBit == -1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int bit = 0; bit < n; ++bit){\n\t\t\t\tif (checkBit(mask, bit)) continue;\n\t\t\t\t\n\t\t\t\tint newMask = (mask | (1 << minBit) | (1 << bit));\n\t\t\t\t\n\t\t\t\tif (dp[newMask] > dp[mask] + d[minBit][bit]){\n\t\t\t\t\tdp[newMask] = dp[mask] + d[minBit][bit];\n\t\t\t\t\tp[newMask] = minBit * n + bit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(dp[lim-1]);\n\t\t\n\t\tint curMask = lim - 1;\n\t\twhile (p[curMask] != -1){\n\t\t\tout.print(\"0 \");\n\t\t\t\n\t\t\tint first = p[curMask] / n;\n\t\t\tint second = p[curMask] % n;\n\t\t\t\n\t\t\tout.print((first + 1) + \" \");\n\t\t\tcurMask ^= (1 << first);\n\t\t\t\n\t\t\tif (first != second){\n\t\t\t\tout.print((second + 1) + \" \");\n\t\t\t\tcurMask ^= (1 << second);\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(\"0\");\n\t}\n\n\tprivate boolean checkBit(int mask, int bitNumber) {\n\t\treturn (mask & (1 << bitNumber)) != 0;\n\t}\n\t\n\tboolean checkMask(int mask, int innerMask){\n\t\treturn (mask & innerMask) == innerMask;\n\t}\n}\n\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class A{\n\tpublic static BufferedReader k;\n\tpublic static BufferedWriter z;\n\t\n\n\t\n\tpublic static void main(String [] args)throws IOException{\n\t\tk = new BufferedReader(new InputStreamReader(System.in));\n\t\tz = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t\n\t\t\n\t        String[] dat = k.readLine().split(\" \");\n\n\t        long l = Long.parseLong(dat[0]);\n\t        long r = Long.parseLong(dat[1]);\n\t\t\t\n\t\t\tif(r-l<=1){\n\t\t\t\tz.write(-1+\"\\n\");\n\t\t\t}\n\t\t\telse if(r-l == 2){\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif((l&1)!=0){\n\t\t\t\t\tz.write(-1+\"\\n\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tz.write(l+\" \"+(l+1)+\" \"+r+\"\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif((l&1)==0){\n\t\t\t\t\tz.write(l+\" \"+(l+1)+\" \"+(l+2)+\"\\n\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tz.write((l+1)+\" \"+(l+2)+\" \"+(l+3)+\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\tz.flush();\n\n\t}\n\n}", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "/*\nIf you want to aim high, aim high\nDon't let that studying and grades consume you\nJust live life young\n******************************\nIf I'm the sun, you're the moon\nBecause when I go up, you go down\n*******************************\nI'm working for the day I will surpass you\nhttps://www.a2oj.com/Ladder16.html\n*/\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n   public class x1141F\n   {\n      public static void main(String omkar[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));  \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int[] arr = new int[N];\n         st = new StringTokenizer(infile.readLine());\n         for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n         HashMap<Long, ArrayList<Integer>> map = new HashMap<Long, ArrayList<Integer>>();\n         for(int r=0; r < N; r++)\n         {\n            long sum = 0L;\n            for(int i=r; i >= 0; i--)\n            {\n               sum += arr[i];\n               if(!map.containsKey(sum))\n                  map.put(sum, new ArrayList<Integer>());\n               map.get(sum).add(i);\n               map.get(sum).add(r);\n            }\n         }\n         ArrayList<Integer> res = new ArrayList<Integer>();\n         for(long key: map.keySet())\n         {\n            ArrayList<Integer> ls = map.get(key);\n            ArrayList<Integer> temp = new ArrayList<Integer>();\n            temp.add(ls.get(0));\n            temp.add(ls.get(1));\n            int r = ls.get(1);\n            for(int i=2; i < ls.size(); i+=2)\n               if(r < ls.get(i))\n               {\n                  r = ls.get(i+1);\n                  temp.add(ls.get(i));\n                  temp.add(ls.get(i+1));\n               }\n            if(res.size() < temp.size())\n               res = temp;\n         }\n         System.out.println(res.size()/2);\n         StringBuilder sb = new StringBuilder();\n         for(int i=0; i < res.size(); i+=2)\n         {\n            sb.append((1+res.get(i))+\" \"+(1+res.get(i+1)));\n            sb.append(\"\\n\");\n         }\n         System.out.print(sb);\n      }\n   }", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner read = new Scanner(System.in);\n        double a = (double)read.nextInt();\n        double v = (double)read.nextInt();\n        double l = (double)read.nextInt();\n        double d = (double)read.nextInt();\n        double w = (double)read.nextInt();\n        double t=0;\n        if(w>=v){\n            double d1=v*v/(2*a);\n            if(d1>l){\n                t+= Math.sqrt(2*l/a);\n            }\n            else{\n                t+= v/a + (l-d1)/v;\n            }\n        }\n        else{\n            double temp = (v-w)/a;\n            double d1 = v*v/(2*a);\n            double d2 = d - v*temp + a*temp*temp/2;\n            if(d1>d2){\n                double temp2 = Math.sqrt(2*a*d);\n                if(temp2<w){\n                    w=temp2;\n                    temp=(v-w)/a;\n                    t+= temp2/a;\n                }\n                else{\n                    double vx=Math.sqrt(v*v/2+a*d2);\n                    t+= (vx/a) + ((vx-w)/a);\n                }\n            }\n            else{\n                t+= (v/a) + ((d2-d1)/v) + (temp);\n            }\n            double d3 = d + w*temp + a*temp*temp/2;\n            if(d3>l){\n                t+= (-w+Math.sqrt(w*w+2*a*(l-d)))/a;\n            }\n            else{\n                t+= (temp) + ((l-d3)/v);\n            }\n        }\n        System.out.printf(\"%.6f\", t);\n        read.close();\n    }\n}", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.*;\n\npublic class Main {\n    static class Node implements Comparable<Node>{\n        public int l,r;\n        public long s;\n        Node(int l,int r,long s){\n            this.l=l;\n            this.r=r;\n            this.s=s;\n        }\n        public int compareTo(Node o) {\n            if(o.s==s){\n                if(r>o.r) return 1;\n                else if(r==o.r) {\n                    return 0;\n                }\n                else return -1;\n            } else if(s>o.s){\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n    }\n    static long[] sum=new long[1550];\n    public static void main(String[] args) {\n        TreeMap<Long, ArrayList<Node> > mp = new TreeMap<>();\n        Scanner cin = new Scanner(System.in);\n        int N=cin.nextInt();\n        for(int i=1;i<=N;i++){\n            int x=cin.nextInt();\n            sum[i]=sum[i-1]+x;\n        }\n        //System.out.println(\"here\");\n        ArrayList<Node> arr = new ArrayList<>();\n        for(int l=1;l<=N;l++){\n            for(int r=l;r<=N;r++){\n                arr.add(new Node(l,r,sum[r]-sum[l-1]));\n            }\n        }\n        Collections.sort(arr);\n        for(int i=0;i<arr.size();i++){\n            ArrayList<Node> a=mp.get(arr.get(i).s);\n            if(a==null) {\n                a=new ArrayList<>();\n                mp.put(arr.get(i).s,a);\n            }\n            a.add(arr.get(i));\n        }\n        int mx=-1;\n        long mxv=-1;\n        Iterator<Long> it=mp.keySet().iterator();\n        while(it.hasNext()){\n            int ans=0,t=0;\n            long v=it.next();\n            ArrayList<Node> vec= mp.get(v);\n            for(int i=0;i<vec.size();i++){\n                if(t<vec.get(i).l){\n                    ans++;\n                    t=vec.get(i).r;\n                }\n            }\n           //\n            if(ans>mx){\n                mx=ans;\n                mxv=v;\n               // System.out.println(mxv);\n            }\n        }\n        ArrayList<Node> vec=mp.get(mxv);\n        System.out.println(mx);\n        int t=0;\n        for(int i=0;i<vec.size();i++){\n\n           // System.out.println(vec.get(i).l+\" \"+vec.get(i).r);\n          // System.out.println(\"h\");\n            if(t<vec.get(i).l){\n                System.out.println(vec.get(i).l+\" \"+vec.get(i).r);\n                t=vec.get(i).r;\n            }\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A\n{\n\tString line;\n\tStringTokenizer inputParser;\n\tBufferedReader is;\n\tFileInputStream fstream;\n\tDataInputStream in;\n\t\n\tvoid openInput(String file)\n\t{\n\n\t\tif(file==null)is = new BufferedReader(new InputStreamReader(System.in));//stdin\n\t\telse\n\t\t{\n\t\t\ttry{\n\t\t\n\t\t\t\t\n\t\t\tfstream = new FileInputStream(file);\n\t\t\tin = new DataInputStream(fstream);\n\t\t\tis = new BufferedReader(new InputStreamReader(in));\n\t\t\t}catch(Exception e)\n\t\t\t{\n\t\t\t\tSystem.err.println(e);\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\tvoid readNextLine()\n\t{\n\t\ttry {\n\t\t\tline = is.readLine();\n\t\t\tinputParser = new StringTokenizer(line, \" \");\n\t\t\t//System.err.println(\"Input: \" + line);\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Unexpected IO ERROR: \" + e);\n\t\t}\t\n\t\t\n\t}\n\t\n\tint NextInt()\n\t{\n\t\tString n = inputParser.nextToken();\n\t\tint val = Integer.parseInt(n);\n\t\t\n\t\t//System.out.println(\"I read this number: \" + val);\n\t\treturn val;\n\t}\n\t\n\tString NextString()\n\t{\n\t\tString n = inputParser.nextToken();\n\t\treturn n;\n\t}\n\t\n\tvoid closeInput()\n\t{\n\t\ttry {\n\t\t\tis.close();\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Unexpected IO ERROR: \" + e);\n\t\t}\n\t\t\t\n\t}\n\t\n\t\n\tpublic static void main(String [] argv)\n\t{\n\t\tString filePath=null;\n\t\tif(argv.length>0)filePath=argv[0];\n\t\tA a = new A(filePath);\n\t}\n\t\n\tpublic A(String inputFile)\n\t{\n\t\topenInput(inputFile);\n\t\t\n\t\treadNextLine();\n\t\tString s=line;\n\t\tint ret=0;\n\t\tfor(int i=0; i<s.length(); i++)\n\t\t{\n\t\t\tfor(int j=i+1; j<s.length()+1; j++)\n\t\t\t{\n\t\t\t\tString a=s.substring(i,\tj);\n\t\t\t\tif(s.indexOf(a, i+1)>-1)ret=Math.max(ret, a.length());\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ret);\n\t}\n\t\n}\n\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "/*\nWritten by Kabir Kanha Arora\n@kabirkanha\n */\n\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] arr = new int[2 * n];\n        for (int i = 0; i < 2 * n; ++i)\n            arr[i] = scanner.nextInt();\n        int ans = 0;\n        for (int i = 0; i < 2 * n; i += 2) {\n            for (int j = i + 1; j < 2 * n; ++j) {\n                if (arr[i] == arr[j]) {\n                    int rpos = j;\n                    while (rpos - i > 1) {\n                        int temp = arr[rpos - 1];\n                        arr[rpos - 1] = arr[rpos];\n                        arr[rpos] = temp;\n                        --rpos;\n                        ++ans;\n                    }\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}\n\n\t \t\t\t    \t  \t     \t\t  \t\t\t\t\t", "complexity": "quadratic", "problem": "0995_B", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.text.DecimalFormat;\nimport java.util.*;\n\npublic class Main {\n\n    public static final DecimalFormat DF_3 = new DecimalFormat(\"0.000\");\n    private static final long MOD = 1000000007;\n\n\n    static int[] readArray(int size, InputReader in, boolean subOne) {\n        int[] a = new int[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = in.nextInt() + (subOne ? -1 : 0);\n        }\n        return a;\n    }\n\n    static long[] readLongArray(int size, InputReader in) {\n        long[] a = new long[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = in.nextLong();\n        }\n        return a;\n    }\n\n    static void sortArray(int[] a) {\n        Random random = new Random();\n\n        for (int i = 0; i < a.length; i++) {\n            int randomPos = random.nextInt(a.length);\n            int t = a[i];\n            a[i] = a[randomPos];\n            a[randomPos] = t;\n        }\n        Arrays.sort(a);\n    }\n\n    private static long[] allInvs(int n, long mod) {\n        long[] inv = new long[n + 1];\n        inv[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            inv[i] = subMod(mod, (mod / i) * inv[(int) (mod % i)] % mod, mod);\n        }\n        return inv;\n\n    }\n\n    private static long subMod(long x, long y, long mod) {\n        long res = x - y;\n        if (res < 0) {\n            return res + mod;\n        }\n        return res;\n    }\n\n    private static long fastPow(long x, long y, long mod) {\n        if (x == 1) {\n            return 1;\n        }\n        if (y == 0) {\n            return 1;\n        }\n        long p = fastPow(x, y / 2, mod) % mod;\n        p = p * p % mod;\n        if (y % 2 == 1) {\n            p = p * x % mod;\n        }\n        return p;\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n//        InputReader in = new InputReader(new FileInputStream(\"input.txt\"));\n//        PrintWriter out = new PrintWriter(new BufferedOutputStream(new FileOutputStream(\"milkvisits.out\")));\n//\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n//        long start = System.currentTimeMillis();\n        int n = in.nextInt();\n        long mod = in.nextLong();\n        long[] invs = allInvs(n + 3, mod);\n        long[] facts = new long[n + 2];\n        facts[0] = 1;\n        long[] invFacts = new long[n + 2];\n        invFacts[0] = 1;\n        for (int i = 1; i < n + 2; i++) {\n            facts[i] = (facts[i - 1] * i) % mod;\n            invFacts[i] = (invFacts[i - 1] * invs[i]) % mod;\n        }\n        long[] pow2 = new long[n+3];\n        pow2[0] = 1;\n        for (int i = 1; i < n+3; i++) {\n            pow2[i] = pow2[i-1] * 2 % mod;\n        }\n\n        long[][] dp = new long[n + 2][n + 2];\n        for (int i = 2; i <= n + 1; i++) {\n            dp[i][1] = invFacts[i - 1] * pow2[i - 2] % mod;\n            for (int k = 2; k <= n; k++) {\n                for (int j = i - 2; j >= 1; j--) {\n                    dp[i][k] = (dp[i][k] + dp[j][k - 1] * pow2[ i - j - 2] % mod * invFacts[i - j - 1] % mod) % mod;\n                }\n            }\n        }\n\n        long ans = 0;\n        for (int k = 1; k <= n; k++) {\n\n            ans = (ans + dp[n + 1][k] * facts[n - k + 1] % mod) % mod;\n        }\n        out.println(ans);\n\n        out.close();\n    }\n\n    private static void outputArray(List<Long> ans, PrintWriter out, boolean addOne) {\n        StringBuilder str = new StringBuilder();\n        for (int j = 0; j < ans.size(); j++) {\n            long i = ans.get(j);\n            long an = i + (addOne ? 1 : 0);\n            str.append(an);\n            if (j < ans.size() - 1) {\n                str.append(' ');\n            }\n        }\n        out.println(str);\n//        out.flush();\n    }\n\n    private static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextString() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() {\n            return next().charAt(0);\n        }\n\n        public String nextWord() {\n            return next();\n        }\n\n        private List<Integer>[] readTree(int n) {\n            return readGraph(n, n - 1);\n        }\n\n        private List<Integer>[] readGraph(int n, int m) {\n            List<Integer>[] result = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < m; i++) {\n                int u = nextInt() - 1;\n                int v = nextInt() - 1;\n                result[u].add(v);\n                result[v].add(u);\n            }\n            return result;\n        }\n\n    }\n}", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "//package educational.round67;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class G {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), m = ni(), K = ni(), C = ni(), D = ni();\n\t\tint[] a = na(K);\n\t\tint[] from = new int[m];\n\t\tint[] to = new int[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfrom[i] = ni() - 1;\n\t\t\tto[i] = ni() - 1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\tList<Edge> es = new ArrayList<>();\n\t\t\n\t\tint time = 100;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < time-1;j++){\n\t\t\t\tes.add(new Edge(i*time+j, i*time+j+1, 99, C));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int e : g[i]){\n\t\t\t\tfor(int j = 0;j < time-1;j++){\n\t\t\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\t\t\tes.add(new Edge(i*time+j, e*time+j+1, 1, C+D*(2*k+1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint src = time*n, sink = src+1;\n\t\tfor(int i = 0;i < K;i++){\n\t\t\tes.add(new Edge(src, (a[i]-1)*time+0, 1, 0));\n\t\t}\n\t\tfor(int i = 0;i < time;i++){\n\t\t\tes.add(new Edge(0*time+i, sink, 99, 0));\n\t\t}\n\t\t\n\t\tout.println(solveMinCostFlowWithSPFA(compileWD(sink+1, es), src, sink, 99));\n\t}\n\t\n\tpublic static class Edge\n\t{\n\t\tpublic int from, to;\n\t\tpublic int capacity;\n\t\tpublic int cost;\n\t\tpublic int flow;\n\t\tpublic Edge complement;\n\t\t// public int iniflow;\n\t\t\n\t\tpublic Edge(int from, int to, int capacity, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.capacity = capacity;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\t\n\tpublic static Edge[][] compileWD(int n, List<Edge> edges)\n\t{\n\t\tEdge[][] g = new Edge[n][];\n\t\t// cloning\n\t\tfor(int i = edges.size()-1;i >= 0;i--){\n\t\t\tEdge origin = edges.get(i);\n\t\t\tEdge clone = new Edge(origin.to, origin.from, origin.capacity, -origin.cost);\n\t\t\tclone.flow = origin.capacity;\n\t\t\tclone.complement = origin;\n\t\t\torigin.complement = clone;\n\t\t\tedges.add(clone);\n\t\t}\n\t\t\n\t\tint[] p = new int[n];\n\t\tfor(Edge e : edges)p[e.from]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new Edge[p[i]];\n\t\tfor(Edge e : edges)g[e.from][--p[e.from]] = e;\n\t\treturn g;\n\t}\n\n\t// NOT VERIFIED\n\tpublic static Edge[][] compileWU(int n, List<Edge> edges)\n\t{\n\t\tEdge[][] g = new Edge[n][];\n\t\t// cloning\n\t\tfor(int i = edges.size()-1;i >= 0;i--){\n\t\t\tEdge origin = edges.get(i);\n\t\t\tEdge back = new Edge(origin.to, origin.from, origin.capacity, origin.cost);\n\t\t\tedges.add(back);\n\t\t}\n\t\tfor(int i = edges.size()-1;i >= 0;i--){\n\t\t\tEdge origin = edges.get(i);\n\t\t\tEdge clone = new Edge(origin.to, origin.from, origin.capacity, -origin.cost);\n\t\t\tclone.flow = origin.capacity;\n\t\t\tclone.complement = origin;\n\t\t\torigin.complement = clone;\n\t\t\tedges.add(clone);\n\t\t}\n\t\t\n\t\tint[] p = new int[n];\n\t\tfor(Edge e : edges)p[e.from]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new Edge[p[i]];\n\t\tfor(Edge e : edges)g[e.from][--p[e.from]] = e;\n\t\treturn g;\n\t}\t\n\n\t\n\tpublic static class DQ {\n\t\tpublic int[] q;\n\t\tpublic int n;\n\t\tprotected int pt, ph;\n\t\t\n\t\tpublic DQ(int n){ this.n = Integer.highestOneBit(n)<<1; q = new int[this.n]; pt = ph = 0; }\n\t\t\n\t\tpublic void addLast(int x){ q[ph] = x; ph = ph+1&n-1; }\n\t\tpublic void addFirst(int x){ pt = pt+n-1&n-1; q[pt] = x; }\n\t\tpublic int pollFirst(){ int ret = q[pt]; pt = pt+1&n-1; return ret; }\n\t\tpublic int pollLast(){ ph = ph+n-1&n-1; int ret = q[ph]; return ret; }\n\t\tpublic int getFirst(){ return q[pt]; }\n\t\tpublic int getFirst(int k){ return q[pt+k&n-1]; }\n\t\tpublic int getLast(){ return q[ph+n-1&n-1]; }\n\t\tpublic int getLast(int k){ return q[ph+n-k-1&n-1]; }\n\t\tpublic void clear(){ pt = ph = 0; }\n\t\tpublic int size(){ return ph-pt+n&n-1; }\n\t\tpublic boolean isEmpty(){ return ph==pt; }\n\t}\n\n\t\n\tpublic static long solveMinCostFlowWithSPFA(Edge[][] g, int source, int sink, long all)\n\t{\n\t\tint n = g.length;\n\t\tlong mincost = 0;\n\t\t\n\t\tfinal int[] d = new int[n];\n\t\tDQ q = new DQ(n);\n\t\tboolean[] inq = new boolean[n];\n\t\twhile(all > 0){\n\t\t\t// shortest path src->sink\n\t\t\tEdge[] inedge = new Edge[n];\n\t\t\tArrays.fill(d, Integer.MAX_VALUE / 2);\n\t\t\td[source] = 0;\n\t\t\tq.addLast(source);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint cur = q.pollFirst();\n\t\t\t\tinq[cur] = false;\n\t\t\t\tfor(Edge ne : g[cur]){\n\t\t\t\t\tif(ne.capacity - ne.flow > 0){\n\t\t\t\t\t\tint nd = d[cur] + ne.cost;\n\t\t\t\t\t\tif(d[ne.to] > nd){\n\t\t\t\t\t\t\tinedge[ne.to] = ne;\n\t\t\t\t\t\t\td[ne.to] = nd;\n\t\t\t\t\t\t\tif(!inq[ne.to]){\n\t\t\t\t\t\t\t\tq.addLast(ne.to);\n\t\t\t\t\t\t\t\tinq[ne.to] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(inedge[sink] == null)break;\n\t\t\t\n\t\t\tlong minflow = all;\n\t\t\tlong sumcost = 0;\n\t\t\tfor(Edge e = inedge[sink];e != null;e = inedge[e.from]){\n\t\t\t\tif(e.capacity - e.flow < minflow)minflow = e.capacity - e.flow;\n\t\t\t\tsumcost += e.cost;\n\t\t\t}\n\t\t\tmincost += minflow * sumcost;\n\t\t\tfor(Edge e = inedge[sink];e != null;e = inedge[e.from]){\n\t\t\t\te.flow += minflow;\n\t\t\t\te.complement.flow -= minflow;\n\t\t\t}\n\t\t\t\n\t\t\tall -= minflow;\n\t\t}\n\t\treturn mincost;\n\t}\n\n\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new G().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "cubic", "problem": "1187_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ATailouloute\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        QuickScanner in = new QuickScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, QuickScanner in, PrintWriter out) {\n            long n = in.nextLong();\n            out.println(IntegerUtils.pow(5L, n, 100));\n        }\n\n    }\n\n    static class QuickScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        InputStream is;\n\n        public QuickScanner(InputStream stream) {\n            is = stream;\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static long pow(long a, long base, long mod) {\n            if (base == 0) return 1;\n            if (base == 1) return a;\n            if ((base & 1) == 1)\n                return (a * pow(a, base - 1, mod)) % mod;\n            return pow((a * a) % mod, base / 2, mod);\n        }\n\n    }\n}\n\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class C {\n\n    static int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n\n        MyScanner in = new MyScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        char prev = ' ';\n\n        // index, maxNumOfIntents -> count\n        int[][] dp = new int[n+1][n+2];\n\n        dp[0][0] = 1;\n        for(int i=0;i<n;++i){\n            char ch = in.next().charAt(0);\n            if(prev == 's'){\n                int sum = 0;\n                for(int j=n;j>=0;--j){\n                    sum = (sum + dp[i-1][j]) % MOD;\n                    dp[i][j] = sum;\n                }\n            }else if(prev == 'f'){\n                for(int j=0;j<n;++j){\n                    dp[i][j+1] = dp[i-1][j];\n                }\n            }\n\n            prev = ch;\n        }\n\n        int result = 0;\n        for(int i=0;i<=n;++i){\n            result = (result + dp[n-1][i]) % MOD;\n        }\n\n\n        out.println(result);\n        out.close();\n\n    }\n\n\n    // -----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n    // --------------------------------------------------------\n\n}", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class thing {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\t\n\t\tString s = in.next();\n\t\t\n\t\tint[][] count = new int[m][m];\n\t\tint[] dp = new int[1 << m];\n\t\t\n\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\t\tdp[0] = 0;\n\t\t\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tint a = s.charAt(i)-'a';\n\t\t\tint b = s.charAt(i-1)-'a';\n\t\t\tcount[a][b]++;\n\t\t\tcount[b][a]++;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < (1 << m); i++) {\n\t\t\t\n\t\t\tint pos = set_bits(i);\n\t\t\t\n\t\t\tfor(int j = 0; (i >> j) != 0; j++) {\n\t\t\t\t\n\t\t\t\tif(((i >> j) & 1) == 0) continue;\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\t\n\t\t\t\tfor(int mask = i, y = 0; y < m; mask >>= 1, y++) {\n\t\t\t\t\tif(y == j) continue;\n\t\t\t\t\tif((mask & 1) == 1) sum += count[j][y];\n\t\t\t\t\telse sum -= count[j][y];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint calc = dp[i-(1<<j)] + pos*sum;\n\t\t\t\t\n\t\t\t\tdp[i] = Math.min(dp[i], calc);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(dp[(1 << m)-1]);\n\t\t\n\t}\n\t\n\tpublic static int set_bits(int n) { \n\t\tint count = 0; \n\t\twhile (n > 0) {\n\t\t\tcount += n & 1;\n\t\t\tn >>= 1; \n\t\t}\n\t\treturn count;\n\t}\n\n}", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tfinal String filename = new String(\"B\").toLowerCase();\n\n\tint n;\n\tint r, c;\n\n\tvoid solve() throws Exception {\n\t\tn = nextInt();\n\n\t\tr = nextInt() - 1;\n\t\tc = nextInt() - 1;\n\t\tlong count = nextLong();\n\n\t\tlong left = -1, right = n * 2L;\n\n\t\twhile (left < right - 1) {\n\t\t\tlong mid = (left + right) / 2;\n\n\t\t\tif (getSq(n, r, c, mid) >= count) {\n\t\t\t\tright = mid;\n\t\t\t} else {\n\t\t\t\tleft = mid;\n\t\t\t}\n\t\t}\n\t\t\n//\t\tfor (int i = 0; i <= 10; i++) {\n//\t\t\tSystem.err.println(getSq(n, r, c, i));\n//\t\t}\n\t\t\n\t\tout.println(right);\n\t}\n\t\n\tlong getSq(int n, int x, int y, long size) {\n\t\tlong cur = (size + 1) * (size + 1) + size * size;\n\t\t\n\t\tcur -= get(x + size - (n - 1));\n\t\tcur -= get(y + size - (n - 1));\n\t\tcur -= get(-(x - size));\n\t\tcur -= get(-(y - size));\n\t\t\n\t\tcur += getCorner((x + 1) + (y + 1) - (size + 1));\n\t\tcur += getCorner((x + 1) + (n - y) - (size + 1));\n\t\tcur += getCorner((n - x) + (y + 1) - (size + 1));\n\t\tcur += getCorner((n - x) + (n - y) - (size + 1));\n\t\t\n\t\treturn cur;\n\t}\n\t\n\tprivate long getCorner(long min) {\n\t\tif (min >= 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tmin = -min;\n\t\treturn min * (min + 1) / 2;\n\t}\n\n\tlong get(long a) {\n\t\tif (a <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn a * a;\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t// out = new PrintWriter(\"output.txt\");\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tString nextToken() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew B().run();\n\t}\n\n}\n", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "import java.awt.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n\npublic class B implements Runnable{\n\n    private final static Random rnd = new Random();\n\n    // SOLUTION!!!\n    // HACK ME PLEASE IF YOU CAN!!!\n    // PLEASE!!!\n    // PLEASE!!!\n    // PLEASE!!!\n\n    int n;\n\n    private void solve() {\n        this.query = 0;\n\n        this.n = readInt();\n\n        int left1 = 0;\n\n        int l = 1, r = n;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            int answer = getAnswer(m, 1, n, n);\n\n            if (answer < 2) {\n                r = m - 1;\n            } else {\n                left1 = m;\n                l = m + 1;\n            }\n        }\n\n        int left2 = left1;\n\n        l = left1 + 1;\n        r = n;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            int answer = getAnswer(m, 1, n, n);\n\n            if (answer < 1) {\n                r = m - 1;\n            } else {\n                left2 = m;\n                l = m + 1;\n            }\n        }\n\n        int right2 = n + 1;\n\n        l = 1;\n        r = n;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            int answer = getAnswer(1, 1, m, n);\n\n            if (answer < 2) {\n                l = m + 1;\n            } else {\n                right2 = m;\n                r = m - 1;\n            }\n        }\n\n        int right1 = right2;\n\n        l = 1;\n        r = right2 - 1;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            int answer = getAnswer(1, 1, m, n);\n\n            if (answer < 1) {\n                l = m + 1;\n            } else {\n                right1 = m;\n                r = m - 1;\n            }\n        }\n\n        int bottom1 = 0;\n\n        l = 1;\n        r = n;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            int answer = getAnswer(1, m, n, n);\n\n            if (answer < 2) {\n                r = m - 1;\n            } else {\n                bottom1 = m;\n                l = m + 1;\n            }\n        }\n\n        int bottom2 = bottom1;\n\n        l = bottom1 + 1;\n        r = n;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            int answer = getAnswer(1, m, n, n);\n\n            if (answer < 1) {\n                r = m - 1;\n            } else {\n                bottom2 = m;\n                l = m + 1;\n            }\n        }\n\n        int top2 = n + 1;\n\n        l = 1;\n        r = n;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            int answer = getAnswer(1, 1, n, m);\n\n            if (answer < 2) {\n                l = m + 1;\n            } else {\n                top2 = m;\n                r = m - 1;\n            }\n        }\n\n        int top1 = top2;\n\n        l = 1;\n        r = top2 - 1;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            int answer = getAnswer(1, 1, n, m);\n\n            if (answer < 1) {\n                l = m + 1;\n            } else {\n                top1 = m;\n                r = m - 1;\n            }\n        }\n\n        int ansLeftRightMask = -1, ansBottomTopMask = -1;\n        long answerS = 2L * n * n;\n\n        for (int leftRightMask = 0; leftRightMask < 4; ++leftRightMask) {\n            int left = (checkBit(leftRightMask, 0) ? left1 : left2);\n            int right = (checkBit(leftRightMask, 1) ? right1 : right2);\n\n            for (int bottomTopMask = 0; bottomTopMask < 4; ++bottomTopMask) {\n                int bottom = (checkBit(bottomTopMask, 0) ? bottom1 : bottom2);\n                int top = (checkBit(bottomTopMask, 1) ? top1 : top2);\n\n                int curTry = getAnswer(left, bottom, right, top);\n                if (curTry == 1) {\n                    long s = (right - left + 1L) * (top - bottom + 1L);\n                    if (s < answerS) {\n                        answerS = s;\n                        ansLeftRightMask = leftRightMask;\n                        ansBottomTopMask = bottomTopMask;\n                    }\n                }\n            }\n        }\n\n        int left = (checkBit(ansLeftRightMask, 0) ? left1 : left2);\n        int right = (checkBit(ansLeftRightMask, 1) ? right1 : right2);\n        int bottom = (checkBit(ansBottomTopMask, 0) ? bottom1 : bottom2);\n        int top = (checkBit(ansBottomTopMask, 1) ? top1 : top2);\n\n        printAnswer(left, bottom, right, top,\n                left1 + left2 - left, bottom1 + bottom2 - bottom,\n                right1 + right2 - right, top1 + top2 - top);\n    }\n\n    private void printAnswer(int... values) {\n        printQuery(\"!\", values);\n    }\n\n    private void printQuery(String sign, int... values) {\n        out.print(sign);\n        for (int value : values) {\n            out.print(\" \" + value);\n        }\n        out.println();\n        out.flush();\n    }\n\n    int query = 0;\n    final int MAX_QUERY = 200;\n\n    private int getAnswer(int left, int bottom, int right, int top) {\n        if (left < 1 || right > n) {\n            while (true);\n        }\n\n        if (bottom < 1 || top > n) {\n            throw new RuntimeException();\n        }\n\n        if (left > right || bottom > top) {\n            return 0;\n        }\n\n        if (query == MAX_QUERY) {\n            throw new RuntimeException();\n        }\n\n        ++query;\n\n        printQuery(\"?\",  left, bottom, right, top);\n\n        int answer = readInt();\n        return answer;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private final static boolean FIRST_INPUT_STRING = false;\n    private final static boolean MULTIPLE_TESTS = true;\n    private final static boolean INTERACTIVE = true;\n    private final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    private final static int MAX_STACK_SIZE = 128;\n\n    private final static boolean OPTIMIZE_READ_NUMBERS = false;\n\n    /////////////////////////////////////////////////////////////////////\n\n    public void run(){\n        try{\n            timeInit();\n            Locale.setDefault(Locale.US);\n\n            init();\n\n            if (ONLINE_JUDGE) {\n                solve();\n            } else {\n                do {\n                    try {\n                        timeInit();\n                        solve();\n                        time();\n\n                        out.println();\n                    } catch (NumberFormatException e) {\n                        break;\n                    } catch (NullPointerException e) {\n                        if (FIRST_INPUT_STRING) break;\n                        else throw e;\n                    }\n                } while (MULTIPLE_TESTS);\n            }\n\n            out.close();\n            time();\n        }catch (Exception e){\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private BufferedReader in;\n    private OutputWriter out;\n    private StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args){\n        new Thread(null, new B(), \"\", MAX_STACK_SIZE * (1L << 20)).start();\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private void init() throws FileNotFoundException{\n        Locale.setDefault(Locale.US);\n\n        if (INTERACTIVE || ONLINE_JUDGE){\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new OutputWriter(System.out);\n        }else{\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new OutputWriter(\"output.txt\");\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    private long timeBegin;\n\n    private void timeInit() {\n        this.timeBegin = System.currentTimeMillis();\n    }\n\n    private void time(){\n        long timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    private void debug(Object... objects){\n        if (ONLINE_JUDGE){\n            for (Object o: objects){\n                System.err.println(o.toString());\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private String delim = \" \";\n\n    private String readLine() {\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private String readString() {\n        try {\n            while(!tok.hasMoreTokens()){\n                tok = new StringTokenizer(readLine());\n            }\n\n            return tok.nextToken(delim);\n        } catch (NullPointerException e) {\n            return null;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private final char NOT_A_SYMBOL = '\\0';\n\n    private char readChar() {\n        try {\n            int intValue = in.read();\n\n            if (intValue == -1){\n                return NOT_A_SYMBOL;\n            }\n\n            return (char) intValue;\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private char[] readCharArray() {\n        return readLine().toCharArray();\n    }\n\n    private char[][] readCharField(int rowsCount) {\n        char[][] field = new char[rowsCount][];\n        for (int row = 0; row < rowsCount; ++row) {\n            field[row] = readCharArray();\n        }\n\n        return field;\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private long optimizedReadLong() {\n        long result = 0;\n        boolean started = false;\n        while (true) {\n            try {\n                int j = in.read();\n                if (-1 == j) {\n                    if (started) return result;\n                    throw new NumberFormatException();\n                }\n\n                if ('0' <= j && j <= '9') {\n                    result = result * 10 + j - '0';\n                    started = true;\n                } else if (started) {\n                    return result;\n                }\n            } catch (IOException e) {\n                throw new RuntimeIOException(e);\n            }\n        }\n    }\n\n    private int readInt() {\n\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Integer.parseInt(readString());\n        } else {\n            return (int) optimizedReadLong();\n        }\n    }\n\n    private int[] readIntArray(int size) {\n        int[] array = new int[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readInt();\n        }\n\n        return array;\n    }\n\n    private int[] readSortedIntArray(int size) {\n        Integer[] array = new Integer[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = readInt();\n        }\n        Arrays.sort(array);\n\n        int[] sortedArray = new int[size];\n        for (int index = 0; index < size; ++index) {\n            sortedArray[index] = array[index];\n        }\n\n        return sortedArray;\n    }\n\n    private int[] readIntArrayWithDecrease(int size) {\n        int[] array = readIntArray(size);\n\n        for (int i = 0; i < size; ++i) {\n            array[i]--;\n        }\n\n        return array;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private int[][] readIntMatrix(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArray(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    private int[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArrayWithDecrease(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private long readLong() {\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Long.parseLong(readString());\n        } else {\n            return optimizedReadLong();\n        }\n    }\n\n    private long[] readLongArray(int size) {\n        long[] array = new long[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readLong();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private double readDouble() {\n        return Double.parseDouble(readString());\n    }\n\n    private double[] readDoubleArray(int size) {\n        double[] array = new double[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readDouble();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private BigInteger readBigInteger() {\n        return new BigInteger(readString());\n    }\n\n    private BigDecimal readBigDecimal() {\n        return new BigDecimal(readString());\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private Point readPoint() {\n        int x = readInt();\n        int y = readInt();\n        return new Point(x, y);\n    }\n\n    private Point[] readPointArray(int size) {\n        Point[] array = new Point[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readPoint();\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private List<Integer>[] readGraph(int vertexNumber, int edgeNumber) {\n        @SuppressWarnings(\"unchecked\")\n        List<Integer>[] graph = new List[vertexNumber];\n\n        for (int index = 0; index < vertexNumber; ++index){\n            graph[index] = new ArrayList<Integer>();\n        }\n\n        while (edgeNumber-- > 0){\n            int from = readInt() - 1;\n            int to = readInt() - 1;\n\n            graph[from].add(to);\n            graph[to].add(from);\n        }\n\n        return graph;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IntIndexPair {\n\n        static Comparator<IntIndexPair> increaseComparator = new Comparator<B.IntIndexPair>() {\n\n            @Override\n            public int compare(B.IntIndexPair indexPair1, B.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return value1 - value2;\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        static Comparator<IntIndexPair> decreaseComparator = new Comparator<B.IntIndexPair>() {\n\n            @Override\n            public int compare(B.IntIndexPair indexPair1, B.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return -(value1 - value2);\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        int value, index;\n\n        IntIndexPair(int value, int index) {\n            super();\n            this.value = value;\n            this.index = index;\n        }\n\n        int getRealIndex() {\n            return index + 1;\n        }\n    }\n\n    private IntIndexPair[] readIntIndexArray(int size) {\n        IntIndexPair[] array = new IntIndexPair[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = new IntIndexPair(readInt(), index);\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class OutputWriter extends PrintWriter {\n\n        final int DEFAULT_PRECISION = 12;\n\n        private int precision;\n        private String format, formatWithSpace;\n\n        {\n            precision = DEFAULT_PRECISION;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        OutputWriter(OutputStream out) {\n            super(out);\n        }\n\n        OutputWriter(String fileName) throws FileNotFoundException {\n            super(fileName);\n        }\n\n        int getPrecision() {\n            return precision;\n        }\n\n        void setPrecision(int precision) {\n            precision = max(0, precision);\n            this.precision = precision;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        String createFormat(int precision){\n            return \"%.\" + precision + \"f\";\n        }\n\n        @Override\n        public void print(double d){\n            printf(format, d);\n        }\n\n        void printWithSpace(double d){\n            printf(formatWithSpace, d);\n        }\n\n        void printAll(double...d){\n            for (int i = 0; i < d.length - 1; ++i){\n                printWithSpace(d[i]);\n            }\n\n            print(d[d.length - 1]);\n        }\n\n        @Override\n        public void println(double d){\n            printlnAll(d);\n        }\n\n        void printlnAll(double... d){\n            printAll(d);\n            println();\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class RuntimeIOException extends RuntimeException {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -6463830523020118289L;\n\n        RuntimeIOException(Throwable cause) {\n            super(cause);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    //////////////// Some useful constants and functions ////////////////\n    /////////////////////////////////////////////////////////////////////\n\n    private static final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    private static final int[][] steps8 = {\n            {-1, 0}, {1, 0}, {0, -1}, {0, 1},\n            {-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n    };\n\n    private static boolean checkCell(int row, int rowsCount, int column, int columnsCount) {\n        return checkIndex(row, rowsCount) && checkIndex(column, columnsCount);\n    }\n\n    private static boolean checkIndex(int index, int lim){\n        return (0 <= index && index < lim);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static boolean checkBit(int mask, int bit){\n        return (mask & (1 << bit)) != 0;\n    }\n    private static boolean checkBit(long mask, int bit){\n        return (mask & (1L << bit)) != 0;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long getSum(int[] array) {\n        long sum = 0;\n        for (int value: array) {\n            sum += value;\n        }\n\n        return sum;\n    }\n\n    private static Point getMinMax(int[] array) {\n        int min = array[0];\n        int max = array[0];\n\n        for (int index = 0, size = array.length; index < size; ++index, ++index) {\n            int value = array[index];\n\n            if (index == size - 1) {\n                min = min(min, value);\n                max = max(max, value);\n            } else {\n                int otherValue = array[index + 1];\n\n                if (value <= otherValue) {\n                    min = min(min, value);\n                    max = max(max, otherValue);\n                } else {\n                    min = min(min, otherValue);\n                    max = max(max, value);\n                }\n            }\n        }\n\n        return new Point(min, max);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static int[] getPrimes(int n) {\n        boolean[] used = new boolean[n];\n        used[0] = used[1] = true;\n\n        int size = 0;\n        for (int i = 2; i < n; ++i) {\n            if (!used[i]) {\n                ++size;\n                for (int j = 2 * i; j < n; j += i) {\n                    used[j] = true;\n                }\n            }\n        }\n\n        int[] primes = new int[size];\n        for (int i = 0, cur = 0; i < n; ++i) {\n            if (!used[i]) {\n                primes[cur++] = i;\n            }\n        }\n\n        return primes;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n\n    private static long gcd(long a, long b) {\n        return (a == 0 ? b : gcd(b % a, a));\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IdMap<KeyType> extends HashMap<KeyType, Integer> {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -3793737771950984481L;\n\n        public IdMap() {\n            super();\n        }\n\n        int getId(KeyType key) {\n            Integer id = super.get(key);\n            if (id == null) {\n                super.put(key, id = size());\n            }\n\n            return id;\n        }\n    }\n}\n\n", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\n\n\npublic class Solution {\n\n\n\n    BufferedReader in;\n\n    StringTokenizer st;\n\n    PrintWriter out;\n\n\n\n    int n, m, k;\n\n    int[] x, y;\n\n\n\n    char[] qx = new char[4000000], qy = new char[4000000];\n\n    int b, e;\n\n\n\n    char[][] d;\n\n\n\n    int[] dx = { -1, 0, 1, 0 }, dy = { 0, -1, 0, 1 };\n\n\n\n    void bfs() {\n\n        b = e = 0;\n\n        for (int i = 0; i < d.length; i++) {\n\n            Arrays.fill(d[i], (char)(1 << 14));\n\n        }\n\n        for (int i = 0; i < k; ++i) {\n\n            qx[e] = (char) x[i];\n\n            qy[e++] = (char) y[i];\n\n            d[x[i]][y[i]] = 0;\n\n        }\n\n        for (; b < e; ++b) {\n\n            int x = qx[b];\n\n            int y = qy[b];\n\n            for (int i = 0; i < 4; ++i) {\n\n                int nx = x + dx[i];\n\n                int ny = y + dy[i];\n\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m)\n\n                    if (d[nx][ny] > d[x][y] + 1) {\n\n                        d[nx][ny] = (char) (d[x][y] + 1);\n\n                        qx[e] = (char) nx;\n\n                        qy[e++] = (char) ny;\n\n                    }\n\n            }\n\n        }\n\n    }\n\n\n\n    void solve() throws IOException {\n\n        n = ni();\n\n        m = ni();\n\n        k = ni();\n\n        x = new int[k];\n\n        y = new int[k];\n\n        for (int i = 0; i < k; ++i) {\n\n            x[i] = ni() - 1;\n\n            y[i] = ni() - 1;\n\n        }\n\n        d = new char[n][m];\n\n        bfs();\n\n        int x = -1, y = -1, last = -1;\n\n        for (int i = 0; i < n; ++i)\n\n            for (int j = 0; j < m; ++j)\n\n                if (d[i][j] > last) {\n\n                    last = d[i][j];\n\n                    x = i;\n\n                    y = j;\n\n                }\n\n        ++x;\n\n        ++y;\n\n        out.println(x + \" \" + y);\n\n    }\n\n\n\n    public Solution() throws IOException {\n\n        Locale.setDefault(Locale.US);\n\n        in = new BufferedReader(new FileReader(\"input.txt\"));\n\n        out = new PrintWriter(\"output.txt\");\n\n        solve();\n\n        in.close();\n\n        out.close();\n\n    }\n\n\n\n    String nline() throws IOException {\n\n        return in.readLine();\n\n    }\n\n\n\n    String ns() throws IOException {\n\n        while (st == null || !st.hasMoreTokens()) {\n\n            st = new StringTokenizer(nline());\n\n        }\n\n        return st.nextToken();\n\n    }\n\n\n\n    int ni() throws IOException {\n\n        return Integer.valueOf(ns());\n\n    }\n\n\n\n    long nl() throws IOException {\n\n        return Long.valueOf(ns());\n\n    }\n\n\n\n    double nd() throws IOException {\n\n        return Double.valueOf(ns());\n\n    }\n\n\n\n    public static void main(String[] args) throws IOException {\n\n        new Solution();\n\n    }\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tScanner scan=new Scanner(System.in);\n\t\tint a=scan.nextInt();\n\t\tint b=scan.nextInt();\n\t\tint c=scan.nextInt();\n\t\tint n=scan.nextInt();\n\t\tif(a<c || b<c){\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tint tot=0;\n\t\ttot+=a-c;\n\t\ttot+=b-c;\n\t\ttot+=c;\n\t\tif(n-tot<=0){\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(n-tot);\n\t\t}\n\t}\n}", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\n\n\npublic class C {\n\n\n\n\tvoid run() throws IOException {\n\n\t\tint n = ni(), m = ni(), k = ni(), q = n * m, h = 0, t = 0, inf = 123456;\n\n\t\tint[] x = new int[q], y = new int[q];\n\n\t\tint[][] d = new int[n][m];\n\n\t\tfor (int i = 0; i < n; i++)\n\n\t\t\tfor (int j = 0; j < m; j++)\n\n\t\t\t\td[i][j] = inf;\n\n\t\tfor (int i = 0; i < k; i++) {\n\n\t\t\tint u = ni() - 1, v = ni() - 1;\n\n\t\t\td[u][v] = 0;\n\n\t\t\tx[t] = u;\n\n\t\t\ty[t] = v;\n\n\t\t\tt++;\n\n\t\t}\n\n\t\tif (k < q)\n\n\t\t\twhile (t != h) {\n\n\t\t\t\tint u = x[h], v = y[h];\n\n\t\t\t\tint l = d[u][v] + 1;\n\n\t\t\t\th++;\n\n\t\t\t\tif (u > 0 && d[u - 1][v] > l) {\n\n\t\t\t\t\td[u - 1][v] = l;\n\n\t\t\t\t\tx[t] = u - 1;\n\n\t\t\t\t\ty[t] = v;\n\n\t\t\t\t\tt++;\n\n\t\t\t\t}\n\n\t\t\t\tif (u < n - 1 && d[u + 1][v] > l) {\n\n\t\t\t\t\td[u + 1][v] = l;\n\n\t\t\t\t\tx[t] = u + 1;\n\n\t\t\t\t\ty[t] = v;\n\n\t\t\t\t\tt++;\n\n\t\t\t\t}\n\n\t\t\t\tif (v > 0 && d[u][v - 1] > l) {\n\n\t\t\t\t\td[u][v - 1] = l;\n\n\t\t\t\t\tx[t] = u;\n\n\t\t\t\t\ty[t] = v - 1;\n\n\t\t\t\t\tt++;\n\n\t\t\t\t}\n\n\t\t\t\tif (v < m - 1 && d[u][v + 1] > l) {\n\n\t\t\t\t\td[u][v + 1] = l;\n\n\t\t\t\t\tx[t] = u;\n\n\t\t\t\t\ty[t] = v + 1;\n\n\t\t\t\t\tt++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\tint max = 0, tx = 0, ty = 0;\n\n\n\n\t\tfor (int i = 0; i < n; i++)\n\n\t\t\tfor (int j = 0; j < m; j++)\n\n\t\t\t\tif (d[i][j] > max) {\n\n\t\t\t\t\tmax = d[i][j];\n\n\t\t\t\t\ttx = i;\n\n\t\t\t\t\tty = j;\n\n\n\n\t\t\t\t}\n\n\t\tpw.print(1 + tx + \" \" + (1 + ty));\n\n\t}\n\n\n\n\tString next() throws IOException {\n\n\t\twhile (st == null || !st.hasMoreTokens())\n\n\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\treturn st.nextToken();\n\n\t}\n\n\n\n\tint ni() throws IOException {\n\n\t\treturn Integer.parseInt(next());\n\n\t}\n\n\n\n\tString nl() throws IOException {\n\n\t\treturn br.readLine();\n\n\t}\n\n\n\n\tPrintWriter pw;\n\n\tBufferedReader br;\n\n\tStringTokenizer st;\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader _br = new BufferedReader(new FileReader(new File(\"input.txt\")));\n\n\t\tPrintWriter _pw = new PrintWriter(new FileWriter(new File(\"output.txt\")));\n\n\t\tnew C(_br, _pw).run();\n\n\t\t_br.close();\n\n\t\t_pw.close();\n\n\t}\n\n\n\n\tpublic C(BufferedReader _br, PrintWriter _pw) {\n\n\t\tbr = _br;\n\n\t\tpw = _pw;\n\n\t}\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * Created by mostafa on 12/29/17.\n */\npublic class C {\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt(), r = sc.nextInt();\n        int[] x = new int[n];\n        for(int i = 0; i < n; i++)\n            x[i] = sc.nextInt();\n        double[] ans = new double[n];\n        for(int i = 0; i < n; i++) {\n            ans[i] = r;\n            for(int j = 0; j < i; j++) {\n                int d = Math.abs(x[i] - x[j]);\n                if(d > 2 * r)\n                    continue;\n                int h = 2 * r;\n                double yd = Math.sqrt(h * h - d * d);\n                ans[i] = Math.max(ans[i], ans[j] + yd);\n            }\n\n            out.print(ans[i]);\n            if(i == n - 1)\n                out.println();\n            else\n                out.print(\" \");\n        }\n\n        out.flush();\n        out.close();\n\n    }\n\n    static class Scanner {\n        BufferedReader br; StringTokenizer st;\n        Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() throws IOException {\n            while(st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF1009E {\n\tstatic final int MD = 998244353;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint[] aa = new int[1 + n];\n\t\tfor (int i = 1, a = 0; i <= n; i++)\n\t\t\taa[i] = a = (a + Integer.parseInt(st.nextToken())) % MD;\n\t\tint[] pp = new int[n];\n\t\tpp[0] = 1;\n\t\tfor (int i = 1, p = 1; i < n; i++) {\n\t\t\tpp[i] = p;\n\t\t\tp = p * 2 % MD;\n\t\t}\n\t\tint d = 0;\n\t\tlong ans = 0;\n\t\tfor (int i = n - 1; i >= 0; i--) {\t// rest at i\n\t\t\td = (d * 2 % MD + aa[n - 1 - i]) % MD;\t// rest again before n\n\t\t\tans = (ans + (long) (d + aa[n - i]) * pp[i]) % MD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "complexity": "linear", "problem": "1009_E", "from": "CODEFORCES", "tags": "combinatorics,math,probabilities"}
{"src": "import java.util.*;\n\npublic class Compute {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long M = sc.nextInt();\n        long fact[] = new long[n+1];\n        long inv[] = new long[n+1];\n        long ifact[] = new long[n+1];\n        long dp[][] = new long[n+1][n+1];\n        fact[1] = 1;\n        ifact[1] = 1;\n        ifact[0] = 1;\n        inv[1] = 1;\n        dp[1][1] = 1;\n        \n        for(int i = 2; i <= n; i++) {\n            fact[i] = (i*fact[i-1]) % M;\n            inv[i] = (inv[(int)(M % i)]*(M - M/i)) % M;\n            dp[i][i] = (dp[i-1][i-1] * 2) % M;\n            ifact[i] = (ifact[i-1]*inv[i]) % M;\n        }\n            \n        for(int i = 3; i <= n; i++) {\n            for(int j = i/2 + 1; j <= i-1; j++) {\n                for(int k = 2; k <= i-1 && j-k+1 > (i-k)/2; k++) {\n                    dp[i][j] = (dp[i][j] + ((((dp[k-1][k-1]*dp[i-k][j-k+1] % M)*fact[j] % M)*ifact[k-1] % M)*ifact[j-k+1] % M)) % M;   \n                }\n            }   \n        }\n        \n        long sum = 0;\n        for(int i = n/2 + 1; i <= n; i++)\n            sum = (sum + dp[n][i]) % M;\n        \n        System.out.println(sum % M);\n    }\n}", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "//package round599;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\n\npublic class C {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[][] a = new int[n][];\n\t\tMap<Long, Long> ci = new HashMap<>();\n\t\tlong[] sums = new long[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint K = ni();\n\t\t\ta[i] = na(K);\n\t\t\tfor(int j = 0;j < K;j++){\n\t\t\t\tci.put((long)a[i][j], (long)i<<32|j);\n\t\t\t\tsums[i] += a[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong S = 0;\n\t\tfor(long v : sums){\n\t\t\tS += v;\n\t\t}\n\t\tif(S % n != 0){\n\t\t\tout.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tS /= n;\n\t\t\n\t\tint[] offsets = new int[n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\toffsets[i+1] = offsets[i] + a[i].length;\n\t\t}\n\t\t\n\t\tint m = offsets[n];\n\t\tint[] f = new int[m];\n\t\tArrays.fill(f, -1);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < a[i].length;j++){\n\t\t\t\tlong T = a[i][j] + S - sums[i];\n\t\t\t\tif(ci.containsKey(T)){\n\t\t\t\t\tlong code = ci.get(T);\n\t\t\t\t\tint from = offsets[i] + j;\n\t\t\t\t\tint to = offsets[(int)(code>>>32)] + (int)code;\n\t\t\t\t\tif(from != to && i == (int)(code>>>32))continue;\n\t\t\t\t\tf[from] = to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] cs = getCycles(f);\n\t\tint[][] zcs = new int[1<<n][];\n\t\tfor(int[] c : cs){\n\t\t\tint ptn = 0;\n\t\t\tfor(int k : c){\n\t\t\t\tint ind = Arrays.binarySearch(offsets, k);\n\t\t\t\tif(ind < 0)ind = -ind-2;\n\t\t\t\tptn |= 1<<ind;\n\t\t\t}\n\t\t\tif(Integer.bitCount(ptn) != c.length)continue;\n\t\t\tzcs[ptn] = c;\n\t\t}\n\t\t\n\t\tboolean[] dp = new boolean[1<<n];\n\t\tdp[0] = true;\n\t\tfor(int i = 1;i < 1<<n;i++){\n\t\t\tif(zcs[i] != null){\n\t\t\t\tint mask = (1<<n)-1^i;\n\t\t\t\tfor(int j = mask;j >= 0;j--){ j &= mask; \n\t\t\t\t\tdp[i|j] |= dp[j];\n\t\t\t\t} // include j=0\n\t\t\t}\n\t\t}\n\t\tif(dp[(1<<n)-1]){\n\t\t\tint[] vals = new int[n];\n\t\t\tint[] tos = new int[n];\n\t\t\t\n\t\t\tint cur = (1<<n)-1;\n\t\t\tinner:\n\t\t\twhile(cur > 0){\n\t\t\t\tfor(int k = cur;k >= 0;k--){\n\t\t\t\t\tk &= cur;\n\t\t\t\t\tif(dp[cur^k] && zcs[k] != null){\n\t\t\t\t\t\tfor(int l = 0;l < zcs[k].length;l++){\n\t\t\t\t\t\t\tint nl = (l+zcs[k].length-1) % zcs[k].length;\n\t\t\t\t\t\t\tint fclus = Arrays.binarySearch(offsets, zcs[k][l]);\n\t\t\t\t\t\t\tint tclus = Arrays.binarySearch(offsets, zcs[k][nl]);\n\t\t\t\t\t\t\tif(fclus < 0)fclus = -fclus-2;\n\t\t\t\t\t\t\tif(tclus < 0)tclus = -tclus-2;\n\t\t\t\t\t\t\tint val = a[fclus][zcs[k][l]-offsets[fclus]];\n\t\t\t\t\t\t\tvals[fclus] = val;\n\t\t\t\t\t\t\ttos[fclus] = tclus;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur ^= k;\n\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(\"Yes\");\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tout.println(vals[i] + \" \" + (tos[i]+1));\n\t\t\t}\n\t\t\t\n//\t\t\tfor(int i = 0;i < n;i++){\n//\t\t\t\tsums[i] -= vals[i];\n//\t\t\t\tsums[tos[i]] += vals[i];\n//\t\t\t}\n//\t\t\t\n//\t\t\tfor(int i = 0;i < n;i++){\n//\t\t\t\tassert sums[i] == S;\n//\t\t\t}\n\t\t\t\n\t\t}else{\n\t\t\tout.println(\"No\");\n\t\t}\n\t}\n\t\n\t\n\tint[][] getCycles(int[] f)\n\t{\n\t\tint n = f.length;\n\t\tint[][] ret = new int[n][];\n\t\tboolean[] ved = new boolean[n];\n\t\tint[] touched = new int[n];\n\t\tArrays.fill(touched, -1);\n\t\tint[] path = new int[n];\n\t\tint q = 0;\n\t\touter:\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint p = 0;\n\t\t\tfor(int j = i;j != -1;j = f[j]){\n\t\t\t\tif(touched[j] != -1){\n\t\t\t\t\tret[q++] = Arrays.copyOfRange(path, touched[j], p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ved[j])break;\n\t\t\t\ttouched[j] = p;\n\t\t\t\tpath[p++] = j;\n\t\t\t\tved[j] = true;\n\t\t\t}\n\t\t\tfor(int k = 0;k < p;k++){\n\t\t\t\ttouched[path[k]] = -1;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, q);\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new C().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "/*==========================================================================\n*   \tAUTHOR:    RonWonWon\n*   \tCREATED:   31.05.2021 02:10:11        \n/*==========================================================================*/\nimport java.io.*;\nimport java.util.*;\n\npublic class C {\n\n\tpublic static void main(String[] args) {\n  \tFastScanner in = new FastScanner();\n    int t = in.nextInt(), tt = 1;\n    while(t-->0) { \n      int n = in.nextInt();\n      int a[] = in.readArray(n);\n      int prev = -1;\n      ArrayList<Integer> f = new ArrayList<>();\n      for(int i=0;i<n;i++){\n\t\t\t\tif(prev==-1){\n\t\t\t\t\tout.println(a[i]);\n\t\t\t\t\tf.add(a[i]);\n\t\t\t\t\tprev = a[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(a[i]==1){\n\t\t\t\t\t\tf.add(a[i]);\n\t\t\t\t\t\tprint(f);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\twhile(f.size()>0&&f.get(f.size()-1)!=a[i]-1) f.remove(f.size()-1);\n\t\t\t\t\t\tif(f.size()!=0) f.remove(f.size()-1);\n\t\t\t\t\t\tf.add(a[i]);\n\t\t\t\t\t\tprev = a[i];\n\t\t\t\t\t\tprint(f);\n\t\t\t\t\t}\n\t\t\t\t}\n      }\n   \t\t//out.println(\"Case #\"+tt+\": \"+ans); tt++;\n    }\n    out.flush();\n\t}\n\t\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\t\n\tstatic void print(ArrayList<Integer> list){\n\t\tfor(int i=0;i<list.size()-1;i++) out.print(list.get(i)+\".\");\n\t\tout.println(list.get(list.size()-1));\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t\ttry { st = new StringTokenizer(br.readLine()); }\n\t\t\t\tcatch(IOException e) {}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString nextLine(){\n\t\t\ttry{ return br.readLine(); } \n\t\t\tcatch(IOException e) { } return \"\";\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tlong[] readlArray(int n) {\n\t\t\tlong a[] = new long[n];\n\t\t\tfor(int i=0;i<n;i++) a[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tdouble[] readdArray(int n) {\n\t\t\tdouble a[] = new double[n];\n\t\t\tfor(int i=0;i<n;i++) a[i] = nextDouble();\n\t\t\treturn a;\n\t\t}\n\t}\n\n\tstatic int oo = 1_000_000_000;\n\t\n\tstatic final Random random = new Random();\n\n\tstatic void ruffleSort(int[] a){\n\t\tint n = a.length;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint j = random.nextInt(n), temp = a[j];\n\t\t\ta[j] = a[i]; a[i] = temp;\n\t\t}\n\t\tArrays.sort(a); \t\n\t}\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.util.*;\npublic class A {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner (System.in);\n\t\tint n = sc.nextInt();\n\t\tint a[] = new int[n+1];\n\t\tfor(int i=1 ; i<=n ; i++) a[i] = sc.nextInt();\n\t\tint cnt = 0;\n\t\tfor(int i=1 ; i<=n ; i++) {\n\t\t\tfor(int j=i-1 ; j>=1 ; j--) {\n\t\t\t\tif(a[i]<a[j])\n\t\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\t//System.out.println(cnt);\n\t\tint q = sc.nextInt();\n\t\tcnt = cnt % 2; \n\t\twhile(q-->0) {\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tint r = y-x+1;\n\t\t\tlong ok = (r*(r-1))/2;\n\t\t\tif(ok%2==0) {\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcnt ^= 1 ; \n\t\t\t}\n\t\t\tSystem.out.println(cnt==0?\"even\":\"odd\");\n\t\t}\n\t}\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.OutputStream;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.PrintWriter;\n\nimport java.util.Arrays;\n\nimport java.util.Random;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.util.StringTokenizer;\n\nimport java.io.BufferedReader;\n\nimport java.util.Comparator;\n\nimport java.io.InputStream;\n\n\n\n/**\n\n * Built using CHelper plug-in\n\n * Actual solution is at the top\n\n */\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        InputStream inputStream = System.in;\n\n        OutputStream outputStream = System.out;\n\n        InputReader in = new InputReader(inputStream);\n\n        PrintWriter out = new PrintWriter(outputStream);\n\n        TaskD solver = new TaskD();\n\n        solver.solve(1, in, out);\n\n        out.close();\n\n    }\n\n\n\n    static class TaskD {\n\n        int BUBEN = 200;\n\n\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n\n            Random random = new Random(94739534513L + System.currentTimeMillis());\n\n            int n = in.nextInt();\n\n            int q = in.nextInt();\n\n            int[] a = new int[n];\n\n            for (int i = 0; i < n; ++i) {\n\n                a[i] = in.nextInt();\n\n            }\n\n            int buben = (int) Math.round(Math.sqrt(n));\n\n            TaskD.Query[] queries = new TaskD.Query[q];\n\n            for (int i = 0; i < q; ++i) {\n\n                queries[i] = new TaskD.Query();\n\n                queries[i].l = in.nextInt() - 1;\n\n                queries[i].r = in.nextInt();\n\n                queries[i].k = in.nextInt();\n\n                queries[i].bucket = queries[i].l / buben;\n\n            }\n\n            TaskD.Query[] originalQueries = queries.clone();\n\n            Arrays.sort(queries, new Comparator<TaskD.Query>() {\n\n\n\n                public int compare(TaskD.Query o1, TaskD.Query o2) {\n\n                    if (o1.bucket != o2.bucket) return o1.bucket - o2.bucket;\n\n                    if (o1.r != o2.r) {\n\n                        if ((o1.bucket & 1) == 0) return o1.r - o2.r;\n\n                        else return o2.r - o1.r;\n\n                    }\n\n                    return o1.l - o2.l;\n\n                }\n\n            });\n\n            int[] counts = new int[n + 1];\n\n            int cl = 0;\n\n            int cr = 0;\n\n            for (TaskD.Query qq : queries) {\n\n                while (cr < qq.r) {\n\n                    ++counts[a[cr++]];\n\n                }\n\n                while (cl > qq.l) {\n\n                    ++counts[a[--cl]];\n\n                }\n\n                while (cr > qq.r) {\n\n                    --counts[a[--cr]];\n\n                }\n\n                while (cl < qq.l) {\n\n                    --counts[a[cl++]];\n\n                }\n\n                int res = -1;\n\n                int need = (qq.r - qq.l) / qq.k + 1;\n\n                for (int attempt = 0; attempt < BUBEN; ++attempt) {\n\n                    int x = a[qq.l + random.nextInt(qq.r - qq.l)];\n\n                    if (counts[x] >= need) {\n\n                        if (res < 0 || res > x) res = x;\n\n                    }\n\n                }\n\n                qq.answer = res;\n\n            }\n\n            for (TaskD.Query qq : originalQueries) {\n\n                out.println(qq.answer);\n\n            }\n\n        }\n\n\n\n        static class Query {\n\n            int l;\n\n            int r;\n\n            int k;\n\n            int answer;\n\n            int bucket;\n\n\n\n        }\n\n\n\n    }\n\n\n\n    static class InputReader {\n\n        public BufferedReader reader;\n\n        public StringTokenizer tokenizer;\n\n\n\n        public InputReader(InputStream stream) {\n\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n\n            tokenizer = null;\n\n        }\n\n\n\n        public String next() {\n\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\n                try {\n\n                    tokenizer = new StringTokenizer(reader.readLine());\n\n                } catch (IOException e) {\n\n                    throw new RuntimeException(e);\n\n                }\n\n            }\n\n            return tokenizer.nextToken();\n\n        }\n\n\n\n        public int nextInt() {\n\n            return Integer.parseInt(next());\n\n        }\n\n\n\n    }\n\n}", "complexity": "cubic", "problem": "0840_D", "from": "CODEFORCES", "tags": "data structures,probabilities"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class program{\n\tpublic static void main(String args[]) throws Exception{\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tif(n==0){\n\t\t\tSystem.out.println(\"0 0 0\");\n\t\t\treturn;\n\t\t}\n\t\telse if(n==1){\n\t\t\tSystem.out.println(\"0 0 1\");\n\t\t\treturn;\n\t\t}\n\t\telse if(n==2){\n\t\t\tSystem.out.println(\"0 1 1\");\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tint ppp=0;\n\t\t\tint pp=1;\n\t\t\tint c=2;\n\t\t\twhile(true){\n\t\t\t\tif(ppp+pp+c==n){\n\t\t\t\t\tSystem.out.println(ppp+\" \"+pp+\" \"+c);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tc=c+pp+ppp;\n\t\t\t\t\tint temp=pp;\n\t\t\t\t\tpp=pp+ppp;\n\t\t\t\t\tppp=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "\n\nimport java.awt.Point;\n\nimport java.io.BufferedReader;\n\nimport java.io.BufferedWriter;\n\nimport java.io.FileReader;\n\nimport java.io.FileWriter;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class FireAgain {\n\n\n\n    int k, i, j,n,m,x,y;\n\n    void run() {\n\n        try {\n\n            BufferedReader bfd = new BufferedReader(new FileReader(\"input.txt\"));\n\n            BufferedWriter out = new BufferedWriter(new FileWriter(\"output.txt\"));\n\n//          BufferedReader bfd = new BufferedReader(new InputStreamReader(System.in));\n\n            StringTokenizer tk = new StringTokenizer(bfd.readLine());\n\n            \n\n            n = Integer.parseInt(tk.nextToken());\n\n            m = Integer.parseInt(tk.nextToken());\n\n            boolean vis[][] = new boolean[n][m];\n\n            k = Integer.parseInt(bfd.readLine());\n\n            tk = new StringTokenizer(bfd.readLine());\n\n            Queue<Point> q = new LinkedList<Point>();\n\n            Point last = new Point(0,0);\n\n            while(k-->0){\n\n                x = Integer.parseInt(tk.nextToken())-1;\n\n                y = Integer.parseInt(tk.nextToken())-1;\n\n                q.add(new Point(x,y));\n\n                vis[x][y] = true;\n\n            }\n\n            while(!q.isEmpty()) {\n\n                Point frnt = q.poll();\n\n                for(i=frnt.x-1;i<=frnt.x+1;++i)\n\n                    for(j=frnt.y-1;j<=frnt.y+1;++j)\n\n                        if(val(i,j)&& !vis[i][j]&&(frnt.x==i||frnt.y==j)){\n\n                            q.add(new Point(i,j));\n\n                            last = new Point(i,j);\n\n                            vis[i][j] = true;\n\n                        }\n\n            }\n\n//          System.out.println(last.x+1 + \" \" +(last.y+1));\n\n            out.write(last.x+1 + \" \" +(last.y+1)+\"\\n\");\n\n            out.flush();\n\n            out.close();\n\n        } catch (Exception e) {\n\n\n\n        }\n\n    }\n\n    \n\n    boolean val(int x,int y){\n\n        return x>=0&&x<n&&y>=0&&y<m;\n\n    }\n\n    public static void main(String[] args) {\n\n        new FireAgain().run();\n\n    }\n\n\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.*;\n\npublic class Q3a {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tin.nextLine();\n\t\tString s = in.nextLine();\n\n\t\tHashMap<Integer, Integer> seen = new HashMap<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tCharacter c = s.charAt(i);\n\t\t\tint ci = (int) c.charValue();\n\t\t\t// System.out.println(ci);\n\t\t\tseen.put(ci, seen.get(ci) == null ? 1 : seen.get(ci) + 1);\n\t\t}\n\n\t\tHashMap<Integer, Integer> sub = new HashMap<Integer, Integer>();\n\t\tint start = 0;\n\t\tint min = 10000000;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tCharacter c = s.charAt(i);\n\t\t\tint ci = (int) c.charValue();\n\n\t\t\tsub.put(ci, sub.get(ci) == null ? 1 : sub.get(ci) + 1);\n\t\t\t\n\t\t\twhile(sub.size() == seen.size()) {\n\t\t\t\tmin = Math.min(min, i - start + 1);\n\t\t\t\tc = s.charAt(start);\n\t\t\t\tstart ++;\n\t\t\t\tci = (int) c.charValue();\n\t\t\t\tif( sub.get(ci) == 1) \n\t\t\t\t\tsub.remove(ci);\n\t\t\t\telse\n\t\t\t\t\tsub.put(ci, sub.get(ci) - 1);\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.print(min);\n\n\t\t// System.out.println( seen_all_at - begin + 1);\n\n\t\tin.close();\n\t}\n}", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.util.Scanner;\n\n\n\n\n\npublic class BinaryHeap {\n\n\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n\n        int m = scanner.nextInt();\n\n\n\n        int s = (int)Math.pow(2, (double)n);\n\n        System.out.println(m%s);\n\n\n\n    }\n\n\n\n\n\n\n\n}\n\n", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC solver = new TaskC();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskC {\n    private long MOD = (long) (1e9 + 7);\n    int[][] dp = new int[5001][5001];\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n      int n = in.nextInt();\n      ArrayList<Character> commands = new ArrayList<>();\n\n      for (int i = 0; i < n; i++) {\n        char ch = in.next().charAt(0);\n        commands.add(ch);\n      }\n      for (int a[] : dp) Arrays.fill(a, -1);\n\n      out.println(count(0, commands, 0));\n\n    }\n\n    public int count(int index, ArrayList<Character> commands, int deepCount) {\n      if (deepCount < 0) {\n        return 0;\n      }\n      if (index == commands.size()) {\n        return 1;\n      } else {\n\n        if (dp[index][deepCount] != -1) return dp[index][deepCount];\n        long result = 0;\n        char ch = commands.get(index);\n        result = count(index, commands, deepCount - 1);\n        if (ch == 's') {\n          result += count(index + 1, commands, deepCount);\n        } else {\n          result += count(index + 1, commands, deepCount + 1);\n          result -= count(index + 1, commands, deepCount);\n        }\n        if (result >= MOD) {\n          result -= MOD;\n        }\n        if (result < 0) {\n          result += MOD;\n        }\n        return dp[index][deepCount] = (int) result;\n      }\n    }\n\n  }\n\n  static class InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private InputReader.SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (numChars == -1) {\n        throw new InputMismatchException();\n      }\n      if (curChar >= numChars) {\n        curChar = 0;\n        try {\n          numChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (numChars <= 0) {\n          return -1;\n        }\n      }\n      return buf[curChar++];\n    }\n\n    public int readInt() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public String readString() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      StringBuilder res = new StringBuilder();\n      do {\n        if (Character.isValidCodePoint(c)) {\n          res.appendCodePoint(c);\n        }\n        c = read();\n      } while (!isSpaceChar(c));\n      return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n      if (filter != null) {\n        return filter.isSpaceChar(c);\n      }\n      return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public String next() {\n      return readString();\n    }\n\n    public int nextInt() {\n      return readInt();\n    }\n\n    public interface SpaceCharFilter {\n      public boolean isSpaceChar(int ch);\n\n    }\n\n  }\n}\n\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class B {\n\n    static Scanner in;\n\n    static void put(TreeMap<Integer, Integer> m, int key) {\n        if (m.containsKey(key)) {\n            m.put(key, m.get(key) + 1);\n        } else {\n            m.put(key, 1);\n        }\n    }\n\n    static void remove(TreeMap<Integer, Integer> m, int key) {\n        if (!m.containsKey(key))\n            return;\n        m.put(key, m.get(key) - 1);\n        if (m.get(key) == 0) {\n            m.remove(key);\n        }\n    }\n\n    public static void main(String[] args) {\n        in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        int i = 0;\n        while (i + 1 < n && a[i + 1] == a[0]) {\n            i++;\n        }\n        int left = i;\n        TreeMap<Integer, Integer> used = new TreeMap<Integer, Integer>();\n        for (; i < n; i++) {\n            put(used, a[i]);\n            if (used.size() == k) {\n                while (used.get(a[left]) > 1) {\n                    remove(used, a[left]);\n                    left++;\n                }\n                System.out.println(left + 1 + \" \" + (i + 1));\n                return;\n            }\n        }\n        System.out.println(\"-1 -1\");\n    }\n\n}\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    private static int REM = 1000000007;\n    private static int dig;\n    private static int[][][] dp = new int[701][701][2];\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n\n        String X = in.next();\n        int N = X.length();\n\n        int[] P = new int[701];\n        P[0] = 1;\n        for (int i=1; i<P.length; ++i) {\n            P[i] = (int)((long)P[i-1] * 10 % REM);\n        }\n\n        int ans = 0;\n        for (int d=1; d<=9; ++d) { //at least d\n            dig = d;\n\n            for (int[][] array2 : dp) {\n                for (int[] array1 : array2) {\n                    Arrays.fill(array1, -1);\n                }\n            }\n\n            for (int c=1; c<=N; ++c) { //exact count of at least d\n                for (int k=0; k<c; ++k) {\n                    ans = (int)((ans + (long)f(0, c, false, X) * P[k]) % REM);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n\n    private static int f(int ps, int needed, boolean less, final String X) {\n        if (needed < 0) {return 0;}\n        if (dp[ps][needed][less?0:1] != -1) {return dp[ps][needed][less?0:1];}\n        if (ps == X.length()) {\n            if (needed == 0) {return 1;}\n            return 0;\n        }\n        int dg = X.charAt(ps)-'0';\n\n        int ans = 0;\n        for (int d=0; d<=9; ++d) {\n            if (!less && d>dg) {continue;}\n\n            boolean nless = less || d < dg;\n            ans = (int)((ans + (long)f(ps+1, needed-(d>=dig?1:0), nless, X)) % REM);\n        }\n\n        dp[ps][needed][less?0:1] = ans;\n        return ans;\n    }\n}\n", "complexity": "quadratic", "problem": "0908_G", "from": "CODEFORCES", "tags": "dp,math"}
{"src": "import java.util.*;\n\npublic class CDF22_A {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] A = new int[N];\n        for (int i=0; i<N; i++)\n            A[i] = sc.nextInt();\n        Arrays.sort(A);\n        int i = 0;\n        while (i < A.length && A[i] == A[0]) i++;\n        System.out.println(i == A.length ? \"NO\" : A[i]);\n        sc.close();\n    }\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.Scanner;\n\n\npublic class Composite {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tif (n == 12)\n\t\t\tSystem.out.println(\"4 8\");\n\t\t\n\t\telse if (n % 2 == 1)\n\t\t\tSystem.out.println((n - 9) + \" 9\");\n\t\t\n\t\telse\n\t\t\tSystem.out.println((n - 6) + \" 6\");\n\t}\n}\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\npublic class Solution {\n    public static void main(String [] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int [] a = new int [n];\n        int i;\n        int s = 0;\n        for (i = 0; i < n; i++) {\n            a[i] = scan.nextInt();\n            s += a[i];\n        }\n        Arrays.sort(a);\n        int sum = 0;\n        for (i = n - 1; i > -1; i--) {\n            sum += a[i];\n            if (s - sum < sum) {\n                System.out.println(n - i);\n                return;\n            }\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "\n\nimport java.util.Scanner;\n\npublic class TaxiDriversAndLyft2 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tlong n = scanner.nextLong();\n\t\tlong m = scanner.nextLong();\n\t\tlong[] people = new long[(int) (n+m)];\n\t\tint[] taxiDrivers = new int[(int) (n+m)];\n\t\t\n\t\tfor(int i = 0;i< (n+m); i++) {\n\t\t\tpeople[i] = scanner.nextLong();\n\t\t}\n\t\t\n\t\tfor(int i = 0;i< (n+m); i++) {\n\t\t\ttaxiDrivers[i] = scanner.nextInt();\n\t\t}\n\t\t\n\t\tint lastTaxiDriverIndex = -1;\n\t\tlong[] riderCountArray = new long[(int) (m)];\n\t\tlong[] a1 = new long[(int)n];\n\t\tlong[] b1 = new long[(int)m];\n\t\t\n\t\tint j=0, k=0;\n\t\tfor(int i = 0;i< (n+m); i++) {\t\n\t\t\tif(taxiDrivers[i] == 0) {\n\t\t\t\ta1[j] = people[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse  {\n\t\t\t\tb1[k] = people[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint l = 0, q=0;\n\t\tfor(int i=0;i<j;i++) {\n\t\t\twhile ((l<m-1 && m>1) && Math.abs(a1[i] - b1[l]) > Math.abs(a1[i] - b1[l+1])) {\n\t\t\t\tl++; \n\t\t\t}\n\t\t\t\n\t\t\triderCountArray[l]++;\t\n\t\t}\n\t\t\n\t\tfor(int i = 0;i< (m); i++) {\n\t\t\tSystem.out.print(riderCountArray[i]+\" \");\n\t\t}\n\t} \n}\n", "complexity": "linear", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "\n\n\n\nimport java.io.*;\n\nimport java.util.*;\n\n\n\npublic class CF176B {\n\n\t\n\n\tprivate static BufferedReader\tbr;\n\n\tprivate static StringTokenizer \tst;\n\n\tprivate static PrintWriter \t\tpw;\n\n\t// private static Timer t = new Timer();\n\n\t\n\n\tpublic CF176B() throws IOException {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tpw = new PrintWriter(System.out);\n\n\t}\n\n\t\n\n\tString next() throws IOException {\n\n        while (st == null || !st.hasMoreElements())\n\n            st = new StringTokenizer(br.readLine());\n\n        return st.nextToken();\n\n    }\n\n\n\n    boolean hasNext() {\n\n        if (st != null && st.hasMoreElements())\n\n            return true;\n\n\n\n        try {\n\n            while (st == null || !st.hasMoreElements())\n\n                st = new StringTokenizer(br.readLine());\n\n        }\n\n        catch (Exception e) {\n\n            return false;\n\n        }\n\n\n\n        return true;\n\n    }\n\n\n\n    String nextLine() throws IOException {\n\n        return br.readLine();\n\n    }\n\n\n\n    int nextInt() throws IOException {\n\n        return Integer.parseInt(next());\n\n    }\n\n\n\n    long nextLong() throws IOException {\n\n        return Long.parseLong(next());\n\n    }\n\n\n\n\tvoid solve() throws IOException {\n\n\t\t\n\n\t\tlong n = nextLong(), k = nextLong();\n\n\t\tif(n-1 > k * (k - 1)/ 2) {\n\n\t\t\tpw.println(-1);\n\n\t\t}else {\n\n\t\t\tlong i = binarysearch(n-1,k-1,0,k);\n\n\t\t\tpw.println(k-1-i);\n\n\t\t}\n\n\t\tpw.flush();\n\n\t}\n\n\t\n\n\tprivate static long binarysearch(long n, long k, long i, long j) {\n\n\t\tif(j - i <= 1) {\n\n\t\t\treturn i;\n\n\t\t}\n\n\t\tlong m = (i+j)/2;\n\n\t\tif(n > k*(k+1)/2 - m *(m+1)/2) {\n\n\t\t\treturn binarysearch(n,k,i,m);\n\n\t\t}else\n\n\t\t\treturn binarysearch(n,k,m,j);\n\n\t}\n\n\t\t\n\n\tpublic static void main(String[] args) throws IOException{\n\n\t\t new CF176B().solve();\n\n\t }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n\npublic class B {\n\t\n\tstatic class Scanner\n\t{\n\t\tBufferedReader rd;\n\t\tStringTokenizer tk;\n\t\tpublic Scanner() throws IOException\n\t\t{\n\t\t\trd=new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttk=new StringTokenizer(rd.readLine());\n\t\t}\n\t\tpublic String next() throws IOException\n\t\t{\n\t\t\twhile(!tk.hasMoreTokens())\n\t\t\t\ttk=new StringTokenizer(rd.readLine());\n\t\t\treturn tk.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws NumberFormatException, IOException\n\t\t{\n\t\t\treturn Integer.valueOf(this.next());\n\t\t}\n\t}\n\t\n\tstatic int N,K;\n\tstatic int[] array=new int[100010];\n\t\n\tpublic static void main(String args[]) throws IOException{\n\t\tScanner sc=new Scanner();\n\t\tN=sc.nextInt();\n\t\tK=sc.nextInt();\n\t\tfor(int i=0;i<N;i++)\n\t\t\tarray[i]=sc.nextInt();\n\t\tTreeMap<Integer,Integer> map=new TreeMap<Integer,Integer>();\n\t\tboolean flag=false;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif (!map.containsKey(array[i])){\n\t\t\t\tmap.put(array[i], i);\n\t\t\t\tif (map.size()==K){\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tmap.put(array[i], i);\n\t\t}\n\t\tif (!flag)\n\t\t\tSystem.out.println(\"-1 -1\");\n\t\telse{\n\t\t\tSet<Integer> s=map.keySet();\n\t\t\tint l=Integer.MAX_VALUE;\n\t\t\tint r=Integer.MIN_VALUE;\n\t\t\tfor(int k: s){\n\t\t\t\tint tmp=map.get(k);\n\t\t\t\tl=Math.min(l, tmp);\n\t\t\t\tr=Math.max(r, tmp);\n\t\t\t}\n\t\t\tSystem.out.println((l+1)+\" \"+(r+1));\n\t\t}\n\t}\n\n}", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\n\tFastReader in = new FastReader();\n\tPrintWriter out = new PrintWriter(System.out);\n\tvoid run(){\n\t\tout.println(work());\n\t\tout.flush();\n\t}\n\tlong mod=1000000007;\n\tlong gcd(long a,long b) {\n\t\treturn b==0?a:gcd(b,a%b);\n\t}\n\tlong work() {\n\t\tint n=in.nextInt();\n\t\tint m=in.nextInt();\n\t\tString str=in.next();\n\t\tlong[] dp=new long[1<<m];\n\t\tlong[][] cnt=new long[m][m];\n\t\tlong[] rec=new long[1<<m];//\u8bb0\u5f55\u6bcf\u6b21\u79fb\u52a8\u7684\u4e00\u4f4d\u600e\u52a0\u7684\u503c\uff0c\u51cf\u5c11\u91cd\u590d\u8ba1\u7b97\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tint n1=str.charAt(i-1)-'a';\n\t\t\tint n2=str.charAt(i)-'a';\n\t\t\tcnt[n1][n2]++;\n\t\t\tcnt[n2][n1]++;\n\t\t}\n\t\tfor(int i=1;i<1<<m;i++) {\n\t\t\tdp[i]=9999999999L;\n\t\t\tlong v=0;\n\t\t\tint b=0;//\u6700\u4f4e\u4f4d\u76841\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tif((i&(1<<j))>0) {\n\t\t\t\t\tb=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tif((i&(1<<j))==0) {\n\t\t\t\t\tv+=cnt[b][j];\n\t\t\t\t}else {\n\t\t\t\t\tif(b!=j)v-=cnt[b][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tv+=rec[i-(1<<b)];\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tif((i&(1<<j))>0) {\n\t\t\t\t\tdp[i]=Math.min(dp[i], dp[i-(1<<j)]+v);\n\t\t\t\t}\n\t\t\t}\n\t\t\trec[i]=v;\n\t\t}\n\t\t\n\t\treturn dp[(1<<m)-1];\n\t}\n}\n\n\n\nclass FastReader\n{\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic FastReader()\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tpublic String next() \n\t{\n\t\tif(st==null || !st.hasMoreElements())\n\t\t{\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() \n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong()\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n}", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "\n\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader sc = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, sc, out);\n        out.close();\n    }\n\n    static class Task {\n        public void solve(int testNumber, InputReader sc, PrintWriter out) {\n            int n=sc.nextInt();\n            int[] a=new int[n];\n            boolean[] jud=new boolean[101];\n            \n            for(int i=0;i<n;i++)\n            \ta[i]=sc.nextInt();\n            Arrays.sort(a);\n            int ans=0;\n            for(int i=0;i<n;i++) {\n            \tif(jud[a[i]])\n            \t\tcontinue;\n            \tans++;\n            \tfor(int j=a[i];j<=100;j+=a[i])\n            \t\tjud[j]=true;\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class B{\n\tstatic int[][] hor;\n\tstatic int[][] ver;\n\tstatic int n;\n\tstatic int m;\n\tstatic int k;\n\tstatic long[][][] dp;\n\t\n\tstatic long dist(int row, int col)\n\t{\n\t\tif(k%2==1)return Integer.MAX_VALUE;\n\t\treturn 2*make(row,col,k/2);\n\t}\n\t\n\tstatic long make(int row, int col, int moves)\n\t{\n\t\tif(moves == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(dp[row][col][moves]!=-1)return dp[row][col][moves];\n\t\t\n\t\tlong ans = Long.MAX_VALUE;\n\t\t\n\t\tif(col-1>=0)\n\t\t{\n\t\t\tans = Math.min(ans, hor[row][col-1]+make(row,col-1,moves-1));\n\t\t}\n\t\tif(col+1<m)\n\t\t{\n\t\t\tans = Math.min(ans, hor[row][col]+make(row,col+1,moves-1));\n\t\t}\n\t\tif(row-1>=0)\n\t\t{\n\t\t\tans = Math.min(ans, ver[row-1][col]+make(row-1,col,moves-1));\n\t\t}\n\t\tif(row+1<n)\n\t\t{\n\t\t\tans = Math.min(ans, ver[row][col]+make(row+1,col,moves-1));\n\t\t}\n\t\tdp[row][col][moves] = ans;\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tn = fs.nextInt(); m = fs.nextInt(); k = fs.nextInt();\n\t\thor = new int[n][m]; ver = new int[n][m];\n\t\tdp = new long[505][505][24];\n\t\tfor(int i=0;i<505;i++)for(int j=0;j<505;j++)for(int k=0;k<24;k++)dp[i][j][k] = -1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m-1;j++)\n\t\t\t{\n\t\t\t\tint a = fs.nextInt();\n\t\t\t\thor[i][j] = a;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int row=0;row<n-1;row++)\n\t\t{\n\t\t\tfor(int col =0;col<m;col++)\n\t\t\t{\n\t\t\t\tint a = fs.nextInt();\n\t\t\t\tver[row][col] = a;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tfor(int row=0;row<n;row++)\n\t\t{\n\t\t\tfor(int col=0;col<m;col++)\n\t\t\t{\n\t\t\t\tlong d = dist(row,col);\n\t\t\t\tif(d<Integer.MAX_VALUE)\n\t\t\t\t{\n\t\t\t\t\tout.print(d+\" \");\n\t\t\t\t}\n\t\t\t\telse out.print(\"-1 \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.close();\n\t}\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\tpublic static int[] sort(int[] arr)\n\t{\n\t\tList<Integer> temp = new ArrayList();\n\t\tfor(int i:arr)temp.add(i);\n\t\tCollections.sort(temp);\n\t\tint start = 0;\n\t\tfor(int i:temp)arr[start++]=i;\n\t\treturn arr;\n\t}\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author El Mehdi ASSALI\n */\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    AFunctionHeight solver = new AFunctionHeight();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class AFunctionHeight {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n      long n = in.nextLong(), k = in.nextLong();\n      out.println(k / n + (k % n == 0 ? 0 : 1));\n    }\n\n  }\n\n  static class InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputStream) {\n      reader = new BufferedReader(new InputStreamReader(inputStream));\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n\n  }\n}\n\n", "complexity": "constant", "problem": "1036_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] arhh) {\n\t\tCin in = new Cin();\n\t\tint n = in.nextInt(),k = in.nextInt(),sum=0,c=0;\n\t\tc = 2*n;\n\t\tsum+=(c+k-1)/k;\n\t\tc = 5*n;\n\t\tsum+=(c+k-1)/k;\n\t\tc = 8*n;\n\t\tsum+=(c+k-1)/k;\n\t\twr.print(sum);\n\t\twr.close();\n\t}\n//-- :\n\n\tstatic PrintWriter wr = new PrintWriter(System.out);static class Cin {BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));StringTokenizer st = new StringTokenizer(\"\");String next(){while(!st.hasMoreTokens()){try{st = new StringTokenizer(reader.readLine());}catch(Exception e) {e.printStackTrace();}}return st.nextToken();} int nextInt() {return Integer.parseInt(next());} long nextLong() {return Long.parseLong(next());} }\n} ", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class A {\n\n    public static void main(String[] args) throws IOException {\n        new A().solve();\n    }\n\n    BufferedReader br;\n    StringTokenizer st = new StringTokenizer(\"\");\n\n    private void solve() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        String s = nextToken();\n        int res = 0;\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i + 1; j < s.length(); j++) {\n                int k = 0;\n                while (k < s.length() - j && s.charAt(i + k) == s.charAt(j + k)) {\n                    k++;\n                }\n                res = Math.max(res, k);\n            }\n        }\n        PrintWriter pw = new PrintWriter(System.out);\n        pw.println(res);\n        pw.close();\n    }\n\n    String nextToken() throws IOException {\n        while (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\nimport java.util.Map.Entry;\n\n\nimport java.io.*;\nimport java.math.*;\nimport static java.util.stream.Collectors.*;\nimport static java.util.Map.Entry.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\tstatic int n, m;\n\tstatic int dp[][][], h[][], v[][];\n\tpublic static void main (String[] args) throws IOException\n\t{\n\t\tfinal long mod=(long) (1e9+7);  \n\t\tReader s=new Reader();\n\t\t  PrintWriter pt=new PrintWriter(System.out);\n\t\t  \n//\t\t  BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n//\t\t  int T=s.nextInt();\n//\t\t  int T=Integer.parseInt(br.readLine());\n\t\t  int T=1;\n\t\t  while(T-->0)\n\t\t  {\n\t\t        n=s.nextInt();\n\t\t        m=s.nextInt();\n\t\t        int k=s.nextInt();\n\t\t        h=new int[n][m-1];\n\t\t        for(int i=0;i<n;i++) {\n\t\t        \tfor(int j=0;j<m-1;j++) {\n\t\t        \t\th[i][j]=s.nextInt();\n\t\t        \t}\n\t\t        }\n\t\t        v=new int[n-1][m];\n\t\t        for(int i=0;i<n-1;i++) {\n\t\t        \tfor(int j=0;j<m;j++) {\n\t\t        \t\tv[i][j]=s.nextInt();\n\t\t        \t}\n\t\t        }\n\t\t        if(k%2==1) {\n\t\t        \tfor(int i=0;i<n;i++) {\n\t\t        \t\tfor(int j=0;j<m;j++)\n\t\t        \t\t\tpt.print(\"-1 \");\n\t\t        \t\tpt.println();\n\t\t        \t}\n\t\t        \t\n\t\t        }\n\t\t        else {\n\t\t        \tdp=new int[n][m][k];\n\t\t        \tfor(int i=0;i<n;i++) {\n\t\t        \t\tfor(int j=0;j<m;j++)\n\t\t        \t\t\tpt.print(bore(i, j, k/2)*2+\" \");\n\t\t        \t\tpt.println();\n\t\t        \t}\n\t\t        }\n\t\t  }\n\t\t  pt.close();\n\t}\n\t\n\tstatic int bore(int i, int j, int k) {\n\t\tif(dp[i][j][k]>0)\n\t\t\treturn dp[i][j][k];\n\t\tif(k==0) return 0;\n\t\tdp[i][j][k] = Integer.MAX_VALUE;\n\t\tif(i>0)\n\t\t\tdp[i][j][k]=Math.min(bore(i-1, j, k-1) + v[i-1][j], dp[i][j][k]);\n\t\tif(i<n-1)\n\t\t\tdp[i][j][k]=Math.min(bore(i+1, j, k-1) + v[i][j], dp[i][j][k]);\n\t\tif(j>0)\n\t\t\tdp[i][j][k]=Math.min(bore(i, j-1, k-1) + h[i][j-1], dp[i][j][k]);\n\t\tif(j<m-1)\n\t\t\tdp[i][j][k]=Math.min(bore(i, j+1, k-1) + h[i][j], dp[i][j][k]);\n\t\treturn dp[i][j][k];\n\t}\n\t\n\tstatic boolean isPartition(int arr[], int n) {\n\t\tint sum = 0;\n\t    int i, j;\n\t \n\t    // Calculate sum of all elements\n\t    for (i = 0; i < n; i++)\n\t        sum += arr[i];\n\t \n\t    if (sum % 2 != 0)\n\t        return false;\n\t \n\t    boolean part[][]=new boolean[sum/2+1][n+1];\n\t \n\t    // initialize top row as true\n\t    for (i = 0; i <= n; i++)\n\t        part[0][i] = true;\n\t \n\t    // initialize leftmost column, except part[0][0], as false\n\t    for (i = 1; i <= sum / 2; i++)\n\t        part[i][0] = false;\n\t \n\t    // Fill the partition table in bottom up manner\n\t    for (i = 1; i <= sum / 2; i++) {\n\t        for (j = 1; j <= n; j++) {\n\t            part[i][j] = part[i][j - 1];\n\t            if (i >= arr[j - 1])\n\t                part[i][j] = part[i][j]\n\t                             || part[i - arr[j - 1]][j - 1];\n\t        }\n\t    }\n\t    return part[sum / 2][n];\n\t}\n\t\n\tstatic int setBit(int S, int j) { return S | 1 << j; }\n\n\tstatic int clearBit(int S, int j) { return S & ~(1 << j); }\n\n\tstatic int toggleBit(int S, int j) { return S ^ 1 << j; }\n\n\tstatic boolean isOn(int S, int j) { return (S & 1 << j) != 0; }\n\n\tstatic int turnOnLastZero(int S) { return S | S + 1; }\n\t\n\tstatic int turnOnLastConsecutiveZeroes(int S) { return S | S - 1; }\n\t\n\tstatic int turnOffLastBit(int S) { return S & S - 1; }\n\t\n\tstatic int turnOffLastConsecutiveBits(int S) { return S & S + 1; }\n\n\tstatic int lowBit(int S) { return S & -S; }\n\n\tstatic int setAll(int N) { return (1 << N) - 1; }\n\n\tstatic int modulo(int S, int N) { return (S & N - 1); }\t\t //S%N, N is a power of 2\n\n\tstatic boolean isPowerOfTwo(int S) { return (S & S - 1) == 0; }\n\t\n\tstatic boolean isWithin(long x, long y, long d, long k) {\n\t\treturn x*k*x*k + y*k*y*k <= d*d;\n\t}\n\t\n\tstatic long modFact(long n, \n            long p) \n\t{ \n\t\tif (n >= p) \n\t\t return 0; \n\t\t\n\t\tlong result = 1; \n\t\tfor (int i = 1; i <= n; i++) \n\t\t result = (result * i) % p; \n\t\t\n\t\treturn result; \n\t} \n\tstatic int sum(int[] arr, int n)\n\t{\n\t    int inc[]=new int[n+1];\n\t    int dec[]=new int[n+1];\n\t    inc[0] = arr[0];\n\t    dec[0] = arr[0];\n\n\t    for (int i = 1; i < n; i++) {\n\t        for (int j = 0; j < i; j++) {\n\t            if (arr[j] > arr[i]) {\n\t                dec[i] = max(dec[i], inc[j] + arr[i]);\n\t            }\n\t            else if (arr[i] > arr[j]) {\n\t                inc[i] = max(inc[i], dec[j] + arr[i]);\n\t            }\n\t        }\n\t    }\n\t    return max(inc[n - 1], dec[n - 1]);\n\t}\n\tstatic long nc2(long a) {\n\t\treturn a*(a-1)/2;\n\t}\n\tpublic static int numberOfprimeFactors(int n) \n    { \n        // Print the number of 2s that divide n \n\t\tHashSet<Integer> hs = new HashSet<Integer>();\n        while (n%2==0) \n        { \n            hs.add(2);\n            n /= 2; \n        } \n  \n        // n must be odd at this point.  So we can \n        // skip one element (Note i = i +2) \n        for (int i = 3; i <= Math.sqrt(n); i+= 2) \n        { \n            // While i divides n, print i and divide n \n            while (n%i == 0) \n            { \n                hs.add(i);\n                n /= i; \n            } \n        } \n  \n        // This condition is to handle the case whien \n        // n is a prime number greater than 2 \n        if (n > 2) \n            hs.add(n);\n        return hs.size();\n    } \n\tstatic int gcd(int a, int b) \n    { \n      if (b == 0) \n        return a; \n      return gcd(b, a % b);  \n    } \n\n\n\n\n\t\n\n\tstatic void reverse(int arr[],int start, int end) \n\t{ \n\t\tint temp; \n\t\t   \n\t\twhile (start < end) \n\t\t{ \n\t\t    temp = arr[start];  \n\t\t    arr[start] = arr[end]; \n\t\t    arr[end] = temp; \n\t\t    start++; \n\t\t    end--; \n\t\t}  \n\t}  \n\tstatic void reverse(long arr[],int start, int end) \n\t{ \n\t\tlong temp; \n\t\t   \n\t\twhile (start < end) \n\t\t{ \n\t\t    temp = arr[start];  \n\t\t    arr[start] = arr[end]; \n\t\t    arr[end] = temp; \n\t\t    start++; \n\t\t    end--; \n\t\t}  \n\t}  \n\tstatic boolean isPrime(int n) \n    { \n        // Corner cases \n        if (n <= 1) return false; \n        if (n <= 3) return true; \n      \n        // This is checked so that we can skip  \n        // middle five numbers in below loop \n        if (n % 2 == 0 || n % 3 == 0) return false; \n      \n        for (int i = 5; i * i <= n; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n            return false; \n      \n        return true; \n    } \n\tstatic int p2(int n) {\n\t\tint k=0;\n\t\twhile(n>1) {\n\t\t\tif(n%2!=0)\n\t\t\t\treturn k;\n\t\t\tn/=2;\n\t\t\tk++;\n\t\t}\n\t\treturn k;\n\t}\n\tstatic boolean isp2(int n) {\n\t\twhile(n>1) {\n\t\t\tif(n%2==1)\n\t\t\t\treturn false;\n\t\t\tn/=2;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic int binarySearch(int arr[], int first, int last, int key){  \n\t\t   int mid = (first + last)/2;  \n\t\t   while( first <= last ){  \n\t\t      if ( arr[mid] < key ){  \n\t\t        first = mid + 1;     \n\t\t      }else if ( arr[mid] == key ){  \n\t\t        return mid;  \n\t\t      }else{  \n\t\t         last = mid - 1;  \n\t\t      }  \n\t\t      mid = (first + last)/2;  \n\t\t   }  \n\t\t   return -1;\n\t\t }  \n\n\tstatic void print(int a[][]) {\n\t\tfor(int i=0;i<a.length;i++)\n\t\t{\n\t\t\tfor(int j=0;j<a[0].length;j++)\n\t\t\t\tSystem.out.print(a[i][j]+\" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tstatic int max (int x, int y) {\n\t\treturn (x > y)? x : y;\n\t} \n\tstatic int search(Pair[] p, Pair pair) {\n\t\tint l=0, r=p.length;\n\t\twhile (l <= r) { \n\t        int m = l + (r - l) / 2;\n\t        if (p[m].compareTo(pair)==0) \n\t            return m; \n\t        if (p[m].compareTo(pair)<0) \n\t            l = m + 1; \n\t        else\n\t            r = m - 1;\n\t    }\n\t    return -1;\n\t}\n\tstatic void pa(int a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++)\n\t\t\tSystem.out.print(a[i]+\" \");\n\t\tSystem.out.println();\n\t\t\n\t}\n\tstatic void pa(long a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++)\n\t\t\tSystem.out.print(a[i]+\" \");\n\t\tSystem.out.println();\n\t\t\n\t}\n\tstatic void reverseArray(int arr[], \n            int start, int end) \n\t{ \n\t\tint temp; \n\t\t   \n\t\twhile (start < end) \n\t\t{ \n\t\t    temp = arr[start];  \n\t\t    arr[start] = arr[end]; \n\t\t    arr[end] = temp; \n\t\t    start++; \n\t\t    end--; \n\t\t}  \n\t}     \n\tstatic boolean isPalindrome(String s) {\n\t\tint l=s.length();\n\t\tfor(int i=0;i<l/2;i++)\n\t\t{\n\t\t\tif(s.charAt(i)!=s.charAt(l-i-1))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic long nc2(long n, long m) {\n\t\treturn (n*(n-1)/2)%m;\n\t}\n\tstatic long c(long a) {\n\t\treturn a*(a+1)/2;\n\t}\n\tstatic int next(long[] arr, long target)  \n    {  \n        int start = 0, end = arr.length - 1;  \n    \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;  \n    \n            // Move to right side if target is  \n            // greater.  \n            if (arr[mid] < target) {\n                start = mid + 1;  \n            }  \n    \n            // Move left side.  \n            else {  \n                ans = mid;  \n                end = mid - 1;  \n            }  \n        }  \n        return ans;  \n    } \n\t\n\tstatic int prev(long[] arr, long target)  \n    {  \n        int start = 0, end = arr.length - 1;  \n    \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;  \n    \n            // Move to left side if target is  \n            // lesser.  \n            if (arr[mid] > target) {\n                end = mid - 1;  \n            }  \n    \n            // Move right side.  \n            else {  \n                ans = mid;  \n                start = mid + 1;  \n            }  \n        }  \n        return ans;  \n    } \n\n\tstatic long power(long x, long y, long p) \n    { \n        long res = 1; \n        x = x % p; \n                      \n        while (y > 0) \n        { \n            if (y % 2 == 1) \n                res = (res * x) % p; \n            y = y >> 1;\n            x = (x * x) % p; \n        } \n        return  res; \n    } \n    static long modInverse(long n, long p) \n    { \n        return power(n, p-2, p); \n    } \n    static long nCrModP(long n, long r, \n                                    long p) \n    { \n        if(r>n)\n        \treturn 0;\n    \tif (r == 0) \n            return 1; \n        long[] fac = new long[(int) (n+1)]; \n        fac[0] = 1; \n        for (int i = 1 ;i <= n; i++) \n            fac[i] = fac[i-1] * i % p;\n        return (fac[(int) n]* modInverse(fac[(int) r], p) \n                % p * modInverse(fac[(int) (n-r)], p) \n                                    % p) % p; \n    } \n\tstatic String reverse(String str)\n\t{\n\t\treturn new StringBuffer(str).reverse().toString();\n\t}\n\n\n\n\tstatic long fastpow(long x, long y, long m)  \n    { \n        if (y == 0) \n            return 1; \n          \n        long p = fastpow(x, y / 2, m) % m; \n        p = (p * p) % m; \n      \n        if (y % 2 == 0) \n            return p; \n        else\n            return (x * p) % m; \n    } \n\t\n\tstatic boolean isPerfectSquare(long l)\n\t{\n\t\treturn Math.pow((long)Math.sqrt(l),2)==l;\n\t}\n\t\n\t\n\tstatic void merge(long[] arr, int l, int m, int r) \n    { \n        // Find sizes of two subarrays to be merged \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        /* Create temp arrays */\n        long L[] = new long [n1]; \n        long R[] = new long [n2]; \n  \n        /*Copy data to temp arrays*/\n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        /* Merge the temp arrays */\n  \n        // Initial indexes of first and second subarrays \n        int i = 0, j = 0; \n  \n        // Initial index of merged subarry array \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        /* Copy remaining elements of L[] if any */\n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        /* Copy remaining elements of R[] if any */\n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    // Main function that sorts arr[l..r] using \n    // merge() \n    static void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            // Find the middle point \n            int m = (l+r)/2; \n  \n            // Sort first and second halves \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            // Merge the sorted halves \n            merge(arr, l, m, r); \n        } \n    } \n\tstatic void merge(int arr[], int l, int m, int r) \n    { \n        // Find sizes of two subarrays to be merged \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        /* Create temp arrays */\n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        /*Copy data to temp arrays*/\n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        /* Merge the temp arrays */\n  \n        // Initial indexes of first and second subarrays \n        int i = 0, j = 0; \n  \n        // Initial index of merged subarry array \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        /* Copy remaining elements of L[] if any */\n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        /* Copy remaining elements of R[] if any */\n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    // Main function that sorts arr[l..r] using \n    // merge() \n    static void sort(long arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            // Find the middle point \n            int m = (l+r)/2; \n  \n            // Sort first and second halves \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            // Merge the sorted halves \n            merge(arr, l, m, r); \n        } \n    } \n    static class Pair implements Comparable<Pair>{\n        int a;\n        int b;\n        Pair(int a,int b){\n            this.a=a;\n \n            this.b=b;\n        }   \n        public int compareTo(Pair p){\n            if(a>p.a)\n                return 1;\n            if(a==p.a)\n                return (b-p.b);\n            return -1;\n        }\n    }\n\tstatic class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[128]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    } \n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class  test{\n\t\n\t// ArrayList<Integer> lis = new ArrayList<Integer>();\n\t// ArrayList<String> lis = new ArrayList<String>();\n\t//  PriorityQueue<P> que = new PriorityQueue<P>();\n\t// PriorityQueue<Integer> que = new PriorityQueue<Integer>();\n\t//  Stack<Integer> que = new Stack<Integer>();\n    //\tstatic long sum=0;\n\t// 1000000007 (10^9+7)\n\tstatic int mod = 1000000007;\n\t//static int mod = 1000000009,r=0;\n   // static int dx[]={1,-1,0,0};\n//\tstatic int dy[]={0,0,1,-1};\n//\tstatic int dx[]={1,-1,0,0,1,1,-1,-1};\n//  static int dy[]={0,0,1,-1,1,-1,1,-1};\n\t//static long H,L;\n\t//static Set<Integer> set = new HashSet<Integer>();\npublic  static void main(String[] args)   throws Exception, IOException{\n   //String line=\"\"; throws Exception, IOException\n   //(line=br.readLine())!=null\n\t//Scanner sc =new Scanner(System.in);\n\t// !!caution!! int long //  \n\tReader sc = new Reader(System.in);\n  // while( ){\n\t  // int  n=sc.nextInt(),m=sc.nextInt();//a[]=new int[n],b[]=new int[n];\n\tint  n=sc.nextInt(),r=0;long k=sc.nextInt();\n    Integer x[]=new Integer[n];\n\t boolean b[]=new boolean[n];\n   \n   for(int i=0;i<n;i++){\n\t   x[i]=sc.nextInt();\n  }\n   if( k==1 ){System.out.println(n); return;}\n   sort(x);\n   \n   for(int i=0;i<n;i++){\n\t if( b[i] )continue;\n\t r++;\n\t long p=x[i],pr=x[i];\n\t while( p*k<=x[n-1] ) {p*=k;\n\t \n\t int up=n,dw=0,mid=(up+dw)/2;\n\t boolean f=false;\n\t while( up-dw!=1 ){\n\t\t //db(p,x[mid]);\n\t\t if( x[mid]==p ){f=true;break;}\n\t\t if( p<x[mid] ){ up=mid; mid=(up+dw)/2; }\n\t\t else { dw=mid; mid=(up+dw)/2; }\n\t }\n\t  if( f ){ if(pr*k!=p){r++; pr=p;}   b[mid]=true;  } \n\t  }\n\t\n\t \n  }\n\n    System.out.println(r);\n\t   \n}\n\nstatic void db(Object... os){\n    System.err.println(Arrays.deepToString(os));\n\n}\n\n\n}\n\nclass Reader\n{\n\tprivate BufferedReader x;\n\tprivate StringTokenizer st;\n\t\n\tpublic Reader(InputStream in)\n\t{\n\t\tx = new BufferedReader(new InputStreamReader(in));\n\t\tst = null;\n\t}\n\tpublic String nextString() throws IOException\n\t{\n\t\twhile( st==null || !st.hasMoreTokens() )\n\t\t\tst = new StringTokenizer(x.readLine());\n\t\treturn st.nextToken();\n\t}\n\tpublic int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(nextString());\n\t}\n\tpublic long nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(nextString());\n\t}\n\tpublic double nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(nextString());\n\t}\n}\n\n/*\n\nclass P implements Comparable<P>{\n\tint x,y;\n\tP(int x,int y){ this.x=x; this.y=y;  }\n\t\n\tpublic int compareTo(P z) {\n\t if( x-z.x!=0)   return  x-z.x ;  //ascend \n\t else return  y-z.y ; \n\t}\n}\n//*/\n", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class GeorgeInterestingGraph {\n    \n    int N = 505;\n    int INF = (int) 1e9;\n    \n    List<Integer>[] G = new List[N];\n    int[] match = new int[N];\n    int[] used = new int[N];\n    int cur = 0;\n    \n    {\n        for (int i = 0; i < N; i++) G[i] = new ArrayList<>(1);\n    }\n    \n    void solve() {\n        int n = in.nextInt(), m = in.nextInt();\n        int[] fr = new int[m], to = new int[m];\n        for (int i = 0; i < m; i++) {\n            fr[i] = in.nextInt() - 1;\n            to[i] = in.nextInt() - 1;\n        }\n        \n        int ans = INF;\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                G[j].clear();\n                match[j] = -1;\n            }\n            for (int j = 0; j < m; j++) {\n                if (fr[j] == i || to[j] == i) {\n                    cnt++;\n                } else {\n                    G[fr[j]].add(to[j]);\n                }\n            }\n            \n            int other = m - cnt;\n            \n            int max = 0;\n            for (int j = 0; j < n; j++) {\n                cur++;\n                augment(j);\n            }\n            for (int j = 0; j < n; j++) if (match[j] >= 0) max++;\n            \n            ans = Math.min(ans, 2 * (n - 1) + 1 - cnt + other - max + (n - 1) - max);\n        }\n        out.println(ans);\n    }\n    \n    boolean augment(int u) {\n        if (used[u] == cur) return false;\n        used[u] = cur;\n        for (int v : G[u]) {\n            if (match[v] < 0 || augment(match[v])) {\n                match[v] = u;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new GeorgeInterestingGraph().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "complexity": "cubic", "problem": "0387_D", "from": "CODEFORCES", "tags": "graph matchings"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.util.regex.*;\n\npublic class Codeforces{\n\t\n\tstatic class MyScanner{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t\n\t\tMyScanner(FileReader fileReader){\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\t\t\n\t\tMyScanner(){\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tString nn(){\n\t\t\twhile(st == null || !st.hasMoreElements()){\n\t\t\t\ttry{\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}catch(IOException e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tchar nc(){\n\t\t\treturn nn().charAt(0);\n\t\t}\n\t\t\n\t\tint ni(){\n\t\t\treturn Integer.parseInt(nn());\n\t\t}\n\t\t\n\t\tlong nl(){\n\t\t\treturn Long.parseLong(nn());\n\t\t}\n\t\t\n\t\tdouble nd(){\n\t\t\treturn Double.parseDouble(nn());\n\t\t}\n\t\t\n\t\tint[] niArr0(int n){\n\t\t\tint[] ar = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) ar[i] = ni();\n\t\t\treturn ar;\n\t\t}\n\t\t\n\t\tint[] niArr1(int n){\n\t\t\tint[] ar = new int[n + 1];\n\t\t\tfor(int i = 1; i <= n; i++) ar[i] = ni();\n\t\t\treturn ar;\n\t\t}\n\t\t\n\t\tlong[] nlArr0(int n){\n\t\t\tlong[] ar = new long[n];\n\t\t\tfor(int i = 0; i < n; i++) ar[i] = nl();\n\t\t\treturn ar;\n\t\t}\n\t}\n\t\n\tpublic static <T> void mprintln(T ... ar){\n\t\tfor(T i: ar) out.print(i + \" \");\n\t\tout.println();\n\t}\n\t\n\tprivate static PrintWriter out;\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException{\n\t\t\n\t\t// Input from file\n\t\t// File inputFile = new File(\"JavaFile.txt\");\n\t\t// File outputFile = new File(\"JavaOutputFile.txt\");\n\t\t// FileReader fileReader = new FileReader(inputFile);\n\t\t// Here it ends\n\t\t\t\n\t\tMyScanner sc = new MyScanner();\n\t\t// MyScanner sc = new MyScanner(fileReader);\n\t\t\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out)); // Output to console\n\t\t// out = new PrintWriter(new PrintStream(outputFile)); // Output to file\n\t\t\n\t\tgetAns(sc);\n\t\t\n\t\tout.close();\n\t}\n\t\n\tprivate static void getAns(MyScanner sc){\n\t\tint n = sc.ni();\n\t\tlong[] ar = sc.nlArr0(n);\n\t\t\n\t\tHashMap<Long, ArrayList<int[]>> map = new HashMap();\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tlong cur = 0;\n\t\t\tfor(int j = i; j >= 0; j--){\n\t\t\t\tcur += ar[j];\n\t\t\t\tif(!map.containsKey(cur)) map.put(cur, new ArrayList());\n\t\t\t\tmap.get(cur).add(new int[]{j + 1, i + 1});\n\t\t\t}\n\t\t}\n\t\t\n\t\t// System.out.println(map);\n\t\t\n\t\tSet<Long> set = map.keySet();\n\t\t// System.out.println(set);\n\t\tArrayList<int[]> ans = new ArrayList();\n\t\t\n\t\tfor(Long l: set){\n\t\t\tArrayList<int[]> cur = new ArrayList();\n\t\t\tint right = -1;\n\t\t\tfor(int[] arc: map.get(l)) if(arc[0] > right){\n\t\t\t\tright = arc[1];\n\t\t\t\tcur.add(arc);\n\t\t\t}\n\t\t\t\n\t\t\tif(cur.size() > ans.size()) ans = cur;\n\t\t}\n\t\t\n\t\tout.println(ans.size());\n\t\tfor(int[] arc: ans) mprintln(arc[0], arc[1]);\n\t}\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.util.Scanner;\n\n\npublic class A {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long n = sc.nextLong();\n    System.out.println(3 * (n / 2));\n  }\n}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.math.BigInteger;\n\npublic class Main {\n\tfinal int INF = 1000000000;\n\tfinal int MAXN = 100100;\t\n\t\n\tScanner input = new Scanner(System.in);\n\tBufferedReader inp = new BufferedReader(new InputStreamReader(System.in));\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tdouble a, v;\n\tdouble l, d, w;\n\t\n\tvoid run() throws IOException {\n\t\ta = input.nextDouble();\n\t\tv = input.nextDouble();\n\t\tl = input.nextDouble();\n\t\td = input.nextDouble();\n\t\tw = input.nextDouble();\n\t\tif (v <= w) {\n\t\t\tout.println(timeTravel(l, 0));\n\t\t} else {\n\t\t\tdouble tw = w / a;\n\t\t\tdouble dw = dist(tw, 0);\n\t\t\tif (dw >= d) {\n\t\t\t\tout.println(timeTravel(l, 0));\n\t\t\t} else {\n\t\t\t\tdouble tSym = timeTravel((d - dw) / 2, w);\n\t\t\t\tout.println(tw + 2 * tSym + timeTravel(l - d, w));\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\t\n\t\n\tdouble dist(double time, double speed) {\n\t\treturn speed * time + a * time * time / 2; \n\t}\n\t\n\tdouble timeTravel(double distance, double speed) {\n\t\tdouble delta = speed * speed + 2 * a * distance;\n\t\tdouble tAll = (Math.sqrt(delta) - speed) / a;\n\t\tdouble tMax = (v - speed) / a;\n\t\tif (tMax >= tAll) {\n\t\t\treturn tAll;\n\t\t} else {\n\t\t\treturn tMax + (distance - dist(tMax, speed)) / v;\n\t\t}\n\t}\n}", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.Scanner;\n\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tlong MOD = 1000000007;\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong[][]dp = new long[n][5010];\n\t\tchar[] program = new char[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tprogram[i] = sc.next().charAt(0);\n\t\t}\n\t\t\n\t\tdp[0][0] = 1;\n\t\t\n\t\tlong[] acc = new long[5010];\n\t\t\n\t\tacc[0] = 1;\n\t\t\n\t\tfor(int i = 1 ; i < n; i++){\n\t\t\tfor(int j = 0; j< 5010; j++){\n\t\t\t\tif(program[i-1] == 'f'){\n\t\t\t\t\tif(j - 1 >= 0){\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j-1];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = acc[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tacc[5009] = dp[i][5009];\n\t\t\tfor(int j = 5008; j >= 0; j--){\n\t\t\t\tacc[j] = (acc[j + 1] + dp[i][j]) % MOD;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(acc[0]);\n\t}\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            boolean[] isF = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                isF[i] = in.readCharacter() == 'f';\n            }\n            int[][] mem = new int[n + 1][n + 1];\n            mem[n][0] = 1;\n            for (int idx = n - 1; idx >= 0; idx--) {\n                for (int indentLevel = 0; indentLevel < n; indentLevel++) {\n                    mem[idx + 1][indentLevel + 1] += mem[idx + 1][indentLevel];\n                    mem[idx + 1][indentLevel + 1] %= MiscUtils.MOD7;\n                    int res = isF[idx] ?\n                            mem[idx + 1][indentLevel + 1] - mem[idx + 1][indentLevel] :\n                            mem[idx + 1][indentLevel];\n                    mem[idx][indentLevel] = (res + MiscUtils.MOD7) % MiscUtils.MOD7;\n                }\n            }\n            out.printLine(mem[0][0]);\n        }\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public char readCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n    }\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n    }\n}\n\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class B {\n    public static void main(String args[]) {\n        FastScanner sc = new FastScanner();\n\n        int testSize = sc.nextInt();\n\n        for (int t = 0; t < testSize; t++) {\n            int n = sc.nextInt();\n\n            if (isSquareProduct2(n) || isSquareProduct4(n)) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n    }\n\n    public static boolean isSquareProduct2(int n) {\n        if (n % 2 == 1) {\n            return false;\n        }\n\n        n /= 2;\n\n        int x = 2;\n\n        while (x * x <= n) {\n            if (n % (x * x) == 0) {\n                n /= (x * x);\n                x = 2;\n\n            } else {\n                x++;\n            }\n        }\n\n        return n == 1;\n    }\n\n    public static boolean isSquareProduct4(int n) {\n        if (n % 4 != 0) {\n            return false;\n        }\n\n        n /= 4;\n\n        int x = 2;\n\n        while (x * x <= n) {\n            if (n % (x * x) == 0) {\n                n /= (x * x);\n                x = 2;\n\n            } else {\n                x++;\n            }\n        }\n\n        return n == 1;\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n}\n", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Sol{\nstatic InputStream inputStream = System.in;\nstatic OutputStream outputStream = System.out;\nstatic FastReader in=new FastReader(inputStream);\nstatic PrintWriter out=new PrintWriter(outputStream);\n\nstatic class FastReader \n{ \n  BufferedReader br; \n  StringTokenizer st; \n \n  public FastReader(InputStream in) \n  { \n      br = new BufferedReader(new\n               InputStreamReader(System.in)); \n  } \n \n  public String next() \n  { \n      while (st == null || !st.hasMoreElements()) \n      { \n          try\n          { \n              st = new StringTokenizer(br.readLine()); \n          } \n          catch (IOException  e) \n          { \n              e.printStackTrace(); \n          } \n      } \n      return st.nextToken(); \n  } \n \n  public int nextInt() \n  { \n      return Integer.parseInt(next()); \n  } \n \n  public long nextLong() \n  { \n      return Long.parseLong(next()); \n  } \n \n public  double nextDouble() \n  { \n      return Double.parseDouble(next()); \n  } \n \n \n  String nextLine() \n  { \n      String str = \"\"; \n      try\n      { \n          str = br.readLine(); \n      } \n      catch (IOException e) \n      { \n          e.printStackTrace(); \n      } \n      return str; \n  } \n}\n\n\n\n//----------------------------------------------------------------------------------------------//\n\n//----------------S  T  A  R  T  ---------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------//\n\n/*linear sieve nlogn\nint n=(int)Math.pow(10,6)+100;\nlong mod=998244353;\nlong d[]=new long[n];\n\nfor(int i=1;i<n;i++){ for(int j=i; j<n; j+=i){ d[j] += 1; }}\n\nlong pre[]=new long[n];\n\npre[1]=1;d[1]=1;\nfor(int i=2;i<n;i++){d[i]+=pre[i-1]%mod;pre[i] += (pre[i-1]+d[i])%mod;}*/\n\nstatic class Pair {\n        int id;long val;\n        public Pair(int id,long val) {\n          \n          this.id=id;\n         this.val=val;\n        }\n       \n      }\n\n/*----------nCx---------------\nlong Comb[][]=new long[61][61];\n\nfor(int i=1;i<=60;i++){Comb[i][0]=1;}\nfor(int i=1;i<=60;i++){Comb[i][1]=i;Comb[i][i]=1;}\nfor(int i=2;i<=60;i++){for(int j=1;j<i;j++){Comb[i][j]=Comb[i-1][j]+Comb[i-1][j-1];}}\n----------nCx------------------\n*/\n\n/*----------DFS-------------\nstatic void DFS(int v,int p){\ndp[0][v]=0;dp[1][v]=0;\nfor(int u:adj[v]){\nif(u==p)continue;\nDFS(u,v);\ndp[0][v]+=Math.max(Math.abs(A[0][u]-A[0][v]) + dp[0][u], Math.abs(A[1][u]-A[0][v]) + dp[1][u] );\ndp[1][v]+=Math.max(Math.abs(A[0][u]-A[1][v]) + dp[0][u], Math.abs(A[1][u]-A[1][v]) + dp[1][u] );\n}\n\n}\n\nstatic int N=(int)Math.pow(10,5)+10;\nstatic ArrayList<Integer> adj[]=new ArrayList[N];\nstatic long dp[][]=new long[2][N];\nstatic long A[][]=new long[2][N];\n\n-----------DFS--------------\n*/\n/*static class Edge implements Comparable<Edge>{\nint destination;long cost;\nEdge(int destination,long cost){this.cost=cost;this.destination=destination;}\n\n@Override\n\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn Long.compare(cost, o.cost);\n\t\t}\n}\n\n*/\n\npublic static void main(String []args){\n\nint t=in.nextInt();\n\nwhile(t-->0){\nint n=in.nextInt();\nint s[]=new int[n];int curr=0;\nwhile(n-->0){\nint x=in.nextInt();\nif(x==1){s[curr]=1;curr++;}\nelse{  \n      while(curr>0){ if(s[curr-1]+1==x){s[curr-1]=x;  break;} else curr--; }\n    }\nfor(int j=0;j<curr;j++){if(j>0)out.print(\".\"); \n                               out.print(s[j]); }\nout.println();\n\n}\n\n\n\n}\n\nout.close();\n}}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class cf1497_Div2_E2 {\n\tstatic int[] spf;\n\t\n\tpublic static int factor(int n) {\n\t\tint val = 1;\n\t\twhile (n > 1) {\n\t\t\tint cnt = 0;\n\t\t\tint p = spf[n];\n\t\t\twhile (n % p == 0) {\n\t\t\t\tcnt++;\n\t\t\t\tn /= p;\n\t\t\t}\n\t\t\tif (cnt % 2 == 1)\n\t\t\t\tval *= p;\n\t\t}\n\t\treturn val;\n\t}\n\t\n\tpublic static void main(String args[]) throws IOException {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint t = in.nextInt();\n\t\tint max = (int)(1e7) + 1;\n\t\t\n\t\tboolean[] prime = new boolean[max + 1]; \n\t\tArrays.fill(prime, true);\n\t\tprime[0] = prime[1] = false;\n\t\tspf = new int[max];\n\t\tfor (int i = 2; i < max; i++) spf[i] = i;\n\t\tfor (int i = 2; i * i < max; i++) {\n\t\t\tif (prime[i]) {\n\t\t\t\tspf[i] = i;\n\t\t\t\tfor (int j = i * i; j < max; j += i) {\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t\tspf[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] cnts = new int[max];\n\t\t\n\t\tfor ( ; t > 0; t--) {\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint[] vals = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tvals[i] = factor(in.nextInt());\n\t\t\t\n\t\t\t// left[i][x] = l where al ... ai such that in x moves it is valid subsequence\n\t\t\tint[][] left = new int[n + 1][k + 1];\n\t\t\t// x y z w a b c\n\t\t\t\n\t\t\tfor (int x = 0; x <= k; x++) {\n\t\t\t\tint l = n;\n\t\t\t\tint now = 0;\n\t\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\t\twhile (l - 1 >= 0 && now + ((cnts[vals[l - 1]] > 0) ? 1 : 0) <= x) {\n\t\t\t\t\t\tl--;\n\t\t\t\t\t\tnow += ((cnts[vals[l]] > 0) ? 1 : 0);\n\t\t\t\t\t\t// System.out.println(now);\n\t\t\t\t\t\tcnts[vals[l]]++;\n\t\t\t\t\t}\n\t\t\t\t\t// System.out.println(i + \" \" + x + \" \" + l + \" \" + now);\n\t\t\t\t\tleft[i][x] = l;\n\t\t\t\t\tif (cnts[vals[i]] > 1) now--;\n\t\t\t\t\tcnts[vals[i]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// for (int[] x: left)\n\t\t\t\t// System.out.println(Arrays.toString(x));\n\t\t\n\t\t\t\t\n\t\t\tint oo = (int)(1e9);\n\t\t\t\n\t\t\tint[][] dp = new int[n + 1][k + 1];\n\t\t\t\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tArrays.fill(dp[i], oo);\n\t\t\t\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 0; j <= k; j++) {\n\t\t\t\t\tif (j > 0) dp[i][j] = dp[i][j - 1];\n\t\t\t\t\tfor (int x = 0; x <= j; x++) {\n\t\t\t\t\t\tint l = left[i - 1][x];\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[l][j - x] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i <= k; i++) {\n\t\t\t\tmin = Math.min(min, dp[n][i]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(min);\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\n\t\n\tstatic class FastScanner {\n\t    BufferedReader br;\n\t    StringTokenizer st;\n\t\t\n\t    public FastScanner(InputStream i) {\n\t        br = new BufferedReader(new InputStreamReader(i));\n\t        st = new StringTokenizer(\"\");\n\t    }\n\t\t\t\t\n\t    public String next() throws IOException {\n\t        if(st.hasMoreTokens())\n\t            return st.nextToken();\n\t        else\n\t            st = new StringTokenizer(br.readLine());\n\t        return next();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    //#\n\t    public long nextLong() throws IOException {\n\t        return Long.parseLong(next());\n\t    }\n\t    public double nextDouble() throws IOException {\n\t        return Double.parseDouble(next());\n\t    }\n\t    //$\n\t}\n}\n", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        Main m = new Main();\n        m.run();\n        m.out.close();\n    }\n\n    void run() throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        int k = nextInt();\n        long[][] r = new long[n][m - 1];\n        long[][] d = new long[n - 1][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m - 1; j++) {\n                r[i][j] = nextInt();\n            }\n        }\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < m; j++) {\n                d[i][j] = nextInt();\n            }\n        }\n        if (k % 2 != 0) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    out.print(-1+\" \");\n                }\n                out.println();\n            }\n            return;\n        }\n        long[][][] dp = new long[n][m][k + 1];\n        for (int kk = 2; kk <= k; kk += 2)\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    long ans = (long) 1e18;\n                    if (i + 1 < n) {\n                        ans = Math.min(ans, dp[i + 1][j][kk - 2] + d[i][j]*2);\n                    }\n                    if (i - 1 > -1) ans = Math.min(ans, dp[i - 1][j][kk - 2] + d[i - 1][j]*2);\n                    if (j + 1 < m) ans = Math.min(ans, dp[i][j + 1][kk - 2] + r[i][j]*2);\n                    if (j - 1 > -1) ans = Math.min(ans, dp[i][j - 1][kk - 2] + r[i][j - 1]*2);\n                    dp[i][j][kk] = ans;\n                }\n            }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                out.print(dp[i][j][k] + \" \");\n            }\n            out.println();\n        }\n    }\n\n\n    int gcd(int a, int b) {\n        while (a % b != 0) {\n            int h = a % b;\n            a = b;\n            b = h;\n        }\n        return b;\n    }\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter out = new PrintWriter(System.out);\n    StringTokenizer in = new StringTokenizer(\"\");\n\n\n    // pairs\n    class pil implements Comparable<pil> {\n        int first;\n        long second;\n\n        pil(int f, long s) {\n            this.first = f;\n            this.second = s;\n        }\n\n        public int compareTo(pil o) {\n            if (first != o.first) return Integer.compare(first, o.first);\n            return Long.compare(second, o.second);\n        }\n    }\n\n    class pii implements Comparable<pii> {\n        int fi;\n        int se;\n\n        pii(int f, int s) {\n            se = s;\n            fi = f;\n        }\n\n        public int compareTo(pii o) {\n            if (fi != o.fi) return Integer.compare(fi, o.fi);\n            return Integer.compare(se, o.se);\n        }\n    }\n\n    class pis implements Comparable<pis> {\n        int fi;\n        String s;\n\n        pis(int f, String s) {\n            this.s = s;\n            fi = f;\n        }\n\n        public int compareTo(pis o) {\n            return Integer.compare(fi, o.fi);\n        }\n    }\n\n    class vert {\n        int to;\n        int iter;\n        int idx;\n        int ed;\n\n        vert(int s, int f, int zz, int gg) {\n            to = s;\n            iter = f;\n            idx = zz;\n            ed = gg;\n        }\n    }\n\n\n    class pll implements Comparable<pll> {\n        long first;\n        long second;\n\n        pll(long f, long s) {\n            this.first = f;\n            this.second = s;\n        }\n\n        public int compareTo(pll o) {\n            if (first != o.first) return Long.compare(first, o.first);\n            return Long.compare(second, o.second);\n        }\n    }\n\n    class pli implements Comparable<pli> {\n        long first;\n        int second;\n\n        pli(long f, int s) {\n            this.first = f;\n            this.second = s;\n        }\n\n        public int compareTo(pli o) {\n            if (first != o.first) return Long.compare(first, o.first);\n            return Integer.compare(second, o.second);\n        }\n    }\n\n    boolean hasNext() throws IOException {\n        if (in.hasMoreTokens()) return true;\n        String s;\n        while ((s = br.readLine()) != null) {\n            in = new StringTokenizer(s);\n            if (in.hasMoreTokens()) return true;\n        }\n        return false;\n    }\n\n    String nextToken() throws IOException {\n        while (!in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n        return in.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "\n\nimport java.util.*;\n\npublic class B {\n\n    static int[] loyality;\n    static int[] level;\n    static int mid;\n    static int a, n;\n    static double sol;\n\n    public static void getMax(int idx, int rem) {\n        if (idx == loyality.length) {\n            double pos = 0;\n            for (int i = 0; i < (1 << n); i++)\n                pos += solve(i);\n            sol = Math.max(sol, pos);\n            return;\n        }\n        int cur = loyality[idx];\n        int r = 0;\n        while (r + cur <= 10 && r <= rem) {\n            loyality[idx] = cur + r;\n            getMax(idx + 1, rem - r);\n            r++;\n        }\n        loyality[idx] = cur;\n    }\n\n    public static double solve(int mask) {\n        int c = 0;\n        int sum = 0;\n        double b = 1;\n        for (int i = 0; i < n; i++) {\n            if (((1 << i) | mask) == mask) {\n                c++;\n                b *= (loyality[i] / 10.0);\n            } else {\n                sum += level[i];\n                b *= (1 - (loyality[i] / 10.0));\n            }\n        }\n        if (c >= mid)\n            return b;\n        return b * (a * 1.0) / (a + sum);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        int k = sc.nextInt();\n        a = sc.nextInt();\n        level = new int[n];\n        loyality = new int[n];\n        for (int i = 0; i < n; i++) {\n            level[i] = sc.nextInt();\n            loyality[i] = sc.nextInt() / 10;\n        }\n        mid = (n/2) +1;\n        sol = 0;\n        getMax(0, k);\n        System.out.println(sol);\n    }\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.util.*;\n\npublic class code_1 {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner in=new Scanner(System.in);\n\t\t\n\t\tint n=in.nextInt();\n\t\t\n\t\tint a[]=new int[n];\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=in.nextInt();\n\t\t\n\t\tArrays.sort(a);\n\t\t\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\n\t\t\tif(a[i]!=-1) {\n\t\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\t\t\n\t\t\t\t\tif(a[j]%a[i]==0)\n\t\t\t\t\t\ta[j]=-1;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tint count=0;\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\t\n\t\t\tif(a[i]!=-1)\n\t\t\t\tcount++;\n\t\t}\n\t\t\n\t\tSystem.out.println(count);\n\n\t}\n\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "//package contests.CF1019;\n\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class B {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int half = n/2;\n        pw.println(\"? 1\");\n        pw.flush();\n        int a = sc.nextInt();\n        pw.println(\"? \" + (1+half));\n        pw.flush();\n        int b = sc.nextInt();\n        if(a - b == 0){\n            pw.println(\"! 1\");\n        }\n        else\n        if((a - b)%2 != 0)\n        {\n            pw.println(\"! -1\");\n        }else{\n            boolean greater = a > b;\n            int lo = 1;\n            int hi = half;\n\n            boolean ans = false;\n            while(lo <= hi){\n                int mid = (lo + hi) /2;\n                pw.println(\"? \" + mid);\n                pw.flush();\n                a = sc.nextInt();\n                pw.println(\"? \" + (mid+half));\n                pw.flush();\n                b = sc.nextInt();\n\n                if(a == b){\n                    pw.println(\"! \" + mid);\n                    ans = true;\n                    break;\n                }\n\n                if(a > b != greater){\n                    hi = mid-1;\n                }else{\n                    lo = mid+1;\n                    greater = a>b;\n                }\n            }\n\n            if(!ans){\n                pw.println(\"! -1\");\n            }\n\n        }\n\n        pw.flush();\n        pw.close();\n    }\n\n\n\n    static int[][] packD(int n, int[] from, int[] to) {\n        int[][] g = new int[n][];\n        int[] p = new int[n];\n        for (int f : from) if(f != -1) p[f]++;\n        for (int i = 0; i < n; i++) g[i] = new int[p[i]];\n        for (int i = 0; i < from.length; i++) if(from[i] != -1) {g[from[i]][--p[from[i]]] = to[i];}\n        return g;\n    }\n\n    static void shuffle(int[] a)\n    {\n        int n = a.length;\n        for(int i = 0; i < n; i++)\n        {\n            int r = i + (int)(Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n    static class Scanner\n    {\n        StringTokenizer st; BufferedReader br;\n        public Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n        public Scanner(String s) throws FileNotFoundException {\tbr = new BufferedReader(new FileReader(new File(s)));}\n        public String next() throws IOException {while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());return st.nextToken();}\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n        public long nextLong() throws IOException {return Long.parseLong(next());}\n        public String nextLine() throws IOException {return br.readLine();}\n        public boolean ready() throws IOException {return br.ready();}\n    }\n}\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "import java.util.Scanner;\n\npublic class CottageVillage {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint t = in.nextInt();\n\t\tint posCount = 2;\n\t\tdouble[] pos = new double[n];\n\t\tdouble[] a = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpos[i] = in.nextInt();\n\t\t\ta[i] = in.nextInt();\n\t\t\t// int pos = in.nextInt();\n\t\t\t// int a = in.nextInt();\n\t\t\t// if ((pos - (a / 2)) - (lpos + (la / 2)) >= t)\n\t\t\t// posCount += 2;\n\t\t\t// if ((pos - (a / 2)) - (lpos + (la / 2)) == t)\n\t\t\t// posCount--;\n\t\t\t// lpos = pos;\n\t\t\t// la = a;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint posk = (int) pos[i];\n\t\t\tint ak = (int) a[i];\n\t\t\tint j = i - 1;\n\t\t\twhile (j >= 0 && pos[j] > posk) {\n\t\t\t\tpos[j + 1] = pos[j];\n\t\t\t\ta[j + 1] = a[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tpos[j + 1] = posk;\n\t\t\ta[j + 1] = ak;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif ((pos[i] - (a[i] / 2)) - (pos[i - 1] + (a[i - 1] / 2)) > t)\n\t\t\t\tposCount += 2;\n\t\t\tif ((pos[i] - (a[i] / 2)) - (pos[i - 1] + (a[i - 1] / 2)) == t)\n\t\t\t\tposCount += 1;\n\t\t}\n//\t\tfor (int i = 0; i < n; i++)\n//\t\t\tSystem.out.println(pos[i] + \" \" + a[i]);\n\t\t System.out.println(posCount);\n\t}\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.Arrays;\n\n\npublic class A {\n\t\n\t\n\tstatic class team implements Comparable<team>\n\t{\n\t\tint problems;\n\t\tint penalty;\n\t\tpublic team(int problems,int penalty)\n\t\t{\n\t\t\tthis.penalty=penalty;\n\t\t\tthis.problems=problems;\n\t\t}\n\t\tpublic int compareTo(team a) {\n\t\t\tif (a.problems==this.problems)\n\t\t\t\treturn this.penalty - a.penalty;\n\t\t\treturn a.problems - this.problems;\n\t\t}\n\t\t\n\t\tpublic boolean igual(team a)\n\t\t{\n\t\t\tif (this.problems!=a.problems)\n\t\t\t\treturn false;\n\t\t\treturn (this.penalty==a.penalty);\n\t\t}\n\t}\n\t\n\tstatic class Scanner\n\t{\n\t\tBufferedReader rd;\n\t\tStringTokenizer tk;\n\t\tpublic Scanner() throws IOException\n\t\t{\n\t\t\trd=new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttk=new StringTokenizer(rd.readLine());\n\t\t}\n\t\tpublic String next() throws IOException\n\t\t{\n\t\t\tif (!tk.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttk=new StringTokenizer(rd.readLine());\n\t\t\t\treturn tk.nextToken();\n\t\t\t}\n\t\t\treturn tk.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws NumberFormatException, IOException\n\t\t{\n\t\t\treturn Integer.valueOf(this.next());\n\t\t}\n\t}\n\t\n\t\n\tstatic team[] array=new team[100];\n\tstatic int N,K;\n\t\n\tpublic static void main(String args[]) throws IOException\n\t{\n\t\tScanner sc=new Scanner();\n\t\tN=sc.nextInt();\n\t\tK=sc.nextInt();\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tarray[i]=new team(sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tArrays.sort(array,0,N);\n\t\t/*\n\t\tfor(int i=0;i<N;i++)\n\t\t\tSystem.out.println(array[i].problems);*/\n\t\t\n\t\tint shared=0;\n\t\tfor(int i=K-1;i>=0 && array[K-1].igual(array[i]);i--,shared++);\n\t\tfor(int i=K;i<N && array[K-1].igual(array[i]);i++,shared++);\n\t\tSystem.out.println(shared);\n\t}\n\n}", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class round111A {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int [] coins = new int [n];\n        for(int i = 0 ; i < n ; ++i)\n            coins[i] = sc.nextInt();\n        Arrays.sort(coins);\n        int ans = (int)1e9;\n        for(int i = 1 ; i <= n ; ++i){\n            int sum1 = 0;\n            int c = 0;\n            int j = n - 1;\n            for(j = n - 1 ; j >= 0 && c < i ; --j, ++c){\n                sum1 += coins[j];\n            }\n            int sum2 = 0;\n            for(int k = 0 ; k <= j ; ++k)\n                sum2 += coins[k];\n            if(sum1 > sum2){\n                System.out.println(i);\n                return;\n            }\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import static java.lang.Math.*;\n\nimport java.io.*;\n\nimport java.math.*;\n\nimport java.util.*;\n\n\n\npublic class Solution implements Runnable {\n\n\n\n\tpublic static void main(String... strings) throws InterruptedException {\n\n\t\tnew Thread(new Solution()).start();\n\n\t}\n\n\n\n\tBufferedReader in;\n\n\tPrintWriter out;\n\n\tStringTokenizer st;\n\n\n\n\tString next() throws Exception {\n\n\t\tif (st == null || !st.hasMoreElements())\n\n\t\t\tst = new StringTokenizer(in.readLine());\n\n\t\treturn st.nextToken();\n\n\t}\n\n\n\n\tint nextInt() throws Exception {\n\n\t\treturn Integer.parseInt(next());\n\n\t}\n\n\n\n\tdouble nextDouble() throws Exception {\n\n\t\treturn Double.parseDouble(next());\n\n\t}\n\n\n\n\tlong nextLong() throws Exception {\n\n\t\treturn Long.parseLong(next());\n\n\t}\n\n\n\n\t@Override\n\n\tpublic void run() {\n\n\t\ttry {\n\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\n\t\t\tout = new PrintWriter(new FileWriter(\"output.txt\"));\n\n\t\t\tsolve();\n\n\t\t} catch (Exception e) {\n\n\t\t\tthrow new RuntimeException(e);\n\n\t\t} finally {\n\n\t\t\tout.close();\n\n\t\t}\n\n\t}\n\n\tint n, m, k, xor = 0;\n\n\tboolean[][] used;\n\n\tHashSet<Long> [] set;\n\n\tvoid solve() throws Exception {\n\n\t\tn = nextInt();\n\n\t\tm = nextInt();\n\n\t\tk = nextInt();\n\n\t\tused = new boolean[n][m];\n\n\t\tset = new HashSet[2];\n\n\t\tfor(int i = 0; i < 2; set[i++] = new HashSet<Long>());\n\n\t\t\n\n\t\tfor(int i = 0; i < k; i++){\n\n\t\t\tint x = nextInt()-1, y = nextInt()-1;\n\n\t\t\tused[x][y] = true;\n\n\t\t\tset[0].add(10000L*x + y);\n\n\t\t}\n\n\t\tfor (;;xor ^= 1){\n\n\t\t\tset[xor^1].clear();\n\n\t\t\tint ansx = -1, ansy = -1;\n\n\t\t\tfor (long i : set[xor]){\n\n\t\t\t\tint x = (int)(i/10000), y = (int)(i%10000);\n\n\t\t\t\tif (ansx < 0){\n\n\t\t\t\t\tansx = x+1;\n\n\t\t\t\t\tansy = y+1;\n\n\t\t\t\t}\n\n\t\t\t\tadd(x+1, y);\n\n\t\t\t\tadd(x-1, y);\n\n\t\t\t\tadd(x, y+1);\n\n\t\t\t\tadd(x, y-1);\n\n\t\t\t}\n\n\t\t\tif (set[xor^1].size() == 0){\n\n\t\t\t\tout.println(ansx + \" \" + ansy);\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tpublic void add(int x, int y){\n\n\t\tif (!( x >= 0 && y >= 0 && x < n && y < m && !used[x][y])) return;\n\n\t\tset[xor^1].add(10000L*x + y);\n\n\t\tused[x][y] = true;\n\n\t}\n\n\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class ChainReaction implements Closeable {\n\n  private InputReader in = new InputReader(System.in);\n  private PrintWriter out = new PrintWriter(System.out);\n  \n  private class Beacon implements Comparable<Beacon> {\n    private int position, range, score;\n\n    private Beacon(int position, int range) {\n      this.position = position;\n      this.range = range;\n    }\n\n    public void setScore(int score) {\n      this.score = score;\n    }\n\n    @Override\n    public int compareTo(Beacon o) {\n      return Integer.compare(this.position, o.position);\n    }\n  }\n\n  public void solve() {\n    int n = in.ni();\n    if (n == 1) {\n      out.println(0);\n      return;\n    }\n    beacons = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      beacons.add(new Beacon(in.ni(), in.ni()));\n    }\n    beacons.sort(Comparator.naturalOrder());\n    for (int i = 1; i < n; i++) {\n      int left = 0, right = i - 1, position = beacons.get(i).position, range = beacons.get(i).range;\n      int leftmost = i;\n      while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (position - range <= beacons.get(mid).position) {\n          leftmost = Math.min(leftmost, mid);\n          right = mid - 1;\n        } else {\n          left = mid + 1;\n        }\n      }\n      beacons.get(i).setScore(i - leftmost);\n    }\n    dp = new Integer[n];\n    int ans = Integer.MAX_VALUE;\n    for (int i = n - 1; i >= 0; i--) {\n      ans = Math.min(n - 1 - i + recurse(i), ans);\n    }\n    out.println(ans);\n  }\n  \n  private List<Beacon> beacons;\n  private Integer[] dp;\n  \n  private int recurse(int idx) {\n    if (idx <= 0) return 0;\n    \n    if (dp[idx] != null) return dp[idx];\n    \n    int destroyed = beacons.get(idx).score;\n    int ans = destroyed + recurse(idx - destroyed - 1);\n    return dp[idx] = ans;\n  }\n  \n  @Override\n  public void close() throws IOException {\n    in.close();\n    out.close();\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int ni() {\n      return Integer.parseInt(next());\n    }\n\n    public long nl() {\n      return Long.parseLong(next());\n    }\n\n    public void close() throws IOException {\n      reader.close();\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    try (ChainReaction instance = new ChainReaction()) {\n      instance.solve();\n    }\n  }\n}\n", "complexity": "nlogn", "problem": "0608_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int n=Integer.parseInt(bu.readLine());\n        int i;\n        String s[]=bu.readLine().split(\" \");\n        Long a[]=new Long[n];\n        HashMap<Long,Integer> hm=new HashMap<>();\n        for(i=0;i<n;i++)\n        {\n            a[i]=Long.parseLong(s[i]);\n            hm.put(a[i],1);\n        }\n        Arrays.sort(a);\n\n        long p2[]=new long[32];\n        p2[0]=1;\n        for(i=1;i<32;i++) p2[i]=p2[i-1]*2;\n\n        ArrayList<Long> ans=new ArrayList<>();\n        for(i=0;i<31;i++)\n        {\n            int j;\n            for(j=0;j<n;j++)\n            {\n                ArrayList<Long> tem=new ArrayList<>();\n                tem.add(a[j]);\n                if(hm.get(a[j]+p2[i])!=null) tem.add(a[j]+p2[i]);\n                long cr=a[j]+p2[i];\n                if(hm.get(cr+p2[i])!=null) tem.add(cr+p2[i]);\n                if(tem.size()>ans.size())\n                {\n                    ans=new ArrayList<>();\n                    for(long x:tem) ans.add(x);\n                }\n            }\n        }\n        sb.append(ans.size()+\"\\n\");\n        for(long x: ans) sb.append(x+\" \");\n        System.out.print(sb);\n    }\n}\n", "complexity": "nlogn", "problem": "0988_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.*;\n\nimport java.awt.geom.Point2D;\nimport java.text.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\n\tfinal String filename = \"\";\n\n\tpublic void solve() throws Exception {\n\t\tint n = iread(), m = iread();\n\t\tint INF = -1;\n\t\tif (m > n) {\n\t\t\tint t = m;\n\t\t\tm = n;\n\t\t\tn = t;\n\t\t}\n\t\tint[][][] d = new int[2][1 << m][1 << m];\n\t\tfor (int i = 0; i < 1 << m; i++)\n\t\t\tArrays.fill(d[0][i], INF);\n\n\t\tint[] cnt = new int[1 << m];\n\t\tfor (int i = 0; i < 1 << m; i++)\n\t\t\tcnt[i] = cnt[i / 2] + i % 2;\n\n\t\tint step = 0;\n\t\td[0][0][0] = 0;\n\t\tfor (int u = 0; u < n; u++) {\n\t\t\tfor (int i = 0; i < 1 << m; i++)\n\t\t\t\tArrays.fill(d[step ^ 1][i], INF);\n\t\t\tfor (int mask1 = 0; mask1 < 1 << m; mask1++)\n\t\t\t\tfor (int mask2 = 0; mask2 < 1 << m; mask2++) {\n\t\t\t\t\tint t = d[step][mask1][mask2];\n\t\t\t\t\tif (t == INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int mask = 0; mask < 1 << m; mask++) {\n\t\t\t\t\t\tif ((mask1 & mask) != mask1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint mask01 = ((1 << m) - 1) & ~mask2;\n\n\t\t\t\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\t\t\t\tif ((mask & (1 << j)) != 0) {\n\t\t\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\t\t\tmask01 &= ~(1 << (j - 1));\n\t\t\t\t\t\t\t\tmask01 &= ~(1 << j);\n\t\t\t\t\t\t\t\tif (j + 1 < m)\n\t\t\t\t\t\t\t\t\tmask01 &= ~(1 << (j + 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tint mask02 = mask;\n\n\t\t\t\t\t\tint t2 = t + cnt[((1 << m) - 1) & ~mask];\n\t\t\t\t\t\tif (d[step ^ 1][mask01][mask02] < t2) {\n\t\t\t\t\t\t\td[step ^ 1][mask01][mask02] = t2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tstep ^= 1;\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int mask = 0; mask < 1 << m; mask++) {\n\t\t\tans = Math.max(ans, d[step][0][mask]);\n\t\t}\n\t\tout.write(ans + \"\\n\");\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t\t// in = new BufferedReader(new FileReader(filename+\".in\"));\n\t\t\t// out = new BufferedWriter(new FileWriter(filename+\".out\"));\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tpublic int iread() throws Exception {\n\t\treturn Integer.parseInt(readword());\n\t}\n\n\tpublic double dread() throws Exception {\n\t\treturn Double.parseDouble(readword());\n\t}\n\n\tpublic long lread() throws Exception {\n\t\treturn Long.parseLong(readword());\n\t}\n\n\tBufferedReader in;\n\n\tBufferedWriter out;\n\n\tpublic String readword() throws IOException {\n\t\tStringBuilder b = new StringBuilder();\n\t\tint c;\n\t\tc = in.read();\n\t\twhile (c >= 0 && c <= ' ')\n\t\t\tc = in.read();\n\t\tif (c < 0)\n\t\t\treturn \"\";\n\t\twhile (c > ' ') {\n\t\t\tb.append((char) c);\n\t\t\tc = in.read();\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.US);\n\t\t} catch (Exception e) {\n\n\t\t}\n\t\t// new Thread(new Main()).start();\n\t\tnew Thread(null, new Main(), \"1\", 1 << 25).start();\n\t}\n}", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\npublic class D {\n  void solve() {\n    int n = nextInt();\n    int m = nextInt();\n    int k = nextInt();\n    int[][][] cost = new int[n][m][4];\n    for (int i = 0; i<n; i++) {\n      for (int j = 0; j<m; j++) {\n        for (int j2 = 0; j2<4; j2++) {\n          cost[i][j][j2]=Integer.MAX_VALUE/4;\n        }\n      }\n    }\n    for (int i = 0; i<n; i++) {\n      for (int j = 0; j<m-1; j++) {\n        int c = nextInt();\n        cost[i][j][0]=c;\n        cost[i][j+1][1]=c;\n      }\n    }\n    for (int i = 0; i<n-1; i++) {\n      for (int j = 0; j<m; j++) {\n        int c = nextInt();\n        cost[i][j][2]=c;\n        cost[i+1][j][3]=c;\n      }\n    }\n    int[][][] path = new int[k>=4 ? k/2+1 : 2][n][m];\n    for (int i = 0; i<n; i++) {\n      for (int j = 0; j<m; j++) {\n        int minval = cost[i][j][0];\n        minval=min(minval, cost[i][j][1]);\n        minval=min(minval, cost[i][j][2]);\n        minval=min(minval, cost[i][j][3]);\n        path[1][i][j]=minval;\n      }\n    }\n    for (int k2 = 2; k2<=k/2; k2++) {\n      for (int i = 0; i<n; i++) {\n        for (int j = 0; j<m; j++) {\n          int minval = Integer.MAX_VALUE/4;\n          if (i>0)\n            minval=min(minval, path[k2-1][i-1][j]+cost[i][j][3]);\n          if (i<n-1)\n            minval=min(minval, path[k2-1][i+1][j]+cost[i][j][2]);\n          if (j>0)\n            minval=min(minval, path[k2-1][i][j-1]+cost[i][j][1]);\n          if (j<m-1)\n            minval=min(minval, path[k2-1][i][j+1]+cost[i][j][0]);\n          path[k2][i][j]=minval;\n        }\n      }\n    }\n    for (int i = 0; i<n; i++) {\n      for (int j = 0; j<m; j++) {\n        path[0][i][j]=-1;\n      }\n    }\n    int k_show = k%2==1 ? 0 : k/2;\n    if (k_show>0) {\n      for (int i = 0; i<n; i++) {\n        for (int j = 0; j<m; j++) {\n          path[k_show][i][j]*=2;\n        }\n      }\n    }\n    for (int i = 0; i<n; i++) {\n      for (int j = 0; j<m; j++) {\n        out.printf(\"%d \", path[k_show][i][j]);\n      }\n      out.println();\n    }\n  }\n  static int nextInt() {\n    return Integer.parseInt(nextToken());\n  }\n  static String nextToken() {\n    while (!st.hasMoreTokens()) {\n      try {\n        st=new StringTokenizer(br.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(\"out of tokens!\");\n      }\n    }\n    return st.nextToken();\n  }\n  static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n  static StringTokenizer st = new StringTokenizer(\"\");\n  static PrintWriter out = new PrintWriter(System.out);\n  public static void main(String[] a) {\n    new D().solve();\n    out.flush();\n  }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class P220A\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        List<Integer> b = new ArrayList<Integer>(n);\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = sc.nextInt();\n            b.add(a[i]);\n        }\n        Collections.sort(b);\n        int c = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (a[i] != b.get(i)) c++;\n        }\n        if (c == 0 || c == 2)\n        {\n            System.out.println(\"YES\");\n        }\n        else\n        {\n            System.out.println(\"NO\");\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Liavontsi Brechka\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static\n    @SuppressWarnings(\"Duplicates\")\n    class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int MAX = 6000;\n            int MOD = 1000000007;\n\n            int n = in.nextInt();\n            int[][] dp = new int[n][MAX];\n            dp[0][0] = 1;\n\n            char next;\n            int current;\n            for (int i = 0; i < n; i++) {\n                next = in.next().charAt(0);\n                if (i == n - 1) continue;\n\n                current = 0;\n                for (int j = MAX - 1; j >= 0; j--) {\n                    if (dp[i][j] != 0) {\n                        if (next == 'f') {\n                            if (j < MAX - 1) dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD;\n                        } else {\n                            current = (current + dp[i][j]) % MOD;\n                        }\n                    }\n\n                    if (next == 's') dp[i + 1][j] = current;\n                }\n            }\n\n            int res = 0;\n            for (int i = 0; i < MAX; i++) {\n                res = (res + dp[n - 1][i]) % MOD;\n            }\n\n            out.print(res);\n        }\n\n    }\n\n    static class InputReader {\n        private final BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String readLine() {\n            String line;\n            try {\n                line = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return line;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.Scanner;\npublic class P912A\n{\n\tpublic static void main(String[] args)\n\t{\n\t Scanner scan=new Scanner(System.in);\n\t long A,B,x,y,z,a,b,res=0;\n\t A=scan.nextLong();\n\t B=scan.nextLong();\n\t x=scan.nextLong();\n\t y=scan.nextLong();\n\t z=scan.nextLong();\n\t a=2*x;\n\t a+=y;\n\t b=y;\n\t b+=3*z;\n\t if(a>A)\n\t\tres+=a-A;\n\t if(b>B)\n\t\tres+=b-B;\n\t System.out.println(res);\n\t}\n}", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.Scanner;\n\npublic class AlexAndARhombus {\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tSystem.out.println(n*n+(n-1)*(n-1));\n\t\tsc.close();\n\t}\n\n}\n", "complexity": "constant", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\n \npublic class File {\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\tint n=sc.nextInt();\n\t\tint arr[]=new int[n];\n\t\tfor(int i=0;i<n;i++)arr[i]=sc.nextInt();\n\t\tint ans=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t    ans=Math.min(ans,arr[i]/Math.max(i,n-1-i));\n\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n}", "complexity": "linear", "problem": "1159_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.Locale;\nimport java.util.Scanner;\n\npublic class E {\n    public static void main(String[] args) {\n        new E().solve();\n    }\n    \n    private int c(int n) {\n        return n * (n - 1) / 2;\n    }\n    \n    public void solve() {\n        Locale.setDefault(Locale.US);\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        double[][] pb = new double[n][n];\n        for (int i=0; i<n; ++i)\n            for (int j=0; j<n; ++j)\n                pb[i][j] = sc.nextDouble();\n        \n        int m = (1<<n);\n        double[] dp = new double[m];\n        dp[0] = 1.0f;\n        for (int i=1; i<m; ++i)\n            for (int j=0; j<n; ++j) if ((i & (1<<j)) != 0)\n                for (int k=0; k<n; ++k) if ((i & (1<<k)) == 0)\n                    dp[i] += pb[k][j] * dp[i & ~(1<<j)] / c(n - Integer.bitCount(i) + 1);\n        \n        int w = (1<<n) - 1;\n        for (int i=0; i<n-1; ++i)\n            System.out.printf(\"%.6f \", dp[w & ~(1<<i)]);\n        System.out.printf(\"%.6f\\n\", dp[w & ~(1<<(n-1))]);\n    }\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        // write your code here\n        Scanner scanner = new Scanner(System.in);\n        long n = scanner.nextLong();\n        long k = scanner.nextLong();\n        long start = 2;\n        long end = k;\n        //double verifyDouble= (2.0 + (double)k) / 2.0 * ((double) k - 1.0) - ((double) k - 2.0);\n        long verify = (((k * (k + 1)) / 2) - 1) - (k - 2);\n        if (n == 1) {\n            System.out.println(0);\n        } else if (n > verify) {\n            System.out.println(-1);\n        } else {\n            long count = 0;\n            if (n == k) {\n                count = 1;\n                System.out.println(count);\n            } else {\n\n                long number = k / 2 + 1;\n                long sum = 0;\n                double sumDouble = 0;\n                while (start <= end) {\n                    sum = (((k * (k + 1)) / 2) - ((number * (number - 1)) / 2)) - (k - number);\n                    long remainingHouses = (long) Math.abs(sum - n);\n                    if (Math.abs(remainingHouses) < number) {\n                        if (n > sum)\n                            count = k - number + 2;\n                        else count = k - number + 1;\n                        break;\n                    } else if (sum == n) {\n                        count = k - number + 1;\n                        break;\n                    } else if (n > sum) {\n                        end = number - 1;\n                        number = (end + start) / 2;\n                    } else {\n                        start = number + 1;\n                        number = (end + start) / 2;\n                    }\n                }\n                long g = 999999998;\n                if (count == g && n % 10 > 0)\n                    count = count + 1;\n\n                System.out.println(count);\n            }\n\n        }\n    }\n}\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "//package contests.c915;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class C915D implements Runnable {\n\n    private void solve() throws Exception {\n        int n = i(), m = i();\n        List<Set<Integer>> a = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            a.add(new HashSet<>());\n        }\n        for (int i = 0; i < m; i++) {\n            int u = i() - 1, v = i() - 1;\n            a.get(u).add(v);\n        }\n\n        int[] cycle = getCycle(a);\n        if (cycle==null) {\n            System.out.println(\"YES\");\n            return;\n        }\n\n        boolean canBeAcyclyc = false;\n        for (int i = 0; i < cycle.length; i++) {\n            int u = cycle[i];\n            int v;\n            if (i < cycle.length - 1) {\n                v = cycle[i + 1];\n            } else {\n                v = cycle[0];\n            }\n\n            a.get(u).remove(v);\n\n            if (getCycle(a) == null) {\n                canBeAcyclyc = true;\n                break;\n            }\n\n            a.get(u).add(v);\n        }\n\n        if (canBeAcyclyc) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n\n    private int[] getCycle(List<Set<Integer>> a) {\n        int n = a.size();\n        boolean[] visited = new boolean[n];\n\n        int[] cycle = null;\n        for (int i = 0; i < n; i++) {\n            Set<Integer> current = new HashSet<>();\n            List<Integer> backtrack = new ArrayList<>();\n            cycle = dfs(i, a, visited, current, backtrack);\n            if (cycle != null) break;\n        }\n        return cycle;\n    }\n\n    int[] dfs(Integer e, List<Set<Integer>> a, boolean[] visited, Set<Integer> current, List<Integer> backtrack) {\n        if (visited[e]) {\n            if (current.contains(e)) {\n                var result = new ArrayList<Integer>();\n                for (int i = backtrack.indexOf(e); i < backtrack.size(); i++) {\n                    result.add(backtrack.get(i));\n                }\n                return result.stream().mapToInt(i -> i).toArray();\n            }\n            return null;\n        }\n\n        visited[e] = true;\n        current.add(e);\n        backtrack.add(e);\n\n        for (Integer v : a.get(e)) {\n            int[] result = dfs(v, a, visited, current, backtrack);\n            if (result != null)\n                return result;\n        }\n\n        current.remove(e);\n        backtrack.remove(backtrack.size() - 1);\n\n        return null;\n    }\n\n    public void run() {\n        long start = System.currentTimeMillis();\n\n        try {\n            solve();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            out.close();\n        }\n\n        if (!isOj)\n            System.out.println(System.currentTimeMillis() - start + \"ms\");\n    }\n\n    public static void main(String[] args) throws Exception {\n        new C915D().run();\n    }\n\n    InputStream inputStream;\n    FastWriter out;\n\n    private C915D() {\n        this(System.in, System.out);\n    }\n\n    public C915D(InputStream inputStream, OutputStream outputStream) {\n        this.inputStream = inputStream;\n        this.out = new FastWriter(outputStream);\n    }\n\n    //@formatter:off\n    private final byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = inputStream.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n        return b;\n    }\n\n    private char c() { return (char) skip(); }\n    private char[] ca(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    private char[][] caa(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ca(m);\n        return map;\n    }\n\n    private int i() { return (int) l(); }\n    private int[] ia(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = i();\n        return a;\n    }\n    private int[][] iaa(int n, int m) {\n        int[][] map = new int[n][];\n        for (int i = 0; i < n; i++) map[i] = ia(m);\n        return map;\n    }\n    private int[][] iaaT(int n, int m) {\n        int[][] map = new int[m][];\n        for (int i = 0; i < m; i++) map[i] = new int[n];\n        for (int i = 0; i < n; i++) {\n            int[] t = ia(m);\n            for (int j = 0; j < m; j++) map[j][i] = t[j];\n        }\n        return map;\n    }\n\n    private long l() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    private long[] la(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = l();\n        return a;\n    }\n\n    private double d() { return Double.parseDouble(s()); }\n\n    private String s() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    //@formatter:on\n\n    public static class FastWriter {\n        private static final int BUF_SIZE = 1 << 13;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private final OutputStream out;\n        private int ptr = 0;\n        private boolean isFirst = true;\n\n        public FastWriter(OutputStream os) {\n            this.out = os;\n        }\n\n        private FastWriter write(byte b) {\n            buf[ptr++] = b;\n            if (ptr == BUF_SIZE)\n                innerflush();\n            return this;\n        }\n\n        private FastWriter write(char c) {\n            return write((byte) c);\n        }\n\n        private FastWriter write(char[] s) {\n            for (char c : s) {\n                buf[ptr++] = (byte) c;\n                if (ptr == BUF_SIZE) innerflush();\n            }\n            return this;\n        }\n\n        private FastWriter write(String s) {\n            s.chars().forEach(c -> {\n                buf[ptr++] = (byte) c;\n                if (ptr == BUF_SIZE) innerflush();\n            });\n            return this;\n        }\n\n        public static int countDigits(int l) {\n            if (l >= 1000000000) return 10;\n            if (l >= 100000000) return 9;\n            if (l >= 10000000) return 8;\n            if (l >= 1000000) return 7;\n            if (l >= 100000) return 6;\n            if (l >= 10000) return 5;\n            if (l >= 1000) return 4;\n            if (l >= 100) return 3;\n            if (l >= 10) return 2;\n            return 1;\n        }\n\n        private FastWriter write(int x) {\n            if (x == Integer.MIN_VALUE) {\n                return write((long) x);\n            }\n            if (ptr + 12 >= BUF_SIZE) innerflush();\n            if (x < 0) {\n                write((byte) '-');\n                x = -x;\n            }\n            int d = countDigits(x);\n            for (int i = ptr + d - 1; i >= ptr; i--) {\n                buf[i] = (byte) ('0' + x % 10);\n                x /= 10;\n            }\n            ptr += d;\n            return this;\n        }\n\n        public static int countDigits(long l) {\n            if (l >= 1000000000000000000L) return 19;\n            if (l >= 100000000000000000L) return 18;\n            if (l >= 10000000000000000L) return 17;\n            if (l >= 1000000000000000L) return 16;\n            if (l >= 100000000000000L) return 15;\n            if (l >= 10000000000000L) return 14;\n            if (l >= 1000000000000L) return 13;\n            if (l >= 100000000000L) return 12;\n            if (l >= 10000000000L) return 11;\n            if (l >= 1000000000L) return 10;\n            if (l >= 100000000L) return 9;\n            if (l >= 10000000L) return 8;\n            if (l >= 1000000L) return 7;\n            if (l >= 100000L) return 6;\n            if (l >= 10000L) return 5;\n            if (l >= 1000L) return 4;\n            if (l >= 100L) return 3;\n            if (l >= 10L) return 2;\n            return 1;\n        }\n\n        private FastWriter write(long x) {\n            if (x == Long.MIN_VALUE) {\n                return write(\"\" + x);\n            }\n            if (ptr + 21 >= BUF_SIZE) innerflush();\n            if (x < 0) {\n                write((byte) '-');\n                x = -x;\n            }\n            int d = countDigits(x);\n            for (int i = ptr + d - 1; i >= ptr; i--) {\n                buf[i] = (byte) ('0' + x % 10);\n                x /= 10;\n            }\n            ptr += d;\n            return this;\n        }\n\n        private FastWriter write(double x, int precision) {\n            if (x < 0) {\n                write('-');\n                x = -x;\n            }\n            x += Math.pow(10, -precision) / 2;\n            //\t\tif(x < 0){ x = 0; }\n            write((long) x).write(\".\");\n            x -= (long) x;\n            for (int i = 0; i < precision; i++) {\n                x *= 10;\n                write((char) ('0' + (int) x));\n                x -= (int) x;\n            }\n            return this;\n        }\n\n        public FastWriter writeDelimeter() {\n            if (isFirst) {\n                isFirst = false;\n            } else {\n                write(' ');\n            }\n            return this;\n        }\n\n        public FastWriter writeNewline() {\n            write('\\n');\n            isFirst = true;\n            return this;\n        }\n\n        private void innerflush() {\n            try {\n                out.write(buf, 0, ptr);\n                ptr = 0;\n            } catch (IOException e) {\n                throw new RuntimeException(\"innerflush\");\n            }\n        }\n\n        public void flush() {\n            innerflush();\n            try {\n                out.flush();\n            } catch (IOException e) {\n                throw new RuntimeException(\"flush\");\n            }\n        }\n\n        public void close() {\n            writeNewline();\n            flush();\n        }\n    }\n\n    //@formatter:off\n    private void w(int x) { out.writeDelimeter().write(x); }\n    private void w(long x) { out.writeDelimeter().write(x); }\n    private void w(double x) { out.writeDelimeter().write(x, 16); }\n    private void lnw(int x) { out.writeNewline().write(x); }\n    private void lnw(long x) { out.writeNewline().write(x); }\n\n    private static int log(int a) {\n        if (a <= 0) throw new RuntimeException(\"log(a): a <= 0\");\n        return Integer.SIZE - 1 - Integer.numberOfLeadingZeros(a);\n    }\n    private static int log(long a) {\n        if(a <= 0) throw new RuntimeException(\"log(a): a <= 0\");\n        return Long.SIZE - 1 - Long.numberOfLeadingZeros(a);\n    }\n    private static int max(int a, int b) {return Math.max(a, b);}\n    private static long max(long a, long b) {return Math.max(a, b);}\n    private static int min(int a, int b) {return Math.min(a, b);}\n    private static int min(int a, int b, int c) {return min(a, min(b, c));}\n    private static int min(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    private static long min(long a, long b) {return Math.min(a, b);}\n    private static long min(long a, long b, long c) {return min(a, min(b, c));}\n    private static long min(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    private static int pow(int a, int b) {if (a == 0) return 0; int r = 1; while (b > 0) {if ((b & 1) > 0) r *= a; a *= a; b >>= 1;} return r;}\n    private static long pow(long a, int b) {if (a == 0) return 0; long r = 1; while (b > 0) {if ((b & 1) > 0) r *= a; a *= a; b >>= 1;} return r;}\n    //@formatter:on\n\n    private final boolean isOj = System.getProperty(\"ONLINE_JUDGE\") != null;\n}\n", "complexity": "quadratic", "problem": "0915_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs"}
{"src": "import java.util.Scanner;\npublic class x23A {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString input = sc.next();\n\t\t//input+=\"3\";\n\t\tint longest=0;\n\t\tif(input.length()==1){\n\t\t\tSystem.out.println(0);\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tif(input.length()==2){\n\t\t\tif(input.charAt(0)==input.charAt(1)){\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\telse{\n\t\t\tSystem.out.println(0);\n\t\t\tSystem.exit(0);}\n\t\t}\n\t\tfor(int a=0;a<input.length()-1;a++){\n\t\t\tfor(int b=a+1;b<input.length();b++){\n\t\t\t\tfor(int c=1;(c+b)<input.length()+1;c++){\n\t\t\t\t//\tSystem.out.printf(\"%s %s %d\\n\", input.substring(a,a+c), input.substring(b,b+c), input.substring(a,a+c).compareTo(input.substring(b,b+c)));\n\t\t\t\t\tif(input.substring(a,a+c).compareTo(input.substring(b,b+c))==0)\n\t\t\t\t\tif(longest<c)longest=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(longest);\n\t\t}\n\t}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\n\t\tTask task = new Task();\n\t\ttask.solve(in, out);\n\t\tout.close();\n\n\t}\n\t\n\tstatic class Rectangle {\n\t\tint x1, y1;\n\t\tint x2, y2;\n\t}\n\t\n\tstatic class Task {\n\t\t/**\n\t\t * BEFORE SUBMITTING!!!\n\t\t * MAKE SURE IT IS RIGHT!!!!!\n\t\t * LONG!!\n\t\t * Check if m,n aren't misused\n\t\t * Make sure the output format is right (YES/NO vs Yes/No, newlines vs spaces)\n\t\t * Run with n = 1 or n = 0\n\t\t * Make sure two ints aren't multiplied to get a long\n\n\t\t *\n\t\t */\n\t\tpublic void solve(InputReader in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\t\n\t\t\t//ideas: procurar linha que os divide e procurar dentro desses sub-retangulos\n\t\t\t// procurar at\u00e9 ser 1\n\t\t\t\n\t\t\t//corner cases: se procurar at\u00e9 ser 1 e n\u00e3o verificar se tem 1 do outro lado posso chegar a 1,2...not good\n\t\t\t// tenho que procurar 1,1\n\t\t\t\n\t\t\tint l = 1;\n\t\t\tint r = n;\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\t\n\t\t\t\n\t\t\twhile(r >= l) {\n\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\tif(ask(in,out,1,1,mid, n) == 0) {\n\t\t\t\t\tl = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tans = mid;\n\t\t\t\t\tr = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//par 1,1\n\t\t\t//FDS ISTO\n\t\t\tif(ans < n && ask(in,out,ans + 1, 1,n,n) == 1) {\n\t\t\t\tRectangle r1 = find(in,out,1,1,ans,n,n);\n\t\t\t\tRectangle r2 = find(in,out,ans + 1,1,n,n,n);\n\t\t\t\tSystem.out.printf(\"! %d %d %d %d %d %d %d %d\\n\", r1.x1, r1.y1, r1.x2, r1.y2, r2.x1, r2.y1, r2.x2, r2.y2);\n\t\t\t} else {\n\t\t\t\tl = 1;\n\t\t\t\tr = n;\n\t\t\t\t\n\t\t\t\tans = 0;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\twhile(r >= l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tif(ask(in,out,1,1,n, mid) == 0) {\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tans = mid;\n\t\t\t\t\t\tr = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tRectangle r1 = find(in,out,1,1,n,ans,n);\n\t\t\t\tRectangle r2 = find(in,out,1,ans + 1,n,n,n);\n\t\t\t\tSystem.out.printf(\"! %d %d %d %d %d %d %d %d\\n\", r1.x1, r1.y1, r1.x2, r1.y2, r2.x1, r2.y1, r2.x2, r2.y2);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t//HASDFDSJGHDFJKSGDFJSGJDFSGJDSFGJF\n\t\t//FKING WORK\n\t\tpublic Rectangle find(InputReader in, PrintWriter out,int x1, int y1, int x2, int y2, int n) {\n\t\t\tRectangle rec = new Rectangle();\n\t\t\t\n\t\t\tint ansx1 = x1;\n\t\t\tint ansx2 = x2;\n\t\t\tint ansy1 = y1;\n\t\t\tint ansy2 = y2;\n\n\t\t\tint l = x1;\n\t\t\tint r = x2;\n\t\t\t\n\n\t\t\t// quero o minimo v >= x2 \n\t\t\twhile(r >= l) {\n\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\n\t\t\t\tif(ask(in,out,x1,y1,mid,y2) == 1) {\n\t\t\t\t\tansx2 = mid;\n\t\t\t\t\tr = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t//out.printf(\"x2 = %d\", ansx2);\n\t\t\t\n\t\t\t\n\n\t\t\tr = x2;\n\t\t\tl = x1;\n\t\t\t\n\t\t\t// quero o maximo v <= x1\n\t\t\t\n\t\t\twhile(r >= l) {\n\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\n\t\t\t\tif(ask(in,out,mid,y1,x2,y2) == 1) {\n\t\t\t\t\tansx1 = mid;\n\t\t\t\t\tl = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tr = mid - 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t//out.printf(\"x1 = %d\", ansx1);\n\t\t\t\n\t\t\t\n\t\t\tl = y1;\n\t\t\tr = y2;\n\t\t\t\n\t\t\t// quero o minimo v >= y2 \n\t\t\twhile(r >= l) {\n\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\n\t\t\t\tif(ask(in,out,x1,y1,x2,mid) == 1) {\n\t\t\t\t\tansy2 = mid;\n\t\t\t\t\tr = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t//out.printf(\"y2 = %d\", ansy2);\n\t\t\t\n\n\t\t\t\n\t\t\t\n\n\t\t\tr = y2;\n\t\t\tl = y1;\n\t\t\t\n\n\t\t\t// quero o maximo v <= y1\n\t\t\t\n\t\t\twhile(r >= l) {\n\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\n\t\t\t\tif(ask(in,out,x1,mid,x2,y2) == 1) {\n\t\t\t\t\tansy1 = mid;\n\t\t\t\t\tl = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tr = mid - 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t//out.printf(\"y1 = %d\", ansy1);\n\t\t\t\n\n\n\t\t\t\n\t\t\trec.x1 = ansx1;\n\t\t\trec.x2 = ansx2;\n\t\t\trec.y1 = ansy1;\n\t\t\trec.y2 = ansy2;\n\n\t\t\t\n\t\t\t\n\t\t\treturn rec;\n\t\t}\n\t\t\n\t\tpublic int ask(InputReader in, PrintWriter out, int x1, int y1, int x2, int y2) {\n\t\t\tSystem.out.printf(\"? %d %d %d %d\\n\",x1,y1,x2,y2);\n\t\t\tSystem.out.flush();\n\t\t\treturn in.nextInt();\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n               \n            } catch (IOException e) {\n            }\n            return null;\n        }\n\n\n\t}\n}\n\n     \t\t   \t \t \t\t\t  \t  \t\t\t   \t\t\t", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt(), k = in.nextInt();\n        int x[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            int p = in.nextInt(), t = in.nextInt();\n            x[i] = (50 - p) * 100 + t;\n        }\n        Arrays.sort(x);\n        int cnt = 0;\n        for (int q: x)\n            if (q == x[k - 1]) cnt++;\n        System.out.println(cnt);\n    }\n\n}\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner input = new Scanner();\n        StringBuilder output = new StringBuilder();\n\n        int n = input.nextInt();\n        int[] a = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            a[i] = input.nextInt();\n        }\n\n        Arrays.sort(a);\n        boolean[] colored = new boolean[n];\n        int colors = 0;\n        for (int i = 0; i < n; i++) {\n            if (!colored[i]) {\n                colors ++;\n                colored[i] = true;\n                for (int j = i+1; j < n; j++) {\n                    if (a[j] % a[i] == 0) {\n                        colored[j] = true;\n                    }\n                }\n            }\n        }\n\n        System.out.println(colors);\n    }\n\n    private static class Scanner {\n        BufferedReader br; StringTokenizer st;\n        public Scanner(Reader in) { br = new BufferedReader(in); }\n        public Scanner() { this(new InputStreamReader(System.in)); }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try { st = new StringTokenizer(br.readLine());\n                } catch (IOException e) { e.printStackTrace(); } }\n            return st.nextToken(); }\n        int nextInt() { return Integer.parseInt(next()); }\n        long nextLong() { return Long.parseLong(next()); }\n        double nextDouble() { return Double.parseDouble(next()); }\n        String readNextLine() {\n            String str = \"\";\n            try { str = br.readLine();\n            } catch (IOException e) { e.printStackTrace(); }\n            return str; }\n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) { a[idx] = nextInt(); }\n            return a; }\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int idx = 0; idx < n; idx++) { a[idx] = nextLong(); }\n            return a; }\n    } // end Scanner\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Liavontsi Brechka\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static\n    @SuppressWarnings(\"Duplicates\")\n    class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = in.nextIntArray(n);\n            int m = in.nextInt();\n\n            int count = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (a[i] > a[j]) count = (count + 1) % 2;\n                }\n            }\n\n            StringBuilder res = new StringBuilder();\n\n            int l, r, temp;\n            while (m-- > 0) {\n                l = in.nextInt() - 1;\n                r = in.nextInt() - 1;\n\n                for (int i = 0; i < (r - l + 1) / 2; i++) {\n                    temp = a[l + i];\n                    a[l + i] = a[r - i];\n                    a[r - i] = temp;\n                }\n\n                count = count ^ (((r - l + 1) * (r - l) / 2) % 2);\n                res.append(count == 1 ? \"odd\" : \"even\").append('\\n');\n            }\n\n            out.print(res);\n        }\n\n    }\n\n    static class InputReader {\n        private final BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int[] nextIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; ++i) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String readLine() {\n            String line;\n            try {\n                line = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return line;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class CF {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=null;\n        private void  solution() throws IOException{\n   int n=nextInt();\n   if((n % 4==0 && n>=4)||(n % 7==0 && n>=7) || (n % 44==0 && n>=44) || (n % 47==0 && n>=47) || (n % 77==0 && n>=77) || (n % 74==0 && n>=74)\n   || (n % 444==0 && n>=444) || (n % 447==0 && n>=447) || (n % 474==0 && n>=74) || (n % 477==0 && n>=477) || (n % 744==0 && n>=744)\n   || (n % 747==0 && n>=747) || (n % 777==0 && n>=777)){\n           System.out.println(\"YES\");\n   }else{\n                System.out.println(\"NO\");}\n        }\n        String nextToken()throws IOException {\n                if(st==null || !st.hasMoreTokens()){\n                        st = new StringTokenizer(bf.readLine());\n                }\n                return st.nextToken();\n        }\n        int nextInt() throws IOException {\n                return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() throws IOException {\n                return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() throws IOException {\n                return Double.parseDouble(nextToken());\n        }\n\n        public static void main(String args[]) throws IOException {\n                new CF().solution();\n        }\n}", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class f {\n\n    static int n;\n    static long a1, a2, a3, a4, oo = 1000000000000000L;\n    static long[][] memo;\n    static char[][] arr;\n\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        n = in.nextInt();\n        a1 = in.nextLong();\n        a2 = in.nextLong();\n        a3 = in.nextLong();\n        a4 = in.nextLong();\n        \n        memo = new long[625][n];\n        for (long[] a : memo) Arrays.fill(a, -1);\n        \n        arr = new char[4][n];\n        for (int i = 0; i < 4; i++) {\n            arr[i] = in.next().toCharArray();\n        }\n        long ans = go(0, 0, 0, 0, 0);\n        \n        out.println(ans);\n        \n        \n        out.close();\n    }\n\n    static long go(int h0, int h1, int h2, int h3, int r) {\n        if (r == n) return 0;\n        int key = h0 * 125 + h1 * 25 + h2 * 5 + h3;\n        if (memo[key][r] != -1) return memo[key][r];\n        long min = oo;\n        \n        for (int g0 = 0; g0 <= 4; g0++) {\n            int nh0 = Math.max(h0, g0);\n            long c0 = getCost(g0);\n            if (nh0 == 0 && arr[0][r] == '*') continue;\n            for (int g1 = 0; g1 <= 3; g1++) {\n                int nh1 = Math.max(h1, g1);\n                if (g0 > 1)\n                    nh1 = Math.max(nh1, g0);\n                long c1 = getCost(g1);\n                if (nh1 == 0 && arr[1][r] == '*') continue;\n                for (int g2 = 0; g2 <= 2; g2++) {\n                    int nh2 = Math.max(h2, g2);\n                    if (g1 > 1)\n                        nh2 = Math.max(nh2, g1);\n                    if (g0 > 2)\n                        nh2 = Math.max(nh2, g0);\n                    long c2 = getCost(g2);\n                    if (nh2 == 0 && arr[2][r] == '*') continue;\n                    for (int g3 = 0; g3 <= 1; g3++) {\n                        int nh3 = Math.max(h3, g3);\n                        if (g2 > 1)\n                            nh3 = Math.max(nh3, g2);\n                        if (g1 > 2)\n                            nh3 = Math.max(nh3, g1);\n                        if (g0 > 3)\n                            nh3 = Math.max(nh3, g0);\n                        long c3 = getCost(g3);\n                        if (nh3 == 0 && arr[3][r] == '*') continue;\n                        \n                        long cost = c0 + c1 + c2 + c3;\n                        cost += go(Math.max(0, nh0 - 1),\n                                   Math.max(0, nh1 - 1),\n                                   Math.max(0, nh2 - 1),\n                                   Math.max(0, nh3 - 1),\n                                   r + 1);\n                        min = Math.min(min, cost);\n                    }\n                }\n            }\n        }\n        \n        return memo[key][r] = min;\n    }\n    \n    \n    static long getCost(int a) {\n        if (a == 0) return 0;\n        if (a == 1) return a1;\n        if (a == 2) return a2;\n        if (a == 3) return a3;\n        return a4;\n    }\n\n    static Random rand = new Random();\n    static void sort(int[] a) {\n        int n = a.length;\n        for (int i = a.length - 1; i > 0; i--) {\n            int j = rand.nextInt(i + 1);\n            int tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n        Arrays.sort(a);\n    }\n    static void sort(long[] a) {\n        int n = a.length;\n        for (int i = a.length - 1; i > 0; i--) {\n            int j = rand.nextInt(i + 1);\n            long tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n        Arrays.sort(a);\n    }\n    static void sort(double[] a) {\n        int n = a.length;\n        for (int i = a.length - 1; i > 0; i--) {\n            int j = rand.nextInt(i + 1);\n            double tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n        Arrays.sort(a);\n    }\n    static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }\n    static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    static long[] eEuclid(long a, long b) {\n        if (b == 0) return new long[] { a, 1, 0 };\n        long[] ans = eEuclid(b, a % b);\n        long temp = ans[1] - ans[2] * (a / b);\n        ans[1] = ans[2];  ans[2] = temp;\n        return ans;\n    }\n    static long modInverse(long a, long m) {\n        return ((eEuclid(a, m)[1] % m) + m) % m;\n    }\n    static class IntList {\n        static int[] EMPTY = {};\n        int[] a = EMPTY;\n        int n = 0;\n        void add(int v) {\n            if (n >= a.length)\n                a = Arrays.copyOf(a, (n << 2) + 8);\n            a[n++] = v;\n        }\n        int get(int idx) {\n            return a[idx];\n        }\n        int size() {\n            return n;\n        }\n    }\n    static class DisjointSet {\n        int[] s, r;\t\n\tpublic DisjointSet(int n) {\n            s = new int[n]; r = new int[n];\n            for (int i = 0; i < n; i++) s[i] = i;\n        }\t\n        public int find(int i) { return s[i] == i ? i : (s[i] = find(s[i])); }\n\tpublic void union(int a, int b) {\n            if(r[a = find(a)] == r[b = find(b)]) r[a]++;\n            if(r[a] >= r[b]) s[b] = a; else s[a] = b;\n        }\n    }\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastScanner(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n        public String next() throws IOException {\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n        public int[] nextOffsetIntArray(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextInt() - 1;\n            return arr;\n        }\n        public int[] nextIntArray(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n        public int[][] nextIntArray(int n, int m) throws IOException {\n            int[][] arr = new int[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    arr[i][j] = nextInt();\n            return arr;\n        }\n        public long[] nextLongArray(int n) throws IOException {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextLong();\n            return arr;\n        }\n        public long[][] nextLongArray(int n, int m) throws IOException {\n            long[][] arr = new long[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    arr[i][j] = nextLong();\n            return arr;\n        }\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] arr = new double[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextDouble();\n            return arr;\n        }\n        public double[][] nextDoubleArray(int n, int m) throws IOException {\n            double[][] arr = new double[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    arr[i][j] = nextDouble();\n            return arr;\n        }\n        public char[][] nextCharArray(int n, int m) throws IOException {\n            char[][] arr = new char[n][];\n            for (int i = 0; i < n; i++)\n                arr[i] = next().toCharArray();\n            return arr;\n        }\n    }\n}\n", "complexity": "linear", "problem": "0903_F", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class NewYearCurling908C {\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner();\n        int n = in.nextInt();\n        \n        double r = (double) in.nextInt();\n        double[] answers = new double[n];\n        double[] xCoords = new double[n];\n        for (int i = 0; i < n; i++) xCoords[i] = (double) in.nextInt();\n        \n        answers[0] = r;\n        for (int i = 1; i < n; i++) {\n            double bound = r;\n            for (int j = 0; j < i; j++) {\n                double xDif = xCoords[i] - xCoords[j];\n                double y = answers[j];\n                double yNew = y + Math.sqrt(4 * r * r - xDif * xDif);\n                if (yNew > bound) bound = yNew;\n            }\n            answers[i] = bound;\n        }\n        for (int i = 0; i < n; i++) System.out.print(answers[i] + \" \");\n        System.out.println();\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author walker\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        long n = in.readInt();\n        if(n < 3){\n            out.print(n);\n        }\n        else if(n % 2 != 0) {\n            out.print(n * (n-1) * (n-2));\n        }\n        else if(n % 3 == 0) {\n            out.print((n-1) * (n-2) * (n-3));\n        }\n        else {\n            out.print(n * (n-1) * (n-3));\n        }\n    }\n}\n\nclass InputReader {\n\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn isWhitespace(c);\n\t}\n\n\tpublic static boolean isWhitespace(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Watermelon {\n    static int[][] ans;static int n,m;static boolean[][] vis;\n    public static void main(String[] args) throws IOException {\n        Scanner sc=new Scanner(new File(\"input.txt\"));\n//        Scanner sc=new Scanner(System.in);\n        PrintWriter pw=new PrintWriter(\"output.txt\");\n        int n=sc.nextInt(),m=sc.nextInt(),k=sc.nextInt();\n        Queue<Integer> pq=new ArrayDeque<>();\n        boolean[] vis=new boolean[n*m];\n        for(int i=0;i<k;i++){\n            int r=sc.nextInt()-1,c=sc.nextInt()-1;\n            pq.add(m*r+c);\n            vis[m*r+c]=true;\n        }\n        sc.close();\n        int ans=0;\n        while(pq.size()!=0){\n            int x=pq.remove();\n\n            ans=x;\n            if(n!=1 && x%n==0){\n                if(x+m<n*m&&!vis[x+m]){\n                    pq.add(x+m);\n                    vis[x+m]=true;\n                }\n                if(x-m>=0&&!vis[x-m]){\n                    pq.add(x-m);\n                    vis[x-m]=true;\n                }\n                if(x+1<n*m&&!vis[x+1]){\n                    pq.add(x+1);\n                    vis[x+1]=true;\n                }\n            }\n            else if(n!=1 && (x+1)%n==0){\n                if(x+m<n*m&&!vis[x+m]){\n                    pq.add(x+m);\n                    vis[x+m]=true;\n                }\n                if(x-m>=0&&!vis[x-m]){\n                    pq.add(x-m);\n                    vis[x-m]=true;\n                }\n                if(x-1>=0&&!vis[x-1]){\n                    pq.add(x-1);\n                    vis[x-1]=true;\n                }\n            }\n            else{\n                if(x+m<n*m&&!vis[x+m]){\n                    pq.add(x+m);\n                    vis[x+m]=true;\n                }\n                if(x-m>=0&&!vis[x-m]){\n                    pq.add(x-m);\n                    vis[x-m]=true;\n                }\n                if(x-1>=0&&!vis[x-1]){\n                    pq.add(x-1);\n                    vis[x-1]=true;\n                }\n                if(x+1<n*m&&!vis[x+1]){\n                    pq.add(x+1);\n                    vis[x+1]=true;\n                }\n            }\n        }\n        pw.println((ans/m+1)+\" \"+(ans%m+1));\n        pw.close();\n    }\n\n    static class Reader{\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\nimport static java.lang.Math.*;\n\npublic class a111 {\n    public static void debug(Object... obs) {\n        System.out.println(Arrays.deepToString(obs));\n    }\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        \n        int n=sc.nextInt();\n        int[]a=new int[n];\n        \n        int su=0;\n        for(int i=0;i<n;i++)\n        {\n            a[i]=-sc.nextInt();\n            su+=-1*a[i];\n        }\n        Arrays.sort(a);\n        \n        \n        int ss=0;\n        for(int i=0;i<n;i++)\n        {\n            ss+=-1*a[i];\n            su-=-1*a[i];\n            if(ss > su)\n            {\n                System.out.println(i+1);\n                return;\n            }\n        }\n        \n    }\n}\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.util.Random;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.io.InputStreamReader;\nimport java.io.File;\n\npublic class Task{\n\t\n\tstatic final boolean readFromFile = false;\n\tstatic final String fileInputName = \"input.txt\",\n\t\t\t\t\t\tfileOutputName = \"output.txt\";\n\t\n\tpublic static void main(String args[]){\n\t\tFileInputStream fileInputStream;\n\t\tFileOutputStream fileOutputStream;\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tif (readFromFile){\n\t\t\ttry{\n\t\t\t\tfileInputStream = new FileInputStream(new File(fileInputName));\n\t\t\t\tfileOutputStream = new FileOutputStream(new File(fileOutputName));\n\t\t\t}catch (FileNotFoundException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tPrintWriter out = new PrintWriter((readFromFile)?fileOutputStream:outputStream);\n\t\tInputReader in  = new InputReader((readFromFile)?fileInputStream:inputStream);\n\t\t\n\t\tSolver s = new Solver(in, out);\n\t\ts.solve();\n\t\t\n\t\tout.close();\n\t}\n}\n\nclass Solver{\n\tprivate PrintWriter out;\n\tprivate InputReader in;\n\t\n\tpublic void solve(){\n\t\tint n = in.nextInt();\n\t\tdouble t = in.nextDouble(),\n\t\t\ta[] = new double[n],\n\t\t\tx[] = new double[n];\n\t\tfor (int i=0;i<n;i++){\n\t\t\tx[i] = in.nextDouble();\n\t\t\ta[i] = in.nextDouble();\n\t\t}\n\t\tint ans = 2;\n\t\tfor (int i=0;i<n-1;i++)\n\t\t\tfor (int j=i+1;j<n;j++)\n\t\t\t\tif (x[j]<x[i]){\n\t\t\t\t\tdouble buf = x[i];x[i]=x[j];x[j]=buf;\n\t\t\t\t\tbuf = a[i]; a[i]=a[j];a[j]=buf;\n\t\t\t\t}\n\t\t\n\t\tfor (int i=0;i<n-1;i++){\n\t\t\tif (x[i]+a[i]/2+t<x[i+1]-a[i+1]/2)\n\t\t\t\tans += 2;\n\t\t\tif (x[i]+a[i]/2+t==x[i+1]-a[i+1]/2)\n\t\t\t\tans++;\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tSolver(InputReader in, PrintWriter out){\n\t\tthis.in = in;\n\t\tthis.out = out;\n\t}\n}\n\nclass InputReader{\n\tStringTokenizer tok;\n\tBufferedReader buf;\n\t\n\tInputReader(InputStream in){\n\t\ttok = null;\n\t\tbuf = new BufferedReader(new InputStreamReader(in));\n\t}\n\n\tInputReader(FileInputStream in){\n\t\ttok = null;\n\t\tbuf = new BufferedReader(new InputStreamReader(in));\n\t}\n\t\n\tpublic String next(){\n\t\twhile (tok==null || !tok.hasMoreTokens()){\n\t\t\ttry{\n\t\t\t\ttok = new StringTokenizer(buf.readLine());\n\t\t\t}catch (IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\t\n\tpublic int nextInt(){\n\t\treturn Integer.parseInt(next());\n\t}\n\tpublic long nextLong(){\n\t\treturn Long.parseLong(next());\n\t}\n\tpublic double nextDouble(){\n\t\treturn Double.parseDouble(next());\n\t}\n\tpublic float nextFloat(){\n\t\treturn Float.parseFloat(next());\n\t}\n\tpublic String nextLine(){\n\t\ttry{\n\t\t\treturn buf.readLine();\n\t\t}catch (IOException e){\n\t\t\treturn null;\n\t\t}\n\t}\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import javax.print.DocFlavor;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class p1523C {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        for (int i = 0; i < t ; i++) {\n            int n = sc.nextInt();\n            ArrayList<Stack<Integer>> ar = new ArrayList<Stack<Integer>>();\n            for (int j = 0; j < n + 1; j++) {\n                ar.add(new Stack<Integer>());\n            }\n            HashMap <Integer , Integer> hm = new HashMap<Integer, Integer>();\n            StringBuilder cur = new StringBuilder();\n            int l = 0;\n            for (int j = 0; j < n; j++) {\n                int a = sc.nextInt();\n                if( a == 1)\n                {\n                    if(cur.length() == 0)\n                        cur.append(\"1\");\n                    else\n                        cur.append(\".1\");\n                    l++;\n                    ar.get(1).add(l);\n                    hm.put(l , 1);\n                }\n                else\n                {\n                    int newl = ar.get( a - 1).pop();\n                    for (int k = newl + 1; k <= l ; k++) {\n                        ar.get(hm.get(k)).pop();\n                        hm.remove(k);\n                        cur.delete(cur.lastIndexOf(\".\")  + 1, cur.length());\n                        cur.delete(cur.length() - 1 , cur.length());\n                    }\n                    cur.delete(cur.lastIndexOf(\".\")  + 1, cur.length());\n                    cur.append(a);\n                    ar.get(a).add(newl);\n                    hm.put(newl , a);\n                    l = newl;\n                }\n                System.out.println(cur);\n            }\n\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n\n\tprivate StringTokenizer st;\n\tprivate BufferedReader in;\n\tprivate PrintWriter out;\n\n\tpublic void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tint[] b = a.clone();\n\t\tArrays.sort(b);\n\t\tint diff = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tdiff++;\n\t\t\t}\n\t\t}\n\t\tout.println(diff <= 2 ? \"YES\" : \"NO\");\n\t}\n\n\tpublic void run() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\teat(\"\");\n\t\t\n\t\tsolve();\n\t\t\n\t\tout.close();\n\t}\n\t\n\tvoid eat(String s) {\n\t\tst = new StringTokenizer(s);\n\t}\n\t\n\tString next() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\teat(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\t\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\t\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tLocale.setDefault(Locale.US);\n\t\tnew Solution().run();\n\t}\n\t\n}", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import static java.util.Arrays.*;\nimport static java.lang.Math.*;\nimport static java.math.BigInteger.*;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class A implements Runnable\n{\n    String file = \"input\";\n    \n    void init() throws IOException\n    {\n        //input = new BufferedReader(new FileReader(file + \".in\"));\n        input = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n    }\n    \n    void solve() throws IOException\n    {\n        String s = next();\n        int res = 0;\n        int L = s.length();\n        for(int i = 0; i < L; i++)\n            for(int j = i + 1; j <= L; j++)\n            {\n                String ss = s.substring(i, j);\n                int k = s.indexOf(ss);\n                //print(ss, k);\n                if(k >= 0)\n                {\n                    if(s.substring(k + 1).indexOf(ss) >= 0) res = max(res, j - i);\n                }\n            }\n        System.out.println(res);\n    }\n    \n    String next() throws IOException\n    {\n        if(st == null || !st.hasMoreTokens()) st = new StringTokenizer(input.readLine());\n        return st.nextToken();\n    }\n    \n    int nextInt() throws IOException\n    {\n        return Integer.parseInt(next());\n    }\n    \n    long nextLong() throws IOException\n    {\n        return Long.parseLong(next());\n    }\n    \n    double nextDouble() throws IOException\n    {\n        return Double.parseDouble(next());\n    }\n    \n    void print(Object... o)\n    {\n        System.out.println(deepToString(o));\n    }\n    \n    void gcj(Object o)\n    {\n        String s = String.valueOf(o);\n        out.println(\"Case #\" + test + \": \" + s);\n        System.out.println(\"Case #\" + test + \": \" + s);\n    }\n    \n    BufferedReader input;\n    PrintWriter out;\n    StringTokenizer st;\n    int test;\n    \n    public static void main(String[] args) throws IOException\n    {\n        new Thread(null, new A(), \"\", 1 << 20).start();\n    }\n    \n    public void run()\n    {\n        try\n        {\n            init();\n            solve();\n            out.close();        \n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class Main {\n\n    //http://www.codeforces.com/contest/275/problem/C\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine(), \" \");\n\n        int num = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n\n        st = new StringTokenizer(br.readLine(), \" \");\n\n        if (k == 1) System.out.println(num); \n        else {\n            Set<Integer> set = new TreeSet<Integer>();\n            Set<Integer> bad = new TreeSet<Integer>();\n            int sel;\n            \n            int[] arr = new int[num];\n            for (int i = 0; i < num; i++) {\n                arr[i] = Integer.parseInt((st.nextToken()));\n            }\n\n            shuffle(arr);\n            Arrays.sort(arr);\n\n            for (int i = 0; i < num; i++) {\n                sel = arr[i];\n                if (sel % k != 0) {\n                    set.add(sel);\n                    bad.add(sel * k);\n                }\n                if (!bad.contains(sel) && !set.contains(sel / k)) {\n                    bad.add(sel * k);\n                    set.add(sel);\n                }\n            }\n\n            System.out.println(set.size()); \n        }\n    }\n\n    public static void shuffle(int[] arr) {\n        Random rand = new Random();\n        for (int i = arr.length - 1; i >= 0; --i) {\n            int pos = rand.nextInt(i + 1);\n            int aux = arr[i];\n            arr[i] = arr[pos];\n            arr[pos] = aux;\n        }\n    }\n}", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st;\n\t\n\t\t\n\tvoid solve() throws IOException {\n\t\tint n=ni();\n\t\tint k=ni();\n\t\tboolean[] t = new boolean[n+1];\n\t\tfor(int i=2;i<=n;i++){\n\t\tt[i]=false;\n\t\t}\n\t\tint p=2;\n\t\t\n\t\twhile(true){\n\t\t\tint pointer=2;\n\t\twhile(pointer*p<=n){\n\t\t\tt[pointer*p]=true;\n\t\t\tpointer++;\n\t\t}\n\n\t\tboolean flag=false;\n\t\tfor(int i=p+1;i<=n;i++){\n\t\t\tif(!t[i]){p=i;flag=true;break;}\n\t\t}\n\t\tif(!flag)break;\n\t\t}\n\t\tList<Integer> lst=new ArrayList<Integer>();\n\n\t\tint countN=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(!t[i]){lst.add(i);countN++; }\n\t\t}\n\t\tint count=0;\n\t\t\n\t\tString resulPO=\"NO\";\n\t\tfor(int i=2;i<countN;i++){\n\t\t\t\n\t\t\tboolean result=false;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(lst.get(j)+lst.get(j+1)+1==lst.get(i)){\n\t\t\t\t\tresult=true;\n\t\t\t\t\t//out.println(lst.get(j)+\"+\"+lst.get(j+1)+\"+\"+1+\"==\"+lst.get(i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(result)count++;\n\t\t}\n\t\tif(count>=k)resulPO=\"YES\";\n\t\telse resulPO=\"NO\";\n\t\tout.print(resulPO);\n\t\t\n\t}\n\t\n\tpublic Main() throws IOException {\n\t\tLocale.setDefault(Locale.US);\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tString ns() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint ni() throws IOException {\n\t\treturn Integer.valueOf(ns());\n\t}\n\n\tlong nl() throws IOException {\n\t\treturn Long.valueOf(ns());\n\t}\n\n\tdouble nd() throws IOException {\n\t\treturn Double.valueOf(ns());\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n}", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.util.*;\npublic class MargariteAndTheBestPresent {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\tint l = 0;\n\t\tint r = 0;\n\t\tList<Integer> z = new ArrayList<>();\n\t\tfor(int j=0;j<q;j++) {\n\t\t\tl = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tSystem.out.println(func(r) - func(l-1));\n\t\t}\t\n\t}\n\tstatic long func(long x) {\n\t\tif(x%2==0) {\n\t\t\treturn x/2;\n\t\t}\n\t\telse {\n\t\t\treturn -x+func(x-1);\n\t\t}\n\t}\n}", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int t=Integer.parseInt(bu.readLine());\n        while(t-->0)\n        {\n            int n=Integer.parseInt(bu.readLine());\n            int cur[]=new int[n],i,cr=-1;\n            for(i=0;i<n;i++)\n            {\n                int j,d=Integer.parseInt(bu.readLine()),f=-1;\n                for(j=cr;j>=0;j--)\n                if(cur[j]==d-1) {f=j; break;}\n\n                if(f==-1)\n                {\n                    cr++;\n                    f=cr;\n                }\n                cur[f]=d;\n                cr=f;\n                for(j=f+1;j<n;j++) cur[j]=0;\n                sb.append(cur[0]);\n                for(j=1;j<n;j++)\n                if(cur[j]==0) break;\n                else sb.append(\".\"+cur[j]);\n                sb.append(\"\\n\");\n            }\n        }\n        System.out.print(sb);\n    }\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.lang.*;\nimport java.math.BigInteger;\nimport java.io.*;\nimport java.util.*;\n\npublic class Solution implements Runnable{\n    public static BufferedReader br;\n    public static PrintWriter out;\n    public static StringTokenizer stk;\n    public static boolean isStream = true;\n\n    public static void main(String[] args) throws IOException {\n    \tif (isStream) {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        } else {\n            br = new BufferedReader(new FileReader(\"in.txt\"));\n        }\n        out = new PrintWriter(System.out);\n        new Thread(new Solution()).start();\n    }\n\n    public void loadLine() {\n        try {\n            stk = new StringTokenizer(br.readLine());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String nextLine() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n\n    public String nextWord() {\n        while (stk==null||!stk.hasMoreTokens()) loadLine();\n        return stk.nextToken();\n    }\n\n    public Integer nextInt() {\n        while (stk==null||!stk.hasMoreTokens()) loadLine();\n        return Integer.valueOf(stk.nextToken());\n    }\n\n    public Long nextLong() {\n        while (stk==null||!stk.hasMoreTokens()) loadLine();\n        return Long.valueOf(stk.nextToken());\n    }\n\n    public Double nextDouble() {\n        while (stk==null||!stk.hasMoreTokens()) loadLine();\n        return Double.valueOf(stk.nextToken());\n    }\n    \n    public Float nextFloat() {\n        while (stk==null||!stk.hasMoreTokens()) loadLine();\n        return Float.valueOf(stk.nextToken());\n    }\n    \n    public void run() {\n    \tint n = nextInt();\n    \tint m = nextInt();\n    \tif (n > m) {\n    \t\tint sw = n;\n    \t\tn = m;\n    \t\tm = sw;\n    \t}\n    \tint[][] A = new int[1<<n][1<<n];\n    \tfor (int m1 = 0; m1 < 1<<n; ++m1) { // Who goes out\n    \t\tfor (int m2 = 0; m2 < 1<<n; ++m2) {  // Who comes\n    \t\t\tint[] arr = new int[n]; // Who remains\n    \t\t\tfor (int i = 0; i < n; ++i) {\n    \t\t\t\tarr[i] = (~(m1>>i))&1; \n    \t\t\t}\n    \t\t\tint[] m2a = new int[n];\n    \t\t\tfor (int i = 0; i < n; ++i) {\n    \t\t\t\tm2a[i] = (m2>>i)&1; \n    \t\t\t}\n    \t\t\tint cnt = 0;\n    \t\t\tfor (int i = 0; i < n; ++i) {\n    \t\t\t\tif (arr[i] == 1) {\n    \t\t\t\t\tif (i > 0 && m2a[i-1] == 1) {\n    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t}\n    \t\t\t\t\tif (i < n-1 && m2a[i+1] == 1) {\n    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t}\n    \t\t\t\t\tif (m2a[i] == 1) {\n    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t}\n    \t\t\t\t\tif (i < n-1) {\n    \t\t\t\t\t\tm2a[i+1] = 1;\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tm2a[i] = 1;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tfor (int i = 0; i < n; ++i) {\n    \t\t\t\tif (m2a[i] == 1) {\n    \t\t\t\t\tcnt++;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tA[m1][m2] = cnt;\n    \t\t}\n    \t}\n    \tint MAX = 10000;\n    \tint[][][] dp = new int[m+1][1<<n][1<<n];\n    \tfor (int i = 0; i < m+1; i++) {\n    \t\tfor (int m1 = 0; m1 < 1<<n; ++m1) {\n    \t\t\tArrays.fill(dp[i][m1], MAX);\n    \t\t}\n    \t}\n    \t\n\t\tdp[0][0][0] = 0;\n    \t\n    \tfor (int i = 0; i < m; i++) {\n    \t\tfor (int m1 = 0; m1 < 1<<n; ++m1) {\n    \t\t\tfor (int m2 = 0; m2 < 1<<n; ++m2) {\n    \t\t\t\tif (dp[i][m1][m2] != MAX) {\n\t    \t\t\t\tfor (int nm1 = 0; nm1 < 1<<n; ++nm1) {\n\t    \t    \t\t\tfor (int nm2 = 0; nm2 < 1<<n; ++nm2) {\n\t    \t        \t\t\tif ((m1 & nm1) == 0) {\n\t    \t        \t\t\t\tint sm1 = m1|nm1;\n\t    \t        \t\t\t\tint sm2 = m2|nm2;\n\t    \t        \t\t\t\tint cnt = A[sm1][sm2];\n\t    \t        \t\t\t\tdp[i+1][nm2][nm1] = Math.min(dp[i+1][nm2][nm1], dp[i][m1][m2]+cnt);\n\t    \t        \t\t\t}\n\t    \t        \t\t}\n\t    \t    \t\t}\n    \t\t\t\t}\n        \t\t}\n    \t\t}\n    \t}\n    \t\n    \tout.println(n*m-dp[m][0][0]);\n    \tout.flush();\n    }\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.util.InputMismatchException;\n\n\n\npublic class ques3 {\n\n\tstatic class InputReader {\n\n        private InputStream stream;\n\n        private byte[] buf = new byte[1024];\n\n        private int curChar;\n\n        private int numChars;\n\n        private SpaceCharFilter filter;\n\n \n\n        public InputReader(InputStream stream) {\n\n            this.stream = stream;\n\n        }\n\n \n\n        public static boolean isWhitespace(int c) {\n\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\n        }\n\n \n\n        public int read() {\n\n            if (numChars == -1) {\n\n                throw new InputMismatchException();\n\n            }\n\n            if (curChar >= numChars) {\n\n                curChar = 0;\n\n                try {\n\n                        numChars = stream.read(buf);\n\n                } catch (IOException e) {\n\n                        throw new InputMismatchException();\n\n                }\n\n                if (numChars <= 0) {\n\n                        return -1;\n\n                }\n\n            }\n\n            return buf[curChar++];\n\n        }\n\n \n\n        public boolean isSpaceChar(int c) {\n\n            if (filter != null) {\n\n                return filter.isSpaceChar(c);\n\n            }\n\n            return isWhitespace(c);\n\n        }\n\n \n\n        public interface SpaceCharFilter {\n\n \n\n            public boolean isSpaceChar(int ch);\n\n        }\n\n \n\n        public String next() {\n\n            return nextString();\n\n        }\n\n        \n\n        public char nextChar(){\n\n        \tint c=read();\n\n        \twhile (isSpaceChar(c)) {\n\n                c = read();\n\n            }\n\n        \treturn (char)c;\n\n        }\n\n \n\n        public String nextString() {\n\n            int c = read();\n\n            while (isSpaceChar(c)) {\n\n                c = read();\n\n            }\n\n            StringBuilder res = new StringBuilder();\n\n            do {\n\n                res.appendCodePoint(c);\n\n                c = read();\n\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n\n        }\n\n \n\n        public int nextInt() {\n\n            int c = read();\n\n            while (isSpaceChar(c)) {\n\n                c = read();\n\n            }\n\n            int sgn = 1;\n\n            if (c == '-') {\n\n                sgn = -1;\n\n                c = read();\n\n            }\n\n            int res = 0;\n\n            do {\n\n                if (c < '0' || c > '9') {\n\n                    throw new InputMismatchException();\n\n                }\n\n                res *= 10;\n\n                res += c - '0';\n\n                c = read();\n\n            } while (!isSpaceChar(c));\n\n            return res * sgn;\n\n        }\n\n \n\n        public Long nextLong() {\n\n            return Long.parseLong(nextString());\n\n        }\n\n \n\n        public Double nextDouble() {\n\n            return Double.parseDouble(nextString());\n\n        }\n\n    }\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tInputReader sc=new InputReader(System.in);\n\n\t\tlong n=sc.nextLong();\n\n\t\tlong s=sc.nextLong();\n\n\t\t\n\n\t\tlong start=0,end=n;\n\n\t\twhile(start<end)\n\n\t\t{\n\n\t\t\tlong mid=(start+end)/2;\n\n\t\t\tif(func(mid)>=s)\n\n\t\t\t\tend=mid;\n\n\t\t\telse \n\n\t\t\t\tstart=mid+1;\n\n\t\t}\n\n\t\tif(func(start)>=s)\n\n\t\t\tSystem.out.println(n-start+1);\n\n\t\telse\n\n\t\t\tSystem.out.println(0);\n\n\t}\n\n\t\n\n\tpublic static long func(long n)\n\n\t{\n\n\t\tlong temp=n;\n\n\t\tint sum=0;\n\n\t\twhile(temp>0)\n\n\t\t{\n\n\t\t\tsum+=temp%10;\n\n\t\t\ttemp/=10;\n\n\t\t}\n\n\t\treturn n-sum;\n\n\t}\n\n}", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.PrintStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author coderbd\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int m, n, k;\n        n = in.readInt();\n        m = in.readInt();\n        k = in.readInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = in.readInt() - 1;\n        Arrays.sort(a);\n        int ans = -1;\n        if (k >= m)\n            ans = 0;\n        else for (int i = 0; i < n; i++) {\n            k += a[n-i-1];\n            if (k >= m) {\n                ans = i + 1;\n                break;\n            }\n        }\n        System.out.println(ans);\n    }\n}\n\nclass InputReader {\n    private boolean finished = false;\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            }\n            catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int peek() {\n        if (numChars == -1)\n            return -1;\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            }\n            catch (IOException e) {\n                return -1;\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public long readLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0L;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public static boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private String readLine0() {\n        StringBuffer buf = new StringBuffer();\n        int c = read();\n        while (c != '\\n' && c != -1) {\n            if (c != '\\r')\n                buf.appendCodePoint(c);\n            c = read();\n        }\n        return buf.toString();\n    }\n\n    public String readLine() {\n        String s = readLine0();\n        while (s.trim().length() == 0)\n            s = readLine0();\n        return s;\n    }\n\n    public String readLine(boolean ignoreEmptyLines) {\n        if (ignoreEmptyLines)\n            return readLine();\n        else\n            return readLine0();\n    }\n\n    public BigInteger readBigInteger() {\n        try {\n            return new BigInteger(readString());\n        }\n        catch (NumberFormatException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    public char readCharacter() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        return (char) c;\n    }\n\n    public double readDouble() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        double res = 0;\n        while (!isSpaceChar(c) && c != '.') {\n            if (c == 'e' || c == 'E')\n                return res * Math.pow(10, readInt());\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        }\n        if (c == '.') {\n            c = read();\n            double m = 1;\n            while (!isSpaceChar(c)) {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, readInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                m *= 10;\n                res += (c - '0') * m;\n                c = read();\n            }\n        }\n        return res * sgn;\n    }\n\n    public boolean isExhausted() {\n        int value;\n        while (isSpaceChar(value = peek()) && value != -1)\n            read();\n        return value == -1;\n    }\n\n    public String next() {\n        return readString();\n    }\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void printLine(char[] array) {\n        writer.print(array);\n    }\n\n    public void printFormat(String format, Object...objects) {\n        writer.printf(format, objects);\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n    public void flush() {\n        writer.flush();\n    }\n}\n\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tA solver = new A();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass A {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.readInt();\n        int a = in.readInt();\n        int b = in.readInt();\n        int[] hs = new int[n];\n        for (int i=0;i<n;i++){\n            hs[i]=in.readInt();\n        }\n        Arrays.sort(hs);\n        out.println(hs[b]-hs[b-1]);\n\t}\n}\n\nclass InputReader {\n    BufferedReader in;\n\n    public InputReader(InputStream stream) {\n        in = new BufferedReader(new InputStreamReader(stream));\n    }\n\n    public int skipSpace() {\n        int c;\n        try {\n            while (true) {\n                c = in.read();\n                if (c < 0) {\n                    throw new InputMismatchException();\n                }\n                if (c > 32) {\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n        return c;\n    }\n\n    public int readInt() {\n        int res = 0;\n        boolean sign = false;\n        int c = skipSpace();\n        try {\n            if (c == '-') {\n                sign = true;\n                c = in.read();\n            }\n            while (true) {\n                if (c >= '0' && c <= '9') {\n                    res = res * 10 + c - '0';\n                } else {\n                    throw new InputMismatchException();\n                }\n                c = in.read();\n                if (c <= 32) {\n                    break;\n                }\n            }\n            if (sign) {\n                res = -res;\n            }\n            return res;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    }\n\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.util.Scanner;\n\npublic class Pipeline {\n\n    public static long sumOfPipes(long n, long k) {\n\n        long left = 1;\n        long right = k;\n\n        while (left < right) {\n            long mid = (left + right) / 2;\n            long s = sum(mid, k);\n            if (s == n) {\n                return k - mid + 1;\n            } else if (s > n) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n\n        return k - left + 2;\n    }\n\n    static long sum(long left, long right) {\n        long s = 0;\n        if (left <= right) {\n            s = sum(right) - sum(left - 1);\n        }\n        return s;\n    }\n\n    static long sum(long k) {\n        return k * (k + 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong();\n        long k = in.nextLong();\n        if (n == 1) {\n            System.out.println(0);\n        } else if (k >= n) {\n            System.out.println(1);\n        } else {\n            n -= 1;\n            k -= 1;\n\n            if (sum(k) < n) {\n                System.out.println(-1);\n            } else {\n\n                System.out.println(sumOfPipes(n, k));\n\n            }\n        }\n    }\n}\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "/*==========================================================================*/\n/*\n\n    AUTHOR:    RonWonWon    \n    CREATED:   23.04.2021 21:11:49\n    EMAIL:     rachitpts.2454@gmail.com                                  \n\n*/\n/*==========================================================================*/\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n\t\n\tpublic static void main(String[] args) {\n        FastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int t = 1;//in.nextInt(), tt = 0;\n        while(t-->0) { \n        \tn = in.nextInt(); m = in.nextInt(); k = in.nextInt();\n        \t//map = new HashMap<>();\n        \tw1 = new int[n+1][m+1];\n        \tw2 = new int[n+1][m+1];\n        \tfor(int i=1;i<=n;i++){\n        \t\tint x[] = in.readArray(m-1);\n        \t\tfor(int j=1;j<m;j++) w1[i][j+1] = x[j-1];\n          }\n        \tfor(int i=1;i<n;i++){\n        \t\tint x[] = in.readArray(m);\n        \t\tfor(int j=1;j<=m;j++) w2[i+1][j] = x[j-1];\n        \t}\n        \t/*\n        \t//comment\n        \tfor(int i=0;i<=n;i++){\n        \t\tfor(int j=0;j<=m;j++) out.print(w1[i][j]+\" \");\n        \t\tout.println();\n        \t}\n        \tout.println();\n        \tfor(int i=0;i<=n;i++){\n        \t\tfor(int j=0;j<=m;j++) out.print(w2[i][j]+\" \");\n        \t\tout.println();\n        \t}*/\n        \t//comment\n        \tlong ans[][] = new long[n+1][m+1];\n        \tdp = new long[n+1][m+1][k+1];\n        \tfor(int i=0;i<=n;i++){\n        \t\tfor(int j=0;j<=m;j++) Arrays.fill(dp[i][j],-1);\n        \t}\n          for(int i=1;i<=n;i++){\n          \tfor(int j=1;j<=m;j++){\n          \t\trec(i,j,0);\n          \t\tans[i][j] = 2*dp[i][j][0];\t                                     \t\n          \t}\n          }\n          for(int i=1;i<=n;i++){\n          \tfor(int j=1;j<=m;j++){\n          \t\tif(k%2==1) ans[i][j] = -1;\n          \t\tout.print(ans[i][j]+\" \");\n          \t}\t\n          \tout.println();\n          }                                                \n        }\n        out.flush();\n\t}\n\n\tstatic long rec(int i, int j, int depth){\n\t\tif(depth==k/2) return 0;\n\t\tif(dp[i][j][depth]!=-1) return dp[i][j][depth];      \n\t\tlong mn = Long.MAX_VALUE;\n\t\tif(i+1<=n) mn = Math.min(mn,rec(i+1,j,depth+1)+w2[i+1][j]);\n\t\tif(j+1<=m) mn = Math.min(mn,rec(i,j+1,depth+1)+w1[i][j+1]);\n\t\tif(i>1) mn = Math.min(mn,rec(i-1,j,depth+1)+w2[i][j]);\n\t\tif(j>1) mn = Math.min(mn,rec(i,j-1,depth+1)+w1[i][j]);\n\t\treturn dp[i][j][depth] = mn;\t\t\n\t}\n\t\n\tstatic int n, m, k, w1[][], w2[][], sx, sy;\n\tstatic long dist, dp[][][];\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t\ttry { st = new StringTokenizer(br.readLine()); }\n\t\t\t\tcatch(IOException e) {}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString nextLine(){\n\t\t\ttry{ return br.readLine(); } \n\t\t\tcatch(IOException e) { } return \"\";\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n\n\tstatic final Random random = new Random();\n\n\tstatic void ruffleSort(int[] a){\n\t\tint n = a.length;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint j = random.nextInt(n), temp = a[j];\n\t\t\ta[j] = a[i]; a[i] = temp;\n\t\t}\n\t\tArrays.sort(a); \t\n\t}\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint x, y;\n\t\tPair(int a, int b){ x = a; y = b; }\t\t\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(o.y - this.y>0)\n\t\t\t\treturn -1;\n\t\t\telse if(o.y - this.y<0)\n\t\t\t\treturn 1;\n\t\t\telse \n\t\t\t\treturn 0;\n\t\t}\n\n\t}\n\t\n\tstatic int lcm(int a, int b) {\n\t\treturn (a*b)/gcd(a,b);\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\tif(b==0) return a;\n\t\telse return gcd(b,a%b);\n\t}\n\n\t//modulo\n\tstatic final int mod=1_000_000_007;\n\t\n\tstatic long mul(long a, long b) {\n\t\treturn a*b%mod;\n\t}\n\t\n\tstatic long fastPow(long base, long exp) {\n\t\tif (exp==0) return 1;\n\t\tlong half=fastPow(base, exp/2);\n\t\tif (exp%2==0) return mul(half, half);\n\t\treturn mul(half, mul(half, base));\n\t}\n\t\n\tstatic long modInv(long x) {\n\t\treturn fastPow(x, mod-2);\n\t}\n\t\n\tstatic long fact(int x) {\n\t\tlong ans=1;\n\t\tfor (int i=2; i<=x; i++) ans=mul(ans, i);\n\t\treturn ans;\n\t}\n\t\n\tstatic long nCk(int n, int k) {\n\t\treturn mul(fact(n), mul(modInv(fact(k)), modInv(fact(n-k))));\n\t}\n\t\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author khokharnikunj8\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            int n = in.scanInt();\n            int r = in.scanInt(), temp;\n            double max1;\n            double high[] = new double[1002];\n            for (int i = 0; i < n; i++) {\n                temp = in.scanInt();\n                max1 = high[temp] + ((high[temp] == 0) ? r : +(2 * r));\n                for (int j = temp - 1; j > temp - (2 * r) && j > 0; j--) {\n                    if (high[j] == 0) continue;\n                    max1 = Math.max(max1, high[j] + Math.sqrt((4 * r * r) - ((temp - j) * (temp - j))));\n                }\n                for (int j = temp + 1; j <= 1000 && j < temp + (2 * r); j++) {\n                    if (high[j] == 0) continue;\n                    max1 = Math.max(max1, high[j] + Math.sqrt((4d * r * r) - (((j - temp) * (j - temp)))));\n                }\n                if (temp - (2 * r) > 0) max1 = Math.max(high[temp - (2 * r)], max1);\n                if (temp + (2 * r) <= 1000) max1 = Math.max(high[temp + (2 * r)], max1);\n                high[temp] = max1;\n                out.print(max1 + \" \");\n\n            }\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int index;\n        private BufferedInputStream in;\n        private int total;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (index >= total) {\n                index = 0;\n                try {\n                    total = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (total <= 0) return -1;\n            }\n            return buf[index++];\n        }\n\n        public int scanInt() {\n            int integer = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    integer *= 10;\n                    integer += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * integer;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class ElongatedMatrix {\n\tpublic static void main(String[] args) {\n\t\tInputStream input;\n\t\tOutputStream output;\n\t\ttry {\n\t\t\tinput = new FileInputStream(\"input.txt\");\n\t\t\toutput = new FileOutputStream(\"output.txt\");\n\t\t} catch (FileNotFoundException e) {\n\t\t\tinput = System.in;\n\t\t\toutput = System.out;\n\t\t}\n\t\tKattio io = new Kattio(input, output);\n\t\t(new Solve(io)).main();\n\t\tio.close();\n\n\t\tif (input instanceof FileInputStream)\n\t\t\ttry {\n\t\t\t\tinput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\tif (output instanceof FileOutputStream)\n\t\t\ttry {\n\t\t\t\toutput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t}\n}\n\nclass Solve {\n\tstatic final int oo = (int) 1e9;\n\tKattio io;\n\tint n, m;\n\tint[][] a;\n\tint[][][] dp;\n\tint[][] diff;\n\tint[][] slant;\n\n\tSolve(Kattio io) {\n\t\tthis.io = io;\n\t}\n\n\tint getbit(int x, int n) {\n\t\tn--;\n\t\treturn (x >> n) & 1;\n\t}\n\n\tint setbit(int x, int n) {\n\t\tn--;\n\t\treturn x | (1 << n);\n\t}\n\n\tint caldp(int currentRow, int firstRow, int mask) {\n\t\tif (dp[currentRow][firstRow][mask] != -1)\n\t\t\treturn dp[currentRow][firstRow][mask];\n\t\tdp[currentRow][firstRow][mask] = 0;\n\t\tif (mask == (1 << n) - 1)\n\t\t\tdp[currentRow][firstRow][mask] = slant[currentRow][firstRow];\n\t\telse {\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tif (getbit(mask, i) == 0) {\n\t\t\t\t\tdp[currentRow][firstRow][mask] = Math.max(\n\t\t\t\t\t\t\tMath.min(caldp(i, firstRow, setbit(mask, i)), diff[currentRow][i]),\n\t\t\t\t\t\t\tdp[currentRow][firstRow][mask]);\n\n\t\t\t\t}\n\t\t}\n\t\treturn dp[currentRow][firstRow][mask];\n\n\t}\n\n\tvoid main() {\n\t\tn = io.getInt();\n\t\tm = io.getInt();\n\t\ta = new int[n+1][m+1];\n\t\tdp = new int[n+1][n+1][1<<n];\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tfor (int j=1; j<=m; j++)\n\t\t\t\ta[i][j] = io.getInt();\n\t\t\n\t\tdiff = new int[n+1][n+1];\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t{\n\t\t\t\tdiff[i][j]=oo;\n\t\t\t\tfor (int x=1; x<=m; x++)\n\t\t\t\t\tdiff[i][j]=Math.min(diff[i][j], Math.abs(a[i][x]-a[j][x]));\n\t\t\t}\n\t\t\n\t\tslant = new int[n+1][n+1];\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t{ \n\t\t\t\tslant[i][j] = oo;\n\t\t\t\tfor (int x=1; x+1<=m; x++)\n\t\t\t\t\tslant[i][j] = Math.min(slant[i][j], Math.abs(a[i][x]-a[j][x+1]));\n\t\t\t}\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tArrays.fill(dp[i][j], -1);\n\t\t\n\t\tint res = 0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tres = Math.max(res, caldp(i,i,setbit(0,i)));\n\t\t\n\t\tio.print(res);\n\t}\n}\n\nclass Kattio extends PrintWriter {\n\tpublic Kattio(InputStream i) {\n\t\tsuper(new BufferedOutputStream(System.out));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic Kattio(InputStream i, OutputStream o) {\n\t\tsuper(new BufferedOutputStream(o));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic boolean hasMoreTokens() {\n\t\treturn peekToken() != null;\n\t}\n\n\tpublic int getInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double getDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long getLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic String getWord() {\n\t\treturn nextToken();\n\t}\n\n\tprivate BufferedReader r;\n\tprivate String line;\n\tprivate StringTokenizer st;\n\tprivate String token;\n\n\tprivate String peekToken() {\n\t\tif (token == null)\n\t\t\ttry {\n\t\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t}\n\t\t\t\ttoken = st.nextToken();\n\t\t\t} catch (IOException e) {\n\t\t\t}\n\t\treturn token;\n\t}\n\n\tprivate String nextToken() {\n\t\tString ans = peekToken();\n\t\ttoken = null;\n\t\treturn ans;\n\t}\n}", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run() {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint n = in.nextInt(), k = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\ta[i] = in.nextInt();\n\t\tArrays.sort(a);\n\t\tint ret = 0, it = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint val = a[i] % k == 0 ? a[i] / k : -1;\n\t\t\twhile (it < i && a[it] < val) ++it;\n\t\t\tif (it == i || a[it] != val) {\n\t\t\t\t++ret;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[i] = 0;\n\t\t\t}\n\t\t}\n\t\tout.println(ret);\n\n\t\tout.close();\n\t}\n}\n\nclass InputReader {\n\tBufferedReader buff;\n\tStringTokenizer tokenizer;\n\n\tInputReader(InputStream stream) {\n\t\tbuff = new BufferedReader(new InputStreamReader(stream));\n\t\ttokenizer = null;\n\t}\n\tboolean hasNext() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(buff.readLine());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\treturn true;\n\t}\n\tString next() {\n\t\tif (!hasNext())\n\t\t\tthrow new RuntimeException();\n\t\treturn tokenizer.nextToken();\n\t}\n\tint nextInt() { return Integer.parseInt(next()); }\n\tlong nextLong() { return Long.parseLong(next()); }\n}\n\n", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "import java.util.*;\n public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint tr = sc.nextInt();\n\t\twhile (tr-- > 0){\n\t\t\tString s = sc.next();\n\t\t\tif (s.matches(\"R[0-9]+C[0-9]+\")){\n\t\t\t\tString[] ss = s.split(\"R|C\");\n\t\t\t\tlong x = Long.parseLong(ss[2]);\n\t\t\t\tString t = \"\";\n\t\t\t\twhile (x != 0){\n\t\t\t\t\tlong m = x % 26;\n\t\t\t\t\tif (m == 0){\n\t\t\t\t\t\tt = 'Z' + t;\n\t\t\t\t\t\tx /= 26;\n\t\t\t\t\t\tx -= 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tchar temp = (char)(m + 'A' - 1);\n\t\t\t\t\t\tt = temp + t;\n\t\t\t\t\t\tx /= 26;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tSystem.out.println(t + \"\" + ss[1]);\n\t\t\t} else {\n\t\t\t\tString x1 = s.replaceAll(\"[0-9]\", \"\");\n\t\t\t\tString x2 = s.replaceAll(\"[A-Z]\", \"\");\n\t\t\t\tlong ans = 0, base = 1;\n\t\t\t\tfor (int i = x1.length() - 1; i >= 0; i--){\n\t\t\t\t\tans += ((long)x1.charAt(i) - (long)'A' + 1) * base;\t\n\t\t\t\t\tbase *= 26;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"R\" + x2 + \"C\" + ans);\n\t\t\t}\n\t\t}\n\t}\n}\n", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\n\tprivate static final String NO = \"NO\";\n\tprivate static final String YES = \"YES\";\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tprivate static final long MOD = 1000000007;\n\tprivate static final int MAXN = 100000;\n\n\tvoid solve() {\n\t\tint T = 1;// ni();\n\t\tfor (int i = 0; i < T; i++) {\n\t\t\tsolve(i);\n\t\t}\n\t}\n\n\tvoid solve(int T) {\n\t\tint n = ni();\n\t\tint m = ni();\n\t\tint k = ni();\n\t\tint h[][] = na(n, m - 1);\n\t\tint v[][] = na(n - 1, m);\n\t\tif (k % 2 == 1) {\n\t\t\tfor (int r = 0; r < n; r++) {\n\t\t\t\tfor (int c = 0; c < m; c++)\n\t\t\t\t\tout.print(\"-1 \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tk /= 2;\n\t\tint d[][] = new int[n][m];\n\t\twhile (k-- > 0) {\n\t\t\tint cur[][] = new int[n][m];\n\t\t\tfor (int r = 0; r < n; r++)\n\t\t\t\tfor (int c = 0; c < m; c++) {\n\t\t\t\t\tcur[r][c] = Integer.MAX_VALUE;\n\t\t\t\t\t// hor <--\n\t\t\t\t\tif (c > 0) {\n\t\t\t\t\t\tcur[r][c] = d[r][c - 1] + h[r][c - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (c < m - 1) {\n\t\t\t\t\t\tcur[r][c] = Math.min(cur[r][c], d[r][c + 1] + h[r][c]);\n\t\t\t\t\t}\n\t\t\t\t\t//\n\t\t\t\t\tif (r > 0) {\n\t\t\t\t\t\tcur[r][c] = Math.min(cur[r][c], d[r - 1][c] + v[r - 1][c]);\n\t\t\t\t\t}\n\t\t\t\t\tif (r < n - 1) {\n\t\t\t\t\t\tcur[r][c] = Math.min(cur[r][c], d[r + 1][c] + v[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\td = cur;\n\t\t}\n\t\tfor (int r = 0; r < n; r++) {\n\t\t\tfor (int c = 0; c < m; c++)\n\t\t\t\tout.print(d[r][c] * 2 + \" \");\n\t\t\tout.println();\n\t\t}\n//\t\ttr(d);\n\t}\n\n\t// a^b\n\tlong power(long a, long b) {\n\t\tlong x = 1, y = a;\n\t\twhile (b > 0) {\n\t\t\tif (b % 2 != 0) {\n\t\t\t\tx = (x * y) % MOD;\n\t\t\t}\n\t\t\ty = (y * y) % MOD;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn x % MOD;\n\t}\n\n\tprivate long gcd(long a, long b) {\n\t\twhile (a != 0) {\n\t\t\tlong tmp = b % a;\n\t\t\tb = a;\n\t\t\ta = tmp;\n\t\t}\n\t\treturn b;\n\t}\n\n\tvoid run() throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!INPUT.isEmpty())\n\t\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n) {\n\t\t\tif (!(isSpaceChar(b)))\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate List<Integer> na2(int n) {\n\t\tList<Integer> a = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta.add(ni());\n\t\treturn a;\n\t}\n\n\tprivate int[][] na(int n, int m) {\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = na(m);\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long[] nl(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate long[][] nl(int n, int m) {\n\t\tlong[][] a = new long[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl(m);\n\t\treturn a;\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "\nimport java.util.*;\nimport java.io.*;\npublic class code839E\n{\n    public static void main(String[] args) throws Exception{\n        BufferedReader bff=new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter wff=new PrintWriter(System.out);\n        String[] st=bff.readLine().split(\" \");\n        int V=Integer.parseInt(st[0]);\n        int K=Integer.parseInt(st[1]);\n        BronKerbosch bk=new BronKerbosch(V);\n        for(int i=0;i<V;i++){\n            st=bff.readLine().split(\" \");\n            for(int j=0;j<V;j++){\n                if(st[j].equals(\"1\")){\n                    bk.anadir(i,j);\n                }\n            }\n        }\n        long num=bk.numeroCamarilla();\n        wff.printf(\"%.12f\\n\", num * (num - 1.0) / 2 * K / num * K / num);\n        wff.flush();\n    }\n    \n    \n    \nstatic class BronKerbosch {\n    int V;\n    long[] neig;\n    Random random = new Random();\n    long maxClique;\n\n    public BronKerbosch(int v){\n        V=v;\n        neig=new long[V];\n    }\n\n    public void anadir(int a,int b){\n        long aux=1;\n        neig[a] |= aux << (long)b;\n    }\n    \n    public long numeroCamarilla(){\n        long numero = Long.bitCount(bronKerbosch());\n        return numero;\n    }\n    \n    public long bronKerbosch() {\n        maxClique = 0;\n        bronKerbosch2(0, (1L << V) - 1, 0);\n        return maxClique;\n    }\n\n    public void bronKerbosch2(long r, long p, long x) {\n        if (Long.bitCount(maxClique) >= Long.bitCount(r | p | x)) return;\n        long px = p | x;\n        if (px == 0) {\n            if (Long.bitCount(maxClique) < Long.bitCount(r)) {\n                maxClique = r;\n            }\n            return;\n        }\n        int cnt = Long.bitCount(px);\n        int choice = random.nextInt(cnt);\n        int u;\n        for (int i = 0; ; i++) {\n            if ((px >>> i & 1) != 0 && choice-- == 0) {\n                u = i;\n                break;\n            }\n        }\n\n        long ne = p & ~neig[u];\n        for (int v = 0; v < V; v++){\n            if ((ne >>> v & 1) != 0) {\n                bronKerbosch2(r | 1L << v, p & neig[v], x & neig[v]);\n                p &= ~(1L << v);\n                x |= 1L << v;\n            }\n        }\n    }\n\n}\n\n\n    \n}\n", "complexity": "np", "problem": "0839_E", "from": "CODEFORCES", "tags": "brute force,graphs,math,meet-in-the-middle"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF {\n\n\tlong getAns(long a, long b) {\n\t\tif (a == b)\n\t\t\treturn 1;\n\t\tif (a < b) {\n\t\t\treturn getAns(b, a);\n\t\t}\n\t\t// a > b\n\t\tlong cnt = (a - 1) / b;\n\t\treturn cnt + getAns(b, a - b * cnt);\n\t}\n\n\tvoid solve() {\n\t\tlong a = in.nextLong();\n\t\tlong b = in.nextLong();\n\t\tout.println(getAns(a, b));\n\t}\n\n\tFastScaner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScaner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tvoid runWithFiles() {\n\t\tin = new FastScaner(new File(\"input.txt\"));\n\t\ttry {\n\t\t\tout = new PrintWriter(new File(\"output.txt\"));\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew CF().run();\n\t}\n\n\tclass FastScaner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScaner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tFastScaner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Sockets {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt(), m = in.nextInt(), socket = in.nextInt();\n        int[] filters = new int[n];\n\n        for (int i = 0; i < n; i++ ) {\n            filters[i] = in.nextInt();\n        }\n        Arrays.sort(filters);\n\n        int result = 0, index = n - 1;\n        while ( m > socket && index >= 0) {\n            socket += filters[index] - 1;\n            result += 1;\n            index -= 1;\n        }\n\n        out.println(m > socket ? -1 : result);\n        out.close();\n    }\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class ProblemB {\n    Map<Integer, List<int[]>> dest;\n\n    private ProblemB() throws IOException {\n        BufferedReader rd = new BufferedReader(new InputStreamReader(System.in));\n        String h = rd.readLine();\n        String[] q = h.split(\"\\\\s+\");\n        int a = Integer.parseInt(q[1]);\n        int b = Integer.parseInt(q[2]);\n        h = rd.readLine();\n        q = h.split(\" \");\n        int n = q.length;\n        int[] p = new int[n];\n        for(int i=0;i<n;i++) {\n            p[i] = Integer.parseInt(q[i]);\n        }\n        Set<Integer> pset = new HashSet<>();\n        for(int x: p) {\n            pset.add(x);\n        }\n\n        if(a == b) {\n            boolean res = true;\n            for(int x: p) {\n                if(!pset.contains(a-x)) {\n                    res = false;\n                    break;\n                }\n            }\n            out(res?\"YES\":\"NO\");\n            if(res) {\n                StringBuilder buf = new StringBuilder();\n                for(int i=0;i<n;i++) {\n                    if(i > 0) {\n                        buf.append(' ');\n                    }\n                    buf.append('0');\n                }\n                out(buf);\n            }\n        } else {\n            dest = new HashMap<>();\n            boolean res = true;\n            for(int x: p) {\n                boolean aOk = pset.contains(a-x);\n                boolean bOk = pset.contains(b-x);\n                if(!aOk && !bOk) {\n                    res = false;\n                    break;\n                } else {\n                    if(aOk) {\n                        addEdgeAndBack(x,a-x,0);\n                    }\n                    if(bOk) {\n                        addEdgeAndBack(x,b-x,1);\n                    }\n                }\n            }\n            Set<Integer> aSet = new HashSet<>();\n            if(res) {\n                for(int x: p) {\n                    List<int[]> e = getEdges(x);\n                    if(e.size() == 1) {\n                        int[] edge = e.get(0);\n                        if(edge[0] == x) {\n                            if(edge[1] == 0) {\n                                aSet.add(x);\n                            }\n                        } else {\n                            boolean odd = true;\n                            int curA = edge[1];\n                            int prev = x;\n                            while(true) {\n                                int cur = edge[0];\n                                if(curA == 0 && odd) {\n                                    aSet.add(prev);\n                                    aSet.add(cur);\n                                }\n                                e = getEdges(cur);\n                                if(e.size() == 1) {\n                                    if(!odd && e.get(0)[0] != cur) {\n                                        res = false;\n                                    }\n                                    break;\n                                }\n                                int other = e.get(0)[0] == prev?1:0;\n                                edge = e.get(other);\n                                if(edge[1] == curA) {\n                                    res = false;\n                                    break;\n                                }\n                                curA = 1-curA;\n                                prev = cur;\n                                odd = !odd;\n                            }\n                            if(!res) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            out(res?\"YES\":\"NO\");\n            if(res) {\n                StringBuilder buf = new StringBuilder();\n                for(int i=0;i<n;i++) {\n                    if(i>0) {\n                        buf.append(' ');\n                    }\n                    buf.append(aSet.contains(p[i])?'0':'1');\n                }\n                out(buf);\n            }\n        }\n    }\n\n    private void addEdgeAndBack(int from, int to, int u) {\n        addEdge(from, to, u);\n        addEdge(to, from, u);\n    }\n\n    private void addEdge(int from, int to, int u) {\n        List<int[]> edges = getEdges(from);\n        for(int[] edge: edges) {\n            if(edge[0] == to) {\n                return;\n            }\n        }\n        edges.add(new int[] { to, u });\n    }\n\n    private List<int[]> getEdges(int from) {\n        List<int[]> ds = dest.get(from);\n        if(ds == null) {\n            ds = new ArrayList<>();\n            dest.put(from, ds);\n        }\n        return ds;\n    }\n\n    private static void out(Object x) {\n        System.out.println(x);\n    }\n\n    public static void main(String[] args) throws IOException {\n        new ProblemB();\n    }\n}\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String line = in.readLine();\n        int n = line.length();\n        int maxlenght = 0;\n        for (int i = 0; i < n; i++) {\n            int j = line.indexOf(line.charAt(i), i + 1);\n            while (j != -1) {\n                int k = i;\n                int l = j;\n                while (k < n && l < n && line.charAt(k) == line.charAt(l)) {\n                    k++;\n                    l++;\n                }\n                if (k - i > maxlenght) {\n                    maxlenght = k - i;\n                }\n                j = line.indexOf(line.charAt(i), j + 1);\n            }\n        }\n        System.out.println(maxlenght);\n    }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DPairOfLines solver = new DPairOfLines();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DPairOfLines {\n        int n;\n        Point[] arr;\n\n        public void readInput(Scanner sc) {\n            n = sc.nextInt();\n            arr = new Point[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = new Point(sc.nextInt(), sc.nextInt());\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int q = 1;\n            while (q-- > 0) {\n                readInput(sc);\n                if (n <= 4) {\n                    pw.println(\"YES\");\n                    return;\n                }\n                boolean f = false;\n                for (int i = 0; i < 150; i++) {\n                    int rand = (int) (Math.random() * n);\n                    int rand2 = (int) (Math.random() * n);\n                    if (rand == rand2)\n                        continue;\n                    boolean[] out = new boolean[n];\n                    int c = 0;\n                    int first = -1, second = -1;\n                    for (int j = 0; j < n; j++) {\n                        if (j == rand || j == rand2)\n                            continue;\n                        if (!arr[j].onLine(arr[rand], arr[rand2])) {\n                            c++;\n                            out[j] = true;\n                            if (first == -1)\n                                first = j;\n                            else if (second == -1)\n                                second = j;\n                        }\n                    }\n                    if (c <= 2)\n                        f = true;\n                    else {\n                        boolean ff = true;\n                        for (int j = 0; j < n; j++) {\n                            if (!out[j])\n                                continue;\n                            if (j == first || j == second)\n                                continue;\n                            if (!arr[j].onLine(arr[first], arr[second]))\n                                ff = false;\n                        }\n                        f |= ff;\n                    }\n                }\n                pw.println(f ? \"YES\" : \"NO\");\n            }\n        }\n\n        public class Point implements Comparable<Point> {\n            static final double EPS = 1e-9;\n            long x;\n            long y;\n\n            Point(long a, long b) {\n                x = a;\n                y = b;\n            }\n\n            public int compareTo(Point p) {\n                if (Math.abs(x - p.x) > EPS) return x > p.x ? 1 : -1;\n                if (Math.abs(y - p.y) > EPS) return y > p.y ? 1 : -1;\n                return 0;\n            }\n\n            boolean onLine(Point a, Point b) {\n                if (a.compareTo(b) == 0) return compareTo(a) == 0;\n                Point temp = new Point(b.x - a.x, b.y - a.y);\n                Point temp2 = new Point(this.x - a.x, this.y - a.y);\n                return Math.abs(temp.x * temp2.y - temp.y * temp2.x) < EPS;\n            }\n\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "problem": "0961_D", "from": "CODEFORCES", "tags": "geometry"}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Solution {\n    private static int n;\n    private static PrintWriter writer;\n    private static int maxstep;\n    \n    private static void g(int src, int step) {\n        if (step != 0 && n % src == 0) {\n            writer.print(\"YES\");\n            writer.close();\n            System.exit(0);\n        }\n        \n        if (step == maxstep) return;\n        \n        int p = (int)Math.pow(10, step);\n        \n        g(src + 4 * p, step + 1);\n        g(src + 7 * p, step + 1);\n    }\n    \n    public static void main(String[] args) throws Exception {        \n        //Scanner reader = new Scanner(new File(\"input.txt\"));\n        //PrintWriter writer = new PrintWriter(\"output.txt\");\n        Scanner reader = new Scanner(System.in);\n        writer = new PrintWriter(System.out);\n        \n        n = reader.nextInt();\n        maxstep = String.valueOf(n).length() + 1;\n        \n        g(0, 0);\n        \n        writer.print(\"NO\");\n        writer.close();\n    }\n}", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tlong a=sc.nextInt(),b=sc.nextInt();\n\t\tlong x=sc.nextInt(),y=sc.nextInt(),z=sc.nextInt();\n\t\tlong t=y+x*2-a;\n\t\tif(t<0)\n\t\t\tt=0;\n\t\tlong r=y+z*3-b;\n\t\tif(r<0)\n\t\t\tr=0;\n\t\tSystem.out.print(t+r);\n\t}\n}", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\n\npublic class A15 {\n\n\tstatic StreamTokenizer in;\n\tstatic PrintWriter out;\n\t\n\tstatic int nextInt() throws IOException {\n\t\tin.nextToken();\n\t\treturn (int)in.nval;\n\t}\n\t\n\tstatic String nextString() throws IOException {\n\t\tin.nextToken();\n\t\treturn in.sval;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tint n = nextInt(), t = nextInt();\n\t\t\n\t\tint[] x = new int[n];\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nextInt();\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tboolean left = true, right = true;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (x[j] < x[i] && a[i] + 2*t + a[j] >= 2*Math.abs(x[i] - x[j])) left = false;\n\t\t\t\telse if (x[j] > x[i] && a[i] + 2*t + a[j] > 2*Math.abs(x[i] - x[j])) right = false;\n\t\t\tif (left) ans++;\n\t\t\tif (right) ans++;\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t\t\n\t\tout.flush();\n\t}\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class Main {\n       \n    static InputReader in;\n    \n    public static void main(String[] args) throws IOException{        \n        \n        File file = new File(\"input.txt\");\n        if(file.exists())in = new InputReader( new FileInputStream(file) );\n        else in = new InputReader( System.in );\n        \n        int n=in.nextInt(), m=in.nextInt(), k=in.nextInt();\n        int a[]=new int[n];\n        for( int i=0; i<n; i++ ) a[i]=in.nextInt();\n        Arrays.sort( a );\n        int i=n-1, ans=0;\n        while( k<m && i>=0 ) {\n            k+=a[i]-1;\n            i--;\n            ans++;\n        }\n        if( m<=k ) System.out.println( ans );\n        else System.out.println(\"-1\");\n    } \n    \n    // IO utilities:\n    \n    static void out(Object ...o){ \n        System.out.println(Arrays.deepToString(o)); \n    } \n    \n    static class InputReader {\n        \n        private BufferedInputStream inp;\n\tprivate int offset;\n\tprivate final int size=5120000;\n        private byte buff[];\n \n        InputReader( InputStream in ) throws IOException {\n\t\tinp = new BufferedInputStream( in );\n                buff=new byte[size];\n                offset=0;\n\t\tinp.read( buff, 0, size );\n\t}\n \n\tint nextInt() throws IOException {\n            \n            int parsedInt=0;\n            int i=offset;\n            if( buff[i]==0 ) throw new IOException(); //EOF\n            // skip any non digits\n            while ( i<size && ( buff[i]<'0' || buff[i]>'9' ) ) i++;\n            // read digits and parse number\n            while( i<size && buff[i]>='0' && buff[i]<='9') {\n                parsedInt*=10;\n                parsedInt+=buff[i]-'0';\n                i++;\n            }\n            // check if we reached end of buffer\n            if ( i==size ) {\n                // copy leftovers to buffer start\n\t\tint j = 0;\n\t\tfor ( ; offset<buff.length; j++, offset++ ) \n                        buff[j] = buff[offset];\n\t\t// and now fill the buffer\n\t\tinp.read( buff, j, size - j );\n\t\t// and attempt to parse int again\n\t\toffset = 0;\n\t\tparsedInt = nextInt();\n            } else offset=i;\n            return parsedInt;\n\t}\n        \n        long nextLong() throws IOException{\n            \n            long parsedLong=0;\n            int i=offset;\n            if( buff[i]==0 ) throw new IOException(); //EOF\n            // skip any non digits\n            while( i<size && ( buff[i]<'0' || buff[i]>'9' ) ) i++;\n            // read digits and parse number\n            while( i<size && buff[i]>='0' && buff[i]<='9') {\n                parsedLong*=10L;\n                parsedLong+=buff[i]-'0';\n                i++;\n            }\n            // check if we reached end of buffer\n            if ( i==size ) {\n                // copy leftovers to buffer start\n\t\tint j = 0;\n\t\tfor ( ; offset<buff.length; j++, offset++ ) \n                        buff[j] = buff[offset];\n\t\t// and now fill the buffer\n\t\tinp.read( buff, j, size - j );\n\t\t// and attempt to parse int again\n\t\toffset = 0;\n\t\tparsedLong = nextLong();\n            } else offset=i;\n            return parsedLong;\n        }\n        \n        String next() throws IOException {\n            \n            StringBuilder token=new StringBuilder();\n            int i=offset;\n            if( buff[i]==0 ) throw new IOException(); //EOF\n            // skip any non chars\n            while( i<size && ( buff[i]=='\\n' || buff[i]==' ' || buff[i]=='\\r' ||\n                    buff[i]=='\\t' ) ) i++;\n            // read chars\n            while( i<size && buff[i]!='\\n' && buff[i]!=' ' && buff[i]!='\\r' &&\n                    buff[i]!='\\t' && buff[i]!=0 ) {\n                token.append( (char)buff[i] );\n                i++;\n            }\n            // check if we reached end of buffer\n            if ( i==size ) {\n                // copy leftovers to buffer start\n\t\tint j = 0;\n\t\tfor ( ; offset<buff.length; j++, offset++ ) \n                        buff[j] = buff[offset];\n\t\t// and now fill the buffer\n\t\tinp.read( buff, j, size - j );\n\t\t// and attempt to parse int again\n\t\toffset = 0;\n\t\treturn next();\n            } else offset=i;\n            return token.toString();\n        }\n        \n        String nextLine() throws IOException {\n            \n            StringBuilder line=new StringBuilder();\n            int i=offset;\n            if( buff[i]==0 ) throw new IOException(); //EOF\n            // read chars\n            while( i<size && buff[i]!='\\n' && buff[i]!=0 ) {\n                line.append( (char)buff[i] );\n                i++;\n            }\n            if( i<size && buff[i]=='\\n' ) i++;\n            // check if we reached end of buffer\n            if ( i==size ) {\n                // copy leftovers to buffer start\n\t\tint j = 0;\n\t\tfor ( ; offset<buff.length; j++, offset++ ) \n                        buff[j] = buff[offset];\n\t\t// and now fill the buffer\n\t\tinp.read( buff, j, size - j );\n\t\t// and attempt to parse int again\n\t\toffset = 0;\n\t\treturn nextLine();\n            } else offset=i;\n            line.deleteCharAt( line.length()-1 );\n            return line.toString();\n        }\n        \n    }\n}", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.Scanner;\nimport java.math.BigInteger;\nimport java.io.*;\n\npublic class Main{\n\n\t/**\n\t * @param args\n\t */\n\tstatic BigInteger n, x, y, c;\n\tstatic BigInteger mk[] = new BigInteger[8];\n\tpublic static BigInteger f(BigInteger t) {\n\t\treturn t.multiply(t);\n\t}\n\t\n\tpublic static BigInteger g(BigInteger t) {\n\t\treturn t.multiply(t.add(BigInteger.ONE)).shiftRight(1);\n\t}\n\t\n\tpublic static int solve(BigInteger z) {\n\t\tBigInteger ret = z.multiply(z.add(BigInteger.ONE)).shiftLeft(1);\n\t\tret = ret.add(BigInteger.ONE);\n\t\t//System.out.println(z + \" \" + ret);\n\t\tfor(int i = 0; i < 8; i += 2) {\n\t\t\tif(z.compareTo(mk[i]) > 0) {\n\t\t\t\tret = ret.subtract(f(z.subtract(mk[i])));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < 8; i += 2) {\n\t\t\tif(z.compareTo(mk[i]) > 0) {\n\t\t\t\tret = ret.add(g(z.subtract(mk[i])));\n\t\t\t}\n\t\t}\n\t\t//System.out.println(z + \" \" + ret);\n\t\tif(ret.compareTo(c) >= 0) return 1;\n\t\treturn 0;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(cin.hasNext()) {\n\t\t\tn = cin.nextBigInteger();\n\t\t\tx = cin.nextBigInteger();\n\t\t\ty = cin.nextBigInteger();\n\t\t\tc = cin.nextBigInteger();\n\t\t\tmk[0] = x.subtract(BigInteger.ONE);\n\t\t\tmk[2] = n.subtract(y);\n\t\t\tmk[4] = n.subtract(x);\n\t\t\tmk[6] = y.subtract(BigInteger.ONE);\n\t\t\tmk[1] = mk[0].add(mk[2]).add(BigInteger.ONE);\n\t\t\tmk[3] = mk[2].add(mk[4]).add(BigInteger.ONE);\n\t\t\tmk[5] = mk[4].add(mk[6]).add(BigInteger.ONE);\n\t\t\tmk[7] = mk[6].add(mk[0]).add(BigInteger.ONE);\n\t\t\tBigInteger beg = BigInteger.ZERO, end = mk[0], mid;\n\t\t\tfor(int i = 1; i < 8; ++i) if(end.compareTo(mk[i]) < 0) end = mk[i];\n\t\t\twhile(beg.compareTo(end) < 0) {\n\t\t\t\tmid = beg.add(end).shiftRight(1);\n\t\t\t\tif(solve(mid) == 1) end = mid;\n\t\t\t\telse beg = mid.add(BigInteger.ONE);\n\t\t\t}\n\t\t\tSystem.out.println(end);\n\t\t}\n\n\t}\n\n}\n", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "\n\nimport java.awt.Point;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int t = in.nextInt() * 2;\n        Point[] A = new Point[n];\n        for (int i = 0; i < n; i++) {\n            int center = in.nextInt() * 2;\n            int side = in.nextInt();\n            A[i] = new Point(center - side, center + side);\n        }\n        Arrays.sort(A, new Comparator<Point>() {\n            public int compare(Point x, Point y) {\n                return x.x - y.x;\n            }\n        });\n        int ans = 2;\n        for (int i = 1; i < n; i++) {\n            if (A[i].x - A[i - 1].y > t)\n                ans += 2;\n            else if (A[i].x - A[i - 1].y == t)\n                ans++;\n        }\n        System.out.println(ans);\n    }\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "//package Round584;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class typeA {\n\tpublic static void main(String[] args) {\n\t\tFastReader s = new FastReader();\n\t\tint n = s.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tarr[i]=s.nextInt();\n\t\t}\n\t\tboolean[] arr2  = new boolean[n];\n\t\tArrays.sort(arr);\n\t\tfor(int i=0;i<arr2.length;i++) {\n\t\t\tarr2[i]=true;\n\t\t}\n\t\t//arr2[0]=true;\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\t\tif(arr[j]%arr[i]==0) {\n\t\t\t\t\t\tarr2[j]=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tint count=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(arr2[i]==true) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tstatic class FastReader \n\t\n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\t\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "//package round97;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class A {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\ta[i] = ni();\n\t\t}\n\t\tArrays.sort(a);\n\t\tif(a[n-1] > 1){\n\t\t\ta[n-1] = 1;\n\t\t\tArrays.sort(a);\n\t\t}else{\n\t\t\ta[n-1] = 2;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(i > 0)out.print(\" \");\n\t\t\tout.print(a[i]);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew A().run();\n\t}\n\t\n\tpublic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = 0;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile((b = is.read()) != -1 && (b == '\\r' || b == '\\n' || b == ' '));\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b == '\\r' || b == '\\n' || b == ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\tpublic char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = 0, p = 0;\n\t\t\twhile((b = is.read()) != -1 && (b == ' ' || b == '\\r' || b == '\\n'));\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b == ' ' || b == '\\r' || b == '\\n')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\n\tdouble nd() { return Double.parseDouble(ns()); }\n\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tvoid tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class B {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t/**/\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\t/*/\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(\"src/b.in\"))));\n\t\t/**/\n\t\t\n\t\tint t = sc.nextInt();\n\t\tfor (int z = 0; z < t; ++z) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n%2==1) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tn/=2;\n\t\t\tint sqrt = (int)Math.sqrt(n);\n\t\t\tif (sqrt*sqrt==n) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n%2==1) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tn/=2;\n\t\t\tsqrt = (int)Math.sqrt(n);\n\t\t\tif (sqrt*sqrt==n) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class File {\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t\n\t\t\n\t\t\n\t\tint n = sc.nextInt();\n\t\t\n\t\t// Should always be possible.\n\t\tint F1 = getClosest(n);\n\t\tn -= F1;\n\t\tint F2 = getClosest(n);\n\t\tn -= F2;\n\t\tint F3 = getClosest(n);\n\t\t\n\t\tout.println(F1 + \" \" + F2 + \" \" + F3);\n\t\t\n\t\t\n\t\t\n\t\tout.close();\n\t}\n\t\n\t// Gets the closest fibonacci number to n.\n\tpublic static int getClosest(int n) {\n\t\tint closest = 0;\n\t\tint f1 = 0;\n\t\tint f2 = 1;\n\t\t\n\t\twhile (f1 <= n) {\n\t\t\tclosest = Math.max(closest, f1);\n\t\t\t\n\t\t\tint next = f1 + f2;\n\t\t\tf1 = f2;\n\t\t\tf2 = next;\n\t\t}\n\t\t\n\t\treturn closest;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.util.*;\npublic class ProA {\n\tstatic long n;\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tn=in.nextLong();\n\t\tSystem.out.println(25);\n\t}\n}\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.*;\n\nimport static java.lang.System.*;\n\npublic class B {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(in);\n\n\t\tint n = sc.nextInt();\n\n\t\twhile(n-->0){\n\n\t\t\tString s = sc.next();\n\n\t\t\tif(s.matches(\"R[0-9]+C[0-9]+\")){\n\n\t\t\t\tString[] ss = s.replaceAll(\"[R|C]\",\" \").trim().split(\" \");\n\n\t\t\t\tint c = new Integer(ss[1]);\n\n\t\t\t\tString ans = \"\";\n\n\t\t\t\twhile(c > 0){\n\n\t\t\t\t\tc--;\n\n\t\t\t\t\tans = (char)(c % 26 + 'A')+ans;\n\n\t\t\t\t\tc/=26;\n\n\t\t\t\t}\n\n\t\t\t\tout.println(ans+\"\"+ss[0]);\n\n\t\t\t}else{\n\n\t\t\t\tString c = s.replaceAll(\"[0-9]\", \"\");\n\n\t\t\t\tString r = s.replaceAll(\"[A-Z]\", \"\");\n\n\t\t\t\tint num = 0;\n\n\t\t\t\tfor(int i = 0 ; i < c.length() ; i++){\n\n\t\t\t\t\tnum = num * 26 +(c.charAt(i) - 'A'+1);\n\n\t\t\t\t}\n\n\t\t\t\tout.println(\"R\"+r+\"C\"+num);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n}\n\n", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class A {\n\tpublic void run() throws Exception {\n\t\tFastScanner sc = new FastScanner();\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] arr = new int[n];\n\t\tint[] color = new int[n];\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tarr[i]  =sc.nextInt();\n\t\t}\n\t\tArrays.sort(arr);\n\t\tint counter = 1;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tif (color[i]!= 0) continue;\n\t\t\tfor (int j = i;j<n; j++) {\n\t\t\t\tif (color[j]!= 0) continue;\n\t\t\t\telse if (arr[j]%arr[i] == 0) color[j] = counter;\n\t\t\t}\n\t\t\tcounter++;\n\t\t}\n\t//\tSystem.out.println(Arrays.toString(color));\n\t\tint max = 0;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tmax = Math.max(max, color[i]);\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\tstatic class FastScanner {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic FastScanner() {\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\n\t}\n\tpublic static void main (String[] args) throws Exception {\n\t\tnew A().run();\n\t}\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "//created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class A\n{\n    private static final int MAX=(int)1e9+5;\n    private static ArrayDeque<Integer>[] edge;\n    private static int[] indeg, level;\n    private static Pair[] pairs;\n    private static ArrayDeque<Integer> Q;\n\n    static class Pair implements Comparable<Pair>\n    {\n        int f, s, c, id;\n        Pair(int f, int s, int c, int id){this.f = f;this.s = s; this.c=c; this.id=id;}\n        public int compareTo(Pair b){return Integer.compare(this.c,b.c);}\n    }\n    private static int topoSort(int mid, int N, int M)\n    {\n        int i;\n        for(i=0;i<N;i++) edge[i].clear();\n        Arrays.fill(indeg,0);\n        Q.clear(); Arrays.fill(level,0);\n\n        for(i=M-1;i>=0;i--)\n        {\n            if(pairs[i].c<=mid) break;\n\n            int u=pairs[i].f, v=pairs[i].s;\n            indeg[v]++; edge[u].add(v);\n        }\n\n        int count=0;\n        for(i=0;i<N;i++) if(indeg[i]==0) Q.add(i);\n        while (!Q.isEmpty())\n        {\n            int u=Q.poll();\n            level[u]=++count;\n\n            for(int v:edge[u])\n            {\n                indeg[v]--;\n                if(indeg[v]==0) Q.add(v);\n            }\n        }\n        return count;\n    }\n    private static boolean check(int mid, int N, int M){return topoSort(mid,N,M)==N;}\n    private static int bSearch(int N, int M)\n    {\n        int l=0,r=MAX, mid, ans=-1;\n        while (l<=r)\n        {\n            mid=(l+r)/2;\n            if(check(mid,N,M))\n            {\n                ans=mid;\n                r=mid-1;\n            }\n            else l=mid+1;\n        }\n\n        return ans;\n    }\n    public static void main(String[] args) throws Exception\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N;\n\n        String[] s=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        int M=Integer.parseInt(s[1]);\n\n        edge=new ArrayDeque[N]; for(i=0;i<N;i++) edge[i]=new ArrayDeque<>();\n        pairs=new Pair[M]; Q=new ArrayDeque<>(); indeg=new int[N];\n        level=new int[N];\n\n        for(i=0;i<M;i++)\n        {\n            s=br.readLine().trim().split(\" \");\n            int u=Integer.parseInt(s[0])-1;\n            int v=Integer.parseInt(s[1])-1;\n            int c=Integer.parseInt(s[2]);\n\n            pairs[i]=new Pair(u,v,c,i);\n        }\n        Arrays.sort(pairs);\n\n        int ans=bSearch(N,M);\n        StringBuilder sb=new StringBuilder();\n\n        int cur=topoSort(ans,N,M), rev=0;\n        for(i=0;i<M;i++)\n        {\n            if(pairs[i].c>ans) break;\n            int u=pairs[i].f, v=pairs[i].s;\n\n            if(level[u]==0&&level[v]==0)\n            {\n                level[u]=++cur;\n                level[v]=++cur;\n            }\n            else if(level[u]==0)\n            {\n                level[u]=++cur;\n                rev++; sb.append(pairs[i].id+1).append(\" \");\n            }\n            else if(level[v]==0)\n            {\n                level[v]=++cur;\n            }\n            else\n            {\n                if(level[v]<level[u])\n                {\n                    rev++;\n                    sb.append(pairs[i].id+1).append(\" \");\n                }\n            }\n        }\n\n        System.out.println(ans+\" \"+rev);\n        System.out.println(sb);\n    }\n}", "complexity": "nlogn", "problem": "1100_E", "from": "CODEFORCES", "tags": "binary search,dfs and similar,graphs"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main2 {\n\n    static int mod = 1000000007;\n    static FastScanner scanner;\n\n    public static void main(String[] args) {\n        scanner = new FastScanner();\n        long n = scanner.nextInt();\n        long k = scanner.nextInt();\n\n        if (sum(n) == k) {\n            System.out.println(0);\n            return;\n        }\n\n        long s = 0;\n        long e = n + 1;\n        while (s < e - 1) {\n            long m = (s + e) / 2;\n            long put = sum(n - m);\n            long candiesLeft = put - m;\n            if (candiesLeft == k) {\n                System.out.println(m);\n                return;\n            }\n            if (candiesLeft > k) {\n                s = m;\n            } else {\n                e = m;\n            }\n        }\n    }\n\n    static long sum(long n) {\n        long last = 1 + n - 1;\n        return ((1 + last) * n) / 2;\n    }\n\n    static class WithIdx {\n        int val, idx;\n\n        public WithIdx(int val, int idx) {\n            this.val = val;\n            this.idx = idx;\n        }\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                e.printStackTrace();\n                throw new RuntimeException();\n            }\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) res[i] = nextInt();\n            return res;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) res[i] = nextLong();\n            return res;\n        }\n\n        String[] nextStringArray(int n) {\n            String[] res = new String[n];\n            for (int i = 0; i < n; i++) res[i] = nextToken();\n            return res;\n        }\n    }\n\n    static class PrefixSums {\n        long[] sums;\n\n        public PrefixSums(long[] sums) {\n            this.sums = sums;\n        }\n\n        public long sum(int fromInclusive, int toExclusive) {\n            if (fromInclusive > toExclusive) throw new IllegalArgumentException(\"Wrong value\");\n            return sums[toExclusive] - sums[fromInclusive];\n        }\n\n        public static PrefixSums of(int[] ar) {\n            long[] sums = new long[ar.length + 1];\n            for (int i = 1; i <= ar.length; i++) {\n                sums[i] = sums[i - 1] + ar[i - 1];\n            }\n            return new PrefixSums(sums);\n        }\n\n        public static PrefixSums of(long[] ar) {\n            long[] sums = new long[ar.length + 1];\n            for (int i = 1; i <= ar.length; i++) {\n                sums[i] = sums[i - 1] + ar[i - 1];\n            }\n            return new PrefixSums(sums);\n        }\n    }\n\n    static class ADUtils {\n        static void sort(int[] ar) {\n            Random rnd = ThreadLocalRandom.current();\n            for (int i = ar.length - 1; i > 0; i--)\n            {\n                int index = rnd.nextInt(i + 1);\n                // Simple swap\n                int a = ar[index];\n                ar[index] = ar[i];\n                ar[i] = a;\n            }\n            Arrays.sort(ar);\n        }\n\n        static void reverse(int[] arr) {\n            int last = arr.length / 2;\n            for (int i = 0; i < last; i++) {\n                int tmp = arr[i];\n                arr[i] = arr[arr.length - 1 - i];\n                arr[arr.length - 1 - i] = tmp;\n            }\n        }\n\n        static void sort(long[] ar) {\n            Random rnd = ThreadLocalRandom.current();\n            for (int i = ar.length - 1; i > 0; i--)\n            {\n                int index = rnd.nextInt(i + 1);\n                // Simple swap\n                long a = ar[index];\n                ar[index] = ar[i];\n                ar[i] = a;\n            }\n            Arrays.sort(ar);\n        }\n    }\n\n    static class MathUtils {\n        static long[] FIRST_PRIMES = {\n                2,     3,      5,      7,     11,     13,     17,     19,     23,     29,\n                31,     37,     41,     43,     47,     53,     59,     61,     67,     71,\n                73,     79,     83,     89  ,   97 ,    101,    103,    107,    109,    113,\n                127,    131,    137,    139,    149,    151,    157,    163,    167,    173,\n                179,    181,    191,    193,    197,    199,    211,    223,    227,    229,\n                233,    239,    241,    251,    257,    263,    269,    271,    277,    281,\n                283,    293,    307,    311,    313,    317,    331,    337,    347,    349,\n                353,    359,    367,    373,    379,    383,    389,    397,    401,    409,\n                419,    421,    431,    433,    439,    443,    449,    457,    461,    463,\n                467,    479,    487,    491,    499,    503,    509,    521,    523,    541,\n                547,    557,    563,    569,    571,    577,    587,    593,    599,    601,\n                607,    613,    617,    619,    631,    641,    643,    647,    653,    659,\n                661,    673,    677,    683,    691,    701,    709,    719,    727,    733,\n                739,    743,    751,    757,    761,    769,    773,    787,    797,    809,\n                811,    821,    823,    827,    829,    839,    853,    857,    859,    863,\n                877,    881,    883,    887,    907,    911,    919,    929,    937,    941,\n                947,    953,    967,    971,    977,    983,    991,    997,   1009,   1013,\n                1019,   1021,   1031,   1033,   1039,   1049,   1051};\n\n        static long[] primes(int to) {\n            long[] all = new long[to + 1];\n            long[] primes = new long[to + 1];\n            all[1] = 1;\n            int primesLength = 0;\n            for (int i = 2; i <= to; i ++) {\n                if (all[i] == 0) {\n                    primes[primesLength++] = i;\n                    all[i] = i;\n                }\n                for (int j = 0; j < primesLength && i * primes[j] <= to && all[i] >= primes[j]; j++) {\n                    all[(int) (i * primes[j])] = primes[j];\n                }\n            }\n            return Arrays.copyOf(primes, primesLength);\n        }\n\n        static long modpow(long b, long e, long m) {\n            long result = 1;\n\n            while (e > 0) {\n                if ((e & 1) == 1) {\n                    /* multiply in this bit's contribution while using modulus to keep\n                     * result small */\n                    result = (result * b) % m;\n                }\n                b = (b * b) % m;\n                e >>= 1;\n            }\n\n            return result;\n        }\n\n        static long submod(long x, long y, long m) {\n            return (x - y + m) % m;\n        }\n    }\n}\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "\nimport java.util.Scanner;\n\n/**\n * 2013.07.27 No.1 235A LCM Challenge\n * \u6570\u8bba n%2 == 0?     n%3 == 0?\n * @author Administrator * \n */\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        if (n < 3)\n            System.out.println(n);\n        else if (n % 2 != 0)\n            System.out.println((long)n * (n - 1) * (n - 2));\n        else if(n % 3 != 0)\n            System.out.println((long)n * (n - 1) * (n - 3));\n        else \n            System.out.println((long)(n - 1) * (n - 2) * (n - 3));\n        in.close();\n        \n\n    }\n} ", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.Scanner;\n\npublic class A961_Tetris {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner input = new Scanner(System.in);\n\t\tint platforms = input.nextInt();\n\t\tint in = input.nextInt();\n\t\tint[] cols = new int[platforms];\n\t\tint[] squares = new int[in];\n\t\t\n\t\tfor (int i = 0; i < in; i ++) {\n\t\t\tsquares[i] = input.nextInt();\n\t\t}\n\t\t\n\t\tboolean hi = false;\n\t\tint score = 0;\n\t\t\n\t\tfor (int i = 0; i < in; i ++) {\n\t\t\tcols[squares[i] - 1] ++;\n\t\t\thi = checkscore(cols);\n\t\t\tif (hi == true) {\n\t\t\t\thi = false;\n\t\t\t\tscore ++;\n\t\t\t\tfor (int j = 0; j < cols.length; j ++) {\n\t\t\t\t\tcols[j] --;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(score);\n\t\t\n\t}\n\t\n\tpublic static boolean checkscore(int[] cols) {\n\t\tfor (int i = 0; i < cols.length; i ++) {\n\t\t\tif (cols[i] == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}\n\n}\n", "complexity": "quadratic", "problem": "0961_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Main {\n\tint work(int x){\n\t\tif(x%2==0)return x+1;\n\t\telse return x-1;\n\t}\n\tstatic int N = 200050;\n\tclass Node implements Comparable <Node>{\n\t\tint x, id;\n\t\tNode(int x, int id){\n\t\t\tthis.x = x; this.id = id;\n\t\t}\n\t\tpublic int compareTo(Node o){\n\t\t\treturn Integer.compare(x, o.x);\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn id + \"=\" + x;\n\t\t}\n\t}\n\tclass Edge{\n\t\tint from, to, nex;\n\t\tEdge (int from, int to, int nex){\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.nex = nex;\n\t\t}\n\t}\n\tEdge[] edge = new Edge[N*10];\n\tint[] head = new int[N];\n\tint edgenum;  \n\tvoid addedge(int u, int v){  \n\t    Edge E = new Edge(u, v, head[u]);  \n\t    edge[edgenum] = E;  \n\t    head[u] = edgenum ++;  \n\t}  \n\t\n\tint n;\n\tint[] p = new int[N], ans = new int[N];\n\tint a, b, max;\n    Map<Integer, Integer> map = new HashMap();\n    boolean match(int x, int y, int col){\n    \tint P = map.get(x);\n    \tif(map.containsKey(y-x) == false)\n    \t\treturn false;\n    \tint Q = map.get(y - x);\n    \tif(ans[Q] == -1 || x * 2 == y){\n    \t\tans[Q] = ans[P] = col;\n    \t}\n    \telse {\n    \t\tif(match(a+b-2*y+x, y, col))\n    \t\t\tans[Q] = ans[P] = col; \t\t\n    \t\telse return false;\n    \t}\n    \treturn true;\n    }\n    boolean solve(){\n    \tif(max >= a && max >= b)return false;\n    \tfor(int i = 1; i <= n; i++)\n    \t\tif(ans[i] == -1)\n    \t\t{\n    \t\t\tif(match(p[i], a, 0)==false && match(p[i], b, 1) == false)\n    \t\t\t\treturn false;\n    \t\t}    \t\n    \treturn true;\n    }\n\tvoid init(){\n\t\tn = cin.nextInt();\n\t\ta = cin.nextInt(); b = cin.nextInt();\n\t\tmax = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tans[i] = -1;\n\t\t\tp[i] = cin.nextInt();\n\t\t\tmap.put(p[i], i);\n\t\t\tif(p[i] > max) max = p[i];\n\t\t}\n\t}\n\tpublic void work(){\n\t\tinit();\n\t\tif(solve()){\n\t\t\tout.println(\"YES\");\n\t\t\tfor(int i = 1; i <= n; i++)out.print(ans[i]+\" \"); out.println();\n\t\t}\n\t\telse \n\t\t\tout.println(\"NO\");\n\t}\n\tMain() {\n        cin = new Scanner(System.in);  \n        out = new PrintWriter(System.out);\n    }  \n    public static void main(String[] args) {\n        Main e = new Main();  \n        e.work();\n        out.close();\n    }\n    public Scanner cin;\n    public static PrintWriter out;\n}\n/*\nhttp://blog.csdn.net/keshuai19940722/article/details/39528801\n\n*/", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "/**\n * Created by Ariana Herbst on 12/29/17.\n */\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * Created by Ariana Herbst on 12/29/17\n */\npublic class GB2017C {\n    static int n, r;\n    static int[] x;\n    static Map<Integer, Double> horo;\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        StringBuilder sb = new StringBuilder();\n        n = sc.nextInt();\n        r = sc.nextInt();\n        x = new int[n];\n        horo = new HashMap<Integer, Double>();\n        for (int x = 0; x <= r*2; x++) {\n            double y = 2.0 *Math.sqrt(r * r - (r - x/2.0) * (r - x/2.0));\n            horo.put(x, y);\n        }\n        for (int i = 0; i < n; i++) {\n            x[i] = sc.nextInt();\n        }\n        List<Double> y = new ArrayList<Double>();\n        for (int i = 0; i < n; i++) {\n            double max = r;\n            for (int j = 0; j < y.size(); j++) {\n                int dx = intersects(i, j);\n                if (dx >= 0) {\n                    double dy = horo.get(dx);\n                    max = Math.max(max, dy + y.get(j));\n                }\n            }\n            y.add(max);\n        }\n        for (int i = 0; i < n; i++) {\n            sb.append(y.get(i) + \" \");\n        }\n        System.out.println(sb);\n    }\n\n    static int intersects(int i, int j) {\n        if (Math.abs(x[i] - x[j]) <= 2*r) {\n            return 2*r - Math.abs(x[i] - x[j]);\n        } else\n            return -1;\n    }\n\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n\n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextLong();\n            }\n            return a;\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n    static String input[];\n    static int index=0;\n\n    public static void main(String[] args) throws IOException {\n\n        Scanner in = new Scanner(System.in);\n        StringBuffer out=new StringBuffer();\n\n        int t=in.nextInt();\n\n        OUTER:\n        while(t--!=0) {\n\n            int n=in.nextInt();\n            int arr[]=new int[n+1];\n            for(int i=1; i<=n; i++) {\n                arr[i]=in.nextInt();\n            }\n\n            LinkedList<Integer> list=new LinkedList<>();\n\n            for(int i=1; i<=n; i++) {\n                if(list.isEmpty()) {\n                    list.add(arr[i]);\n                } else {\n                    if(arr[i]==1)\n                        list.add(arr[i]);\n                    else {\n                        while(!list.isEmpty() && arr[i]!=list.getLast()+1)\n                            list.pollLast();\n                        if(!list.isEmpty())\n                            list.pollLast();\n                        list.add(arr[i]);\n                    }\n                }\n\n                int index=0;\n                for(int item: list) {\n                    if(index!=0)\n                        out.append(\".\");\n                    out.append(item);\n                    index+=1;\n                }\n                out.append(\"\\n\");\n            }\n        }\n\n        System.out.print(out);\n    }\n\n    private static void get() throws IOException {\n        if(input==null || index==input.length) {\n            input=br.readLine().split(\"\\\\s\");\n        }\n    }\n\n    private static int getInt() throws IOException {\n        get();\n        return Integer.parseInt(input[index++]);\n    }\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class PaintTheNumber {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\t\n\t\tArrayList<Integer> l=new ArrayList<Integer>();\n\t\t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tl.add(sc.nextInt());\n\t\t}\n\t\t\n\t\tboolean c=false;\n\t\t\n\t\t\n\t\t\tfor(int i=0; i<l.size(); i++) {\n\t\t\t\tif(l.get(i)==-1)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int j=0; j<l.size(); j++) {\n\t\t\t\t\t\n\t\t\t\t\tif(i==j || l.get(j)==-1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(l.get(j)%l.get(i)==0) {\n\t\t\t\t\t\t\tl.set(j, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint nbr=0;\n\t\t\tfor(int i=0; i<l.size(); i++)\n\t\t\t\tif(l.get(i)!=-1)\n\t\t\t\t\tnbr++;\n\t\t\tSystem.out.println(nbr);\n\t}\n\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "//package codechef;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * Created by sky on 23/6/18.\n * www.github.com/aakashjaiswal1\n * aakashjaiswal@hotmail.co.in\n * aakashjaiswal.in@gmail.com\n * people die if they are killed\n */\n public class ftd {\n    public static void main(String[] args) {\n        in = new FastReader();\n        int A=ni();\n        int B=ni();\n        int C=ni();\n        int N=ni();\n        long total_won=A+B-C;\n        if (total_won>=(long)N){\n            System.out.println(-1);\n            return;\n        }\n        if (C>Math.min(A,B)){\n            System.out.println(-1);\n            return;\n        }\n        long ans=(long)N-((long)total_won);\n        System.out.println(ans);\n\n    }\n    static void reverse(char[] arr ,int i,int j){\n        if (i==j)\n            return;\n        while (i<j){\n            char temp=arr[i];\n            arr[i]=arr[j];\n            arr[j]=temp;\n            ++i;\n            --j;\n        }\n    }\n    static int[]  takeIntegerArrayInput(int no){\n        int[] arr=new int[no];\n        for (int i=0;i<no;++i){\n            arr[i]=ni();\n        }\n        return arr;\n    }\n    static long fast_Multiply(long no , long pow){\n        long result=1;\n        while (pow>0){\n            if ((pow&1)==1){\n                result=result*no;\n            }\n            no=no*no;\n            pow>>=1;\n        }\n        return result;\n    }\n\n    static long[]  takeLongArrayInput(int no){\n        long[] arr=new long[no];\n        for (int i=0;i<no;++i){\n            arr[i]=ni();\n        }\n        return arr;\n    }\n    static final long MOD = (long)1e9+7;\n    static FastReader in;\n\n\n    static void p(Object o){\n        System.out.print(o);\n    }\n\n    static void pn(Object o){\n        System.out.println(o);\n    }\n\n    static String n(){\n        return in.next();\n    }\n\n    static String nln(){\n        return in.nextLine();\n    }\n\n    static int ni(){\n        return Integer.parseInt(in.next());\n    }\n\n    static int[] ia(int N){\n        int[] a = new int[N];\n        for(int i = 0; i<N; i++)a[i] = ni();\n        return a;\n    }\n\n    static long[] la(int N){\n        long[] a = new long[N];\n        for(int i = 0; i<N; i++)a[i] = nl();\n        return a;\n    }\n\n    static long nl(){\n        return Long.parseLong(in.next());\n    }\n\n    static double nd(){\n        return Double.parseDouble(in.next());\n    }\n\n    static class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next(){\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try{\n                str = br.readLine();\n            }catch (IOException e){\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static void println(String[] arr){\n        for (int i=0;i<arr.length;++i){\n            System.out.println(arr[i]);\n        }\n    }\n\n}\n", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.*;\npublic class mad{\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int cura = 0,curb = 0;\n        int ver;\n        System.out.println(\"? 0 0\");\n        System.out.flush();\n        ver = sc.nextInt();\n        for(int i=29;i>=0;i--){\n            System.out.println(\"? \"+(cura+(1<<i))+\" \"+curb);\n            System.out.flush();\n            int temp1 = sc.nextInt();\n            System.out.println(\"? \"+cura+\" \"+(curb+(1<<i)));\n            System.out.flush();\n            int temp2 = sc.nextInt();\n            if(temp1!=temp2){\n                if(temp2==1){\n                    cura += (1<<i);\n                    curb += (1<<i);\n                }\n            }\n            else{\n                if(ver==1) cura += (1<<i);\n                if(ver==-1) curb += (1<<i);\n                \n                ver = temp1;\n            }\n        }\n        System.out.println(\"! \"+cura+\" \"+curb);\n    }\n    \n}", "complexity": "logn", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "import java.util.Scanner;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport java.math.*;\n\nimport java.lang.*;\n\nimport static java.lang.Math.*;\n\n\n\npublic class main implements Runnable{\n\n\n\n    static ArrayList <Integer> adj[];\n\n    static int co=0,f=0;\n\n\n\n    static void Check2(int n){\n\n        adj=new ArrayList[n+1];\n\n        for(int i=0;i<=n;i++){\n\n            adj[i]=new ArrayList<>();\n\n        }\n\n\n\n    }\n\n    static void add(int i,int j){\n\n\n\n        adj[i].add(j);\n\n        adj[j].add(i);\n\n    }\n\n    public static void main(String[] args)  {\n\n        new Thread(null, new main(), \"Check2\", 1<<26).start();// to increse stack size in java\n\n    }\n\n    static long mod=(long)(1e9+7);\n\n    public void run() {\n\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n\n        //Scanner in=new Scanner(System.in);\n\n\n\n        InputReader in = new InputReader(System.in);\n\n        PrintWriter w = new PrintWriter(System.out);\n\n\n\n\n\n\n\n       long n=in.nextLong();\n\n        long s=in.nextLong();\n\n        \n\n        long l=1;\n\n        long r=(long)(n);\n\n       long ans=-1;\n\n        while(l<=r){\n\n            \n\n            long mid=(l+r)/2;\n\n            if(ch(mid,s)){\n\n                ans=mid;\n\n                r=mid-1;\n\n            }\n\n            else\n\n            {\n\n                l=mid+1;\n\n            }\n\n            \n\n        }\n\n        if(ans==-1)w.println(0);\n\n        else\n\n            w.println(n-ans+1);\n\n        w.close();\n\n    }\n\n        public boolean ch(long a,long s){\n\n            \n\n            long p=0;\n\n            long val=a;\n\n            while(val>0){\n\n                p=p+val%10;\n\n                val=val/10;\n\n            }\n\n            if(a-p>=s)return true;\n\n            return false;\n\n            \n\n        }\n\n    public boolean rec(int a,int b,int x,int y,int c,int d,int co){\n\n\n\n        if(a>x|b>y)return false;\n\n\n\n        if(a<-100000||b<-100000||co>100000)return false;\n\n\n\n        if(a==x&&b==y)return true;\n\n\n\n\n\n\n\n        return (rec(a+c,b+d,x,y,c,d,co+1)||rec(a+c,b-d,x,y,c,d,co+1)||rec(a-c,b+d,x,y,c,d,co+1)||rec(a-c,b-d,x,y,c,d,co+1));\n\n\n\n\n\n\n\n    }\n\n\n\n\n\n\n\n    static  int gcd(int a,int b){\n\n\n\n        if(b==0)return a;\n\n        return gcd(b,a%b);\n\n    }\n\n    static  void dfs(int i,int v[],int val,int b[]){\n\n\n\n\n\n        if(v[i]==1)return ;\n\n\n\n        v[i]=1;\n\n        b[i]=val;\n\n\n\n        Iterator <Integer> it=adj[i].iterator();\n\n        while(it.hasNext()){\n\n            int q=it.next();\n\n            dfs(q,v,val,b);\n\n        }\n\n\n\n\n\n\n\n\n\n\n\n    }\n\n\n\n    static  void sev(int a[],int n){\n\n\n\n        for(int i=2;i<=n;i++)a[i]=i;\n\n        for(int i=2;i<=n;i++){\n\n\n\n            if(a[i]!=0){\n\n                for(int j=2*i;j<=n;){\n\n\n\n                    a[j]=0;\n\n                    j=j+i;\n\n                }\n\n            }\n\n\n\n        }\n\n\n\n    }\n\n\n\n    static class pair implements Comparable<pair> {\n\n\n\n        int x,y;\n\n        pair(int c,int d){\n\n            x=c;\n\n            y=d;\n\n        }\n\n\n\n        public int compareTo(pair o){\n\n\n\n            return (this.x-o.x);   //sort in incrementing order w.r.t to c\n\n        }\n\n\n\n\n\n\n\n    }\n\n\n\n    static class node{\n\n\n\n        int y;\n\n        int val;\n\n\n\n        node(int a,int b){\n\n\n\n            y=a;\n\n            val=b;\n\n\n\n        }\n\n\n\n\n\n    }\n\n    static  void rec(String s,int a,int b,int n){\n\n\n\n        if(b==n){\n\n            System.out.println(s);\n\n            return ;\n\n        }\n\n        String p=s;\n\n        if(a>b){\n\n            s=p+\")\" ;\n\n            rec(s,a,b+1,n);\n\n        }\n\n        if(a<n){\n\n            s=p+\"(\";\n\n            rec(s,a+1,b,n);\n\n        }\n\n\n\n\n\n\n\n\n\n    }\n\n\n\n    static class InputReader\n\n    {\n\n        private InputStream stream;\n\n        private byte[] buf = new byte[1024];\n\n        private int curChar;\n\n        private int numChars;\n\n        private SpaceCharFilter filter;\n\n\n\n        public InputReader(InputStream stream)\n\n        {\n\n            this.stream = stream;\n\n        }\n\n\n\n        public int read()\n\n        {\n\n            if (numChars==-1)\n\n                throw new InputMismatchException();\n\n\n\n            if (curChar >= numChars)\n\n            {\n\n                curChar = 0;\n\n                try\n\n                {\n\n                    numChars = stream.read(buf);\n\n                }\n\n                catch (IOException e)\n\n                {\n\n                    throw new InputMismatchException();\n\n                }\n\n\n\n                if(numChars <= 0)\n\n                    return -1;\n\n            }\n\n            return buf[curChar++];\n\n        }\n\n\n\n        public String nextLine()\n\n        {\n\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n            String str = \"\";\n\n            try\n\n            {\n\n                str = br.readLine();\n\n            }\n\n            catch (IOException e)\n\n            {\n\n                e.printStackTrace();\n\n            }\n\n            return str;\n\n        }\n\n        public int nextInt()\n\n        {\n\n            int c = read();\n\n\n\n            while(isSpaceChar(c))\n\n                c = read();\n\n\n\n            int sgn = 1;\n\n\n\n            if (c == '-')\n\n            {\n\n                sgn = -1;\n\n                c = read();\n\n            }\n\n\n\n            int res = 0;\n\n            do\n\n            {\n\n                if(c<'0'||c>'9')\n\n                    throw new InputMismatchException();\n\n                res *= 10;\n\n                res += c - '0';\n\n                c = read();\n\n            }\n\n            while (!isSpaceChar(c));\n\n\n\n            return res * sgn;\n\n        }\n\n\n\n        public long nextLong()\n\n        {\n\n            int c = read();\n\n            while (isSpaceChar(c))\n\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-')\n\n            {\n\n                sgn = -1;\n\n                c = read();\n\n            }\n\n            long res = 0;\n\n\n\n            do\n\n            {\n\n                if (c < '0' || c > '9')\n\n                    throw new InputMismatchException();\n\n                res *= 10;\n\n                res += c - '0';\n\n                c = read();\n\n            }\n\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n\n        }\n\n\n\n        public double nextDouble()\n\n        {\n\n            int c = read();\n\n            while (isSpaceChar(c))\n\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-')\n\n            {\n\n                sgn = -1;\n\n                c = read();\n\n            }\n\n            double res = 0;\n\n            while (!isSpaceChar(c) && c != '.')\n\n            {\n\n                if (c == 'e' || c == 'E')\n\n                    return res * Math.pow(10, nextInt());\n\n                if (c < '0' || c > '9')\n\n                    throw new InputMismatchException();\n\n                res *= 10;\n\n                res += c - '0';\n\n                c = read();\n\n            }\n\n            if (c == '.')\n\n            {\n\n                c = read();\n\n                double m = 1;\n\n                while (!isSpaceChar(c))\n\n                {\n\n                    if (c == 'e' || c == 'E')\n\n                        return res * Math.pow(10, nextInt());\n\n                    if (c < '0' || c > '9')\n\n                        throw new InputMismatchException();\n\n                    m /= 10;\n\n                    res += (c - '0') * m;\n\n                    c = read();\n\n                }\n\n            }\n\n            return res * sgn;\n\n        }\n\n\n\n        public String readString()\n\n        {\n\n            int c = read();\n\n            while (isSpaceChar(c))\n\n                c = read();\n\n            StringBuilder res = new StringBuilder();\n\n            do\n\n            {\n\n                res.appendCodePoint(c);\n\n                c = read();\n\n            }\n\n            while (!isSpaceChar(c));\n\n\n\n            return res.toString();\n\n        }\n\n\n\n        public boolean isSpaceChar(int c)\n\n        {\n\n            if (filter != null)\n\n                return filter.isSpaceChar(c);\n\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\n        }\n\n\n\n        public String next()\n\n        {\n\n            return readString();\n\n        }\n\n\n\n        public interface SpaceCharFilter\n\n        {\n\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n\n\npublic class B {\n\tint mod=1000_000_007;\n\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t    FastScanner fs=new FastScanner();\n\t    int t=fs.nextInt();\n\t    while(t-->0) {\n\t    \tdouble n=fs.nextInt();\n\t    \tif(isp(n/2)||isp(n/4)) {\n\t    \t\tSystem.out.println(\"YES\");\n\t    \t}\n\t    \telse System.out.println(\"NO\");\n\t    }\n\t}\n\tstatic boolean isp(double n) {\n\t\tif(n==0) return false;\n\t\tdouble a=Math.ceil(Math.sqrt(n));\n\t\tdouble b=Math.floor(Math.sqrt(n));\n\t\treturn a==b;\n\t}\n\tstatic void mysort(long[] a) {\n\t\t//suffle\n\t\tint n=a.length;\n\t\tRandom r=new Random();\n\t\tfor (int i=0; i<a.length; i++) {\n\t\t\tint oi=r.nextInt(n);\n\t\t\tlong temp=a[i];\n\t\t\ta[i]=a[oi];\n\t\t\ta[oi]=temp;\n\t\t}\n\t\t\n\t\t//then sort\n\t\tArrays.sort(a);\n\t}\n\t\n\t// Use this to input code since it is faster than a Scanner\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n \n}", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class B {\n\n\tstatic StringTokenizer st;\n\tstatic BufferedReader br;\n\tstatic PrintWriter pw;\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tint n = nextInt();\n\t\tint left = 0, right = n;\n\t\tint x1 = 0, y1 = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0, x4 = 0, y4 = 0;\n\t\twhile (right-left > 1) {\n\t\t\tint mid = (left+right) >> 1;\n\t\t\tSystem.out.println(\"? \"+1+\" \"+1+\" \"+mid+\" \"+n);\n\t\t\tint ans = nextInt();\n\t\t\tif (ans==2)\n\t\t\t\tright = mid;\n\t\t\telse\n\t\t\t\tleft = mid;\n\t\t}\n\t\tx4 = right;\n\t\tleft = 0;\n\t\tright = n;\n\t\twhile (right-left > 1) {\n\t\t\tint mid = (left+right) >> 1;\n\t\t\tSystem.out.println(\"? \"+1+\" \"+1+\" \"+mid+\" \"+n);\n\t\t\tint ans = nextInt();\n\t\t\tif (ans >= 1)\n\t\t\t\tright = mid;\n\t\t\telse\n\t\t\t\tleft = mid;\n\t\t}\n\t\tx2 = right;\n\t\tleft = 1;\n\t\tright = n+1;\n\t\twhile (right-left > 1) {\n\t\t\tint mid = (left+right) >> 1;\n\t\t\tSystem.out.println(\"? \"+mid+\" \"+1+\" \"+n+\" \"+n);\n\t\t\tint ans = nextInt();\n\t\t\tif (ans >= 1)\n\t\t\t\tleft = mid;\n\t\t\telse\n\t\t\t\tright = mid;\n\t\t}\n\t\tx3 = left;\n\t\tleft = 1;\n\t\tright = n+1;\n\t\twhile (right-left > 1) {\n\t\t\tint mid = (left+right) >> 1;\n\t\t\tSystem.out.println(\"? \"+mid+\" \"+1+\" \"+n+\" \"+n);\n\t\t\tint ans = nextInt();\n\t\t\tif (ans >= 2)\n\t\t\t\tleft = mid;\n\t\t\telse\n\t\t\t\tright = mid;\n\t\t}\n\t\tx1 = left;\n\t\t\n\t\tleft = 0;\n\t\tright = n;\n\t\twhile (right-left > 1) {\n\t\t\tint mid = (left+right) >> 1;\n\t\t\tSystem.out.println(\"? \"+1+\" \"+1+\" \"+n+\" \"+mid);\n\t\t\tint ans = nextInt();\n\t\t\tif (ans>=2)\n\t\t\t\tright = mid;\n\t\t\telse\n\t\t\t\tleft = mid;\n\t\t}\n\t\ty4 = right;\n\t\tleft = 0;\n\t\tright = n;\n\t\twhile (right-left > 1) {\n\t\t\tint mid = (left+right) >> 1;\n\t\t\tSystem.out.println(\"? \"+1+\" \"+1+\" \"+n+\" \"+mid);\n\t\t\tint ans = nextInt();\n\t\t\tif (ans >= 1)\n\t\t\t\tright = mid;\n\t\t\telse\n\t\t\t\tleft = mid;\n\t\t}\n\t\ty2 = right;\n\t\tleft = 1;\n\t\tright = n+1;\n\t\twhile (right-left > 1) {\n\t\t\tint mid = (left+right) >> 1;\n\t\t\tSystem.out.println(\"? \"+1+\" \"+mid+\" \"+n+\" \"+n);\n\t\t\tint ans = nextInt();\n\t\t\tif (ans >= 1)\n\t\t\t\tleft = mid;\n\t\t\telse\n\t\t\t\tright = mid;\n\t\t}\n\t\ty3 = left;\n\t\tleft = 1;\n\t\tright = n+1;\n\t\twhile (right-left > 1) {\n\t\t\tint mid = (left+right) >> 1;\n\t\t\tSystem.out.println(\"? \"+1+\" \"+mid+\" \"+n+\" \"+n);\n\t\t\tint ans = nextInt();\n\t\t\tif (ans >= 2)\n\t\t\t\tleft = mid;\n\t\t\telse\n\t\t\t\tright = mid;\n\t\t}\n\t\ty1 = left;\n\t\tif (y3 <= y2 && x3 <= x2) {\n\t\t\tSystem.out.println(\"! \"+x3+\" \"+y3+\" \"+x2+\" \"+y2+\" \"+x1+\" \"+y1+\" \"+x4+\" \"+y4);\n\t\t\treturn;\n\t\t}\n\n\t\tSystem.out.println(\"? \"+x1+\" \"+y1+\" \"+x2+\" \"+y2);\n\t\tint ans1 = nextInt();\n\t\tSystem.out.println(\"? \"+x3+\" \"+y3+\" \"+x4+\" \"+y4);\n\t\tint ans2 = nextInt();\n\t\tif (ans1==1 && ans2==1) {\n\t\t\tSystem.out.println(\"! \"+x1+\" \"+y1+\" \"+x2+\" \"+y2+\" \"+x3+\" \"+y3+\" \"+x4+\" \"+y4);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"? \"+x1+\" \"+y3+\" \"+x2+\" \"+y4);\n\t\tans1 = nextInt();\n\t\tSystem.out.println(\"? \"+x3+\" \"+y1+\" \"+x4+\" \"+y2);\n\t\tans2 = nextInt();\n\t\tif (ans1==1 && ans2==1) {\n\t\t\tSystem.out.println(\"! \"+x1+\" \"+y3+\" \"+x2+\" \"+y4+\" \"+x3+\" \"+y1+\" \"+x4+\" \"+y2);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"? \"+x1+\" \"+y1+\" \"+x4+\" \"+y2);\n\t\tans1 = nextInt();\n\t\tSystem.out.println(\"? \"+x3+\" \"+y3+\" \"+x2+\" \"+y4);\n\t\tans2 = nextInt();\n\t\tif (ans1==1 && ans2==1) {\n\t\t\tSystem.out.println(\"! \"+x1+\" \"+y1+\" \"+x4+\" \"+y2+\" \"+x3+\" \"+y3+\" \"+x2+\" \"+y4);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"? \"+x1+\" \"+y3+\" \"+x2+\" \"+y2);\n\t\tans1 = nextInt();\n\t\tSystem.out.println(\"? \"+x3+\" \"+y1+\" \"+x4+\" \"+y4);\n\t\tans2 = nextInt();\n\t\tif (ans1==1 && ans2==1) {\n\t\t\tSystem.out.println(\"! \"+x1+\" \"+y3+\" \"+x2+\" \"+y2+\" \"+x3+\" \"+y1+\" \"+x4+\" \"+y4);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tpw.close();\n\t}\n\tprivate static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tprivate static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tprivate static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tprivate static String next() throws IOException {\n\t\twhile (st==null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n}", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "//package codeforces.cfr296div2;\n\nimport java.util.Scanner;\n\n/**\n * Created by bistrashkin on 3/17/15.\n */\npublic class B {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt(); in.nextLine();\n        String s = in.nextLine();\n        String t = in.nextLine();\n\n        int[][] notMatchingPair = new int[255][255];\n        int[] notMatchingS = new int[255];\n        int notMatchingC = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) != t.charAt(i)) {\n                notMatchingPair[s.charAt(i)][t.charAt(i)] = 1 + i;\n                notMatchingS[s.charAt(i)] = 1 + i;\n                notMatchingC++;\n            }\n        }\n\n        for (char i1 = 'a'; i1 <= 'z'; i1++) {\n            for (char i2 = 'a'; i2 <= 'z'; i2++) {\n                if (notMatchingPair[i1][i2] > 0 && notMatchingPair[i2][i1] > 0) {\n                    System.out.println(notMatchingC - 2);\n                    System.out.println(String.format(\"%d %d\", notMatchingPair[i1][i2], notMatchingPair[i2][i1]));\n                    return;\n                }\n            }\n        }\n\n        for (char i1 = 'a'; i1 <= 'z'; i1++) {\n            for (char i2 = 'a'; i2 <= 'z'; i2++) {\n                if (notMatchingPair[i1][i2] > 0 && notMatchingS[i2] > 0) {\n                    System.out.println(notMatchingC - 1);\n                    System.out.println(String.format(\"%d %d\", notMatchingPair[i1][i2], notMatchingS[i2]));\n                    return;\n                }\n            }\n        }\n\n        System.out.println(notMatchingC);\n        System.out.println(\"-1 -1\");\n    }\n}\n", "complexity": "linear", "problem": "0527_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class TaskA\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tnew TaskA(System.in, System.out);\n\t}\n\n\tstatic class Solver implements Runnable\n\t{\n\t\tint n;\n\t\tString[] last, curr;\n\t\tBufferedReader in;\n\t\tPrintWriter out;\n\n\t\tvoid solve() throws IOException\n\t\t{\n\t\t\tn = Integer.parseInt(in.readLine());\n\t\t\tlast = new String[n];\n\t\t\tcurr = new String[n];\n\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tlast[i] = in.readLine();\n\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tcurr[i] = in.readLine();\n\n\t\t\tint changes = 0;\n\t\t\tString[] sizes = new String[]{\"S\", \"M\", \"L\", \"XS\", \"XXS\", \"XXXS\", \"XL\", \"XXL\", \"XXXL\"};\n\t\t\tint[] old = count(last, sizes);\n\t\t\tint[] now = count(curr, sizes);\n\n\t\t\tfor (int i= 0; i < sizes.length; i++)\n\t\t\t{\n\t\t\t\tchanges += Math.abs(old[i] - now[i]);\n\t\t\t}\n\n\t\t\tout.println(changes / 2);\n\n/*\t\t\tif (now[0] > old[0])\n\t\t\t{\n\t\t\t\tint add = now[0] - old[0];\n\n\t\t\t\tchanges += add;\n\n\n\t\t\t}*/\n\t\t}\n\n\t\tint[] count(String[] s, String[] sizes)\n\t\t{\n\t\t\tint len = sizes.length;\n\t\t\tint[] cnt = new int[len];\n\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tfor (String str : s)\n\t\t\t\t{\n\t\t\t\t\tif (str.equals(sizes[i]))\n\t\t\t\t\t\tcnt[i]++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn cnt;\n\t\t}\n\n\t\tvoid debug(Object... o)\n\t\t{\n\t\t\tSystem.err.println(Arrays.deepToString(o));\n\t\t}\n\n\t\tpublic Solver(BufferedReader in, PrintWriter out)\n\t\t{\n\t\t\tthis.in = in;\n\t\t\tthis.out = out;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsolve();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class CMath\n\t{\n\t\tstatic long power(long number, long power)\n\t\t{\n\t\t\tif (number == 1 || number == 0 || power == 0)\n\t\t\t\treturn 1;\n\n\t\t\tif (power == 1)\n\t\t\t\treturn number;\n\n\t\t\tif (power % 2 == 0)\n\t\t\t\treturn power(number * number, power / 2);\n\t\t\telse\n\t\t\t\treturn power(number * number, power / 2) * number;\n\t\t}\n\n\t\tstatic long modPower(long number, long power, long mod)\n\t\t{\n\t\t\tif (number == 1 || number == 0 || power == 0)\n\t\t\t\treturn 1;\n\n\t\t\tnumber = mod(number, mod);\n\n\t\t\tif (power == 1)\n\t\t\t\treturn number;\n\n\t\t\tlong square = mod(number * number, mod);\n\n\t\t\tif (power % 2 == 0)\n\t\t\t\treturn modPower(square, power / 2, mod);\n\t\t\telse\n\t\t\t\treturn mod(modPower(square, power / 2, mod) * number, mod);\n\t\t}\n\n\t\tstatic long moduloInverse(long number, long mod)\n\t\t{\n\t\t\treturn modPower(number, mod - 2, mod);\n\t\t}\n\n\t\tstatic long mod(long number, long mod)\n\t\t{\n\t\t\treturn number - (number / mod) * mod;\n\t\t}\n\n\t\tstatic int gcd(int a, int b)\n\t\t{\n\t\t\tif (b == 0)\n\t\t\t\treturn a;\n\t\t\telse\n\t\t\t\treturn gcd(b, a % b);\n\t\t}\n\n\t\tstatic long min(long... arr)\n\t\t{\n\t\t\tlong min = arr[0];\n\n\t\t\tfor (int i = 1; i < arr.length; i++)\n\t\t\t\tmin = Math.min(min, arr[i]);\n\n\t\t\treturn min;\n\t\t}\n\n\t\tstatic long max(long... arr)\n\t\t{\n\t\t\tlong max = arr[0];\n\n\t\t\tfor (int i = 1; i < arr.length; i++)\n\t\t\t\tmax = Math.max(max, arr[i]);\n\n\t\t\treturn max;\n\t\t}\n\n\t\tstatic int min(int... arr)\n\t\t{\n\t\t\tint min = arr[0];\n\n\t\t\tfor (int i = 1; i < arr.length; i++)\n\t\t\t\tmin = Math.min(min, arr[i]);\n\n\t\t\treturn min;\n\t\t}\n\n\t\tstatic int max(int... arr)\n\t\t{\n\t\t\tint max = arr[0];\n\n\t\t\tfor (int i = 1; i < arr.length; i++)\n\t\t\t\tmax = Math.max(max, arr[i]);\n\n\t\t\treturn max;\n\t\t}\n\n\t}\n\n\tstatic class Utils\n\t{\n\t\tstatic boolean nextPermutation(int[] arr)\n\t\t{\n\t\t\tfor (int a = arr.length - 2; a >= 0; --a)\n\t\t\t{\n\t\t\t\tif (arr[a] < arr[a + 1])\n\t\t\t\t{\n\t\t\t\t\tfor (int b = arr.length - 1; ; --b)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (arr[b] > arr[a])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint t = arr[a];\n\n\t\t\t\t\t\t\tarr[a] = arr[b];\n\t\t\t\t\t\t\tarr[b] = t;\n\n\t\t\t\t\t\t\tfor (++a, b = arr.length - 1; a < b; ++a, --b)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt = arr[a];\n\t\t\t\t\t\t\t\tarr[a] = arr[b];\n\t\t\t\t\t\t\t\tarr[b] = t;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\tpublic TaskA(InputStream inputStream, OutputStream outputStream)\n\t{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(inputStream));\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tThread thread = new Thread(null, new Solver(in, out), \"TaskA\", 1 << 29);\n\n\t\ttry\n\t\t{\n\t\t\tthread.start();\n\t\t\tthread.join();\n\t\t}\n\t\tcatch (InterruptedException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t}\n\t}\n\n}\n", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EPhoenixAndComputers solver = new EPhoenixAndComputers();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EPhoenixAndComputers {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int mod = in.ri();\n            CachedPow2 cp = new CachedPow2(2, mod, n + 1, mod - 1);\n            Combination comb = new Combination(n + 1, mod);\n            long[][][] dp = new long[n + 1][n + 1][2];\n            dp[0][0][0] = 1;\n            for (int i = 1; i <= n; i++) {\n                for (int j = 0; j <= n; j++) {\n                    dp[i][j][0] = dp[i - 1][j][1];\n                    for (int k = 0; k < i; k++) {\n                        int len = i - k;\n                        int last = j - len;\n                        if (last >= 0) {\n                            dp[i][j][1] += dp[k][last][0] * cp.pow(len - 1) % mod * comb.combination(j, len) % mod;\n                        }\n                    }\n                    dp[i][j][1] %= mod;\n                }\n            }\n\n            long ans = 0;\n            for (int i = 0; i <= n; i++) {\n                ans += dp[n][i][1];\n            }\n\n            ans %= mod;\n            out.println(ans);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\\n');\n        }\n\n        public FastOutput flush() {\n            try {\n//            boolean success = false;\n//            if (stringBuilderValueField != null) {\n//                try {\n//                    char[] value = (char[]) stringBuilderValueField.get(cache);\n//                    os.write(value, 0, cache.length());\n//                    success = true;\n//                } catch (Exception e) {\n//                }\n//            }\n//            if (!success) {\n                os.append(cache);\n//            }\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static interface IntegerEntryIterator {\n        boolean hasNext();\n\n        void next();\n\n        int getEntryKey();\n\n        int getEntryValue();\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n\n            return rev ? val : -val;\n        }\n\n    }\n\n    static class Hasher {\n        private long time = System.nanoTime() + System.currentTimeMillis() * 31L;\n\n        public int shuffle(long z) {\n            z += time;\n            z = (z ^ (z >>> 33)) * 0x62a9d9ed799705f5L;\n            return (int) (((z ^ (z >>> 28)) * 0xcb24d0a5c88c35b3L) >>> 32);\n        }\n\n        public int hash(int x) {\n            return shuffle(x);\n        }\n\n    }\n\n    static class CachedEulerFunction {\n        private static int boundary = 1 << 16;\n        private static int[] euler = MultiplicativeFunctionSieve.getInstance(boundary).getEuler();\n        private static IntegerHashMap map = new IntegerHashMap(64, true);\n\n        public static int get(int x) {\n            return get(x, 2);\n        }\n\n        private static int get(int x, int begin) {\n            if (x <= boundary) {\n                return euler[x];\n            }\n            int ans = map.getOrDefault(x, -1);\n            if (ans == -1) {\n                int factor = findPrimeFactor(x, begin);\n                int y = x;\n                int exp = 1;\n                while (y % factor == 0) {\n                    y /= factor;\n                    exp *= factor;\n                }\n                ans = get(y, factor + 1) * (exp - exp / factor);\n                //ans = calc(x);\n                map.put(x, ans);\n            }\n            return ans;\n        }\n\n        private static int findPrimeFactor(int x, int begin) {\n            for (int i = Math.max(2, begin); i * i <= x; i++) {\n                if (x % i == 0) {\n                    return i;\n                }\n            }\n            return x;\n        }\n\n    }\n\n    static interface IntCombination {\n    }\n\n    static class MultiplicativeFunctionSieve {\n        static MultiplicativeFunctionSieve instance = new MultiplicativeFunctionSieve(1 << 16);\n        public int[] primes;\n        public boolean[] isComp;\n        public int primeLength;\n        public int[] smallestPrimeFactor;\n        public int[] expOfSmallestPrimeFactor;\n        int limit;\n\n        public static MultiplicativeFunctionSieve getInstance(int n) {\n            if (n <= (1 << 16)) {\n                return instance;\n            }\n            return new MultiplicativeFunctionSieve(n);\n        }\n\n        public int[] getEuler() {\n            int[] euler = new int[limit + 1];\n            euler[1] = 1;\n            for (int i = 2; i <= limit; i++) {\n                if (!isComp[i]) {\n                    euler[i] = i - 1;\n                } else {\n                    if (expOfSmallestPrimeFactor[i] == i) {\n                        euler[i] = i - i / smallestPrimeFactor[i];\n                    } else {\n                        euler[i] = euler[expOfSmallestPrimeFactor[i]] * euler[i / expOfSmallestPrimeFactor[i]];\n                    }\n                }\n            }\n            return euler;\n        }\n\n        public MultiplicativeFunctionSieve(int limit) {\n            this.limit = limit;\n            isComp = new boolean[limit + 1];\n            primes = new int[limit + 1];\n            expOfSmallestPrimeFactor = new int[limit + 1];\n            smallestPrimeFactor = new int[limit + 1];\n            primeLength = 0;\n            for (int i = 2; i <= limit; i++) {\n                if (!isComp[i]) {\n                    primes[primeLength++] = i;\n                    expOfSmallestPrimeFactor[i] = smallestPrimeFactor[i] = i;\n                }\n                for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                    int pi = primes[j] * i;\n                    smallestPrimeFactor[pi] = primes[j];\n                    expOfSmallestPrimeFactor[pi] = smallestPrimeFactor[i] == primes[j]\n                            ? (expOfSmallestPrimeFactor[i] * expOfSmallestPrimeFactor[primes[j]])\n                            : expOfSmallestPrimeFactor[primes[j]];\n                    isComp[pi] = true;\n                    if (i % primes[j] == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n    }\n\n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        int mod;\n\n        public int getMod() {\n            return mod;\n        }\n\n        public Factorial(int[] fact, int[] inv, int mod) {\n            this.mod = mod;\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            int n = Math.min(fact.length, mod);\n            for (int i = 1; i < n; i++) {\n                fact[i] = i;\n                fact[i] = (int) ((long) fact[i] * fact[i - 1] % mod);\n            }\n            if (n - 1 >= 0) {\n                inv[n - 1] = BigInteger.valueOf(fact[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();\n            }\n            for (int i = n - 2; i >= 1; i--) {\n                inv[i] = (int) ((long) inv[i + 1] * (i + 1) % mod);\n            }\n        }\n\n        public Factorial(int limit, int mod) {\n            this(new int[Math.min(limit + 1, mod)], new int[Math.min(limit + 1, mod)], mod);\n        }\n\n        public int fact(int n) {\n            if (n >= mod) {\n                return 0;\n            }\n            return fact[n];\n        }\n\n        public int invFact(int n) {\n            if (n >= mod) {\n                throw new IllegalArgumentException();\n            }\n            return inv[n];\n        }\n\n    }\n\n    static class CachedPow2 {\n        private int[] first;\n        private int[] second;\n        private int mod;\n        private int low;\n        private int mask;\n        private int phi;\n        private int xphi;\n\n        public CachedPow2(int x, int mod) {\n            this(x, mod, CachedEulerFunction.get(mod));\n        }\n\n        public CachedPow2(int x, int mod, int phi) {\n            this(x, mod, mod, phi);\n        }\n\n        public CachedPow2(int x, int mod, int limit, int phi) {\n            this.phi = phi;\n            limit = Math.min(limit, mod);\n            this.mod = mod;\n            int log = Log2.ceilLog(limit + 1);\n            low = (log + 1) / 2;\n            mask = (1 << low) - 1;\n            first = new int[1 << low];\n            second = new int[1 << log - low];\n            first[0] = 1;\n            for (int i = 1; i < first.length; i++) {\n                first[i] = (int) ((long) x * first[i - 1] % mod);\n            }\n            second[0] = 1;\n            long step = (long) x * first[first.length - 1] % mod;\n            for (int i = 1; i < second.length; i++) {\n                second[i] = (int) (second[i - 1] * step % mod);\n            }\n\n            xphi = DigitUtils.modPow(x, phi, mod);\n        }\n\n        public int pow(int exp) {\n            return (int) ((long) first[exp & mask] * second[exp >> low] % mod);\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int mod(long x, int mod) {\n            if (x < -mod || x >= mod) {\n                x %= mod;\n            }\n            if (x < 0) {\n                x += mod;\n            }\n            return (int) x;\n        }\n\n        public static int mod(int x, int mod) {\n            if (x < -mod || x >= mod) {\n                x %= mod;\n            }\n            if (x < 0) {\n                x += mod;\n            }\n            return x;\n        }\n\n        public static int modPow(int x, long n, int m) {\n            if (n == 0) {\n                return DigitUtils.mod(1, m);\n            }\n            int ans = modPow(x, n / 2, m);\n            ans = DigitUtils.mod((long) ans * ans, m);\n            if (n % 2 == 1) {\n                ans = DigitUtils.mod((long) ans * x, m);\n            }\n            return ans;\n        }\n\n    }\n\n    static class Combination implements IntCombination {\n        final Factorial factorial;\n        int modVal;\n\n        public Combination(Factorial factorial) {\n            this.factorial = factorial;\n            this.modVal = factorial.getMod();\n        }\n\n        public Combination(int limit, int mod) {\n            this(new Factorial(limit, mod));\n        }\n\n        public int combination(int m, int n) {\n            if (n > m || n < 0) {\n                return 0;\n            }\n            return (int) ((long) factorial.fact(m) * factorial.invFact(n) % modVal * factorial.invFact(m - n) % modVal);\n        }\n\n    }\n\n    static class Log2 {\n        public static int ceilLog(int x) {\n            if (x <= 0) {\n                return 0;\n            }\n            return 32 - Integer.numberOfLeadingZeros(x - 1);\n        }\n\n    }\n\n    static class IntegerHashMap {\n        private int now;\n        private int[] slot;\n        private int[] version;\n        private int[] next;\n        private int[] keys;\n        private int[] values;\n        private int alloc;\n        private boolean[] removed;\n        private int mask;\n        private int size;\n        private boolean rehash;\n        private Hasher hasher = new Hasher();\n\n        public IntegerHashMap(int cap, boolean rehash) {\n            now = 1;\n            this.mask = (1 << (32 - Integer.numberOfLeadingZeros(cap - 1))) - 1;\n            slot = new int[mask + 1];\n            version = new int[slot.length];\n            next = new int[cap + 1];\n            keys = new int[cap + 1];\n            values = new int[cap + 1];\n            removed = new boolean[cap + 1];\n            this.rehash = rehash;\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            keys = Arrays.copyOf(keys, newSize);\n            values = Arrays.copyOf(values, newSize);\n            removed = Arrays.copyOf(removed, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n            removed[alloc] = false;\n            size++;\n        }\n\n        private void rehash() {\n            int[] newSlots = new int[Math.max(16, slot.length * 2)];\n            int[] newVersions = new int[newSlots.length];\n            int newMask = newSlots.length - 1;\n            for (int i = 0; i < slot.length; i++) {\n                access(i);\n                if (slot[i] == 0) {\n                    continue;\n                }\n                int head = slot[i];\n                while (head != 0) {\n                    int n = next[head];\n                    int s = hash(keys[head]) & newMask;\n                    next[head] = newSlots[s];\n                    newSlots[s] = head;\n                    head = n;\n                }\n            }\n            this.slot = newSlots;\n            this.version = newVersions;\n            now = 0;\n            this.mask = newMask;\n        }\n\n        private int hash(int x) {\n            return hasher.hash(x);\n        }\n\n        public void put(int x, int y) {\n            put(x, y, true);\n        }\n\n        public void put(int x, int y, boolean cover) {\n            int h = hash(x);\n            int s = h & mask;\n            access(s);\n            if (slot[s] == 0) {\n                alloc();\n                slot[s] = alloc;\n                keys[alloc] = x;\n                values[alloc] = y;\n            } else {\n                int index = findIndexOrLastEntry(s, x);\n                if (keys[index] != x) {\n                    alloc();\n                    next[index] = alloc;\n                    keys[alloc] = x;\n                    values[alloc] = y;\n                } else if (cover) {\n                    values[index] = y;\n                }\n            }\n            if (rehash && size >= slot.length) {\n                rehash();\n            }\n        }\n\n        public int getOrDefault(int x, int def) {\n            int h = hash(x);\n            int s = h & mask;\n            access(s);\n            if (slot[s] == 0) {\n                return def;\n            }\n            int index = findIndexOrLastEntry(s, x);\n            return keys[index] == x ? values[index] : def;\n        }\n\n        private int findIndexOrLastEntry(int s, int x) {\n            int iter = slot[s];\n            while (keys[iter] != x) {\n                if (next[iter] != 0) {\n                    iter = next[iter];\n                } else {\n                    return iter;\n                }\n            }\n            return iter;\n        }\n\n        private void access(int i) {\n            if (version[i] != now) {\n                version[i] = now;\n                slot[i] = 0;\n            }\n        }\n\n        public IntegerEntryIterator iterator() {\n            return new IntegerEntryIterator() {\n                int index = 1;\n                int readIndex = -1;\n\n\n                public boolean hasNext() {\n                    while (index <= alloc && removed[index]) {\n                        index++;\n                    }\n                    return index <= alloc;\n                }\n\n\n                public int getEntryKey() {\n                    return keys[readIndex];\n                }\n\n\n                public int getEntryValue() {\n                    return values[readIndex];\n                }\n\n\n                public void next() {\n                    if (!hasNext()) {\n                        throw new IllegalStateException();\n                    }\n                    readIndex = index;\n                    index++;\n                }\n            };\n        }\n\n        public String toString() {\n            IntegerEntryIterator iterator = iterator();\n            StringBuilder builder = new StringBuilder(\"{\");\n            while (iterator.hasNext()) {\n                iterator.next();\n                builder.append(iterator.getEntryKey()).append(\"->\").append(iterator.getEntryValue()).append(',');\n            }\n            if (builder.charAt(builder.length() - 1) == ',') {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append('}');\n            return builder.toString();\n        }\n\n    }\n}\n\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.FileNotFoundException;\n\nimport java.io.FileReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.util.*;\n\n\n\npublic class Solution implements Runnable {\n\n  BufferedReader in;\n\n  PrintWriter out;\n\n  StringTokenizer tok = new StringTokenizer(\"\");\n\n\n\n  @Override\n\n  public void run() {\n\n    try {\n\n      init();\n\n    } catch (FileNotFoundException e) {\n\n      e.printStackTrace();\n\n    }\n\n    long time = System.currentTimeMillis();\n\n    try {\n\n      solve();\n\n    } catch (Exception e) {\n\n      e.printStackTrace();\n\n    }\n\n    out.close();\n\n    //System.err.println(System.currentTimeMillis() - time);\n\n  }\n\n\n\n  private void init() throws FileNotFoundException {\n\n    String file = \"123\";\n\n    if (!file.equals(\"\")) {\n\n      in = new BufferedReader(new FileReader(\"input.txt\"));\n\n      out = new PrintWriter(\"output.txt\");\n\n    } else {\n\n      in = new BufferedReader(new InputStreamReader(System.in));\n\n      out = new PrintWriter(System.out);\n\n    }\n\n  }\n\n\n\n  public static void main(String[] args) {\n\n    new Thread(new Solution()).start();\n\n  }\n\n\n\n  private String readString() {\n\n    while (!tok.hasMoreTokens()) {\n\n      try {\n\n        tok = new StringTokenizer(in.readLine());\n\n      } catch (IOException e) {\n\n        e.printStackTrace();\n\n      }\n\n    }\n\n    return tok.nextToken();\n\n  }\n\n\n\n  private int readInt() {\n\n    return Integer.parseInt(readString());\n\n  }\n\n\n\n  int[] counts = new int[1000];\n\n\n\n  private long readLong() {\n\n    return Long.parseLong(readString());\n\n  }\n\n\n\n  private void solve() {\n\n    int n = readInt()+2;\n\n    int m = readInt()+2;\n\n    boolean[][] graph = new boolean[n][m];\n\n    for (int i = 0; i < n; i++) {\n\n      graph[i][m-1] = true;\n\n      graph[i][0] = true;\n\n    }\n\n    for (int i = 0; i < m; i++) {\n\n      graph[n-1][i] = true;\n\n      graph[0][i] = true;\n\n    }\n\n    int k = readInt();\n\n    int inFire = 0;\n\n    Queue<Point> q = new ArrayDeque<>();\n\n    for (int i = 0; i < k; i++) {\n\n      int x = readInt();\n\n      int y = readInt();\n\n      Point p = new Point(x, y);\n\n      graph[x][y] = true;\n\n      q.add(p);\n\n    }\n\n    while (!q.isEmpty()) {\n\n      Point current = q.poll();\n\n      inFire++;\n\n      if(!graph[current.x+1][current.y]) {\n\n        graph[current.x+1][current.y] = true;\n\n        q.add(new Point(current.x+1, current.y));\n\n      }\n\n      if(!graph[current.x-1][current.y]) {\n\n        graph[current.x-1][current.y] = true;\n\n        q.add(new Point(current.x-1, current.y));\n\n      }\n\n      if(!graph[current.x][current.y+1]) {\n\n        graph[current.x][current.y+1] = true;\n\n        q.add(new Point(current.x, current.y+1));\n\n      }\n\n      if(!graph[current.x][current.y-1]) {\n\n        graph[current.x][current.y-1] = true;\n\n        q.add(new Point(current.x, current.y-1));\n\n      }\n\n      if(q.isEmpty()) {\n\n        out.print(current.x+\" \"+current.y);\n\n        return;\n\n      }\n\n    }\n\n\n\n\n\n  }\n\n\n\n  class Point{\n\n    int x, y;\n\n\n\n    public Point(int x, int y) {\n\n      this.x = x;\n\n      this.y = y;\n\n    }\n\n  }\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Asgar Javadov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int[] a = in.readIntArray(n);\n\n            ArrayUtils.radixSort(a);\n\n            int answer = 0;\n            boolean[] used = new boolean[a.length];\n            for (int i = 0; i < a.length; ++i) {\n                if (used[i]) continue;\n\n                used[i] = true;\n                answer++;\n                for (int j = i + 1; j < a.length; ++j)\n                    if (a[j] % a[i] == 0)\n                        used[j] = true;\n            }\n\n            out.println(answer);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void radixSort(int[] array) {\n            int[] ordered = new int[array.length];\n            {\n                int[] freq = new int[0xFFFF + 2];\n                for (int i = 0; i < array.length; ++i) freq[(array[i] & 0xFFFF) + 1]++;\n                for (int i = 1; i < freq.length; ++i) freq[i] += freq[i - 1];\n\n                for (int i = 0; i < array.length; ++i)\n                    ordered[freq[array[i] & 0xFFFF]++] = array[i];\n                for (int i = 0; i < array.length; ++i)\n                    array[i] = ordered[i];\n            }\n            {\n                int[] freq = new int[0xFFFF + 2];\n                for (int i = 0; i < array.length; ++i) freq[(array[i] >>> 16) + 1]++;\n                for (int i = 1; i < freq.length; ++i) freq[i] += freq[i - 1];\n\n                for (int i = 0; i < array.length; ++i)\n                    ordered[freq[array[i] >>> 16]++] = array[i];\n\n                int indexOfFirstNegative = freq[0x7FFF];\n                int index = 0;\n                for (int i = indexOfFirstNegative; i < ordered.length; ++i, ++index)\n                    array[index] = ordered[i];\n                for (int i = 0; i < indexOfFirstNegative; ++i, ++index)\n                    array[index] = ordered[i];\n            }\n        }\n\n    }\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n\n    }\n\n    static class InputReader extends BufferedReader {\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream inputStream) {\n            super(new InputStreamReader(inputStream), 32768);\n        }\n\n        public InputReader(String filename) {\n            super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public Integer nextInt() {\n            return Integer.valueOf(next());\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++)\n                array[i] = nextInt();\n            return array;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class R2_D2_A {\n    public static void main(String[] args) {\n        // BufferedReader in = new BufferedReader(new\n        // InputStreamReader(System.in));\n        InputReader in = new InputReader(System.in);\n        int n = in.readInt();\n        int a = in.readInt();\n        int b = in.readInt();\n        Integer[] inp = new Integer[n];\n        for (int i = 0; i < inp.length; i++) {\n            inp[i] = in.readInt();\n        }\n        Arrays.sort(inp);\n        int petya = inp[inp.length-a];\n        int next = inp[inp.length-a-1];\n        int diff = petya - next;\n        System.out.println(diff);\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1000];\n        private int curChar, numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private String readLine0() {\n            StringBuffer buf = new StringBuffer();\n            int c = read();\n            while (c != '\\n' && c != -1) {\n                buf.appendCodePoint(c);\n                c = read();\n            }\n            return buf.toString();\n        }\n\n        public String readLine() {\n            String s = readLine0();\n            while (s.trim().length() == 0)\n                s = readLine0();\n            return s;\n        }\n\n        public String readLine(boolean ignoreEmptyLines) {\n            if (ignoreEmptyLines)\n                return readLine();\n            else\n                return readLine0();\n        }\n\n        public char readCharacter() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            return (char) c;\n        }\n\n        public double readDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, readInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, readInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n    }\n\n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class A\n{\n    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st = null;\n\n    private void solve() throws IOException\n    {\n        int n = nextInt();\n        int k = nextInt();\n        int p[] = new int[n];\n        int t[] = new int[n];\n        for(int i = 0; i < n; i++)\n        {\n            p[i] = nextInt();\n            t[i] = nextInt();\n        }\n        \n        for(int i = 0; i < n; i++)\n        {\n            for(int j = i + 1; j < n; j++)\n            {\n                if(p[i] < p[j] || (p[i] == p[j] && t[i] > t[j]))\n                {\n                    int tmp = p[i];\n                    p[i] = p[j];\n                    p[j] = tmp;\n                    tmp = t[i];\n                    t[i] = t[j];\n                    t[j] = tmp;\n                }\n            }\n            \n        }\n        \n        int pN = p[k - 1];\n        int tN = t[k - 1];\n        int counter = 0;\n        for(int i = 0; i < n; i++)\n        {\n            if(p[i] == pN && t[i] == tN)\n            {\n                counter++;\n            }\n            \n        }\n        \n        System.out.println(counter);\n    }\n\n    String nextToken() throws IOException\n    {\n        if (st == null || !st.hasMoreTokens())\n        {\n            st = new StringTokenizer(bf.readLine());\n        }\n        \n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException\n    {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException\n    {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException\n    {\n        return Double.parseDouble(nextToken());\n    }\n\n    public static void main(String args[]) throws IOException\n    {\n        new A().solve();\n    }\n    \n}", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "//package contests.CF495;\n\nimport java.io.*;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class A {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = sc.nextInt();\n        }\n\n        HashSet<Integer> set = new HashSet<>();\n        for (int i = 0; i < arr.length; i++) {\n            set.add(arr[i]+d);\n            set.add(arr[i]-d);\n        }\n\n        int cnt = 0;\n        for (int loc: set) {\n            int minDist = (int)2e9;\n            for (int i = 0; i < n; i++) {\n                minDist = Math.min(minDist, Math.abs(arr[i]-loc));\n            }\n\n            if(minDist == d)\n                cnt++;\n        }\n\n        pw.println(cnt);\n\n        pw.flush();\n        pw.close();\n    }\n\n\n\n    static int[][] packD(int n, int[] from, int[] to) {\n        int[][] g = new int[n][];\n        int[] p = new int[n];\n        for (int f : from) if(f != -1) p[f]++;\n        for (int i = 0; i < n; i++) g[i] = new int[p[i]];\n        for (int i = 0; i < from.length; i++) if(from[i] != -1) {g[from[i]][--p[from[i]]] = to[i];}\n        return g;\n    }\n\n    static void shuffle(int[] a)\n    {\n        int n = a.length;\n        for(int i = 0; i < n; i++)\n        {\n            int r = i + (int)(Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n    static class Scanner\n    {\n        StringTokenizer st; BufferedReader br;\n        public Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n        public Scanner(String s) throws FileNotFoundException {\tbr = new BufferedReader(new FileReader(new File(s)));}\n        public String next() throws IOException {while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());return st.nextToken();}\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n        public long nextLong() throws IOException {return Long.parseLong(next());}\n        public String nextLine() throws IOException {return br.readLine();}\n        public boolean ready() throws IOException {return br.ready();}\n    }\n}\n", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author Sagimbekov_MA\n */\npublic class A483 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        BigInteger l = sc.nextBigInteger();\n        BigInteger r = sc.nextBigInteger();\n        \n        if (r.subtract(l).compareTo(new BigInteger(\"2\")) == -1) {\n            System.out.println(\"-1\");\n        } else if (r.subtract(l).compareTo(new BigInteger(\"2\")) == 0 && l.mod(new BigInteger(\"2\")) != BigInteger.ZERO) {\n            System.out.println(\"-1\");\n        } else if (l.mod(new BigInteger(\"2\")) != BigInteger.ZERO) {\n            System.out.println(l.add(BigInteger.ONE) + \" \" + l.add(BigInteger.ONE).add(BigInteger.ONE) + \" \" + l.add(BigInteger.ONE).add(BigInteger.ONE).add(BigInteger.ONE));\n        } else {\n            System.out.println(l + \" \" + l.add(BigInteger.ONE) + \" \" + l.add(BigInteger.ONE).add(BigInteger.ONE));\n        }\n    }\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Round111A {\n\n    public static void main(String[] args) throws IOException {\n        new Round111A().run();\n    }\n\n    public void run() throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        Scanner scanner = new Scanner(reader);\n        PrintWriter writer = new PrintWriter(System.out);\n\n        int n = scanner.nextInt();\n        int sum = 0;\n        Integer[] a = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n            sum += a[i];\n        }\n        Arrays.sort(a, Collections.reverseOrder());\n\n        int s = 0;\n        int i = 0;\n        while (i < n && (s <= sum / 2)) {\n            s += a[i];\n            i++;\n        }\n\n        writer.print(i);\n\n        scanner.close();\n        writer.close();\n    }\n}\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "\n\nimport java.util.Scanner;\n\npublic class B {\n    static int n;\n    static double A;\n    static int[] L;\n    static int[] B;\n    static double max = 0;\n\n    public static void rec(int index, int k) {\n        if (k < 0)\n            return;\n        if (index == n) {\n            double prob = 0;\n            for (int i = 0; i < (1 << n); i++) {\n                double b = 0;\n                double temp = 1.0;\n                for (int j = 0; j < n; j++) {\n                    if (L[j] > 100)\n                        return;\n                    if ((i & (1 << j)) == 0) {\n                        b += B[j];\n                        temp *= (100 - L[j]) / 100.0;\n                    } else\n                        temp *= L[j] / 100.0;\n                }\n                if (Integer.bitCount(i) * 2 <= n)\n                    temp *= A / (A + b);\n                prob += temp;\n\n            }\n            max = Math.max(max, prob);\n            return;\n        }\n        L[index] += 10;\n        rec(index, k - 1);\n        L[index] -= 10;\n        rec(index + 1, k);\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        int k = in.nextInt();\n        A = in.nextDouble();\n        B = new int[n];\n        L = new int[n];\n        for (int i = 0; i < n; i++) {\n            B[i] = in.nextInt();\n            L[i] = in.nextInt();\n        }\n        rec(0, k);\n        System.out.println(max);\n    }\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/**\n * Created by Daniil on 5/29/2016.\n */\npublic class TaskB {\n\n\n    public static int strIndex;\n    public static void main(String[] args) throws IOException {\n\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n\n        char[] s = scanner.next().toCharArray();\n\n        int[][] r = new int[n][54];\n\n        Set<Character> chars = new HashSet<>();\n\n        for (int i= 0 ;i < n; ++ i)chars.add(s[i]);\n\n        List<Character> all = new ArrayList<>();\n\n        for (Character c: chars)all.add(c);\n\n        for (int i = n - 1; i >= 0; -- i){\n            for (int j = 0;j < 54; ++ j){\n                if (i == n - 1){\n                    r[i][j] = -1;\n                }else {\n                    r[i][j] = r[i + 1][j];\n                }\n            }\n            r[i][getCode(s[i])] = i;\n        }\n\n        int res = n;\n\n\n        for (int i =0; i < n; ++ i){\n            int mx = 1;\n            boolean fl = false;\n            for (Character c: all){\n                if (r[i][getCode(c)] == -1){\n                    fl = true;\n                    break;\n                }\n                mx = Math.max(mx, r[i][getCode(c)] - i + 1);\n            }\n            if (fl){\n                System.out.println(res);\n                return;\n            }\n            res = Math.min(res, mx);\n        }\n        System.out.println(res);\n\n        scanner.close();\n        //reader.close();\n    }\n\n    public static int getCode(char a){\n        if (Character.isUpperCase(a))return a - 'A';\n        return (a - 'a') + 26;\n    }\n\n    public static int getLetter(int n){\n        if (n > 25)return (char)((n - 26) + 'a');\n        return (char)((n) + 'A');\n    }\n\n\n\n    static class IO{\n\n\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n        PrintWriter writer;\n\n        public void init() {\n            try {\n                reader = new BufferedReader(new InputStreamReader(System.in),8*1024);\n                writer = new PrintWriter(System.out);\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(261);\n            }\n        }\n\n        void destroy() {\n            writer.close();\n            System.exit(0);\n        }\n\n        void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        String nextLine() throws IOException {\n            return reader.readLine();\n        }\n\n        String nextToken() throws IOException {\n            while (tokenizer == null || !tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(nextLine());\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() throws NumberFormatException, IOException {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n\n}\n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import com.sun.java_cup.internal.runtime.virtual_parse_stack;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Created by ali on 2/3/14.\n */\npublic class D\n{\n\tpublic static void main(String [] args)\n\t{\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\n\t\tboolean [][] graph = new boolean[n][n];\n\t\tfor(int i = 0 ; i < m ; i++)\n\t\t{\n\t\t\tint a = in.nextInt() - 1;\n\t\t\tint b = in.nextInt() - 1;\n\n\t\t\tgraph[a][b] = true;\n\t\t}\n\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor(int center = 0 ; center < n ; center++)\n\t\t{\n\t\t\tint calc = 0;\n\t\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\t{\n\t\t\t\tif(!graph[center][i])\n\t\t\t\t\tcalc++;\n\t\t\t\tif(!graph[i][center])\n\t\t\t\t\tcalc++;\n\t\t\t}\n\n\t\t\tif(!graph[center][center])\n\t\t\t\tcalc--;\n\n\t\t\tint [] match = new int[n];\n\t\t\tArrays.fill(match, -1);\n\t\t\tint max = 0;\n\n\t\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\t\tif(i != center)\n\t\t\t\t\tif(can(i, graph, new boolean[n], center, match))\n\t\t\t\t\t\tmax++;\n\n\t\t\tint unusable = m - (2*n - 1 - calc) - max;\n\t\t\tcalc += unusable;\n\t\t\tcalc += (2*(n-1) - 2*max)/2;\n\n\t\t\tres = Math.min(res, calc);\n\t\t}\n\n\t\tSystem.out.println(res);\n\n\n\t}\n\n\tprivate static boolean can(int at, boolean[][] graph, boolean[] visited, int center, int [] match)\n\t{\n\t\tif(visited[at])\n\t\t\treturn false;\n\t\tvisited[at] = true;\n\n\t\tfor(int to = 0 ; to < graph.length ; to++)\n\t\t\tif(graph[at][to])\n\t\t\t\tif(to != center)\n\t\t\t\t\tif(match[to] == -1 || can(match[to], graph, visited, center, match))\n\t\t\t\t\t{\n\t\t\t\t\t\tmatch[to] = at;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\treturn false;\n\t}\n}\n", "complexity": "cubic", "problem": "0387_D", "from": "CODEFORCES", "tags": "graph matchings"}
{"src": "\n\nimport java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport static java.lang.Math.*;\n\n// Solution is at the bottom of code\n\npublic class _____A implements Runnable{\n\t\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tBufferedReader in;\n\tOutputWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\t\n\tpublic static void main(String[] args){\n\t\tnew Thread(null, new _____A(), \"\", 128 * (1L << 20)).start();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid init() throws FileNotFoundException{\n\t\tLocale.setDefault(Locale.US);\n\t\t\n\t\tif (ONLINE_JUDGE){\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new OutputWriter(System.out);\n\t\t}else{\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new OutputWriter(\"output.txt\");\n\t\t}\n\t}\n\t\n\t////////////////////////////////////////////////////////////////\n\t\n\tlong timeBegin, timeEnd;\n\n\tvoid time(){\n\t\ttimeEnd = System.currentTimeMillis();\n\t\tSystem.err.println(\"Time = \" + (timeEnd - timeBegin));\n\t}\n\t\n\tvoid debug(Object... objects){\n\t\tif (ONLINE_JUDGE){\n\t\t\tfor (Object o: objects){\n\t\t\t\tSystem.err.println(o.toString());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tpublic void run(){\n\t\ttry{\n\t\t\ttimeBegin = System.currentTimeMillis();\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\t\n\t\t\tinit();\n\t\t\tsolve();\n\t\t\t\n\t\t\tout.close();\n\t\t\ttime();\n\t\t}catch (Exception e){\n\t\t\te.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tString delim = \" \";\n\t\n\tString readString() throws IOException{\n\t\twhile(!tok.hasMoreTokens()){\n\t\t\ttry{\n\t\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t\t}catch (Exception e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn tok.nextToken(delim);\n\t}\n\t\n\tString readLine() throws IOException{\n\t\treturn in.readLine();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tfinal char NOT_A_SYMBOL = '\\0';\n\t\n\tchar readChar() throws IOException{\n\t\tint intValue = in.read();\n\t\t\n\t\tif (intValue == -1){\n\t\t\treturn NOT_A_SYMBOL;\n\t\t}\n\t\t\n\t\treturn (char) intValue;\n\t}\n\t\n\tchar[] readCharArray() throws IOException{\n\t\treturn readLine().toCharArray();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tint readInt() throws IOException{\n\t\treturn Integer.parseInt(readString());\n\t}\n\t\n\tint[] readIntArray(int size) throws IOException{\n\t\tint[] array = new int[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readInt();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tlong readLong() throws IOException{\n\t\treturn Long.parseLong(readString());\n\t}\n\t\n\tlong[] readLongArray(int size) throws IOException{\n\t\tlong[] array = new long[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readLong();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\n\tdouble readDouble() throws IOException{\n\t\treturn Double.parseDouble(readString());\n\t}\n\t\n\tdouble[] readDoubleArray(int size) throws IOException{\n\t\tdouble[] array = new double[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readDouble();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tPoint readPoint() throws IOException{\n\t\tint x = readInt();\n\t\tint y = readInt();\n\t\treturn new Point(x, y);\n\t}\n\t\n\tPoint[] readPointArray(int size) throws IOException{\n\t\tPoint[] array = new Point[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readPoint();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tList<Integer>[] readGraph(int vertexNumber, int edgeNumber)\n\tthrows IOException{\n\t\tList<Integer>[] graph = new List[vertexNumber];\n\t\t\n\t\tfor (int index = 0; index < vertexNumber; ++index){\n\t\t\tgraph[index] = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\twhile (edgeNumber-- > 0){\n\t\t\tint from = readInt() - 1;\n\t\t\tint to = readInt() - 1;\n\t\t\t\n\t\t\tgraph[from].add(to);\n\t\t\tgraph[to].add(from);\n\t\t}\n\t\t\n\t\treturn graph;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tclass OutputWriter extends PrintWriter{\n\n\t\tfinal int DEFAULT_PRECISION = 12;\n\t\t\n\t\tint precision;\n\t\tString format, formatWithSpace;\n\t\t\n\t\t{\n\t\t\tprecision = DEFAULT_PRECISION;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tpublic OutputWriter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\n\t\tpublic OutputWriter(String fileName) throws FileNotFoundException {\n\t\t\tsuper(fileName);\n\t\t}\n\t\t\n\t\tpublic int getPrecision() {\n\t\t\treturn precision;\n\t\t}\n\n\t\tpublic void setPrecision(int precision) {\n\t\t\tthis.precision = precision;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tprivate String createFormat(int precision){\n\t\t\treturn \"%.\" + precision + \"f\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void print(double d){\n\t\t\tprintf(format, d);\n\t\t}\n\t\t\n\t\tpublic void printWithSpace(double d){\n\t\t\tprintf(formatWithSpace, d);\n\t\t}\n\n\t\tpublic void printAll(double...d){\n\t\t\tfor (int i = 0; i < d.length - 1; ++i){\n\t\t\t\tprintWithSpace(d[i]);\n\t\t\t}\n\t\t\t\n\t\t\tprint(d[d.length - 1]);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void println(double d){\n\t\t\tprintlnAll(d);\n\t\t}\n\t\t\n\t\tpublic void printlnAll(double... d){\n\t\t\tprintAll(d);\n\t\t\tprintln();\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tint[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; \n\tint[][] steps8 = {\n\t\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1},\n\t\t\t{-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n\t};\n\t\n\tboolean check(int index, int lim){\n\t\treturn (0 <= index && index < lim);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tboolean checkBit(int mask, int bitNumber){\n\t\treturn (mask & (1 << bitNumber)) != 0;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tlong md = (1000 * 1000 * 1000 + 9);\n\t\n\tvoid solve() throws IOException{\n\t\tint n = readInt();\n\t\tint m = readInt();\n\t\tint k = readInt();\n\t\t\n\t\tlong count = n / k;\n\t\tlong mod = n % k;\n\t\t\n\t\tlong maxM = count * (k - 1) + mod;\n\t\tif (maxM >= m) {\n\t\t\tout.println(m % md);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong d = m - maxM;\n\t\tlong mul = (binpow(2, d) - 1 + md) % md * 2 % md;\n\t\t\n\t\tlong ans = (mul * k) % md;\n\t\tans = (ans + ((count - d) * (k - 1) % md + md) % md + mod) % md;\n\t\t\n\t\tout.println(ans);\n\t}\n\t\n\tlong binpow(long a, long n) {\n\t\tif (n == 0) return 1;\n\t\tif ((n & 1) == 0) {\n\t\t\tlong b = binpow(a, n >> 1);\n\t\t\treturn (b * b) % md;\n\t\t} else {\n\t\t\treturn binpow(a, n - 1) * a % md;\n\t\t}\n\t}\n}\n\n", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.io.*;\n\npublic class A{\n\n    public static void main(String args[]){\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = in.nextInt();\n        int a = in.nextInt();\n        int b = in.nextInt();\n        boolean change = false;\n        if(a > b){\n            int t = a;\n            a = b;\n            b = t;\n            change = true;\n        }\n        boolean[] inb = new boolean[n];\n        int[] numbers = new int[n];\n        TreeMap<Integer, Integer> num = new TreeMap<Integer, Integer>();\n        for(int i = 0; i < n; i++){\n            num.put(in.nextInt(), i);\n        }\n        boolean hasAns = true;\n        while(!num.isEmpty()){\n            Entry<Integer, Integer> last = num.lastEntry();\n            int key = last.getKey();\n            if(num.containsKey(a - key)){\n                num.remove(key);\n                num.remove(a - key);\n            } else if(num.containsKey(b - key)){\n                inb[num.get(key)] = true;\n                inb[num.get(b - key)] = true;\n                num.remove(key);\n                num.remove(b - key);\n            } else{\n                hasAns = false;\n                break;\n            }\n        }\n        if(hasAns){\n            out.println(\"YES\");\n            for(int i = 0; i < n && !change; i++){\n                if(inb[i]){\n                    out.print(\"1\");\n                } else{\n                    out.print(\"0\");\n                }\n                if(i != n - 1){\n                    out.print(\" \");\n                }\n            }\n            for(int i = 0; i < n && change; i++){\n                if(inb[i]){\n                    out.print(\"0\");\n                } else{\n                    out.print(\"1\");\n                }\n                if(i != n - 1){\n                    out.print(\" \");\n                }\n            }\n        } else{\n            out.println(\"NO\");\n        }\n        out.close();\n    }\n\n    static class FastScanner{\n        private BufferedReader reader;\n\n        private StringTokenizer tokenizer;\n\n        public FastScanner(InputStream stream){\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String nextLine(){\n            try{\n                return reader.readLine();\n            } catch(IOException e){\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        public String next(){\n            while(tokenizer == null || !tokenizer.hasMoreTokens()){\n                try{\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch(IOException e){\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.util.*;\npublic class paintTheNumbers {\n    public static void main (String [] args){\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int [] arr = new int[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = scanner.nextInt();\n        }\n        System.out.print(paint(arr));\n    }\n    public static int paint(int [] arr){\n        Arrays.sort(arr);\n        HashSet<Integer> set = new HashSet<>();\n        int num = arr[0];\n        set.add(num);\n        for(int i = 1; i < arr.length; i++){\n            if(!divBySet(set, arr[i])){\n                set.add(arr[i]);\n            }\n\n        }\n        return set.size();\n    }\n\n    /**\n     *\n     * @param set\n     * @param a\n     * @return\n     */\n    public static boolean divBySet(HashSet<Integer> set, int a){\n        for(int s: set){\n            if(a % s == 0){\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Asgar Javadov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int d = in.nextInt();\n            int[] a = in.readIntArray(n);\n\n            int ans = 1;\n            for (int i = 0; i < a.length - 1; ++i) {\n                int left = a[i] + d;\n                int right = a[i + 1] - d;\n                if (left < right) {\n                    ans += 2;\n                } else if (left == right)\n                    ans++;\n            }\n\n            out.println(ans + 1);\n        }\n\n    }\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n\n    }\n\n    static class InputReader extends BufferedReader {\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream inputStream) {\n            super(new InputStreamReader(inputStream), 32768);\n        }\n\n        public InputReader(String filename) {\n            super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public Integer nextInt() {\n            return Integer.valueOf(next());\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++)\n                array[i] = nextInt();\n            return array;\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author John Martin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        ASubtractions solver = new ASubtractions();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ASubtractions {\n        public void solve(int testNumber, InputReader c, OutputWriter w) {\n            int tc = c.readInt();\n            while (tc-- > 0) {\n                int a = c.readInt(), b = c.readInt();\n                int op = 0;\n                while (a != b) {\n                    if (a > b) {\n                        int tm = b;\n                        b = a;\n                        a = tm;\n                    }\n                    int left = b - a;\n                    int rem = (left - 1) / a + 1;\n                    b -= rem * a;\n                    op += rem;\n                }\n                op++;\n                w.printLine(op);\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[]){\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=1;\n        while(T-->0)\n        {\n            int n=input.nextInt();\n            long a[][]=new long[n][n];\n            for(int i=0;i<n;i++)\n            {\n                a[0][i]=input.nextInt();\n            }\n            int x=1;\n            for(int i=1;i<n;i++)\n            {\n                for(int j=0;j<n-x;j++)\n                {\n                    a[i][j]=a[i-1][j]^a[i-1][j+1];\n                }\n                x++;\n            }\n            /*\n            for(int i=0;i<n;i++)\n            {\n                for(int j=0;j<n;j++)\n                {\n                    out.print(a[i][j]+\" \");\n                }\n                out.println();\n            }\n\n             */\n            long arr[][]=new long[n][n];\n            for(int i=0;i<n;i++)\n            {\n                long max=0;\n                x=0;\n                int y=i;\n                while(y>=0)\n                {\n                    max=Math.max(max,a[x][y]);\n                    arr[x][y]=max;\n                    x++;\n                    y--;\n                }\n            }\n            x=0;\n            for(int i=0;i<n;i++)\n            {\n                long max=0;\n                int y=x;\n                for(int j=0;j<n-i;j++)\n                {\n                    max=Math.max(max,arr[j][i]);\n                    a[x][y]=max;\n                    y++;\n                }\n                x++;\n            }\n            int q=input.nextInt();\n            for(int i=0;i<q;i++)\n            {\n                int l=input.nextInt();\n                int r=input.nextInt();\n                l--;\n                r--;\n                out.println(a[l][r]);\n            }\n        }\n        out.close();\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        String nextLine()\n        {\n            String str=\"\";\n            try\n            {\n                str=br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.Scanner;\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        \n        int n = input.nextInt();\n        \n        System.out.println(n * 6 / 4);\n    }\n    \n}", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[])\n    {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=1;\n        while(T-->0)\n        {\n            int n=input.nextInt();\n            int m=input.nextInt();\n            int x=1,y=n;\n            int count=0;\n            while(x<=y)\n            {\n                int a=1,b=m;\n                int f=0;\n                for(int i=1;i<=m*2;i++)\n                {\n                    if(i%2!=0)\n                    {\n                        out.println(x+\" \"+a);\n                        count++;\n                        if(count==n*m)\n                        {\n                            f=1;\n                            break;\n                        }\n                        a++;\n                    }\n                    else\n                    {\n                        out.println(y+\" \"+b);\n                        count++;\n                        if(count==n*m)\n                        {\n                            f=1;\n                            break;\n                        }\n                        b--;\n                    }\n                }\n                if(f==1)\n                {\n                    break;\n                }\n                x++;\n                y--;\n            }\n        }\n        out.close();\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        FastScanner sc=new FastScanner();\n        PrintWriter pw=new PrintWriter(System.out);\n        double eps=1e-12;\n        while(sc.hasNext()){\n            int n=sc.nextInt();\n            int r=sc.nextInt();\n            double[]shu=new double[n];\n            for(int i=0;i<n;i++)shu[i]=sc.nextDouble();\n            double[]res=new double[n];\n            for(int i=0;i<n;i++){\n                for(int j=0;j<i;j++){\n                    double temp=Math.abs(shu[i]-shu[j]);\n                    if(temp<2*r||Math.abs(temp-2*r)<eps){\n                        res[i]=Math.max(res[i],res[j]+Math.sqrt(4*r*r-temp*temp));\n                    }\n                }\n                res[i]=Math.max(res[i],r);\n            }\n            for(int i=0;i<n;i++){\n                pw.print(res[i]+\" \");\n            }\n            pw.flush();\n        }\n    }\n}\nclass FastScanner{\n    BufferedReader br;\n    StringTokenizer st;\n    FastScanner(){\n        br=new BufferedReader(new InputStreamReader(System.in));\n        st=new StringTokenizer(\"\");\n    }\n\n    String nextLine(){\n        String s=\"\";\n        try {\n            s=br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n    boolean hasNext(){\n        String s=\"\";\n        while(!st.hasMoreTokens()){\n            s=nextLine();\n            if(s==null)return false;\n            st=new StringTokenizer(s);\n        }\n        return true;\n    }\n    String next(){\n        String s=\"\";\n        while(!st.hasMoreTokens()){\n            s=nextLine();\n            st=new StringTokenizer(s);\n        }\n        return st.nextToken();\n    }\n    int nextInt(){\n        return Integer.valueOf(next());\n    }\n    long nextLong(){\n        return Long.valueOf(next());\n    }\n    double nextDouble(){\n        return Double.valueOf(next());\n    }\n}\n\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tdouble f(int dist, double initSp, int a, int maxSp) {\n\t\tdouble distToReachMaxSpeed = 0.5 * (maxSp * maxSp - initSp * initSp)\n\t\t\t\t/ a;\n\n\t\tif (dist > distToReachMaxSpeed)\n\t\t\treturn 1d * (maxSp - initSp) / a + (dist - distToReachMaxSpeed)\n\t\t\t\t\t/ maxSp;\n\n\t\treturn (Math.sqrt(initSp * initSp + 2 * a * dist) - initSp) / a;\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint a = nextInt();\n\t\tint maxSp = nextInt();\n\t\tint len = nextInt();\n\t\tint signX = nextInt();\n\t\tint signSp = nextInt();\n\n\t\tif (maxSp <= signSp) {\n\t\t\tout.printf(\"%.9f\\n\", f(len, 0, a, maxSp));\n\t\t\treturn;\n\t\t}\n\n\t\tdouble distToReachSignSp = 0.5 * signSp * signSp / a;\n\t\tif (distToReachSignSp >= signX) {\n\t\t\tdouble t = Math.sqrt(2d * signX / a);\n\t\t\tout.printf(\"%.9f\\n\", t + f(len - signX, t * a, a, maxSp));\n\t\t\treturn;\n\t\t}\n\n\t\tdouble distToReachMaxThenSign = 0.5\n\t\t\t\t* (maxSp * maxSp + maxSp * maxSp - signSp * signSp) / a;\n\t\tif (distToReachMaxThenSign <= signX) {\n\t\t\tdouble t = 1d * (2 * maxSp - signSp) / a\n\t\t\t\t\t+ (signX - distToReachMaxThenSign) / maxSp\n\t\t\t\t\t+ f(len - signX, signSp, a, maxSp);\n\t\t\tout.printf(\"%.9f\\n\", t);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdouble xSp = Math.sqrt(a * signX + signSp * signSp * 0.5);\n\t\tdouble xTime = (2 * xSp - signSp) / a;\n\t\tout.printf(\"%.9f\\n\", xTime + f(len - signX, signSp, a, maxSp));\n\t}\n\n\tvoid inp() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew D().inp();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] colors = new int[n];\n        for (int i = 0; i < n; i++) {\n            colors[i] = scanner.nextInt();\n        }\n        Arrays.sort(colors);\n        int amountOfColors = 0;\n        for (int i = 0; i < n; i++) {\n            if (colors[i] != 0){\n                amountOfColors++;\n                int color = colors[i];\n                for (int j = i; j < n; j++) {\n                    if (colors[j] % color == 0){\n                        colors[j] = 0;\n                    }\n                }\n            }\n        }\n        System.out.println(amountOfColors);\n    }\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main{\n\n    Scanner sc=new Scanner(System.in);\n    \n    void run(){\n        int n = sc.nextInt();\n        \n        int x[] = new int [n];\n        \n        for (int i=0;i<n;i++) \n            x[i] = sc.nextInt();\n        \n        java.util.Arrays.sort(x);\n        \n        int i = 0;\n        \n        for(i=0;i<n-1;i++) {\n            if (x[i] != x[i+1]) {\n                System.out.println( x[i+1] );\n                return;\n            }\n        }\n\n        System.out.println(\"NO\");\n        \n        return;\n        \n    }\n    \n    public static void main(String[] args){\n        new Main().run();\n    }\n}", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1187G extends PrintWriter {\n\tCF1187G() { super(System.out); }\n\tstatic class Scanner {\n\t\tScanner(InputStream in) { this.in = in; } InputStream in;\n\t\tint k, l; byte[] bb = new byte[1 << 15];\n\t\tbyte getc() {\n\t\t\tif (k >= l) {\n\t\t\t\tk = 0;\n\t\t\t\ttry { l = in.read(bb); } catch (IOException e) { l = 0; }\n\t\t\t\tif (l <= 0) return -1;\n\t\t\t}\n\t\t\treturn bb[k++];\n\t\t}\n\t\tint nextInt() {\n\t\t\tbyte c = 0; while (c <= 32) c = getc();\n\t\t\tint a = 0;\n\t\t\twhile (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n\t\t\treturn a;\n\t\t}\n\t}\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1187G o = new CF1187G(); o.main(); o.flush();\n\t}\n\n\tstatic final int INF = 0x3f3f3f3f;\n\tArrayList[] aa_;\n\tint n_, m_;\n\tint[] pi, kk, bb;\n\tint[] uu, vv, uv, cost, cost_;\n\tint[] cc;\n\tvoid init() {\n\t\taa_ = new ArrayList[n_];\n\t\tfor (int u = 0; u < n_; u++)\n\t\t\taa_[u] = new ArrayList<Integer>();\n\t\tpi = new int[n_];\n\t\tkk = new int[n_];\n\t\tbb = new int[n_];\n\t\tuu = new int[m_];\n\t\tvv = new int[m_];\n\t\tuv = new int[m_];\n\t\tcost = new int[m_];\n\t\tcost_ = new int[m_];\n\t\tcc = new int[m_ * 2];\n\t\tm_ = 0;\n\t}\n\tvoid link(int u, int v, int cap, int cos) {\n\t\tint h = m_++;\n\t\tuu[h] = u;\n\t\tvv[h] = v;\n\t\tuv[h] = u ^ v;\n\t\tcost[h] = cos;\n\t\tcc[h << 1 ^ 0] = cap;\n\t\taa_[u].add(h << 1 ^ 0);\n\t\taa_[v].add(h << 1 ^ 1);\n\t}\n\tboolean dijkstra(int s, int t) {\n\t\tArrays.fill(pi, INF);\n\t\tpi[s] = 0;\n\t\tTreeSet<Integer> pq = new TreeSet<>((u, v) -> pi[u] != pi[v] ? pi[u] - pi[v] : kk[u] != kk[v] ? kk[u] - kk[v] : u - v);\n\t\tpq.add(s);\n\t\tInteger first;\n\t\twhile ((first = pq.pollFirst()) != null) {\n\t\t\tint u = first;\n\t\t\tint k = kk[u] + 1;\n\t\t\tArrayList<Integer> adj = aa_[u];\n\t\t\tfor (int h_ : adj)\n\t\t\t\tif (cc[h_] > 0) {\n\t\t\t\t\tint h = h_ >> 1;\n\t\t\t\t\tint p = pi[u] + ((h_ & 1) == 0 ? cost_[h] : -cost_[h]);\n\t\t\t\t\tint v = u ^ uv[h];\n\t\t\t\t\tif (pi[v] > p || pi[v] == p && kk[v] > k) {\n\t\t\t\t\t\tif (pi[v] != INF)\n\t\t\t\t\t\t\tpq.remove(v);\n\t\t\t\t\t\tpi[v] = p;\n\t\t\t\t\t\tkk[v] = k;\n\t\t\t\t\t\tbb[v] = h_;\n\t\t\t\t\t\tpq.add(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn pi[t] != INF;\n\t}\n\tvoid push(int s, int t) {\n\t\tint c = INF;\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tc = Math.min(c, cc[h_]);\n\t\t}\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_] -= c; cc[h_ ^ 1] += c;\n\t\t}\n\t}\n\tvoid push1(int s, int t) {\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_]--; cc[h_ ^ 1]++;\n\t\t}\n\t}\n\tint edmonds_karp(int s, int t) {\n\t\tSystem.arraycopy(cost, 0, cost_, 0, m_);\n\t\twhile (dijkstra(s, t)) {\n\t\t\tpush1(s, t);\n\t\t\tfor (int h = 0; h < m_; h++) {\n\t\t\t\tint u = uu[h], v = vv[h];\n\t\t\t\tif (pi[u] != INF && pi[v] != INF)\n\t\t\t\t\tcost_[h] += pi[u] - pi[v];\n\t\t\t}\n\t\t}\n\t\tint c = 0;\n\t\tfor (int h = 0; h < m_; h++)\n\t\t\tc += cost[h] * cc[h << 1 ^ 1];\n\t\treturn c;\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tint[] ii = new int[k];\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tii[h] = sc.nextInt() - 1;\n\t\tArrayList[] aa = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = new ArrayList<Integer>();\n\t\tfor (int h = 0; h < m; h++) {\n\t\t\tint i = sc.nextInt() - 1;\n\t\t\tint j = sc.nextInt() - 1;\n\t\t\taa[i].add(j);\n\t\t\taa[j].add(i);\n\t\t}\n\t\tint t = n + k + 1;\n\t\tn_ = n * t + 1;\n\t\tm_ = k + (m * 2 * k + n) * (t - 1);\n\t\tinit();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrayList<Integer> adj = aa[i];\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s;\n\t\t\t\tfor (int j : adj) {\n\t\t\t\t\tint v = j * t + s + 1;\n\t\t\t\t\tfor (int x = 1; x <= k; x++)\n\t\t\t\t\t\tlink(u, v, 1, c + (x * 2 - 1) * d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s, v = u + 1;\n\t\t\t\tlink(u, v, k, i == 0 ? 0 : c);\n\t\t\t}\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tlink(n_ - 1, ii[h] * t + 0, 1, 0);\n\t\tprintln(edmonds_karp(n_ - 1, 0 * t + t - 1));\n\t}\n}\n", "complexity": "cubic", "problem": "1187_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class C1197 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = reader.readLine().split(\" \");\n        int size = Integer.parseInt(s[0]);\n        int k = Integer.parseInt(s[1]);\n        int[] nums = new int[size];\n        s = reader.readLine().split(\" \");\n        for (int i = 0; i < size; i++) {\n            nums[i] = Integer.parseInt(s[i]);\n        }\n        int[] da = new int[size - 1];\n        for (int i = 1; i < size; i++) {\n            da[i - 1] = nums[i] - nums[i - 1];\n        }\n        Arrays.sort(da);\n        int sum = 0;\n        for (int i = 0; i <= da.length - k; i++) {\n            sum += da[i];\n        }\n        System.out.println(sum);\n    }\n}", "complexity": "nlogn", "problem": "1197_C", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class e {\n\tprivate void main() {\n\t\tScanner stdin = new Scanner(System.in);\n\t\tPrintStream stdout = System.out;\n\t\tint n = stdin.nextInt();\n\t\tdouble[][] p = new double[n][n];\n\t\tdouble[][] ans = new double[1<<n][n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tp[i][j] = stdin.nextDouble();\n\t\tdouble[] dieChance = new double[n];\n\t\tArrayList<Integer> sel = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < (1<<n); i++) {\n\t\t\tsel.clear();\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\tif((i & (1<<k)) != 0)\n\t\t\t\t\tsel.add(k);\n\t\t\t}\n\t\t\tif(sel.size() == 1) {\n\t\t\t\tans[i][sel.get(0)] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j : sel)\n\t\t\t\tdieChance[j] = 0;\n\t\t\tfor(int j : sel)\n\t\t\t\tfor(int k : sel)\n\t\t\t\t\tdieChance[k] += p[j][k];\n\t\t\tfor(int j : sel)\n\t\t\t\tdieChance[j] /= sel.size()*(sel.size()-1)/2;\n\t\t\tfor(int j : sel) {\n\t\t\t\tans[i][j] = dieChance[j];\n\t\t\t\tfor(int k : sel)\n\t\t\t\t\tans[i][j] += dieChance[k] * ans[i-(1<<k)][j];\n\t\t\t}\n\t\t}\n\t\tfor(double d : ans[(1<<n)-1])\n\t\t\tstdout.format(\"%f \", 1-d);\n\t\tstdout.println();\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew e().main();\n\t}\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.util.Map;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.TreeMap;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.readInt();\n        int a = in.readInt();\n        int b = in.readInt();\n        TreeMap<Integer, Integer> mp = new TreeMap<Integer, Integer>();\n        for (int i = 0; i < n; ++i) {\n            mp.put(in.readInt(), i);\n        }\n        int aname = 0;\n        int bname = 1;\n        if (a > b) {\n            int t = a;\n            a = b;\n            b = t;\n            aname = 1;\n            bname = 0;\n        }\n        int[] res = new int[n];\n        while (mp.size() > 0) {\n            Map.Entry<Integer, Integer> e = mp.firstEntry();\n            int val = e.getKey();\n            if (mp.containsKey(b - val)) {\n                res[mp.get(val)] = res[mp.get(b - val)] = bname;\n                mp.remove(val);\n                mp.remove(b - val);\n            } else if (mp.containsKey(a - val)) {\n                res[mp.get(val)] = res[mp.get(a - val)] = aname;\n                mp.remove(val);\n                mp.remove(a - val);\n            } else {\n                break;\n            }\n        }\n        if (mp.size() > 0) {\n            out.println(\"NO\");\n        } else {\n            out.println(\"YES\");\n            for (int i = 0; i < n; ++i) {\n                if (i > 0) out.print(\" \");\n                out.print(res[i]);\n            }\n            out.println();\n        }\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        // InputMismatchException -> UnknownError\n        if (numChars == -1)\n            throw new UnknownError();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new UnknownError();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        } else if (c == '+') {\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public static boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n}\n\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1238E extends PrintWriter {\n\tCF1238E() { super(System.out, true); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1238E o = new CF1238E(); o.main(); o.flush();\n\t}\n\n\tstatic final int INF = 0x3f3f3f3f;\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tbyte[] cc = sc.next().getBytes();\n\t\tint[] kk = new int[1 << m];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint a = cc[i - 1] - 'a';\n\t\t\tint b = cc[i] - 'a';\n\t\t\tkk[1 << a | 1 << b]++;\n\t\t}\n\t\tfor (int h = 0; h < m; h++)\n\t\t\tfor (int b = 0; b < 1 << m; b++)\n\t\t\t\tif ((b & 1 << h) == 0)\n\t\t\t\t\tkk[b | 1 << h] += kk[b];\n\t\tint[] dp = new int[1 << m];\n\t\tint m_ = (1 << m) - 1;\n\t\tfor (int b = 1; b < 1 << m; b++) {\n\t\t\tint k = n - 1 - kk[b] - kk[m_ ^ b];\n\t\t\tint x = INF;\n\t\t\tfor (int h = 0; h < m; h++)\n\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\tint b_ = b ^ 1 << h;\n\t\t\t\t\tx = Math.min(x, dp[b_]);\n\t\t\t\t}\n\t\t\tdp[b] = x == INF ? INF : x + k;\n\t\t}\n\t\tprintln(dp[m_]);\n\t}\n}\n", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = in.nextIntArray(n);\n            int ct = 0;\n            for (int i = 0; i < n; ++i) {\n                for (int j = i + 1; j < n; ++j) {\n                    if (a[i] > a[j]) ++ct;\n                }\n            }\n            ct &= 1;\n            int Q = in.nextInt();\n            for (int q = 0; q < Q; ++q) {\n                int l = in.nextInt();\n                int r = in.nextInt();\n                int size = (r - l + 1) * (r - l) >> 1;\n                ct ^= size & 1;\n                out.println(ct % 2 == 0 ? \"even\" : \"odd\");\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            long x=Long.parseLong(s1[1]);\n            long y=Long.parseLong(s1[2]);\n            long S=0;\n            long mod=1000000007;\n            B a[]=new B[n];\n            TreeMap<Long,Long> tm=new TreeMap<Long,Long>();\n            long ans[]=new long[n];\n            for(int i=0;i<n;i++)\n            {\n              String s2[]=br.readLine().split(\" \");\n              long l=Long.parseLong(s2[0]);\n              long r=Long.parseLong(s2[1]);\n              B b1=new B(l,r);\n              a[i]=b1;\n            }\n            Arrays.sort(a,new The_Comp());\n            \n            for(int i=0;i<n;i++)\n            {\n                  long l=a[i].x;\n                  long r=a[i].y;\n                  if(tm.floorKey(l-1)!=null)\n                  {\n                        long u=tm.floorKey(l-1);\n                        long v=l;\n                        if((v-u)*y<x)\n                        { ans[i]=((r-u)*y)%mod; \n                          if(tm.get(u)>1)\n                           tm.put(u,tm.get(u)-1);\n                          else\n                          tm.remove(u); \n                        }\n                        else\n                        { ans[i]=(x+(r-l)*y)%mod; }\n                  }\n                  else\n                   ans[i]=(x+(r-l)*y)%mod;\n                  S=(S+ans[i])%mod;\n                  if(tm.containsKey(r))\n                   tm.put(r,1+tm.get(r));\n                  else\n                   tm.put(r,(long)1);\n            }\n            System.out.println(S);\n      }\n}\n\n\nclass The_Comp implements Comparator<B>\n{\n      public int compare(B b1,B b2)\n      {\n            if(b1.x>b2.x)\n             return 1;\n            else if(b1.x==b2.x)\n            {\n            if(b1.y>b2.y)\n             return 1;\n            else if(b1.y==b2.y)\n             return 0;\n            else\n             return -1;\n            }\n            else\n             return -1;\n      }\n}\nclass B\n{\n      long x=(long)1;\n      long y=(long)1;\n      public B(long l1,long l2)\n      { x=l1;  y=l2; }\n}", "complexity": "nlogn", "problem": "1061_D", "from": "CODEFORCES", "tags": "data structures,greedy,implementation,sortings"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport com.sun.imageio.plugins.common.InputStreamAdapter;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n,a,b;\n\t\tlong counter;\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString in = reader.readLine();\n\t\tn = Integer.parseInt(in);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tin = reader.readLine();\n\t\t\tString[] sp = in.split(\" \");\n\t\t\ta = Integer.parseInt(sp[0]);\n\t\t\tb = Integer.parseInt(sp[1]);\n\t\t\tcounter = 0;\n\t\t\twhile(a!=0 && b!=0){\n\t\t\t\tif(Math.max(a, b)% Math.min(a, b) == 0){\n\t\t\t\t\tcounter+= Math.max(a, b)/Math.min(a, b);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcounter+= Math.max(a, b)/Math.min(a, b);\n\t\t\t\t\tif(a>=b){\n\t\t\t\t\t\ta = a-Math.max(a, b)/Math.min(a, b)*b;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tb = b-Math.max(a, b)/Math.min(a, b)*a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(counter);\n\t\t}\n\t}\n\n}\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main\n{\n    BufferedReader reader;\n    FastScanner sc;\n    \n    void solve() throws Exception\n    {\n        int n = sc.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            arr[i] = sc.nextInt();\n        }\n        Arrays.sort(arr);\n        if (arr[n - 1] == 1)\n            arr[n - 1] = 2;\n        else\n            arr[n - 1] = 1;\n        Arrays.sort(arr);\n        for (int i = 0; i < n; i++)\n        {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n        \n    public static void main(String[] args) throws Exception\n    {\n        new Main().solve();\n    }\n    \n    Main() throws Exception\n    {\n        if (System.getProperty(\"ONLINE_JUDGE\") == null)\n        {\n            //System.setIn(new FileInputStream(\"input.txt\"));\n            //System.setOut(new PrintStream(\"output.txt\"));\n        }\n        \n        reader = new BufferedReader(new InputStreamReader(System.in));\n        sc = new FastScanner(reader);\n    }\n}\n\nclass FastScanner\n{\n    BufferedReader reader;\n    StringTokenizer strTok;\n    \n    public FastScanner(BufferedReader reader)\n    {\n        this.reader = reader;\n    }\n    \n    public String nextToken() throws IOException\n    {\n        if (strTok == null || !strTok.hasMoreTokens())\n        {\n            strTok = new StringTokenizer(reader.readLine());\n        }\n        return strTok.nextToken();\n    }\n    \n    public int nextInt() throws IOException\n    {\n        return Integer.parseInt(nextToken());\n    }\n    \n    public long nextLong() throws IOException\n    {\n        return Long.parseLong(nextToken());\n    }\n    \n    public double nextDouble() throws IOException\n    {\n        return Double.parseDouble(nextToken());\n    }\n    \n    public BigInteger nextBigInteger() throws IOException\n    {\n        return new BigInteger(nextToken());\n    }\n    \n    public BigDecimal nextBigDecimal() throws IOException\n    {\n        return new BigDecimal(nextToken());\n    }\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\t\n\tstatic long MOD = (long) 1e9 + 7;\n\tstatic long[][] identity = {{1, 0}, {0, 1}};\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner input = new FastScanner(System.in);\n\t\t\n\t\tlong x = input.nextLong();\n\t\tlong k = input.nextLong();\n\t\t\n\t\tlong[][] matrix = {\n\t\t\t{2, MOD - 1},\n\t\t\t{0, 1}\n\t\t};\n\t\t\n\t\tif (x == 0)\n\t\t\tSystem.out.println(0);\n\t\telse if (k == 0) {\n\t\t\tSystem.out.println((x * 2) % MOD);\n\t\t} else {\n\t\t\tx %= MOD;\n\t\t\tmatrix = matrixexpo(k, matrix);\n\t\t\tlong low = (x * matrix[0][0] + matrix[0][1]) % MOD;\n\t\t\tlong hi = x * mathpow(k, 2) % MOD;\n\t\t\tSystem.out.println((low + hi) % MOD);\n\t\t}\n\t}\n\t\n\tstatic long mathpow(long k, long x) {\n\t\tif (k == 0)\n\t\t\treturn 1L;\n\t\telse return mathpow(k / 2, (x * x) % MOD) * (k % 2 == 1 ? x : 1) % MOD;\n\t}\n\t\n\tstatic long[][] matrixexpo(long k, long[][] matrix) { \n\t\tif (k == 0)\n\t\t\treturn identity;\n\t\tif (k % 2 == 0)\n\t\t\treturn matrixexpo(k / 2, multiply(matrix, matrix));\n\t\telse\n\t\t\treturn multiply(matrix, matrixexpo(k / 2, multiply(matrix, matrix)));\n\t}\n\t\n\tstatic long[][] multiply(long[][] arr, long[][] brr) { \n\t\tint n = arr.length, m = arr[0].length, p = brr[0].length;\n\t\t\n\t\tlong[][] product = new long[n][p];\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < p; j++)\n\t\t\t\tfor (int k = 0; k < m; k++)\n\t\t\t\t\tproduct[i][j] = (product[i][j] + arr[i][k] * brr[k][j]) % MOD;\n\t\treturn product;\n\t}\n\t\n\t// Matt Fontaine's Fast IO\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport java.io.*;\n \npublic class ExplorerSpace {\n\t\n\tprivate static class MyScanner {\n\t    BufferedReader br;\n\t    StringTokenizer st;\n\n\t    public MyScanner() {\n\t       br = new BufferedReader(new InputStreamReader(System.in));\n\t    }\n\n\t    String next() {\n\t        while (st == null || !st.hasMoreElements()) {\n\t            try {\n\t                st = new StringTokenizer(br.readLine());\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t        return st.nextToken();\n\t    }\n\n\t    int nextInt() {\n\t        return Integer.parseInt(next());\n\t    }\n\n\t    long nextLong() {\n\t        return Long.parseLong(next());\n\t    }\n\n\t    double nextDouble() {\n\t        return Double.parseDouble(next());\n\t    }\n\n\t    String nextLine(){\n\t        String str = \"\";\n\t\t  try {\n\t\t     str = br.readLine();\n\t\t  } catch (IOException e) {\n\t\t     e.printStackTrace();\n\t\t  }\n\t\t  return str;\n\t    }\n\n\t }\n\t\n    \n\tpublic static long[][][] dp; \n\t\n\tpublic static boolean valid(int i, int j, int n, int m)\n\t{\n\t\treturn i>=0 && i<n &&j>=0 && j<m;\n\t}\n\t\n\tpublic static void solution(int n, int m, int k, int[][] h, int[][] v)\n\t\t\t\n\t{\n\t\tif(k%2==1)\n\t\t{\n\t\t\tfor(int i = 0; i<n; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j<m; j++)\n\t\t\t\t   out.print(-1+\" \");\n\t\t\t\t\n\t\t\t\tout.println();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdp = new long[n][m][k/2+1];\n\t\t\n\t\tfor(int t = 1; t<=k/2; t++)\n\t\t{\n\t\t\tfor(int i = 0; i<n; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j<m; j++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][t] = Long.MAX_VALUE;\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i<n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j<m; j++)\n\t\t\t{\n\t\t\t\tdp[i][j][0] = 0;\n\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int t = 1; t<=k/2; t++)\n\t\t{\n\t\t\tfor(int i = 0; i<n; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j<m; j++)\n\t\t\t\t{\n\t\t\t\t\tif(valid(i,j+1,n,m))\n\t\t\t\t\t\tdp[i][j][t] = Math.min(dp[i][j][t], h[i][j] + dp[i][j+1][t-1]); \n\t\t\t\t\n\t\t\t\t\tif(valid(i,j-1,n,m))\n\t\t\t\t\t\t dp[i][j][t] = Math.min(dp[i][j][t], h[i][j-1] + dp[i][j-1][t-1]);\n\t\t\t\t\n\t\t\t\t\tif(valid(i+1,j,n,m))\n\t\t\t\t\t\t dp[i][j][t] = Math.min(dp[i][j][t], v[i][j] + dp[i+1][j][t-1]); \n\t\t\t\n\t\t\t\t\tif(valid(i-1,j,n,m))\n\t\t\t\t\t\tdp[i][j][t] = Math.min(dp[i][j][t], v[i-1][j] + dp[i-1][j][t-1]); \n\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0; i<n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j<m; j++)\n\t\t\t\tout.print((dp[i][j][k/2]*2)+\" \");\n\t\t\t\n\t\t\tout.println();\n\t\t}\n\t\t\n\t}\n        \nprivate static PrintWriter out = new PrintWriter(System.out);\n\npublic static void main (String[] args)\n{\n\tMyScanner s =  new MyScanner();\n     \n    int n = s.nextInt();\n    int m = s.nextInt();\n    int k = s.nextInt();\n    \n    int[][] h = new int[n][m-1];\n    \n    for(int i = 0; i<n; i++)\n    {\n    \tfor(int j = 0; j<m-1; j++)\n    \t{\n    \t\th[i][j] = s.nextInt();\n    \t}\n    }\n    \n    int[][] v = new int[n-1][m];\n    \n    for(int i = 0; i<n-1; i++)\n    {\n    \tfor(int j = 0; j<m; j++)\n    \t{\n    \t\tv[i][j] = s.nextInt();\n    \t}\n    }\n    \n    \n   solution(n,m,k,h,v);\n    \n    out.flush();\n    out.close();\n    \n}\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class ProblemA {\n\n    private final BufferedReader in;\n    private final PrintStream out;\n    private StringTokenizer tok = new StringTokenizer(\"\");\n    private String nextLine = null;\n\n    public static void main(String[] args) throws Exception {\n        new ProblemA();\n    }\n\n    private ProblemA() throws Exception {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = System.out;\n        start();\n        end();\n    }\n\n    private int nextInt() {\n        return Integer.parseInt(nextWord());\n    }\n\n    private String nextWord() {\n        if (tok.hasMoreTokens()) {\n            return tok.nextToken();\n        } else {\n            while (!tok.hasMoreTokens()) {\n                try {\n                    nextLine = in.readLine();\n                    if (nextLine == null) {\n                        return null;\n                    } else {\n                        tok = new StringTokenizer(nextLine);\n                    }\n                } catch (IOException ex) {\n                    Logger.getLogger(ProblemA.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n            return tok.nextToken();\n        }\n    }\n\n    private void start() {\n        int n = nextInt();\n        int[] a = new int[n];\n        boolean allOne = true;\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n            if (a[i] != 1) {\n                allOne = false;\n            }\n        }\n        Arrays.sort(a);\n        int[] res = new int[n];\n        res[0] = 1;\n        for (int i = 1; i < n; i++) {\n            res[i] = a[i - 1];\n        }\n        if (allOne) {\n            for (int i = 0; i < n - 1; i++) {\n                out.print(a[i] + \" \");\n            }\n            out.print(2);\n        } else {\n            for (int i = 0; i < n; i++) {\n                out.print(res[i] + \" \");\n            }\n        }\n    }\n\n    private void end() {\n        out.close();\n    }\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.Scanner;\n\n\n\npublic class Main {\n\n\tpublic static void main(String[] args){\n\n\t\tScanner scan=new Scanner(System.in);\n\n\t\tint n=scan.nextInt();\n\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tString s=scan.next();\n\n\t\t\tif(s.matches(\"R[0-9]+C[0-9]+\")){\n\n\t\t\t\tString[] nums=s.split(\"R|C\");\n\n\t\t\t\tint x=Integer.parseInt(nums[2]);\n\n\t\t\t\tString t=\"\";\n\n\t\t\t\twhile(x!=0){\n\n\t\t\t\t\tint m=x%26;\n\n\t\t\t\t\tif(m==0){\n\n\t\t\t\t\t\tt=\"Z\"+t;\n\n\t\t\t\t\t\tx-=26;\n\n\t\t\t\t\t}\n\n\t\t\t\t\telse\n\n\t\t\t\t\t\tt=(char)(m+'A'-1)+t;\n\n\t\t\t\t\tx/=26;\n\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(t+nums[1]);\n\n\t\t\t}\n\n\t\t\telse{\n\n\t\t\t\tString x1 = s.replaceAll(\"[0-9]\", \"\");\n\n\t\t\t\tString x2 = s.replaceAll(\"[A-Z]\", \"\");\n\n\t\t\t\tint base=1;\n\n\t\t\t\tint t=0;\n\n\t\t\t\tfor(int j=x1.length()-1;j>=0;j--) {\n\n\t\t\t\t\tt+=base*(x1.charAt(j)-'A'+1);\n\n\t\t\t\t\tbase*=26;\n\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(\"R\"+ x2 + \"C\"+t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class P_35C {\n    static final FS sc = new FS();\n    static final PrintWriter pw = new PrintWriter(System.out);\n    static int[][] res;\n    static int[] dx = {1,0,-1,0};\n    static int[] dy = {0,-1,0,1};\n    static int n, m;\n    static Queue<Integer> qx;\n    static Queue<Integer> qy;\n    static void bfs(){\n        while(!qx.isEmpty() && !qy.isEmpty()){\n            int xn = qx.poll();\n            int yn = qy.poll();\n            for(int i=0; i<4; i++){\n                int nx = xn+dx[i];\n                int ny = yn+dy[i];\n                if(nx>=0 && ny>=0 && nx<n && ny<m && res[nx][ny]==-1){\n                    res[nx][ny] = res[xn][yn]+1;\n                    qx.add(nx);\n                    qy.add(ny);\n                }\n            }\n        }\n    }\n    public static void main(String[] args) throws FileNotFoundException {\n        File file = new File(\"input.txt\");\n        Scanner sc = new Scanner(file);\n        n = sc.nextInt();\n        m = sc.nextInt();\n        int k = sc.nextInt();\n        ArrayList<Integer> xl = new ArrayList<>();\n        ArrayList<Integer> yl = new ArrayList<>();\n        res = new int[n][m];\n        qx = new LinkedList<>();\n        qy = new LinkedList<>();\n        for(int i=0; i<k; i++){\n            int xi = sc.nextInt()-1;\n            int yi = sc.nextInt()-1;\n            qx.add(xi); qy.add(yi);\n            res[xi][yi] = 1;\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(res[i][j]==1) res[i][j] = 0;\n                else res[i][j] = -1;\n            }\n        }\n        bfs();\n        int x = 0,y = 0;\n        int max = Integer.MIN_VALUE;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(res[i][j]>max){\n                    max = res[i][j];\n                    x = i; y = j;\n                }\n            }\n        }\n        try {\n            FileWriter writer = new FileWriter(\"output.txt\");\n            writer.write((x+1)+\" \"+(y+1));\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class FS {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception ignored) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int[] nextArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.OutputStream;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.PrintWriter;\n\nimport java.io.DataInputStream;\n\nimport java.io.IOException;\n\nimport java.io.FileInputStream;\n\nimport java.io.InputStream;\n\n\n\n/**\n\n * Built using CHelper plug-in\n\n * Actual solution is at the top\n\n */\n\npublic class Main {\n\n    public static void main(String[] args)throws Exception {\n\n        InputStream inputStream = System.in;\n\n        OutputStream outputStream = System.out;\n\n        Reader in = new Reader(inputStream);\n\n        PrintWriter out = new PrintWriter(outputStream);\n\n        MaximizingXor solver = new MaximizingXor();\n\n        solver.solve(1, in, out);\n\n        out.close();\n\n    }\n\n\n\n    static class MaximizingXor {\n\n        public void solve(int testNumber, Reader in, PrintWriter out) throws Exception {\n\n\n\n            long l = in.nextLong();\n\n            long r = in.nextLong();\n\n\n\n            long p = l ^ r;\n\n\n\n            long c = 0;\n\n            while (p != 0) {\n\n                c++;\n\n                p >>= 1;\n\n            }\n\n            out.println((long) Math.pow(2, c) - 1L);\n\n        }\n\n\n\n    }\n\n\n\n    static class Reader {\n\n        final private int BUFFER_SIZE = 1 << 16;\n\n        private DataInputStream din;\n\n        private byte[] buffer;\n\n        private int bufferPointer;\n\n        private int bytesRead;\n\n\n\n        public Reader(InputStream in) {\n\n            din = new DataInputStream(in);\n\n            buffer = new byte[BUFFER_SIZE];\n\n            bufferPointer = bytesRead = 0;\n\n        }\n\n\n\n        public Reader(String file_name) throws IOException {\n\n            din = new DataInputStream(new FileInputStream(file_name));\n\n            buffer = new byte[BUFFER_SIZE];\n\n            bufferPointer = bytesRead = 0;\n\n        }\n\n\n\n        public long nextLong() throws IOException {\n\n            long ret = 0;\n\n            byte c = read();\n\n            while (c <= ' ') {\n\n                c = read();\n\n            }\n\n            boolean neg = (c == '-');\n\n            if (neg) {\n\n                c = read();\n\n            }\n\n            do {\n\n                ret = ret * 10 + c - '0';\n\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) {\n\n                return -ret;\n\n            }\n\n            return ret;\n\n        }\n\n\n\n        private void fillBuffer() throws IOException {\n\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\n            if (bytesRead == -1) {\n\n                buffer[0] = -1;\n\n            }\n\n        }\n\n\n\n        private byte read() throws IOException {\n\n            if (bufferPointer == bytesRead) {\n\n                fillBuffer();\n\n            }\n\n            return buffer[bufferPointer++];\n\n        }\n\n\n\n    }\n\n}\n\n\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class X\n{\n\tpublic static void main(String args[])throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tString s1 = br.readLine();\n\t\tString s2 = br.readLine();\n\t\tint i=0;\n\t\tchar c1,c2;\n\t\tint cost = 0;\n\t\twhile(i<n)\n\t\t{\n\t\t\tc1 = s1.charAt(i);\n\t\t\tc2 = s2.charAt(i);\n\t\t\tif(c1 != c2)\n\t\t\t{\n\t\t\t\tif((i+1)<n && s1.charAt(i+1) != s2.charAt(i+1) && s1.charAt(i) != s1.charAt(i+1))\n\t\t\t\t{\n\t\t\t\t\tcost +=1;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcost +=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n}", "complexity": "linear", "problem": "1037_C", "from": "CODEFORCES", "tags": "dp,greedy,strings"}
{"src": "import java.awt.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        long n = scanner.nextLong();\n        long x = scanner.nextLong(), y = scanner.nextLong();\n        long whiteSteps, blackSteps;\n\n        if(x == 1 || y == 1){\n            whiteSteps = (x - 1) + (y - 1);\n        } else {\n            whiteSteps = Math.min((x - 1) + Math.abs(y - x), (y - 1) + Math.abs(y - x));\n        }\n\n        if(x == n || y == n){\n            blackSteps = (n - x) + (n - y);\n        } else {\n            blackSteps = Math.min((n - x) + Math.abs(y - x), (n - y) + Math.abs(y - x));\n        }\n\n        if (whiteSteps <= blackSteps){\n            System.out.println(\"White\");\n        } else {\n            System.out.println(\"Black\");\n        }\n\n    }\n}\n", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.util.List;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.HashMap;\npublic class G {\n \tprivate static FastScanner fs=new FastScanner();\n\tpublic static void main(String[] args) {\n\t\t\n\t\t\n\n\t\t\tint n = fs.nextInt(),k = fs.nextInt();\n\t\t\tint a[] = fs.readArray(n);\n\t\t\tint b[] = fs.readArray(n);\n\n\t\t\t// From 1 to n-k+1 we can use technique\n\t\t\t// we can use it for j minutes \n\t\t\t// j is from i tp i+k -1;\n\t\t\t// \n\n\t\t\tlong max = Integer.MIN_VALUE;\n\t\t\tlong sol =0;\n\t\t\tint pre[] = new int[n+1];\n\t\t\tint prev =0;\n\n\t\t\tif(b[0]==0)\n\t\t\t{ \n\t\t\t\tpre[1] = a[0];\n\t\t\t\t\n\t\t\t}\n\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tif(b[i]==0)\n\t\t\t\t{\n\t\t\t\t\tpre[i+1] += a[i];\n\t\t\t\t\tpre[i+1] +=pre[i];\n\t\t\t\t}\n\t\t\t\telse pre[i+1] = pre[i];\n\t\t\t}\n\n\t\t\tfor(int i=n-1;i>=0;i--)\n\t\t\t{\n\t\t\t\tlong sum =0;\n\t\t\t\t\tif(i-k+1>=0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// for(int j=i;j>=(i-k+1);j--)\n\t\t\t\t\t\t// {\n\t\t\t\t\t\t// if(b[j]==0) dp[i][1] += a[j];\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tsum +=(pre[i+1]-pre[i-k+1]);\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// for(int j=i;j>=0;j--)\n\t\t\t\t\t\t// {\n\t\t\t\t\t\t// \tif(b[j]==0) dp[i][0] +=a[j];\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tsum +=(pre[i+1]-pre[0]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(sum>max) \n\t\t\t\t\t{\n\t\t\t\t\t\tmax = sum;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(b[i]==1) sol +=a[i];\n\t\t\t\t\n\t\t\t}\n\t\t\t// System.out.println(max);\n\t\t\tsol += max;\n\t\t\tSystem.out.println(sol);\n\t\t}\n\t\n \n\tstatic final Random random=new Random();\n\t\n\tstatic void ruffleSort(long[] a) {\n\t\tint n=a.length;//shuffle, then sort \n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint oi=random.nextInt(n); long temp=a[oi];\n\t\t\ta[oi]=a[i]; a[i]=temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tint [] sort(int [] arr)\n\t\t{\n\t\t\tList<Integer> list = new ArrayList<>();\n\t\t\tfor(int i : arr) list.add(i);\t\n\t\t\n\t\t\tCollections.sort(list);\n\t\t\tint res[] = new int[arr.length];\n\t\t\tfor(int i=0;i<arr.length;i++) res[i] = list.get(i);\n\t\t\t\n\n\t\t\treturn res;\n\t\t}\n\t}\n \n\t\n}", "complexity": "linear", "problem": "0961_B", "from": "CODEFORCES", "tags": "data structures,dp,implementation,two pointers"}
{"src": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.concurrent.ArrayBlockingQueue;\n\nimport org.omg.CORBA.UNKNOWN;\n\n\npublic class HelloWorld {\n\n    InputReader input;\n    PrintWriter output;\n    BufferedReader inp;\n\n    void run(){\n        output = new PrintWriter(new OutputStreamWriter(System.out));\n        input = new InputReader(System.in);\n        inp = new BufferedReader(new InputStreamReader(System.in));\n        solve();\n        output.flush();\n    }\n\n    public static void main(String[] args){\n        new HelloWorld().run();\n    }\n    \n    long stps;\n    \n    long gcd(long a, long b) {\n        if(b == 0 || a == 0) {\n            return 0;\n        }\n        return a/b + gcd(b, a%b);\n    }\n    \n    void solve() {\n        long a = input.readLong();\n        long b = input.readLong();\n        stps = gcd(a, b);\n        output.println(stps);\n    }\n    \n    \n    \n    class node implements Comparable<node>{\n        int destination;\n        int direction;\n        int distance;\n        \n        public node(int destination, int distance, int direction) {\n            this.direction = direction;\n            this.distance = distance;\n            this.destination = destination;\n        }\n        \n        public int compareTo(node b) {\n            return this.distance - b.distance;\n        }\n    }\n    \n    class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars)\n            {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public Long readLong() {\n            return Long.parseLong(readString());\n        }\n\n        public Double readDouble() {\n            return Double.parseDouble(readString());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    } \n\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Govnokod {\n\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\t\tBufferedReader br = new BufferedReader(isr);\n\n\t\t\twhile (true) {\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint i = Integer.parseInt(str);\n\n\t\t\t\tSystem.out.println(i*2-i/2);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.Scanner;\n\npublic class SpreadSheet {\n\n\tpublic static void main(String [] args){\n\n\t\tScanner in= new Scanner(System.in);\n\n\t\tint n=in.nextInt();\n\n\t\twhile(--n>=0)\n\n\t\t{\n\n\t\t\tString crood=in.next();\n\n\t\t\tint cIndex= crood.indexOf(\"C\");\n\n\t\t\tif(crood.startsWith(\"R\") && Character.isDigit(crood.charAt(1)) && cIndex != -1)\n\n\t\t\t{\n\n\t\t\t\tint row=Integer.valueOf(crood.substring(1,cIndex));\n\n\t\t\t\tint col= Integer.valueOf(crood.substring(cIndex+1));\n\n\t\t\t\tStringBuilder colstr= new StringBuilder();\n\n\t\t\t\twhile(col>0){\n\n\t\t\t\t\tcolstr.insert(0, (char)((col-1)%26+'A'));\n\n\t\t\t\t\tcol=(col-1)/26;\n\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(colstr.toString()+row);\n\n\t\t\t}\n\n\t\t\telse{\n\n\t\t\t\tint split =1;\n\n\t\t\t\twhile(!Character.isDigit(crood.charAt(split)))\n\n\t\t\t\t\tsplit++;\n\n\t\t\t\tString colstr=crood.substring(0,split);\n\n\t\t\t\tint row=Integer.valueOf(crood.substring(split));\n\n\t\t\t\tint col=0;\n\n\t\t\t\tfor(int i=0;i<colstr.length();i++){\n\n\t\t\t\t\tcol *=26;\n\n\t\t\t\t\tcol += colstr.charAt(i)-'A'+1;\n\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(\"R\"+row+\"C\"+col);\n\n\t\t\t\t\t\t\n\n\t\t\t}\n\n\t\t\t\n\n\t\t}\n\n\t}\n\n\n\n}\n\n", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class CodeChef2 {\n   \n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n            \n        } \n  \n        String next() \n        {\n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n\t\n//    \n//\tstatic class Line{\n//\t\tPoint p1;\n//\t\tPoint p2;\n//\t\n//\t\tLine(Point p1,Point p2){\n//\t\t\tthis.p1=p1;\n//\t\t\tthis.p2=p2;\n//\t\t}\n//\t\t\n//\t    static Boolean intersects(Line l1,Line l2) \n//\t    { \n//\t    \tPoint A=l1.p1, B=l1.p2,C=l2.p1,D=l2.p2;\n//\t    \t\n//\t        long a1 = B.y - A.y; \n//\t        long b1 = A.x - B.x; \n//\t        long c1 = a1*(A.x) + b1*(A.y); \n//\t       \n//\t        long a2 = D.y - C.y; \n//\t        long b2 = C.x - D.x; \n//\t        long c2 = a2*(C.x)+ b2*(C.y); \n//\t       \n//\t        long determinant = a1*b2 - a2*b1; \n//\t       \n//\t        if (determinant == 0) \n//\t        { \n//\t            return false; \n//\t        } \n//\t        else\n//\t        { \n//\t            long x = (b2*c1 - b1*c2)/determinant; \n//\t            long y = (a1*c2 - a2*c1)/determinant; \n//\t            \n//\t            if(x>=0 || x<=1) {\n//\t            \treturn true;\n//\t            }\n//\t            return false;\n//\t        } \n//\t    }\n//\t    \n//\t    static Point getSlope(Line l) {\n//\t    \tlong num=l.p1.y - l.p2.y;\n//\t    \tlong den=l.p1.x - l.p2.x;\n//\t    \t\n//\t    \tlong gcd=gcd(num,den);\n//\t    \treturn new Point(num/gcd,den/gcd);\n//\t    }\n//\n//\t\tprivate static long gcd(long a, long b) {\n//\t\t\treturn b==0?a:gcd(b,a%b);\n//\t\t}\n//\t    \n//\t}\n\t\n\tstatic class Pair{\n\t\tint x;\n\t\tlong y;\n\t\t\n\t\tPair(int x,long y, Integer integer, int i){\n\t\t\tthis.y=y;\n\t\t\tthis.x=x;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x +\" \"+ y+\")\";\n\t\t} \n\t\t\n\t\t\n\t}\n\t\n\tstatic class Edge{\n\t\tint src;\n\t\tint dest;\n\t\tint cost;\n\t\tint val;\n\t\t\n\t\tEdge(int src,int dest,int cost,int val){\n\t\t\tthis.src=src;\n\t\t\tthis.dest=dest;\n\t\t\tthis.cost=cost;\n\t\t\tthis.val=val;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + src +\" \"+ dest+\": \"+ cost +\" , \"+val+\")\";\n\t\t} \n\t\t\n\t\t\n\t}\n\t\n    static class Pair2{\n    \tPair node;\n    \tint dist;\n    \t\n    \tPair2(Pair p,int dist){\n    \t\tnode=p;\n    \t\tthis.dist=dist;\n    \t}\n    }\n    \n    static long M=1000000007l;\n    static HashMap<Character,ArrayList<Character>> dirs;\n    \n    public static void main(String[] args) throws Exception {\n        FastReader sc=new FastReader();\n        BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));\n        \n//        ArrayList<Integer> prime=getPrimeSieve();\n        int t=sc.nextInt();\n        int po=0;\n        \n        dirs=new HashMap<>();\n        dirs.put('U', new ArrayList<>());\n        dirs.get('U').addAll(Arrays.asList('U','R','D','L'));\n        dirs.put('L', new ArrayList<>());\n        dirs.get('L').addAll(Arrays.asList('L','U','R','D'));\n        dirs.put('D', new ArrayList<>());\n        dirs.get('D').addAll(Arrays.asList('D','L','U','R'));\n        dirs.put('R', new ArrayList<>());\n        dirs.get('R').addAll(Arrays.asList('R','D','L','U'));\n//        \n        outer:while(t-- >0) {\n        \tpo++;\n        \tint n=sc.nextInt();\n        \tint x=(int) Math.sqrt(n/2);\n        \tint y=(int) Math.sqrt(n/4);\n        \t\n        \tif(x*x*2 == n || y*y*4==n)\n        \t\tbw.append(\"YES\\n\");\n        \telse {\n        \t\tbw.append(\"NO\\n\");\n        \t}\n//        \tint x=sc.nextInt();\n//        \tInteger[] arr=new Integer[n];\n//        \tlong sum=0;\n//        \t\n//        \tfor(int i=0;i<n;i++) {\n//        \t\tarr[i]=sc.nextInt();\n//        \t\tsum+=arr[i];\n//        \t}\n//        \t\n//        \tif(sum==x) {\n//    \t\t\tbw.append(\"NO\\n\");\n//    \t\t\tcontinue outer;\n//        \t}\n//\n//        \tArrays.sort(arr,Collections.reverseOrder());\n//        \t\n//        \tsum=0;\n//        \tfor(int i=0;i<n-1;i++) {\n//        \t\tsum+=arr[i];\n//        \t\t\n//        \t\tif(sum==x) {\n//        \t\t\tint temp=arr[i];\n//        \t\t\tarr[i+1]=arr[i];\n//        \t\t\tarr[i]=temp;\n//            \t\tsum=sum-arr[i+1]+arr[i];\n//        \t\t}\n//        \t}\n//        \tbw.append(\"YES\\n\");\n        \t\n//        \tfor(int i=0;i<n;i++) {\n//        \t\tbw.append(arr[i]+\" \");\n//        \t}\n//        \tbw.append(\"\\n\");\n//        \tbw.append(\"Case #\"+po+\": \"+0+\"\\n\");\n        }\n        bw.close();\n    }\n    \n    \n    \n\tprivate static int abs(int i) {\n\t\tif(i<0) {\n\t\t\treturn -i;\n\t\t}\n\t\treturn i;\n\t}\n\n\n\n\tprivate static String getRoaring2(String s) {\n\t\tString res=\"\";\n\t\tString max=\"\";\n\t\t\n\t\tfor(int i=1;i<=s.length()/2;i++) {\n\t\t\t\n\t\t\tlong prev=Long.parseLong(s.substring(0, i));\n\t\t\tres=Long.toString(prev);\n\t\t\tlong prev1=Long.parseLong(res);\n\t\t\tlong ans=Long.parseLong(s);\n\t\t\tlong next=prev+1;\n\t\t\t\n\t\t\twhile(prev1 <= ans) {\n\t\t\t\tprev1=Long.parseLong(res+Long.toString(next));\n\t\t\t\tres+=Long.toString(next);\n\t\t\t\tnext++;\n\t\t\t}\n\t\t\tif(max.length() == 0) {\n\t\t\t\tmax=res;\n\t\t\t\tres=\"\";\n\t\t\t}else {\n\t\t\t\tLong a=Long.parseLong(max);\n\t\t\t\tlong m=Math.max(a, prev1);\n\t\t\t\tmax=Long.toString(m);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tprivate static String getRoaring(String s) {\n\t\tint val=-1;\n\t\tfor(int i=1;i<=s.length()/2;i++) {\n\t\t\tlong prev=Long.parseLong(s.substring(0, i));\n\t\t\tint j=i,update=i;\n\t\t\t\n\t\t\twhile(j<s.length()) {\n\t\t\t\tif(numDigit(prev+1) > numDigit(prev)) {\n\t\t\t\t\tupdate++;\n\t\t\t\t}\n\t\t\t\tif(j+update > s.length()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlong cur=Long.parseLong(s.substring(j, j+update));\n\t\t\t\tif(cur != prev+1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t\tprev=cur;\n\t\t\t\tj+=update;\n\t\t\t}\n\t\t\t\n\t\t\tif(j>= s.length()) {\n\t\t\t\tval=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(val==-1) {\n\t\t\treturn \"\";\n\t\t}else {\n\t\t\tString res=\"\";\n\t\t\tlong prev=Long.parseLong(s.substring(0, val));\n\t\t\tres=Long.toString(prev+1);\n\t\t\tSystem.out.println(res+ \" \");\n\t\t\t\n\t\t\tlong prev1=Long.parseLong(res);\n\t\t\t\n\t\t\tlong ans=Long.parseLong(s);\n\t\t\t\n\t\t\tlong next=prev+1;\n\t\t\t\n\t\t\twhile(prev1 <= ans) {\n\t\t\t\tprev1=Long.parseLong(res+Long.toString(next));\n\t\t\t\tnext++;\n\t\t\t}\n\t\t\treturn Long.toString(prev1);\n\t\t}\n\t\t\n\t}\n\n\tprivate static boolean isRoaring(String s) {\n\t\tfor(int i=1;i<=s.length()/2;i++) {\n\t\t\tlong prev=Long.parseLong(s.substring(0, i));\n//\t\t\tSystem.out.println(\"prev= \"+prev+\" \");\n\t\t\tint j=i,update=i;\n\t\t\t\n\t\t\twhile(j<s.length()) {\n\t\t\t\tif(numDigit(prev+1) > numDigit(prev)) {\n\t\t\t\t\tupdate++;\n\t\t\t\t}\n\t\t\t\tif(j+update > s.length()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlong cur=Long.parseLong(s.substring(j, j+update));\n//\t\t\t\tSystem.out.println(\"cur= \"+cur+\" \");\n\t\t\t\tif(cur != prev+1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t\tprev=cur;\n\t\t\t\tj+=update;\n\t\t\t}\n\t\t\t\n\t\t\tif(j>= s.length()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static long numDigit(long ans) {\n\t\tlong sum=0;\n\t\twhile(ans > 0) {\n\t\t\tsum++;\n\t\t\tans/=10;\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate static boolean go(int i, int j, long n, long m, Integer k, HashMap<Integer, Boolean>[][] dp) {\n\t\tif(i==n && j==m && k==0) {\n\t\t\treturn true;\n\t\t}\n\t\tif(i<1 || j<1 || i>n || j>m || k<0) {\n\t\t\treturn false;\n\t\t}\n\t\tif(dp[i][j].containsKey(k)) {\n\t\t\treturn dp[i][j].get(k);\n\t\t}\n\t\t\n\t\tboolean down=go(i+1,j,n,m,k-j,dp);\n\t\tboolean left=go(i,j+1,n,m,k-i,dp);\n\t\t\n\t\tdp[i][j].put(k, left||down);\n\t\treturn left||down;\n\t}\n\n\n\tprivate static long getDigitSum(long ans) {\n\t\tlong sum=0;\n\t\twhile(ans > 0) {\n\t\t\tsum+=ans%10;\n\t\t\tans/=10;\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate static boolean getAns2(int l, long[] prefix, long x) {\n\t\t\n\t\tfor(int i=l;i<prefix.length-1;i++) {\n\t\t\tif((x^prefix[i]) == (prefix[prefix.length-1]^prefix[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static boolean getAns(long[] prefix) {\n\t\t\n\t\tfor(int i=0;i<prefix.length-1;i++) {\n\t\t\tif(prefix[i] == (prefix[prefix.length - 1]^prefix[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tprivate static void rotate(ArrayList<Integer> arr, int i) {\n\t\treverse(arr,0,i-1);\n\t\treverse(arr,i,arr.size()-1);\n\t\treverse(arr,0,arr.size()-1);\n\t}\n\n\tprivate static void reverse(ArrayList<Integer> arr, int l, int m) {\n\t\twhile(l<m) {\n\t\t\tint temp=arr.get(l);\n\t\t\tarr.set(l,arr.get(m));\n\t\t\tarr.set(m, temp);\n\t\t\tl++;\n\t\t\tm--;\n\t\t}\n\t}\n\n\tstatic int modInverse(int a, int m)\n    {\n        int m0 = m;\n        int y = 0, x = 1;\n \n        if (m == 1)\n            return 0;\n \n        while (a > 1) {\n            int q = a / m;\n \n            int t = m;\n\n            m = a % m;\n            a = t;\n            t = y;\n\n            y = x - q * y;\n            x = t;\n        }\n \n        if (x < 0)\n            x += m0;\n \n        return x;\n    }\n   \n\n\tprivate static long isPerfectSquare(long num) {\n\t\tlong l=1,h=num;\n\t\t\n\t\twhile(l<=h) {\n\t\t\tlong mid=l+(h-l)/2;\n\t\t\t\n\t\t\tif(mid*mid == num) {\n\t\t\t\treturn mid;\n\t\t\t}else if(mid*mid < num) {\n\t\t\t\tl=mid+1;\n\t\t\t}else {\n\t\t\t\th=mid-1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\n\tprivate static void rightmax(long[] arr, long n,int[] res,int[] rightmax) {\n    \t\n\t\tDeque<Integer> stack=new ArrayDeque<>();\n\t\t\n\t\tstack.clear();\n\t\tfor(int i=(int) (n-1);i>=0;i--) {\n\t\t\twhile(!stack.isEmpty() && arr[stack.peek()] <= arr[i]) {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\t\n\t\t\trightmax[i]=(stack.isEmpty()?Integer.MAX_VALUE:stack.peek());\n\t\t\tstack.addFirst(i);\n\t\t}\n\t}\n\t\n\t\n\n\tprivate static boolean rotatedSorted(long[] arr, int min) {\n\t\treverse(arr,0,min-1);\n\t\treverse(arr,min,arr.length-1);\n\t\treverse(arr,0,arr.length-1);\n\t\t\n\t\tif(isSorted(arr)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static boolean isSorted(long[] arr) {\n\t\tfor(int i=1;i<arr.length;i++) {\n\t\t\tif(arr[i] < arr[i-1]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static int countDigit(long x) {\n\t\tint count=0;\n\t\twhile(x > 0) {\n\t\t\tx/=10;\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\tprivate static boolean isSub(String s, String c) {\n\t\tint l=0;\n\t\t\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tif(l < c.length() && c.charAt(l)==s.charAt(i)) {\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(l==c.length()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(l==c.length()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic long power(long a, long d, long n)\n\t {\n\t\t    long res = 1; \n\t\t    a = a % n;\n\t\t    if (a == 0)\n\t\t      return 0; \n\t\t \n\t\t    while (d > 0)\n\t\t    {\n\t\t \n\t\t      if ((d & 1) != 0)\n\t\t        res = (res * a) % n;\n\t\t \n\t\t      d = d >> 1;\n\t\t      a = (a * a) % n;\n\t\t    }\n\t\t    return res;\n\t\t  }\n\n\tprivate static void reverse(long[] arr,int l,int m) {\n\t\twhile(l<m) {\n\t\t\tlong temp=arr[l];\n\t\t\tarr[l]=arr[m];\n\t\t\tarr[m]=temp;\n\t\t\tl++;\n\t\t\tm--;\n\t\t}\n\t}\n\n\t\n\t static int UpperBound(ArrayList<Integer> a, int x) {// x is the key or target value\n\t\t    int l=-1,r=a.size();\n\t\t    while(l+1<r) {\n\t\t       int m=(l+r)>>>1;\n\t\t       if(a.get(m)<=x) l=m;\n\t\t       else r=m;\n\t\t    }\n\t\t    return l+1;\n\t }\n\n\tprivate static void printMat(int[][] dp) {\n\t\t\n    \tSystem.out.println(\"--------------------------------------------------------------------\");\n\t\tfor(int i=0;i<dp.length;i++) {\n    \t\tfor(int j=0;j<dp[0].length;j++) {\n    \t\t\tSystem.out.print(dp[i][j]+\" \");\n    \t\t}\n    \t\tSystem.out.println();\n    \t}\n\t\tSystem.out.println(\"--------------------------------------------------------------------\");\n\t}\n   \n\tprivate static int highestOneBit(long n) {\n\t\tlong x=Long.highestOneBit(n);\n\t\tint c=0;\n\t\twhile(x >0) {\n\t\t\tx=x/2;\n\t\t\tc++;\n\t\t}\n\t\treturn c-1;\n\t}\n\t\n\tprivate static int bitcount(long l) {\n\t\tint count=0;\n\t\t\n    \twhile(l>0) {\n\t\t\tl-=(l&(-l));\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\n\tprivate static void bfs(HashMap<Integer, HashSet<Integer>> tree, int start) {\n    \tQueue<Integer> q=new LinkedList<>();\n\t\tq.offer(start);\n\t\tHashSet<Integer> visited=new HashSet<>();\n\t\t\n\t\tSystem.out.print(q.peek()+\"\\n\");\n\t\t\n\t\twhile(!q.isEmpty()) {\n\t\t\tint parent=q.poll();\n\t\t\t\n\t\t\tif(visited.contains(parent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisited.add(parent);\n\t\t\tint flag=0;\n\n\t\t\tfor(int child:tree.get(parent)) {\n\t\t\t\tif(!visited.contains(child)) {\n\t\t\t\t\tq.offer(child);\n\t\t\t\t\tSystem.out.print(child+\" \");\n\t\t\t\t\tflag=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag==0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic int par;\n\tprivate static HashMap<Integer, HashSet<Integer>> getTreeInputLevel(StringTokenizer st) {\n\t\tQueue<Integer> q=new LinkedList<>();\n\t\t\n\t\tHashMap<Integer, HashSet<Integer>> tree=new HashMap<>();\n\t\tq.offer(Integer.parseInt(st.nextToken()));\n\t\t\n\t\tpar=q.peek();\n\t\t\n\t\twhile(!q.isEmpty()) {\n\t\t\tint parent=q.poll();\n\t\t\t\n\t\t\tif(!tree.containsKey(parent)) {\n\t\t\t\ttree.put(parent, new HashSet<Integer>());\n\t\t\t}\n\t\t\t\n\t\t\tint left=-1,right=-1;\n\t\t\t\n\t\t\tif(st.hasMoreElements())\n\t\t\t\tleft=Integer.parseInt(st.nextToken());\n\t\t\t\n\t\t\tif(st.hasMoreElements())\n\t\t\t\tright=Integer.parseInt(st.nextToken());\n\t\t\t\n\t\t\tif(left != -1) {\n\t\t\t\ttree.get(parent).add(left);\n\t\t\t\tif(!tree.containsKey(left)) {\n\t\t\t\t\ttree.put(left, new HashSet<Integer>());\n\t\t\t\t}\n\t\t\t\ttree.get(left).add(parent);\n\t\t\t\tq.offer(left);\n\t\t\t}\n\t\t\t\n\t\t\tif(right != -1) {\n\t\t\t\ttree.get(parent).add(right);\n\t\t\t\tif(!tree.containsKey(right)) {\n\t\t\t\t\ttree.put(right, new HashSet<Integer>());\n\t\t\t\t}\n\t\t\t\ttree.get(right).add(parent);\n\t\t\t\tq.offer(right);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\ttree.remove(-1);\n\t\treturn tree;\n\t}\n\n\n\n\n\n\n\tprivate static int containsString(String s1,String s2) {\n\t\tString s=s1+\"#\"+s2;\n\t\tint[] z=getZfunc(s);\n\t\t\n\t\tboolean flag=false;\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tif(z[i]==s1.length()) {\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tint count=0;\n\t\t\n\t\tfor(int i=s1.length();i<z.length;i++) {\n//\t\t\tSystem.out.print(z[i]+\" \");\n\t\t\tif(z[i]==s1.length()) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println();\n\t\treturn count;\n\t}\n\n\n\tprivate static int[] getZfunc(String s) {\n\t\tint[] z=new int[s.length()];\n\t\t int l=0,r=0;\n\t\t \n\t\t for(int i=1;i<s.length();i++) {\n\t\t\t \n\t\t\t if(i <= r) {\n\t\t\t\t z[i]=Math.min( z[i-l] , r-i+1);\n\t\t\t }\n\t\t\t while(i+z[i] < s.length() && s.charAt(z[i])==s.charAt(i+z[i])) {\n\t\t\t\t z[i]++;\n\t\t\t }\n\t\t\t if(i+z[i] -1 > r) {\n\t\t\t\t l=i;\n\t\t\t\t r=i+z[i]-1;\n\t\t\t }\n\t\t\t \n\t\t }\n\t\treturn z;\n\t}\n\n\n\t\n\tprivate static long ceil(long n,long k) {\n\t\tlong ans;\n\t\tif(n%k==0) {\n\t\t\tans=n/k;\n\t\t}else {\n\t\t\tans=n/k+1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\n\tstatic ArrayList<Integer> getDivisor(int n){\n    \tArrayList<Integer> div=new ArrayList<>();\n    \t\n        for (int i=1; i*i <= n; i++) \n        { \n            if (n%i==0) \n            { \n                if (n/i == i) \n                    div.add(i); \n                else { \n                    div.add(i);\n                    div.add(n/i);\n                }\n            } \n        }\n        \n        return div;\n    }\n\t\n    static long gcd(long x,long y) {\n    \treturn (y==0?x:gcd(y,x%y));\n    }\n    \n\tstatic int MAXN = 1000001;\n\tstatic int[] spf=new int[MAXN];\n\t\n    static void sieveSmallestFactor() \n    { \n        spf[1] = 1;\n        \n        for (int i=2; i<MAXN; i++) \n        \tspf[i] = i;\n        \n        for (int i=4; i<MAXN; i+=2) \n            spf[i] = 2; \n       \n        \n        for (int i=3; i*i<MAXN; i++) \n        { \n            if (spf[i] == i) \n            { \n                for (int j=i*i; j<MAXN; j+=i) \n                    if (spf[j]==j) \n                        spf[j] = i; \n            } \n        } \n    } \n    \n    \n\tprivate static HashMap<Integer,Integer> PrimeFactorizationmap(long n) {\n\t\tint count=0;\n\t\t\n\t\tHashMap<Integer,Integer> factors=new HashMap<>();\n\t\tif(n==1) {\n\t\t\tfactors.put( 1,1);\n\t\t\treturn factors;\n\t\t}else {\n\t\t\tfor(long i=2; i*i <= n ;i++) {\n\t\t\t\tlong z=n;\n\t\t\t\tif(z%i==0) {\n\t\t\t\t\tcount=0;\n\t\t\t\t\twhile(z%i==0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tz=z/i;\n\t\t\t\t\t}\n\t\t\t\t\tfactors.put((int) (i+0),count);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(n>1) {\n\t\t\t\tfactors.put((int) (n+0),1);\n\t\t\t}\n\t\t}\n\t\treturn factors;\n\t}\n\t\n\n    \n    static HashMap<Integer,Integer> getprimeFactors(int n) \n    {\n        HashMap<Integer,Integer> ret = new HashMap<>();\n        while (n > 1) \n        { \n        \tif(ret.containsKey(spf[n])) {\n        \t\tret.put(spf[n],ret.get(spf[n])+1);\n        \t}else {\n        \t\tret.put(spf[(int) n],1);\n        \t}\n            n = n / spf[n]; \n        }\n        \n        return ret; \n    }\n    \n    static ArrayList<Integer> getPrimeSieve(){\n\t\tint primesieve[]=new int[1000005];\n\t\t\n\t\tArrays.fill(primesieve,0);\n\t\t\n\t\tfor(int i=2;i*i<primesieve.length;i++) {\n\t\t\tif(primesieve[i]==0)\t\n\t\t\t\tfor(int j=i*i;j<primesieve.length;j+=i) {\t\n\t\t\t\t\t\tprimesieve[j]=1;\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tArrayList<Integer> prime=new ArrayList<>();\n\t\tfor(int i=2;i<primesieve.length;i++) {\n\t\t\tif(primesieve[i]==0) {\n\t\t\t\tprime.add(i);\n\t\t\t}\n\t\t}\n\t\treturn prime;\n    }\n    \n    \n    \n    \n\tprivate static boolean checkPrimeRM(long n,int k) {\n\t\tif(n<=4) {\n\t\t\treturn n==2||n==3;\n\t\t}\n\t\t\n\t\tint s=0;\n\t\tlong d=n-1;\n\t\t\n\t\twhile((d&1) != 1) {\n\t\t\td=d/2;\n\t\t\ts++;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<k;i++) {\n\t\t\tlong a=2+(int)Math.random()*(n-4);\n\t\t\tif(isComposite(a,s,d,n)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static boolean isComposite(long a, int s, long d, long n) {\n\t\tlong x=power(a,d,n);\n\t\t\n\t\tif(x==1 || x==n-1) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<s;i++){\n\t\t\tif(x%(n-1)==0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tx=(x*x)%n;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n    \n    public static HashSet<Long> getPrimeLtoR(int l,int r,List<Integer> prime) {\n\t\tif(l==1) l++;\n\t\t\n\t\tint[] arr=new int[r-l+1];\n\t\t\n\t\tArrays.fill(arr,0);\n\t\t\n\t\tfor(int i: prime ){\n\n\t\t\tif(i*i<=r) {\n\t\t\t\t\n\t\t\t\tint j=(l/i)*i;\n\t\t\t\tif(j<l) \n\t\t\t\t\tj+=i;\n\t\t\t\tfor(;j<=r;j+=i) {\n\t\t\t\t\tif(j!=i)\n\t\t\t\t\t\tarr[j-l]=1;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tHashSet<Long> primeLtoR=new HashSet<>();\n\t\t\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tif(arr[i]==0) {\n\t\t\t\tprimeLtoR.add((i+l+0l));\n\t\t\t}\n\t\t}\n\t\treturn primeLtoR;\n\t}\n}", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Solution {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer st;\n\n    int n, k;\n\n    boolean[] prime;\n    int[] primes;\n\n    void sieve() {\n        prime = new boolean[n + 1];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        int cnt = 0;\n        for (int i = 2; i <= n; ++i)\n            if (prime[i]) {\n                ++cnt;\n                for (int j = i + i; j <= n; j += i)\n                    prime[j] = false;\n            }\n        primes = new int[cnt];\n        cnt = 0;\n        for (int i = 0; i <= n; ++i)\n            if (prime[i])\n                primes[cnt++] = i;\n    }\n\n    void solve() throws IOException {\n        n = ni();\n        k = ni();\n        sieve();\n        int cnt = 0;\n        for (int i = 2; i <= n; ++i) {\n            if (!prime[i])\n                continue;\n            boolean ok = false;\n            for (int j = 0; j < primes.length - 1; ++j)\n                if (primes[j] + primes[j + 1] + 1 == i) {\n                    ok = true;\n                    break;\n                }\n            if (ok)\n                ++cnt;\n        }\n        if (cnt >= k)\n            out.println(\"YES\");\n\n        else\n            out.println(\"NO\");\n    }\n\n    public Solution() throws IOException {\n        Locale.setDefault(Locale.US);\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        in.close();\n        out.close();\n    }\n\n    String ns() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.valueOf(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.valueOf(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.valueOf(ns());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Solution();\n    }\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "//package round455;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class C {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint mod = 1000000007;\n\t\tlong[] dp = new long[5005];\n\t\tdp[0] = 1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tchar c = nc();\n\t\t\tif(c == 's'){\n\t\t\t\tif(i < n-1){\n\t\t\t\t\tfor(int j = 5003;j >= 0;j--){\n\t\t\t\t\t\tdp[j] += dp[j+1];\n\t\t\t\t\t\tif(dp[j] >= mod)dp[j] -= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 5003;j >= 0;j--){\n\t\t\t\t\tdp[j+1] = dp[j];\n\t\t\t\t}\n\t\t\t\tdp[0] = 0;\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tfor(int i = 0;i < 5005;i++)ans += dp[i];\n\t\tout.println(ans % mod);\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new C().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int r = in.nextInt();\n            int[] x = in.nextIntArray(n);\n            double[] py = new double[n];\n            for (int i = 0; i < n; i++) {\n                double y = r;\n                for (int j = 0; j < i; j++) {\n                    int dx = Math.abs(x[i] - x[j]);\n                    if (dx > 2 * r) continue;\n                    y = Math.max(y, Math.sqrt(4 * r * r - dx * dx) + py[j]);\n                }\n                py[i] = y;\n            }\n            for (int i = 0; i < n; i++) {\n                out.printf(\"%.10f%s\", py[i], i == n - 1 ? \"\\n\" : \" \");\n            }\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class task2\n{\t\n\tpublic static void main( String[] args ) throws IOException\n\t{\n\t\tReader.init(System.in);\n\t\tint a = Reader.nextInt();\n\t\tint b = Reader.nextInt();\n\t\tint c = Reader.nextInt();\n\t\tint n = Reader.nextInt();\n\t\tboolean flag = false;\n\t\tif ( c <= a )\n\t\t{\n\t\t\ta = a - c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag= true;\n\t\t}\n\t\tif ( c <=b )\n\t\t{\n\t\t\tb = b - c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag = true;\n\t\t}\n\t\tif( flag == false )\n\t\t{\n\t\t\tint d = a+b+c;\n\t\t\tint res = n - d;\n\t\t\tif ( res >= 1 )\n\t\t\t{\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t}\n}\n\nclass Ink\n{\n\tlong req;\n\tlong price;\n}\n\nclass InkComp implements Comparator<Ink> \n{\t \n    public int compare(Ink emp1, Ink emp2) \n    {\n        return (int) (emp1.req - emp2.req);\n    }\n}\n\nclass Reader \n{\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    static void init(InputStream input) \n    {\n        reader = new BufferedReader(new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n   \n    static String next() throws IOException \n    {\n        while ( ! tokenizer.hasMoreTokens() ) \n        {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException \n    {\n        return Integer.parseInt( next() );\n    }\n    \n    static double nextDouble() throws IOException \n    {\n        return Double.parseDouble( next() );\n    }\n    \n    static long nextLong() throws IOException \n    {\n        return Long.parseLong( next() );\n    }\n}", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.util.Arrays;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class LittleGirlandMaximumXOR {\n\n\n\n\tstatic long l, r;\n\n\tstatic long[][] dp;\n\n\n\n\tstatic boolean bit(long x, int i) {\n\n\t\treturn (x & (1L << (long) i)) != 0;\n\n\t}\n\n\n\n\tstatic long solve(int i, int a, int b, int c, int d) {\n\n\t\tif (i == -1)\n\n\t\t\treturn 0;\n\n\t\tint mask = (a << 3) | (b << 2) | (c << 1) | d;\n\n\t\tif (dp[i][mask] != -1)\n\n\t\t\treturn dp[i][mask];\n\n\t\tlong ans = 0;\n\n\t\tboolean bl = bit(l, i);\n\n\t\tboolean br = bit(r, i);\n\n\t\t// 0 0\n\n\t\tif ((a == 1 || !bl) && (c == 1 || !bl))\n\n\t\t\tans = solve(i - 1, a, br ? 1 : b, c, br ? 1 : d);\n\n\t\t// 1 1\n\n\t\tif ((b == 1 || br) && (d == 1 || br))\n\n\t\t\tans = Math.max(ans, solve(i - 1, !bl ? 1 : a, b, !bl ? 1 : c, d));\n\n\t\t// 0 1\n\n\t\tif ((a == 1 || !bl) && (d == 1 || br))\n\n\t\t\tans = Math.max(\n\n\t\t\t\t\tans,\n\n\t\t\t\t\t(1L << (long) i)\n\n\t\t\t\t\t\t\t+ solve(i - 1, a, br ? 1 : b, !bl ? 1 : c, d));\n\n\t\t// 1 0\n\n\t\tif ((b == 1 || br) && (c == 1 || !bl))\n\n\t\t\tans = Math.max(\n\n\t\t\t\t\tans,\n\n\t\t\t\t\t(1L << (long) i)\n\n\t\t\t\t\t\t\t+ solve(i - 1, !bl ? 1 : a, b, c, br ? 1 : d));\n\n\t\treturn dp[i][mask] = ans;\n\n\t}\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tout = new PrintWriter(System.out);\n\n\t\tsc = new StringTokenizer(\"\");\n\n\t\tl = nxtLng();\n\n\t\tr = nxtLng();\n\n\t\tdp = new long[61][1 << 4];\n\n\t\tfor (long[] a : dp)\n\n\t\t\tArrays.fill(a, -1);\n\n\t\tout.println(solve(60, 0, 0, 0, 0));\n\n\t\tbr.close();\n\n\t\tout.close();\n\n\t}\n\n\n\n\tstatic BufferedReader br;\n\n\tstatic StringTokenizer sc;\n\n\tstatic PrintWriter out;\n\n\n\n\tstatic String nxtTok() throws IOException {\n\n\t\twhile (!sc.hasMoreTokens()) {\n\n\t\t\tString s = br.readLine();\n\n\t\t\tif (s == null)\n\n\t\t\t\treturn null;\n\n\t\t\tsc = new StringTokenizer(s.trim());\n\n\t\t}\n\n\t\treturn sc.nextToken();\n\n\t}\n\n\n\n\tstatic int nxtInt() throws IOException {\n\n\t\treturn Integer.parseInt(nxtTok());\n\n\t}\n\n\n\n\tstatic long nxtLng() throws IOException {\n\n\t\treturn Long.parseLong(nxtTok());\n\n\t}\n\n\n\n\tstatic double nxtDbl() throws IOException {\n\n\t\treturn Double.parseDouble(nxtTok());\n\n\t}\n\n\n\n\tstatic int[] nxtIntArr(int n) throws IOException {\n\n\t\tint[] a = new int[n];\n\n\t\tfor (int i = 0; i < n; i++)\n\n\t\t\ta[i] = nxtInt();\n\n\t\treturn a;\n\n\t}\n\n\n\n\tstatic long[] nxtLngArr(int n) throws IOException {\n\n\t\tlong[] a = new long[n];\n\n\t\tfor (int i = 0; i < n; i++)\n\n\t\t\ta[i] = nxtLng();\n\n\t\treturn a;\n\n\t}\n\n\n\n\tstatic char[] nxtCharArr() throws IOException {\n\n\t\treturn nxtTok().toCharArray();\n\n\t}\n\n}", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "/**\n * @author derrick20\n */\nimport java.io.*;\nimport java.util.*;\n\npublic class SameSumBlocks {\n    public static void main(String[] args) throws Exception {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int N = sc.nextInt();\n        int[] pre = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            pre[i] = pre[i - 1] + sc.nextInt();\n        }\n        var sumMap = new HashMap<Integer, ArrayList<Pair>>();\n        for (int i = 1; i <= N; i++) {\n            for (int j = i; j <= N; j++) {\n                int sum = pre[j] - pre[i - 1];\n                sumMap.computeIfAbsent(sum, val -> new ArrayList<>()).add(new Pair(i, j));\n            }\n        }\n        var ans = new ArrayList<Pair>();\n        for (var list : sumMap.values()) {\n            Collections.sort(list, Comparator.comparingInt(p -> p.r));\n            // greedily schedule the intervals\n            int last = 0;\n            var group = new ArrayList<Pair>();\n            for (Pair p : list) {\n                if (p.l > last) {\n                    group.add(p);\n                    last = p.r;\n                }\n            }\n            if (group.size() > ans.size()) {\n                ans = group;\n            }\n        }\n        out.println(ans.size());\n        for (Pair p : ans) {\n            out.println(p);\n        }\n        out.close();\n    }\n\n    static class Pair {\n        int l, r;\n        public Pair(int ll, int rr) {\n            l = ll; r = rr;\n        }\n        public String toString() {\n            return l + \" \" + r;\n        }\n    }\n\n    static class FastScanner {\n        private int BS = 1<<16;\n        private char NC = (char)0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n\n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n\n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            }\n            catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n\n        private char getChar(){\n            while(bId==size) {\n                try {\n                    size = in.read(buf);\n                }catch(Exception e) {\n                    return NC;\n                }\n                if(size==-1)return NC;\n                bId=0;\n            }\n            return (char)buf[bId++];\n        }\n\n        public int nextInt() {\n            return (int)nextLong();\n        }\n\n        public int[] nextInts(int N) {\n            int[] res = new int[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = (int) nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongs(int N) {\n            long[] res = new long[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long nextLong() {\n            cnt=1;\n            boolean neg = false;\n            if(c==NC)c=getChar();\n            for(;(c<'0' || c>'9'); c = getChar()) {\n                if(c=='-')neg=true;\n            }\n            long res = 0;\n            for(; c>='0' && c <='9'; c=getChar()) {\n                res = (res<<3)+(res<<1)+c-'0';\n                cnt*=10;\n            }\n            return neg?-res:res;\n        }\n\n        public double nextDouble() {\n            double cur = nextLong();\n            return c!='.' ? cur:cur+nextLong()/cnt;\n        }\n\n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while(c<=32)c=getChar();\n            while(c>32) {\n                res.append(c);\n                c=getChar();\n            }\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while(c<=32)c=getChar();\n            while(c!='\\n') {\n                res.append(c);\n                c=getChar();\n            }\n            return res.toString();\n        }\n\n        public boolean hasNext() {\n            if(c>32)return true;\n            while(true) {\n                c=getChar();\n                if(c==NC)return false;\n                else if(c>32)return true;\n            }\n        }\n    }\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "/*\n * PDPM IIITDM Jabalpur\n * Asutosh Rana\n */\n\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n\tlong MOD = 1000000007;\n\tInputReader in;\n\tBufferedReader br;\n\tPrintWriter out;\n\n\tpublic static void main(String[] args) throws java.lang.Exception {\n\t\tMain solver = new Main();\n\t\tsolver.in = new InputReader(System.in);\n\t\tsolver.br = new BufferedReader(new InputStreamReader(System.in));\n\t\tsolver.out = new PrintWriter(System.out);\n\t\tsolver.solve();\n\t\tsolver.out.flush();\n\t\tsolver.out.close();\n\t}\n\n\tpublic void solve() {\n\n\t\tint tc = 1;//in.readInt();\n\n\t\tfor (int cas = 1; cas <= tc; cas++) {\n\t\t\tint N = in.readInt();\n\t\t\tint[] A = new int[N];\n\t\t\tin.readInt(A);\n\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\t\tif(A[i]>A[j])\n\t\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = res % 2;\n\t\t\t\n\t\t\tint Q = in.readInt();\n\t\t\twhile(Q-->0){\n\t\t\t\tint l = in.readInt();\n\t\t\t\tint r = in.readInt();\n\t\t\t\tint add = (r-l+1)/2;\n\t\t\t\tres = res + add;\n\t\t\t\tres%=2;\n\t\t\t\tout.println(res%2==0?\"even\":\"odd\");\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\nclass InputReader {\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic void readInt(int[] A) {\n\t\tfor (int i = 0; i < A.length; i++)\n\t\t\tA[i] = readInt();\n\t}\n\n\tpublic long readLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic void readLong(long[] A) {\n\t\tfor (int i = 0; i < A.length; i++)\n\t\t\tA[i] = readLong();\n\t}\n\n\tpublic double readDouble() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tdouble res = 0;\n\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t}\n\t\tif (c == '.') {\n\t\t\tc = read();\n\t\t\tdouble m = 1;\n\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tm /= 10;\n\t\t\t\tres += (c - '0') * m;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t}\n\t\treturn res * sgn;\n\t}\n\n\tpublic char[] readCharA() {\n\t\treturn readString().toCharArray();\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic String next() {\n\t\treturn readString();\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n\n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;   \n   \npublic class Main   \n{   \n public static void main(String[] args)   \n {   \n  Scanner keyboard = new Scanner(System.in);   \n  int size = Integer.parseInt(keyboard.nextLine());   \n  int[] arr = new int[size];   \n  int i = 0;   \n  while( size != 0 )   \n  {    \n   arr[i] = keyboard.nextInt();   \n   size--;    \n   i++;   \n  }   \n   \n  if( arr.length == 1 )    \n  {   \n   System.out.println(\"NO\");   \n  }   \n  else   \n  {   \n   Arrays.sort(arr);   \n   boolean val = false;   \n   int ans = 0;   \n   for ( i = 0; i< arr.length-1 ; i++ )   \n   {   \n    if( arr[i] != arr[i+1] )   \n    {   \n     val = true;   \n     ans = arr[i+1];   \n     System.out.println(ans);   \n     i = arr.length;   \n    }    \n    else if( i == arr.length-2 ) //val == false  \n    {   \n     System.out.println(\"NO\");      \n    }   \n   }   \n  }\n }\n}", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.*;\npublic class Main{\n    static int solve(int x,int y,int moves,int[][][] dp,int[][] xf,int[][] xb,int[][] yf,int[][] yb,int r,int c){\n        if(moves==0) return 0;\n        if(dp[x][y][moves]!=-1) return dp[x][y][moves];\n        int ans=Integer.MAX_VALUE;\n        if(x-1>=0){\n            ans=Math.min(ans,solve(x-1,y,moves-1,dp,xf,xb,yf,yb,r,c)+yb[x][y]);\n        }\n        if (x + 1 < r) {\n            ans=Math.min(ans,solve(x+1,y,moves-1,dp,xf,xb,yf,yb,r,c)+yf[x][y]);\n        }\n        if(y-1>=0){\n            ans=Math.min(ans,solve(x,y-1,moves-1,dp,xf,xb,yf,yb,r,c)+xb[x][y]);\n        }\n        if (y + 1 < c) {\n            ans=Math.min(ans,solve(x,y+1,moves-1,dp,xf,xb,yf,yb,r,c)+xf[x][y]);\n        }\n        dp[x][y][moves]=ans;\n        return ans;\n    }\n    public static void main(String[] args)\n    {\n        Scanner obj=new Scanner(System.in);\n        int n=obj.nextInt();\n        int m=obj.nextInt();\n        int k=obj.nextInt();\n        int[][][] dp=new int[n][m][k];\n        int xf[][]=new int[n][m]; //ith row ,j->j+1 dist\n        int xb[][]=new int[n][m];  //ith row , j->j-1 dist\n        int yf[][]=new int[n][m]; //jth column,ith row->i+1 row\n        int yb[][]=new int[n][m]; //jth column,ith row->i-1 row\n        int c;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m-1;j++){\n                c=obj.nextInt();\n                xf[i][j]=c;\n                xb[i][j+1]=c;\n            }\n        }\n        for(int i=0;i<n-1;i++){\n            for(int j=0;j<m;j++){\n                c=obj.nextInt();\n                yf[i][j]=c;\n                yb[i+1][j]=c;\n            }\n        }\n        if(k%2==1){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<m;j++) {\n                    System.out.print(-1+\" \");\n                }\n                System.out.println();\n            }\n        }else{\n            for(int i=0;i<n;i++){\n                for(int j=0;j<m;j++){\n                    for(int k1=0;k1<k;k1++){\n                        dp[i][j][k1]=-1;\n                    }\n                }\n            }\n            for(int i=0;i<n;i++) {\n                for (int j = 0; j < m; j++) {\n                    System.out.print(2*solve(i,j,k/2,dp,xf,xb,yf,yb,n,m)+\" \");\n                }\n                System.out.println();\n            }\n\n        }\n    }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ijxjdjd\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        SameSumBlocks solver = new SameSumBlocks();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class SameSumBlocks {\n        int N;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            N = in.nextInt();\n            int[] arr = new int[N];\n            for (int i = 1; i <= N; i++) {\n                arr[i - 1] = in.nextInt();\n            }\n            HashMap<Integer, ArrayList<Segment>> map = new HashMap<>();\n            for (int i = 1; i <= N; i++) {\n                int sum = 0;\n                for (int j = i; j <= N; j++) {\n                    sum += arr[j - 1];\n                    map.putIfAbsent(sum, new ArrayList<>());\n                    map.get(sum).add(new Segment(i, j));\n                }\n            }\n            int resI = 0;\n            int resVal = 0;\n            int sum = 0;\n            if (arr.length > 1 && arr[1] == -999) {\n                for (int i = 11; i < 130; i++) {\n                    sum += arr[i];\n                }\n            }\n            for (int key : map.keySet()) {\n                if (map.get(key).size() > resI) {\n                    int next = largestNon(map.get(key));\n                    if (next > resI) {\n                        resVal = key;\n                        resI = next;\n                    }\n                }\n            }\n            Pair res = largestNonOverlap(map.get(resVal));\n            out.println(resI);\n            for (int i = 0; i < resI; i++) {\n                out.println(res.used.get(i).li + \" \" + res.used.get(i).ri);\n            }\n        }\n\n        int largestNon(ArrayList<Segment> arr) {\n            Collections.sort(arr, new Comparator<Segment>() {\n\n                public int compare(Segment o1, Segment o2) {\n                    return Integer.compare(o1.ri, o2.ri);\n                }\n            });\n            SameSumBlocks.SegmentTree seg = new SameSumBlocks.SegmentTree(N + 1);\n            for (int i = 0; i < arr.size(); i++) {\n                seg.add(arr.get(i).ri, arr.get(i).ri, 1 + seg.query(0, arr.get(i).li - 1).mx);\n            }\n            return seg.query(0, N).mx;\n        }\n\n        Pair largestNonOverlap(ArrayList<Segment> arr) {\n            Segment[] segs = new Segment[N + 1];\n            int[] dp = new int[N + 1];\n            for (int i = 0; i <= N; i++) {\n                segs[i] = new Segment(-1, 0);\n            }\n            for (Segment s : arr) {\n                if (s.li > segs[s.ri].li) {\n                    segs[s.ri] = s;\n                }\n            }\n            int[] used = new int[N + 1];\n            for (int i = 1; i <= N; i++) {\n                dp[i] = dp[i - 1];\n                used[i] = used[i - 1];\n                if (segs[i].li != -1) {\n                    if (dp[i] < dp[segs[i].li - 1] + 1) {\n                        used[i] = i;\n                        dp[i] = dp[segs[i].li - 1] + 1;\n                    }\n                }\n            }\n            ArrayList<Segment> res = new ArrayList<>();\n            int u = used[N];\n            while (segs[u].li > 0) {\n                res.add(segs[u]);\n                u = used[segs[u].li - 1];\n            }\n            return new Pair(dp[N], res);\n        }\n\n        class Segment {\n            int li;\n            int ri;\n\n            Segment() {\n            }\n\n            Segment(int li, int ri) {\n                this.li = li;\n                this.ri = ri;\n            }\n\n        }\n\n        class Pair {\n            int val;\n            ArrayList<Segment> used = new ArrayList<>();\n\n            Pair(int val, ArrayList<Segment> used) {\n                this.val = val;\n                this.used = used;\n            }\n\n        }\n\n        static class SegmentTree {\n            Node[] tree;\n            int size = 0;\n\n            public Node none() {\n                //return a node that will do nothing while merging: ex. Infinity for min query, -Infinity for max query, 0 for sum\n                Node res = new Node();\n                return res;\n            }\n\n            public SegmentTree(int N) {\n                tree = new Node[4 * N];\n                size = N;\n                for (int i = 0; i < 4 * N; i++) {\n                    tree[i] = new Node();\n                }\n            }\n\n            Node combine(Node a, Node b) {\n                //change when doing different operations\n                Node res = new Node();\n                res.mx = Math.max(a.mx, b.mx);\n                return res;\n            }\n\n            public Node query(int l, int r) {\n                return queryUtil(1, 0, size - 1, l, r);\n            }\n\n            public Node queryUtil(int n, int tl, int tr, int l, int r) {\n                //node number, cur range of node, cur range of query\n                if (l > r) {\n                    return none();\n                }\n                if (tl == l && tr == r) {\n                    return tree[n];\n                }\n                int tm = (tl + tr) / 2;\n                return combine(queryUtil(2 * n, tl, tm, l, Math.min(r, tm)), queryUtil(2 * n + 1, tm + 1, tr, Math.max(tm + 1, l), r));\n            }\n\n            public void add(int l, int r, int val) {\n                //change query, not assignment\n                addUtil(1, 0, size - 1, l, r, val);\n            }\n\n            public void addUtil(int n, int tl, int tr, int l, int r, int val) {\n                if (l > r) {\n                    return;\n                }\n                if (tl == l && tr == r) {\n                    tree[n].update(val);\n                } else {\n                    int tm = (tl + tr) / 2;\n                    addUtil(2 * n, tl, tm, l, Math.min(tm, r), val);\n                    addUtil(2 * n + 1, tm + 1, tr, Math.max(l, tm + 1), r, val);\n                    tree[n] = combine(tree[2 * n], tree[2 * n + 1]);\n                }\n            }\n\n            class Node {\n                int mx = 0;\n                int lzy = 0;\n\n                void update(int val) {\n                    mx = Math.max(mx, val);\n                    lzy += val;\n                }\n\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.util.*;\npublic class D\n{\n public static void main(String args[])\n  {\n   int n;\n   Scanner in = new Scanner (System.in);\n   n= in.nextInt();\n   if (n%4==0 || n%7==0 || n%44==0 || n%47==0 || n%444==0 || n%447==0 ||\n       n%474==0 || n%477==0 || n%744==0 || n%747==0 || n%774==0 || n%777==0)\n       System.out.println(\"YES\"); else System.out.println(\"NO\");\n  }\n}\n\t\t \t\t \t \t  \t \t\t\t \t  \t \t \t", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\npublic class Main\n{\n    static MyScanner scan;\n    static PrintWriter pw;\n    public static void main(String[] args) {\n        new Thread(null,null,\"_\",1<<25)\n        {\n            public void run()\n            {\n                try\n                {\n                    solve();\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n    static void solve() throws IOException {\n        scan = new MyScanner();\n        pw = new PrintWriter(System.out, true);\n        StringBuilder sb = new StringBuilder();\n        int n = ni();\n        int d = ni();\n        int arr[] = new int[n];\n        int cnt = 2;\n        for(int i=0;i<n;++i)\n            arr[i] = ni();\n        for(int i=0;i<n-1;++i)\n        {\n            if(arr[i+1]-d==arr[i]+d)\n            {\n                ++cnt;\n                continue;\n            }\n            if(arr[i+1]-(arr[i]+d)>d)\n                ++cnt;\n            if((arr[i+1]-d)-arr[i]>d)\n                ++cnt;\n        }\n        pl(cnt);\n        pw.flush();\n        pw.close();\n    }\n    static long MMI(long A,long MOD)\n    {\n        return modpow(A,MOD-2,MOD);\n    }\n    static long modpow(long x,long y,long MOD)\n    {\n        if(y==0)\n            return 1;\n        if((y&1)==0)\n            return modpow((x*x)%MOD,y>>1,MOD);\n        else return (x*modpow(x,y-1,MOD))%MOD;\n    }\n    static class Pair implements Comparable<Pair>\n    {\n        int x,y;\n        Pair(int x,int y)\n        {\n            this.x=x;\n            this.y=y;\n        }\n        public int compareTo(Pair other)\n        {\n            if(this.x!=other.x)\n                return this.x-other.x;\n            return this.y-other.y;\n        }\n        public String toString()\n        {\n            return \"{\"+x+\",\"+y+\"}\";\n        }\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static String ne() throws IOException\n    {\n        return scan.next();\n    }\n    static String nel() throws IOException\n    {\n        return scan.nextLine();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static class MyScanner\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        MyScanner()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String nextLine()throws IOException\n        {\n            return br.readLine();\n        }\n        String next() throws IOException\n        {\n            if(st==null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        int nextInt() throws IOException\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong() throws IOException\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble() throws IOException\n        {\n            return Double.parseDouble(next());\n        }\n    }\n}", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\nimport java.util.Scanner;\n\npublic class Pipeline3 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong n = sc.nextLong();\n\t\tlong k = sc.nextLong();\n\t\t\n\t    if(n==1)\n\t    {\n\t    \tSystem.out.println(\"0\");\n\t    }else  if(n <= k)\n\t    {\n\t    \tSystem.out.println(\"1\");\n\t    }\n\t    else\n\t    {\n\t    \tk--;\n\t    \tn--;\n\t    \t\n\t    \tif(sum(k) < n)\n\t    \t\tSystem.out.println(-1);\n\t    \telse\n\t    \t{\n\t    \t\tSystem.out.println(minCalc(n, k));\n\t    \t}\n\t    \t\n\t    }\n\n\t}\n\t\n\t\n\tprivate static long minCalc(long n, long k) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tlong start= 1; \n\t\tlong end = k;\n\t\t\n\t\twhile(start< end)\n\t\t{\n\t\t\tlong mid = (start + end)/2;\n\t\t\t\n\t\t\tlong sum =sum(mid , k);\n\t\t\t\n\t\t\tif(sum == n)\n\t\t\t{\n\t\t\t\treturn k - mid +1;\n\t\t\t}\n\t\t\tif(sum > n)\n\t\t\t\tstart = mid + 1;\n\t\t\telse\n\t\t\t\tend = mid;\n\t\t\t\t\n\t\t}\n\t\treturn k-start + 2;\n\t\t\n\t}\n\n\n\tpublic static long sum(long n)\n\t{\n\t\treturn  n*(n+1)/2;\n\t}\n\tpublic static long sum(long s, long e)\n\t{\n\t\tif(s <= 1)\n\t\t\treturn sum(e);\n\t\telse\n\t\t\treturn sum(e) - sum(s-1);\n\t}\n\n}\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "\nimport java.util.*;\n\n\npublic class main {\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int houses = sc.nextInt();\n        int size = sc.nextInt();\n        hizzy[] array = new hizzy[houses];\n        long total =2;\n        for(int a=0;a<houses;a++)array[a]=new hizzy(sc.nextInt(),sc.nextInt());\n        Arrays.sort(array);\n        for(int a=0;a<houses-1;a++){\n            double L = array[a].loc+array[a].size/2;\n            double R = array[a+1].loc-array[a+1].size/2;\n            if(R-L>size)total+=2;\n            else if((R-L)==size)total++;\n        }\n        System.out.println(total);\n    }   \n\n}\nclass hizzy implements Comparable{\n    double loc;\n    double size;\n    hizzy(double l, double s){\n        this.loc=l;\n        this.size=s;\n    }\n    \n    public int compareTo(Object o) {\n        hizzy other = (hizzy) o;\n        return (int) (this.loc-other.loc);\n    }\n    \n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int t=sc.nextInt();\n        while(t-->0)\n        {\n            int n=sc.nextInt();\n            if(n%2==1)\n            {\n                System.out.println(\"NO\");\n                continue;\n            }\n            // squares of 2\n            int num=n/2;\n            int root = (int)Math.sqrt(num);\n            if(root*root==num)\n            {\n                System.out.println(\"YES\");\n                continue;\n            }\n            // squares of 4\n            if(n%4!=0)\n            {\n                System.out.println(\"NO\");\n                continue;\n            }\n            num = n/4;\n            root = (int) Math.sqrt(num);\n            if(root*root==num)\n            {\n                System.out.println(\"YES\");\n            }\n            else\n            {\n                System.out.println(\"NO\");\n            }\n        }\n    }\n}", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport static java.lang.Math.*;\n\npublic class Main{\n    \n    public void go(){\n        int n=sc.nextInt(), k=sc.nextInt(), A=sc.nextInt();\n        ArrayList< ArrayList< Integer > > waysGiveCandies = doit1(n, k, new ArrayList< Integer >());\n/*\n        System.out.printf(\"%d\\n\", waysGiveCandies.size());\n        for(ArrayList< Integer > x : waysGiveCandies){\n            for(int i : x)\n                System.out.printf(\"%d \", i);\n            System.out.printf(\"\\n\");\n        }\n*/\n        int[] lvl = new int[n], loyal = new int[n];\n        for(int i=0; i<n; ++i){\n            lvl[i] = sc.nextInt();\n            loyal[i] = sc.nextInt();\n        }\n\n        double ret = 0;\n        for(ArrayList< Integer > distribution : waysGiveCandies){\n            double[] Loyal = new double[n];\n            for(int i=0; i<n; ++i) Loyal[i] = min(loyal[i]+10*distribution.get(i), 100)/100.0;\n            double pWin = 0;\n            for(int i=0; i<1<<n; ++i){\n                double pVoteOccurs = 1;\n                for(int j=0; j<n; ++j) \n                    if((i&(1<<j))!=0) // if winner\n                        pVoteOccurs *= Loyal[j];\n                    else // if loser\n                        pVoteOccurs *= 1-Loyal[j];\n\n                int B = 0;\n                for(int j=0; j<n; ++j) if((i&(1<<j))==0)\n                    B += lvl[j];\n                double pWinFight = (double)A/(A+B);\n\n                // if win vote, don't need to fight\n                if(bit_count(i)*2 > n)\n                    pWinFight = 1;\n\n                pWin += pVoteOccurs * pWinFight;\n            }\n            ret = max(ret, pWin);\n        }\n\n        System.out.printf(\"%.9f\\n\", ret);\n    }\n\n    ArrayList< ArrayList< Integer > > doit1(int n, int k, ArrayList< Integer > soFar){\n        ArrayList< ArrayList< Integer > > ret = new ArrayList< ArrayList< Integer > >();\n        \n        // base case\n        if(n==1){\n            soFar.add(k);\n            ret.add(soFar);\n            return ret;\n        }\n\n        // general case\n        for(int i=0; i<k+1; ++i){\n            ArrayList< Integer > tmp = new ArrayList< Integer >(soFar);\n            tmp.add(i);\n            ret.addAll(doit1(n-1, k-i, tmp));\n        }\n\n        return ret;\n    }\n\n    // syntax\n    // ArrayList<Integer>[] myMat = (ArrayList<Integer>[]) new ArrayList[nB];\n\n    // Pairs\n    public class ii implements Comparable< ii >{\n        int x, y;\n        public ii(){}\n        public ii(int xx, int yy){ x=xx; y=yy; }\n        public int compareTo(ii p){ return x!=p.x ? x-p.x : y-p.y; }\n        public int hashCode(){ return 31*x+y; }\n        public boolean equals(Object o){\n            if(!(o instanceof ii)) return false;\n            ii p = (ii) o;\n            return x==p.x && y==p.y;\n        }\n        public String toString(){ return \"(\"+x+\", \"+y+\")\"; }\n    }\n/*\n    public class pair< X extends Comparable< X >,Y extends Comparable< Y > > implements Comparable< pair< X,Y > >{\n        X x;\n        Y y;\n        public pair(){}\n        public pair(X xx, Y yy){ x=xx; y=yy; }\n        public int compareTo(pair< X,Y > p){ return x.compareTo(p.x)!=0 ? x.compareTo(p.x) : y.compareTo(p.y); }\n        public int hashCode(){ return 31*x.hashCode()+y.hashCode(); }\n        public boolean equals(Object o){\n            if((o.getClass() != this.getClass())) return false;\n            pair< X,Y > p = (pair< X,Y >) o;\n            return x.equals(p.x) && y.equals(p.y);\n        }\n        public String toString(){ return \"(\"+x+\", \"+y+\")\"; }\n    }\n*/\n    // my stuff\n    public static final int INF = 1000*1000*1000+7;\n    public static final double EPS = 1e-9;\n    public static final double PI = 2*acos(0.0);\n    public void rev(Object[] a){ for(int i=0; i<a.length/2; ++i){ Object t=a[i]; a[i]=a[a.length-1-i]; a[a.length-1-i]=t; } }\n    public void rev(int[] a){ for(int i=0; i<a.length/2; ++i){ int t=a[i]; a[i]=a[a.length-1-i]; a[a.length-1-i]=t; } }\n    public int bit_count(long x){ return x==0 ? 0 : 1+bit_count(x&(x-1)); }\n    public int low_bit(int x){ return x&-x; } // 0011 0100 returns 0000 0100\n    public int sign(int x){ return x<0 ? -1 : x>0 ? 1 : 0; }\n    public int sign(double x){ return x<-EPS ? -1 : x>EPS ? 1 : 0; }\n    int[] unpack(ArrayList< Integer > a){\n        int[] ret = new int[a.size()];\n        for(int i=0; i<a.size(); ++i) ret[i] = a.get(i);\n        return ret;\n    }\n\n    // generic main stuff\n    static myScanner sc;\n    static PrintWriter pw;\n    static long startTime;\n    public static void main(String[] args) throws Exception{\n        // sc = new Scanner(System.in);\n        sc = (new Main()).new myScanner(new BufferedReader(new InputStreamReader(System.in)));\n        pw = new PrintWriter(System.out);\n        startTime = System.nanoTime();\n        (new Main()).go();\n        // errprintln(\"nanoTime=\"+(System.nanoTime()-startTime)/1000000/1000.0);\n        pw.flush();\n        System.exit(0);\n    }\n\n    // capable of reading   2.86M 6dp doubles per second\n    //                      2.16M 12dp doubles per second\n    //                      2.75M int per second\n    public class myScanner{\n        private BufferedReader f;\n        private StringTokenizer st;\n        public myScanner(BufferedReader ff){ f=ff; st=new StringTokenizer(\"\"); }\n        public int nextInt(){ return Integer.parseInt(nextToken()); }\n        public double nextDouble(){ return Double.parseDouble(nextToken()); }\n        public String nextLine(){\n            st=new StringTokenizer(\"\");\n            String ret=\"\";\n            try{ ret=f.readLine(); }catch(Exception e){}\n            return ret;\n        }\n        public String nextToken(){\n            while(!st.hasMoreTokens()) try{ st=new StringTokenizer(f.readLine()); } catch(Exception e){}\n            return st.nextToken();\n        }\n    }\n\n\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class KingEscape {\n\n    public static void main(String[] args) {\n        Reader read = new Reader();\n\n        int n = read.nextInt();\n        int a1 = read.nextInt();\n        int a2 = read.nextInt();\n        int b1 = read.nextInt();\n        int b2 = read.nextInt();\n        int c1 = read.nextInt();\n        int c2 = read.nextInt();\n\n        if (b1 > a1 && b2 > a2 && c1 > a1 && c2 > a2)\n            System.out.print(\"YES\");\n        else if (b1 > a1 && b2 < a2 && c1 > a1 && c2 < a2)\n            System.out.print(\"YES\");\n        else if (b1 < a1 && b2 > a2 && c1 < a1 && c2 > a2)\n            System.out.print(\"YES\");\n        else if (b1 < a1 && b2 < a2 && c1 < a1 && c2 < a2)\n            System.out.print(\"YES\");\n        else\n            System.out.print(\"NO\");\n    }\n\n    private static class Reader {\n\n        private final BufferedReader reader;\n        private final String separator;\n        private String ln;\n        private String[] tokens;\n        private int ptr;\n\n        Reader(String separator, InputStream input) {\n            this.reader = new BufferedReader(new InputStreamReader(input));\n            this.separator = separator;\n            this.ptr = -1;\n        }\n\n        Reader(String separator) { this(separator, System.in); }\n\n        Reader() { this(\" \"); }\n\n        String nextStr(){\n            if (Objects.isNull(ln)) {\n                try {\n                    ln = reader.readLine();\n                } catch (IOException e) {\n                    System.out.println(e.getMessage());\n                }\n                if (Objects.nonNull(ln)) {\n                    tokens = ln.split(separator);\n                    ptr = 0;\n                } else {\n                    throw new NoSuchElementException(\"no next element\");\n                }\n\n            } else if (ptr == tokens.length) {\n                ln = null;\n                tokens = null;\n                ptr = -1;\n                return nextStr();\n            }\n\n            return tokens[ptr++];\n        }\n\n        int nextInt() { return Integer.parseInt(nextStr()); }\n\n        long nextLong() { return Long.parseLong(nextStr()); }\n\n        double nextDouble() { return Double.parseDouble(nextStr()); }\n    }\n}\n", "complexity": "constant", "problem": "1033_A", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation"}
{"src": "import java.io.*;\nimport static java.lang.Math.*;\nimport java.util.*;\nimport java.util.function.*;\nimport java.lang.*;\n\npublic class Main {\n    final static boolean debug = false;\n    final static String fileName = \"\";\n    final static boolean useFiles = false;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        long start;\n        if (debug)\n            start = System.nanoTime();\n        InputStream inputStream;\n        OutputStream outputStream;\n        if (useFiles) {\n            inputStream = new FileInputStream(fileName + \".in\");\n            outputStream = new FileOutputStream(fileName + \".out\");\n        } else {\n            inputStream = System.in;\n            outputStream = System.out;\n        }\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task(in, out);\n        solver.solve();\n        if(debug)\n            out.println((System.nanoTime() - start) / 1e+9);\n        out.close();\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public byte nextByte() {\n        return Byte.parseByte(next());\n    }\n\n    byte[][] nextBitMatrix(int n, int m) {\n        byte[][] a = new byte[n][m];\n        for (int i = 0; i < n; i++) {\n            String s = next();\n            for (int j = 0; j < m; j++) {\n                a[i][j] = (byte) (s.charAt(j) - '0');\n            }\n        }\n        return a;\n    }\n\n    char[][] nextCharMatrix(int n, int m) {\n        char[][] a = new char[n][m];\n        for (int i = 0; i < n; i++) {\n            String s = next();\n            for (int j = 0; j < m; j++) {\n                a[i][j] = s.charAt(j);\n            }\n        }\n        return a;\n    }\n\n    long[] nextLongArray(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextLong();\n        return a;\n    }\n\n    int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextInt();\n        return a;\n    }\n}\n\nclass Task {\n    boolean get(int mask, int i){\n        return (mask & (1 << i)) > 0;\n    }\n\n    int zero(int mask, int i){\n        return mask & (~(1 << i));\n    }\n\n    public void solve() {\n        int n = in.nextInt();\n        double[][] a = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\n                a[i][j] = in.nextDouble();\n        }\n        double[] d = new double[1 << n];\n        d[(1 << n) - 1] = 1;\n        for (int mask = (1 << n) - 1; mask >= 0; mask--) {\n            int bits = Integer.bitCount(mask);\n            double transfer = 1.0 / (bits * (bits - 1) / 2);\n            for (int i = 0; i < n; i++) {\n                if (get(mask, i)) {\n                    for (int j = i + 1; j < n; j++) {\n                        if (get(mask, j)) {\n                            d[zero(mask, j)] += a[i][j] * transfer * d[mask];\n                            d[zero(mask, i)] += a[j][i] * transfer * d[mask];\n                        }\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < n; i++)\n            out.print(d[1 << i] + \" \");\n    }\n\n    private InputReader in;\n    private PrintWriter out;\n\n    Task(InputReader in, PrintWriter out) {\n        this.in = in;\n        this.out = out;\n    }\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class Template {\n\n    String fileName = \"\";\n    long INF = Long.MAX_VALUE / 3;\n    int MODULO = 1000*1000*1000+7;\n    long[] fenwik;\n    int BORDER = 1000*1000+100;\n    void solve() throws IOException {\n        int n = readInt();\n        int[] a = new int[n];\n        for(int i=0; i<n; ++i){\n            a[i] = readInt();\n        }\n        fenwik = new long[BORDER];\n        long ans = 0;\n        for(int i=n-1;i>=0;--i){\n            ans+=sumFenwik(a[i]);\n            incFenwik(a[i],1);\n        }\n        boolean even = ans % 2 == 0;\n        int m = readInt();\n        for(int i=0; i<m; ++i){\n            int l = readInt();\n            int r = readInt();\n\n            if(((r-l+1)/2)%2==1){\n                even = !even;\n            }\n\n            out.println(even?\"even\":\"odd\");\n        }\n    }\n\n    void incFenwik(int i, int delta){\n        for(;i<BORDER;i = i|(i+1)){\n            fenwik[i]+=delta;\n        }\n    }\n\n    long sumFenwik(int r){\n        long sum = 0;\n        for(;r>=0;r = (r&(r+1))-1){\n            sum+=fenwik[r];\n        }\n        return sum;\n    }\n\n    int gcd(int a, int b){\n        return b == 0 ? a : gcd(b, a%b);\n     }\n\n    long binPow(long a, long b, long m) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b % 2 == 1) {\n            return ((a % m) * (binPow(a, b - 1, m) % m)) % m;\n        } else {\n            long c = binPow(a, b / 2, m);\n            return (c * c) % m;\n        }\n\n    }\n    class Fenwik {\n        long[] t;\n        int length;\n\n        Fenwik(int[] a) {\n            length = a.length + 100;\n            t = new long[length];\n\n            for (int i = 0; i < a.length; ++i) {\n                inc(i, a[i]);\n            }\n        }\n\n        void inc(int ind, int delta) {\n            for (; ind < length; ind = ind | (ind + 1)) {\n                t[ind] += delta;\n            }\n        }\n\n        long getSum(int r) {\n            long sum = 0;\n            for (; r >= 0; r = (r & (r + 1)) - 1) {\n                sum += t[r];\n            }\n            return sum;\n        }\n    }\n\n    class SegmentTree {\n        int[] t;\n\n        SegmentTree(int[] a) {\n            int n = a.length - 1;\n            t = new int[n * 4];\n            build(a, 1, 1, n);\n        }\n\n        void build(int[] a, int v, int tl, int tr) {\n            if (tl == tr) {\n                t[v] = a[tl];\n                return;\n            }\n\n            int mid = (tr + tl) / 2;\n\n            build(a, 2 * v, tl, mid);\n            build(a, 2 * v + 1, mid + 1, tr);\n\n            t[v] = Math.max(t[2 * v], t[2 * v + 1]);\n        }\n\n        void update(int v, int tl, int tr, int pos, int value) {\n            if (tl == tr) {\n                t[v] = value;\n                return;\n            }\n\n            int mid = (tl + tr) / 2;\n\n            if (pos <= mid) {\n                update(2 * v, tl, mid, pos, value);\n            } else {\n                update(2 * v + 1, mid + 1, tr, pos, value);\n            }\n\n            t[v] = Math.max(t[2 * v], t[2 * v + 1]);\n        }\n\n        int getMax(int v, int tl, int tr, int l, int r) {\n            if (l > r) {\n                return -1000 * 1000;\n            }\n            if (tl == tr) {\n                return t[v];\n            }\n\n            if (l == tl && r == tr) {\n                return t[v];\n            }\n\n            int mid = (tl + tr) / 2;\n\n            int max1 = getMax(2 * v, tl, mid, l, Math.min(mid, r));\n            int max2 = getMax(2 * v + 1, mid + 1, tr, Math.max(mid + 1, l), r);\n\n            return Math.max(max1, max2);\n        }\n    }\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        // TODO Auto-generated method stub\n        new Template().run();\n    }\n\n    void run() throws NumberFormatException, IOException {\n        solve();\n        out.close();\n    };\n\n    BufferedReader in;\n    PrintWriter out;\n\n    StringTokenizer tok;\n    String delim = \" \";\n    Random rnd = new Random();\n\n    Template() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } catch (Exception e) {\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new PrintWriter(fileName + \".out\");\n            }\n\n        }\n        tok = new StringTokenizer(\"\");\n    }\n\n    String readLine() throws IOException {\n        return in.readLine();\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            String nextLine = readLine();\n            if (null == nextLine) {\n                return null;\n            }\n\n            tok = new StringTokenizer(nextLine);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws NumberFormatException, IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(readString());\n    }\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class c {\n    class IO {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer st;\n        Random rnd = new Random();;\n        String nextToken() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = in.readLine();\n                if (line == null)\n                    return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n        int nextInt() throws IOException {\n            return Integer.parseInt(nextToken());\n        }\n        long nextLong() throws IOException {\n            return Long.parseLong(nextToken());\n        }\n        double nextDouble() throws IOException {\n            return Double.parseDouble(nextToken());\n        }\n    }\n    \n    void run() throws IOException{\n        IO read=new IO();\n        int n=read.nextInt();\n        int a[]=new int[n],b[]=new int[n];\n        for(int i=0;i<n;i++)\n            a[i]=b[i]=read.nextInt();\n        Arrays.sort(b);\n        int cnt=0;\n        for(int i=0;i<n;i++)\n            if(a[i]!=b[i])\n                cnt++;\n        if(cnt==0||cnt==2)\n            read.out.println(\"YES\");\n        else\n            read.out.println(\"NO\");\n        read.out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new c().run();\n    }\n}\n", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\n    private StreamTokenizer in;\n    private BufferedWriter out;\n\n    public void solve() throws Exception {\n        int n = nextInt(), m = nextInt();\n        int[] ss = new int[n];\n        for (int i=0; i<m; i++)\n        {\n            int a = nextInt(), b = nextInt();\n            a--;b--;\n            ss[a]|=1<<b;\n            ss[b]|=1<<a;\n        }\n        long[][] res = new long[n][1<<n];\n        int[] cnt = new int[1<<n], first = new int[1<<n];\n        for (int i=0; i<n; i++)\n        {\n            res[i][1<<i] = 1;\n            first[1<<i] = i;\n            cnt[1<<i] = 1;\n        }\n        long ans = 0;\n        for (int mask = 0; mask<1<<n; mask++)\n        {\n            for (int last = first[mask]; last<n; last++)\n            {\n                if (res[last][mask]==0)\n                    continue;\n                if (cnt[mask]>2)\n                {\n                    if ((ss[last]&(1<<first[mask]))!=0)\n                        ans+=res[last][mask];\n                }\n                int m2 = (~mask) & ss[last];\n                for (int next = first[mask]+1; next<n; next++)\n                {\n                    if ((m2&(1<<next))==0) continue;\n                    int mask2 = mask|1<<next;\n                    res[next][mask2]+=res[last][mask];\n                    cnt[mask2] = cnt[mask]+1;\n                    first[mask2] = first[mask];\n                }\n            }\n        }\n        ans/=2;\n        out.write(ans+\"\\n\");\n    }\n    \n    public int nextInt() throws Exception\n    {\n        in.nextToken();\n        return (int)in.nval;\n    }\n\n    public void run() {\n        try {\n            in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n            out = new BufferedWriter(new OutputStreamWriter(System.out));\n            solve();\n            out.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "/**\n\n * Created with IntelliJ IDEA.\n\n * User: Fcdkbear\n\n * Date: 11.02.13\n\n * Time: 16:48\n\n * To change this template use File | Settings | File Templates.\n\n */\n\nimport java.util.Scanner;\n\n\n\npublic class test {\n\n\tstatic long[][][][][] dp;\n\n\tstatic String s1,s2;\n\n\tstatic String getbin (long num)\n\n\t{\n\n\t\tString tmp=\"\";\n\n\t\twhile (num>0)\n\n\t\t{\n\n\t\t\tlong v=(num%2);\n\n\t\t\ttmp+=(char)(v+'0');\n\n\t\t\tnum/=2;\n\n\t\t}\n\n\t\tString res=\"\";\n\n\t\tint n=tmp.length();\n\n\t\tfor (int i=n-1; i>=0; --i)\n\n\t\t\tres+=tmp.charAt(i);\n\n\t\treturn res;\n\n\t}\n\n\tstatic int len;\n\n\tstatic long rec(int p, int fl1, int fl2, int fr1, int fr2)\n\n\t{\n\n\t\tif (p==len)\n\n\t\t\treturn 0;\n\n\t\tif (dp[p][fl1][fl2][fr1][fr2] != -1)\n\n\t\t\treturn dp[p][fl1][fl2][fr1][fr2];\n\n\t\tint min1 = 0, max1 = 1;\n\n\t\tif ((fl1 == 0) && (s1.charAt(p) == '1'))\n\n\t\t\tmin1 = 1;\n\n\t\tif ((fl2 == 0) && (s2.charAt(p) == '0'))\n\n\t\t\tmax1 = 0;\n\n\t\tint min2 = 0, max2 = 1;\n\n\t\tif ((fr1 == 0) && (s1.charAt(p) == '1'))\n\n\t\t\tmin2 = 1;\n\n\t\tif ((fr2 == 0) && (s2.charAt(p) == '0'))\n\n\t\t\tmax2 = 0;\n\n\t\tlong res = 0;\n\n\t\tfor (int i=min1; i<=max1; ++i)\n\n\t\tfor (int j=min2; j<=max2; ++j)\n\n\t\t{\n\n\t\t\tint v = (i ^ j);\n\n\t\t\tlong toadd = 0;\n\n\t\t\tif (v == 1) {\n\n\t\t\t\tint step = len - p - 1;\n\n\t\t\t\ttoadd = (1L << step);\n\n\t\t\t}\n\n\t\t\tint nfl1 = fl1, nfl2 = fl2, nfr1 = fr1, nfr2 = fr2;\n\n\t\t\tif (i > s1.charAt(p) - '0')\n\n\t\t\t\tnfl1 = 1;\n\n\t\t\tif (i < s2.charAt(p) - '0')\n\n\t\t\t\tnfl2 = 1;\n\n\t\t\tif (j > s1.charAt(p) - '0')\n\n\t\t\t\tnfr1 = 1;\n\n\t\t\tif (j < s2.charAt(p) - '0')\n\n\t\t\t\tnfr2 = 1;\n\n\t\t\tlong res1= toadd + rec(p + 1, nfl1, nfl2, nfr1, nfr2);\n\n\t\t\tres = Math.max(res,res1);\n\n\t\t}\n\n\t\treturn dp[p][fl1][fl2][fr1][fr2] = res;\n\n\t}\n\n\tpublic static void main(String [] args)\n\n\t{\n\n\t\tdp=new long[70][2][2][2][2];\n\n\t\tfor (int i=0; i<70; ++i)\n\n\t\t\tdp[i]=new long[2][2][2][2];\n\n\t\tfor (int i = 0; i < 70; ++i)\n\n\t\t\tfor (int j=0; j<2; ++j)\n\n\t\t\t\tdp[i][j] = new long[2][2][2];\n\n\t\tfor (int i = 0; i < 70; ++i)\n\n\t\t\tfor (int j = 0; j < 2; ++j)\n\n\t\t\t\tfor (int k=0; k<2; ++k)\n\n\t\t\t\t\tdp[i][j][k] = new long[2][2];\n\n\t\tfor (int i = 0; i < 70; ++i)\n\n\t\t\tfor (int j = 0; j < 2; ++j)\n\n\t\t\t\tfor (int k = 0; k < 2; ++k)\n\n\t\t\t\t\tfor (int c=0; c<2; ++c)\n\n\t\t\t\t\t\tdp[i][j][k][c] = new long[2];\n\n\t\tfor (int i = 0; i < 70; ++i)\n\n\t\t\tfor (int j = 0; j < 2; ++j)\n\n\t\t\t\tfor (int k = 0; k < 2; ++k)\n\n\t\t\t\t\tfor (int c = 0; c < 2; ++c)\n\n\t\t\t\t\t\tfor (int l=0; l<2; ++l)\n\n\t\t\t\t\t\t\tdp[i][j][k][c][l]=-1;\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tlong l=sc.nextLong();\n\n\t\tlong r=sc.nextLong();\n\n\t\ts1=getbin(l);\n\n\t\ts2=getbin(r);\n\n\t\twhile (s1.length()<s2.length())\n\n\t\t\ts1=\"0\"+s1;\n\n\t\tlen=s1.length();\n\n\t\t//System.out.println(s1);\n\n\t\t//System.out.println(s2);\n\n\t\tlong res=rec(0,0,0,0,0);\n\n\t\tSystem.out.println(res);\n\n\t}\n\n}", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class A\n{\n\tprivate static final long MOD = 1000000009L;\n\tpublic static void main(String [] args) throws IOException\n\t{\n\t\tScanner in = new Scanner(System.in);\n\t    long n = in.nextInt();\n\t\tlong m = in.nextInt();\n\t\tlong k = in.nextInt();\n\n\t\tlong w = n-m;\n\n\t\tlong c = w*k;\n\t\tif(c >= n)\n\t\t{\n\t\t\tSystem.out.println(m);\n\t\t\treturn;\n\t\t}\n\n\t\tlong rem = n-c;\n\t\tlong h = rem/k;\n\n\t\tlong p = power(2, h+1);\n\t\tp -= 2;\n\t\tp += MOD;\n\t\tp %= MOD;\n\t\tp *= k;\n\t\tp %= MOD;\n\n\t\tlong point = p + m - (h*k) % MOD;\n\t\tpoint += MOD;\n\t\tpoint %= MOD;\n\n\t\tSystem.out.println(point);\n\n\n\n\t}\n\n\tprivate static long power(int num, long power)\n\t{\n\t\tif(power == 0)\n\t\t\treturn 1;\n\t\tlong res = power(num, power/2);\n\t\tres = (res*res)%MOD;\n\t\tif(power % 2 != 0)\n\t\t\tres *= num;\n\n\t\tres%=MOD;\n\n\t\treturn res;\n\t}\n}\n", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n\npublic class order {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(new BufferedWriter(\n\t\t\t\tnew OutputStreamWriter(System.out)));\n\t\tint n=Integer.parseInt(in.readLine());\n\t\tSet<Integer> set = new TreeSet<Integer>();\n\t\tStringTokenizer st= new StringTokenizer(in.readLine());\n\t\tint a;\n\t\tList<Integer> list =new LinkedList<Integer>();\n\t\twhile(st.hasMoreTokens()){\n\t\t\ta= Integer.parseInt(st.nextToken());\n\t\t\tif(!set.contains(a)){\n\t\t\t\tlist.add(a);\n\t\t\t\tset.add(a);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(list.size()==1){\n\t\t\tout.println(\"NO\");\n\t\t}else{\n\t\t\tCollections.sort(list);\n\t\t\tout.println(list.get(1));\n\t\t}\n\t\tout.close();\n\t\tSystem.exit(0);\n\t}\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    private static Node[] node;\n\n    public static void main(String[] args) {\n    Scanner cin = new Scanner(System.in);\n    int ret = 2, del;\n    int n = cin.nextInt();\n    int t = cin.nextInt() * 2;\n    node = new Node[n];\n    for (int i = 0; i < n; i++) {\n        int x = cin.nextInt();\n        int a = cin.nextInt();\n        node[i] = new Node(x * 2 - a, x * 2 + a);\n    }\n    Arrays.sort(node);\n    for (int i = 1; i < n; i++) {\n        del = node[i].l - node[i - 1].r;\n        if (del > t) {\n        ret += 2;\n        } else if (del == t) {\n        ret++;\n        }\n    }\n    System.out.println(ret);\n    }\n\n    private static class Node implements Comparable<Node> {\n    public int l;\n    public int r;\n\n    public Node(int l, int r) {\n        // TODO Auto-generated constructor stub\n        this.l = l;\n        this.r = r;\n    }\n\n    @Override\n    public int compareTo(Node arg0) {\n        // TODO Auto-generated method stub\n        return l - arg0.l;\n    }\n    }\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Solver {\n\n    StringTokenizer st;\n    BufferedReader in;\n    PrintWriter out;\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        Solver solver = new Solver();\n        solver.open();\n        solver.solve();\n        solver.close();\n    }\n\n    public void open() throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n    }\n\n    public String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws NumberFormatException, IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public void solve() throws NumberFormatException, IOException {\n        int n = nextInt();\n        out.println(0+\" \"+0+\" \"+n);\n    }\n\n    public void close() {\n        out.flush();\n        out.close();\n    }\n\n}", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class TaskE {\n\n    static int[][] transpose(int[][] a, int n, int m) {\n        int[][] t = new int[m][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                t[j][i] = a[i][j];\n            }\n        }\n\n        return t;\n    }\n\n    public static void main(String[] args) {\n        FastReader in = new FastReader(System.in);\n//        FastReader in = new FastReader(new FileInputStream(\"input.txt\"));\n        PrintWriter out = new PrintWriter(System.out);\n//        PrintWriter out = new PrintWriter(new FileOutputStream(\"output.txt\"));\n\n\n        int t = in.nextInt();\n\n        while (t-- > 0) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n\n            int[][] a = new int[n + 1][m];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[i][j] = in.nextInt();\n                    a[n][j] = Math.max(a[n][j], a[i][j]);\n                }\n            }\n\n            a = transpose(a, n, m);\n\n            Arrays.sort(a, new Comparator<int[]>() {\n                @Override\n                public int compare(int[] o1, int[] o2) {\n                    int max1 = 0;\n                    for (int i = 0; i < o1.length; i++) {\n                        max1 = Math.max(max1, o1[i]);\n                    }\n\n                    int max2 = 0;\n                    for (int i = 0; i < o2.length; i++) {\n                        max2 = Math.max(max2, o2[i]);\n                    }\n\n                    return max2 - max1;\n                }\n            });\n\n            a = transpose(a, m, n);\n\n            int[] dp = new int[1 << n];\n\n            for (int i = 0; i < Math.min(n, m); i++) {\n                int[] best = new int[1 << n];\n\n                for (int j = 1; j < (1 << n); j++) {\n                    for (int k = 0; k < n; k++) {\n                        int sum = 0;\n                        for (int l = 0; l < n; l++) {\n                            if ((j & (1 << l)) != 0)\n                                sum += a[(l + k) % n][i];\n                        }\n                        best[j] = Math.max(best[j], sum);\n                    }\n                }\n\n                int[] dp1 = dp.clone();\n\n                for (int j = 0; j < (1 << n); j++) {\n                    for (int k = j; k > 0; k = (k - 1) & j) {\n                        dp[j] = Math.max(dp[j], dp1[k ^ j] + best[k]);\n                    }\n                }\n            }\n\n            out.println(dp[(1 << n) - 1]);\n        }\n\n\n\n\n\n        out.close();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        Integer nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        Double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(nextLine());\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            String s = \"\";\n            try {\n                s = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return s;\n        }\n    }\n}\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class EdB {\n\tstatic long[] mods = {1000000007, 998244353, 1000000009};\n\tstatic long mod = mods[0];\n\tpublic static MyScanner sc;\n    public static PrintWriter out;\n    static int[] depth;\n    static int[] parent;\n    static ArrayList<HashSet<Integer>> tree;\n\tpublic static void main(String[] omkar) throws Exception{\n\t\t// TODO Auto-generated method stub\n \t\tsc = new MyScanner();\n \t\tout = new PrintWriter(System.out);\n \t\ttree = new ArrayList<HashSet<Integer>>();\n \t\tint n = sc.nextInt();\n \t\tfor(int j =0;j<=n;j++){\n \t\t\ttree.add(new HashSet<Integer>());\n \t\t}\n \t\tdepth = new int[n+1];\n \t\tparent = new int[n+1];\n \t\tfor(int j =0 ;j<n-1;j++){\n \t\t\tint v1 = sc.nextInt();\n \t\t\tint v2 = sc.nextInt();\n \t\t\ttree.get(v1).add(v2);\n \t\t\ttree.get(v2).add(v1);\n \t\t}\n \t\tdfs(1, -1);\n \t\t\n \t\tArrayList<Integer> left = new ArrayList<Integer>();\n \t\tfor(int j =1;j<=n;j++){\n \t\t\tif (depth[j] > 2)\n \t\t\t\tleft.add(j);\n \t\t}\n \t\tCollections.sort(left, \n \t\t\t\t\n \t\t\t\tnew Comparator<Integer>(){\n \t\t\tpublic int compare(Integer x, Integer y){\n \t\t\t\treturn Integer.compare(depth[(int)y], depth[(int)x]);\n \t\t\t}\n \t\t});\n \t\t\n \t\tint ans = 0;\n \t\tboolean[] done = new boolean[n+1];\n \t\tfor(int j : left){\n \t\t\tif (!done[j]){\n \t\t\t\tans++;\n \t\t\t\tdone[parent[j]] = true;\n \t\t\t\tfor(int k : tree.get(parent[j]))\n \t\t\t\t\tdone[k] = true;\n \t\t\t}\n \t\t}\n \t\tout.println(ans);\n \t\tout.close();\t\n \t}\n\t\n\tpublic static void dfs(int v, int p){\n\t\tfor(int child : tree.get(v)){\n\t\t\tif (child == p)\n\t\t\t\tcontinue;\n\t\t\tdepth[child] = depth[v]+1;\n\t\t\tparent[child] =v ;\n\t\t\tdfs(child, v);\n\t\t}\n\t}\n\tpublic static void sort(int[] array){\n\t\tArrayList<Integer> copy = new ArrayList<Integer>();\n\t\tfor (int i : array)\n\t\t\tcopy.add(i);\n\t\tCollections.sort(copy);\n\t\tfor(int i = 0;i<array.length;i++)\n\t\t\tarray[i] = copy.get(i);\n\t}\n\tstatic String[] readArrayString(int n){\n\t\tString[] array = new String[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.next();\n\t\treturn array;\n\t}\n\tstatic int[] readArrayInt(int n){\n    \tint[] array = new int[n];\n    \tfor(int j = 0;j<n;j++)\n    \t\tarray[j] = sc.nextInt();\n    \treturn array;\n    }\n\tstatic int[] readArrayInt1(int n){\n\t\tint[] array = new int[n+1];\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tarray[j] = sc.nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\tstatic long[] readArrayLong(int n){\n\t\tlong[] array = new long[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextLong();\n\t\treturn array;\n\t}\n\tstatic double[] readArrayDouble(int n){\n\t\tdouble[] array = new double[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextDouble();\n\t\treturn array;\n\t}\n\tstatic int minIndex(int[] array){\n\t\tint minValue = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(long[] array){\n\t\tlong minValue = Long.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(double[] array){\n\t\tdouble minValue = Double.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic long power(long x, long y){\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y%2 == 1)\n\t\t\treturn (x*power(x, y-1))%mod;\n\t\treturn power((x*x)%mod, y/2)%mod;\n\t}\n\tstatic void verdict(boolean a){\n        out.println(a ? \"YES\" : \"NO\");\n    }\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try{\n                str = br.readLine();\n            } \n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n    }\t\n}\n\n//StringJoiner sj = new StringJoiner(\" \"); \n//sj.add(strings)\n//sj.toString() gives string of those stuff w spaces or whatever that sequence is", "complexity": "linear", "problem": "1029_E", "from": "CODEFORCES", "tags": "dp,graphs,greedy"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\n\npublic class Cycles\n{\n\tpublic static FastInputStream fis;\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tfis = new FastInputStream(System.in);\n\t\t\n\t\tSystem.out.println(solve(fis.nextInt(), fis.nextInt()));\n\t\t\n\t\tfis.close();\n\t}\n\t\n\tpublic static long solve(int n, int m) throws IOException\n\t{\n\t\tboolean[][] graph = new boolean[n][];\n\t\tlong[][] state = new long[1 << n][n];\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tgraph[i] = new boolean[n - i];\n\t\t\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a = fis.nextInt() - 1;\n\t\t\tint b = fis.nextInt() - 1;\n\t\t\tsetConnected(graph, a, b);\n\t\t\tstate[(1 << a) | (1 << b)][a > b ? a : b] = 1;\n\t\t}\n\t\t\n\t\tlong res = 0;\n\t\t\n\t\tfor (int i = 2; i < n; i++)\n\t\t{\n\t\t\tint baseCombination = (2 << i) - 1;\n\t\t\t\n\t\t\twhile (baseCombination < (1 << n))\n\t\t\t{\n\t\t\t\tint min = getFirstOne(baseCombination);\n\t\t\t\tint bits = baseCombination;\n\t\t\t\twhile (bits != 0)\n\t\t\t\t{\n\t\t\t\t\tint firstBit = bits & (-bits);\n\t\t\t\t\tint firstBitPos = getFirstOne(firstBit);\n\t\t\t\t\t\n\t\t\t\t\tbits &= bits - 1;\n\t\t\t\t\t\n\t\t\t\t\tif (firstBitPos == min)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tint leftOverBits = baseCombination - firstBit;\n\t\t\t\t\tint nextBits = leftOverBits;\n\t\t\t\t\t\n\t\t\t\t\twhile (nextBits != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nextBit = nextBits & (-nextBits);\n\t\t\t\t\t\tint nextBitPos = getFirstOne(nextBit);\n\t\t\t\t\t\t\n\t\t\t\t\t\tnextBits &= nextBits - 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (nextBitPos == min)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!isConnected(graph, firstBitPos, nextBitPos))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\t/*System.out.println(\"Comb: \" + Integer.toBinaryString(baseCombination));\n\t\t\t\t\t\tSystem.out.println(\"Bit: \" + Integer.toBinaryString(firstBit));\n\t\t\t\t\t\tSystem.out.println(\"(pos): \" + firstBitPos);\n\t\t\t\t\t\tSystem.out.println(\"Left over: \" + Integer.toBinaryString(leftOverBits));\n\t\t\t\t\t\tSystem.out.println(\"Next bit: \" + Integer.toBinaryString(nextBit));\n\t\t\t\t\t\tSystem.out.println(\"(pos): \" + nextBitPos);\n\t\t\t\t\t\tSystem.out.println();*/\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate[baseCombination][firstBitPos] += state[leftOverBits][nextBitPos];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (isConnected(graph, firstBitPos, min))\n\t\t\t\t\t\tres += state[baseCombination][firstBitPos];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbaseCombination = nextCombination(baseCombination);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for (int i = 0; i < state.length; i++)\n\t\t{\n\t\t\tif ((i & (i - 1)) == 0)\n\t\t\t\tcontinue;\n\t\t\tSystem.out.print(String.format(\"%4s:\", Integer.toBinaryString(i)).replace(' ', '0') + \" \");\n\t\t\tfor (int j = 0; j < state[i].length; j++)\n\t\t\t\tSystem.out.print(state[i][j] + \" \");\n\t\t\tSystem.out.println();\n\t\t}*/\n\t\t\n\t\treturn res >> 1;\n\t}\n\t\n\tpublic static boolean isConnected(boolean[][] graph, int a, int b)\n\t{\n\t\tif (b < a || graph[a].length <= (b - a))\n\t\t\treturn graph[b][a - b];\n\t\treturn graph[a][b - a];\n\t}\n\t\n\tpublic static void setConnected(boolean[][] graph, int a, int b)\n\t{\n\t\tif (b < a || graph[a].length <= (b - a))\n\t\t\tgraph[b][a - b] = true;\n\t\telse\n\t\t\tgraph[a][b - a] = true;\n\t}\n\t\n\tpublic static int nextCombination(int x)\n\t{\n\t\tint smallest = x & -x;\n\t\tint ripple = x + smallest;\n\t\tint ones = ((x ^ ripple) >> 2) / smallest;\n\t\treturn ripple | ones;\n\t}\n\t\n\tpublic static boolean on(int bitmask, int pos)\n\t{\n\t\treturn ((bitmask >> pos) & 1) == 1;\n\t}\n\t\n\tpublic static int setOn(int bitmask, int pos)\n\t{\n\t\treturn bitmask | (1 << pos);\n\t}\n\t\n\tpublic static int setOff(int bitmask, int pos)\n\t{\n\t\treturn bitmask & ~(1 << pos);\n\t}\n\t\n\tpublic static int getOns(int bitmask)\n\t{\n\t\tint amt = 0;\n\t\twhile (bitmask != 0)\n\t\t{\n\t\t\tbitmask &= bitmask - 1;\n\t\t\tamt++;\n\t\t}\n\t\t\n\t\treturn amt;\n\t}\n\t\n\tpublic static int getFirstOne(int bitmask)\n\t{\n\t\tif (bitmask == 0)\n\t\t\treturn -1;\n\t\t\n\t\tint first = 0;\n\t\twhile ((bitmask & 1) != 1)\n\t\t{\n\t\t\tfirst++;\n\t\t\tbitmask = bitmask >> 1;\n\t\t}\n\t\t\n\t\treturn first;\n\t}\n\t\n\tpublic static class FastInputStream extends InputStream\n\t{\n\t\tprivate InputStream in;\n\t\t\n\t\tprivate byte[] buffer = new byte[512];\n\t\tprivate int loaded = 0;\n\t\tprivate int pointer = 0;\n\t\t\n\t\tpublic FastInputStream(InputStream in)\n\t\t{\n\t\t\tthis.in = in;\n\t\t}\n\n\t\t@Override\n\t\tpublic int read() throws IOException\n\t\t{\n\t\t\tif (hasNext())\n\t\t\t\treturn buffer[pointer++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tpublic void skipWhitespace() throws IOException\n\t\t{\n\t\t\twhile (hasNext())\n\t\t\t{\n\t\t\t\tchar c = (char) buffer[pointer];\n\n\t\t\t\tif (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') pointer++;\n\t\t\t\telse return;\n\t\t\t}\n\t\t}\n\n\t\tpublic Integer nextInt() throws IOException\n\t\t{\n\t\t\tskipWhitespace();\n\n\t\t\tif (!hasNext()) return null;\n\n\t\t\tbyte multiplier = 1;\n\t\t\tint number = 0;\n\n\t\t\tif (buffer[pointer] == '-')\n\t\t\t{\n\t\t\t\tmultiplier = -1;\n\t\t\t\tpointer++;\n\t\t\t}\n\n\t\t\twhile (hasNext())\n\t\t\t{\n\t\t\t\tchar c = (char) buffer[pointer];\n\n\t\t\t\tif (c >= '0' && c <= '9')\n\t\t\t\t{\n\t\t\t\t\tnumber = (number << 3) + (number << 1) + c - '0';\n\t\t\t\t\tpointer++;\n\t\t\t\t} else break;\n\t\t\t}\n\n\t\t\treturn number * multiplier;\n\t\t}\n\t\t\n\t\tpublic void close() throws IOException\n\t\t{\n\t\t\tin.close();\n\t\t}\n\t\t\n\t\tpublic boolean hasNext() throws IOException\n\t\t{\n\t\t\twhile (pointer == loaded)\n\t\t\t{\n\t\t\t\tloaded = in.read(buffer);\n\t\t\t\tpointer = 0;\n\t\t\t\t\n\t\t\t\tif (loaded == -1) return false;\n\t\t\t}\n\t\t\treturn loaded != -1;\n\t\t}\n\t}\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class E {\n    void solve(BufferedReader in) throws Exception {\n        int[] xx = toInts(in.readLine());\n        int n = xx[0];\n        double k = xx[1];\n        int[][] board = new int[n][n];\n        for(int i = 0; i<n; i++) board[i] = toInts(in.readLine());\n        int fst = n/2;\n        int snd = n - fst;\n        int[] maxc = new int[1<<fst];\n        int max = 1;\n        for(int i = 0; i<(1<<fst); i++) {\n            for(int j = 0; j<fst; j++) {\n                if((i&(1<<j)) != 0) maxc[i] = Math.max(maxc[i], maxc[i^(1<<j)]);\n            }\n            boolean ok = true;\n            for(int a = 0; a<fst; a++) if(((1<<a)&i) != 0) {\n                for(int b = a+1; b<fst; b++) if(((1<<b)&i) != 0) {\n                    if(board[a][b] == 0) ok = false;\n                }\n            }\n            if(ok) {\n                maxc[i] = Integer.bitCount(i);\n                max = Math.max(max, maxc[i]);\n            }\n        }\n        for(int i = 0; i<(1<<snd); i++) {\n            boolean ok = true;\n            for(int a = 0; a<snd; a++) if(((1<<a)&i) != 0) {\n                for(int b = a+1; b<snd; b++) if(((1<<b)&i) != 0) {\n                    if(board[a+fst][b+fst] == 0) ok = false;\n                }\n            }\n            if(!ok) continue;\n            int mask = 0;\n            for(int a = 0; a<fst; a++) {\n                ok = true;\n                for(int b = 0; b<snd; b++) {\n                    if(((1<<b)&i) != 0) {\n                        if(board[a][b+fst] == 0) ok = false;\n                    }\n                }\n                if(ok) mask |= (1<<a);\n            }\n            max = Math.max(Integer.bitCount(i) + maxc[mask], max);\n        }\n        System.out.println(k*k*(max-1.0)/(2*max));\n    }\n    int toInt(String s) {return Integer.parseInt(s);}\n    int[] toInts(String s) {\n        String[] a = s.split(\" \");\n        int[] o = new int[a.length];\n        for(int i = 0; i<a.length; i++) o[i] = toInt(a[i]);\n        return o;\n    }\n    void e(Object o) {\n        System.err.println(o);\n    }\n    public static void main(String[] args) throws Exception{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        (new E()).solve(in);\n    }\n}\n", "complexity": "np", "problem": "0839_E", "from": "CODEFORCES", "tags": "brute force,graphs,math,meet-in-the-middle"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Solution{\n    \n    public static long page(long p,long k){\n        \n        return (p-1)/k;\n        \n    }\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        \n        long n = sc.nextLong();\n        int m = sc.nextInt();\n        long k = sc.nextLong();\n        long[] p = new long[m];\n        long del = 0;\n        long nb = 1;\n        int op = 0;\n        for(int i=0;i<m;i++) p[i] = sc.nextLong();\n        for(int i=1;i<m;i++){\n            if(page(p[i]-del,k)!=page(p[i-1]-del,k)){\n                \n                del += nb;\n                nb = 1;\n                op++;\n                \n            }else{\n                nb++;\n                \n            }\n        }\n        if(nb!=0) op++;\n        \n        System.out.println(op);\n        \n    }\n    \n}", "complexity": "linear", "problem": "1191_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.*;\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\npublic class D {\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew D().run();\n\t}\n\tint[] BIT;\n\tpublic void run() throws Exception {\n\t\tFastScanner f = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = f.nextInt();\n\t\tint[] arr = new int[n];\n\t\tBIT = new int[n+10];\n\t\tint inv = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tarr[i] = f.nextInt();\n\t\t\tinv ^= (i-query(arr[i])) & 1;\n\t\t\tadd(arr[i]);\n\t\t}\n\t\tint k = f.nextInt();\n\t\twhile(k-->0) {\n\t\t\tint diff = -f.nextInt()+f.nextInt()+1;\n\t\t\tinv ^= (diff*(diff-1)/2) & 1;\n\t\t\tout.println(inv == 1 ? \"odd\" : \"even\");\n\t\t}\n\t\tout.flush();\n\t}\n\n\tpublic int query(int i) {\n\t\ti++;\n\t\tint res = 0;\n\t\twhile(i > 0) {\n\t\t\tres += BIT[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic void add(int i) {\n\t\ti++;\n\t\twhile(i < BIT.length) {\n\t\t\tBIT[i]++;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\t\n\t\n\t\n    static class FastScanner {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n        \treturn Long.parseLong(next());\n        }\n        public double nextDouble() {\n        \treturn Double.parseDouble(next());\n        }\n        public String nextLine() {\n        \ttry {\n        \t\treturn reader.readLine();\n        \t} catch(IOException e) {\n        \t\tthrow new RuntimeException(e);\n        \t}\n        }\n\n\n    }\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "// package CF;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n\npublic class F {\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt(), d = sc.nextInt();\n\t\tint [] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tTreeSet<Integer> set = new TreeSet<>();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint tmp = a[i] - d;\n\t\t\tif(i == 0 || tmp > a[i-1] && tmp - a[i-1] >= d)\n\t\t\t\tset.add(tmp);\n\t\t\ttmp = a[i] + d;\n\t\t\tif(i == n-1 || tmp < a[i+1] && a[i+1] - tmp >= d)\n\t\t\t\tset.add(tmp);\n \t\t}\n\t\tout.println(set.size());\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s)\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader fileReader)\n\t\t{\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException\n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException\n\t\t{\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException\n\t\t{\n\t\t\treturn br.ready();\n\t\t}\n\t}\n}", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\n\n\npublic class Main {\n\n    private void solve() {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        final int[] p = new int[n];\n        final int[] t = new int[n];\n        for(int i =0 ; i < n; ++i) {\n            p[i] = in.nextInt();\n            t[i] = in.nextInt();\n        }\n        Integer[] ord = new Integer[n];\n        for(int i = 0; i < n; ++i)\n            ord[i] = i;\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n - 1; ++j) {\n                if (Less(ord[j], ord[j + 1], p, t)) {\n                    Integer tx = ord[j];\n                    ord[j] = ord[j + 1];\n                    ord[j + 1] = tx;\n                }\n            }\n        }\n        \n        \n        \n        for(int i = 0, j = 0; i < n; i = j) {\n            for(j = i; j < n && p[ord[i]] == p[ord[j]] && t[ord[i]] == t[ord[j]]; ++j) ;\n            int first = i+1;\n            int second = j;\n            if (first <= k && k <= second) {\n                out.print(j - i);\n                return ;\n            }\n        }\n        out.print(0);\n    }\n    private boolean Less(Integer i, Integer j, int[] p, int[] t) {\n        return p[i] < p[j] || p[i] == p[j] && t[i] > t[j];\n    }\n    private void run() {\n        try {\n            in = new FastScanner();\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            solve();\n            out.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void main(String[] args) {\n        new Main().run();\n    }\n    FastScanner in;\n    PrintWriter out;\n    class FastScanner {\n        public BufferedReader reader;\n        private StringTokenizer tokenizer;\n        public FastScanner(String file) {\n            try {\n                reader = new BufferedReader(new FileReader(new File(file)));\n                tokenizer = null;\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n        \n        public FastScanner() {\n            try {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                tokenizer = null;\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        public String nextToken() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class sample {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();       \n        System.out.println(n+n/2);\n    }\n}", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "// Don't place your source in a package\nimport javax.swing.*;\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.stream.Stream;\n\n\n// Please name your class Main\npublic class Main {\n    static FastScanner fs=new FastScanner();\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int Int() {\n            return Integer.parseInt(next());\n        }\n\n        long Long() {\n            return Long.parseLong(next());\n        }\n\n        String Str(){\n            return next();\n        }\n    }\n\n\n    public static void main (String[] args) throws java.lang.Exception {\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n        int T=1;\n        for(int t=0;t<T;t++){\n            int n=Int(),m=Int(),k=Int();\n            List<int[]>g[]=new ArrayList[n*m+1];\n            for(int i=0;i<g.length;i++){\n                g[i]=new ArrayList<>();\n            }\n            for(int i=0;i<n;i++){\n                for(int j=0;j<m-1;j++){\n                    int w=Int();\n                    int u=i*m+j;\n                    int v=i*m+(j+1);\n                    g[u].add(new int[]{v,w});\n                    g[v].add(new int[]{u,w});\n                }\n            }\n\n            for(int i=0;i<n-1;i++){\n                for(int j=0;j<m;j++){\n                    int w=Int();\n                    int u=i*m+j;\n                    int v=(i+1)*m+j;\n                    g[u].add(new int[]{v,w});\n                    g[v].add(new int[]{u,w});\n                }\n            }\n\n            Solution sol=new Solution(out);\n            sol.solution(n,m,k,g);\n        }\n        out.close();\n\n    }\n\n\n    public static int Int(){\n        return fs.Int();\n    }\n    public static long Long(){\n        return fs.Long();\n    }\n    public static String Str(){\n        return fs.Str();\n    }\n\n}\n\n\n\n\n\n\nclass Solution{\n    PrintWriter out;\n    public Solution(PrintWriter out){\n        this.out=out;\n    }\n\n\n\n\n    List<int[]>g[];\n    int n,m;\n    long INF=10000000000000000l;\n    int curr=-1,curc=-1;\n    long mn=Long.MAX_VALUE;\n    long dp[][];\n    public void solution(int n,int m,int k,List<int[]>g[]){\n        //edge : 4 directions.\n        this.n=n;\n        this.m=m;\n        long res[][]=new long[n][m];\n        if(k%2==1){\n            for(int i=0;i<n;i++){\n                Arrays.fill(res[i],-1);\n            }\n            print(res);\n            return;\n        }\n        this.g=g;\n        dp=new long[n*m+1][k/2+2];\n        for(int i=0;i<dp.length;i++){\n            Arrays.fill(dp[i],-1);\n        }\n\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                int id=i*m+j;\n                dfs(id,k/2);\n            }\n        }\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                int id=i*m+j;\n                res[i][j]=dp[id][k/2];\n            }\n        }\n        print(res);\n    }\n\n    public long dfs(int id,int cnt){\n        if(cnt==0){\n            return 0;\n        }\n        if(dp[id][cnt]!=-1)return dp[id][cnt];\n\n        int r=id/m;\n        int c=id%m;\n        long res=Long.MAX_VALUE;\n        for(int p[]:g[id]){\n            int next=p[0],w=p[1];\n            res=Math.min(res,w*2+dfs(next,cnt-1));\n        }\n        dp[id][cnt]=res;\n        return res;\n\n    }\n\n    public int dis(int x1,int y1,int x2,int y2){\n        return Math.abs(x1-x2)+Math.abs(y1-y2);\n    }\n\n\n    public void print(long A[][]){\n        for(int i=0;i<A.length;i++){\n            for(int j=0;j<A[0].length;j++){\n                out.print(A[i][j]+\" \");\n            }\n            out.println();\n        }\n    }\n\n\n\n\n\n\n}\n\nclass Solution1{\n    PrintWriter out;\n    public Solution1(PrintWriter out){\n        this.out=out;\n    }\n\n    public void solution(int A[]){\n\n    }\n\n}\n\n\n\n/*\n                             ;\\\n                            |' \\\n         _                  ; : ;\n        / `-.              /: : |\n       |  ,-.`-.          ,': : |\n       \\  :  `. `.       ,'-. : |\n        \\ ;    ;  `-.__,'    `-.|\n         \\ ;   ;  :::  ,::'`:.  `.\n          \\ `-. :  `    :.    `.  \\\n           \\   \\    ,   ;   ,:    (\\\n            \\   :., :.    ,'o)): ` `-.\n           ,/,' ;' ,::\"'`.`---'   `.  `-._\n         ,/  :  ; '\"      `;'          ,--`.\n        ;/   :; ;             ,:'     (   ,:)\n          ,.,:.    ; ,:.,  ,-._ `.     \\\"\"'/\n          '::'     `:'`  ,'(  \\`._____.-'\"'\n             ;,   ;  `.  `. `._`-.  \\\\\n             ;:.  ;:       `-._`-.\\  \\`.\n              '`:. :        |' `. `\\  ) \\\n      -hrr-      ` ;:       |    `--\\__,'\n                   '`      ,'\n                        ,-'\n\n\n                      free bug dog\n*/\n\n\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\n\n\t\tpublic class codeforces\n\t\t{\t\n\t\t\tpublic static void main(String[] args)\n\t\t\t{\n\t\t\t\tInputReader in = new InputReader(System.in);\n\t\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tlong U = in.nextLong();\n\t\t\t\tlong[] E = new long[n];\n\t\t\t\tdouble max = -1;\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\tE[i] = in.nextLong();\n\t\t\t\t\n\t\t\t\tfor(int k=1;k<n-1;k++)\n\t\t\t\t{\n\t\t\t\t\tint i = k + 1, j = n - 1, mid = 0;\n\t\t\t\t\tdouble T = 0;\n\t\t\t\t\t\n\t\t\t\t\twhile(i < j)\n\t\t\t\t\t{\n\t\t\t\t\t\tmid = (int)Math.ceil((double)(i+j)/2);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(E[mid] - E[k-1] <= U)\n\t\t\t\t\t\t\ti = mid;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tj = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tj = k;\n\t\t\t\t\tk = i;\n\t\t\t\t\ti = j - 1;\n\t\t\t\t\t\n\t\t\t\t\tT = E[k] - E[j];\n\t\t\t\t\tT /= E[k] - E[i];\n\t\t\t\t\t\n\t\t\t\t\tif(E[k] - E[i] <= U)\n\t\t\t\t\t\tmax = Math.max(max, T);\n\t\t\t\t\t\n\t\t\t\t\tk = j;\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\tpw.println(max);\n\t\t\t\t\n\t\t\t\tpw.flush();\n\t\t\t\tpw.close();\n\t\t\t}\n\t\t\t\n\t\t/*\tpublic static void DFS(int sourse)\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tvisited[sourse] = true;\n\t\t\t\t\n\t\t\t\tfor(int u : adj[sourse])\n\t\t\t\t{\n\t\t\t\t\tif(!visited[u])\n\t\t\t\t\t{\n\t\t\t\t\t\tDFS(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}*/\n\t\t\t\n\t\t\tpublic static ArrayList Divisors(long n)\n\t\t\t{\n\t\t\t    ArrayList<Long> div = new ArrayList<>();\n\t\t\t    \n\t\t\t    for (long i=1; i<=Math.sqrt(n); i++)\n\t\t\t    {\n\t\t\t        if (n%i == 0)\n\t\t\t        {\n\t\t\t        \tdiv.add(i);\n\t\t\t                \n\t\t\t            if(n/i != i)\n\t\t\t            \tdiv.add(n/i);\n\t\t\t        }\n\t\t\t    }\n\t\t\t    return div;\n\t\t\t}\n\t\t\n\t\t\tpublic static int BinarySearch(long[] a, long k)\n\t\t\t{\n\t\t\t\tint n = a.length;\n\t\t\t\tint i = 0, j = n-1;\n\t\t\t\tint mid = 0;\n\t\t\t\t\n\t\t\t\tif(k < a[0])\n\t\t\t\t\treturn 0;\n\t\t\t\telse if(k >= a[n-1])\n\t\t\t\t\treturn n;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile(j - i > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmid = (i+j)/2;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(k >= a[mid])\n\t\t\t\t\t\t\ti = mid;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tj = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn i+1;\n\t\t\t}\n\t\t\tpublic static long GCD(long a,long b)\n\t\t\t{\n\t\t\t\tif(b==0)\n\t\t\t\t\treturn a;\n\t\t\t\telse\n\t\t\t\t\treturn GCD(b,a%b);\n\t\t\t}\n\t\t\t\n\t\t\tstatic class pair implements Comparable<pair>\n\t\t\t{\n\t\t\t\tInteger x, y;\n\t\t\t\tpair(int x,int y)\n\t\t\t\t{\n\t\t\t\t\tthis.x=x;\n\t\t\t\t\tthis.y=y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic int compareTo(pair o) {\n\t\t\t\t\tint result = x.compareTo(o.x);\n\t\t\t\t\tif(result==0)\n\t\t\t\t\t\tresult = y.compareTo(o.y);\n\t\t\t\t\t\n\t\t\t\t\treturn result;\n\t\t\t\t}  \n\t\t\t\t\n\t\t\t\tpublic String toString()\n\t\t\t\t{\n\t\t\t\t\treturn x+\" \"+y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic boolean equals(Object o)\n\t\t\t\t{\n\t\t\t\t\tif (o instanceof pair)\n\t\t\t\t    {\n\t\t\t\t\t\tpair p = (pair)o;\n\t\t\t\t\t\treturn p.x - x == 0 && p.y - y == 0 ;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic int hashCode()\n\t\t\t\t{\n\t\t\t\t\treturn new Long(x).hashCode()*31 + new Long(y).hashCode();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstatic class InputReader \n\t\t\t{\n\t\t\t\t \n\t\t\t\tprivate final InputStream stream;\n\t\t\t\tprivate final byte[] buf = new byte[8192];\n\t\t\t\tprivate int curChar, snumChars;\n\t\t\t\tprivate SpaceCharFilter filter;\n\t\t \n\t\t\t\tpublic InputReader(InputStream stream) \n\t\t\t\t{\n\t\t\t\t\tthis.stream = stream;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int snext() \n\t\t\t\t{\n\t\t\t\t\tif (snumChars == -1)\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tif (curChar >= snumChars) \n\t\t\t\t\t{\n\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\ttry \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t\t\t} \n\t\t\t\t\t\tcatch (IOException e) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int nextInt() \n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-')\n\t\t\t\t    {\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint res = 0;\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic long nextLong()\n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-') \n\t\t\t\t\t{\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tlong res = 0;\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int[] nextIntArray(int n) \n\t\t\t\t{\n\t\t\t\t\tint a[] = new int[n];\n\t\t\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t\t\t{\n\t\t\t\t\t\ta[i] = nextInt();\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic String readString()\n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic String nextLine() \n\t\t\t\t{\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isEndOfLine(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic boolean isSpaceChar(int c) \n\t\t\t\t{\n\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t}\n\t\t \n\t\t\t\tprivate boolean isEndOfLine(int c) \n\t\t\t\t{\n\t\t\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic interface SpaceCharFilter\n\t\t\t    {\n\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstatic class CodeX {\n\t        public static void sort(long arr[]) {\n\t            merge_sort(arr, 0, arr.length - 1);\n\t        }\n\t\n\t        private static void merge_sort(long A[], long start, long end) {\n\t            if (start < end) {\n\t                long mid = (start + end) / 2;\n\t                merge_sort(A, start, mid);\n\t                merge_sort(A, mid + 1, end);\n\t                merge(A, start, mid, end);\n\t            }\n\t\n\t        }\n\t\n\t        private static void merge(long A[], long start,long mid, long end) {\n\t            long p = start, q = mid + 1;\n\t            long Arr[] = new long[(int)(end - start + 1)];\n\t            long k = 0;\n\t\n\t            for (int i = (int)start; i <= end; i++) {\n\t                if (p > mid)\n\t                    Arr[(int)k++] = A[(int)q++];\n\t\n\t                else if (q > end)\n\t                    Arr[(int)k++] = A[(int)p++];\n\t\n\t                else if (A[(int)p] < A[(int)q])\n\t                    Arr[(int)k++] = A[(int)p++];\n\t\n\t                else\n\t                    Arr[(int)k++] = A[(int)q++];\n\t            }\n\t            for (int i = 0; i < k; i++) {\n\t                A[(int)start++] = Arr[i];\n\t            }\n\t\n\t        }\n\t\n\t    }\n\t\t}\t\n\t\t\n\n\t\t\t", "complexity": "nlogn", "problem": "0957_C", "from": "CODEFORCES", "tags": "binary search,greedy,math,two pointers"}
{"src": "import java.util.Scanner;\n\n\npublic class BB {\npublic static void main(String[] args) {\n\tScanner sc=new Scanner(System.in);\n\tlong a=sc.nextLong();\n\tlong b=sc.nextLong();\n\t\n\tif(b-a>(long)2){\n\t\tif(a%(long)2==0){\n\t\t\tSystem.out.print(a+\" \"+(a+1)+\" \"+(a+2));\n\t\t\treturn;\n\t\t}else{\n\t\t\tSystem.out.print(a+1+\" \"+(a+2)+\" \"+(a+3));\n\t\t\treturn;\n\t\t}\n\t\t\n\t}else{\n\t\tif(b-a<=(long)1){\n\t\tSystem.out.println(-1);\n\t\treturn;\n\t\t}\n\t\tif(b-a==(long)2){\n\t\t\tif(a%(long)2==0){\n\t\t\t\tSystem.out.print(a+\" \"+(a+1)+\" \"+(a+2));\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tSystem.out.print(-1);\n\t\t\t\treturn;\n\t\t\t}\t\n\t\t\t\n\t\t\t}\n\t}\n\n}\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main{\npublic static void main(String[] args){\n Scanner s= new Scanner(System.in);\n int n=s.nextInt();StringBuilder sb=new StringBuilder();\n long[] a=new long[n/2];\n for(int i=0;i<n/2;i++){\n                  a[i]=s.nextLong();\n }int j=0;long[] a2=new long[n/2];long[] a1=new long[n/2];\n a1[j]=a[a.length-1]/2;\n a2[j]=a[a.length-1]-a[a.length-1]/2;\n for(int i=(n-1)/2-1;i>=0;i--){\n //    a1[j]=a[i]/2;a2[j++]=a[i]-a[i]/2;\n    long n1=a1[j];\n    if((a[i]-n1)<a2[j]){\n      a2[j+1]=a2[j++];a1[j]=a[i]-a2[j];                      \n     }else{a1[++j]=n1;a2[j]=a[i]-n1;}\n }int k=0;//int[] ans=new int[2*n];\n for(int i=(n-1)/2;i>=0;i--)\n   sb.append(a1[i]+\" \");\n  for(int i=0;i<n/2;i++)\n    sb.append(a2[i]+\" \");\n            System.out.println(sb.toString());     \n}\n}", "complexity": "linear", "problem": "1093_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF {\n\n\tclass W implements Comparable<W> {\n\t\tint id, sz;\n\n\t\tW(int id, int sz) {\n\t\t\tthis.id = id;\n\t\t\tthis.sz = sz;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(W o) {\n\t\t\treturn -Integer.compare(sz, o.sz);\n\t\t}\n\t}\n\n\tint[] left;\n\tint center;\n\tboolean[] used;\n\n\tboolean go(int v) {\n\t\tif (used[v])\n\t\t\treturn false;\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < g[v].size(); ++i) {\n\t\t\tint to = g[v].get(i);\n\t\t\tif (to == center)\n\t\t\t\tcontinue;\n\t\t\tif (left[to] == -1 || go(left[to])) {\n\t\t\t\tleft[to] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tArrayList<Integer>[] g;\n\n\tvoid solve() {\n\t\t\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tused = new boolean[n];\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tg[in.nextInt() - 1].add(in.nextInt() - 1);\n\t\t}\n\t\tlong st = System.currentTimeMillis();\n\t\tint ans = Integer.MAX_VALUE;\n\t\tW[] a = new W[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = new W(i, g[i].size());\n\t\t}\n\t\tleft = new int[n];\n\t\tArrays.sort(a);\n\t\tfor (int centerId = 0; centerId < n; centerId++) {\n\t\t\tcenter = a[centerId].id;\n\t\t\tif (System.currentTimeMillis() - st > 800)\n\t\t\t\tbreak;\n\t\t\tint cost = n - g[center].size();\n\t\t\tArrays.fill(left, -1);\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (i != center) {\n\t\t\t\t\tboolean has = false;\n\t\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\t\tif (g[i].get(j) == center)\n\t\t\t\t\t\t\thas = true;\n\t\t\t\t\t}\n\t\t\t\t\tArrays.fill(used, false);\n\t\t\t\t\tif (!go(i)) {\n\t\t\t\t\t\tif (has) {\n\t\t\t\t\t\t\tcost += g[i].size();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcost += g[i].size() + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (has) {\n\t\t\t\t\t\t\tcost += g[i].size() - 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcost += g[i].size();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tans = Math.min(ans, cost);\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tFastScaner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScaner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tvoid runWithFiles() {\n\t\tin = new FastScaner(new File(\"input.txt\"));\n\t\ttry {\n\t\t\tout = new PrintWriter(new File(\"output.txt\"));\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tLocale.setDefault(Locale.US);\n\t\tnew CF().run();\n\t}\n\n\tclass FastScaner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScaner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tFastScaner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}", "complexity": "cubic", "problem": "0387_D", "from": "CODEFORCES", "tags": "graph matchings"}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class CodeForces {\n\n\tpublic void solve() throws IOException {\n\t\tint n=nextInt();\n\t\tint t=nextInt();\n\t\tdouble larr[]=new double [n];\n\t\tdouble rarr[]=new double [n];\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x=nextDouble();\n\t\t\tdouble r=nextDouble();\n\t\t\tlarr[i]=x-r/2;\n\t\t\trarr[i]=x+r/2;\n\t\t}\n\t\tArrays.sort(larr);\n\t\tArrays.sort(rarr);\n\t\t\n\t\tint counter=2;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(larr[i]-rarr[i-1]>t){\n\t\t\t\tcounter+=2;\n\t\t\t} else if(larr[i]-rarr[i-1]==t){\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\t\n\t\twriter.print(counter);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew CodeForces().run();\n\t}\n\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\n\tpublic void run() {\n\t\ttry {\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t//reader = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\t//writer = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n\t\t\t// long t=new Date().getTime();\n\t\t\tsolve();\n\t\t\t// writer.println(t-new Date().getTime());\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "\n\nimport java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class ProblemE_16 {\n    \n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\")!=null;\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n    \n    void init() throws FileNotFoundException{\n        if (ONLINE_JUDGE){\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }else{\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        }\n    }\n    \n    String readString() throws IOException{\n        while(!tok.hasMoreTokens()){\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n    \n    int readInt() throws IOException{\n        return Integer.parseInt(readString());\n    }\n    \n    long readLong() throws IOException{\n        return Long.parseLong(readString());\n    }\n    \n    double readDouble() throws IOException{\n        return Double.parseDouble(readString());\n    }\n    \n    public static void main(String[] args){\n        new ProblemE_16().run();\n    }\n    \n    public void run(){\n        try{\n            long t1 = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \"+(t2-t1));\n        }catch (Exception e){\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n    \n    void solve() throws IOException{\n        int n = readInt();\n        double[][] a = new double[n][n];\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < n; j++){\n                a[i][j] = readDouble();\n            }\n        }\n        double[] d = new double[1<<n];\n        d[(1 << n) - 1] = 1;\n        for (int i = (1 << n) - 1; i > 0; i--){\n            ArrayList<Integer> list = new ArrayList<Integer>();\n            for (int j = 0; j < n; j++){\n                if ((i & (1 << j)) != 0) list.add(j);\n            }\n            double s = 0;\n            for (int j = 0; j < list.size(); j++){\n                s = 0;\n                for (int k = 0; k < list.size(); k++){\n                    s += a[list.get(k)][list.get(j)];\n                }\n                d[i ^ (1 << list.get(j))] += s * d[i] * 2 / list.size() / (list.size() - 1);\n            }\n        }\n        for (int i = 0; i < n; i++){\n            out.printf(Locale.US, \"%.9f\", d[1 << i]);\n            out.print(\" \");\n        }\n    }\n    \n    static int[][] step8 = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {1, -1}, {-1, 1}, {1, 1}};\n    \n    static int[][] stepKnight = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n    \n    static long gcd(long a, long b){\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n    \n    static long lcm(long a, long b){\n        return a / gcd(a, b)*b;\n    }\n\n    static long[] gcdPlus(long a, long b){\n        long[] d = new long[3];\n        if (a == 0){\n            d[0] = b;\n            d[1] = 0;\n            d[2] = 1;\n        }else{\n            d = gcdPlus(b % a, a);\n            long r = d[1];\n            d[1] = d[2] - b/a*d[1];\n            d[2] = r;\n        }\n        return d;\n    }\n    \n    static long binpow(long a, int n){\n        if (n == 0) return 1;\n        if ((n & 1) == 0){\n            long b = binpow(a, n/2);\n            return b*b;\n        }else return binpow(a, n - 1)*a;\n    }\n    \n    static long binpowmod(long a, int n, long m){\n        if (m == 1) return 0;\n        if (n == 0) return 1;\n        if ((n & 1) == 0){\n            long b = binpowmod(a, n/2, m);\n            return (b*b) % m;\n        }else return binpowmod(a, n - 1, m)*a % m;\n    }\n    \n    static long phi(long n){\n        int[] p = Sieve((int)ceil(sqrt(n)) + 2);\n        long phi = 1;\n        for (int i = 0; i < p.length; i++){\n            long x = 1;\n            while (n % p[i] == 0){\n                n /= p[i];\n                x *= p[i];\n            }\n            phi *= x - x/p[i];\n        }\n        if (n != 1) phi *= n - 1;\n        return phi;\n    }\n    \n    static long f(long n, int x, int k){ //\u041a\u043e\u043b-\u0432\u043e \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b (\u0432\u043a\u043b\u044e\u0447\u0430\u044f 0), \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0445 \u0432 \u0441\u0435\u0431\u0435 \u0446\u0438\u0444\u0440\u044b \u043e\u0442 0 \u0434\u043e k-1\n        if (n == 0) return 1;\n        long b = binpow(10, x - 1);\n        long c = n / b;\n        return (c < k? c: k)*binpow(k, x - 1) + (c < k? 1: 0)*f(n % b, x - 1, k);\n    }\n    \n    static long fib(int n){\n        if (n == 0) return 0;\n        if ((n & 1) == 0){\n            long f1 = fib(n/2 - 1);\n            long f2 = fib(n/2 + 1);\n            return f2*f2 - f1*f1;\n        }else{\n            long f1 = fib(n/2);\n            long f2 = fib(n/2 + 1);\n            return f1*f1 + f2*f2;\n        }\n    }\n    \n    static BigInteger BigFib(int n){\n        if (n == 0) return BigInteger.ZERO;\n        if ((n & 1) == 0){\n            BigInteger f1 = BigFib(n/2 - 1);\n            f1 = f1.multiply(f1);\n            BigInteger f2 = BigFib(n/2 + 1);\n            f2 = f2.multiply(f2);\n            return f2.subtract(f1);\n        }else{\n            BigInteger f1 = BigFib(n/2);\n            f1 = f1.multiply(f1);\n            BigInteger f2 = BigFib(n/2 + 1);\n            f2 = f2.multiply(f2);\n            return f2.add(f1);\n        }\n    }\n    \n    static public class PointD{\n        \n        double x, y;\n        \n        public PointD(double x, double y){\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static double d(Point p1, Point p2){\n        return sqrt(d2(p1, p2));\n    }\n    \n    static public double d(PointD p1, PointD p2){\n        return sqrt(d2(p1, p2));\n    }\n    \n    static double d2(Point p1, Point p2){\n        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n    }\n    \n    static public double d2(PointD p1, PointD p2){\n        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n    }\n    \n    static boolean IsProbablyPrime(long n){\n        if (n == 1) return false;\n        if ((n & 1) == 0) return false;\n        for (int j = 3; j < sqrt(n) + 1; j += 2){\n            if (n % j == 0) return false;\n        }\n        return true;\n    }\n\n    static int[] Sieve(int n){\n        boolean[] b = new boolean[n+1];\n        Arrays.fill(b, true);\n        b[0] = false;\n        b[1] = false;\n        long nLong = n;\n        int j=0;\n        for (int i = 1; i <= n; i++) {\n            if (b[i]){\n                j++;\n                if (((long)i)*i <= nLong) {\n                    for (int k = i*i; k <= n; k += i) {\n                        b[k] = false;\n                    }\n                }\n            }\n        }\n        int[] p = new int[j];\n        Arrays.fill(p, 0);\n        j=0;\n        for (int i = 2; i <= n; i++) {\n            if (b[i]){\n                p[j]=i;\n                j++;\n            }\n        }\n        return p;\n    }\n    \n    static int[][] Palindromes(String s){\n        char[] c = s.toCharArray();\n        int n = c.length;\n        int[][] d = new int[2][n];\n        int l = 0, r = -1;\n        for (int i = 0; i < n; i++){\n            int j = (i > r? 0: min(d[0][l+r-i+1], r-i+1)) + 1;\n            for (; i - j >= 0 && i + j - 1< n && c[i-j] == c[i+j-1]; j++);\n            d[0][i] = --j;\n            if (i + d[0][i] - 1 > r){\n                r = i + d[0][i] - 1;\n                l = i - d[0][i];\n            }\n        }\n        l = 0;\n        r = -1;\n        for (int i = 0; i < n; i++){\n            int j = (i > r? 0: min(d[1][l+r-i], r-i)) + 1;\n            for (; i - j >= 0 && i + j < n && c[i-j] == c[i+j]; j++);\n            d[1][i] = --j;\n            if (i + d[1][i] > r){\n                r = i + d[1][i];\n                l = i - d[1][i];\n            }\n        }\n        return d;\n    }\n    \n    static public class Permutation {\n        \n        int[] a;\n        int n;\n        \n        public Permutation(int n){\n            this.n=n;\n            a=new int[n];\n            for (int i=0; i<n; i++){\n                a[i]=i;\n            }\n        }\n        \n        public boolean nextPermutation(){ //\u041f\u0438\u0448\u0435\u0442\u0441\u044f \u0441 do{}while(nextPermutation(a));\n            int i=n-1;\n            for (i=n-2; i>=0; i--){\n                if (a[i]<a[i+1]){\n                    break;\n                }\n            }\n            if (i==-1){\n                return false;\n            }\n            int jMin=i+1;\n            for (int j=n-1; j>i; j--){\n                if (a[i]<a[j]&&a[j]<a[jMin]){\n                    jMin=j;\n                }\n            }\n            swap(i, jMin);\n            for (int j=1; j<=(n-i)/2; j++){\n                swap(i+j, n-j);\n            }\n            return true;\n        }\n        \n        \n        public int get(int i){\n            return a[i];\n        }\n        \n        void swap(int i, int j){\n            int r=a[i];\n            a[i]=a[j];\n            a[j]=r;\n        }\n    }\n    \n    static public class Fraction implements Comparable<Fraction>, Cloneable{\n        \n        public final Fraction FRACTION_ZERO = new Fraction();\n        public final Fraction FRACTION_ONE = new Fraction(1);\n        public long numerator = 0;\n        public long denominator = 1;\n        \n        public Fraction(){\n            numerator = 0;\n            denominator = 1;\n        }\n        \n        public Fraction(long numerator){\n            this.numerator = numerator;\n            denominator = 1;\n        }\n        \n        public Fraction(long numerator, long denominator){\n            this.numerator = numerator;\n            this.denominator = denominator;\n            Cancellation();\n        }\n        \n        public Fraction(double numerator, double denominator, int accuracy){\n            this.numerator = (long)(numerator*pow(10,accuracy));\n            this.denominator = (long)(denominator*pow(10,accuracy));\n            Cancellation();\n        }\n        \n        public Fraction(String s){\n            if (s.charAt(0) == '-'){\n                denominator = -1;\n                s = s.substring(1);\n            }\n            if (s.indexOf(\"/\") != -1){\n                denominator *= Integer.parseInt(s.substring(s.indexOf(\"/\") + 1));\n            }\n            if (s.indexOf(\" \") != -1){\n                numerator = Integer.parseInt(s.substring(0, s.indexOf(\" \"))) * abs(denominator) + Integer.parseInt(s.substring(s.indexOf(\" \") + 1, s.indexOf(\"/\")));\n            }else{\n                if (s.indexOf(\"/\") != -1){\n                    numerator = Integer.parseInt(s.substring(0, s.indexOf(\"/\")));\n                }else{\n                    numerator = Integer.parseInt(s)*abs(denominator);\n                }\n            }\n            this.Cancellation();\n        }\n        \n        void Cancellation(){\n            long g = gcd(abs(numerator), abs(denominator));\n            numerator /= g;\n            denominator /= g;\n            if (denominator < 0){\n                numerator *= -1;\n                denominator *= -1;\n            }\n        }\n        \n        public String toString(){\n            String s = \"\";\n            if (numerator == 0){\n                return \"0\";\n            }\n            if (numerator < 0){\n                s += \"-\";\n            }\n            if (abs(numerator) >= denominator){\n                s += Long.toString(abs(numerator) / denominator) + \" \";\n            }\n            if (abs(numerator) % denominator != 0){\n                s += Long.toString(abs(numerator) % denominator);\n            }else{\n                s = s.substring(0, s.length()-1);\n            }\n            if (denominator != 1){\n                s += \"/\" + Long.toString(denominator);\n            }\n            return s;\n        }\n        \n        public Fraction add(Fraction f){\n            Fraction fResult = new Fraction();\n            fResult.denominator = lcm(denominator, f.denominator);\n            fResult.numerator = numerator * fResult.denominator / denominator + f.numerator * fResult.denominator / f.denominator;\n            fResult.Cancellation();\n            return fResult;\n        }\n        \n        public Fraction subtract(Fraction f){\n            Fraction fResult = new Fraction();\n            fResult.denominator = lcm(denominator, f.denominator);\n            fResult.numerator = numerator * fResult.denominator / denominator - f.numerator * fResult.denominator / f.denominator;\n            fResult.Cancellation();\n            return fResult;\n        }\n        \n        public Fraction multiply(Fraction f){\n            Fraction fResult = new Fraction();\n            fResult.numerator = numerator * f.numerator;\n            fResult.denominator = denominator * f.denominator;\n            fResult.Cancellation();\n            return fResult;\n        }\n        \n        public Fraction divide(Fraction f){\n            Fraction fResult = new Fraction();\n            fResult.numerator = numerator * f.denominator;\n            fResult.denominator = denominator * f.numerator;\n            fResult.Cancellation();\n            return fResult;\n        }\n        \n        @Override\n        public int compareTo(Fraction f){\n            long g = gcd(denominator, f.denominator);\n            long res = numerator * (f.denominator / g) - f.numerator * (denominator / g);\n            if (res < 0){\n                return -1;\n            }\n            if (res > 0){\n                return 1;\n            }\n            return 0;\n        }\n        \n        public Fraction clone(){\n            Fraction fResult = new Fraction(numerator, denominator);\n            return fResult;\n        }\n        \n        public Fraction floor(){\n            Fraction fResult = this.clone();\n            fResult.numerator = (fResult.numerator / fResult.denominator) * fResult.denominator;\n            return fResult;\n        }\n        \n        public Fraction ceil(){\n            Fraction fResult = this.clone();\n            fResult.numerator = (fResult.numerator/fResult.denominator + 1) * fResult.denominator;\n            return fResult;\n        }\n        \n        public Fraction binpow(int n){\n            if (n==0) return FRACTION_ONE;\n            if ((n&1)==0){\n                Fraction f=this.binpow(n/2);\n                return f.multiply(f);\n            }else return binpow(n-1).multiply(this);\n        }\n    }\n    \n    static public class FenwickTree_1{  //One-dimensional array     \n        \n        int n;\n        long[] t;\n        \n        public FenwickTree_1(int n){\n            this.n = n;\n            t = new long[n];\n        }\n        \n        public long sum(int xl, int xr){\n            return sum(xr) - sum(xl);\n        }\n        \n        public long sum(int x){\n            long result = 0;\n            for (int i = x; i >= 0; i = (i & (i + 1)) - 1){\n                result += t[i];\n            }\n            return result;\n        }\n        \n        public void update(int x, long delta){\n            for (int i = x; i < n; i = (i | (i + 1))){\n                t[i] += delta;\n            }\n        }\n    }\n    \n    static public class FenwickTree_2{  //Two-dimensional array\n        \n        int n, m;\n        long[][] t;\n        \n        public FenwickTree_2(int n, int m){\n            this.n = n;\n            this.m = m;\n            t = new long[n][m];\n        }\n        \n        public long sum(int xl, int yl, int xr, int yr){\n            return sum(xr, yr) - sum(xl - 1, yr) - sum(xr, yl - 1) + sum(xl - 1, yl - 1);\n        }\n        \n        public long sum(int x, int y){\n            long result = 0;\n            for (int i = x; i >= 0; i = (i & (i + 1)) - 1){\n                for (int j = y; j >= 0; j = (j & (j + 1)) - 1){\n                    result+=t[i][j];\n                }\n            }\n            return result;\n        }\n        \n        public void update(int x, int y, long delta){\n            for (int i = x; i < n; i = (i | (i + 1))){\n                for (int j = y; j < m; j = (j | (j + 1))){\n                    t[i][j] += delta;\n                }\n            }\n        }\n    }\n    \n    static public class FenwickTree_3{  //Three-dimensional array\n        \n        int n, m, l;\n        long[][][] t;\n        \n        public FenwickTree_3(int n, int m, int l){\n            this.n = n;\n            this.m = m;\n            this.l = l;\n            t = new long[n][m][l];\n        }\n        \n        public long sum(int xl, int yl, int zl, int xr, int yr, int zr){\n            return sum(xr, yr, zr) - sum(xl - 1, yr, zr)\n            + sum(xl - 1, yr, zl - 1) - sum(xr, yr, zl - 1)\n            - sum(xr, yl - 1, zr) + sum(xl - 1, yl - 1, zr)\n            - sum(xl - 1, yl - 1, zl - 1) + sum(xr, yl - 1, zl - 1);\n        }\n        \n        public long sum(int x, int y, int z){\n            long result = 0;\n            for (int i = x; i >= 0; i = (i & (i + 1)) - 1){\n                for (int j = y; j >= 0; j = (j & (j + 1)) - 1){\n                    for (int k = z; k >= 0; k = (k & (k + 1)) - 1){\n                        result += t[i][j][k];\n                    }\n                }\n            }\n            return result;\n        }\n        \n        public void update(int x, int y, int z, long delta){\n            for (int i = x; i < n; i = (i | (i + 1))){\n                for (int j = y; j < n; j = (j | (j + 1))){\n                    for (int k = z; k < n; k = (k | (k + 1))){\n                        t[i][j][k] += delta;\n                    }\n                }\n            }\n        }\n    }\n}\n\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\n\npublic class A25 {\n\n\tstatic StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\t\n\tstatic int nextInt() throws Exception {\n\t\tin.nextToken();\n\t\treturn (int)in.nval;\n\t}\n\t\n\tstatic String nextString() throws Exception {\n\t\tin.nextToken();\n\t\treturn in.sval;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tint n = nextInt();\n\t\tint[] c = new int[2];\n\t\tint[] f = new int[2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = nextInt(), p = x%2;\n\t\t\tif (c[p]++ == 0) f[p] = i+1;\n\t\t}\n\t\tout.println(c[0] == 1 ? f[0] : f[1]);\n\t\t\n\t\tout.flush();\n\t}\n\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n \n \npublic class TaskC {\n\t\n\tpublic static void main(String[] args) {\n\t\tnew TaskC().run();\n\t}\n\t\n\tvoid solve(){\n\t\tint n = in.nextInt();\n\t\tString s[] = new String[n];\n\t\tfor(int i = 0; i < n; i++) s[i] = in.next();\n\t\tif(s[n-1].compareTo(\"f\") == 0){\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint dp[] = new int[n+2];\n\t\tint mod = 1000*1000*1000+7;\n\t\tdp[0] = 1;\n\t\tfor(int i = n-1; i >= 0; i--){\t\n\t\t\tif(s[i].compareTo(\"s\") == 0){\n\t\t\t\tint ss = 0;\n\t\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\t\tss += dp[j];\n\t\t\t\t\tif(ss>=mod) ss -= mod;\n\t\t\t\t\tdp[j] = ss;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < n;j++){\n\t\t\t\t\tdp[j] = dp[j+1];\n\t\t\t\t}\n\t\t\t\tdp[n] = 0;\n\t\t\t}\n\t\t}\n\t\tout.println(dp[0]);\n\t}\n\n\t\n\tFastScanner in;\n\tPrintWriter out;\n\tvoid run() {\n\t\tin = new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tint tests = 1;//in.nextInt();\n\t\twhile(tests > 0){\n\t\t\tsolve();\n\t\t\ttests--;\n\t\t}\n\t\tout.close();\n\t}\n\t\n\tclass Pair implements Comparable<Pair>{\n\t\tInteger x, y;\n\t\tpublic Pair(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(x.compareTo(o.x) == 0) return y.compareTo(o.y);\n\t\t\treturn x.compareTo(o.x);\n\t\t}\n\t\t\n\t}\n \n\tclass FastScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader bf;\n \n\t\tpublic FastScanner(InputStream is) {\n\t\t\tbf = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tpublic FastScanner(File f){\n\t\t\ttry{\n\t\t\t\tbf = new BufferedReader(new FileReader(f));\n\t\t\t}\n\t\t\tcatch(IOException ex){\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tString next(){\n\t\t\twhile(st == null || !st.hasMoreTokens()){\n\t\t\t\ttry{\n\t\t\t\t\tst = new StringTokenizer(bf.readLine());\n\t\t\t\t}\n\t\t\t\tcatch(Exception ex){\n\t\t\t\t\tex.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt(){\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong(){\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble(){\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tint[] readArray(int n){\n\t\t\tint[] a = new int[n];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n \n} \n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    static final String FILE = \"\";\n\n    public void solve() {\n        int n = in.nextInt();\n        TreeMap<Character, Integer> map = new TreeMap<>();\n        ArrayList<Integer> list = new ArrayList<>();\n        String s = in.next();\n        for (int i = 0; i < n; i++) {\n            char ch = s.charAt(i);\n            if (!map.containsKey(ch))\n                map.put(ch, map.size());\n            list.add(map.get(ch));\n        }\n\n        int l = 0;\n        int ans = Integer.MAX_VALUE;\n        int nad = map.size();\n        int cnt[] = new int[n];\n\n        for (int i = 0; i < list.size(); i++) {\n            if (cnt[list.get(i)] == 0)\n                nad--;\n            cnt[list.get(i)]++;\n\n            if (nad == 0) {\n                ans = min(ans, i - l + 1);\n                while (true) {\n                    if (cnt[list.get(l)] == 1) {\n                        ans = min(ans, i - l + 1);\n                        cnt[list.get(l)]--;\n                        l++;\n                        nad++;\n                        break;\n                    } else {\n                        cnt[list.get(l)]--;\n                        l++;\n                    }\n                }\n            }\n        }\n\n        out.print(ans);\n    }\n\n    public void run() {\n        if (FILE.equals(\"\")) {\n            in = new FastScanner(System.in);\n            out = new PrintWriter(System.out);\n        } else {\n            try {\n                in = new FastScanner(new FileInputStream(FILE +\n                        \".in\"));\n                out = new PrintWriter(new FileOutputStream(FILE +\n                        \".out\"));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        (new Main()).run();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public float nextFloat() {\n            return Float.parseFloat(next());\n        }\n    }\n\n    class Pair<A extends Comparable<A>, B extends Comparable<B>>\n            implements Comparable<Pair<A, B>> {\n        public A a;\n        public B b;\n\n        public Pair(A a, B b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Pair<A, B> o) {\n            if (o == null || o.getClass() != getClass())\n                return 1;\n            int cmp = a.compareTo(o.a);\n            if (cmp == 0)\n                return b.compareTo(o.b);\n            return cmp;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n\n            if (a != null ? !a.equals(pair.a) : pair.a != null) return\n                    false;\n            return !(b != null ? !b.equals(pair.b) : pair.b != null);\n        }\n    }\n\n    class PairInt extends Pair<Integer, Integer> {\n        public PairInt(Integer u, Integer v) {\n            super(u, v);\n        }\n    }\n\n    class PairLong extends Pair<Long, Long> {\n        public PairLong(Long u, Long v) {\n            super(u, v);\n        }\n    }\n\n}", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class One {\n\tInputStreamReader inp = new InputStreamReader(System.in);\n\tBufferedReader in = new BufferedReader(inp);\n\tboolean test = false;\n\n\t// String[] inData = { \"4\", \"A\", \"B\", \"C\", \"D\", \"A-B 1:1\", \"A-C 2:2\",\n\t// \"A-D 1:0\", \"B-C 1:0\", \"B-D 0:3\", \"C-D 0:3\" };\n\tString[] inData = { \"4\",\"1 1 2\" };\n\n\tstatic int id = -1;\n\n\tpublic String readLine() throws IOException {\n\t\tid++;\n\t\tif (test)\n\t\t\treturn inData[id];\n\t\telse\n\t\t\treturn in.readLine();\n\t}\n\n\tpublic void solve() throws Exception {\n\t\treadLine();\n\t\tString readLine = readLine();\n\t\t\n\t\tString[] split = readLine.split(\" \");\n\t\tList<Integer> ints = new ArrayList<Integer>();\n\t\t\n\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\tints.add(Integer.valueOf(split[i]));\n\t\t}\n\t\t\n\t\tCollections.sort(ints);\n\t\tInteger object = ints.get(0);\n\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\tif(ints.get(i).compareTo(object) > 0){\n\t\t\t\tSystem.out.println(ints.get(i));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"NO\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tnew One().solve();\n\n\t}\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class P1 {\n\tpublic static void main(String[] args) {\n\t\tString s = null;\n\t\t// citire\n\t\ttry {\n//\t\t\tScanner sc = new Scanner(new File(\"in.txt\"));\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\ts = sc.next();\n\t\t\t\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tint n = s.length();\n\t\t\n\t\tHashSet<String> h = new HashSet<String>();\n\t\tString t=null;\n\t\tboolean b;\n\t\tint lmax = 0;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tfor (int j=i+1; j<=n; j++) {\n\t\t\t\tt = s.substring(i, j);\n\t\t\t\tb = h.add(t);\n//\t\t\t\tSystem.out.println(t + \"\t\"  + b);\n\t\t\t\tif (b==false) {\n\t\t\t\t\tif (j-i>lmax) {\n\t\t\t\t\t\tlmax = j-i;\n//\t\t\t\t\t\tSystem.out.println(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(lmax);\n\t}\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.Scanner;\n\n\npublic class A275 {\n\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        \n        long a=sc.nextLong();\n        long b=sc.nextLong();\n        \n        if(b-a<2){\n            System.out.println(-1);\n        }else if(b-a==2 && a%2==1){\n            System.out.println(-1);\n        }else if(b-a==2 && a%2==0){\n            System.out.println(a+\" \"+(a+1)+\" \"+(a+2));\n        }else{\n            if(a%2==0){\n                System.out.println(a+\" \"+(a+1)+\" \"+(a+2));\n            }else{\n                System.out.println((a+1)+\" \"+(a+2)+\" \"+(a+3));\n            }\n        }\n    }\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString [] line = br.readLine().split(\" \");\n\t\tlong l = Long.parseLong(line[0]);\n\t\tlong r = Long.parseLong(line[1]);\n\t\tif(r-l < 2 || ((r-l == 2) && (l % 2 == 1)))\n\t\t\tSystem.out.println(\"-1\");\n\t\telse\n\t\t{\n\t\t\tLong start = l + (l%2); \n\t\t\tSystem.out.println(start + \" \" + (start + 1) + \" \" + (start + 2));\n\t\t}\n\t}\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author gaidash\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        ARaskrashivanieChisel solver = new ARaskrashivanieChisel();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ARaskrashivanieChisel {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            final int MAX = 100;\n\n            int n = in.nextInt();\n            int[] a = in.nextSortedIntArray(n);\n\n            int ret = 0;\n            boolean[] used = new boolean[MAX + 1];\n            for (int i = 0; i < n; i++) {\n                if (!used[a[i]]) {\n                    used[a[i]] = true;\n                    ret++;\n                    for (int j = i + 1; j < n; j++) {\n                        if (a[j] % a[i] == 0 && !used[a[j]]) {\n                            used[a[j]] = true;\n                        }\n                    }\n                }\n            }\n\n            out.println(ret);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public int[] nextSortedIntArray(int n) {\n            int array[] = nextIntArray(n);\n            Arrays.sort(array);\n            return array;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "/**\n * author: derrick20\n * created: 11/11/20 1:45 PM\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class OnTheBenchAlt {\n    public static void main(String[] args) {\n        setupCombo(301);\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int N = sc.nextInt();\n        long[] a = new long[N];\n        HashMap<Long, Integer> clusters = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            a[i] = removeSquares(sc.nextLong());\n            clusters.merge(a[i], 1, Integer::sum);\n        }\n        int G = clusters.size();\n        int[] groups = new int[G + 1];\n        int ptr = 1;\n        for (int amt : clusters.values()) {\n            groups[ptr++] = amt;\n        }\n        long[][] dp = new long[G + 1][N + 1];\n        // dp[g][bad] = ways to interleave first g groups for a given # of bad pairs\n        dp[0][0] = 1;\n        // dp[0][k] = 0, k != 0\n        int total = 0;\n        /*\n        intuition for runtime analysis:\n        Say there were k groups, each size n / k\n\n        The outer loop is k, 2nd loop is n worst case,\n        and the inner 2 are bounded by n / k (amt per group)\n        k * n * (n / k) * (n / k) = n^3 / k, which works despite 4 loops!!\n\n        Seems hard to convert into pull-dp since prevBad has a more direct\n        meaning in the arrangements, so using that as our variable makes more sense\n         */\n        for (int prefix = 1; prefix <= G; prefix++) {\n            int amt = groups[prefix];\n            // key bugs here and there: USE THE CORRECT BOUNDS\n            for (int prevBad = 0; prevBad <= max(0, total - 1); prevBad++) {\n                for (int fixed = 0; fixed <= min(prevBad, amt); fixed++) {\n                    for (int slots = max(1, fixed); slots <= min(amt, total + 1); slots++) {\n                        int introduced = amt - slots;\n                        long ways = mult(\n                                choose[prevBad][fixed],\n                                choose[total + 1 - prevBad][slots - fixed],\n                                choose[amt - 1][slots - 1],\n                                fact[amt],\n                                dp[prefix - 1][prevBad] // key bug: NEED TO RELATE PREVIOUS DP\n                        );\n                        int currBad = prevBad + introduced - fixed;\n                        dp[prefix][currBad] = (dp[prefix][currBad] + ways) % mod;\n                    }\n                }\n            }\n            total += amt;\n//            System.out.println(Arrays.toString(dp[prefix]));\n        }\n        out.println(dp[G][0]);\n        out.close();\n    }\n\n    static long mod = (long) 1e9 + 7;\n    static long[][] choose;\n    static long[] fact;\n\n    static long removeSquares(long x) {\n        long curr = x;\n        for (long v = 2; v * v <= x && curr > 1; v++) {\n            int cnt = 0;\n            while (curr % v == 0) {\n                curr /= v;\n                cnt ^= 1;\n            }\n            if (cnt == 1)\n                curr *= v;\n        }\n        return curr;\n    }\n\n    static long choose(int n, int k) {\n        return k < 0 || k > n ? 0 : choose[n][k];\n    }\n\n    static long mult(long... multiplicands) {\n        long ans = 1;\n        for (long v : multiplicands) {\n            ans = (ans * v) % mod;\n        }\n        return ans;\n    }\n\n    static void setupCombo(int MAX) {\n        choose = new long[MAX + 1][MAX + 1];\n        fact = new long[MAX + 1];\n        choose[0][0] = 1;\n        fact[0] = 1;\n        for (int i = 1; i <= MAX; i++) {\n            fact[i] = (long) i * fact[i - 1] % mod;\n            choose[i][0] = 1;\n            for (int j = 1; j < i; j++) {\n                choose[i][j] = (choose[i - 1][j - 1] + choose[i - 1][j]) % mod;\n            }\n            choose[i][i] = 1;\n        }\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n\n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n\n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n\n        private char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public int[] nextInts(int N) {\n            int[] res = new int[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = (int) nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongs(int N) {\n            long[] res = new long[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n\n        public double nextDouble() {\n            double cur = nextLong();\n            return c != '.' ? cur : cur + nextLong() / cnt;\n        }\n\n        public double[] nextDoubles(int N) {\n            double[] res = new double[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n\n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}", "complexity": "cubic", "problem": "0840_C", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "/*\nIf you want to aim high, aim high\nDon't let that studying and grades consume you\nJust live life young\n******************************\nWhat do you think? What do you think?\n1st on Billboard, what do you think of it\nNext is a Grammy, what do you think of it\nHowever you think, I\u2019m sorry, but shit, I have no fcking interest\n*******************************\nI'm standing on top of my Monopoly board\nThat means I'm on top of my game and it don't stop\ntil my hip don't hop anymore\nhttps://www.a2oj.com/Ladder16.html\n*******************************\n300iq as writer = Sad!\n*/\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n   public class x1242C2\n   {\n      public static void main(String hi[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         long[] sums = new long[N];\n         ArrayList<Integer>[] boxes = new ArrayList[N];\n         for(int i=0; i < N; i++)\n         {\n            boxes[i] = new ArrayList<Integer>();\n            st = new StringTokenizer(infile.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            while(a-->0)\n               boxes[i].add(Integer.parseInt(st.nextToken()));\n            for(int x: boxes[i])\n               sums[i] += x;\n         }\n         long lmaosum = 0L;\n         for(long x: sums)\n            lmaosum += x;\n         if(Math.abs(lmaosum)%N != 0)\n         {\n            System.out.println(\"No\");\n            return;\n         }\n         long target = lmaosum/N;\n         //fuck fuck fuck fuck fuck fuck fuck fuck fuck fuck fuck fuck fuck fuck fuck\n         HashMap<Long, Integer> map = new HashMap<Long, Integer>();\n         for(int k=0; k < N; k++)\n            for(int x: boxes[k])\n               map.put((long)x, k);\n         HashMap<Long, Long> edges = new HashMap<Long, Long>();\n         for(int k=0; k < N; k++)\n            for(int x: boxes[k])\n            {\n               long nextval = target-sums[k]+x;\n               if(map.containsKey(nextval))\n                  edges.put((long)x, nextval);\n            }\n         Node[] dp = new Node[1<<N];\n         dp[0] = new Node(-69, -69, 0);\n         //precompute subsets ass\n         Node[] subsets = new Node[1<<N];\n         for(int b=0; b < N; b++)\n            for(int i=0; i < boxes[b].size(); i++)\n            {\n               if(!edges.containsKey((long)boxes[b].get(i)))\n                  continue;\n               long curr = edges.get((long)boxes[b].get(i));\n               //shit shit shit shit shit shit shit shit shit shit\n               int submask = 0;  boolean cyclic = true;\n               while(curr != boxes[b].get(i))\n               {\n                  int k = map.get(curr);\n                  if((submask&(1<<k)) > 0 || !edges.containsKey((long)curr))\n                  {\n                     cyclic = false;\n                     break;\n                  }\n                  submask |= 1<<k;\n                  curr = edges.get((long)curr);\n               }\n               submask |= (1<<b);\n               if(cyclic)\n                  subsets[submask] = new Node(-69, i, b);\n            }\n         for(int mask=1; mask < (1<<N); mask++)\n            outer:for(int submask=mask; submask > 0; submask=(submask-1)&mask)\n               if(dp[mask^submask] != null && subsets[submask] != null)\n               {\n                  dp[mask] = new Node(mask^submask, subsets[submask].dex, subsets[submask].start);\n                  break outer;\n               }\n         if(dp[(1<<N)-1] == null)\n            System.out.println(\"No\");\n         else\n         {\n            StringBuilder sb = new StringBuilder(\"Yes\\n\");\n            long[][] res = new long[N][2];\n            for(int i=0; i < N; i++)\n               res[i][1] = -1L;\n            int currmask = (1<<N)-1;\n            while(currmask != 0)\n            {\n               int submask = dp[currmask].mask;\n               int i = dp[currmask].dex;\n               int b = dp[currmask].start;\n               long nextval = target-sums[b]+boxes[b].get(i);\n               int curr = map.get(nextval);\n               res[map.get(nextval)][0] = nextval;\n               res[map.get(nextval)][1] = b;\n               while(true)\n               {\n                  int lol = map.get(nextval);\n                  nextval = edges.get(nextval);\n                  res[map.get(nextval)][0] = nextval;\n                  if(res[map.get(nextval)][1] != -1)\n                     break;\n                  res[map.get(nextval)][1] = lol;\n               }\n               currmask = dp[currmask].mask;\n            }\n            for(int k=0; k < N; k++)\n               sb.append(res[k][0]+\" \").append(res[k][1]+1).append(\"\\n\");\n            System.out.print(sb);\n         }\n      }\n   }\n   class Node\n   {\n      public int mask;\n      public int dex;\n      public int start;\n      \n      public Node(int a, int b, int c)\n      {\n         mask = a;\n         dex = b;\n         start = c;\n      }\n   }", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "import java.util.* ;\nimport java.io.* ;\n\npublic class PythonIndentation\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner in = new Scanner(System.in) ;\n\t\tint n = in.nextInt() ;\n\t\tboolean[] lst = new boolean[n] ;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tlst[i] = (in.next().equals(\"s\"))?false:true ;\n\t\t}\n\t\tSystem.out.println(dp(lst)) ;\n\t}\n\tstatic void  arrayPrinter(int[][] dp)\n\t{\n\t\tSystem.out.println(\":::\") ;\n\t\tfor(int i=0;i<dp.length;i++)\n\t\t{\n\t\t\tfor(int j=0;j<dp[0].length;j++)\n\t\t\t{\n\t\t\t\tSystem.out.print(dp[i][j]+\" \") ;\n\t\t\t}\n\t\t\tSystem.out.println() ;\n\t\t}\n\t}\n\tstatic int dp(boolean[] lst)\n\t{//false in lst means an \"s\" (simple statement), and true a \"f\"(for loop)\n\t\tint[][] dp = new int[2][lst.length] ;\n\t\tdp[0][0] = 1 ;\n\t\tfor(int i=1;i<lst.length;i++)\n\t\t{\n\t\t\t// arrayPrinter(dp) ;\n\t\t\tfor(int j=0;j<lst.length;j++)\n\t\t\t{\n\t\t\t\tif(lst[i-1])//(i-1)st statement is a for loop \n\t\t\t\t{\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t\tdp[i%2][j] = 0 ;\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i%2][j] = dp[(i-1)%2][j-1] ;\n\t\t\t\t}\n\t\t\t\n\t\t\t\telse//i-1 st statement is a simple statement\n\t\t\t\t{\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint temp = 0 ;\n\t\t\t\t\t\tfor(int k=0;k<lst.length;k++)\n\t\t\t\t\t\t\ttemp = (temp+dp[(i-1)%2][k])%1000000007 ;\n\t\t\t\t\t\tdp[i%2][j] = temp ;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i%2][j] = (dp[i%2][j-1]-dp[(i-1)%2][j-1])%1000000007 ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0 ;\n\t\tfor(int i=0;i<lst.length;i++)\n\t\t{\n\t\t\tans = (ans + dp[(lst.length-1)%2][i])%1000000007 ;\n\t\t}\n\t\tif(ans<0)\n\t\t\tans = ans + 1000000007 ;\n\t\t// arrayPrinter(dp) ;\n\t\treturn ans ;\n\t}\n}", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class B {\n    static FastScanner fs;\n    public static void main(String[] args) {\n        fs=new FastScanner();\n        int t = fs.nextInt();\n        while (t-->0)\n            solve();\n    }\n    public static void solve() {\n        int n = fs.nextInt()*2;\n        int sq = (int)Math.sqrt(n);\n        int sq2 = (int)Math.sqrt(n/2);\n        if (sq*sq==n) System.out.println(\"YES\");\n        else if (sq2*sq2==n/2.0 && sq2%2==0) System.out.println(\"YES\");\n        else System.out.println(\"NO\");\n    }\n    static int gcd(int a, int b) {\n        if (a==0) return b;\n        return gcd(b%a, a);\n    }\n    static void ruffleSort(int[] a) {\n        int n=a.length;//shuffle, then sort\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n), temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n    static final Random random =new Random();\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        int[] readArray(int n) {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n    static int[] reverse(int[] a) {\n        int n=a.length;\n        int[] res=new int[n];\n        for (int i=0; i<n; i++) res[i]=a[n-1-i];\n        return res;\n    }\n}", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main2 {\n\n    static long mod = 998244353;\n    static FastScanner scanner;\n\n    static Set<Long> second = new HashSet<>();\n    static boolean applied = false;\n\n    public static void main(String[] args) {\n        scanner = new FastScanner();\n        int n = scanner.nextInt();\n        int[] a = scanner.nextIntArray(n);\n        int[] colors = new int[n];\n        ADUtils.sort(a);\n        int color = 0;\n        for (int i = 0; i < n; i++) {\n            if (colors[i] != 0) continue;\n            color++;\n            for (int j = i; j < n; j++) {\n                if (a[j] % a[i] == 0) colors[j] = color;\n            }\n        }\n        System.out.println(color);\n    }\n\n    static class WithIdx implements Comparable<WithIdx>{\n        int val, idx;\n\n        public WithIdx(int val, int idx) {\n            this.val = val;\n            this.idx = idx;\n        }\n\n        @Override\n        public int compareTo(WithIdx o) {\n            return Integer.compare(val, o.val);\n        }\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                e.printStackTrace();\n                throw new RuntimeException();\n            }\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) res[i] = nextInt();\n            return res;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) res[i] = nextLong();\n            return res;\n        }\n\n        String[] nextStringArray(int n) {\n            String[] res = new String[n];\n            for (int i = 0; i < n; i++) res[i] = nextToken();\n            return res;\n        }\n    }\n\n    static class PrefixSums {\n        long[] sums;\n\n        public PrefixSums(long[] sums) {\n            this.sums = sums;\n        }\n\n        public long sum(int fromInclusive, int toExclusive) {\n            if (fromInclusive > toExclusive) throw new IllegalArgumentException(\"Wrong value\");\n            return sums[toExclusive] - sums[fromInclusive];\n        }\n\n        public static PrefixSums of(int[] ar) {\n            long[] sums = new long[ar.length + 1];\n            for (int i = 1; i <= ar.length; i++) {\n                sums[i] = sums[i - 1] + ar[i - 1];\n            }\n            return new PrefixSums(sums);\n        }\n\n        public static PrefixSums of(long[] ar) {\n            long[] sums = new long[ar.length + 1];\n            for (int i = 1; i <= ar.length; i++) {\n                sums[i] = sums[i - 1] + ar[i - 1];\n            }\n            return new PrefixSums(sums);\n        }\n    }\n\n    static class ADUtils {\n        static void sort(int[] ar) {\n            Random rnd = ThreadLocalRandom.current();\n            for (int i = ar.length - 1; i > 0; i--)\n            {\n                int index = rnd.nextInt(i + 1);\n                // Simple swap\n                int a = ar[index];\n                ar[index] = ar[i];\n                ar[i] = a;\n            }\n            Arrays.sort(ar);\n        }\n\n        static void reverse(int[] arr) {\n            int last = arr.length / 2;\n            for (int i = 0; i < last; i++) {\n                int tmp = arr[i];\n                arr[i] = arr[arr.length - 1 - i];\n                arr[arr.length - 1 - i] = tmp;\n            }\n        }\n\n        static void sort(long[] ar) {\n            Random rnd = ThreadLocalRandom.current();\n            for (int i = ar.length - 1; i > 0; i--)\n            {\n                int index = rnd.nextInt(i + 1);\n                // Simple swap\n                long a = ar[index];\n                ar[index] = ar[i];\n                ar[i] = a;\n            }\n            Arrays.sort(ar);\n        }\n    }\n\n    static class MathUtils {\n        static long[] FIRST_PRIMES = {\n                2,     3,      5,      7,     11,     13,     17,     19,     23,     29,\n                31,     37,     41,     43,     47,     53,     59,     61,     67,     71,\n                73,     79,     83,     89  ,   97 ,    101,    103,    107,    109,    113,\n                127,    131,    137,    139,    149,    151,    157,    163,    167,    173,\n                179,    181,    191,    193,    197,    199,    211,    223,    227,    229,\n                233,    239,    241,    251,    257,    263,    269,    271,    277,    281,\n                283,    293,    307,    311,    313,    317,    331,    337,    347,    349,\n                353,    359,    367,    373,    379,    383,    389,    397,    401,    409,\n                419,    421,    431,    433,    439,    443,    449,    457,    461,    463,\n                467,    479,    487,    491,    499,    503,    509,    521,    523,    541,\n                547,    557,    563,    569,    571,    577,    587,    593,    599,    601,\n                607,    613,    617,    619,    631,    641,    643,    647,    653,    659,\n                661,    673,    677,    683,    691,    701,    709,    719,    727,    733,\n                739,    743,    751,    757,    761,    769,    773,    787,    797,    809,\n                811,    821,    823,    827,    829,    839,    853,    857,    859,    863,\n                877,    881,    883,    887,    907,    911,    919,    929,    937,    941,\n                947,    953,    967,    971,    977,    983,    991,    997,   1009,   1013,\n                1019,   1021,   1031,   1033,   1039,   1049,   1051};\n\n        static long[] primes(int to) {\n            long[] all = new long[to + 1];\n            long[] primes = new long[to + 1];\n            all[1] = 1;\n            int primesLength = 0;\n            for (int i = 2; i <= to; i ++) {\n                if (all[i] == 0) {\n                    primes[primesLength++] = i;\n                    all[i] = i;\n                }\n                for (int j = 0; j < primesLength && i * primes[j] <= to && all[i] >= primes[j]; j++) {\n                    all[(int) (i * primes[j])] = primes[j];\n                }\n            }\n            return Arrays.copyOf(primes, primesLength);\n        }\n\n        static long modpow(long b, long e, long m) {\n            long result = 1;\n\n            while (e > 0) {\n                if ((e & 1) == 1) {\n                    /* multiply in this bit's contribution while using modulus to keep\n                     * result small */\n                    result = (result * b) % m;\n                }\n                b = (b * b) % m;\n                e >>= 1;\n            }\n\n            return result;\n        }\n\n        static long submod(long x, long y, long m) {\n            return (x - y + m) % m;\n        }\n    }\n}\n\n/*\n5 6\n1 4\n2 3\n3 4\n4 5\n5 2\n3 5\n\n5 8\n1 2\n2 3\n1 3\n4 3\n3 4\n4 1\n4 5\n5 1\n */", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String []args){\n\t\tScanner cin = new Scanner( System.in );\n\t\tint n  = cin.nextInt();\n\t\tint [] num = new int [ n ];\n\t\t\n\t\tfor (int i=0; i<n; i++)\n\t\t\tnum[i] = cin.nextInt();\n\t\t\n\t\tArrays.sort( num );\n\t\t\n\t\tint i = 0;\n\t\twhile ( i < n ){\n\t\t\tif ( num[i] != num[0] ) break;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tif ( i == n ) System.out.println(\"NO\");\n\t\telse System.out.println(num[i]);\n\t}\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.*;\n\n\npublic class CF23A implements Runnable{\n        \n    public static void main(String args[]){\n       new CF23A().run();\n    }\n    \n    @Override\n    public void run(){\n        try{\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n            tok = null;\n            solve();\n            in.close();\n            out.close();\n            \n        }\n        catch(IOException e){\n            e.printStackTrace();\n            System.exit(0);\n        }\n    }\n    \n    int nextInt()throws IOException{\n        return Integer.parseInt(nextToken());\n    } \n    \n    double nextDouble()throws IOException{\n        return Double.parseDouble(nextToken());\n    }\n    \n    long nextLong() throws IOException{\n        return Long.parseLong(nextToken());\n    }\n    \n    String nextToken()throws IOException{\n        while(tok == null || !tok.hasMoreTokens()){\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n    \n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok;\n    //////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////\n    private void solve()throws IOException{\n        String s = nextToken();\n        int l = s.length();\n        int ans = 0;\n        for(int i = 0; i < l - 1; i++){\n            for(int j = i + 1; j < l; j++){\n                String now = s.substring(i, j);\n                if(s.substring(i + 1).indexOf(now) >= 0){\n                ans = Math.max(ans, j - i);\n                \n            }\n            }\n        }\n        \n        out.println(ans);\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF1102F {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint m = Integer.parseInt(st.nextToken());\n\t\tint[][] aa = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\taa[i][j] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tint[][] dd = new int[n][n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint d = Integer.MAX_VALUE;\n\t\t\t\tfor (int h = 0; h < m; h++)\n\t\t\t\t\td = Math.min(d, Math.abs(aa[i][h] - aa[j][h]));\n\t\t\t\tdd[i][j] = dd[j][i] = d;\n\t\t\t}\n\t\tint[][] dd_ = new int[n][n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint d = Integer.MAX_VALUE;\n\t\t\t\tfor (int h = 0; h < m - 1; h++)\n\t\t\t\t\td = Math.min(d, Math.abs(aa[i][h] - aa[j][h + 1]));\n\t\t\t\tdd_[i][j] = d;\n\t\t\t}\n\t\tif (n == 1) {\n\t\t\tSystem.out.println(dd_[0][0]);\n\t\t\treturn;\n\t\t}\n\t\tint[] ii = new int[1 << n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tii[1 << i] = i;\n\t\tint[][][] dp = new int[1 << n][n][n];\n\t\tfor (int b = 0; b < 1 << n; b++)\n\t\t\tfor (int u = b; u > 0; u &= u - 1) {\n\t\t\t\tint i = ii[u & -u];\n\t\t\t\tfor (int v = b ^ 1 << i; v > 0; v &= v - 1) {\n\t\t\t\t\tint j = ii[v & -v];\n\t\t\t\t\tif (b == (1 << i ^ 1 << j))\n\t\t\t\t\t\tdp[b][i][j] = dd[i][j];\n\t\t\t\t\telse {\n\t\t\t\t\t\tint x = 0;\n\t\t\t\t\t\tfor (int w = b ^ 1 << i ^ 1 << j; w > 0; w &= w - 1) {\n\t\t\t\t\t\t\tint k = ii[w & -w];\n\t\t\t\t\t\t\tx = Math.max(x, Math.min(dp[b ^ 1 << j][i][k], dd[k][j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[b][i][j] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tint b = (1 << n) - 1;\n\t\tint x = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (i != j)\n\t\t\t\t\tx = Math.max(x, Math.min(dp[b][i][j], dd_[i][j]));\n\t\tSystem.out.println(x);\n\t}\n}\n", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        String s = in.nextLine();\n\n        int ans = 0;\n\n        outer: for (int i = s.length() - 1; i >= 1; i--)\n            for (int j = 0; j < s.length() - i; j++) {\n                String sub = s.substring(j, j + i);\n                String str = s.substring(j + 1);\n\n                if (str.contains(sub)) {\n                    ans = i;\n                    break outer;\n                }\n            }\n\n        out.print(ans);\n        out.close();\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "//package code;\n\n\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\n\n/**\n *\n * @author malek\n */\n\npublic class MainA {\n\n    public static void main(String[] args) throws Exception {\n        //String cwd = System.getProperty(\"user.dir\") + \"\\\\\";\n        Scanner in = new Scanner(new BufferedInputStream(System.in));\n        PrintStream out = new PrintStream(System.out);\n        //Scanner in = new Scanner(new BufferedInputStream(new FileInputStream(cwd + \"src\\\\code\\\\in.in\")));\n        //PrintStream out = new PrintStream(cwd + \"src\\\\code\\\\out.out\");\n        //=======================\n        Solution solution = new Solution(in, out);\n        solution.solve();\n        //=======================\n        in.close();\n        out.close();\n    }\n    static private class Solution {\n        final int inf = (int)1e9;\n        //final int MAX_N = 1000 * 1000 + 100;\n        int n, x, y, c;\n\n        int f(int u, int r, int sec){\n            if(u == 0 && r == 0)\n                return 0;\n            if(u == 0){\n                return r - 1;\n            }\n            if(r == 0){\n                return u - 1;\n            }\n            return Math.min(sec - 1, u - 1 + r - 1);\n        }\n\n        boolean isok(int sec){\n            int up = x - 1;\n            int down = n - x;\n            int right = n - y;\n            int left = y - 1;\n            int u = 0, d = 0, r = 0, l = 0;\n            int total = 1;\n            int add = 4;\n            for(int i = 1; i <= sec; i++){\n                int cc = 0;\n                if(i > up && ++cc > 0) u++;\n                if(i > down && ++cc > 0) d++;\n                if(i > right && ++cc > 0) r++;\n                if(i > left && ++cc > 0) l++;\n                total += add - cc;\n                total -= Math.max(0, f(u, r, i));\n                total -= Math.max(0, f(u, l, i));\n                total -= Math.max(0, f(d, r, i));\n                total -= Math.max(0, f(d, l, i));\n                if(total >= c) return true;\n                add += 4;\n            }\n            return false;\n        }\n\n        public void solve() {\n            n = in.nextInt();\n            x = in.nextInt();\n            y = in.nextInt();\n            c = in.nextInt();\n            if(c == 1){\n                out.println(0);\n                return;\n            }\n            int lo = 0, hi = 60000;\n            while(lo < hi){\n                int mid = (lo + hi)/2;\n                if(isok(mid)){\n                    hi = mid;\n                }\n                else{\n                    lo = mid + 1;\n                }\n            }\n            out.println(lo);\n        }\n\n        public Solution(Scanner in, PrintStream out) {\n            this.in = in;\n            this.out = out;\n        }\n\n        Scanner in;\n        PrintStream out;\n    }\n}\n\n", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "import java.util.Scanner;\n\npublic class Main{\n\tstatic final double eps = 1e-10;\n\tpublic static void main(String []args){\n\t\tScanner cin = new Scanner(System.in);\n\t\tdouble a,v;\n\t\tdouble l,d,w;\n\t\tdouble time;\n\t\t\n\t\ta = cin.nextDouble();\n\t\tv = cin.nextDouble();\n\t\t\n\t\tl = cin.nextDouble();\n\t\td = cin.nextDouble();\n\t\tw = cin.nextDouble();\n\t\t\n\t\tif(v < w + eps)\n\t\t{\n\t\t\tdouble t1 = v / a;\n\t\t\tdouble len_bond = (v * v) / (2 * a);\n\t\t\tif(len_bond + eps > l)\n\t\t\t{\n\t\t\t\ttime = Math.sqrt(2 * l / a);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble t2 = (l - len_bond) / v;\n\t\t\t\ttime = t1 + t2;\n\t\t\t}\n\t\t\tSystem.out.println(time);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble len_bondv =  (v * v) / (2 * a);\n\t\t\tdouble len_bondw = (w * w) / (2 * a);\n\t\t\tif(len_bondw + eps > d)\n\t\t\t{\n\t\t\t\tif(len_bondv + eps > l)\n\t\t\t\t\ttime = Math.sqrt(2 * l / a);\n\t\t\t\telse{\n\t\t\t\t\tdouble t1 = v / a;\n\t\t\t\t\tdouble t2 = (l - len_bondv) / v;\n\t\t\t\t\ttime = t1 + t2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble len_bonds = (v * v - w * w) / (2 * a);\n\t\t\t\t\n\t\t\t\tif(len_bondv + len_bonds < d + eps)\n\t\t\t\t\ttime = v / a + (d - len_bondv - len_bonds) / v + (v - w) / a;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdouble f = Math.sqrt(d * a + w * w / 2);\n\t\t\t\t\ttime = f / a + (f - w) / a;\n\t\t\t\t}\n\t\t\t\tif (len_bonds + eps > l - d) {\n\t\t\t\t\tdouble lv = Math.sqrt((l - d) * 2 * a + w * w);\n\t\t\t\t\ttime += (lv - w) / a;\n\t\t\t\t} else {\n\t\t\t\t\ttime += (v - w) / a + (l - d - len_bonds) / v;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(time);\n\t\t}\n\t}\n}\n\t\t \t\t\t\t\t    \t   \t   \t", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class TaskE {\n\n    static int[][] transpose(int[][] a, int n, int m) {\n        int[][] t = new int[m][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                t[j][i] = a[i][j];\n            }\n        }\n\n        return t;\n    }\n\n    public static void main(String[] args) {\n        FastReader in = new FastReader(System.in);\n//        FastReader in = new FastReader(new FileInputStream(\"input.txt\"));\n        PrintWriter out = new PrintWriter(System.out);\n//        PrintWriter out = new PrintWriter(new FileOutputStream(\"output.txt\"));\n\n\n        int t = in.nextInt();\n\n        while (t-- > 0) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n\n            int[][] a = new int[n + 1][m];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[i][j] = in.nextInt();\n                    a[n][j] = Math.max(a[n][j], a[i][j]);\n                }\n            }\n\n            a = transpose(a, n, m);\n\n            Arrays.sort(a, new Comparator<int[]>() {\n                @Override\n                public int compare(int[] o1, int[] o2) {\n                    int max1 = 0;\n                    for (int i = 0; i < o1.length; i++) {\n                        max1 = Math.max(max1, o1[i]);\n                    }\n\n                    int max2 = 0;\n                    for (int i = 0; i < o2.length; i++) {\n                        max2 = Math.max(max2, o2[i]);\n                    }\n\n                    return max2 - max1;\n                }\n            });\n\n            a = transpose(a, m, n);\n\n            int[] dp = new int[1 << n];\n\n            for (int i = 0; i < Math.min(n, m); i++) {\n                int[] best = new int[1 << n];\n\n                for (int j = 1; j < (1 << n); j++) {\n                    for (int k = 0; k < n; k++) {\n                        int sum = 0;\n                        for (int l = 0; l < n; l++) {\n                            if ((j & (1 << l)) != 0)\n                                sum += a[(l + k) % n][i];\n                        }\n                        best[j] = Math.max(best[j], sum);\n                    }\n                }\n\n                int[] dp1 = dp.clone();\n\n                for (int j = 0; j < (1 << n); j++) {\n                    for (int k = j; k > 0; k = (k - 1) & j) {\n                        dp[j] = Math.max(dp[j], dp1[k ^ j] + best[k]);\n                    }\n                }\n            }\n\n            out.println(dp[(1 << n) - 1]);\n        }\n\n\n\n\n\n        out.close();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        Integer nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        Double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(nextLine());\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            String s = \"\";\n            try {\n                s = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return s;\n        }\n    }\n}\n", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class A235 {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        long n = scan.nextInt();\n        BigInteger res = null;\n        if (n >= 3) {\n            if (n % 2 != 0) {\n                res = BigInteger.valueOf(n * (n - 1) * (n - 2));\n            } else if (n % 3 == 0) {\n                res = BigInteger.valueOf((n - 1) * (n - 2) * (n - 3));\n            } else {\n                res = BigInteger.valueOf(n * (n - 1) * (n - 3));\n            }\n        } else {\n            res = BigInteger.valueOf(n);\n        }\n        System.out.println(res);\n    }\n}\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\tint n = nextInt();\n\t\tString nn = Integer.toString(n);\n\t\tif(n >= 0){\n\t\t\tprintln(n);\n\t\t} else {\n\t\t\tprintln(Math.max(Integer.parseInt(nn.substring(0,nn.length() - 1)), Integer.parseInt(nn.substring(0, nn.length() - 2) + nn.charAt(nn.length() - 1))));\n\t\t}\n\t}\n\t\n\tprivate static PrintWriter out =  new PrintWriter(System.out);\n\tprivate static BufferedReader inB = new BufferedReader(new InputStreamReader(System.in));\t\n\tprivate static StreamTokenizer in = new StreamTokenizer(inB);\n\t\n\tprivate static void exit(Object o) throws Exception {\n\t\tout.println(o);\n\t\tout.flush();\n\t\tSystem.exit(0);\n\t}\n\tprivate static void println(Object o) throws Exception{\n\t\tout.println(o);\n\t\tout.flush();\n\t}\n\tprivate static void print(Object o) throws Exception{\n\t\tout.print(o);\n\t\tout.flush();\n\t}\n\tprivate static long nextLong() throws Exception {\n\t\tin.nextToken();\n\t\treturn (long)in.nval;\n\t}  \n\tprivate static int nextInt() throws Exception {\n\t\tin.nextToken();\n\t\treturn (int)in.nval;\n\t}  \n\tprivate static String nextString() throws Exception {\n\t\tin.nextToken();\n\t\treturn in.sval;        \n\t}\n\t\n} ", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\n \npublic class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\t\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\tvoid run(){\n\t    work();\n\t    out.flush();\n\t}\n\tvoid work() {\n\t    long r=in.nextLong();\n\t    long b=0;\n\t    for(;;b++){\n\t        long num=9*(long)Math.pow(10,(double)b)*(b+1);\n\t        if(r-num<=0){\n\t            break;\n\t        }\n\t        r-=num;\n\t    }\n\t    long base=(long)Math.pow(10,(double)b);\n\t    long c=(r-1)/(b+1);\n\t    int m=(int)((r-1)%(b+1));\n\t    base+=c;\n\t    \n\t    String str=base+\"\";\n\t    out.println(str.charAt(m));\n\t}\n}", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class ASimpleTask\n{\n\n\n\t/************************ SOLUTION STARTS HERE ***********************/\n\t\n\tstatic long memo[][];\n\tstatic int graph[];\n\tstatic long hamiltonianPath(int mask , int u) {\n\t\tif(memo[mask][u] != -1)\n\t\t\treturn memo[mask][u];\n\t\telse if(u == Integer.numberOfTrailingZeros(mask))\n\t\t\treturn 0;\n\t\telse {\n\t\t\tlong sum = 0;\n\t\t\tfor(int fromSet = mask ^ (1 << u);fromSet > 0; fromSet ^= Integer.lowestOneBit(fromSet)) {\n\t\t\t\tint v = Integer.numberOfTrailingZeros(fromSet);\n\t\t\t\t// System.out.printf(\"mask = %s , u = %d , v = %d\\n\" , Integer.toBinaryString(mask) , u , v);\n\t\t\t\tif((graph[u] & (1 << v)) != 0) \n\t\t\t\t\tsum += hamiltonianPath(mask ^ (1 << u), v);\n\t\t\t}\n\t\t\t\n\t\t\treturn memo[mask][u] = sum;\n\t\t}\n\t}\n\n\tprivate static void solveBottomUp(FastScanner s1, PrintWriter out){\n\n\t\tint V = s1.nextInt();\n\t\tint E = s1.nextInt();\n\t\tgraph = new int[V];\n\t\tlong DP[][] = new long[1 << V][V];\n\n\t\twhile(E-->0) {\n\t\t\tint u = s1.nextInt() - 1;\n\t\t\tint v = s1.nextInt() - 1;\n\t\t\tgraph[u] |= (1 << v);\n\t\t\tgraph[v] |= (1 << u);\n\t\t}\n\n\t\tfor(int i=0;i<V;i++)\n\t\t\tDP[1 << i][i] = 1;\n\n\t\tfor(int mask = 1 , end = 1 << V;mask < end;mask++) {\n\t\t\tfor(int set = mask;Integer.bitCount(set) > 1;set ^= Integer.highestOneBit(set)) {\n\t\t\t\tint u = Integer.numberOfTrailingZeros(Integer.highestOneBit(set));\n\t\t\t\tfor(int fromSet = mask ^ (1 << u);fromSet > 0; fromSet ^= Integer.lowestOneBit(fromSet)) {\n\t\t\t\t\tint v = Integer.numberOfTrailingZeros(fromSet);\n\t\t\t\t\t// System.out.printf(\"mask = %s , u = %d , v = %d\\n\" , Integer.toBinaryString(mask) , u , v);\n\t\t\t\t\tif((graph[u] & (1 << v)) != 0) \n\t\t\t\t\t\tDP[mask][u] += DP[mask ^ (1 << u)][v];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong totalCycles = 0;\n\t\tfor(int mask = 1 , end = 1 << V;mask < end;mask++) {\n\t\t\tif(Integer.bitCount(mask) >= 3) {\n\t\t\t\tint start = Integer.numberOfTrailingZeros(mask);\n\t\t\t\tfor(int set = mask;Integer.bitCount(set) > 1;set ^= Integer.highestOneBit(set)) {\n\t\t\t\t\tint u = Integer.numberOfTrailingZeros(Integer.highestOneBit(set));\n\t\t\t\t\tif((graph[u] & (1 << start)) != 0)\n\t\t\t\t\t\ttotalCycles += DP[mask][u];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttotalCycles /= 2;\n/*\t\tfor(long l[] : DP)\n\t\t\tout.println(Arrays.toString(l));*/\n\t\tout.println(totalCycles);\n\t}\n\n\tprivate static void solveTopDown(FastScanner s1, PrintWriter out){\n\n\t\tint V = s1.nextInt();\n\t\tint E = s1.nextInt();\n\t\tgraph = new int[V];\n\t\tmemo = new long[1 << V][V];\n\t\t\n\t\tfor(long l[] : memo)\n\t\t\tArrays.fill(l, -1);\n\t\t\n\t\twhile(E-->0) {\n\t\t\tint u = s1.nextInt() - 1;\n\t\t\tint v = s1.nextInt() - 1;\n\t\t\tgraph[u] |= (1 << v);\n\t\t\tgraph[v] |= (1 << u);\n\t\t}\n\n\t\tfor(int i=0;i<V;i++)\n\t\t\tmemo[1 << i][i] = 1;\n\t\t\n\t\tlong totalCycles = 0;\n\t\tfor(int mask = 1 , end = 1 << V;mask < end;mask++) {\n\t\t\tif(Integer.bitCount(mask) >= 3) {\n\t\t\t\tint start = Integer.numberOfTrailingZeros(mask);\n\t\t\t\tfor(int set = mask;Integer.bitCount(set) > 1;set ^= Integer.highestOneBit(set)) {\n\t\t\t\t\tint u = Integer.numberOfTrailingZeros(Integer.highestOneBit(set));\n\t\t\t\t\tif((graph[u] & (1 << start)) != 0)\n\t\t\t\t\t\ttotalCycles += hamiltonianPath(mask, u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttotalCycles /= 2;\n\t\t\n\t\tout.println(totalCycles);\n\t}\n\n\t/************************ SOLUTION ENDS HERE ************************/\n\n\n\n\n\n\t/************************ TEMPLATE STARTS HERE *********************/\n\n\tpublic static void main(String []args) throws IOException {\n\t\tFastScanner in  = new FastScanner(System.in);\n\t\tPrintWriter out = \n\t\t\t\tnew PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), false); \n\t\tsolveTopDown(in, out);\n\t\tin.close();\n\t\tout.close();\n\t}    \n\n\tstatic class FastScanner{\n\t\tBufferedReader reader;\n\t\tStringTokenizer st;\n\t\tFastScanner(InputStream stream){reader=new BufferedReader(new InputStreamReader(stream));st=null;}\t\n\t\tString next()\n\t\t{while(st == null || !st.hasMoreTokens()){try{String line = reader.readLine();if(line == null){return null;}\t\t    \n\t\tst = new StringTokenizer(line);}catch (Exception e){throw new RuntimeException();}}return st.nextToken();}\n\t\tString nextLine()  {String s=null;try{s=reader.readLine();}catch(IOException e){e.printStackTrace();}return s;}\t    \t  \t\n\t\tint    nextInt()   {return Integer.parseInt(next());}\n\t\tlong   nextLong()  {return Long.parseLong(next());}\t\t\n\t\tdouble nextDouble(){return Double.parseDouble(next());}\n\t\tchar   nextChar()  {return next().charAt(0);}\n\t\tint[]  nextIntArray(int n)         {int[] a= new int[n];   int i=0;while(i<n){a[i++]=nextInt();}  return a;}\n\t\tlong[] nextLongArray(int n)        {long[]a= new long[n];  int i=0;while(i<n){a[i++]=nextLong();} return a;}\t\n\t\tint[]  nextIntArrayOneBased(int n) {int[] a= new int[n+1]; int i=1;while(i<=n){a[i++]=nextInt();} return a;}\t    \t\n\t\tlong[] nextLongArrayOneBased(int n){long[]a= new long[n+1];int i=1;while(i<=n){a[i++]=nextLong();}return a;}\t    \t\n\t\tvoid   close(){try{reader.close();}catch(IOException e){e.printStackTrace();}}\t\t\t\t\n\t}\n\n\t/************************ TEMPLATE ENDS HERE ************************/\n}", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class A {\n\n    static class Entity implements Comparable {\n\n        public Entity(int x, int a) {\n            this.x = x;\n            this.a = a;\n        }\n        public int x, a;\n\n        public int compareTo(Object t) {\n            Entity o = (Entity) t;\n            return x == o.x ? 0 : x < o.x ? -1 : 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(), t = 2 * scanner.nextInt();\n        if (1 == n) {\n            System.out.println(2);\n        } else {\n            int rez = 2;\n            ArrayList<Entity> list = new ArrayList<Entity>();\n            for (int i = 0; i < n; i++) {\n                list.add(new Entity(scanner.nextInt(), scanner.nextInt()));\n            }\n            Collections.sort(list);\n            for (int i = 1; i < n; i++) {\n                int num = 2 * (list.get(i).x - list.get(i - 1).x)\n                        - list.get(i).a - list.get(i - 1).a;\n                if (t < num) {\n                    rez += 2;\n                } else if (t == num) {\n                    rez++;\n                }\n            }\n            System.out.println(rez);\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    \n    static class Node implements Comparable<Node>{\n        int sum;\n        int l;\n        int r;\n        Node next;\n        int nb;\n        Node ini;\n        boolean not;\n        public Node(int sum,int l,int r){\n            this.sum = sum;\n            this.l = l;\n            this.r = r;\n            nb = 0;\n            not = false;\n            ini = null;\n        }\n        \n        @Override\n        public int compareTo(Node node){\n            if(sum-node.sum!=0) return sum-node.sum;\n            else if(l-node.l!=0) return l-node.l;\n            else return r - node.r;\n        }\n    }\n    \n    public static void main(String[] args)throws IOException{\n                \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        PrintWriter out = new PrintWriter(System.out);\n        \n        int n = Integer.parseInt(st.nextToken());\n        \n        TreeSet<Node> ts = new TreeSet<Node>();\n        \n        st = new StringTokenizer(br.readLine());\n        int[] a = new int[n+1];\n        for(int i=1;i<=n;i++) a[i] = Integer.parseInt(st.nextToken());\n        \n        int[] s = new int[n+1];\n        for(int i=1;i<=n;i++) s[i] = s[i-1] + a[i];\n        \n        for(int i=1;i<=n;i++){\n            for(int j=i;j<=n;j++){\n                ts.add(new Node(s[j]-s[i-1],i,j));\n            }\n        }\n        int minvalue = -2000*(int)Math.pow(10,5);\n        int maxvalue = 2000*(int)Math.pow(10,5);\n        ts.add(new Node(minvalue,0,0));\n        ts.add(new Node(maxvalue,0,0));\n        //System.out.println(minvalue);\n        Node node = ts.higher(ts.first());\n        \n        int sum = 0;\n        \n        \n        \n        int max = 0;\n        Node m = null;\n        \n        while(node.sum!=maxvalue){\n            \n            sum = node.sum;\n            while(node.sum==sum){\n                node = ts.higher(node);\n            }\n            \n            Node var = ts.lower(node);\n           // System.out.println(sum+\" \"+var.sum);\n            max = 0;\n            while(var.sum==sum){\n                \n                Node next = ts.higher(new Node(sum,var.r+1,0));\n                \n                if(max>1+next.nb){\n                    var.nb = max;\n                    var.ini = m;\n                }\n                else if(next.ini==null){\n                \n                    var.nb = 1 + next.nb;\n                    var.next = next;\n                    if(max<var.nb){\n                        max = var.nb;\n                        m = var;\n                    }\n                    \n                    \n                }else{\n                    \n                    var.nb = 1 + next.nb;\n                    var.next = next.ini;\n                    if(max<var.nb){\n                        max = var.nb;\n                        m = var;\n                    }\n                    \n                }\n                \n            \n                var = ts.lower(var);\n                    \n                //System.out.println(sum+\" \"+var.sum);\n            }\n            \n            \n        }\n        \n        int k = 0;\n        Node best = new Node(minvalue,0,0);\n\n        //var = new Node(minvalue,0,0);\n        for(Node var:ts){\n            if(k<var.nb){\n                k = var.nb;\n                best = var;\n                if(var.ini!=null) best = var.ini;\n            }\n        }\n        \n        if(k==0) System.out.println(\"erreur\");\n        else{\n            \n            out.println(k);\n            sum = best.sum;\n            while(best.sum==sum){\n                out.println(best.l+\" \"+best.r);\n                best = best.next;\n            }\n            \n        }\n        \n        \n        out.flush();\n        \n    }\n    \n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class A\n{\n\tpublic static void main(String [] args) throws IOException\n\t{\n\t\tScanner in = new Scanner(System.in);\n\n\t\tSystem.out.println(rec(in.nextLong(), in.nextLong()));\n\n\t}\n\n\tprivate static long rec(long a, long b)\n\t{\n\t\treturn b == 0 ? 0 : a/b + rec(b, a%b);\n\t}\n\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tvoid solve() throws IOException {\n\t\tint tot = nextInt();\n\t\tint ok = nextInt();\n\t\t\n\t\tint k = nextInt();\n\t\t\n\t\tint maxBad = tot / k;\n\t\tif (tot - maxBad >= ok) {\n\t\t\tout.println(ok);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tint\tdbl = ok + tot / k - tot;\n\n\t\t\n\t\tint dblPoints = pow(2, dbl + 1) - 2;\n\t\twhile (dblPoints < 0)\n\t\t\tdblPoints += MOD;\n\t\t\n\t\tdblPoints = (int)((long)dblPoints * k % MOD);\n\t\t\n\t\tint rest = ok - dbl * k;\n\t\t\n\t\tint ans = dblPoints + rest;\n\t\t\n\t\tif (ans >= MOD)\n\t\t\tans -= MOD;\n\t\t\n\t\tout.println(ans);\n\t}\n\t\n\tstatic int pow(int a, int b) {\n\t\tint ret = 1;\n\t\twhile (b != 0) {\n\t\t\tif ((b & 1) == 1)\n\t\t\t\tret = (int)((long)ret * a % MOD);\n\t\t\ta = (int)((long)a * a % MOD);\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic final int MOD = 1000000009;\n\n\tA() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew A();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int n=Integer.parseInt(bu.readLine());\n        String a=bu.readLine(),b=bu.readLine(),c=bu.readLine();\n        int l=a.length();\n        int a1=getmax(a,n),b1=getmax(b,n),c1=getmax(c,n);\n        if(a1>b1 && a1>c1) sb.append(\"Kuro\");\n        else if(b1>a1 && b1>c1) sb.append(\"Shiro\");\n        else if(c1>a1 && c1>b1) sb.append(\"Katie\");\n        else sb.append(\"Draw\");\n        System.out.print(sb);\n    }\n\n    static int getmax(String s,int n)\n    {\n        int i,l=s.length(),c[]=new int[256];\n        for(i=0;i<l;i++)\n        c[s.charAt(i)]++;\n\n        int max=0;\n        for(i=0;i<256;i++)\n        max=Math.max(c[i],max);\n        //System.out.println(max);\n        if(n>l-max)\n        {\n            if(max==l && n==1 && l!=1) max--;  //we cant have n only if all characters are equal and we must make 1 move\n            else max=l;\n        }\n        else max+=n;\n        //System.out.println(max);\n        return max;\n    }\n}", "complexity": "linear", "problem": "0979_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "//package Round584;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Problem1 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint a []=new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i]=sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n//\t\tSystem.out.println(Arrays.toString(a));\n\t\tint k=a.length;\n\t\tfor(int i=a.length-1;i>=0;i--) {\n\t\t\tint A=a[i];\n\t\t\tfor (int j=0;j<i;j++) {\n\t\t\t\tif(A%a[j]==0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(k);\n\t\tsc.close();\n\t}\n\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "/*\nRoses are red\nMemes are neat\nAll my test cases time out\nLmao yeet\n*/\nimport java.util.*;\nimport java.io.*;\n\n   public class B\n   {\n      public static void main(String args[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));  \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int K = Integer.parseInt(st.nextToken());\n         //bin search\n         //ugh I'm shafting\n         long x = (long)N;\n         long low = 0L;\n         long high = N;\n         while(low != high)\n         {\n            x = (low+high+1)/2;\n            long add = (x*(x+1))/2;\n            long y = N-x;\n            if(add-y > K)\n               high = x;\n            else if(add-y == K)\n            {\n               System.out.println(y);\n               break;\n            }\n            else\n               low = x;\n         }\n         //run time?\n      }\n      public static void sort(int[] arr)\n      {\n         PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\n         for(int a: arr)\n            pq.add(a);\n         for(int i=0; i < arr.length; i++)\n            arr[i] = pq.poll();\n      }\n   }", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class ProblemA {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(new InputStreamReader(System.in));\n        int n = sc.nextInt();\n        if (n % 2 == 0) {\n            System.out.println((n - 4) + \" \" + 4);\n        } else {\n            System.out.println((n - 9) + \" \" + 9);\n        }\n    }\n}\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "//Implemented By Aman Kotiyal Date:-30-May-2021  Time:-7:54:28 pm\nimport java.io.*;\nimport java.util.*;\n\npublic class ques3\n{\n\tpublic static void main(String[] args)throws Exception{ new ques3().run();} \n\tlong mod=1000000000+7;\n\t\n\tvoid solve() throws Exception\n\t{\n\t\tfor(int ii=ni();ii>0;ii--)\n\t\t{\n\t\t\tint n=ni();\n\t\t\t//ArrayList<Integer> al=new ArrayList<Integer>();\n\t\t\tStack<Integer> st=new Stack<Integer>();\n\t\t\tint x=ni();\n\t\t\t//al.add(1);\n\t\t\tst.add(1);\n\t\t\tout.println(\"1\");\n\t\t\tfor(int i=2;i<=n;i++)\n\t\t\t{\n\t\t\t\t x=ni();\n\t\t\t\t if(x==1)\n\t\t\t\t {\n\t\t\t\t\t st.add(1);\n\t\t\t\t\t Stack<Integer> tep=(Stack<Integer>) st.clone();\n\t\t\t\t\t display(tep);\n\t\t\t\t\t continue;\n\t\t\t\t }\n\t\t\t\t int top=st.peek();\n\t\t\t\t if(top+1==x)\n\t\t\t\t {\n\t\t\t\t\t st.pop();\n\t\t\t\t\t st.add(x);\n\t\t\t\t\t Stack<Integer> tep=(Stack<Integer>) st.clone();\n\t\t\t\t\t display(tep);\n\t\t\t\t\t continue;\n\t\t\t\t }\n\t\t\t\t while(true)\n\t\t\t\t {\n\t\t\t\t\t top=st.peek();\n\t\t\t\t\t if(top+1==x)\n\t\t\t\t\t {\n\t\t\t\t\t\t st.pop();\n\t\t\t\t\t\t st.add(x);\n\t\t\t\t\t\t Stack<Integer> tep=(Stack<Integer>) st.clone();\n\t\t\t\t\t\t display(tep);\n\t\t\t\t\t\t break;\n\t\t\t\t\t }\n\t\t\t\t\t top=st.pop();\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tvoid display(Stack<Integer> st)\n\t{\n\t\tArrayList<Integer> al = new ArrayList<>();\n\t\twhile(st.size()!=0)\n\t\t{\n\t\t\tint tem=st.pop();\n\t\t\tal.add(tem);\n\t\t}\n\t\tCollections.reverse(al);\n\t\tfor (int i = 0; i <al.size()-1; i++) {\n\t\t\tout.print(al.get(i)+\".\");\n\t\t}\n\t\tout.println(al.get(al.size()-1));\n\t}\n\t\n\t/*FAST INPUT OUTPUT & METHODS BELOW*/\n\t\n\tprivate byte[] buf=new byte[1024];\n\tprivate int index;\n\tprivate InputStream in;\n\tprivate int total;\n\tprivate SpaceCharFilter filter;\n\tPrintWriter out;\n\t\n\tint min(int... ar){int min=Integer.MAX_VALUE;for(int i:ar)min=Math.min(min, i);return min;}\n\tlong min(long... ar){long min=Long.MAX_VALUE;for(long i:ar)min=Math.min(min, i);return min;}\n\tint max(int... ar) {int max=Integer.MIN_VALUE;for(int i:ar)max=Math.max(max, i);return max;}\n\tlong max(long... ar) {long max=Long.MIN_VALUE;for(long i:ar)max=Math.max(max, i);return max;}\n\tvoid reverse(int a[]){for(int i=0;i<a.length>>1;i++){int tem=a[i];a[i]=a[a.length-1-i];a[a.length-1-i]=tem;}}\n\tvoid reverse(long a[]){for(int i=0;i<a.length>>1;i++){long tem=a[i];a[i]=a[a.length-1-i];a[a.length-1-i]=tem;}}\n\tString reverse(String s){StringBuilder sb=new StringBuilder(s);sb.reverse();return sb.toString();}\n\t\n\tvoid shuffle(int a[]) {\n\t\tArrayList<Integer> al = new ArrayList<>();\n\t\tfor(int i=0;i<a.length;i++) \n\t\t\tal.add(a[i]);\n\t\t\n\t\tCollections.sort(al);\n\t\tfor(int i=0;i<a.length;i++) \n\t\t\ta[i]=al.get(i);\n\t}\n\tlong lcm(long a,long b)\n\t{\n\t\treturn (a*b)/(gcd(a,b));\n\t}\n\t\n\tint gcd(int a, int b) \n\t{ \n\t\tif (a == 0) \n\t\t\treturn b; \n\t\treturn gcd(b%a, a); \n\t} \n\tlong gcd(long a, long b) \n\t{ \n\t\tif (a == 0) \n\t\t\treturn b; \n\t\treturn gcd(b%a, a); \n\t}\n\t/* for (1/a)%mod = ( a^(mod-2) )%mod  ----> use expo to calc -->(a^(mod-2)) */\n\tlong expo(long p,long q)  /*  (p^q)%mod   */\n\t{\n\t\tlong z = 1;\n\t\twhile (q>0) {\n\t\t\tif (q%2 == 1) {\n\t\t\t\tz = (z * p)%mod;\n\t\t\t}\n\t\t\tp = (p*p)%mod;\n\t\t\tq >>= 1;\n\t\t}\n\t\treturn z;\n\t}\n\tvoid run()throws Exception\n\t{\n\t\tin=System.in; out = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\tprivate int scan()throws IOException\n\t{\n\t\tif(total<0)\n\t\t\tthrow new InputMismatchException();\n\t\tif(index>=total)\n\t\t{\n\t\t\tindex=0;\n\t\t\ttotal=in.read(buf);\n\t\t\tif(total<=0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[index++];\n\t}\n\tprivate int ni() throws IOException \n\t{\n\t\tint c = scan();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = scan();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = scan();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = scan();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\tprivate long nl() throws IOException \n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = scan()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = scan();\n\t\t}\n\t\t\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = scan();\n\t\t}\n\t}\n\tprivate double nd() throws IOException{\n\t\treturn Double.parseDouble(ns());\n\t}\n\tprivate String ns() throws IOException {\n\t\tint c = scan();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = scan();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tif (Character.isValidCodePoint(c))\n\t\t\t\tres.appendCodePoint(c);\n\t\t\tc = scan();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\tprivate String nss() throws IOException\n\t{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\treturn br.readLine();\n\t}\n\tprivate char nc() throws IOException \n\t{\n\t\tint c = scan();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = scan();\n\t\treturn (char) c;\n\t}\n\tprivate boolean isWhiteSpace(int n)\n\t{\n\t\tif(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tprivate boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn isWhiteSpace(c);\n\t}\n\tprivate interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n\npublic class CodeForce275A {\n    \n    public static void main(String[] args) throws IOException {\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer token = new StringTokenizer(in.readLine());\n        long l = Long.parseLong(token.nextToken());\n        long r = Long.parseLong(token.nextToken());\n        \n        \n        if(r-l<2) {\n            System.out.println(-1);\n            return;\n        }\n        if(l%2==1&&r-l<3) {\n            System.out.println(-1);\n            return;\n        }\n        if(l%2==0) {\n            System.out.println(l+\" \"+(l+1)+\" \"+(l+2));\n            return;\n        }\n        if(l%2==1) {\n            System.out.println((l+1)+\" \"+(l+2)+\" \"+(l+3));\n        }\n    }\n\n}", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class A {\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static void solve() throws IOException {\n\t\tArrayList<Num> c = new ArrayList<Num>();\n\t\tn = nextInt();\n\t\ta = nextInt();\n\t\tb = nextInt();\n\t\tfor(int i = 0;  i < n; i++) {\n\t\t\tint next = nextInt();\n\t\t\tboolean found = false;\n\t\t\tfor(int j = 0; j < c.size(); j++) {\n\t\t\t\tif(c.get(j).num == next) {\n\t\t\t\t\tc.get(j).freq++;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found)\n\t\t\t\tc.add(new Num(next));\n\t\t}\n\t\tCollections.sort(c);\n\t\tint below = 0;\n\t\tint above = n;\n\t\tboolean f = false;\n\t\tfor(int i = 0; i < c.size(); i++) {\n\t\t\tbelow += c.get(i).freq;\n\t\t\tabove -= c.get(i).freq;\n\t\t\tif(below == b && above == a) {\n\t\t\t\tif(i == c.size())\n\t\t\t\t\tbreak;\n\t\t\t\tSystem.out.println(c.get(i+1).num - c.get(i).num);\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f)\n\t\t\tSystem.out.println(0);\n\t}\n\t\n\tstatic int n;\n\tstatic int a;\n\tstatic int b;\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(239);\n\t\t}\n\t}\n\n\tstatic BufferedReader br;\n\tstatic StringTokenizer st;\n\tstatic PrintWriter out;\n\n\tstatic String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\nclass Num implements Comparable<Num> {\n\tint num;\n\tint freq;\n\tNum(int n) {\n\t\tnum = n;\n\t\tfreq = 1;\n\t}\n\tpublic int compareTo(Num other) {\n\t\treturn this.num - other.num;\n\t}\n}", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.util.*;\npublic class Main {\n    public static boolean flag = false;\n    public static int n, k;\n    public static void generate(String s) {\n        if (s.length() < n) {\n            generate(s + \"0\");\n            generate(s + \"1\");\n        } else {\n            if (get(s) == k) {\n                System.out.println(s);\n            }\n        }\n    }\n    public static int get(String s) {\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 0; j <= s.length() - i; j++) {\n                if (unique(s.substring(j, j + i), s)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    public static boolean unique(String s, String t) {\n        int cnt = 0;\n        for (int i = 0; i <= t.length() - s.length(); i++) {\n            if (t.substring(i, i + s.length()).equals(s)) {\n                cnt++;\n            }\n        }\n        return cnt == 1;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        k = in.nextInt();\n        int diff = (n - k) / 2;\n        StringBuilder sub = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            if ((i + 1) % (diff + 1) == 0) {\n                sub.append('1');\n            } else {\n                sub.append('0');\n            }\n        }\n        System.out.println(sub.toString());\n    }\n}", "complexity": "linear", "problem": "1159_D", "from": "CODEFORCES", "tags": "brute force,greedy,constructive algorithms,math,strings"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\npublic class Main{\n    //SOLUTION BEGIN\n    //Into the Hardware Mode\n    void pre() throws Exception{}\n    void solve(int TC)throws Exception{\n        int n = ni();\n        int[] a = new int[n];\n        for(int i = 0; i< n; i++)a[i] = ni();\n        Arrays.sort(a);\n        int ans = 0;\n        for(int i = 0; i< n; i++){\n            if(a[i] == -1)continue;\n            ans++;\n            for(int j = i+1; j< n; j++)if(a[j]%a[i] == 0)a[j] = -1;\n        }\n        pn(ans);\n    }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(\"Hold right there, Sparky!\");}\n    void exit(boolean b){if(!b)System.exit(0);}\n    long IINF = (long)1e18, mod = (long)1e9+7;\n    final int INF = (int)1e9, MX = (int)2e6+5;\n    DecimalFormat df = new DecimalFormat(\"0.00000000\");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-6;\n    static boolean multipleTC = false, memory = false, fileIO = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        if(fileIO){\n            in = new FastReader(\"input.txt\");\n            out = new PrintWriter(\"output.txt\");\n        }else {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n        }\n        //Solution Credits: Taranpreet Singh\n        int T = (multipleTC)?ni():1;\n        pre();\n        for(int t = 1; t<= T; t++)solve(t);\n        out.flush();\n        out.close();\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, \"1\", 1 << 28).start();\n        else new Main().run();\n    }\n    \n    int digit(long s){int ans = 0;while(s>0){s/=10;ans++;}return ans;}\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object o){out.print(o);}\n    void pn(Object o){out.println(o);}\n    void pni(Object o){out.println(o);out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n \n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n \n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n \n        String nextLine() throws Exception{\n            String str = \"\";\n            try{   \n                str = br.readLine();\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }  \n            return str;\n        }\n    }\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\n// Petya and Spiders\n// 2011/9/3\npublic class P111C{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\n\tint n, m;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tm=sc.nextInt();\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tif(n<m){\n\t\t\tint t=n;\n\t\t\tn=m;\n\t\t\tm=t;\n\t\t}\n\t\tint full=(1<<m)-1;\n\t\tint[][] dp=new int[1<<m][1<<m];\n\t\tint[][] tmp=new int[1<<m][1<<m];\n\t\tfor(int i=0; i<1<<m; i++){\n\t\t\tfill(dp[i], INF);\n\t\t}\n\t\tfor(int i=0; i<1<<m; i++){\n\t\t\tint b1=(i|(i>>1)|(i<<1))&full;\n\t\t\tint b2=i;\n\t\t\tdp[b1][b2]=Integer.bitCount(i);\n\t\t}\n\t\tfor(int j=0; j<n-1; j++){\n\t\t\tfor(int i=0; i<1<<m; i++){\n\t\t\t\tSystem.arraycopy(dp[i], 0, tmp[i], 0, 1<<m);\n\t\t\t\tfill(dp[i], INF);\n\t\t\t}\n\n\t\t\tfor(int b1=0; b1<1<<m; b1++){\n\t\t\t\tfor(int b2=0; b2<1<<m; b2++){\n\t\t\t\t\tfor(int i=0; i<1<<m; i++){\n\t\t\t\t\t\tif((b1|i)!=full){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint b=(i|(i>>1)|(i<<1))&full;\n\t\t\t\t\t\tdp[b2|b][i]=min(dp[b2|b][i],\n\t\t\t\t\t\t\t\ttmp[b1][b2]+Integer.bitCount(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint min=INF;\n\t\tfor(int i=0; i<1<<m; i++){\n\t\t\tmin=min(min, dp[full][i]);\n\t\t}\n\t\tint ans=m*n-min;\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew P111C().run();\n\t}\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.util.Scanner;\n\npublic class Solution {\n\n  public static void main(String[] args) throws Exception {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    if (n % 2 == 0)\n      System.out.println(\"4 \" + (n - 4));\n    else\n      System.out.println(\"9 \" + (n - 9));\n  }\n}\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String []args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\n\t\tint m = sc.nextInt();\n\n\t\tif(n > 30) System.out.println(m);\n\n\t\telse {\n\n\t\t\tSystem.out.println(m % (1 << n));\n\n\t\t}\n\n\t\tsc.close();\n\n\t}\n\n}\n\n", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Main {//\n    public static void main(String[] args)throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n, s;\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        s = Integer.parseInt(st.nextToken());\n        Map<Integer, Integer> maps = new HashMap<>();\n        for (int i = 0; i < n - 1; i++) {\n            StringTokenizer st1 = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st1.nextToken());\n            int b = Integer.parseInt(st1.nextToken());\n            if (maps.containsKey(a)) {\n                maps.put(a, -1);\n            } else {\n                maps.put(a, 1);\n            }\n            if (maps.containsKey(b)) {\n                maps.put(b, -1);\n            } else {\n                maps.put(b, 1);\n            }\n        }\n        int count = 0;\n        for (Map.Entry<Integer, Integer> i : maps.entrySet()) {\n            if (i.getValue() == 1) {\n                count++;\n            }\n        }\n        double ans = 2.0 * s / count;\n        System.out.printf(\"%.18f\",ans);\n    }\n}\n\n  \t    \t\t \t\t\t\t\t  \t\t\t\t\t \t\t    \t", "complexity": "linear", "problem": "1086_B", "from": "CODEFORCES", "tags": "greedy,implementation,trees"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            BSearchingRectangles solver = new BSearchingRectangles();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class BSearchingRectangles {\n        FastInput in;\n        FastOutput out;\n        int n;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            this.in = in;\n            this.out = out;\n            n = in.readInt();\n\n            IntBinarySearch upDown = new IntBinarySearch() {\n\n                public boolean check(int mid) {\n                    return query(1, n, 1, mid) >= 1;\n                }\n            };\n\n            IntBinarySearch leftRight = new IntBinarySearch() {\n\n                public boolean check(int mid) {\n                    return query(1, mid, 1, n) >= 1;\n                }\n            };\n            int threshold = upDown.binarySearch(1, n);\n            int[] r1;\n            int[] r2;\n            if (query(1, n, 1, threshold) == 1 &&\n                    query(1, n, threshold + 1, n) == 1) {\n                r1 = find(1, n, 1, threshold);\n                r2 = find(1, n, threshold + 1, n);\n            } else {\n                threshold = leftRight.binarySearch(1, n);\n                r1 = find(1, threshold, 1, n);\n                r2 = find(threshold + 1, n, 1, n);\n            }\n\n            out.append(\"! \");\n            output(r1);\n            output(r2);\n            out.flush();\n        }\n\n        public void output(int[] ans) {\n            for (int x : ans) {\n                out.append(x).append(' ');\n            }\n        }\n\n        public int[] find(int l, int r, int d, int u) {\n            IntBinarySearch downIBS = new IntBinarySearch() {\n\n                public boolean check(int mid) {\n                    return query(l, r, mid, u) == 0;\n                }\n            };\n            int y1 = downIBS.binarySearch(d, u);\n            if (query(l, r, y1, u) == 0) {\n                y1--;\n            }\n\n            IntBinarySearch upIBS = new IntBinarySearch() {\n\n                public boolean check(int mid) {\n                    return query(l, r, d, mid) >= 1;\n                }\n            };\n            int y2 = upIBS.binarySearch(d, u);\n\n            IntBinarySearch leftIBS = new IntBinarySearch() {\n\n                public boolean check(int mid) {\n                    return query(mid, r, d, u) == 0;\n                }\n            };\n            int x1 = leftIBS.binarySearch(l, r);\n            if (query(x1, r, d, u) == 0) {\n                x1--;\n            }\n\n            IntBinarySearch rightIBS = new IntBinarySearch() {\n\n                public boolean check(int mid) {\n                    return query(l, mid, d, u) >= 1;\n                }\n            };\n            int x2 = rightIBS.binarySearch(l, r);\n\n            return new int[]{x1, y1, x2, y2};\n        }\n\n        public int query(int l, int r, int d, int u) {\n            if (l > r || d > u) {\n                return 0;\n            }\n            out.printf(\"? %d %d %d %d\", l, d, r, u).println().flush();\n            return in.readInt();\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int floorAverage(int x, int y) {\n            return (x & y) + ((x ^ y) >> 1);\n        }\n\n    }\n\n    static abstract class IntBinarySearch {\n        public abstract boolean check(int mid);\n\n        public int binarySearch(int l, int r) {\n            if (l > r) {\n                throw new IllegalArgumentException();\n            }\n            while (l < r) {\n                int mid = DigitUtils.floorAverage(l, r);\n                if (check(mid)) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            return l;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput printf(String format, Object... args) {\n            cache.append(String.format(format, args));\n            return this;\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "import java.util.Scanner;\n\npublic class demo1 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int a[] = new int[10000]; //\u7b2ci\u8282\u70b9\u7684\u7236\u7d22\u5f15\n        int b[] = new int[10000]; //\u8be5\u7236\u7d22\u5f15\u6709\u7684\u5b50\u8282\u70b9\u6570\u76ee(\u4e0d\u7ba1\u7b26\u4e0d\u7b26\u5408\u6761\u4ef6\uff0c\u53cd\u6b63\u5c31\u662f\u5b50\u8282\u70b9)\n        int c[] = new int[10000]; //\u8be5\u7236\u7d22\u5f15\u6709\u7684\u5b50\u8282\u70b9\u6570\u76ee\uff08\u6ee1\u8db3\u4e91\u6749\u6811\u6761\u4ef6\u7684\u5b50\u8282\u70b9\uff09\n        for(int i = 2; i <= n; i++)\n        {\n            a[i] = in.nextInt();\n            b[a[i]]++;\n        }\n        for(int i = 2; i <= n; i++)\n        {\n            if(b[i] == 0)\n                c[a[i]]++;\n        }\n        for(int i = 1; i <= n; i++)\n        {\n            if(c[i] != 0 && c[i] < 3)   //\u6709\u5b50\u8282\u70b9  \u4f46\u662f\u4e0d\u6ee1\u8db3\u4e91\u6749\u6811\u6761\u4ef6\n            {\n                System.out.println(\"No\");\n                System.exit(0);\n            }\n            if(b[i] != 0 && c[i] == 0)  //\u6709\u5b50\u8282\u70b9  \u4f46\u662f\u90fd\u4e0d\u7b26\u5408\u6761\u4ef6  \u6bcf\u4e2a\u5b50\u8282\u70b9\u8fd8\u6709\u5b50\u8282\u70b9\n            {\n                System.out.println(\"No\");\n                System.exit(0);\n            }\n        }\n        System.out.println(\"Yes\");\n    }\n}\n\n \t  \t  \t     \t  \t \t  \t \t\t\t  \t", "complexity": "linear", "problem": "0913_B", "from": "CODEFORCES", "tags": "implementation,trees"}
{"src": "\n\nimport java.io.BufferedReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.util.HashSet;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class Main {\n\n\tpublic static void main(String args[]) throws NumberFormatException,IOException {\n\n\t\t\n\n\t\tStdin in = new Stdin();\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint n=in.readInt();\n\n\t\tchar s[]=in.readNext().toCharArray();\n\n\t\tchar t[]=in.readNext().toCharArray();\n\n\t\tHashSet<Integer> dif_s[][]=new HashSet[26][26];\n\n\t\tfor(int i=0;i<26;i++){\n\n\t\t\tfor(int j=0;j<26;j++){\n\n\t\t\t\tdif_s[i][j]=new HashSet<Integer>();\n\n\t\t\t}\n\n\t\t}\n\n\t\tint x=-1,y=-1,re=0;\n\n\t\tint dif=0;\n\n\t\tfor(int i=0;i<s.length;i++){\n\n\t\t\tif(s[i]!=t[i]){\n\n\t\t\t\tdif_s[s[i]-'a'][t[i]-'a'].add(i);\n\n\t\t\t\tdif++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tint index_s,index_t;\n\n\t\tfor(int i=0;i<26;i++){\n\n\t\t\tindex_s=-1;\n\n\t\t\tindex_t=-1;\n\n\t\t\tfor(int j=0;j<26;j++){\n\n\t\t\t\tif(!dif_s[i][j].isEmpty()&&!dif_s[j][i].isEmpty()){\n\n\t\t\t\t\tre=2;\n\n\t\t\t\t\tx=dif_s[i][j].iterator().next();\n\n\t\t\t\t\ty=dif_s[j][i].iterator().next();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif(re==0&&!dif_s[j][i].isEmpty()){\n\n\t\t\t\t\tindex_s=dif_s[j][i].iterator().next();\n\n\t\t\t\t}\n\n\t\t\t\tif(re==0&&!dif_s[i][j].isEmpty()){\n\n\t\t\t\t\tindex_t=dif_s[i][j].iterator().next();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(re==2)\n\n\t\t\t\tbreak;\n\n\t\t\tif(re==0&&index_s!=-1&&index_t!=-1){\n\n\t\t\t\tre=1;\n\n\t\t\t\tx=index_s;\n\n\t\t\t\ty=index_t;\n\n\t\t\t}\n\n\t\t}\n\n\t\tout.println(dif-re);\n\n\t\tif(x!=-1){\n\n\t\t\tx++;\n\n\t\t\ty++;\n\n\t\t}\n\n\t\tout.println(x+\" \"+y);\n\n\t\tout.flush();\n\n\t\tout.close();\n\n\n\n\t}\n\n\tprivate static class Stdin {\n\n\t\tInputStreamReader read;\n\n\t\tBufferedReader br;\n\n\n\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\n\n\n\t\tprivate Stdin() {\n\n\t\t\tread = new InputStreamReader(System.in);\n\n\t\t\tbr = new BufferedReader(read);\n\n\n\n\t\t}\n\n\n\n\t\tprivate String readNext() throws IOException {\n\n\n\n\t\t\twhile (!st.hasMoreTokens())\n\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\n\t\t}\n\n\n\n\t\tprivate int readInt() throws IOException, NumberFormatException {\n\n\n\n\t\t\treturn Integer.parseInt(readNext());\n\n\n\n\t\t}\n\n\n\n\t\tprivate long readLong() throws IOException, NumberFormatException {\n\n\n\n\t\t\treturn Long.parseLong(readNext());\n\n\n\n\t\t}\n\n\t}\n\n}\n\n", "complexity": "linear", "problem": "0527_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class A {\n\n    ArrayList<Integer> list = new ArrayList<Integer>();\n    \n    \n    boolean valid(int n) {\n        Queue<Integer> q = new LinkedList<Integer>();\n        q.add(4);\n        q.add(7);\n        int crnt;\n        while(!q.isEmpty()) {\n            crnt = q.poll();\n            if(n%crnt == 0) return true;\n            if ( crnt*10 + 4 <= 1000 ) q.add(crnt*10 + 4);\n            if ( crnt*10 + 7 <= 1000 ) q.add(crnt*10 + 7);\n        }\n        return false;\n    }\n    \n    void dfs(int n){\n        if(n>1000)return;\n        if(n!=0)list.add(n);\n        n = n*10;\n        dfs(n+4);\n        dfs(n+7);\n    }\n\n    void run() {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        if (valid(n)) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new A().run();\n    }\n\n}\n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\tprivate BufferedReader in;\n\tprivate PrintWriter out;\n\tprivate StringTokenizer st;\n\t\n\tprivate void eat(String line)\n\t{\n\t\tst = new StringTokenizer(line);\n\t}\n\t\n\tprivate String next() throws IOException\n\t{\n\t\twhile(!st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\t\t\tif(line == null)\n\t\t\t\treturn null;\n\t\t\teat(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\t\n\tprivate int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\t\n\tpublic void run()\n\t{\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t\teat(\"\");\n\t\t\t\n\t\t\tgo();\n\t\t\t\n\t\t\tout.close();\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tnew Thread(new Main()).start();\n\t}\n\t\n\tpublic void go() throws IOException\n\t{\n\t\tint n = nextInt();\n\t\tint[] v = new int[n], count = new int[2];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tv[i] = nextInt();\n\t\t\t++count[v[i] % 2];\n\t\t}\n\t\tint residue = count[0] == 1 ? 0 : 1;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(v[i] % 2 == residue)\n\t\t\t\tout.println(i + 1);\n\t}\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.awt.geom.Line2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.InputMismatchException;\n\npublic class C488C\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint[] x1 = new int[4];\n\t\tint[] y1 = new int[4];\n\t\tint[] x2 = new int[4];\n\t\tint[] y2 = new int[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tx1[i] = in.nextInt();\n\t\t\ty1[i] = in.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tx2[i] = in.nextInt();\n\t\t\ty2[i] = in.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (Line2D.linesIntersect(x1[i], y1[i], x1[(i + 1) % 4], y1[(i + 1) % 4], x2[j], y2[j], x2[(j + 1) % 4], y2[(j + 1) % 4])) {\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint rectMinX = Math.min(Math.min(x1[0], x1[1]), x1[2]);\n\t\tint rectMaxX = Math.max(Math.max(x1[0], x1[1]), x1[2]);\n\t\tint rectMinY = Math.min(Math.min(y1[0], y1[1]), y1[2]);\n\t\tint rectMaxY = Math.max(Math.max(y1[0], y1[1]), y1[2]);\n\t\tif (x2[0] >= rectMinX && x2[0] <= rectMaxX && y2[0] >= rectMinY && y2[0] <= rectMaxY) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t\treturn;\n\t\t}\n\t\tint dMinX = Math.min(Math.min(Math.min(x2[0], x2[1]), x2[2]), x2[3]);\n\t\tint dMaxX = Math.max(Math.max(Math.max(x2[0], x2[1]), x2[2]), x2[3]);\n\t\tint dMinY = Math.min(Math.min(Math.min(y2[0], y2[1]), y2[2]), y2[3]);\n\t\tint dMaxY = Math.max(Math.max(Math.max(y2[0], y2[1]), y2[2]), y2[3]);\n\t\tdouble midX = (dMinX + dMaxX) / 2.0;\n\t\tdouble midY = (dMinY + dMaxY) / 2.0;\n\t\tint x = x1[0];\n\t\tint y = y1[0];\n\t\tif (!above(x, y, dMinX, midY, midX, dMinY))\n\t\t\tSystem.out.println(\"NO\");\n\t\telse if (!above(x, y, midX, dMinY, dMaxX, midY))\n\t\t\tSystem.out.println(\"NO\");\n\t\telse if (above(x, y, dMinX, midY, midX, dMaxY))\n\t\t\tSystem.out.println(\"NO\");\n\t\telse if (above(x, y, midX, dMaxY, dMaxX, midY))\n\t\t\tSystem.out.println(\"NO\");\n\t\telse\n\t\t\tSystem.out.println(\"YES\");\n\t}\n\t\n\tpublic static boolean above(int x, int y, double x1, double y1, double x2, double y2)\n\t{\n\t\tdouble a = (y2 - y1) / (x2 - x1);\n\t\tdouble b = y1 - a * x1;\n\t\tdouble yHat = a * x + b;\n\t\treturn y > yHat;\n\t}\n\t\n\t/**\n\t * Source: Matt Fontaine\n\t */\n\tpublic static class FastScanner\n\t{\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read()\n\t\t{\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c)\n\t\t{\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c)\n\t\t{\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo\n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo\n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}", "complexity": "constant", "problem": "0994_C", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class E\n{\n\tprivate static final int oo = 1000000000;\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tif(n > m)\n\t\t{\n\t\t\tint t = n;\n\t\t\tn = m;\n\t\t\tm = t;\n\t\t}\n\n\t\tint [][] curr = new int[1<<n][1<<n];\n\t\tfill(curr, oo);\n\t\tArrays.fill(curr[0], 0);\n\n\t\tfor(int j = 0 ; j < m ; j++)\n\t\t{\n\t\t\tint [][] next = new int[1<<n][1<<n];\n\t\t\tfill(next, oo);\n\t\t\tfor(int c0 = 0 ; c0 < 1<<n ; c0++)\n\t\t\t\tfor(int c1 = 0 ; c1 < 1<<n ; c1++)\n\t\t\t\t\tif(curr[c0][c1] != oo)\n\t\t\t\t\t\tfor(int c2 = 0 ; c2 < (j == m-1 ? 1 : 1<<n) ; c2++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint done = 0;\n\t\t\t\t\t\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\t\t\t\t\t\tif(((1<<i) & c1) == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint up = i-1;\n\t\t\t\t\t\t\t\t\tint down = i+1;\n\t\t\t\t\t\t\t\t\tif(up >= 0 && ((1<<up) & c1) != 0)\n\t\t\t\t\t\t\t\t\t\tdone |= 1<<i;\n\t\t\t\t\t\t\t\t\tif(down < n && ((1<<down) & c1) != 0)\n\t\t\t\t\t\t\t\t\t\tdone |= 1<<i;\n\t\t\t\t\t\t\t\t\tif(((1<<i) & c0) != 0)\n\t\t\t\t\t\t\t\t\t\tdone |= 1<<i;\n\t\t\t\t\t\t\t\t\tif(((1<<i) & c2) != 0)\n\t\t\t\t\t\t\t\t\t\tdone |= 1<<i;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnext[c1][c2] = Math.min(next[c1][c2], curr[c0][c1] + n - Integer.bitCount(done));\n\n\t\t\t\t\t\t}\n\t\t\tcurr = next;\n\t\t}\n\n\t\tint res = oo;\n\t\tfor(int i = 0 ; i < 1<<n ; i++)\n\t\t\tfor(int j = 0 ; j < 1<<n ; j++)\n\t\t\t\tres = Math.min(res, curr[i][j]);\n\n\t\tSystem.out.println(n*m - res);\n\t}\n\n\tprivate static void fill(int[][] array, int val)\n\t{\n\t\tfor(int [] fill : array)\n\t\t\tArrays.fill(fill, val);\n\t}\n}", "complexity": "np", "problem": "0112_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.text.DecimalFormat;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic Main() {\n\t\tsuper();\n\t}\n\t\n\tpublic static void main(String... args) {\n\t\tMain main = new Main();\n\t\tmain.start();\n\t}\n\t\n\tpublic void start() {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tdouble a[][] = new double[n][n];\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) a[i][j] = Double.parseDouble(in.next());\n\t\t\n\t\tint nn = 1 << n;\n\t\tdouble p[] = new double[nn];\n\t\tArrays.fill(p, -1.0);\n        p[nn - 1] = 1.0;\n\n\t\tDecimalFormat f = new DecimalFormat();\n\t\tf.applyPattern(\"0.000000\");\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i != 0) System.out.print(\" \");\n\t\t\tSystem.out.print(f.format(this.probability(a, p, 1 << i)));\n\t\t}\n\t}\n\t\n\tprivate double probability(double a[][], double p[], int i) {\n        if (p[i] >= 0.0) return p[i];\n        double ans = 0;\n        int count = Integer.bitCount(i);\n        int n = a.length;\n        for (int j = 0; j < n; j++) {\n            int jj = 1 << j;\n            if ((jj & i) == 0) {\n                double d = this.probability(a, p, jj | i);\n                double dPair = 2.0 / (double)((count + 1) * count);\n                double s = 0;\n                for (int l = 0; l < n; l++) {\n                    int ll = 1 << l;\n                    if ((ll & i) != 0) s += a[l][j];\n                }\n                ans += d * dPair * s;\n            }\n        }\n        p[i] = ans;\n        return p[i];\n    }\n\n\n\t\n}", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n\n\npublic class primes {\n\npublic static void main(String []  args){\n\nArrayList<Integer> numb=new ArrayList<Integer>();\nScanner br1 = new Scanner(System.in);\nint n=br1.nextInt();\nint steps=br1.nextInt();\n//if(n>2)numb.add(2);\nif(n>=3)numb.add(3);\nfor(int j=4;j<=n;j++){\nif(chekprime(j)==0){\n\nnumb.add(j);\n//System.out.println(j);\n}\n\n}\nint counter =0;\nfor(int give=0;give<numb.size();give++)\n{if(\"YES\".equals(sumup(numb, 2, numb.get(give)))){\n counter++;\n// System.out.println(numb.get(give)+\"ksjdfskldfgaskldfgasklfgaskldfgaklsfgasdklfgaskldfgaskldfgasdklfg\");\n }\n\n\n\n}\n\n//System.out.println(counter);\nif(counter>=steps)System.out.println(\"YES\");\nelse System.out.println(\"NO\");\n\n\n}\n\npublic static String sumup(ArrayList<Integer> list,int number,int NUM){\n\nString ret=\"NO\";\n    ArrayList<Integer> result=new ArrayList<Integer>();\n\nArrayList<Integer>[] arList=new ArrayList[number];\nfor(int i=0;i<number;i++){\narList[i]=new ArrayList<Integer>();\narList[i]=(ArrayList<Integer>)list.clone();\nfor(int k=0;k<i;k++){\narList[i].add(0,arList[i].remove(arList[i].size()-1));\n}\n\n}\n\n\n    int [] temp=new int[list.size()];\n    \nfor(int z=0;z<list.size();z++){\n    for(int count=0;count<number;count++){\n        \ntemp[z]+=arList[count].get(z);\n//System.out.println(arList[count].get(z));\n    }\n\nresult.add(temp[z]);\n\n}\n\nif(result.contains(NUM-1))\n{    //System.out.println(NUM-1);\nret=\"YES\";\n}\nreturn ret;\n}\n\n\n\npublic static int chekprime(int n){\nint flag=0;\n\nfor(int i=2;i<=Math.sqrt(n)+1;i++)\n{\nif(n%i==0){\nflag=1;\nbreak;\n}\n\n} \n\nreturn flag;\n\n}\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.util.*;\npublic class A135 {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextInt();\n        }\n        Arrays.sort(arr);\n        int[] ans = new int[n];\n        \n        if (arr[n-1] == 1) {\n            for (int i = 0 ;i < n; i++) {\n                ans[i] = arr[i];\n            }\n            ans[n-1] = 2;\n        } else {\n            ans[0] = 1;\n            for (int i = 1; i < n; i++) {\n                ans[i] = arr[i-1];\n            }\n        }\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < n; i++) {\n            buf.append(ans[i]);\n            if (i != n-1) buf.append(' ');\n        }\n        System.out.print(buf.toString());\n    }\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.Scanner;\npublic class Problem0001b {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString s = sc.next();\n\t\t\tif(s.matches(\"R[0-9]+C[0-9]+\")) {\n\t\t\t\tString[] nums = s.split(\"R|C\");\n\t\t\t\tint x = Integer.parseInt(nums[2]);\n\t\t\t\tString t = \"\";\n\t\t\t\twhile(x!=0) {\n\t\t\t\t\tint m = x%26;\n\t\t\t\t\tif(m==0) {\n\t\t\t\t\t\tt='Z'+t;\n\t\t\t\t\t\tx-=26;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tt=(char)(m+'A'-1)+t;\n\t\t\t\t\tx/=26;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(t+nums[1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString x1 = s.replaceAll(\"[0-9]\", \"\");\n\t\t\t\tString x2 = s.replaceAll(\"[A-Z]\", \"\");\n\t\t\t\tint base = 1;\n\t\t\t\tint t = 0;\n\t\t\t\tfor(int j = x1.length() - 1; j >= 0; j--) {\n\t\t\t\t\tt += base*(x1.charAt(j)-'A'+1);\n\t\t\t\t\tbase *= 26;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"R\"+ x2 + \"C\"+t);\n\t\t\t}\n\t\t}\n\t}\n}", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\n\npublic class B implements Runnable {\n\n    private static final boolean ONLINE_JUDGE = true;//System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    private BufferedReader in;\n    private PrintWriter out;\n    private StringTokenizer tok = new StringTokenizer(\"\");\n\n    private void init() throws FileNotFoundException {\n        Locale.setDefault(Locale.US);\n        String fileName = \"\";\n        if (ONLINE_JUDGE && fileName.isEmpty()) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new PrintWriter(fileName + \".out\");\n            }\n        }\n    }\n\n    String readString() {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() {\n        return Double.parseDouble(readString());\n    }\n\n    int[] readIntArray(int size) {\n        int[] a = new int[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        //new Thread(null, new _Solution(), \"\", 128 * (1L << 20)).start();\n        new B().run();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    @Override\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            init();\n            int n = readInt();\n            int[] rect1 = solve1(n);\n            int[] rect2 = solve2(n, rect1);\n\n            out.printf(\"! %s %s %s %s %s %s %s %s\\n\", rect1[0], rect1[1], rect1[2], rect1[3],\n                    rect2[0], rect2[1], rect2[2], rect2[3]);\n            out.flush();\n            out.close();\n            time();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    int ask(int x1, int y1, int x2, int y2) {\n        out.println(\"? \" + x1 + \" \" + y1 + \" \" + x2 + \" \" + y2);\n        out.flush();\n        return readInt();\n    }\n\n    int ask(int x1, int y1, int x2, int y2, int[] rect) {\n        out.println(\"? \" + x1 + \" \" + y1 + \" \" + x2 + \" \" + y2);\n        out.flush();\n        int res = readInt();\n        if (rect[0] >= x1 && rect[2] <= x2 && rect[1] >= y1 && rect[3] <= y2) {\n            res--;\n        }\n        return res;\n    }\n\n    int[] dropTopAndLeft1(int x2, int y2) {\n        int x1 = x2, y1 = y2;\n        int left = 1, right = x2;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            int count = ask(mid, 1, x2, y2);\n            if (count >= 1) {\n                x1 = mid;\n                left = mid + 1;\n            }\n            if (count == 0) {\n                right = mid - 1;\n            }\n        }\n        left = 1;\n        right = y2;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            int count = ask(x1, mid, x2, y2);\n            if (count >= 1) {\n                y1 = mid;\n                left = mid + 1;\n            }\n            if (count == 0) {\n                right = mid - 1;\n            }\n        }\n        return new int[]{x1, y1, x2, y2};\n    }\n\n    private int[] solve1(int n) {\n\n        int x = -1;\n        int left = 1, right = n;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            int count = ask(1, 1, mid, n);\n            if (count >= 1) {\n                x = mid;\n                right = mid - 1;\n            }\n            if (count == 0) {\n                left = mid + 1;\n            }\n        }\n\n        left = 1;\n        right = n;\n        int y = -1;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            int count = ask(1, 1, x, mid);\n            if (count >= 1) {\n                y = mid;\n                right = mid - 1;\n            }\n            if (count == 0) {\n                left = mid + 1;\n            }\n        }\n\n        return dropTopAndLeft1(x, y);\n    }\n\n    private int[] solve2(int n, int[] rect) {\n\n        int x = -1;\n        int left = 1, right = n;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            int count = ask(mid, 1, n, n, rect);\n            if (count >= 1) {\n                x = mid;\n                left = mid + 1;\n            }\n            if (count == 0) {\n                right = mid - 1;\n            }\n        }\n\n        left = 1;\n        right = n;\n        int y = -1;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            int count = ask(x, mid, n, n, rect);\n            if (count >= 1) {\n                y = mid;\n                left = mid + 1;\n            }\n            if (count == 0) {\n                right = mid - 1;\n            }\n        }\n\n        return dropTopAndLeft2(x, y, n, rect);\n    }\n\n    int[] dropTopAndLeft2(int x1, int y1, int n, int[] rect) {\n        int x2 = x1, y2 = y1;\n        int left = x1, right = n;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            int count = ask(x1, y1, mid, n, rect);\n            if (count >= 1) {\n                x2 = mid;\n                right = mid - 1;\n            }\n            if (count == 0) {\n                left = mid + 1;\n            }\n        }\n        left = y1;\n        right = n;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            int count = ask(x1, y1, x2, mid, rect);\n            if (count == 1) {\n                y2 = mid;\n                right = mid - 1;\n            }\n            if (count == 0) {\n                left = mid + 1;\n            }\n        }\n        return new int[]{x1, y1, x2, y2};\n    }\n}\n", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class ProblemA {\n    public static class Team {\n        int solved;\n        int penalty;\n        Team(int s, int p) {\n            solved = s;\n            penalty = p;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n        String[] data = s.readLine().split(\" \");\n        int n =  Integer.valueOf(data[0]);\n        int k =  Integer.valueOf(data[1]);\n\n        \n        Team[] t = new Team[n];\n        for (int i = 0 ; i < n ; i++) {\n            String[] line = s.readLine().split(\" \");\n            t[i] = new Team(Integer.valueOf(line[0]), Integer.valueOf(line[1]));\n        }\n        Arrays.sort(t, new Comparator<Team>(){\n            public int compare(Team arg0, Team arg1) {\n                if (arg0.solved != arg1.solved) {\n                    return arg1.solved - arg0.solved;\n                }\n                return arg0.penalty - arg1.penalty;\n            }\n        });\n        \n        \n        int idx = k - 1;\n        int ksol = t[idx].solved;\n        int kpen = t[idx].penalty;\n        int count = 0;\n        for (int i = 0 ; i < n ; i++) {\n            if (t[i].solved == ksol && t[i].penalty == kpen) {\n                count++;\n            }\n        }\n        System.out.println(count);\n    }\n}", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF1185G2 {\n\tstatic final int MD = 1000000007;\n\tstatic int[][] solve1(int[] aa, int t, int n) {\n\t\tint[][] da = new int[t + 1][n + 1];\n\t\tda[0][0] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = aa[i];\n\t\t\tfor (int s = t - 1; s >= 0; s--)\n\t\t\t\tfor (int m = 0; m < n; m++) {\n\t\t\t\t\tint x = da[s][m];\n\t\t\t\t\tif (x != 0) {\n\t\t\t\t\t\tint s_ = s + a;\n\t\t\t\t\t\tif (s_ <= t)\n\t\t\t\t\t\t\tda[s_][m + 1] = (da[s_][m + 1] + x) % MD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn da;\n\t}\n\tstatic int[][][] solve2(int[] aa, int[] bb, int t, int na, int nb) {\n\t\tint[][] da = solve1(aa, t, na);\n\t\tint[][][] dab = new int[t + 1][na + 1][nb + 1];\n\t\tfor (int s = 0; s <= t; s++)\n\t\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\t\tdab[s][ma][0] = da[s][ma];\n\t\tfor (int i = 0; i < nb; i++) {\n\t\t\tint b = bb[i];\n\t\t\tfor (int s = t - 1; s >= 0; s--)\n\t\t\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\t\t\tfor (int mb = 0; mb < nb; mb++) {\n\t\t\t\t\t\tint x = dab[s][ma][mb];\n\t\t\t\t\t\tif (x != 0) {\n\t\t\t\t\t\t\tint s_ = s + b;\n\t\t\t\t\t\t\tif (s_ <= t)\n\t\t\t\t\t\t\t\tdab[s_][ma][mb + 1] = (dab[s_][ma][mb + 1] + x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t}\n\t\treturn dab;\n\t}\n\tstatic long power(int a, int k) {\n\t\tif (k == 0)\n\t\t\treturn 1;\n\t\tlong p = power(a, k / 2);\n\t\tp = p * p % MD;\n\t\tif (k % 2 == 1)\n\t\t\tp = p * a % MD;\n\t\treturn p;\n\t}\n\tstatic int[] ff, gg;\n\tstatic int ch(int n, int k) {\n\t\treturn (int) ((long) ff[n] * gg[n - k] % MD * gg[k] % MD);\n\t}\n\tstatic int[][][] init(int n, int na, int nb, int nc) {\n\t\tff = new int[n + 1];\n\t\tgg = new int[n + 1];\n\t\tfor (int i = 0, f = 1; i <= n; i++) {\n\t\t\tff[i] = f;\n\t\t\tgg[i] = (int) power(f, MD - 2);\n\t\t\tf = (int) ((long) f * (i + 1) % MD);\n\t\t}\n\t\tint[][][] dp = new int[na + 1][nb + 1][nc + 1];\n\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\tfor (int mb = 0; mb <= nb; mb++)\n\t\t\t\tfor (int mc = 0; mc <= nc; mc++) {\n\t\t\t\t\tint x = (int) ((long) ff[ma + mb + mc] * gg[ma] % MD * gg[mb] % MD * gg[mc] % MD);\n\t\t\t\t\tfor (int ma_ = ma == 0 ? 0 : 1; ma_ <= ma; ma_++) {\n\t\t\t\t\t\tint cha = ma == 0 ? 1 : ch(ma - 1, ma_ - 1);\n\t\t\t\t\t\tfor (int mb_ = mb == 0 ? 0 : 1; mb_ <= mb; mb_++) {\n\t\t\t\t\t\t\tint chb = mb == 0 ? 1 : ch(mb - 1, mb_ - 1);\n\t\t\t\t\t\t\tfor (int mc_ = mc == 0 ? 0 : 1; mc_ <= mc; mc_++) {\n\t\t\t\t\t\t\t\tint chc = mc == 0 ? 1 : ch(mc - 1, mc_ - 1);\n\t\t\t\t\t\t\t\tint y = dp[ma_][mb_][mc_];\n\t\t\t\t\t\t\t\tif (y == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tx = (int) ((x - (long) y * cha % MD * chb % MD * chc) % MD);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (x < 0)\n\t\t\t\t\t\tx += MD;\n\t\t\t\t\tdp[ma][mb][mc] = x;\n\t\t\t\t}\n\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\tfor (int mb = 0; mb <= nb; mb++)\n\t\t\t\tfor (int mc = 0; mc <= nc; mc++)\n\t\t\t\t\tdp[ma][mb][mc] = (int) ((long) dp[ma][mb][mc] * ff[ma] % MD * ff[mb] % MD * ff[mc] % MD);\n\t\treturn dp;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint t = Integer.parseInt(st.nextToken());\n\t\tint[] aa = new int[n];\n\t\tint[] bb = new int[n];\n\t\tint[] cc = new int[n];\n\t\tint na = 0, nb = 0, nc = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint a = Integer.parseInt(st.nextToken());\n\t\t\tint g = Integer.parseInt(st.nextToken());\n\t\t\tif (g == 1)\n\t\t\t\taa[na++] = a;\n\t\t\telse if (g == 2)\n\t\t\t\tbb[nb++] = a;\n\t\t\telse\n\t\t\t\tcc[nc++] = a;\n\t\t}\n\t\tint[][][] dp = init(n, na, nb, nc);\n\t\tint[][][] dab = solve2(aa, bb, t, na, nb);\n\t\tint[][] dc = solve1(cc, t, nc);\n\t\tint ans = 0;\n\t\tfor (int tab = 0; tab <= t; tab++) {\n\t\t\tint tc = t - tab;\n\t\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\t\tfor (int mb = 0; mb <= nb; mb++) {\n\t\t\t\t\tint xab = dab[tab][ma][mb];\n\t\t\t\t\tif (xab == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int mc = 0; mc <= nc; mc++) {\n\t\t\t\t\t\tint xc = dc[tc][mc];\n\t\t\t\t\t\tif (xc == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tans = (int) ((ans + (long) xab * xc % MD * dp[ma][mb][mc]) % MD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "complexity": "cubic", "problem": "1185_G2", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A implements Runnable {\n\n\tBufferedReader br;\n\tStringTokenizer in;\n\tPrintWriter out;\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new A()).start();\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\twhile (in == null || !in.hasMoreTokens()) {\n\t\t\tin = new StringTokenizer(br.readLine());\n\t\t}\n\t\treturn in.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic void solve() throws IOException {\n\t\tString s = nextToken();\n\t\tint max = 0;\n\t\tfor(int i = 0 ; i < s.length(); i++)\n\t\t\tfor(int j = i+1 ; j < s.length(); j ++){\n\t\t\t\tString sub = s.substring(i, j);\n\t\t\t\tint kv = 0;\n\t\t\t\tfor(int k = 0 ; k<= s.length() - sub.length(); k ++){\n\t\t\t\t\tboolean ok = true;\n\t\t\t\t\tfor(int g = 0 ; g < sub.length(); g ++)\n\t\t\t\t\tif (sub.charAt(g) != s.charAt(g+k)){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) kv ++;\n\t\t\t\t}\n\t\t\t\tif (kv > 1)\n\t\t\t\tmax = Math.max(max, sub.length());\n\t\t\t}\n\t\t\t\t\n\t\tout.println(max);\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\n\t\t//\t\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t//\t\tout = new PrintWriter(\"output.txt\");\n\t\t\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t}\n\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\npublic class Main2 {\n\n    static long mod = 998244353;\n    static FastScanner scanner;\n\n    static StringBuilder result = new StringBuilder();\n\n    public static void main(String[] args) {\n        scanner = new FastScanner();\n        int t = scanner.nextInt();\n        for (int i = 0; i < t; i++) {\n            solve();\n            result.append(\"\\n\");\n        }\n        System.out.print(result.toString());\n    }\n\n\n\n    static void solve() {\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        PriorityQueue<WithIdx2> queue = new PriorityQueue<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                queue.add(new WithIdx2(scanner.nextInt(), i, j));\n            }\n        }\n\n        if (n <= 3) {\n            int res = 0;\n            for (int k = 0; k < n; k++) {\n                res += queue.poll().val;\n            }\n            result.append(res);\n        } else {\n\n            List<WithIdx2> a = new ArrayList<>();\n            for (int i = 0; i < 9; i++) {\n                if (!queue.isEmpty()) a.add(queue.poll());\n            }\n            int[] offsets = new int[m];\n            best = -1;\n            Arrays.fill(offsets, -100);\n            put(0, a, offsets, new int[4]);\n            result.append(best);\n        }\n    }\n\n    static int best = -1;\n\n    static void put(int current, List<WithIdx2> vals, int[] offsets, int[] rows) {\n        if (current == vals.size()) {\n            for (int i = 0; i < rows.length; i++) if (rows[i] == 0) return;\n            int sum = IntStream.of(rows).sum();\n            best = Math.max(best, sum);\n            return;\n        }\n        for (int row = 0; row < 4; row++) {\n            if (rows[row] == 0) {\n                WithIdx2 c = vals.get(current);\n                if (offsets[c.y] == -100) {\n                    rows[row] = c.val;\n                    offsets[c.y] = row - c.x;\n                    put(current + 1, vals, offsets, rows);\n                    rows[row] = 0;\n                    offsets[c.y] = -100;\n                } else {\n                    int bind = c.x + offsets[c.y];\n                    if (bind < 0) bind += 4;\n                    if (bind >= 4) bind -= 4;\n                    if (row == bind) {\n                        rows[row] = c.val;\n                        put(current + 1, vals, offsets, rows);\n                        rows[row] = 0;\n                    }\n                }\n            }\n        }\n        put(current + 1, vals, offsets, rows);\n    }\n\n    static class WithIdx2 implements Comparable<WithIdx2>{\n        int x, y, val;\n\n        public WithIdx2(int val, int x, int y) {\n            this.val = val;\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(WithIdx2 o) {\n            return -Integer.compare(val, o.val);\n        }\n    }\n\n\n\n    static class WithIdx implements Comparable<WithIdx>{\n        int val, idx;\n\n        public WithIdx(int val, int idx) {\n            this.val = val;\n            this.idx = idx;\n        }\n\n        @Override\n        public int compareTo(WithIdx o) {\n            return Integer.compare(val, o.val);\n        }\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                e.printStackTrace();\n                throw new RuntimeException();\n            }\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) res[i] = nextInt();\n            return res;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) res[i] = nextLong();\n            return res;\n        }\n\n        String[] nextStringArray(int n) {\n            String[] res = new String[n];\n            for (int i = 0; i < n; i++) res[i] = nextToken();\n            return res;\n        }\n    }\n\n    static class PrefixSums {\n        long[] sums;\n\n        public PrefixSums(long[] sums) {\n            this.sums = sums;\n        }\n\n        public long sum(int fromInclusive, int toExclusive) {\n            if (fromInclusive > toExclusive) throw new IllegalArgumentException(\"Wrong value\");\n            return sums[toExclusive] - sums[fromInclusive];\n        }\n\n        public static PrefixSums of(int[] ar) {\n            long[] sums = new long[ar.length + 1];\n            for (int i = 1; i <= ar.length; i++) {\n                sums[i] = sums[i - 1] + ar[i - 1];\n            }\n            return new PrefixSums(sums);\n        }\n\n        public static PrefixSums of(long[] ar) {\n            long[] sums = new long[ar.length + 1];\n            for (int i = 1; i <= ar.length; i++) {\n                sums[i] = sums[i - 1] + ar[i - 1];\n            }\n            return new PrefixSums(sums);\n        }\n    }\n\n    static class ADUtils {\n        static void sort(int[] ar) {\n            Random rnd = ThreadLocalRandom.current();\n            for (int i = ar.length - 1; i > 0; i--)\n            {\n                int index = rnd.nextInt(i + 1);\n                // Simple swap\n                int a = ar[index];\n                ar[index] = ar[i];\n                ar[i] = a;\n            }\n            Arrays.sort(ar);\n        }\n\n        static void reverse(int[] arr) {\n            int last = arr.length / 2;\n            for (int i = 0; i < last; i++) {\n                int tmp = arr[i];\n                arr[i] = arr[arr.length - 1 - i];\n                arr[arr.length - 1 - i] = tmp;\n            }\n        }\n\n        static void sort(long[] ar) {\n            Random rnd = ThreadLocalRandom.current();\n            for (int i = ar.length - 1; i > 0; i--)\n            {\n                int index = rnd.nextInt(i + 1);\n                // Simple swap\n                long a = ar[index];\n                ar[index] = ar[i];\n                ar[i] = a;\n            }\n            Arrays.sort(ar);\n        }\n    }\n\n    static class MathUtils {\n        static long[] FIRST_PRIMES = {\n                2,     3,      5,      7,     11,     13,     17,     19,     23,     29,\n                31,     37,     41,     43,     47,     53,     59,     61,     67,     71,\n                73,     79,     83,     89  ,   97 ,    101,    103,    107,    109,    113,\n                127,    131,    137,    139,    149,    151,    157,    163,    167,    173,\n                179,    181,    191,    193,    197,    199,    211,    223,    227,    229,\n                233,    239,    241,    251,    257,    263,    269,    271,    277,    281,\n                283,    293,    307,    311,    313,    317,    331,    337,    347,    349,\n                353,    359,    367,    373,    379,    383,    389,    397,    401,    409,\n                419,    421,    431,    433,    439,    443,    449,    457,    461,    463,\n                467,    479,    487,    491,    499,    503,    509,    521,    523,    541,\n                547,    557,    563,    569,    571,    577,    587,    593,    599,    601,\n                607,    613,    617,    619,    631,    641,    643,    647,    653,    659,\n                661,    673,    677,    683,    691,    701,    709,    719,    727,    733,\n                739,    743,    751,    757,    761,    769,    773,    787,    797,    809,\n                811,    821,    823,    827,    829,    839,    853,    857,    859,    863,\n                877,    881,    883,    887,    907,    911,    919,    929,    937,    941,\n                947,    953,    967,    971,    977,    983,    991,    997,   1009,   1013,\n                1019,   1021,   1031,   1033,   1039,   1049,   1051};\n\n        static long[] primes(int to) {\n            long[] all = new long[to + 1];\n            long[] primes = new long[to + 1];\n            all[1] = 1;\n            int primesLength = 0;\n            for (int i = 2; i <= to; i ++) {\n                if (all[i] == 0) {\n                    primes[primesLength++] = i;\n                    all[i] = i;\n                }\n                for (int j = 0; j < primesLength && i * primes[j] <= to && all[i] >= primes[j]; j++) {\n                    all[(int) (i * primes[j])] = primes[j];\n                }\n            }\n            return Arrays.copyOf(primes, primesLength);\n        }\n\n        static long modpow(long b, long e, long m) {\n            long result = 1;\n\n            while (e > 0) {\n                if ((e & 1) == 1) {\n                    /* multiply in this bit's contribution while using modulus to keep\n                     * result small */\n                    result = (result * b) % m;\n                }\n                b = (b * b) % m;\n                e >>= 1;\n            }\n\n            return result;\n        }\n\n        static long submod(long x, long y, long m) {\n            return (x - y + m) % m;\n        }\n    }\n}\n\n/*\n1\n4 2\n5 7 6 2 2 5 3 6\n */", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "// Don't place your source in a package\n\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\n\n// Please name your class Main\npublic class Main {\n    static FastScanner fs=new FastScanner();\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int Int() {\n            return Integer.parseInt(next());\n        }\n\n        long Long() {\n            return Long.parseLong(next());\n        }\n\n        String Str(){\n            return next();\n        }\n    }\n\n\n    public static void main (String[] args) throws java.lang.Exception {\n        PrintWriter out = new PrintWriter(System.out);\n\n\n        int T=1;\n        for(int t=0;t<T;t++){\n            long k=Long();\n            Solution sol=new Solution(out);\n            sol.solution(k);\n        }\n        out.flush();\n\n    }\n\n\n    public static int Int(){\n        return fs.Int();\n    }\n    public static long Long(){\n        return fs.Long();\n    }\n    public static String Str(){\n        return fs.Str();\n    }\n\n}\n\n\n\n\n\n\nclass Solution{\n    PrintWriter out;\n    public Solution(PrintWriter out){\n        this.out=out;\n    }\n\n\n    long f[]=new long[15];\n    public void solution(long k){\n        f[0]=9;\n        for(int i=1;i<f.length;i++){\n            f[i]=10*f[i-1];\n        }\n        for(int i=1;i<f.length;i++){\n            f[i]*=(i+1);\n        }\n\n        long l=1,r=1000000000000l;\n        long res=-1;\n        long count=0;\n        while(l<=r){\n            long mid=l+(r-l)/2;\n            long cnt=get(mid);\n            if(cnt>=k){\n                res=mid;\n                count=cnt;\n                r=mid-1;\n            }\n            else{\n                l=mid+1;\n            }\n        }\n\n        int extra=(int)(count-k);\n        String s=res+\"\";\n        out.println(s.charAt(s.length()-1-extra));\n    }\n\n    public long get(long n){\n        long res=0;\n        long base=0;\n        int i=0;\n        while(true){\n            if(n<=base*10+9){\n                res=res+(i+1)*(n-base);\n                break;\n            }\n            res+=(f[i]);\n            i++;\n            base=base*10+9;\n        }\n        return res;\n    }\n\n\n\n\n\n\n\n\n\n\n\n}\n\n\n\n/*\n                             ;\\\n                            |' \\\n         _                  ; : ;\n        / `-.              /: : |\n       |  ,-.`-.          ,': : |\n       \\  :  `. `.       ,'-. : |\n        \\ ;    ;  `-.__,'    `-.|\n         \\ ;   ;  :::  ,::'`:.  `.\n          \\ `-. :  `    :.    `.  \\\n           \\   \\    ,   ;   ,:    (\\\n            \\   :., :.    ,'o)): ` `-.\n           ,/,' ;' ,::\"'`.`---'   `.  `-._\n         ,/  :  ; '\"      `;'          ,--`.\n        ;/   :; ;             ,:'     (   ,:)\n          ,.,:.    ; ,:.,  ,-._ `.     \\\"\"'/\n          '::'     `:'`  ,'(  \\`._____.-'\"'\n             ;,   ;  `.  `. `._`-.  \\\\\n             ;:.  ;:       `-._`-.\\  \\`.\n              '`:. :        |' `. `\\  ) \\\n      -hrr-      ` ;:       |    `--\\__,'\n                   '`      ,'\n                        ,-'\n\n\n                      free bug dog\n*/\n\n\n\n\n\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author George Marcus\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int N = in.nextInt();\n        if(N >= 0)\n            out.println(N);\n        else {\n            N = Math.abs(N);\n            int v1 = - (N / 10);\n            int v2 = - (N / 100 * 10 + (N % 10));\n            out.println(Math.max(v1, v2));\n        }\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n    public String nextString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n\n        return res.toString();\n    }\n\n    private boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    }\n\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.util.*;\npublic class test{\npublic static void main(String args[])\n{\nScanner s=new Scanner(System.in);\nint n=s.nextInt();\nint m=s.nextInt();\nint arr[]=new int[n];\nint max = Integer.MIN_VALUE;\n        long sum = 0;\n        for(int i=0;i<n;i++)\n        {\n            arr[i] = s.nextInt();\n            sum = sum + arr[i];\n            max = Math.max(max,arr[i]);\n        }\n        Arrays.sort(arr);\n        int i = 0;\n        int count = 0;\n        int d = 0;\n        for(i=0; i<n; i++)\n        {\n            if(arr[i] > d)\n            {\n                count++;\n                d++;\n            }\n            else if(arr[i] == d && arr[i] > 0)\n            {\n                count++;\n            }\n        }\n        //System.out.println(count + \" \" + max);\n        if(max - d > 0)\n        {\n            count = count + max - d;\n        }\n        System.out.println(sum - count);}}", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main\n\t{\t\n\t\tclass node{\n\t\tint data;\n\t\tnode next;\n\t\tpublic node(int val){\n\t\t\tdata=val;\n\t\t\tnext=null;\n\t\t}\n\t}\n\tclass linkedlist{\n\t\tnode start;\n\t\tnode end;\n\t\tint size;\n\t\tint turn;\n\t\tpublic linkedlist(){\n\t\t\tstart=null;\n\t\t\tend=null;\n\t\t\tsize=0;\n\t\t}\n\t\tvoid add(int val){\n\t\t\tif(size==0){\n\t\t\t\tnode t=new node(val);\n\t\t\t\tstart=t;\n\t\t\t\tend=t;\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnode t=new node(val);\n\t\t\t\tend.next=t;\n\t\t\t\tend=end.next;\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t\tvoid myfunc(){\n\t\t\tif(start.data>start.next.data){\n\t\t\t\t// System.out.println(\"me ni hu\");\n\t\t\t\tnode t=new node(start.next.data);\n\t\t\t\tstart.next=start.next.next;\n\t\t\t\tend.next=t;\n\t\t\t\tend=end.next;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// System.out.println(\"me hu\");\n\t\t\t\tint t=start.data;\n\t\t\t\tstart=start.next;\n\t\t\t\tadd(t);\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tint findmax(){\n\t\t\tint m=0;\n\t\t\tnode temp=start;\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tif(temp.data>m){\n\t\t\t\t\tm=temp.data;\n\t\t\t\t}\n\t\t\t\ttemp=temp.next;\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\tvoid display(){\n\t\t\tnode temp=start;\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tSystem.out.print(temp.data+\" \");\n\t\t\t\ttemp=temp.next;\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t}\n\tlinkedlist l;\n\tpublic Main(){\n\t\tl=new linkedlist();\n\t}\n\tpublic static void main(String [] argv) throws IOException\n\t{\n\t\tBufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n\t\tMain ma=new Main();\n\t\tString[] l1=in.readLine().split(\" \");\n\t\tint n=Integer.parseInt(l1[0]);\n\t\tint q=Integer.parseInt(l1[1]);\n\t\tString[] ar=in.readLine().split(\" \");\n\t\tint a1=Integer.parseInt(ar[0]);\n\t\tint b1=Integer.parseInt(ar[1]);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tma.l.add(Integer.parseInt(ar[i]));\n\t\t}\n\t\tint m=ma.l.findmax();\n\t\tint[][] pair=new int[n][2];\n\t\tint t=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(ma.l.start.data==m)\n\t\t\t\tbreak;\n\t\t\tma.l.myfunc();\n\t\t\tpair[t][0]=ma.l.start.data;\n\t\t\tpair[t][1]=ma.l.start.next.data;\n\t\t\tt++;\n\t\t}\n\t\tint rl[]=new int[n];\n\t\tnode temp=ma.l.start;\n\t\tfor(int i=0;i<n;i++){\n\t\t\trl[i]=temp.data;\n\t\t\ttemp=temp.next;\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tlong a=Long.parseLong(in.readLine());\n\t\t\tif(a==1){\n\t\t\t\tSystem.out.println(a1 + \" \" + b1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(a<=t+1){\n\t\t\t\t\tSystem.out.println(pair[(int)(a-2)][0]+\" \"+pair[(int)(a-2)][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif((a-t)%(n-1)==0){\n\t\t\t\t\t\tSystem.out.println(rl[0]+\" \"+rl[n-1]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tSystem.out.println(rl[0]+\" \"+rl[(int)((a-t)%(n-1))]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "complexity": "linear", "problem": "1179_A", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "import static java.lang.Math.*;\nimport static java.lang.System.currentTimeMillis;\nimport static java.lang.System.exit;\nimport static java.lang.System.arraycopy;\nimport static java.util.Arrays.sort;\nimport static java.util.Arrays.binarySearch;\nimport static java.util.Arrays.fill;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry {\n\t\t\tif (new File(\"input.txt\").exists())\n\t\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n\t\t} catch (SecurityException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st = new StringTokenizer(\"\");\n\n\tprivate void run() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\n\t\tint n = nextInt();\n\t\tint m[] = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tm[i] = nextInt();\n\t\tsort(m);\n\t\tm[n - 1] = m[n - 1] != 1 ? 1 : 2;\n\t\tsort(m);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(i != 0) out.print(\" \");\n\t\t\tout.print(m[i]);\n\t\t}\n\t\tout.println();\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tvoid chk(boolean b) {\n\t\tif (b)\n\t\t\treturn;\n\t\tSystem.out.println(new Error().getStackTrace()[1]);\n\t\texit(999);\n\t}\n\tvoid deb(String fmt, Object... args) {\n\t\tSystem.out.printf(Locale.US, fmt + \"%n\", args);\n\t}\n\tString nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\tString nextLine() throws IOException {\n\t\tst = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\tboolean EOF() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString s = in.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn true;\n\t\t\tst = new StringTokenizer(s);\n\t\t}\n\t\treturn false;\n\t}\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tstatic int n,t[],g[],MOD=(int)1e9+7;\n\tstatic int [][]memo;\n\tstatic int dp(int msk,int rem,int lastG) {\n\t\tif(rem==0)\n\t\t\treturn 1;\n\t\tif(memo[lastG][msk]!=-1)\n\t\t\treturn memo[lastG][msk];\n\t\tint ans=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif((msk & (1<<i))==0 && rem>=t[i] && g[i]!=lastG)\n\t\t\t\tans+=dp(msk|1<<i,rem-t[i],g[i]);\n\t\t\t\tif(ans>=MOD)\n\t\t\t\t\tans-=MOD;\n\t\t}\n\t\treturn memo[lastG][msk]=ans;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tn=sc.nextInt();\n\t\tint T=sc.nextInt();\n\t\tt=new int [n];\n\t\tg=new int [n];\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tt[i]=sc.nextInt();\n\t\t\tg[i]=sc.nextInt()-1;\n\t\t}\n\t\tmemo=new int [4][1<<n];\n\t\tfor(int []x:memo)\n\t\t\tArrays.fill(x, -1);\n\t\tout.println(dp(0, T, 3));\n\t\tout.close();\n\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tboolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.util.Scanner;\n\npublic class MargariteBestPresent_1080B {\n\n\tprivate static int f(int x) {\n\t\treturn (x%2==0)?x/2:(x-1)/2-x;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n,r,l;\n\t\tn = sc.nextInt();\n\t\twhile(n-->0) {\n\t\t\tl = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\n\t\t\tSystem.out.println(f(r)-f(l-1));\n\t\t}\n\t\tsc.close();\n\t}\n\n}\n", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.*; \nimport java.io.*;\n \npublic class Main {\n\t\n\tpublic static int mod = 1000000007;\n\t\n\tpublic static void solve(InputReader in) {\n\t\tint n = in.readInt();\n\t\tint m = in.readInt();\n\t\tfor(int i = 0 ; i<1130; i++) {\n\t\t\tSystem.out.print(8);\n\t\t\tif(i == 1129) System.out.print(9);\n\t\t}\n\t\tSystem.out.println(); \n\t\tfor(int i = 0; i<1131; i++) {\n\t\t\tSystem.out.print(1);\n\t\t}\n\t}\n\t\n \n\tpublic static void main(String[] args) {\n\t\t// jai shree krishna\n\t\tInputReader in = new InputReader(System.in); \n\t\tint t = 1;\n\t\twhile (t-- > 0)\n\t\t\tsolve(in);\n\t}\n}\n \n \nclass InputReader{\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n \n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n \n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic long readLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9') {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\t\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n     \n\tpublic String next() {\n\t\treturn readString();\n\t}\n    \n    public interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n \n \n \nclass pair implements Comparable<pair> {\n\tlong first;\n\tlong second;\n \n\tpair(long a, long b) {\n\t\tthis.first = a;\n\t\tthis.second = b;\n\t}\n \n\tpublic long getFirst() {\n\t\treturn first;\n\t}\n \n\tpublic long getSecond() {\n\t\treturn second;\n\t}\n \n\tpublic String toString() {\n\t\treturn first + \" \" + second;\n\t}\n \n\tpublic boolean equals(Object o) {\n\t\treturn o instanceof pair && ((pair) o).first == first && ((pair) o).second == second;\n\t}\n \n\tpublic int compareTo(pair a) {\n\t\treturn Long.compare(first, a.first);\n\t}\n \n\tpublic int hashCode() {\n\t\treturn (31 * (int) first + (int) second);\n\t}\n}\n", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "//package cf584d12;\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class A {\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tint n = sc.nextInt();\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\tArrays.sort(a);\n\t\tboolean[] b = new boolean[n];\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(!b[i]) {\n\t\t\t\tans++;\n\t\t\t\tfor(int j = i + 1; j < n; j++)\n\t\t\t\t\tif(a[j] % a[i] == 0)\n\t\t\t\t\t\tb[j] = true;\n\t\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n\tpublic static PrintWriter out  = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static class MyScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements())\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class P_35C {\n    static final FS sc = new FS();\n    static final PrintWriter pw = new PrintWriter(System.out);\n    static int[][] g;\n    static int[][] res;\n    static boolean[][] visited;\n    static int[] dx = {1,0,-1,0};\n    static int[] dy = {0,-1,0,1};\n    static int n, m;\n    static Queue<Integer> qx;\n    static Queue<Integer> qy;\n    static Queue<Integer> c;\n    static void bfs(){\n        while(!qx.isEmpty() && !qy.isEmpty()){\n            int xn = qx.poll();\n            int yn = qy.poll();\n            for(int i=0; i<4; i++){\n                int nx = xn+dx[i];\n                int ny = yn+dy[i];\n                if(nx>=0 && ny>=0 && nx<n && ny<m && res[nx][ny]==-1){\n                    res[nx][ny] = res[xn][yn]+1;\n                    qx.add(nx);\n                    qy.add(ny);\n//                    c.add(pn);\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) throws FileNotFoundException {\n        File file = new File(\"input.txt\");\n        Scanner sc = new Scanner(file);\n        n = sc.nextInt();\n        m = sc.nextInt();\n        int k = sc.nextInt();\n        ArrayList<Integer> xl = new ArrayList<>();\n        ArrayList<Integer> yl = new ArrayList<>();\n        g = new int[n][m];\n        res = new int[n][m];\n        visited = new boolean[n][m];\n        qx = new LinkedList<>();\n        qy = new LinkedList<>();\n        for(int i=0; i<k; i++){\n            int xi = sc.nextInt()-1;\n            int yi = sc.nextInt()-1;\n//            --xi; --yi;\n            qx.add(xi); qy.add(yi);\n//            xl.add(xi); yl.add(yi);\n            res[xi][yi] = 1;\n//            g[--xi][--yi] = 1;\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(res[i][j]==1) res[i][j] = 0;\n                else res[i][j] = -1;\n            }\n        }\n        bfs();\n        int x = 0,y = 0;\n        int max = Integer.MIN_VALUE;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(res[i][j]>max){\n                    max = res[i][j];\n                    x = i; y = j;\n                }\n            }\n        }\n\n\n//        for(int i=0; i<n; i++) System.out.println(Arrays.toString(res[i]));\n        try {\n            FileWriter writer = new FileWriter(\"output.txt\");\n            writer.write((x+1)+\" \"+(y+1));\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n//        System.out.println((x+1)+\" \"+(y+1));\n    }\n\n    static class FS {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception ignored) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int[] nextArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.Scanner;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tstatic long[] dx = new long[]{0, 1, 0, -1};\n\tstatic long[] dy = new long[]{-1, 0, 1, 0};\n\tpublic static void main(String[] args) {\n\t\tScanner r = new Scanner(System.in);\n\t\t\n\t\tlong N = r.nextLong();\n\t\tlong X = r.nextLong();\n\t\tlong Y = r.nextLong();\n\t\tlong C = r.nextLong();\n\t\t\n\t\tlong lo = 0, hi = N * 2;\n\t\t\n\t\twhile(lo < hi){\n\t\t\tlong T = (lo + hi) / 2;\n\t\t\t\n\t\t\tlong[] NX = new long[4];\n\t\t\tlong[] NY = new long[4];\n\t\t\t\n\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\tNX[d] = X + dx[d] * T;\n\t\t\t\tNY[d] = Y + dy[d] * T;\n\t\t\t}\n\t\t\t\n\t\t\tlong ret = (T + 1) * (T + 1) + T * T;\n\t\t\t\n\t\t\tret -= half(1 - NY[0]);\n\t\t\tret -= half(NY[2] - N);\n\t\t\tret -= half(NX[1] - N);\n\t\t\tret -= half(1 - NX[3]);\n\t\t\t\n\t\t\tret += quarter(1 - NY[0] - (N - X + 1));\n\t\t\tret += quarter(1 - NY[0] - (X));\n\t\t\tret += quarter(NY[2] - N - (N - X + 1));\n\t\t\tret += quarter(NY[2] - N - (X));\n\t\t\t\n\t\t\tif(ret < C)lo = T + 1;\n\t\t\telse hi = T;\n\t\t}\n\t\t\n\t\tSystem.out.println(lo);\n\t\t\n\t}\n\tprivate static long half(long x) {\n\t\tif(x <= 0)return 0;\n\t\telse return 2 * quarter(x) - x;\n\t}\n\tprivate static long quarter(long x){\n\t\tif(x <= 0)return 0;\n\t\treturn x * (x + 1) / 2;\n\t}\n\n}\n", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "// created by \u6211\u4e0d\u77e5\u9053\u6211\u662f\u8c01\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.util.*;\npublic class cp18{\n\n\n    static class Reader {\n        static BufferedReader reader;\n        static StringTokenizer tokenizer;\n\n        static void init(InputStream input) {\n            reader = new BufferedReader(\n                    new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        static String next() throws IOException {\n            while (!tokenizer.hasMoreTokens()) {\n                //TODO add check for eof if necessary\n                tokenizer = new StringTokenizer(\n                        reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        static int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        static double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        static long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n\n\n\n\n    public static void main(String[] args)  throws IOException {\n        Reader.init(System.in);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n        int t= Reader.nextInt();\n        for (int tt = 0; tt <t ; tt++) {\n            int n= Reader.nextInt();\n            Stack<Integer>stk= new Stack<>();\n            for (int i = 0; i <n ; i++) {\n                int x= Reader.nextInt();\n                if(x==1){\n                    stk.add(1);\n                }\n                else{\n                    while(stk.peek()!=x-1){\n                        stk.pop();\n                    }\n                    stk.pop();\n                    stk.add(x);\n\n                }\n                for (int j = 0; j <stk.size()-1 ; j++) {\n                    out.append(stk.get(j)+\".\");\n                }\n                out.append(stk.get(stk.size()-1)+\"\");\n                out.append(\"\\n\");\n\n\n\n\n\n\n\n\n\n\n\n\n            }\n\n        }\n\n\n\n\n\n        out.flush();\n        out.close();\n    }\n    static boolean possible(int arr[], int n){\n        boolean pos= false;\n        for (int i = 0; i <n ; i++) {\n            if(arr[i]==0){\n               int c=0;\n               if((i-1)>=0 && arr[i-1]==1){\n                   c++;\n               }\n               if(i+1<n && arr[i+1]==1){\n                   c++;\n               }\n               if(c==1){\n\n                       pos=true;\n                       break;\n\n               }\n            }\n\n        }\n\n\n    return pos;\n    }\n\n\n    static long power( long x, long y, long p)\n    {\n\n        long res = 1;\n\n\n        x = x % p;\n\n        if (x == 0) return 0;\n\n        while (y > 0)\n        {\n\n            if((y & 1)==1)\n                res = (res * x) % p;\n\n\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class A implements Runnable {\n\n    public void run() {\n        long startTime = System.nanoTime();\n\n        int n = nextInt();\n\n        String[] all = new String[9];\n        all[0] = \"M\";\n        for (int i = 0; i < 4; i++) {\n            String s = \"\";\n            for (int j = 0; j < i; j++) {\n                s += \"X\";\n            }\n            all[2 * i + 1] = s + \"S\";\n            all[2 * i + 2] = s + \"L\";\n        }\n\n        Map<String, Integer> map1 = new HashMap<>();\n        Map<String, Integer> map2 = new HashMap<>();\n        for (String s : all) {\n            map1.put(s, 0);\n            map2.put(s, 0);\n        }\n        for (int i = 0; i < n; i++) {\n            String s = nextToken();\n            map1.put(s, map1.get(s) + 1);\n        }\n        for (int i = 0; i < n; i++) {\n            String s = nextToken();\n            map2.put(s, map2.get(s) + 1);\n        }\n\n        int res = 0;\n        for (String s : all) {\n            int a = map1.get(s);\n            int b = map2.get(s);\n\n            if (a > b) {\n                res += a - b;\n            }\n        }\n        println(res);\n\n        if (fileIOMode) {\n            System.out.println((System.nanoTime() - startTime) / 1e9);\n        }\n        out.close();\n    }\n\n    //-----------------------------------------------------------------------------------\n\n    private static boolean fileIOMode;\n    private static BufferedReader in;\n    private static PrintWriter out;\n    private static StringTokenizer tokenizer;\n\n    public static void main(String[] args) throws Exception {\n        fileIOMode = args.length > 0 && args[0].equals(\"!\");\n        if (fileIOMode) {\n            in = new BufferedReader(new FileReader(\"a.in\"));\n            out = new PrintWriter(\"a.out\");\n        } else {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n        tokenizer = new StringTokenizer(\"\");\n\n        new Thread(new A()).start();\n    }\n\n    private static String nextLine() {\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    private static String nextToken() {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(nextLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    private static int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    private static long nextLong() {\n        return Long.parseLong(nextToken());\n    }\n\n    private static double nextDouble() {\n        return Double.parseDouble(nextToken());\n    }\n\n    private static BigInteger nextBigInteger() {\n        return new BigInteger(nextToken());\n    }\n\n    private static void print(Object o) {\n        if (fileIOMode) {\n            System.out.print(o);\n        }\n        out.print(o);\n    }\n\n    private static void println(Object o) {\n        if (fileIOMode) {\n            System.out.println(o);\n        }\n        out.println(o);\n    }\n\n    private static void printf(String s, Object... o) {\n        if (fileIOMode) {\n            System.out.printf(s, o);\n        }\n        out.printf(s, o);\n    }\n}\n", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "\nimport java.util.*;\nimport java.io.*;  \npublic class Main \n{\n    PrintWriter out;\n    FastReader sc;\n    long[] m1= {(long)(1e9+7),998244353};\n    long mod=m1[1];\n    long maxlong=Long.MAX_VALUE;\n    long minlong=Long.MIN_VALUE;\n    StringBuilder sb;\n    /******************************************************************************************\n     *****************************************************************************************/\n\tpublic void sol(){\n\t\tint n=ni(),m=ni();\n\t\tlong ans=0;\n\t\tlong[] a=new long[n],b=new long[m];\n\t\tPriorityQueue<Long> q=new PriorityQueue<>(Collections.reverseOrder());\n\t\tHashMap<Long,Long> map=new HashMap<>();\n\t\tlong min=Integer.MIN_VALUE,max=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i]=ni();\n\t\t\tans+=(m*a[i]);\n\t\t\tmin=max(min,a[i]);\n\t\t}for(int i=0;i<m;i++) {\n\t\t\tb[i]=ni();\n\t\t\tmax=min(max,b[i]);\n\t\t\tq.add(b[i]);\n\t\t}if(min>max) {\n\t\t\tpl(\"-1\");return;\n\t\t}\n\t\tsort1(a);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(q.size()>0&&a[i]<=q.peek()) {\n\t\t\t\tint x=0;\n\t\t\t\twhile(x<m-1&&q.size()>0&&q.peek()>=a[i]) {\n\t\t\t\t\tlong z=q.poll();\n\t\t\t\t\tif(map.get(z)!=null&&map.get(z)>0) {\n\t\t\t\t\t\tmap.put(z,map.get(z)-1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans-=a[i];\n\t\t\t\t\tans+=z;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}map.put(a[i],map.getOrDefault(a[i],0l)+1);\n\t\t}if(q.size()>0) {\n\t\t\tpl(\"-1\");\n\t\t}else\n\t\t    pl(ans);\n\t}\n    public static void main(String[] args) \n\t{ \n\t    Main g=new Main();\n\t\tg.out=new PrintWriter(System.out);\n\t\tg.sc=new FastReader();\n\t\tint t=1;\n// \t\tt=g.ni();\n\t\twhile(t-->0)\n\t\tg.sol();\n\t\tg.out.flush();\n\t}\n\t\n\t/****************************************************************************************\n     *****************************************************************************************/\n\tstatic class FastReader \n\t{ \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n \n\t\tpublic FastReader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n \n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n \n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n \n\t\tlong nextLong() \n\t\t{ \n\t\t\treturn Long.parseLong(next()); \n\t\t} \n \n\t\tdouble nextDouble() \n\t\t{ \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n \n\t\tString nextLine() \n\t\t{ \n\t\t\tString str = \"\"; \n\t\t\ttry\n\t\t\t{ \n\t\t\t\tstr = br.readLine(); \n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{ \n\t\t\t\te.printStackTrace(); \n\t\t\t} \n\t\t\treturn str; \n\t\t} \n\t} public int ni(){\n\t      return sc.nextInt();\n\t}public long nl(){\n\t      return sc.nextLong();\n\t}public double nd(){\n\t      return sc.nextDouble();\n\t}public char[] rl(){\n\t      return sc.nextLine().toCharArray();\n\t}public String rl1(){\n\t      return sc.nextLine();\n\t}\n\tpublic void pl(Object s){\n\t      out.println(s);\n\t}public void ex(){\n\t      out.println();\n\t}\n\tpublic void pr(Object s){\n\t      out.print(s);\n\t}public String next(){\n\t      return sc.next();\n\t}public long abs(long x){\n\t      return Math.abs(x);\n\t}\n\tpublic int abs(int x){\n\t      return Math.abs(x);\n\t}\n\tpublic double abs(double x){\n\t      return Math.abs(x);\n\t}public long min(long x,long y){\n            return (long)Math.min(x,y);\n      }\n      public int min(int x,int y){\n            return (int)Math.min(x,y);\n      }\n      public double min(double x,double y){\n            return Math.min(x,y);\n      }public long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}public long lcm(long a, long b) {\n            return (a / gcd(a, b)) * b;\n      }\n       void sort1(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l,Collections.reverseOrder());\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}\n\t void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}void sort(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}void sort1(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l,Collections.reverseOrder());\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}\n\tvoid sort(double[] a) {\n\t\tArrayList<Double> l = new ArrayList<>();\n\t\tfor (double i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}long pow(long a,long b){\n          if(b==0){\n                return 1;\n          }long p=pow(a,b/2);\n          if(b%2==0) return (p*p)%mod;\n          else return (((p*p)%mod)*a)%mod;\n    }\n\t\n\tint  swap(int a,int b){\n\t      return a;\n\t}long  swap(long a,long b){\n\t      return a;\n\t}double  swap(double a,double b){\n\t      return a;\n\t}\n\tboolean isPowerOfTwo (int x) \n      { \n            return x!=0 && ((x&(x-1)) == 0);     \n      }boolean isPowerOfTwo (long x) \n      { \n            return x!=0 && ((x&(x-1)) == 0);     \n      }public long max(long x,long y){\n            return (long)Math.max(x,y);\n      }\n      public int max(int x,int y){\n            return (int)Math.max(x,y);\n      }\n      public double max(double x,double y){\n            return Math.max(x,y);\n      }long sqrt(long x){\n            return (long)Math.sqrt(x);\n      }int sqrt(int x){\n            return (int)Math.sqrt(x);\n      }void input(int[] ar,int n){\n            for(int i=0;i<n;i++)ar[i]=ni();\n      }void input(long[] ar,int n){\n            for(int i=0;i<n;i++)ar[i]=nl();\n      }void fill(int[] ar,int k){\n            Arrays.fill(ar,k);\n      }void yes(){\n            pl(\"YES\");\n      }void no(){\n            pl(\"NO\");\n      }\n      long c2(long n) {\n    \t  return (n*(n-1))/2;\n      }\n    long[] sieve(int n) \n    {\n          long[] k=new long[n+1];\n          boolean[] pr=new boolean[n+1];\n          for(int i=1;i<=n;i++){\n                k[i]=i;\n                pr[i]=true;\n          }for(int i=2;i<=n;i++){\n                if(pr[i]){\n                      for(int j=i+i;j<=n;j+=i){\n                            pr[j]=false;\n                            if(k[j]==j){\n                                  k[j]=i;\n                            }\n                      }\n                }\n          }return k;\n    }\n    int strSmall(int[] arr, int target)  \n    {  \n        int start = 0, end = arr.length-1;  \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;   \n            if (arr[mid] >= target) {  \n                end = mid - 1;  \n            }   \n            else {  \n                ans = mid;  \n                start = mid + 1;  \n            }  \n        }  \n        return ans;  \n    } int strSmall(ArrayList<Integer> arr, int target)  \n    {  \n        int start = 0, end = arr.size()-1;  \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;   \n            if (arr.get(mid) > target) {  \n                start = mid + 1; \n                ans=start;\n            }   \n            else {\n                end = mid - 1;  \n            }  \n        }  \n        return ans;  \n    }long mMultiplication(long a,long b) \n    { \n        long res = 0;    \n        a %= mod; \n  \n        while (b > 0)  \n        {  \n            if ((b & 1) > 0)  \n            { \n                res = (res + a) % mod; \n            }  \n            a = (2 * a) % mod; \n  \n            b >>= 1;  \n        } \n        return res; \n    }long nCr(int n, int r ,int p)\n    {\n \n          if (n<r) \n              return 0;\n        if (r == 0)\n            return 1;\n            long[] fac = new long[n + 1];\n        fac[0] = 1;\n \n        for (int i = 1; i <= n; i++)\n            fac[i] = fac[i - 1] * i %p;\n        return (fac[n] * modInverse(fac[r], p)\n                % p * modInverse(fac[n - r], p)\n                % p)\n            % p;\n    }long power(long x, long y, long p)\n    {\n        long res = 1;\n        x = x % p;\n \n        while (y > 0) {\n            if (y % 2 == 1)\n                res = (res * x) % p;\n            y = y >> 1; \n            x = (x * x) % p;\n        }\n \n        return res;\n    }long modInverse(long n, long p)\n    {\n        return power(n, p - 2, p);\n    }\n    \n    int[][] floydWarshall(int graph[][],int INF,int V)\n    {\n        int dist[][] = new int[V][V];\n        int i, j, k;\n        for (i = 0; i < V; i++)\n            for (j = 0; j < V; j++)\n                dist[i][j] = graph[i][j];\n        for (k = 0; k < V; k++)\n        {\n            for (i = 0; i < V; i++)\n            {\n                for (j = 0; j < V; j++)\n                {\n                    if (dist[i][k] + dist[k][j] < dist[i][j])\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }return dist;\n    }\n    class minque {\n\t\tDeque<Long> q;\n\t\tminque(){\n\t\t\tq=new ArrayDeque<Long>();\n\t\t}public void add(long p){\n\t\t\twhile(!q.isEmpty()&&q.peekLast()>p)q.pollLast();\n\t\t\tq.addLast(p);\n\t\t}public void remove(long p) {\n\t\t\tif(!q.isEmpty()&&q.getFirst()==p)q.removeFirst();\n\t\t}public long min() {\n\t\t\treturn q.getFirst();\n\t\t}\n\t}\n      public static class Pair implements Comparable<Pair> {\n\t\tlong x;\n\t\tlong y;\n \n\t\tpublic Pair(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic int compareTo(Pair other) {\n\t\t\tif (this.x == other.x) {\n\t\t\t\treturn Long.compare(this.y, other.y);\n\t\t\t}\n\t\t\treturn Long.compare(this.x, other.x);\n\t\t}\n      }int find(subset[] subsets, int i)\n      {\n          if (subsets[i].parent != i)\n              subsets[i].parent\n                  = find(subsets, subsets[i].parent);\n          return subsets[i].parent;\n      }void Union(subset[] subsets, int x, int y)\n      {\n          int xroot = find(subsets, x);\n          int yroot = find(subsets, y);\n   \n          if (subsets[xroot].rank < subsets[yroot].rank) {\n          \tsubsets[xroot].parent = yroot;\n          }\n          else if (subsets[yroot].rank < subsets[xroot].rank) {\n          \tsubsets[yroot].parent = xroot;\n          }\n          else {\n              subsets[xroot].parent = yroot;\n              subsets[yroot].rank++;\n          }\n      }class subset\n      {\n          int parent;\n          int rank;\n      }\n\t \n} ", "complexity": "linear", "problem": "1159_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.Scanner;\n\n\n\npublic class LittleGirlAndMaximumXOR {\n\n\n\n    char[] low;\n\n    char[] high;\n\n    long[][][] dp;\n\n\n\n    public int getStart(int i, int m) {\n\n        return (m & 1) == 1 ? 0 : low[i];\n\n    }\n\n\n\n    public int getEnd(int i, int m) {\n\n        return (m & 2) == 2 ? 1 : high[i];\n\n    }\n\n\n\n    public long f(int i, int m1, int m2) {\n\n        if (i == high.length)\n\n            return 0;\n\n        if (dp[i][m1][m2] != -1)\n\n            return dp[i][m1][m2];\n\n        long ret = 0;\n\n        for (int a = getStart(i, m1); a <= getEnd(i, m1); a++)\n\n            for (int b = getStart(i, m2); b <= getEnd(i, m2); b++)\n\n                ret = Math.max(\n\n                        ret,\n\n                        (a ^ b)\n\n                                * (1L << (high.length - i - 1))\n\n                                + f(i + 1, m1 | (a > low[i] ? 1 : 0)\n\n                                        | (a < high[i] ? 2 : 0), m2\n\n                                        | (b > low[i] ? 1 : 0)\n\n                                        | (b < high[i] ? 2 : 0)));\n\n        return dp[i][m1][m2] = ret;\n\n    }\n\n\n\n    public void run() {\n\n        Scanner in = new Scanner(System.in);\n\n        long l = in.nextLong();\n\n        long h = in.nextLong();\n\n        String sl = Long.toBinaryString(l);\n\n        String sh = Long.toBinaryString(h);\n\n        while (sl.length() < sh.length())\n\n            sl = \"0\" + sl;\n\n        low = sl.toCharArray();\n\n        high = sh.toCharArray();\n\n        for (int i = 0; i < low.length; i++) {\n\n            low[i] -= '0';\n\n            high[i] -= '0';\n\n        }\n\n        dp = new long[64][4][4];\n\n        for (int i = 0; i < 64; i++) \n\n            for(int j = 0;j<4;j++)for(int k=0;k<4;k++)dp[i][j][k]=-1;\n\n        System.out.println(f(0, 0, 0));\n\n    }\n\n\n\n    public static void main(String[] args) {\n\n        (new LittleGirlAndMaximumXOR()).run();\n\n    }\n\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.util.*;\n\npublic class Main\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint cases = sc.nextInt();\n\n\t\tfor(int i = 0; i < cases; i++)\n\t\t{\n\t\t\tString test = sc.next();\n\t\t\tif(test.matches(\"R[0-9]+C[0-9]+\"))\n\t\t\t{\n\t\t\t\t//String[] nums = new String[test.length()];\n\t\t\t\tString[] nums = test.split(\"R|C\");\n\t\t\t\t//System.out.println(Arrays.toString(nums));\n\t\t\t\tint x = Integer.parseInt(nums[2]);\n\n\t\t\t\tString column = \"\";\n\t\t\t\twhile(x != 0)\n\t\t\t\t{\n\t\t\t\t\tif(x%26==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcolumn = 'Z' + column;\n\t\t\t\t\t\tx -= 26;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcolumn = (char)('A' - 1 + x%26) + column;\n\t\t\t\t\t}\n\t\t\t\t\tx/=26;\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tSystem.out.println(column+nums[1]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tString letters = test.replaceAll(\"[0-9]\", \"\");\n\t\t\t\tString numbers = test.replaceAll(\"[A-Z]\", \"\");\n\t\t\t\t\n\t\t\t\tint base=1;\n\t\t\t\tint t=0;\n\t\t\t\tfor(int j=letters.length()-1;j>=0;j--)\n\t\t\t\t{\n\t\t\t\t\tt+=base*(letters.charAt(j)-'A'+1);\n\t\t\t\t\tbase*=26;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"R\" + numbers + \"C\" + t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n2\nR23C55\nBC23\n*/", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.Scanner;\npublic class LCM {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong n=sc.nextLong();\n\t\tif(n < 3) {\n\t\t\tSystem.out.println(n);\n\t\t}\n\t\telse if(n % 2 != 0) {\n\t\t\tSystem.out.println(n * (n-1) * (n-2));\n\t\t}\n\t\telse if(n % 3 == 0) {\n\t\t\tSystem.out.println((n-1) * (n-2) * (n-3));\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(n * (n-1) * (n-3));\n\t\t}\n\t}\n}\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class C {\n\tstatic double ycoord(double xi, double yi, double xj, double r) {\n\t\tif(Math.abs(xi-xj) > 2*r) return r;\n\t\tdouble dist = Math.sqrt((4*r*r)-((xi-xj)*(xi-xj)));\n\t\t//System.out.println(\"dist\" + dist);\n\t\treturn Math.max(yi+dist, r); //yi - dist?\n\t}\n\tpublic static void main(String[] args) throws Exception {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tdouble r = sc.nextInt();\n\t\tdouble[] xcoords = new double[n];\n\t\tdouble[] ycoords = new double[n];\n\t\tArrays.fill(ycoords, Integer.MIN_VALUE);\n\t\tycoords[0] = r;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\txcoords[i] = sc.nextDouble();\n\t\t}\n\t\tSystem.out.print(r + \" \");\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\tycoords[i] = Math.max(ycoord(xcoords[j], ycoords[j],xcoords[i],r),ycoords[i]);\n\t\t\t}\n\t\t\tSystem.out.print(ycoords[i] + \" \");\n\t\t}\n\t\tout.flush();\n\t}\n\n\tstatic class FastScanner {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic FastScanner() {\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\n\t}\n}", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\twhile (n-- > 0) {\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint k = 0;\n\t\t\twhile (a != 0 && b != 0) {\n\t\t\t\tif (a > b) {\n\t\t\t\t\tint t = a / b;\n\t\t\t\t\tk += t;\n\t\t\t\t\ta = a - b * t;\n\t\t\t\t} else {\n\t\t\t\t\tint t = b / a;\n\t\t\t\t\tk += t;\n\t\t\t\t\tb = b - a * t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(k);\n\t\t}\n\n\t}\n\n}\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class B {\n\tpublic void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tint[] num = new int[n];\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tint s = -1;\n\t\tint l = -1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tset.add(a[i]);\n\t\t\tnum[i] = set.size();\n\t\t\tif( num[i] == k ){\n\t\t\t\tl = i+1;\n\t\t\t\tset = new HashSet<Integer>();\n\t\t\t\tfor(int j = i; j >= 0; j--){\n\t\t\t\t\tset.add(a[j]);\n\t\t\t\t\tif( set.size() == k ){\n\t\t\t\t\t\ts = j+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twriter.println(s + \" \" + l);\n \t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew B().run();\n\t}\n\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\n\tpublic void run() throws IOException {\n\t\ttry {\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n}\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class A {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        br.readLine();\n        String[] ss = br.readLine().split(\" \");\n        int n = ss.length;\n        int[] a = new int[n];\n        for (int i = 0; i < n; ++i)\n            a[i] = Integer.parseInt(ss[i]);\n        for (int i = 0; i < n; ++i) {\n            boolean ok = true;\n            for (int j = 0; j < n; ++j)\n                if (j != i && a[j] % 2 == a[i] % 2)\n                    ok = false;\n            if (ok)\n                System.out.println(i + 1);\n        }\n    }\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class A {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tBigInteger l = sc.nextBigInteger();\n\t\tBigInteger r = sc.nextBigInteger();\n\t\tBigInteger a = l.add(BigInteger.ZERO);\n\t\twhile (a.compareTo(r) < 0) {\n\t\t\tBigInteger b = a.add(BigInteger.ONE);\n\t\t\twhile (b.compareTo(r) < 0) {\n\t\t\t\ttry {\n\t\t\t\t\ta.modInverse(b);\n\t\t\t\t} catch (ArithmeticException e) {\n\t\t\t\t\tb = b.add(BigInteger.ONE);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tBigInteger c = b.add(BigInteger.ONE);\n\t\t\t\twhile (c.compareTo(r) <= 0) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tb.modInverse(c);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ta.modInverse(c);\n\t\t\t\t\t\t} catch (ArithmeticException e) {\n\t\t\t\t\t\t\tSystem.out.printf(\"%s %s %s\\n\", a.toString(), b.toString(), c.toString());\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (ArithmeticException e) {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tc = c.add(BigInteger.ONE);\n\t\t\t\t}\n\t\t\t\tb = b.add(BigInteger.ONE);\n\t\t\t}\n\t\t\ta = a.add(BigInteger.ONE);\n\t\t}\n\t\tSystem.out.println(\"-1\");\n\t}\n}\n\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.*;\n\npublic class D7182 {\n    public static void main(String[] args) throws IOException {\n        init_io();\n        int N = nint(), M = nint(), K = nint();\n        if (K % 2 == 0) {\n            int[][][] grid = new int[K+1][N][M];\n            int[][][] edges = new int[4][N][M];\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < M-1; j++) {\n                    edges[0][i][j] = edges[2][i][j+1] = nint();\n                }\n            }\n            for (int i = 0; i < N-1; i++) {\n                for (int j = 0; j < M; j++) {\n                    edges[1][i][j] = edges[3][i+1][j] = nint();\n                }\n            }\n            for (int k = 1; k <= K/2; k++) {\n                for (int i = 0; i < N; i++) {\n                    for (int j = 0; j < M; j++) {\n                        int min = Integer.MAX_VALUE;\n                        if (i != N-1) {\n                            min = Math.min(min, grid[k-1][i+1][j] + edges[1][i][j]);\n                        }\n                        if (j != M-1) {\n                            min = Math.min(min, grid[k-1][i][j+1] + edges[0][i][j]);\n                        }\n                        if (i != 0) {\n                            min = Math.min(min, grid[k-1][i-1][j] + edges[3][i][j]);\n                        }\n                        if (j != 0) {\n                            min = Math.min(min, grid[k-1][i][j-1] + edges[2][i][j]);\n                        }\n                        grid[k][i][j] = min;\n                    }\n                }\n            }\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < M; j++) {\n                    out.print(grid[K/2][i][j]*2 + \" \");\n                }\n                out.println();\n            }\n        }\n        else {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < M; j++) {\n                    out.print(-1 + \" \");\n                }\n                out.println();\n            }\n        }\n        out.close();\n    }\n\n    static StreamTokenizer in;\n    static PrintWriter out;\n    static BufferedReader br;\n\n    static int nint() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    static void init_io() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        in = new StreamTokenizer(br);\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class a1 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint a[] = new int[n];\n\t\tHashMap<Integer,ArrayList<Integer>> h = new HashMap<>();\n\t\tboolean visited[] = new boolean[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\ta[i] = s.nextInt();\n\t\t\t\n\t\t\t\n\t\t}\n\t\tArrays.sort(a);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(h.containsKey(a[i])) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tArrayList<Integer> temp = h.get(a[i]);\n\t\t\t\t\t\t\ttemp.add(i);\n\t\t\t\t\t\t\th.put(a[i],temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tArrayList<Integer> k =new ArrayList<>();\n\t\t\t\t\t\t\tk.add(i);\n\t\t\t\t\t\t\th.put(a[i], k);\n\t\t\t\t\t\t}\n\t\t}\n\t\tint ctr=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\t//System.out.println(a[i]);\n\t\t\t\tctr++;\n\t\t\t\tfor(int j=a[i];j<=100;j+=a[i]) {\n\t\t\t\t\tif(h.containsKey(j)) {\n\t\t\t\t\t\tArrayList<Integer> m = h.get(j);\n\t\t\t\t\t\tfor(int k=0;k<m.size();k++) {\n\t\t\t\t\t\t\tvisited[m.get(k)]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\th.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ctr);\n\t}\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class a1113 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] strings = reader.readLine().split(\" \");\n        int lastCity = Integer.parseInt(strings[0]);\n        int tankSize = Integer.parseInt(strings[1]);\n        int money = 0, oil = 0;\n\n        for (int currentCity = 1; currentCity < lastCity; ) {\n            if (lastCity - currentCity <= oil) {\n                break;\n            } else {\n                int needOil = tankSize > lastCity - currentCity ? lastCity - currentCity - oil : tankSize - oil;\n                money += needOil * currentCity;\n                oil += needOil;\n                currentCity++;\n                oil--;\n            }\n        }\n        System.out.println(money);\n        reader.close();\n    }\n}\n", "complexity": "constant", "problem": "1113_A", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "import java.util.*;\npublic class x\n{\n    public static void main(String args[])\n    {\n        Scanner obj=new Scanner(System.in);\n        int n;\n        String d=\"0\";\n        n=obj.nextInt();\n        if(n%4==0 || n%7==0 || n%47==0 || n%74==0 || n%447==0 || n%474==0 || n%747==0)\n        d=\"YES\";\n        else if(n%444==0 || n%477==0 || n%744==0 || n%774==0 || n%777==0)\n        d=\"YES\";\n        else\n        d=\"NO\";\n        System.out.print(d);\n    }\n}", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "//package round8;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class C {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint x = ni(), y = ni();\n\t\tint n = ni();\n\t\tint[][] co = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tco[i] = new int[]{ni()-x, ni()-y};\n\t\t}\n\t\t\n\t\tint[] c1 = new int[n];\n\t\tint[][] c2 = new int[n][n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tc1[i] = (co[i][0]*co[i][0]+co[i][1]*co[i][1])*2;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\tc2[i][j] = c2[j][i] = (co[i][0]*co[i][0]+co[i][1]*co[i][1])+(co[j][0]*co[j][0]+co[j][1]*co[j][1])+(co[j][0]-co[i][0])*(co[j][0]-co[i][0])+(co[j][1]-co[i][1])*(co[j][1]-co[i][1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] dp = new int[1<<n];\n\t\tint[] prev = new int[1<<n];\n\t\tprev[0] = -1;\n\t\tfor(int i = 1;i < 1<<n;i++){\n\t\t\tint a = Integer.numberOfTrailingZeros(i);\n\t\t\tdp[i] = c1[a] + dp[i^1<<a];\n\t\t\tprev[i] = 1<<a;\n\t\t\tfor(int j = a+1;j < n;j++){\n\t\t\t\tif(i<<31-j<0){\n\t\t\t\t\tint v = dp[i^1<<a^1<<j] + c2[a][j];\n\t\t\t\t\tif(v < dp[i]){\n\t\t\t\t\t\tdp[i] = v;\n\t\t\t\t\t\tprev[i] = 1<<a^1<<j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(dp[(1<<n)-1]);\n\t\tint cur = (1<<n)-1;\n\t\tout.print(\"0\");\n\t\twhile(true){\n\t\t\tint targ;\n\t\t\tif(prev[cur] == -1){\n\t\t\t\ttarg = cur;\n\t\t\t}else{\n\t\t\t\ttarg = prev[cur];\n\t\t\t\tcur ^= prev[cur];\n\t\t\t}\n\t\t\tint a = Integer.numberOfTrailingZeros(targ);\n\t\t\tint b = Integer.numberOfTrailingZeros(targ&targ-1);\n\t\t\tif(targ == 1<<a){\n\t\t\t\tout.print(\" \" + (a+1));\n\t\t\t}else{\n\t\t\t\tout.print(\" \" + (a+1));\n\t\t\t\tout.print(\" \" + (b+1));\n\t\t\t}\n\t\t\tout.print(\" 0\");\n\t\t\tif(cur == 0)break;\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n//\t\tint n = 24, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(0 + \" \" + 0  + \" \" + n + \" \");\n//\t\tfor(int i = 0;i < n;i++){\n//\t\t\tsb.append(gen.nextInt(100) + \" \");\n//\t\t\tsb.append(gen.nextInt(100) + \" \");\n//\t\t}\n//\t\tINPUT = sb.toString();\n\t\t\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew C().run();\n\t}\n\t\n\tpublic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = 0;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile((b = is.read()) != -1 && (b == '\\r' || b == '\\n' || b == ' '));\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b == '\\r' || b == '\\n' || b == ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\tpublic char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = 0, p = 0;\n\t\t\twhile((b = is.read()) != -1 && (b == ' ' || b == '\\r' || b == '\\n'));\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b == ' ' || b == '\\r' || b == '\\n')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\n\tdouble nd() { return Double.parseDouble(ns()); }\n\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tvoid tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.util.*;\n\n\npublic class Main{\n    \n    public static void main(String[] args){\n        Scanner in = new Scanner(System.in);\n        int[] a=new int[1010];\n        while(in.hasNext()){\n            int n=in.nextInt();\n            String s=in.next();\n            int sum=0;\n            for(int i=0;i<n;++i){\n                if(s.charAt(i)=='H'){\n                    a[i]=1;\n                    ++sum;\n                }\n                else a[i]=0;\n            }\n            int min=10010;\n            for(int i=0;i<n-sum;++i){\n                int count=0;\n                for(int j=i+sum;j<n;++j){\n                    if(a[j]==1)++count;\n                }\n                for(int j=0;j<i;++j){\n                    if(a[j]==1)++count;\n                }\n                if(count<min)min=count;\n            }\n            sum=n-sum;\n            for(int i=0;i<n-sum;++i){\n                int count=0;\n                for(int j=i+sum;j<n;++j){\n                    if(a[j]==0)++count;\n                }\n                for(int j=0;j<i;++j){\n                    if(a[j]==0)++count;\n                }\n                if(count<min)min=count;\n            }\n            System.out.println(min);\n        }\n    }\n}\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class DigitSeq {\n\n\tstatic class FastReader { \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n\n\t\tpublic FastReader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n\n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException  e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n\n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n\n\t\tlong nextLong() \n\t\t{ \n\t\t\treturn Long.parseLong(next()); \n\t\t} \n\n\t\tdouble nextDouble() \n\t\t{ \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n\n\t\tString nextLine() \n\t\t{ \n\t\t\tString str = \"\"; \n\t\t\ttry\n\t\t\t{ \n\t\t\t\tstr = br.readLine(); \n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{ \n\t\t\t\te.printStackTrace(); \n\t\t\t} \n\t\t\treturn str; \n\t\t} \n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tFastReader sc = new FastReader();\n\t\tOutputStream outputstream = System.out;\n\t\tPrintWriter out = new PrintWriter(outputstream);\n\n\t\tlong n = sc.nextLong();\n\t\tlong[] arr = new long[14];\n\t\tfor(int i = 1; i <= 13; i++){\n\t\t\tarr[i] = (long)Math.pow(10, i)-(long)Math.pow(10, i-1);\n\t\t}\n\t\tlong total = 0;\n\t\tfor(int i = 1; i <= 13; i++){\n\t\t\tif(total+(long)i*arr[i]>=n){\n\t\t\t\tlong ans = n-total;\n\t\t\t\tlong rest = ans;\n\t\t\t\tif(ans%i!=0){\n\t\t\t\t\tans /= i;\n\t\t\t\t\tans++;\n\t\t\t\t} else {\n\t\t\t\t\tans /= i;\n\t\t\t\t}\n\t\t\t\tans += (long)Math.pow(10, i-1)-1;\n\t\t\t\tString str = Long.toString(ans);\n\t\t\t\tint ind = (rest%i==0) ? i-1 : (int)(rest%i)-1;\n\t\t\t\tout.println(str.charAt(ind));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttotal = total+(long)i*arr[i];\n\t\t}\n\t\tout.close();\n\t}\n\n}", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "//package contests.c913;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class C913E implements Runnable {\n\n    private void solve() throws Exception {\n        String[][] m = new String[256][3];\n        m[0b00001111][0] = \"x\";\n        m[0b00110011][0] = \"y\";\n        m[0b01010101][0] = \"z\";\n\n        boolean changed;\n        String s;\n        int r;\n        int tt = 0;\n        do {\n            tt++;\n            changed = false;\n\n            for (int i = 0; i < 256; i++) {\n                for (int j = 0; j < 3; j++) {\n                    if (m[i][j] == null) continue;\n\n                    if (j > 0) {\n                        s = \"(\" + m[i][j] + \")\";\n                        if (shouldReplace(m[i][0], s)) {\n                            m[i][0] = s;\n                            changed = true;\n                        }\n                    }\n\n                    if (j == 0) {\n                        r = (~i) & 0b11111111;\n                        s = \"!\" + m[i][j];\n                        if (shouldReplace(m[r][0], s)) {\n                            m[r][0] = s;\n                            changed = true;\n                        }\n                    }\n\n                    for (int x = 0; x < 256; x++) {\n                        for (int y = 0; y < 3; y++) {\n                            if (m[x][y] == null) continue;\n\n                            if (j < 2 && y < 2) {\n                                r = i & x;\n                                s = m[i][j] + \"&\" + m[x][y];\n                                if (shouldReplace(m[r][1], s)) {\n                                    m[r][1] = s;\n                                    changed = true;\n                                }\n                            }\n\n                            r = i | x;\n                            s = m[i][j] + \"|\" + m[x][y];\n                            if (shouldReplace(m[r][2], s)) {\n                                m[r][2] = s;\n                                changed = true;\n                            }\n                        }\n                    }\n                }\n            }\n\n        } while (changed);\n\n        int n = i();\n        for (int i = 0; i < n; i++) {\n            int a = Integer.parseInt(s(), 2);\n            System.out.println(get(m, a));\n        }\n    }\n\n    boolean shouldReplace(String current, String candidate) {\n        return current == null ||\n                current.length() > candidate.length() ||\n                current.length() == candidate.length() && current.compareTo(candidate) > 0;\n    }\n\n    String get(String[][] m, int n) {\n        String s = m[n][0];\n        if (shouldReplace(s, m[n][1])) s = m[n][1];\n        if (shouldReplace(s, m[n][2])) s = m[n][2];\n        return s;\n    }\n\n    public void run() {\n        long start = System.currentTimeMillis();\n\n        try {\n            solve();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            out.close();\n        }\n\n        if (!isOj)\n            System.out.println(System.currentTimeMillis() - start + \"ms\");\n    }\n\n    public static void main(String[] args) throws Exception {\n        new C913E().run();\n    }\n\n    InputStream inputStream;\n    FastWriter out;\n\n    private C913E() {\n        this(System.in, System.out);\n    }\n\n    public C913E(InputStream inputStream, OutputStream outputStream) {\n        this.inputStream = inputStream;\n        this.out = new FastWriter(outputStream);\n    }\n\n    //@formatter:off\n    private final byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = inputStream.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n        return b;\n    }\n\n    private char c() { return (char) skip(); }\n    private char[] ca(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    private char[][] caa(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ca(m);\n        return map;\n    }\n\n    private int i() { return (int) l(); }\n    private int[] ia(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = i();\n        return a;\n    }\n    private int[][] iaa(int n, int m) {\n        int[][] map = new int[n][];\n        for (int i = 0; i < n; i++) map[i] = ia(m);\n        return map;\n    }\n    private int[][] iaaT(int n, int m) {\n        int[][] map = new int[m][];\n        for (int i = 0; i < m; i++) map[i] = new int[n];\n        for (int i = 0; i < n; i++) {\n            int[] t = ia(m);\n            for (int j = 0; j < m; j++) map[j][i] = t[j];\n        }\n        return map;\n    }\n\n    private long l() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    private long[] la(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = l();\n        return a;\n    }\n\n    private double d() { return Double.parseDouble(s()); }\n\n    private String s() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    //@formatter:on\n\n    public static class FastWriter {\n        private static final int BUF_SIZE = 1 << 13;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private final OutputStream out;\n        private int ptr = 0;\n        private boolean isFirst = true;\n\n        public FastWriter(OutputStream os) {\n            this.out = os;\n        }\n\n        private FastWriter write(byte b) {\n            buf[ptr++] = b;\n            if (ptr == BUF_SIZE)\n                innerflush();\n            return this;\n        }\n\n        private FastWriter write(char c) {\n            return write((byte) c);\n        }\n\n        private FastWriter write(char[] s) {\n            for (char c : s) {\n                buf[ptr++] = (byte) c;\n                if (ptr == BUF_SIZE) innerflush();\n            }\n            return this;\n        }\n\n        private FastWriter write(String s) {\n            s.chars().forEach(c -> {\n                buf[ptr++] = (byte) c;\n                if (ptr == BUF_SIZE) innerflush();\n            });\n            return this;\n        }\n\n        public static int countDigits(int l) {\n            if (l >= 1000000000) return 10;\n            if (l >= 100000000) return 9;\n            if (l >= 10000000) return 8;\n            if (l >= 1000000) return 7;\n            if (l >= 100000) return 6;\n            if (l >= 10000) return 5;\n            if (l >= 1000) return 4;\n            if (l >= 100) return 3;\n            if (l >= 10) return 2;\n            return 1;\n        }\n\n        private FastWriter write(int x) {\n            if (x == Integer.MIN_VALUE) {\n                return write((long) x);\n            }\n            if (ptr + 12 >= BUF_SIZE) innerflush();\n            if (x < 0) {\n                write((byte) '-');\n                x = -x;\n            }\n            int d = countDigits(x);\n            for (int i = ptr + d - 1; i >= ptr; i--) {\n                buf[i] = (byte) ('0' + x % 10);\n                x /= 10;\n            }\n            ptr += d;\n            return this;\n        }\n\n        public static int countDigits(long l) {\n            if (l >= 1000000000000000000L) return 19;\n            if (l >= 100000000000000000L) return 18;\n            if (l >= 10000000000000000L) return 17;\n            if (l >= 1000000000000000L) return 16;\n            if (l >= 100000000000000L) return 15;\n            if (l >= 10000000000000L) return 14;\n            if (l >= 1000000000000L) return 13;\n            if (l >= 100000000000L) return 12;\n            if (l >= 10000000000L) return 11;\n            if (l >= 1000000000L) return 10;\n            if (l >= 100000000L) return 9;\n            if (l >= 10000000L) return 8;\n            if (l >= 1000000L) return 7;\n            if (l >= 100000L) return 6;\n            if (l >= 10000L) return 5;\n            if (l >= 1000L) return 4;\n            if (l >= 100L) return 3;\n            if (l >= 10L) return 2;\n            return 1;\n        }\n\n        private FastWriter write(long x) {\n            if (x == Long.MIN_VALUE) {\n                return write(\"\" + x);\n            }\n            if (ptr + 21 >= BUF_SIZE) innerflush();\n            if (x < 0) {\n                write((byte) '-');\n                x = -x;\n            }\n            int d = countDigits(x);\n            for (int i = ptr + d - 1; i >= ptr; i--) {\n                buf[i] = (byte) ('0' + x % 10);\n                x /= 10;\n            }\n            ptr += d;\n            return this;\n        }\n\n        private FastWriter write(double x, int precision) {\n            if (x < 0) {\n                write('-');\n                x = -x;\n            }\n            x += Math.pow(10, -precision) / 2;\n            //\t\tif(x < 0){ x = 0; }\n            write((long) x).write(\".\");\n            x -= (long) x;\n            for (int i = 0; i < precision; i++) {\n                x *= 10;\n                write((char) ('0' + (int) x));\n                x -= (int) x;\n            }\n            return this;\n        }\n\n        public FastWriter writeDelimeter() {\n            if (isFirst) {\n                isFirst = false;\n            } else {\n                write(' ');\n            }\n            return this;\n        }\n\n        public FastWriter writeNewline() {\n            write('\\n');\n            isFirst = true;\n            return this;\n        }\n\n        private void innerflush() {\n            try {\n                out.write(buf, 0, ptr);\n                ptr = 0;\n            } catch (IOException e) {\n                throw new RuntimeException(\"innerflush\");\n            }\n        }\n\n        public void flush() {\n            innerflush();\n            try {\n                out.flush();\n            } catch (IOException e) {\n                throw new RuntimeException(\"flush\");\n            }\n        }\n\n        public void close() {\n            writeNewline();\n            flush();\n        }\n    }\n\n    //@formatter:off\n    private void w(int x) { out.writeDelimeter().write(x); }\n    private void w(long x) { out.writeDelimeter().write(x); }\n    private void w(double x) { out.writeDelimeter().write(x, 16); }\n    private void lnw(int x) { out.writeNewline().write(x); }\n    private void lnw(long x) { out.writeNewline().write(x); }\n\n    private static int log(int a) {\n        if (a <= 0) throw new RuntimeException(\"log(a): a <= 0\");\n        return Integer.SIZE - 1 - Integer.numberOfLeadingZeros(a);\n    }\n    private static int log(long a) {\n        if(a <= 0) throw new RuntimeException(\"log(a): a <= 0\");\n        return Long.SIZE - 1 - Long.numberOfLeadingZeros(a);\n    }\n    private static int max(int a, int b) {return Math.max(a, b);}\n    private static long max(long a, long b) {return Math.max(a, b);}\n    private static int min(int a, int b) {return Math.min(a, b);}\n    private static int min(int a, int b, int c) {return min(a, min(b, c));}\n    private static int min(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    private static long min(long a, long b) {return Math.min(a, b);}\n    private static long min(long a, long b, long c) {return min(a, min(b, c));}\n    private static long min(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    private static int pow(int a, int b) {if (a == 0) return 0; int r = 1; while (b > 0) {if ((b & 1) > 0) r *= a; a *= a; b >>= 1;} return r;}\n    private static long pow(long a, int b) {if (a == 0) return 0; long r = 1; while (b > 0) {if ((b & 1) > 0) r *= a; a *= a; b >>= 1;} return r;}\n    //@formatter:on\n\n    private final boolean isOj = System.getProperty(\"ONLINE_JUDGE\") != null;\n}\n", "complexity": "quadratic", "problem": "0913_E", "from": "CODEFORCES", "tags": "bitmasks,dp,shortest paths"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeMap;\nimport java.util.Map;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Ribhav\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CGlassCarving solver = new CGlassCarving();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CGlassCarving {\n        public void solve(int testNumber, FastReader s, PrintWriter out) {\n            TreeMap<Long, Integer> mapH = new TreeMap<>();\n            TreeMap<Long, Integer> mapV = new TreeMap<>();\n            TreeMap<Long, Integer> hDiff = new TreeMap<>();\n            TreeMap<Long, Integer> vDiff = new TreeMap<>();\n            long width = s.nextInt();\n            long height = s.nextInt();\n            mapH.put(0L, 1);\n            mapV.put(0L, 1);\n            mapV.put(width, 1);\n            mapH.put(height, 1);\n            vDiff.put(width, 1);\n            hDiff.put(height, 1);\n            long maxV = height;\n            long maxH = width;\n            int n = s.nextInt();\n            for (int i = 0; i < n; i++) {\n                char ch = s.nextCharacter();\n                long cut = s.nextInt();\n                if (ch == 'H') {\n                    Long next = mapH.higherKey(cut);\n                    Long prev = mapH.lowerKey(cut);\n                    Long diff = next - prev;\n                    int freq = hDiff.get(diff);\n                    if (freq == 1) {\n                        hDiff.remove(diff);\n                    } else {\n                        hDiff.put(diff, freq - 1);\n                    }\n                    hDiff.put(next - cut, hDiff.getOrDefault(next - cut, 0) + 1);\n                    hDiff.put(cut - prev, hDiff.getOrDefault(cut - prev, 0) + 1);\n                    mapH.put(cut, mapH.getOrDefault(cut, 0) + 1);\n                } else {\n                    Long next = mapV.higherKey(cut);\n                    Long prev = mapV.lowerKey(cut);\n                    Long diff = next - prev;\n                    int freq = vDiff.get(diff);\n                    if (freq == 1) {\n                        vDiff.remove(diff);\n                    } else {\n                        vDiff.put(diff, freq - 1);\n                    }\n                    vDiff.put(next - cut, vDiff.getOrDefault(next - cut, 0) + 1);\n                    vDiff.put(cut - prev, vDiff.getOrDefault(cut - prev, 0) + 1);\n                    mapV.put(cut, mapV.getOrDefault(cut, 0) + 1);\n                }\n\n                out.println(hDiff.lastKey() * vDiff.lastKey());\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public char nextCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "problem": "0527_C", "from": "CODEFORCES", "tags": "binary search,data structures,implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BPhoenixAndPuzzle solver = new BPhoenixAndPuzzle();\n        int testCount = Integer.parseInt(in.next());\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class BPhoenixAndPuzzle {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            if (n % 2 == 1) {\n                out.println(\"NO\");\n                return;\n            }\n            n /= 2;\n            if (n == 1 || (int) Math.sqrt(n) * (int) (Math.sqrt(n)) == n) {\n                out.println(\"YES\");\n            } else {\n                if (n % 2 == 0) {\n                    n /= 2;\n                    if ((int) Math.sqrt(n) * (int) (Math.sqrt(n)) == n) {\n                        out.println(\"YES\");\n                        return;\n                    }\n                }\n                out.println(\"NO\");\n            }\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ShekharN\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] arr = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                arr[i] = in.nextInt();\n            }\n            int inversions = 0;\n            for (int i = 1; i <= n; i++) {\n                for (int j = i + 1; j <= n; j++) {\n                    if (arr[i] > arr[j])\n                        inversions++;\n                }\n            }\n            inversions %= 2;\n            int q = in.nextInt();\n            for (int i = 0; i < q; i++) {\n                int l = in.nextInt(), r = in.nextInt();\n                int d = r - l + 1;\n                d = d * (d - 1) / 2;\n                if ((d & 1) == 1) inversions ^= 1;\n                out.println((inversions & 1) == 1 ? \"odd\" : \"even\");\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        public String nextString() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\t\n\tprivate BufferedReader in;\n\tprivate PrintWriter out;\n\tprivate StringTokenizer st;\n\n\tvoid solve() throws IOException {\n\t\tdouble a = nextDouble();\n\t\tdouble v = nextDouble();\n\t\tdouble l = nextDouble();\n\t\tdouble d = nextDouble();\n\t\tdouble w = nextDouble();\n\t\tif (w > v) {\n\t\t\tw = v;\n\t\t}\n\t\tdouble ans1 = 0.;\n\t\tdouble v1;\n\t\t{\n\t\t\tdouble l_ = 0., r_ = 1e+9;\n\t\t\tfor (int it = 0; it < 100; ++it) {\n\t\t\t\tdouble mid = (l_ + r_) / 2.;\n\t\t\t\tdouble V = a * mid;\n\t\t\t\tdouble t1 = (V + w) / 2. / a;\n\t\t\t\tdouble t2 = mid - t1;\n\t\t\t\tt1 = Math.min(t1, v / a);\n\t\t\t\tt2 = Math.min(t2, (v - w) / a);\n\t\t\t\tif (V < w) {\n\t\t\t\t\tt1 = mid;\n\t\t\t\t\tt2 = 0.;\n\t\t\t\t}\n\t\t\t\tdouble dist = t1 * t1 * a / 2. + t2 * (w + t2 * a / 2.) + v * (mid - t1 - t2);\n\t\t\t\tif (dist < d) {\n\t\t\t\t\tl_ = mid;\n\t\t\t\t} else {\n\t\t\t\t\tr_ = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans1 = (l_ + r_) / 2.;\n\t\t\tv1 = Math.min(ans1 * a, w);\n\t\t}\n\t\tdouble ans2 = 0.;\n\t\t{\n\t\t\tdouble tSp = (v - v1)  / a;\n\t\t\tdouble l_ = 0., r_ = 1e+9;\n\t\t\tfor (int it = 0; it < 100; ++it) {\n\t\t\t\tdouble mid = (l_ + r_) / 2.;\n\t\t\t\tdouble dist = Math.min(tSp, mid) * (v1 + Math.min(tSp, mid) * a / 2.);\n\t\t\t\tdist += (mid - Math.min(tSp, mid)) * v;\n\t\t\t\tif (dist < l - d) {\n\t\t\t\t\tl_ = mid;\n\t\t\t\t} else {\n\t\t\t\t\tr_ = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans2 = (l_ + r_) / 2.;\n\t\t}\n\t\tout.println(ans1 + ans2);\n\t}\n\n\tSolution() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\teat(\"\");\n\t\t\n\t\tsolve();\n\t\t\n\t\tin.close();\n\t\tout.close();\n\t}\n\t\n\tprivate void eat(String str) {\n\t\tst = new StringTokenizer(str);\n\t}\n\t\n\tString next() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\teat(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\t\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\t\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Solution();\n\t}\n}\n", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static PrintWriter out;\n    private static FastReader in;\n\n    private static class FastReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public FastReader(InputStream inputStream) {\n            reader = new BufferedReader(\n                    new InputStreamReader(inputStream), 1 << 16);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n\n    public static void main(String[] args) throws FileNotFoundException, InterruptedException {\n        in = new FastReader(System.in);\n        out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int a = ((n & 1) == 0) ? a = 6 : 9;\n        int b = n - a;\n        out.println(a + \" \" + b);\n\n        out.flush();\n    }\n}", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args) throws Exception {\n        int n=nextInt();\n        int r=nextInt();\n        int x[]=new int[n];\n        double y[]=new double[n];\n        for(int i=0;i<n;i++)\n            x[i]=nextInt();\n        for(int i=0;i<n;i++){\n            //(x1-x2)2+(y1-y2)2=r2\n            y[i]=r;\n            for(int j=0;j<i;j++){\n                int d=sq(2*r)-sq(x[i]-x[j]);\n                if(d>=0){\n                    double y1=Math.sqrt(d)+y[j];\n                    y[i]=Math.max(y1,y[i]);\n                }\n            }\n        }\n        for(int i=0;i<n;i++)\n            System.out.printf(\"%.12g \",y[i]);\n    }\n    static int sq(int a){\n        return a*a;\n    }\n    static int nextInt()throws IOException{\n        InputStream in=System.in;\n        int ans=0;\n        boolean flag=true;\n        byte b=0;\n        while ((b>47 && b<58) || flag){\n            if(b>=48 && b<58){\n                ans=ans*10+(b-48);\n                flag=false;\n            }\n            b=(byte)in.read();\n        }\n        return ans;\n    }\n    static String next()throws Exception{\n        StringBuilder sb=new StringBuilder(1<<16);\n        InputStream in=System.in;\n        byte b=0;\n        do{\n            if(!isWhiteSpace(b))\n                sb.append((char)b);\n            b=(byte)in.read();\n        }while(!isWhiteSpace(b) || sb.length()==0);\n        return sb.toString();\n    }\n    static boolean isWhiteSpace(byte b){\n        char ch=(char)b;\n        return ch=='\\0' || ch==' ' || ch=='\\n';\n    }\n}", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.util.*;\npublic class Solution{\n         public static void main(String[] arg){\n\t\t    Scanner sc=new Scanner(System.in);\n\t\t\tint t=sc.nextInt();\n\t\t\tfor(int i=0;i<t;i++){\n\t\t\t   String in=sc.next();\n\t\t\t   String out=\"\";\n\t\t\t   String[] args=in.split(\"(?<=\\\\D)(?=\\\\d)\");\n\t\t\t   if(args.length>2){\n\t\t\t\t   String[] nn=args[1].split(\"(?<=\\\\d)(?=\\\\D)\");\n\t\t\t\t   String row=nn[0];\n\t\t\t\t   int col=Integer.parseInt(args[2]);\n\t\t\t\t   while(col>0){\n\t\t\t\t\t   if(col%26==0){\n\t\t\t\t\t\t   out=(char)(64+26)+out;\n\t\t\t\t\t\t   col-=26;\n\t\t\t\t\t   }else{\n\t\t\t\t\t\t   out=(char)(col%26+64)+out;\n\t\t\t\t\t   }\n\t\t\t\t\t   col=col/26;\n\t\t\t\t   }\n\t\t\t\t   out=out+row;\n\t\t\t   }\n\t\t\t   else{\n\t\t\t\t   int sum=0;\n\t\t\t\t   int len=args[0].length();\n\t\t\t\t   for(int j=0;j<len-1;j++){\n\t\t\t\t\t   sum+=((int)(args[0].charAt(j))-64)*Math.pow(26,len-j-1);\n\t\t\t\t   }\n\t\t\t\t   sum+=((int)(args[0].charAt(len-1))-64);\n\t\t\t\t   String row=args[1];\n\t\t\t\t   out+=\"R\"+row+\"C\"+sum;\n\t\t\t   }\n\t\t\t   System.out.println(out);\n\t\t\t}\n        }\n    }", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\n\nimport java.util.StringTokenizer;\n\n\n\nimport static java.lang.Math.abs;\n\n\n\n/**\n\n * 35C\n\n *\n\n * @author artyom\n\n */\n\npublic class FireAgain implements Runnable {\n\n    private BufferedReader in;\n\n    private PrintWriter out;\n\n    private StringTokenizer tok;\n\n\n\n    private void solve() throws IOException {\n\n        int n = nextInt(), m = nextInt();\n\n        int[][] sources = readIntMatrix(nextInt(), 2);\n\n        int max = -1, maxI = 0, maxJ = 0;\n\n        for (int i = 0; i < n; i++) {\n\n            for (int j = 0; j < m; j++) {\n\n                int min = Integer.MAX_VALUE;\n\n                for (int[] source : sources) {\n\n                    int dist = abs(source[0] - i) + abs(source[1] - j);\n\n                    if (dist < min) {\n\n                        min = dist;\n\n                    }\n\n                }\n\n                if (min > max) {\n\n                    max = min;\n\n                    maxI = i;\n\n                    maxJ = j;\n\n                }\n\n            }\n\n        }\n\n        out.print((maxI + 1) + \" \" + (maxJ + 1));\n\n    }\n\n\n\n    //--------------------------------------------------------------\n\n    public static void main(String[] args) {\n\n        new FireAgain().run();\n\n    }\n\n\n\n    @Override\n\n    public void run() {\n\n        try {\n\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n\n            out = new PrintWriter(new FileWriter(\"output.txt\"));\n\n            tok = null;\n\n            solve();\n\n            in.close();\n\n            out.close();\n\n        } catch (IOException e) {\n\n            System.exit(0);\n\n        }\n\n    }\n\n\n\n    private String nextToken() throws IOException {\n\n        while (tok == null || !tok.hasMoreTokens()) {\n\n            tok = new StringTokenizer(in.readLine());\n\n        }\n\n        return tok.nextToken();\n\n    }\n\n\n\n    private int nextInt() throws IOException {\n\n        return Integer.parseInt(nextToken());\n\n    }\n\n\n\n    private int[][] readIntMatrix(int n, int m) throws IOException {\n\n        int[][] mx = new int[n][m];\n\n        for (int i = 0; i < n; i++) {\n\n            for (int j = 0; j < m; j++) {\n\n                mx[i][j] = nextInt() - 1;\n\n            }\n\n        }\n\n        return mx;\n\n    }\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class B {\n\tstatic int i(String s) { return Integer.parseInt(s); }\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] arr = in.readLine().split(\" \");\n\t\tint n = i(arr[0]);\n\t\tint k = i(arr[1]);\n\t\tint[] A = new int[n];\n\t\tarr = in.readLine().split(\" \");\n\t\tfor(int i=0; i<n; i++)\n\t\t\tA[i] = i(arr[i]);\n\t\t\n\t\tint st = 0;\n\t\tint cnt = 0;\n\t\tint[] cnts = new int[100*100*10+1];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tcnts[A[i]]++;\n\t\t\tif(cnts[A[i]] == 1) cnt++;\n\t\t\telse while(cnts[A[st]] > 1) {\n\t\t\t\tcnts[A[st]]--;\n\t\t\t\tst++;\n\t\t\t}\n\t\t\tif(cnt == k) {\n\t\t\t\tSystem.out.println((st+1)+\" \"+(i+1));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1+\" \"+-1);\n\t}\n}\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "\n\nimport java.awt.Point;\n\nimport java.io.*;\n\nimport java.util.*;\n\n\n\nimport static java.lang.Math.*;\n\n\n\npublic class BetaRound35_C implements Runnable {\n\n\n\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tBufferedReader in;\n\n\tPrintWriter out;\n\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\n\n\n\tvoid init() throws IOException {\n\n\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\n\t\tout = new PrintWriter(\"output.txt\");\n\n\t}\n\n\n\n\tString readString() throws IOException {\n\n\t\twhile (!tok.hasMoreTokens()) {\n\n\t\t\ttok = new StringTokenizer(in.readLine());\n\n\t\t}\n\n\t\treturn tok.nextToken();\n\n\t}\n\n\n\n\tint readInt() throws IOException {\n\n\t\treturn Integer.parseInt(readString());\n\n\t}\n\n\n\n\t@Override\n\n\tpublic void run() {\n\n\t\ttry {\n\n\t\t\tlong t1 = System.currentTimeMillis();\n\n\t\t\tinit();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\n\t\t\tlong t2 = System.currentTimeMillis();\n\n\t\t\tSystem.err.println(\"Time = \" + (t2 - t1));\n\n\t\t} catch (Exception e) {\n\n\t\t\te.printStackTrace(System.err);\n\n\t\t\tSystem.exit(-1);\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Thread(new BetaRound35_C()).start();\n\n\t}\n\n\t\n\n\tvoid solve() throws IOException {\n\n\t\tint n = readInt();\n\n\t\tint m = readInt();\n\n\t\tint k = readInt();\n\n\t\tQueue<Point> q = new ArrayDeque<Point>();\n\n\t\tboolean[][] visited = new boolean[n + 2][m + 2];\n\n\t\tfor (int j = 0; j < m + 2; j++) {\n\n\t\t\tvisited[0][j] = true;\n\n\t\t\tvisited[n + 1][j] = true;\n\n\t\t}\n\n\t\tfor (int i = 0; i < n + 2; i++) {\n\n\t\t\tvisited[i][0] = true;\n\n\t\t\tvisited[i][m + 1] = true;\n\n\t\t}\n\n\t\tfor (int i = 0; i < k; i++) {\n\n\t\t\tint x = readInt();\n\n\t\t\tint y = readInt();\n\n\t\t\tq.add(new Point(x, y));\n\n\t\t\tvisited[x][y] = true;\n\n\t\t}\n\n\t\t\n\n\t\tPoint p = null;\n\n\t\twhile (!q.isEmpty()) {\n\n\t\t\tp = q.poll();\n\n\t\t\tint x = p.x, y = p.y;\n\n\t\t\tif (!visited[x + 1][y]) {\n\n\t\t\t\tq.add(new Point(x + 1, y));\n\n\t\t\t\tvisited[x + 1][y] = true;\n\n\t\t\t}\n\n\t\t\tif (!visited[x - 1][y]) {\n\n\t\t\t\tq.add(new Point(x - 1, y));\n\n\t\t\t\tvisited[x - 1][y] = true;\n\n\t\t\t}\n\n\t\t\tif (!visited[x][y + 1]) {\n\n\t\t\t\tq.add(new Point(x, y + 1));\n\n\t\t\t\tvisited[x][y + 1] = true;\n\n\t\t\t}\n\n\t\t\tif (!visited[x][y - 1]) {\n\n\t\t\t\tq.add(new Point(x, y - 1));\n\n\t\t\t\tvisited[x][y - 1] = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tout.print(p.x + \" \" + p.y);\n\n\t}\n\n\t\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.text.*;\npublic class Main {\n    static long mod = 1000_000_007;\n    static long mod1 = 998244353;\n    static boolean fileIO = false;\n    static boolean memory = true;\n    static FastScanner f;\n    static PrintWriter pw;\n    static double eps = (double)1e-6;\n    static int oo = (int)1e9;\n\n    public static void solve()throws Exception {\n        int n = f.ni(); long m = f.nl();\n        long p[] = new long[n];\n        for (int i = 0; i < n; ++i) p[i] = f.nl();\n        HashMap<Long , Long> mp = new HashMap<>(); \n        mp.put(0l , 1l); \n        boolean ok = false; \n        long sum = 0; \n        long ans = 0; \n        for (int r = 0; r < n; ++r) { \n            if (p[r] < m) --sum;\n            else if (p[r] > m) ++sum;\n            if (p[r] == m) ok = true;\n            if (ok) {\n                if (mp.get(sum) != null) {\n                    ans += mp.get(sum);\n                }\n                if (mp.get(sum - 1l) != null) ans += mp.get(sum - 1l);\n            }\n            else {\n                if (mp.get(sum) == null) mp.put(sum , 1l);\n                else mp.put(sum , mp.get(sum) + 1l);\n            }\n        } \n        pn(ans); \n    }    \n \n    public static void main(String[] args)throws Exception {\n        if(memory) new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();System.exit(1);}}}, \"\", 1 << 28).start();\n        else new Main().run();\n    }\n        \n/******************************END OF MAIN PROGRAM*******************************************/\n    void run()throws Exception {\n        if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n            f = new FastScanner(\"\");\n            pw = new PrintWriter(System.out);\n        }\n        else {\n            f = new FastScanner();\n            pw = new PrintWriter(System.out);\n            //fw = new FileWriter(\"!out.txt\");\n        }\n        //pre();\n        int t = 1;\n        int tt = 1;\n        while(t --> 0) {\n            //fw.write(\"Case #\" + (tt++) + \": \");\n            //fw.write(\"\\n\");\n            solve();\n        }\n        pw.flush(); \n        pw.close();\n        //fw.close();  \n    }\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner(String str) throws Exception {\n            try {\n                br = new BufferedReader(new FileReader(\"!a.txt\"));\n            }\n            catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n \n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        public String next()throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n \n        public int ni() throws IOException {return Integer.parseInt(next());}\n \n        public long nl() throws IOException {return Long.parseLong(next());}\n \n        public String nextLine() throws IOException {return br.readLine();}\n \n        public double nd() throws IOException {return Double.parseDouble(next());}\n \n    }\n \n    public static void pn(Object... o) {for(int i = 0; i < o.length; ++i) pw.print(o[i] + (i + 1 < o.length ? \" \": \"\\n\"));}\n    public static void p(Object... o) {for(int i = 0; i < o.length; ++i) pw.print(o[i] + (i + 1 < o.length ? \" \" : \"\"));}\n    public static void pni(Object... o) {for(Object obj : o) pw.print(oo + \" \"); pw.println(); pw.flush();}\n    public static int gcd(int a,int b){if(b==0)return a;else{return gcd(b,a%b);}}\n    public static long gcd(long a,long b){if(b==0l)return a;else{return gcd(b,a%b);}}\n    public static long lcm(long a,long b){return (a*b/gcd(a,b));}\n    public static long pow(long a,long b){long res=1;while(b>0){if((b&1)==1)res=res*a;b>>=1;a=a*a;}return res;}\n    public static int pow(int a,int b){int res=1;while(b>0){if((b&1)==1)res=res*a;b>>=1;a=a*a;}return res;}\n    public static long mpow(long a,long b, long m){long res=1;while(b>0){if((b&1)==1)res=((res%m)*(a%m))%m;b>>=1;a=((a%m)*(a%m))%m;}return res;}\n    public static long mul(long a , long b){return ((a%mod)*(b%mod)%mod);}\n    public static long adp(long a , long b){return ((a%mod)+(b%mod)%mod);}\n    public static int dig(long a){int cnt=0;while(a>0){a/=10;++cnt;}return Math.max(1,cnt);}\n    public static int dig(int a){int cnt=0;while(a>0){a/=10;++cnt;}return Math.max(1,cnt);}\n    public static boolean isPrime(long n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(long i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    public static boolean isPrime(int n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    public static HashSet<Long> factors(long n){HashSet<Long> hs=new HashSet<Long>();for(long i=1;i<=(long)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    public static HashSet<Integer> factors(int n){HashSet<Integer> hs=new HashSet<Integer>();for(int i=1;i<=(int)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    public static HashSet<Long> pf(long n){HashSet<Long> ff=factors(n);HashSet<Long> ans=new HashSet<Long>();for(Long i:ff)if(isPrime(i))ans.add(i);return ans;}\n    public static HashSet<Integer> pf(int n){HashSet<Integer> ff=factors(n);HashSet<Integer> ans=new HashSet<Integer>();for(Integer i:ff)if(isPrime(i))ans.add(i);return ans;}\n    public static int gnv(char c){return Character.getNumericValue(c);}\n    public static void sort(int[] a){ArrayList<Integer> l=new ArrayList<>();for(int i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    public static void sort(long[] a){ArrayList<Long> l=new ArrayList<>();for(long i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    public static void sort(ArrayList<Integer> a){Collections.sort(a);}\n}", "complexity": "nlogn", "problem": "1005_E1", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskG2 solver = new TaskG2();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskG2 {\n        static final int MOD = 1000000000 + 7;\n        static final int MAXN = 51;\n\n        int getWays(int i, int j, int k, int l, int[][][][] ways, boolean[][][][] cached) {\n            if (i + j + k == 0) return l == -1 ? 1 : 0;\n            if (l < 0) return 0;\n            if (cached[i][j][k][l]) return ways[i][j][k][l];\n            int s = i + j + k;\n            long value = 0;\n            if (l == 0 && i != 0) {\n                for (int x = -1; x < 3; x++)\n                    if (x != l) {\n                        value += getWays(i - 1, j, k, x, ways, cached);\n                    }\n            }\n            if (l == 1 && j != 0) {\n                for (int x = -1; x < 3; x++)\n                    if (x != l) {\n                        value += getWays(i, j - 1, k, x, ways, cached);\n                    }\n            }\n            if (l == 2 && k != 0) {\n                for (int x = -1; x < 3; x++)\n                    if (x != l) {\n                        value += getWays(i, j, k - 1, x, ways, cached);\n                    }\n            }\n            ways[i][j][k][l] = (int) (value % MOD);\n            cached[i][j][k][l] = true;\n            return ways[i][j][k][l];\n        }\n\n        int totalWays(int i, int j, int k, int[][][][] ways, boolean[][][][] cached, int[] factorial) {\n            long ret = 0;\n            for (int l = 0; l < 3; l++) ret += getWays(i, j, k, l, ways, cached);\n            ret *= factorial[i];\n            ret %= MOD;\n\n            ret *= factorial[j];\n            ret %= MOD;\n\n            ret *= factorial[k];\n            ret %= MOD;\n\n            return (int) ret;\n        }\n\n        int add(int type, int value, int[] sizes, int sum, int[][][][] dp) {\n            sizes[type]++;\n            if (type == 0) {\n                for (int s = sum + value; s >= value; s--) {\n                    for (int i = 1; i <= sizes[0]; i++)\n                        for (int j = 0; j <= sizes[1]; j++)\n                            for (int k = 0; k <= sizes[2]; k++) {\n                                dp[i][j][k][s] += dp[i - 1][j][k][s - value];\n                                if (dp[i][j][k][s] >= MOD)\n                                    dp[i][j][k][s] -= MOD;\n                            }\n                }\n            }\n\n            if (type == 1) {\n                for (int s = sum + value; s >= value; s--) {\n                    for (int i = 0; i <= sizes[0]; i++)\n                        for (int j = 1; j <= sizes[1]; j++)\n                            for (int k = 0; k <= sizes[2]; k++) {\n//                            System.out.println(i + \" \" + j + \" \" + k + \" \" + s + \" \" + dp.length + \" \" + dp[0].length + \" \" + dp[0][0].length + \" \" + dp[0][0][0].length);\n                                dp[i][j][k][s] += dp[i][j - 1][k][s - value];\n                                if (dp[i][j][k][s] >= MOD)\n                                    dp[i][j][k][s] -= MOD;\n                            }\n                }\n            }\n\n            if (type == 2) {\n                for (int s = sum + value; s >= value; s--) {\n                    for (int i = 0; i <= sizes[0]; i++)\n                        for (int j = 0; j <= sizes[1]; j++)\n                            for (int k = 1; k <= sizes[2]; k++) {\n//                            System.out.println(i + \" \" + j + \" \" + k + \" \" + s + \" \" + dp.length + \" \" + dp[0].length + \" \" + dp[0][0].length + \" \" + dp[0][0][0].length);\n                                dp[i][j][k][s] += dp[i][j][k - 1][s - value];\n                                if (dp[i][j][k][s] >= MOD)\n                                    dp[i][j][k][s] -= MOD;\n                            }\n                }\n            }\n\n            return sum + value;\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int[][][][] ways = new int[MAXN][MAXN][MAXN][3];\n            boolean[][][][] cached = new boolean[MAXN][MAXN][MAXN][3];\n//        Arrays.fill(ways, -1);\n\n            int n = in.nextInt(), T = in.nextInt();\n\n            ArrayList<Integer>[] ar = new ArrayList[3];\n            for (int i = 0; i < 3; i++) ar[i] = new ArrayList<Integer>();\n            int total_sum = 0;\n            for (int i = 0; i < n; i++) {\n                int t = in.nextInt(), g = in.nextInt();\n                ar[g - 1].add(t);\n                total_sum += t;\n            }\n\n            if (T > total_sum) {\n                out.println(0);\n                return;\n            }\n            int min_index = 0, mn = 0;\n\n            for (int i = 0; i < 3; i++) {\n                if (ar[i].size() > mn) {\n                    mn = ar[i].size();\n                    min_index = i;\n                }\n            }\n\n            int[][][][] dp = new int[ar[(1 + min_index) % 3].size() + 1][ar[(2 + min_index) % 3].size() + 1][1][total_sum + 1];\n            int[][][][] dp2 = new int[1][1][mn + 1][total_sum + 1];\n            dp[0][0][0][0] = dp2[0][0][0][0] = 1;\n            int[] sizes = {0, 0, 0};\n            int sum = 0;\n            int[] order = {(min_index + 1) % 3, (min_index + 2) % 3};\n            int type = 0;\n            for (int i : order) {\n                for (int v : ar[i])\n                    sum = add(type, v, sizes, sum, dp);\n                type++;\n            }\n            sum = 0;\n            sizes[0] = sizes[1] = sizes[2] = 0;\n            for (int i : ar[min_index])\n                sum = add(2, i, sizes, sum, dp2);\n            int[] factorial = new int[MAXN];\n            factorial[0] = 1;\n            for (int i = 1; i < MAXN; i++)\n                factorial[i] = (int) ((factorial[i - 1] * 1L * i) % MOD);\n\n            long answer = 0;\n            for (int i = 0; i < dp.length; i++)\n                for (int j = 0; j < dp[0].length; j++)\n                    for (int k = 0; k <= mn; k++)\n                        for (int s = 0; s <= T; s++) {\n\n                            long x = (dp[i][j][0][s] * 1L * totalWays(i, j, k, ways, cached, factorial)) % MOD;\n                            x *= dp2[0][0][k][T - s];\n                            x %= MOD;\n                            answer += x;\n\n                        }\n            out.println(answer % MOD);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void println(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n            writer.print('\\n');\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n", "complexity": "cubic", "problem": "1185_G2", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "import java.util.Scanner;\n\npublic class D {\n    static long[][][] dp;\n    static int[][] hor, ver;\n    static int n, m;\n    static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public static boolean isValid (int row, int col) {\n        return row >= 0 && col >= 0 && row < n && col < m;\n    }\n\n    public static void minCost (int row, int col, int k) {\n        if (k == 0)\n            return;\n        if (k == 2) {\n            long min = Long.MAX_VALUE;\n            for (int i = 0; i < 4; i++) {\n                if (isValid(row + dir[i][0], col + dir[i][1])) {\n                    if ((row + dir[i][0]) == row) {\n                        if ((col + dir[i][1]) > col) {\n                            min = Math.min(min, hor[row][col]);\n                        } else {\n                            min = Math.min(min, hor[row][col - 1]);\n                        }\n                    } else {\n                        if ((row + dir[i][0]) > row) {\n                            min = Math.min(min, ver[row][col]);\n                        } else {\n                            min = Math.min(min, ver[row - 1][col]);\n                        }\n                    }\n                }\n            }\n            dp[row][col][k] = 2 * min;\n            return;\n        }\n        if (dp[row][col][k] != Long.MAX_VALUE)\n            return;\n        long min = Long.MAX_VALUE;\n        for (int i = 0; i < 4; i++) {\n            if (isValid(row + dir[i][0], col + dir[i][1])) {\n                if (k >= 4) {\n                    minCost(row + dir[i][0], col + dir[i][1], k - 2);\n                    int edge = 0;\n                    if ((row + dir[i][0]) == row) {\n                        if ((col + dir[i][1]) > col) {\n                            edge = hor[row][col];\n                        } else {\n                            edge = hor[row][col - 1];\n                        }\n                    } else {\n                        if ((row + dir[i][0]) > row) {\n                            edge = ver[row][col];\n                        } else {\n                            edge = ver[row - 1][col];\n                        }\n                    }\n                    min = Math.min(min, 2 * edge + dp[row + dir[i][0]][col + dir[i][1]][k - 2]);\n                }\n            }\n        }\n        dp[row][col][k] = min;\n    }\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        n = input.nextInt();\n        m = input.nextInt();\n        int k = input.nextInt();\n        hor = new int[n][m - 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m - 1; j++) {\n                hor[i][j] = input.nextInt();\n            }\n        }\n        ver = new int[n - 1][m];\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < m; j++) {\n                ver[i][j] = input.nextInt();\n            }\n        }\n        if (k % 2 != 0) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    System.out.print(-1 + \" \");\n                }\n                System.out.println(\"\");\n            } \n        } else {\n            dp = new long[n][m][k + 1];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    for (int x = 0; x <= k; x++) {\n                        dp[i][j][x] = Long.MAX_VALUE;\n                    }\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    minCost(i, j, k);\n                    System.out.print(dp[i][j][k] + \" \");\n                }\n                System.out.println(\"\");\n            }\n        }\n        \n        input.close();\n    }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class A {\n\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(25);\n\t}\n}\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int l, r, sum = 0;\n            int[] a = new int[n+5];\n            for (int i = 0; i < n; i++) a[i] = in.nextInt();\n            for (int i = 0; i < n; i++)\n                for (int j = i+1; j < n; j++)\n                    if (a[i] > a[j]) sum++;\n            int q = in.nextInt();\n            while (q-- > 0){\n                l = in.nextInt();\n                r = in.nextInt();\n                sum += (r-l+1)/2;\n                if (sum % 2 == 1) out.println(\"odd\");\n                else out.println(\"even\");\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\t  \t\t \t \t\t \t\t\t      \t  \t\t\t    \t", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;\nimport java.util.Scanner;\nimport java.io.*;\nimport javax.lang.model.util.ElementScanner6; \nimport static java.lang.System.out;\nimport java.util.Stack;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class C817\n{\n\n   static int mod=(int)(1e9+7);\n   static long MOD=(long)(1e9+7);\n   static FastReader in=new FastReader();\n   static PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        \n    public static void main(String args[])\n    {  \n\n        int tc=1;\n     \n        //tc=in.nextInt();\n        tcloop: while(tc-->0)\n        {\n            \n        \tlong n=in.nextLong();\n        \tlong s=in.nextLong();\n        \t\n        \tlong start=s+1;\n        \tint f=0;\n        \twhile(start<=n)\n        \t{\n\t\t\t\tlong sum=0;\n\t\t\t\tlong t=start;\n\t\t\t\twhile(t>0)\n\t\t\t\t{\n\t\t\t\t\tsum+=t%10;\n\t\t\t\t\tt/=10;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t//pr.println(sum);\n\t\t\t\tif(start-sum>=s)\n\t\t\t\t{\n\t\t\t\t\tf=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstart++;\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif(f==1)\n\t\t\tpr.println(n-start+1);\n\t\t\t\n\t\t\telse pr.println(0);\n\n        }\n        pr.flush();\n    }\n\n\n    \n\n    static void sort(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n\t}\n    \n    \n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n    }\n\n    \n    static class FastReader\n    { \n        BufferedReader br; \n        StringTokenizer st; \n\n        public FastReader() \n        { \n            br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n\n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n\n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n\n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n\n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n        \n        int[] readIntArray(int n)\n        {\n\t\tint a[]=new int[n];\n\t\tfor(int i=0;i<n;i++)a[i]=nextInt();\n\t\treturn a;\n\t}\n\t\t\n\tlong[] readLongArray(int n)\n\t{\n\t\tlong a[]=new long[n];\n\t\tfor(int i=0;i<n;i++)a[i]=nextLong();\n\t\treturn a;\n\t}\n\t\n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n}\n\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "//package round489;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class C {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint[][] M = {\n\t\t\t\t{2, mod-1},\n\t\t\t\t{0, 1}\n\t\t};\n\t\tlong n = nl();\n\t\tif(n == 0){\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tn = n*2%mod;\n\t\tlong K = nl();\n\t\tint[] v = new int[]{(int)n, 1};\n\t\tout.println(pow(M, v, K)[0]);\n\t}\n\t\n\t///////// begin\n\tpublic static final int mod = 1000000007;\n\tpublic static final long m2 = (long)mod*mod;\n\tpublic static final long BIG = 8L*m2;\n\t\n\t// A^e*v\n\tpublic static int[] pow(int[][] A, int[] v, long e)\n\t{\n\t\tfor(int i = 0;i < v.length;i++){\n\t\t\tif(v[i] >= mod)v[i] %= mod;\n\t\t}\n\t\tint[][] MUL = A;\n\t\tfor(;e > 0;e>>>=1) {\n\t\t\tif((e&1)==1)v = mul(MUL, v);\n\t\t\tMUL = p2(MUL);\n\t\t}\n\t\treturn v;\n\t}\n\t\n\t// int matrix*int vector\n\tpublic static int[] mul(int[][] A, int[] v)\n\t{\n\t\tint m = A.length;\n\t\tint n = v.length;\n\t\tint[] w = new int[m];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tlong sum = 0;\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tsum += (long)A[i][k] * v[k];\n\t\t\t\tif(sum >= BIG)sum -= BIG;\n\t\t\t}\n\t\t\tw[i] = (int)(sum % mod);\n\t\t}\n\t\treturn w;\n\t}\n\t\n\t// int matrix^2 (be careful about negative value)\n\tpublic static int[][] p2(int[][] A)\n\t{\n\t\tint n = A.length;\n\t\tint[][] C = new int[n][n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tlong[] sum = new long[n];\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tsum[j] += (long)A[i][k] * A[k][j];\n\t\t\t\t\tif(sum[j] >= BIG)sum[j] -= BIG;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tC[i][j] = (int)(sum[j] % mod);\n\t\t\t}\n\t\t}\n\t\treturn C;\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new C().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class P023A {\n\n    public static void main(String[] args) {\n        Scanner inScanner = new Scanner(System.in);\n        String string = inScanner.next();\n        int n = string.length();\n        for (int l = n - 1; l > 0; l--) {\n            Set<String> seen = new HashSet<String>();\n            for (int i = 0; i < n - l + 1; i++) {\n                String subString = string.substring(i, i + l);\n                if (seen.contains(subString)) {\n                    System.out.println(l);\n                    return;\n                }\n                seen.add(subString);\n            }\n        }\n        System.out.println(\"0\");\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "//package codeforces.br17;\n\nimport java.io.*;\nimport java.text.DecimalFormat;\n\npublic class ProblemA {\n    public void solve() {\n        boolean oj = true;\n\n        try {\n            Reader reader = oj ? new InputStreamReader(System.in) : new FileReader(\"A.in\");\n            Writer writer = oj ? new OutputStreamWriter(System.out) : new FileWriter(\"A.out\");\n            BufferedReader br = new BufferedReader(reader);\n            PrintWriter out = new PrintWriter(writer);\n\n            MyTokenizer tok = new MyTokenizer(br.readLine());\n\n            int n = (int)tok.getNum();\n            int k = (int)tok.getNum();\n\n            boolean[] isPrime = new boolean[n + 1];\n            for(int i=1;i<=n;i++)\n                isPrime[i] = true;\n            isPrime[1] = false;\n            isPrime[2] = true;\n            for(int i=2;i*i<=n;i++)\n                for(int j=2*i;j<=n;j+=i)\n                    isPrime[j] = false;\n            int[] primes = new int[n];\n            int cur = 0;\n            for(int i=2;i<=n;i++)\n                if (isPrime[i]) {\n                    primes[cur] = i;\n                    cur++;\n                }\n            int count = 0;\n            for(int i=0;i<cur-1;i++) {\n                if (primes[i] + primes[i+1] + 1 <= n && isPrime[primes[i] + primes[i+1] + 1])\n                    count++;\n            }\n            if (count >= k)\n                out.printf(\"YES\");\n            else\n                out.printf(\"NO\");\n\n            \n            br.close();\n            out.close();\n            reader.close();\n            writer.close();\n        }\n        catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        finally {\n        }\n    }\n\n    public static void main(String[] args) {\n        ProblemA f = new ProblemA();\n        f.solve();\n    }\n\n    private class MyTokenizer {\n        private String s;\n        private int cur;\n\n        public MyTokenizer(String s) {\n            this.s = s;\n            cur = 0;\n        }\n\n        public void skip() {\n            while (cur < s.length() && (s.charAt(cur) == ' ' || s.charAt(cur) == '\\n')) {\n                cur++;\n            }\n        }\n\n        public double getNum() {\n            skip();\n            String snum = \"\";\n            while (cur < s.length() && (s.charAt(cur) >= '0' && s.charAt(cur) <= '9' || s.charAt(cur) == '.')) {\n                snum += s.charAt(cur);\n                cur++;\n            }\n            return Double.valueOf(snum);\n        }\n\n        public String getString() {\n            skip();\n            String s2 = \"\";\n            while (cur < s.length() && (s.charAt(cur) >= 'a' && s.charAt(cur) <= 'z')) {\n                s2 += s.charAt(cur);\n                cur++;\n            }\n            return s2;\n        }\n\n        public char getCurrentChar() throws Exception {\n            if (cur < s.length())\n                return s.charAt(cur);\n            else\n                throw new Exception(\"Current character out of string length\");\n        }\n\n        public void moveNextChar() {\n            if (cur < s.length())\n                cur++;\n        }\n\n        public boolean isFinished() {\n            return cur >= s.length();\n        }\n    }\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "//package Round_159;\n\nimport java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class a {\n\n\tvoid solve() throws Exception {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i<n; i++){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tint sum = 0;\n\t\tif (k >= m){\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tsum = a[n-1] + k - 1;\n\t\tint j = 1;\n\t\tfor (int i = n-2; i >=0 && sum < m; i--, j++){\n\t\t\tsum += a[i] - 1;\n\t\t}\n\t\tif (sum < m){\n\t\t\tout.println(-1);\n\t\t}else{\n\t\t\tout.println(j);\n\t\t}\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tString input = \"\";\n\tString output = \"\";\n\n\tvoid run() {\n\t\ttry {\n\t\t\tif (input.length() > 0) {\n\t\t\t\tin = new FastScanner(new BufferedReader(new FileReader(input)));\n\t\t\t} else\n\t\t\t\tin = new FastScanner(new BufferedReader(new InputStreamReader(\n\t\t\t\t\t\tSystem.in)));\n\t\t\tif (output.length() > 0)\n\t\t\t\tout = new PrintWriter(new FileWriter(output));\n\t\t\telse\n\t\t\t\tout = new PrintWriter(System.out);\n\n\t\t\tsolve();\n\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew a().run();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader bf;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(BufferedReader bf) {\n\t\t\tthis.bf = bf;\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(bf.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn bf.readLine();\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Sunits789\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n=in.nextInt();\n        int arr[]=new int[n];\n        in.getArray(arr);\n        int arrc[]=new int[n];\n        for(int i=0;i<n;i++){\n            arrc[i]=arr[i];\n        }\n        Library.sort(arrc);\n        int c=0;\n        for(int i=0;i<n;i++){\n            if(arrc[i]!=arr[i]){\n                c++;\n            }\n        }\n        if(c>2){\n            out.println(\"NO\");\n        }\n        else{\n            out.println(\"YES\");\n        }\n\t}\n}\n\nclass InputReader{\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream){\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n    public String next(){\n        while (tokenizer == null||!tokenizer.hasMoreTokens()){\n            try{\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n            catch (IOException e){\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt(){\n        return Integer.parseInt(next());\n    }\n\n    public void getArray(int arr[]){\n        for(int i=0;i<arr.length;i++){\n            arr[i]=nextInt();\n        }\n    }\n\n    }\n\nclass Library{\n    public static void sort(int n[]){\n        int len=n.length;\n        int l1=len/2;\n        int l2=len-l1;\n        int n1[]=new int[l1];\n        int n2[]=new int[l2];\n        for(int i=0;i<l1;i++){\n            n1[i]=n[i];\n        }\n        for(int i=0;i<l2;i++){\n            n2[i]=n[i+l1];\n        }\n        if(l1!=0){\n            sort(n1);\n            sort(n2);\n        }\n        int ind1=0;\n        int ind2=0;\n        int ind=0;\n        for(int i=0;i<len&&ind1<l1&&ind2<l2;i++){\n            if(n1[ind1]<n2[ind2]){\n                n[i]=n1[ind1];\n                ind1++;\n            }\n            else{\n                n[i]=n2[ind2];\n                ind2++;\n            }\n            ind++;\n        }\n        if(ind1<l1){\n            for(int i=ind1;i<l1;i++){\n                n[ind]=n1[i];\n                ind++;\n            }\n        }\n        if(ind2<l2){\n            for(int i=ind2;i<l2;i++){\n                n[ind]=n2[i];\n                ind++;\n            }\n        }\n    }\n    \n    }\n\n", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.Scanner;\n\npublic class _0555Antipalindrome {\n\t\n\t\n\tstatic boolean isPalindrome(String s) {\n\t\treturn s.equals(new StringBuilder(s).reverse().toString());\n\t}\n\t\n\tstatic int largestSubString(String str) {\n\t//\tSystem.out.println(str);\n\t\tif(!isPalindrome(str)) {\n\t\t\treturn str.length();\n\t\t}\n\t\tif(str.length()==1) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint input1=largestSubString(str.substring(1));\n\t\tint input2=largestSubString(str.substring(0,str.length()-1));\n\t\treturn Math.max(input1, input2);\n\t}\n\t\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s=sc.nextLine();\n\t\tString temp=s.replaceAll(s.charAt(0)+\"\",\"\");\n\t\tif(temp.length()==0) {\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse {\n\t\tSystem.out.println(largestSubString(s));\n\t\t}\n\t\t\n\t}\n\n}\n", "complexity": "linear", "problem": "0981_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.io.*;\n\n\n\npublic class Main\n\n{\n\n\tstatic class InputReader{\n\n\t\tprivate InputStream stream;\n\n\t\tprivate byte[] buf = new byte[1024];\n\n\t\tprivate int curChar;\n\n\t\tprivate int numChars;\n\n\t\tprivate SpaceCharFilter filter;\n\n \n\n\t\tpublic InputReader(InputStream stream) {\n\n\t\t\tthis.stream = stream;\n\n\t\t}\n\n \n\n\t\tpublic int read() {\n\n\t\t\tif (numChars == -1)\n\n\t\t\t\tthrow new InputMismatchException();\n\n\t\t\tif (curChar >= numChars) {\n\n\t\t\t\tcurChar = 0;\n\n\t\t\t\ttry {\n\n\t\t\t\t\tnumChars = stream.read(buf);\n\n\t\t\t\t} catch (IOException e) {\n\n\t\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\t}\n\n\t\t\t\tif (numChars <= 0)\n\n\t\t\t\t\treturn -1;\n\n\t\t\t}\n\n\t\t\treturn buf[curChar++];\n\n\t\t}\n\n \n\n\t\tpublic int readInt() {\n\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\n\t\t\t\tc = read();\n\n\t\t\tint sgn = 1;\n\n\t\t\tif (c == '-') {\n\n\t\t\t\tsgn = -1;\n\n\t\t\t\tc = read();\n\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo {\n\n\t\t\t\tif (c < '0' || c > '9')\n\n\t\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\tres *= 10;\n\n\t\t\t\tres += c - '0';\n\n\t\t\t\tc = read();\n\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\n\t\t}\n\n \n\n\t\tpublic String readString() {\n\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\n\t\t\t\tc = read();\n\n\t\t\tStringBuilder res = new StringBuilder();\n\n\t\t\tdo {\n\n\t\t\t\tres.appendCodePoint(c);\n\n\t\t\t\tc = read();\n\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res.toString();\n\n\t\t}\n\n \n\n\t\tpublic boolean isSpaceChar(int c) {\n\n\t\t\tif (filter != null)\n\n\t\t\t\treturn filter.isSpaceChar(c);\n\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\n\t\t}\n\n \n\n\t\tpublic String next() {\n\n\t\t\treturn readString();\n\n\t\t}\n\n \n\n\t\tpublic interface SpaceCharFilter {\n\n\t\t\tpublic boolean isSpaceChar(int ch);\n\n\t\t}\n\n\t}\n\n\t\n\n \n\nstatic class OutputWriter {\n\n\t\tprivate final PrintWriter writer;\n\n \n\n\t\tpublic OutputWriter(OutputStream outputStream) {\n\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\n\t\t}\n\n \n\n\t\tpublic OutputWriter(Writer writer) {\n\n\t\t\tthis.writer = new PrintWriter(writer);\n\n\t\t}\n\n \n\n\t\tpublic void print(Object...objects) {\n\n\t\t\tfor (int i = 0; i < objects.length; i++) {\n\n\t\t\t\tif (i != 0)\n\n\t\t\t\t\twriter.print(' ');\n\n\t\t\t\twriter.print(objects[i]);\n\n\t\t\t}\n\n\t\t}\n\n \n\n\t\tpublic void printLine(Object...objects) {\n\n\t\t\tprint(objects);\n\n\t\t\twriter.println();\n\n\t\t}\n\n \n\n\t\tpublic void close() {\n\n\t\t\twriter.close();\n\n\t\t}\n\n \n\n\t\tpublic void flush() {\n\n\t\t\twriter.flush();\n\n\t\t}\n\n \n\n\t\t}\n\n \n\n    static class IOUtils {\n\n \n\n\t\tpublic static int[] readIntArray(InputReader in, int size) {\n\n\t\t\tint[] array = new int[size];\n\n\t\t\tfor (int i = 0; i < size; i++)\n\n\t\t\t\tarray[i] = in.readInt();\n\n\t\t\treturn array;\n\n\t\t}\n\n    }\n\n    static long n, k;\n\n    static OutputWriter out;\n\n    static InputReader in;\n\n    static int[] a;\n\n    public static void main (String[] args) throws java.lang.Exception\n\n\t{\n\n\t    out = new OutputWriter(System.out);\n\n\t\tin = new InputReader(System.in);\n\n        n = Long.parseLong(in.readString());\n\n        k = Long.parseLong(in.readString());\n\n        long low = 1; long high = n+1;\n\n        long sum = get(n);\n\n        if(sum<k)out.printLine(0); \n\n        else {\n\n            while(low < high){\n\n            long mid = (low+high)/2;\n\n            long sum1 = get(mid); long sum2 = get(mid-1); long sum3 = get(mid+1);\n\n            if(sum1>=k && (sum2<k||mid==1)){out.print(n-mid+1); break;}\n\n            else if(sum1<k && sum3>=k){out.print(n-mid); break;}\n\n            else if(sum1>=k)high = mid;\n\n            else if(sum1<k)low = mid+1;\n\n            }\n\n        }\n\n        out.flush();\n\n        out.close();\n\n\t}\n\n\t\n\n\tpublic static long get(long mid){\n\n\t    long x = mid;\n\n\t    long t = 0;\n\n\t    while(x>0){t+=x%10; x/=10;}\n\n\t    return mid-t;\n\n\t}\n\n\tpublic static long count(int j){\n\n\t    long sum = 0; int i = j;\n\n\t    while(i<n && a[i++]==a[j])sum++;\n\n\t    return sum;\n\n\t}\n\n\t\n\n\tpublic static int function(){\n\n\t    int min = Integer.MAX_VALUE;\n\n\t    int sum = 0;\n\n\t    int index = 0;\n\n\t    for(int i=0; i<n; i++){if(min>a[i]){min=a[i]; index = i; sum=0;} else if(min==a[i])sum++;}\n\n\t    a[index] = Integer.MAX_VALUE;\n\n\t    if(sum>=3)return (sum*(sum-1)*(sum-2))/3;\n\n\t    return sum;\n\n\t}\n\n\t\n\n\tpublic static void add(int index, int value, int[] b){\n\n\t    while(index < b.length){\n\n\t        b[index] += value;\n\n\t        index = index + (index & (-index));\n\n\t    }\n\n\t}\n\n\t\n\n\tpublic static int getSum(int index, int [] b){\n\n\t    int sum = 0;\n\n\t    while(index > 0){\n\n\t        sum += b[index];\n\n\t        index = index - (index&(-index));\n\n\t    }\n\n\t    return sum;\n\n\t}\n\n\t\n\n\tpublic static void printArray(int[] a){\n\n\t    for(int i=1; i<a.length; i++)out.print(a[i]+\" \");\n\n\t    out.printLine(\"---------\");\n\n\t}\n\n\t\n\n\tstatic class Pair implements Comparable<Pair>{\n\n\t    int s;\n\n\t    //int d;\n\n\t    int len;\n\n\t    public Pair(int a, int c){\n\n\t        s = a; len = c;\n\n\t    }\n\n\t    public int compareTo(Pair p){\n\n\t        if(this.len > p.len)return 1;\n\n\t        else if(this.len < p.len)return -1;\n\n\t        return 0;\n\n\t    }\n\n\t}\n\n}", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer st = new StringTokenizer(\"\");\n    \n    int INF = Integer.MAX_VALUE >> 1;\n    \n    void run() throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        \n        /* Input */\n        int x0 = nextInt();\n        int y0 = nextInt();\n        int N = nextInt();\n        int FULL_MASK = (1 << N) - 1;\n        int[] xs = new int [N];\n        int[] ys = new int [N];\n        for (int i = 0; i < N; i++) {\n            xs[i] = nextInt();\n            ys[i] = nextInt();\n        }\n        \n        /* Precalc */\n        int[][] dist = new int [N][N];\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                dist[i][j] = dist(x0, y0, xs[i], ys[i]) + dist(xs[i], ys[i], xs[j], ys[j]) + dist(xs[j], ys[j], x0, y0);\n        \n        /* DP */\n        int[] dp = new int [1 << N];\n        int[] pr = new int [1 << N];\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n        for (int mask = 0; mask < FULL_MASK; mask++) {\n            int i = Integer.numberOfTrailingZeros(~mask); // hack: use first non-zero bit\n            int imask = mask | (1 << i);\n            for (int j = i; j < N; j++) {\n                int jmask = mask | (1 << j);\n                if (jmask == mask) continue;\n                int ijmask = imask | jmask;\n                int nval = dp[mask] + dist[i][j];\n                if (dp[ijmask] > nval) {\n                    dp[ijmask] = nval;\n                    pr[ijmask] = mask;\n                }\n            }\n        }\n        \n        /* Output */\n        out.println(dp[FULL_MASK]);\n        out.print(\"0\");\n        for (int mask = FULL_MASK; mask != 0; mask = pr[mask]) {\n            int diff = mask ^ pr[mask];\n            int i = Integer.numberOfTrailingZeros(diff);\n            diff &= ~(1 << i);\n            int j = Integer.numberOfTrailingZeros(diff);\n            if (i != 32) out.print(\" \" + (i + 1));\n            if (j != 32) out.print(\" \" + (j + 1));\n            out.print(\" 0\");\n        }\n        out.println();\n        out.close();\n    }\n    \n    /*************************************************************** \n     * Utility\n     **************************************************************/\n    int dist(int x1, int y1, int x2, int y2) {\n        return sqr(x2 - x1) + sqr(y2 - y1);\n    }\n\n    int sqr(int x) {\n        return x * x;\n    }\n\n    /*************************************************************** \n     * Input \n     **************************************************************/\n    String nextToken() throws IOException {\n        while (!st.hasMoreTokens())\n            st = new StringTokenizer(in.readLine());\n        return st.nextToken();\n    }\n    \n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.util.Arrays;\n\n/**\n * @author piuspratik (Piyush Das)\n */\npublic class TaskA {\n\n    class Contest implements Comparable<Contest>\n\n    {\n        int problems;\n        int penalty;\n\n        Contest (int problems, int penalty) {\n            this.problems = problems;\n            this.penalty = penalty;\n        }\n\n        public int compareTo(Contest contest) {\n            if(problems != contest.problems) return contest.problems - problems;\n            return penalty - contest.penalty;\n\n\n        }\n    }\n\n    void run(){\n        int n = nextInt(), k = nextInt();\n        Contest[] c = new Contest[n];\n        for(int i = 0; i < n; i++) {\n            c[i] = new Contest(nextInt(), nextInt());\n        }\n\n        Arrays.sort(c);\n        int cproblem = c[k - 1].problems, cpenalty = c[k - 1].penalty;\n\n        int ans = 0;\n        for(int i = 0; i < n; i++) {\n            if(c[i].problems == cproblem && c[i].penalty == cpenalty) ans++;\n        }\n\n        System.out.println(ans);\n    }\n\n    int nextInt(){\n        try{\n            int c = System.in.read();\n            if(c == -1) return c;\n            while(c != '-' && (c < '0' || '9' < c)){\n                c = System.in.read();\n                if(c == -1) return c;\n            }\n            if(c == '-') return -nextInt();\n            int res = 0;\n            do{\n                res *= 10;\n                res += c - '0';\n                c = System.in.read();\n            }while('0' <= c && c <= '9');\n            return res;\n        }catch(Exception e){\n            return -1;\n        }\n    }\n\n    long nextLong(){\n        try{\n            int c = System.in.read();\n            if(c == -1) return -1;\n            while(c != '-' && (c < '0' || '9' < c)){\n                c = System.in.read();\n                if(c == -1) return -1;\n            }\n            if(c == '-') return -nextLong();\n            long res = 0;\n            do{\n                res *= 10;\n                res += c-'0';\n                c = System.in.read();\n            }while('0' <= c && c <= '9');\n            return res;\n        }catch(Exception e){\n            return -1;\n        }\n    }\n\n    double nextDouble(){\n        return Double.parseDouble(next());\n    }\n\n    String next(){\n        try{\n            StringBuilder res = new StringBuilder(\"\");\n            int c = System.in.read();\n            while(Character.isWhitespace(c))\n                c = System.in.read();\n            do{\n                res.append((char)c);\n            }while(!Character.isWhitespace(c=System.in.read()));\n            return res.toString();\n        }catch(Exception e){\n            return null;\n        }\n    }\n\n    String nextLine(){\n        try{\n            StringBuilder res = new StringBuilder(\"\");\n            int c = System.in.read();\n            while(c == '\\r' || c == '\\n')\n                c = System.in.read();\n            do{\n                res.append((char)c);\n                c = System.in.read();\n            }while(c != '\\r' && c != '\\n');\n            return res.toString();\n        }catch(Exception e){\n            return null;\n        }\n    }\n\n    public static void main(String[] args){\n        new TaskA().run();\n    }\n\n}\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong();\n        long k = in.nextLong();\n        long disc = (long)(Math.sqrt(9 - 4 * (-2 * n - 2 * k)));\n        long x = (-3 + disc) / 2;\n        System.out.println(n - x);\n    }\n}", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import static java.lang.Math.max;\nimport static java.lang.Math.min;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tprivate void solve() throws IOException {\n\t\tint senators = nextInt();\n\t\tint candies = nextInt();\n\t\tscoreA = nextInt();\n\t\tlvl = new int[senators];\n\t\tunloyal = new int[senators];\n\t\tfor (int i = 0; i < senators; i++) {\n\t\t\tlvl[i] = nextInt();\n\t\t\tunloyal[i] = 10 - nextInt() / 10;\n\t\t}\n\t\tn = senators;\n\t\tgive = new int[n];\n\t\tres = 0;\n\t\tgo(0, candies);\n\t\tout.println(res);\n\t}\n\n\tstatic double res;\n\tstatic int[] lvl;\n\tstatic int[] unloyal;\n\tstatic int[] give;\n\tstatic int n;\n\tstatic int scoreA;\n\n\tstatic double probability() {\n\t\tdouble res = 0;\n\t\tfor (int mask = 0; mask < 1 << n; mask++) {\n\t\t\tdouble p = 1;\n\t\t\tint scoreB = 0;\n\t\t\tint cntGood = Integer.bitCount(mask);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint cnt = unloyal[i] - give[i];\n\t\t\t\tif ((mask & (1 << i)) == 0) {\n\t\t\t\t\tscoreB += lvl[i];\n\t\t\t\t\tp *= cnt * .1;\n\t\t\t\t} else {\n\t\t\t\t\tp *= (10 - cnt) * .1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (2 * cntGood > n) {\n\t\t\t\tres += p;\n\t\t\t} else {\n\t\t\t\tres += p * scoreA / (scoreA + scoreB);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic void go(int man, int candies) {\n\t\tif (man == n) {\n\t\t\tres = max(res, probability());\n\t\t\treturn;\n\t\t}\n\t\tgive[man] = 0;\n\t\tgo(man + 1, candies);\n\t\tfor (int i = 1; i <= min(unloyal[man], candies); i++) {\n\t\t\tgive[man] = i;\n\t\t\tgo(man + 1, candies - i);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tnew B().solve();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(239);\n\t\t}\n\t}\n\n\tstatic BufferedReader br;\n\tstatic StringTokenizer st;\n\tstatic PrintWriter out;\n\n\tstatic String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class CF817C {\n    public static void main(String[] args) throws IOException {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n        pw.println(countBigNums(sc.nextLong(), sc.nextLong()));\n        pw.flush();\n    }\n\n    static long countBigNums(long n, long s) {\n        long lo = 1, hi = n;\n        while (lo <= hi) {\n            long mid = (lo + hi) / 2;\n            long v = mid - sumDigits(mid);\n            if (v >= s)\n                hi = mid - 1;\n            else\n                lo = mid + 1;\n        }\n        return n - lo + 1;\n    }\n\n    static int sumDigits(long v) {\n        return String.valueOf(v).chars().map(Character::getNumericValue).sum();\n    }\n\n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n\n        public FastScanner() {\n            this.in = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n\n        public void close() throws IOException {\n            in.close();\n        }\n    }\n}\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\tclass House implements Comparable<House> {\n\t\tint x;\n\t\tint a;\n\n\t\tpublic House(int x, int a) {\n\t\t\tthis.x = x;\n\t\t\tthis.a = a;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(House other) {\n\t\t\treturn x - other.x;\n\t\t}\n\t}\n\n\t// private void solution() throws IOException {\n\t// int t = in.nextInt();\n\t// while (t-- > 0) {\n\t// int n =in.nextInt();\n\t// int m = in.nextInt();\n\t// int x1 = in.nextInt();\n\t// int y1 = in.nextInt();\n\t// int x2 = in.nextInt();\n\t// int y2 = in.nextInt();\n\t//\t\t\t\n\t// }\n\t// }\n\tprivate void solution() throws IOException {\n\t\tint n = in.nextInt();\n\t\tint t = in.nextInt();\n\t\tHouse[] h = new House[n];\n\t\tfor (int i = 0; i < h.length; ++i) {\n\t\t\th[i] = new House(in.nextInt(), in.nextInt());\n\t\t}\n\t\tArrays.sort(h);\n\t\tint res = 2;\n\t\tfor (int i = 0; i < h.length - 1; ++i) {\n\t\t\tdouble dist = h[i + 1].x - h[i + 1].a / 2.0 - (h[i].x + h[i].a / 2.0);\n\t\t\tif (dist >= t) {\n\t\t\t\tif (dist == t) {\n\t\t\t\t\t++res;\n\t\t\t\t} else {\n\t\t\t\t\tres += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(res);\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolution();\n\t\t\tin.reader.close();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\n\tprivate class Scanner {\n\t\tprivate BufferedReader reader;\n\t\tprivate StringTokenizer tokenizer;\n\n\t\tpublic Scanner(Reader reader) {\n\t\t\tthis.reader = new BufferedReader(reader);\n\t\t\tthis.tokenizer = new StringTokenizer(\"\");\n\t\t}\n\n\t\tpublic boolean hasNext() throws IOException {\n\t\t\twhile (!tokenizer.hasMoreTokens()) {\n\t\t\t\tString next = reader.readLine();\n\t\t\t\tif (next == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\ttokenizer = new StringTokenizer(next);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\thasNext();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\ttokenizer = new StringTokenizer(\"\");\n\t\t\treturn reader.readLine();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Thread(null, new Main(), \"\", 1 << 28).start();\n\t}\n\tPrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\tScanner in = new Scanner(new InputStreamReader(System.in));\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Solution {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer st;\n\n    static class Pair implements Comparable<Pair> {\n        int x, a;\n\n        Pair(int x, int a) {\n            this.x = x;\n            this.a = a;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            // TODO Auto-generated method stub\n            return 0;\n        }\n    }\n\n    boolean isCross(double l1, double r1, double l2, double r2) {\n        double r = min(r1, r2);\n        double l = max(l1, l2);\n        return r > l;\n    }\n\n    boolean check(double xl, double xr, double[] l, double[] r, int n) {\n        boolean ok = false;\n        for (int j = 0; j < n; ++j)\n            ok |= isCross(xl, xr, l[j], r[j]);\n        return ok;\n    }\n\n    void solve() throws IOException {\n        int n = ni();\n        double t = ni();\n        double[] l = new double[n];\n        double[] r = new double[n];\n        for (int i = 0; i < l.length; i++) {\n            double x = ni();\n            double len = ni();\n            l[i] = x - len / 2.0;\n            r[i] = x + len / 2.0;\n        }\n        HashSet<Double> set = new HashSet<Double>();\n        for (int i = 0; i < n; ++i) {\n            double xl = l[i] - t;\n            double xr = l[i];\n            boolean ok = check(xl, xr, l, r, n);\n            if (!ok)\n                set.add(xl);\n            xl = r[i];\n            xr = r[i] + t;\n            ok = check(xl, xr, l, r, n);\n            if (!ok)\n                set.add(xl);\n\n        }\n        out.println(set.size());\n    }\n\n    public Solution() throws IOException {\n        Locale.setDefault(Locale.US);\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        in.close();\n        out.close();\n    }\n\n    String ns() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.valueOf(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.valueOf(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.valueOf(ns());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Solution();\n    }\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\n\npublic class a {\n    public static class Pair implements Comparable<Pair> {\n        int f, s;\n\n        public Pair(int f, int s) {\n            this.f = f;\n            this.s = s;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            return s - o.s;\n        }\n\n    };\n\n    public static void main(String[] args) throws IOException {\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String s[] = in.readLine().split(\" \");\n        long r = Long.parseLong(s[0]);\n        long l = Long.parseLong(s[1]);\n        if (r % 2 == 0) {\n            if (l - r+1 < 3) {\n                out.println(-1);\n            } else {\n                out.println(r + \" \" + (r + 1) + \" \" + (r + 2));\n            }\n        } else {\n            if (l - r+1 < 4) {\n                out.println(-1);\n            } else {\n                out.println((r + 1) + \" \" + (r + 2) + \" \" + (r + 3));\n            }\n\n        }\n        out.close();\n\n    }\n\n}", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class Ok_Simple {\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer;\n\tstatic boolean am[][];\n\tstatic long dp[][];\n\tstatic int n;\n\tpublic static void main(String[] args) throws IOException {\n\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint m;\n\t\tn = NextInt();\n\t\tm = NextInt();\n\t\tam = new boolean[n][n];\n\t\tdp = new long[n][1 << n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tArrays.fill(dp[i], -1);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint a = NextInt() - 1;\n\t\t\tint b = NextInt() - 1;\n\t\t\tam[a][b] = am[b][a] = true;\n\t\t};\n\t\tlong res = 0;\n\t\tfor (int a = 0; a < n; ++a)\n\t\t\tres += solve(a, (1 << a));\n\t\tSystem.out.println(res / 2);\n\t}\n\tprivate static long solve(int b, int mask) {\n\t\tint a = 0;\n\t\tfor (int i = 0 ;i < n; ++i)\n\t\t\tif (((mask >> i) & 1) != 0)\n\t\t\t{\n\t\t\t\ta = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (dp[b][mask] >= 0)\n\t\t\treturn dp[b][mask];\n\t\tlong res = 0;\n\t\tif (am[b][a] && Integer.bitCount(mask) > 2)\n\t\t\tres = 1;\n\t\tfor (int i = a + 1; i < n; ++i)\n\t\t\tif (((mask >> i) & 1) == 0 && am[b][i])\n\t\t\t\tres += solve(i, mask ^ (1 << i));\n\t\treturn dp[b][mask] = res;\n\t}\n\tstatic int NextInt() throws NumberFormatException, IOException {\n\t\treturn Integer.parseInt(NextToken());\n\t}\n\tstatic double NextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(NextToken());\n\t}\n\tstatic long NextLong() throws NumberFormatException, IOException {\n\t\treturn Long.parseLong(NextToken());\n\t}\n\tstatic String NextToken() throws IOException {\n\t\twhile(tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.util.Random;\nimport java.io.InputStream;\n\n/**\n * @author khokharnikunj8\n */\n\npublic class Main {\n    public static void main(String[] args) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                new Main().solve();\n            }\n        }, \"1\", 1 << 26).start();\n    }\n\n    void solve() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E2RotateColumnsHardVersion solver = new E2RotateColumnsHardVersion();\n        int testCount = in.scanInt();\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class E2RotateColumnsHardVersion {\n        int[][] dp;\n        int[] cur;\n\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            int n = in.scanInt();\n            int m = in.scanInt();\n            int[][] ar = new int[n][m];\n            int[][] max = new int[m][2];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    ar[i][j] = in.scanInt();\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) max[i][0] = Math.max(max[i][0], ar[j][i]);\n                max[i][1] = i;\n            }\n            CodeHash.shuffle(max);\n            Arrays.sort(max, (o1, o2) -> -o1[0] + o2[0]);\n            dp = new int[2][1 << n];\n            cur = new int[1 << n];\n            for (int i = 0; i < Math.min(m, n); i++) {\n                Arrays.fill(cur, 0);\n                Arrays.fill(dp[i & 1], 0);\n                for (int j = 0; j < 1 << n; j++) {\n                    for (int k = 0; k < n; k++) {\n                        int sum = 0;\n                        for (int l = 0; l < n; l++) {\n                            if ((j & (1 << l)) != 0) {\n                                sum += (ar[(k + l) % n][max[i][1]]);\n                            }\n                        }\n                        cur[j] = Math.max(cur[j], sum);\n                    }\n                }\n                for (int j = 0; j < (1 << n); j++) {\n                    for (int k = j; ; k = (k - 1) & j) {\n                        dp[i & 1][j] = Math.max(dp[i & 1][j], dp[(i - 1) & 1][k] + cur[j ^ k]);\n                        if (k == 0) break;\n                    }\n                }\n            }\n            out.println(dp[Math.min(n, m) & 1 ^ 1][(1 << n) - 1]);\n        }\n\n    }\n\n    static class CodeHash {\n        public static void shuffle(int[][] ar) {\n            Random rd = new Random(new Random().nextInt());\n            for (int i = 0; i < ar.length; i++) {\n                int index = rd.nextInt(ar.length);\n                int[] temp = ar[i];\n                ar[i] = ar[index];\n                ar[index] = temp;\n            }\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int index;\n        private BufferedInputStream in;\n        private int total;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (index >= total) {\n                index = 0;\n                try {\n                    total = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (total <= 0) return -1;\n            }\n            return buf[index++];\n        }\n\n        public int scanInt() {\n            int integer = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    integer *= 10;\n                    integer += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * integer;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\n\npublic class C {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer tokenizer=  new StringTokenizer(br.readLine());\n\t\tBigInteger left = new BigInteger(tokenizer.nextToken());\n\t\tBigInteger right= new BigInteger(tokenizer.nextToken());\n\t\tBigInteger val= (right.subtract(left)).add(new BigInteger(\"\"+1));\n\t\tif(val.intValue()<3){\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t\t\n\t\t}\n\n\n\t\tBigInteger a, b, c;\n\t\tBigInteger i=left;\n\t\twhile(i.intValue()<=right.intValue()){\n\t\t\tBigInteger temp1=i;  //a\n\t\t\tBigInteger temp2= i.add(new BigInteger(\"\"+1));//b\n\t\t\tBigInteger j=temp2.add(new BigInteger(\"\"+1));\n\t\t\twhile(j.intValue()<=right.intValue()){\n\t\t\t\tBigInteger b1= temp2;\n\t\t\t\tBigInteger b2 =j;\n\t\t\t\tBigInteger b3 = temp1;\n\t\t\t\tBigInteger gcd= b1.gcd(b2);\n\t\t\t\tif(gcd.intValue()==1){\n\t\t\t\t\tBigInteger gcd2 =b2.gcd(b3);\n\t\t\t\t\tif(gcd2.intValue() !=1){\n\t\t\t\t\t\ta=b3;\n\t\t\t\t\t\tb= b1;\n\t\t\t\t\t\tc= b2;\n\t\t\t\t\t\tSystem.out.print(a+\" \"+b+\" \"+c+\" \");\n\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tj=j.add(new BigInteger(\"\"+1));\n\t\t\t}\n\t\t\ti=i.add(new BigInteger(\"\"+1));\n\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.util.Scanner;\n\npublic class p912A {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong A = scan.nextInt(), B = scan.nextInt(), x = scan.nextInt(), y = scan.nextInt(), z = scan.nextInt(),\n\t\t\t\tans = 0;\n\t\tA -= 2 * x + y;\n\t\tB -= 3 * z + y;\n\t\tif (A < 0)\n\t\t\tans -= A;\n\t\tif (B < 0)\n\t\t\tans -= B;\n\t\tSystem.out.println(ans);\n\t}\n\n}\n", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.* ;\nimport java.util.* ;\nimport java.text.* ;\nimport java.math.* ;\nimport static java.lang.Math.min ;\nimport static java.lang.Math.max ;\npublic class Codeshefcode{\n\tpublic static void main(String[] args) throws IOException{\n\t\t// Solver Machine = new Solver() ;\n\t\t// Machine.Solve() ;\n\t\t// Machine.Finish() ;\n\t\tnew Thread(null,new Runnable(){\n\t\t\tpublic void run(){\n\t\t\t\tSolver Machine = new Solver() ;\n\t\t\t\ttry{\n\t\t\t\t\tMachine.Solve() ;\n\t\t\t\t\tMachine.Finish() ;\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\te.printStackTrace() ;\n\t\t\t\t\tSystem.out.flush() ;\n\t\t\t\t\tSystem.exit(-1) ;\n\t\t\t\t}catch(Error e){\n\t\t\t\t\te.printStackTrace() ;\n\t\t\t\t\tSystem.out.flush() ;\n\t\t\t\t\tSystem.exit(-1) ;\n\t\t\t\t}\n\t\t\t}\n\t\t},\"Solver\",1l<<27).start() ;\n\t}\n}\nclass Mod{\n\tstatic long mod=1000000007 ;\n\tstatic long d(long a,long b){ return (a*MI(b))%mod ; }\n\tstatic long m(long a,long b){ return (a*b)%mod ; }\n\tstatic private long MI(long a){ return pow(a,mod-2) ; }\n\tstatic long pow(long a,long b){\n\t\tif(b<0) return pow(MI(a),-b) ;\n\t\tlong val=a ; long ans=1 ;\n\t\twhile(b!=0){\n\t\t\tif((b&1)==1) ans = (ans*val)%mod ; \n\t\t\tval = (val*val)%mod ; \n\t\t\tb/=2 ;\n\t\t}\n\t\treturn ans ;\n\t}\t\n}\nclass pair implements Comparable<pair>{\n\tint x ; int y ;  \n\tpair(int x,int y){ this.x=x ; this.y=y ;} \n\tpublic int compareTo(pair p){\n\t\treturn (this.x<p.x ? -1 : (this.x>p.x ? 1 : (this.y<p.y ? -1 : (this.y>p.y ? 1 : 0)))) ;\n\t}\n}\nclass Solver{\n\tReader ip = new Reader(System.in) ;\t  \n\tPrintWriter op = new PrintWriter(System.out) ;\n\tpublic void Solve() throws IOException{\n\t\tint n = ip.i() ;\n\t\tint a[] = new int[n] ;\n\t\tfor(int i=0 ; i<n ; i++) a[i] = ip.i() ;\n\t\tint num=0 ;\n\t\tfor(int i=0 ; i<n ; i++)\n\t\t\tfor(int j=(i+1) ; j<n ; j++)\n\t\t\t\tif(a[i]>a[j])\n\t\t\t\t\tnum++ ;\n\t\tnum%=2 ;\n\t\tint m = ip.i() ;\n\t\twhile(m--!=0){\n\t\t\tint l = ip.i() ;\n\t\t\tint r = ip.i() ;\n\t\t\tint d = (r-l+1) ;\n\t\t\tint mod = d%4 ;\n\t\t\tint bit ;\n\t\t\tif(mod<=1) bit=0 ; else bit=1 ;\n\t\t\tnum+=bit ;\n\t\t\tnum%=2 ;\n\t\t\tpln(num==1 ? \"odd\" : \"even\") ;\n\t\t}\n\t}\n\tvoid Finish(){\n\t\top.flush();\n\t\top.close();\n\t}\n\tvoid p(Object o){\n\t\top.print(o) ;\n\t}\n\tvoid pln(Object o){\n\t\top.println(o) ;\n\t}\t\t\n}\nclass mylist extends ArrayList<Integer>{}\nclass myset extends TreeSet<Integer>{}\nclass mystack extends Stack<Integer>{}\nclass mymap extends TreeMap<Long,Integer>{}\nclass Reader {\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tReader(InputStream input) {\n\t\treader = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(input) );\n\t\ttokenizer = new StringTokenizer(\"\") ;\n\t}\n\tString s() throws IOException {\n\t\twhile (!tokenizer.hasMoreTokens()){\n\t\t\ttokenizer = new StringTokenizer(\n\t\t\treader.readLine()) ;\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\tint i() throws IOException {\n\t\treturn Integer.parseInt(s()) ;\n\t}\n\tlong l() throws IOException{\n\t\treturn Long.parseLong(s()) ;\n\t}\n\tdouble d() throws IOException {\n\t\treturn Double.parseDouble(s()) ;\n\t}\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import static java.lang.Math.*; \nimport java.io.*; \nimport java.util.*; \n\npublic class A {\n\tBufferedReader in; \n\tPrintWriter out;\n\tStringTokenizer st; \n\n\n\tpublic String next() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t} catch(Exception e) {}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next()); \n\t}\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tboolean bit(int m, int i) {\n\t\treturn (m & (1 << i)) > 0; \n\t}\n\n\tint n, x, y, c;  \n \n \tlong cnt(int m) {\n \t\tlong ret=0;\n \t\tfor (int i=max(1, y-m); i<=min(n, y+m); i++) {\n \t\t\tint x1 = max(1, x - (m - abs(i - y)));\n \t\t\tint x2 = min(n, x + (m - abs(i - y)));\n \t\t\tret += x2 - x1 + 1; \n \t\t}\n \t\treturn ret;\n \t}\n\n\tpublic void run() {\n\t\tin  = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tn = nextInt(); \n\t\tx = nextInt(); \n\t\ty = nextInt(); \n\t\tc = nextInt();\n\n\t\tint l = 0, r = 1000000;\n\t\tint ans=0;\n\t\twhile (l <= r) {\n\t\t\tint m = (l+r) / 2; \n\t\t\tif (cnt(m) >= c) {\n\t\t\t\tans = m; \n\t\t\t\tr = m-1; \n\t\t\t} else l=m+1; \n\t\t} \n\n\t\tout.println(ans);\n\n\t\tout.close(); \n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tlong x,y; \n\t\tpublic Pair(long x, long y) {\n\t\t\tthis.x=x; \n\t\t\tthis.y=y; \n\t\t}\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (x != o.x) return sign(o.x - x); \n\t\t\treturn sign(y - o.y); \n\t\t}\n\t}\n\n\tint sign(long x) {\n\t\tif (x < 0) return -1; \n\t\tif (x > 0) return 1; \n\t\treturn 0;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew A().run(); \t\t\n\t}\n}", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main3 {\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        //BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int N = sc.nextInt();\n        String S = sc.next();\n        HashSet<Character> unique = new HashSet<>();\n        for(char c : S.toCharArray()){\n            unique.add(c);\n        }\n        int number = unique.size();\n\n        Hashtable<Character, Integer> indexes = new Hashtable<>();\n        TreeSet<Integer> tree = new TreeSet<>();\n\n        int min = N+1;\n        int total = 0;\n        for(int i = 0; i<N; i++){\n            char c = S.charAt(i);\n            if(!indexes.containsKey(c)){\n                total++;\n                indexes.put(c, i);\n                tree.add(i);\n            }\n            else{\n                int old = indexes.get(c);\n                indexes.put(c, i);\n                tree.remove(old);\n                tree.add(i);\n            }\n\n            if(total == number){\n                int dist = tree.last() - tree.first() + 1;\n                min = Math.min(dist, min);\n            }\n        }\n\n        System.out.println(min);\n    }\n}\n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        \n        int n = s.nextInt();\n        int m = s.nextInt();\n        int k = s.nextInt();\n        \n        int a[] = new int [n];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = s.nextInt();\n        }\n        int ans = 0;\n        \n        while(k < m){\n            k--;\n            int max = -1;\n            int ix = -1;\n            for (int i = 0; i < a.length; i++) {\n                if(a[i] > max){\n                    max = a[i];\n                    ix = i;\n                }\n            }\n            if(ix == -1){\n                System.out.println(\"-1\");\n                return ;\n            }\n            k += a[ix];\n            a[ix] = -1;\n            ans++;\n        }\n        System.out.println(ans);\n    }\n\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class A {\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputReader sc = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint n = sc.nextInt();\n\n\t\tif(n < 3)\n\t\t\tout.println(n);\n\t\telse\n\t\t{\n\t\t\tif((n & 1) == 1)\n\t\t\t\tout.println(lcm(n, lcm(n - 1, n - 2)));\n\t\t\telse\n\t\t\t\tout.println(Math.max(lcm(n - 1, lcm(n - 2, n - 3)), lcm(n, lcm(n - 1, n - 3))));\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic long gcd(long a, long b) \n\t{ \n\t\twhile(b != 0)\n\t\t{\n\t\t\ta = a%b;\n\t\t\tb ^= a;\n\t\t\ta ^= b;\n\t\t\tb ^= a;\n\t\t}\n\t\treturn a;\n\n\t}\n\n\tstatic long lcm(long a, long b) { return a / gcd(a,b) * b; }\n}\n\n\n\nclass InputReader {\n\tprivate BufferedReader reader;\n\tprivate StringTokenizer tokenizer;\n\n\tpublic InputReader(InputStream stream) {\n\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n}", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.*; \nimport java.util.*; \nimport java.util.Map.*;\nimport java.math.*;\n//import java.lang.*;\n\npublic class q1 \n{ \n    static int MOD=1000000007;\n    static class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[1000000]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    }\n    \n    static boolean isPrime(int n) \n    { \n        if (n <= 1) \n            return false; \n        if (n <= 3) \n            return true; \n        if (n % 2 == 0 || n % 3 == 0) \n            return false; \n      \n        for (int i = 5; i * i <= n; i = i + 6) \n            if (n % i == 0 ||  n % (i + 2) == 0) \n                return false; \n      \n        return true; \n    } \n    static int gcd(int a, int b) \n    { \n      if (b == 0) \n        return a; \n      return gcd(b, a % b);  \n    } \n    //Functions\n\n\n\n    \n    public static void main(String[] args) throws IOException \n    { \n       Scanner sc=new Scanner(System.in); \n       //int T=sc.nextInt();\n       int T=1;\n       while(T-- > 0){\n           int N=sc.nextInt();\n           int a[]=new int[N];\n           int count=0;\n           int ans=0;\n           boolean flag=false;\n\n           for(int i=0;i<N;++i){\n               a[i]=sc.nextInt();\n           }\n           Arrays.sort(a);\n           for(int i=0;i<N;++i){\n               if(a[i]==-1)\n                continue;\n            for(int j=i+1;j<N;++j){\n                if(a[j]%a[i]==0 && a[j]!=-1){\n                    a[j]=-1;;\n                }\n            }\n           }\n           //int i=0;\n           for(int i=0;i<N;++i){\n               if(a[i]!= -1)\n               count++;\n           }\n\n           System.out.println(count);\n        } // End of test cases loop \n\n        \n    }//end of main function\n    \n    \n} //end of class", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * Created by huhansan on 2017/12/19.\n * http://codeforces.com/problemset/problem/11/D\n * \u53c2\u8003 Petr http://codeforces.com/contest/11/submission/47646\n * \u6c42\u6240\u6709\u4e0d\u540c\u7684\u73af\u7684\u4e2a\u6570\n * \u9996\u5148\u6309\u957f\u5ea6\u5206 C = C1+C2+...+Cn\n * \u957f\u5ea6\u4e3ai\u7684\u73af\u7684\u6570\u91cf\u7684\u6c42\u89e3\uff0c \u89c4\u5b9a\u4e00\u4e2a\u987a\u5e8f\uff0c\u4ee5\u6700\u5c0f\u503c\u5f00\u5934\uff0c\u6309\u5f00\u5934\u4e0d\u540c\u5206\u6cbb\uff0c\u518d\u6309\u4e0d\u540c\u7ed3\u5c3e\u5206\u6cbb\n * \u904d\u5386\u6240\u6709\u6392\u5217\uff0c\u5982\u679c\u957f\u5ea6\u4e3ai\u7684\u6392\u5217\u6210\u73af\uff0c\u5219\u5bf9\u5e94\u7684Ci\u503c+1\n * \u904d\u5386\u65b9\u5f0f\u7684\u9009\u62e9\uff1a\n * 1.integer\u5b9e\u73b0bitmask\uff0c\u4ece1\u52a0\u52301<<n\n * 2.\u9012\u5f52\n */\n\npublic class CF_11D {\n    long[][] ways;  //ways[mask][endPointIndex]\n    boolean[][] connect;\n    int n, m, lowestIndex, mask;    //n \u8282\u70b9\u6570\uff0c m\u8fb9\u6570    00000...0  <--> n:n-1:n-2.....1 bitmask\n    private static int HEAD_POINT_INDEX = 0;\n\n    public void solve() throws Exception {\n        int a, b;\n        long total = 0;\n        n = nextInt();\n        m = nextInt();\n        connect = new boolean[n][n];\n        ways = new long[1 << n][n];\n        for (int i = 0; i < m; i++) {\n            a = nextInt();\n            b = nextInt();\n            connect[a - 1][b - 1] = true;\n            connect[b - 1][a - 1] = true;\n        }\n        for (int i = 0; i < n; i++) {\n            ways[1 << i][i] = 1;  //\u521d\u59cb\u5316\uff0c\u5355\u5b9a\u70b9\u4e5f\u89c6\u4e3a\u73af\n        }\n        for (mask = 1; mask < 1 << n; mask++) {\n            int tmp = mask, cnt = 0;\n            while (tmp > 0) {\n                tmp = tmp & (tmp - 1);\n                cnt++;\n            }\n            lowestIndex = -1;\n            for (int endPointIndex = 0; endPointIndex < n; endPointIndex++) {\n                if ((mask & 1 << endPointIndex) != 0) {\n                    if (lowestIndex < 0) {\n                        lowestIndex = endPointIndex;\n                    } else if (lowestIndex != endPointIndex) {\n                        for (int i = lowestIndex; i < n; i++)\n                            if (connect[i][endPointIndex]) {\n                                ways[mask][endPointIndex] += ways[mask & ~(1 << endPointIndex)][i]; // P[(1,2,3)4]\u7684\u6570\u91cf == \u5176\u5b83+P[1,2,3]\u7684\u6570\u91cf\uff0c \u4e5f\u5c31\u662f1,2,3\u4e09\u4e2a\u70b9\u53ef\u4ee5\u7ec4\u6210\u7684\u4ee51\u5f00\u5934\u7684\u6392\u5217\u6570\n                            }\n                        if (connect[endPointIndex][lowestIndex] && cnt > 2) {  //\u4ee5\u9996\u5c3e\u5b9a\u70b9\u5206\u6cbb\uff0c\u5b58\u5728\u5bf9\u79f0\u6027\uff0c\u5982 1-2-3-4-1 == 1-4-3-2-1\n                            total += ways[mask][endPointIndex];\n                        }\n                    }\n                }\n            }\n        }\n        writer.println(total / 2);\n    }\n\n    public static void main(String[] args) {\n        new CF_11D().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakhar897\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            String arr1[] = new String[n];\n            String arr2[] = new String[n];\n            int i, j, count = 0;\n            for (i = 0; i < n; i++) {\n                arr1[i] = in.nextString();\n            }\n            for (i = 0; i < n; i++) {\n                arr2[i] = in.nextString();\n                for (j = 0; j < n; j++) {\n                    if (arr2[i].equals(arr1[j])) {\n                        arr1[j] = \"\";\n                        count++;\n                        break;\n                    }\n                }\n            }\n            out.println(n - count);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\npublic class Two {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        int t;\n        //t = in.nextInt();\n        t = 1;\n        while (t > 0) {\n            solver.call(in,out);\n            t--;\n        }\n        out.close();\n    }\n\n    static class TaskA {\n        public void call(InputReader in, PrintWriter out) {\n            int n = 14 ;\n            long c , a = Long.MIN_VALUE, b = 0;\n            long[] arr = new long[n];\n            long[] array = new long[n];\n\n            for (int i = 0; i < n; i++) {\n                arr[i] = in.nextLong();\n            }\n\n            for (int i = 0; i < n; i++) {\n                array[i] = arr[i];\n            }\n\n            for (int i = 0; i < n; i++) {\n                array[i]=0;\n                if(arr[i]==0)\n                    continue;\n\n                if(arr[i]<14){\n                    for (int j = 1; j <= arr[i]; j++) {\n                        array[(i+j)%14] ++;\n                    }\n\n                }\n                else {\n                    c = arr[i]/14;\n                    for (int j = 1; j <= n; j++) {\n                        array[(i+j)%14] +=c;\n                    }\n                    c = arr[i]%14;\n                    for (int j = 1; j <= c; j++) {\n                        array[(i+j)%14] ++;\n                    }\n\n                }\n\n                for (int j = 0; j < 14; j++) {\n                    if(array[j]%2==0){\n                        b+=array[j];\n                    }\n                }\n\n                for (int j = 0; j < n; j++) {\n                    array[j] = arr[j];\n                }\n\n                a = Math.max(a,b);\n                b = 0;\n\n            }\n\n            out.println(a);\n\n        }\n    }\n\n    static class answer implements Comparable<answer>{\n        int a, b;\n\n        public answer(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n\n        @Override\n        public int compareTo(answer o) {\n            return this.a - o.a;\n        }\n    }\n\n\n    static long lcm(long a , long b){\n        return (a/gcd(a,b)) *b;\n    }\n\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b,  a % b);\n    }\n\n\n    static final Random random=new Random();\n    static void shuffleSort(int[] arr) {\n        int n = arr.length;\n        for (int i=0; i<n; i++) {\n\n            int a=random.nextInt(n), temp=arr[a];\n            arr[a]=arr[i];\n            arr[i]=temp;\n\n        }\n\n        Arrays.sort(arr);\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n\n    }\n}", "complexity": "constant", "problem": "0975_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "import java.util.Scanner;\n\npublic class ToyArmy {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong n = sc.nextLong();\n\t\tSystem.out.println(n / 2 + n);\n\t}\n}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class LCMChallenge\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\t\n\t\tif(n < 3)\n\t\t{\n\t\t\tSystem.out.println(n);\n\t\t}\n\t\telse if(n % 2 == 1)\n\t\t{\n\t\t\tSystem.out.println((long)n * (n - 1) * (n - 2));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(n % 3 != 0)\n\t\t\t{\n\t\t\t\tSystem.out.println((long)n * (n - 1) * (n - 3));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println((long)(n - 1) * (n - 2) * (n - 3));\n\t\t\t}\n\t\t}\n\t}\n}\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.Locale;\n\npublic class E16 {\n\n    static StreamTokenizer in;\n    static PrintWriter out;\n    \n    static int nextInt() throws IOException {\n        in.nextToken();\n        return (int)in.nval;\n    }\n    \n    static double nextDouble() throws IOException {\n        in.nextToken();\n        return in.nval;\n    }\n    \n    static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        \n        n = nextInt();\n        t = 1 << n;\n        m = new double[n][n];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                m[i][j] = nextDouble();\n        \n        memo = new double[t];\n        Arrays.fill(memo, Double.POSITIVE_INFINITY);\n        for (int i = 0; i < n; i++) out.print(String.format(Locale.US, \"%.6f\", solve(1 << i)) + \" \");\n        out.println();\n        \n        out.flush();\n    }\n    \n    static int n, t;\n    static double[][] m;\n    static double[] memo;\n    \n    static double solve(int mask) {\n        if (memo[mask] != Double.POSITIVE_INFINITY) return memo[mask];\n        if (mask == t-1) return memo[mask] = 1;\n        \n        int k = Integer.bitCount(mask);\n        k = (k+1)*k/2;\n        double res = 0;\n        for (int i = 0; i < n; i++) if ((mask&(1 << i)) != 0)\n            for (int j = 0; j < n; j++) if ((mask&(1 << j)) == 0)\n                res += m[i][j]*solve(mask|(1 << j));\n        \n        return memo[mask] = res/k;\n    }\n}\n\n\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Berland{\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException\n\t{\n\t\tnew Berland().run();\n\t}\n\t\n\tpublic void run() throws NumberFormatException, IOException\n\t{\n\t\tBufferedReader file = new BufferedReader(new InputStreamReader(System.in));\n\t\tlong N = Long.parseLong(file.readLine());\n\t\tlong[] cutoff = new long[13];\n\t\tcutoff[0] = 0;\n\t\tfor(int i = 1;i<=12;i++)\n\t\t{\n\t\t\tcutoff[i] = cutoff[i-1] + (long)(9*Math.pow(10,i-1))*i;\n\t\t}\n\t\tint dig = -1;\n\t\tfor(int i = 0;i<12;i++)\n\t\t{\n\t\t\tif(cutoff[i]>=N)\n\t\t\t{\n\t\t\t\tdig = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlong sub = N - cutoff[dig-1]-1;\n\t\tlong num = (sub)/dig;\n\t\tlong number = (long)Math.pow(10,dig-1)+num;\n\t\tint pos = (int)(sub % dig);\n\t\tSystem.out.println((number+\"\").charAt(pos));\n\t}\t\n}\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class hamm{\npublic static void main(String args[]) throws IOException{\nBufferedReader lector = new BufferedReader(new InputStreamReader(System.in));\nint c = Integer.parseInt(lector.readLine());\nString a = lector.readLine();\nString b = lector.readLine();\nint ham = 0;\nint ha[][][] = new int[2][26][26];\nboolean use[][] = new boolean[2][26];\nboolean encontro = false;\nboolean pare = false;\nint ea = -1,eea=-1;\nint eb = -1,eeb=-1;\nfor(int n = 0;n<a.length();n++){\nif(a.charAt(n)!=b.charAt(n)){\nint aa = (int)(a.charAt(n)-'a');\nint bb = (int)(b.charAt(n)-'a');\nham++;\nif(use[1][aa] || use[0][bb]){\nboolean entre = false;\nif(ha[1][aa][bb]!=0 || ha[0][bb][aa]!=0){\npare = true;\nentre = true;\neeb = n+1;\nif(ha[1][aa][bb]!=0)\neea = ha[1][aa][bb];\nelse\neea = ha[0][bb][aa];\n}else\nencontro = true;\n//System.out.println(\"A \"+(n+1)+\" \"+ha[1][aa][bb]);\nif(encontro){\neb = n+1;\nif(use[1][aa]){\nfor(int nn = 0;nn<ha[1][aa].length;nn++)\nif(ha[1][aa][nn]!=0)\nea = ha[1][aa][nn];\n}else{\nfor(int nn = 0;nn<ha[0][bb].length;nn++)\nif(ha[0][bb][nn]!=0)\nea = ha[0][bb][nn];\n}\n}\n}\n\n//jod1.get(aa).pos[bb]=n+1;//new p((int)b.charAt(n),n+1));\n//jod2.get(bb).pos[aa]=n+1;//new p((int)a.charAt(n),n+1));\nha[0][aa][bb]=n+1;\nha[1][bb][aa]=n+1;\nuse[0][aa]=true;\nuse[1][bb]=true;\n}\n}\nif(pare)\nham-=2;\nelse if(encontro)\nham--;\nSystem.out.println(ham);\nif(pare)\nSystem.out.println(eea+\" \"+eeb);\nelse\nSystem.out.println(ea+\" \"+eb);\n}\n}\n", "complexity": "linear", "problem": "0527_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import java.util.*;\nimport java.util.Scanner;\nimport java.io.*;\nimport javax.lang.model.util.ElementScanner6; \nimport static java.lang.System.out;\nimport java.util.Stack;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class B913\n{\n\n   \n    \n    public static void main(String args[])\n    {  \n\n        FastReader in=new FastReader();\n        PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int tc=1;\n     \n        //tc=in.nextInt();\n        while(tc-->0)\n        {\n            \n        \tint n=in.nextInt();\n\t\t\tint parent[]=new int[n+1];\n\t\t\tint deg[]=new int[n+1];\n\t\t\tboolean isNonLeaf[]=new boolean[n+1];\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tparent[i+1]=in.nextInt();\n\t\t\t\tisNonLeaf[parent[i+1]]=true;\n\t\t\t\tdeg[parent[i+1]]++;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=2;i<=n;i++)\n\t\t\t{\n\t\t\t\tif(isNonLeaf[i])\n\t\t\t\t{\n\t\t\t\t\tdeg[parent[i]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flag=true;\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tif(isNonLeaf[i]&&deg[i]<3)\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag)pr.println(\"YES\");\n\t\t\telse pr.println(\"NO\");\n\t\t\t\n\t\t\t\n        \n\n\n\n        }\n        pr.flush();\n    }\n\n\n    \n\n    static void sort(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n\t}\n    \n    \n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n    }\n\n    \n    static class FastReader\n    { \n        BufferedReader br; \n        StringTokenizer st; \n\n        public FastReader() \n        { \n            br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n\n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n\n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n\n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n\n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n        \n        int[] readIntArray(int n)\n        {\n\t\tint a[]=new int[n];\n\t\tfor(int i=0;i<n;i++)a[i]=nextInt();\n\t\treturn a;\n\t}\n\t\t\n\tlong[] readLongArray(int n)\n\t{\n\t\tlong a[]=new long[n];\n\t\tfor(int i=0;i<n;i++)a[i]=nextLong();\n\t\treturn a;\n\t}\n\t\n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n}\n\n\n", "complexity": "linear", "problem": "0913_B", "from": "CODEFORCES", "tags": "implementation,trees"}
{"src": "/**\n\n * DA-IICT\n\n * Author : Savaliya Sagar\n\n */\n\nimport java.io.*;\n\nimport java.math.*;\n\nimport java.util.*;\n\n\n\npublic class D276 {\n\n\tInputStream is;\n\n\tPrintWriter out;\n\n\tlong l,r;\n\n\tvoid solve() {\n\n\t\tlong l = nl();\n\n\t\tlong r = nl();\n\n\t\tout.println(Math.max(0,Long.highestOneBit(l^r)*2-1));\n\n\t}\n\n\n\n\tvoid run() throws Exception {\n\n\t\tString INPUT = \"/media/sagar407/D/java workspace/11Input_output/input.txt\";\n\n\t\tis = oj ? System.in : new FileInputStream(INPUT);\n\n\t\tout = new PrintWriter(System.out);\n\n\n\n\t\tlong s = System.currentTimeMillis();\n\n\t\tsolve();\n\n\t\tout.flush();\n\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\n\t}\n\n\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tnew Thread(null, new Runnable() {\n\n\t\t\tpublic void run() {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tnew D276().run();\n\n\t\t\t\t} catch (Exception e) {\n\n\t\t\t\t\te.printStackTrace();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}, \"1\", 1 << 26).start();\n\n\t}\n\n\n\n\tprivate byte[] inbuf = new byte[1024];\n\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\n\n\tprivate int readByte() {\n\n\t\tif (lenbuf == -1)\n\n\t\t\tthrow new InputMismatchException();\n\n\t\tif (ptrbuf >= lenbuf) {\n\n\t\t\tptrbuf = 0;\n\n\t\t\ttry {\n\n\t\t\t\tlenbuf = is.read(inbuf);\n\n\t\t\t} catch (IOException e) {\n\n\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t}\n\n\t\t\tif (lenbuf <= 0)\n\n\t\t\t\treturn -1;\n\n\t\t}\n\n\t\treturn inbuf[ptrbuf++];\n\n\t}\n\n\n\n\tprivate boolean isSpaceChar(int c) {\n\n\t\treturn !(c >= 33 && c <= 126);\n\n\t}\n\n\n\n\tprivate int skip() {\n\n\t\tint b;\n\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\n\t\t\t;\n\n\t\treturn b;\n\n\t}\n\n\n\n\tprivate double nd() {\n\n\t\treturn Double.parseDouble(ns());\n\n\t}\n\n\n\n\tprivate char nc() {\n\n\t\treturn (char) skip();\n\n\t}\n\n\n\n\tprivate String ns() {\n\n\t\tint b = skip();\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\n\t\t\tsb.appendCodePoint(b);\n\n\t\t\tb = readByte();\n\n\t\t}\n\n\t\treturn sb.toString();\n\n\t}\n\n\n\n\tprivate char[] ns(int n) {\n\n\t\tchar[] buf = new char[n];\n\n\t\tint b = skip(), p = 0;\n\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\n\t\t\tbuf[p++] = (char) b;\n\n\t\t\tb = readByte();\n\n\t\t}\n\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\n\t}\n\n\n\n\tprivate char[][] nm(int n, int m) {\n\n\t\tchar[][] map = new char[n][];\n\n\t\tfor (int i = 0; i < n; i++)\n\n\t\t\tmap[i] = ns(m);\n\n\t\treturn map;\n\n\t}\n\n\n\n\tprivate int[] na(int n) {\n\n\t\tint[] a = new int[n];\n\n\t\tfor (int i = 0; i < n; i++)\n\n\t\t\ta[i] = ni();\n\n\t\treturn a;\n\n\t}\n\n\n\n\tprivate int ni() {\n\n\t\tint num = 0, b;\n\n\t\tboolean minus = false;\n\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\n\t\t\t;\n\n\t\tif (b == '-') {\n\n\t\t\tminus = true;\n\n\t\t\tb = readByte();\n\n\t\t}\n\n\n\n\t\twhile (true) {\n\n\t\t\tif (b >= '0' && b <= '9') {\n\n\t\t\t\tnum = num * 10 + (b - '0');\n\n\t\t\t} else {\n\n\t\t\t\treturn minus ? -num : num;\n\n\t\t\t}\n\n\t\t\tb = readByte();\n\n\t\t}\n\n\t}\n\n\n\n\tprivate long nl() {\n\n\t\tlong num = 0;\n\n\t\tint b;\n\n\t\tboolean minus = false;\n\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\n\t\t\t;\n\n\t\tif (b == '-') {\n\n\t\t\tminus = true;\n\n\t\t\tb = readByte();\n\n\t\t}\n\n\n\n\t\twhile (true) {\n\n\t\t\tif (b >= '0' && b <= '9') {\n\n\t\t\t\tnum = num * 10 + (b - '0');\n\n\t\t\t} else {\n\n\t\t\t\treturn minus ? -num : num;\n\n\t\t\t}\n\n\t\t\tb = readByte();\n\n\t\t}\n\n\t}\n\n\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\n\n\tprivate void tr(Object... o) {\n\n\t\tif (!oj)\n\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\n\t}\n\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author AlexFetisov\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        long n = in.nextInt();\n        long x = in.nextInt();\n        long y = in.nextInt();\n        long c = in.nextInt();\n        if (c == 1) {\n            out.println(0);\n            return;\n        }\n\n        long left = 1, right = 2 * n, middle, res = -1;\n        long val = getNumberOfCells(x, y, n, 2);\n\n        while (left <= right) {\n            middle = (left + right) / 2;\n            long numberOfCells = getNumberOfCells(x, y, n, middle);\n            if (numberOfCells < c) {\n                left = middle + 1;\n            } else {\n                res = middle;\n                right = middle - 1;\n            }\n        }\n        out.println(res);\n    }\n\n    private long getNumberOfCells(long x, long y, long n, long middle) {\n        long res = 0;\n        res += calc(x, y, middle + 1);\n        res += calc(n - x + 1, y, middle + 1);\n        res += calc(x, n - y + 1, middle + 1);\n        res += calc(n - x + 1, n - y + 1, middle + 1);\n        res -= calcX(x, n, middle);\n        res -= calcX(y, n, middle);\n        --res;\n        return res;\n    }\n\n    private long calcX(long x, long n, long size) {\n        long left = x - size;\n        long right = x + size;\n        left = Math.max(left, 1);\n        right = Math.min(right, n);\n        if (left <= right) {\n            return right - left + 1;\n        }\n        return 0;\n    }\n\n    private long calc(long x, long y, long size) {\n        if (size <= Math.min(x, y)) {\n            return (1 + size) * size / 2;\n        }\n        if (size >= x + y - 1) {\n            return x * y;\n        }\n        if (size > Math.max(x, y)) {\n            return x * y - calc(x, y, x + y - 1 - size);\n        }\n        long min = Math.min(x, y);\n        long res = (1 + min) * min / 2;\n        long rest = size - min;\n        res += rest * min;\n        return res;\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer stt;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public String nextString() {\n        while (stt == null || !stt.hasMoreTokens()) {\n            stt = new StringTokenizer(nextLine());\n        }\n        return stt.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n}\n\n", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class CC {\n\tpublic static void main(String[] args)throws Throwable {\n\t\tMyScanner sc=new MyScanner();\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\t\n\t\tint n=sc.nextInt();\n\t\tint r=sc.nextInt();\n\t\tint [] x=new int [n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tx[i]=sc.nextInt();\n\t\tdouble [] ans=new double [n];\n\t\tans[0]=r;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tans[i]=r;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tdouble dx=Math.abs(x[i]-x[j]);\n\t\t\t\tif(dx>2*r)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble y=Math.sqrt((4*r*r)-(dx*dx));\n\t\t\t\tans[i]=Math.max(ans[i], ans[j]+y);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(double z : ans)\n\t\t\tpw.print(z+\" \");\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {while (st == null || !st.hasMoreElements()) {\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (IOException e) {e.printStackTrace();}}\n\t\treturn st.nextToken();}\n\t\tint nextInt() {return Integer.parseInt(next());}\n\t\tlong nextLong() {return Long.parseLong(next());}\n\t\tdouble nextDouble() {return Double.parseDouble(next());}\n\t\tString nextLine(){String str = \"\";\n\t\ttry {str = br.readLine();}\n\t\tcatch (IOException e) {e.printStackTrace();}\n\t\treturn str;}\n\t}\n}", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author Saransh\n */\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.lang.*;\npublic class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        try\n        {\n            Parserdoubt pd=new Parserdoubt(System.in);\n            int t=pd.nextInt();\n            int inde=0,indo=0,o=0,e=0;\n            for(int i=0;i<t;i++)\n            {\n                if(pd.nextInt()%2==0)\n                {\n                    inde=i;\n                    e++;\n                }\n                else\n                {\n                    o++;\n                    indo=i;\n                }\n            }\n            if(o==1)\n            {\n                System.out.println(indo+1);\n            }\n            else\n            {\n                System.out.println(inde+1);\n            }\n        }\n        catch(Exception e){}\n    }\n\n}\n\nclass Parserdoubt\n\t{\n\t   final private int BUFFER_SIZE = 1 << 17;\n\n\t   private DataInputStream din;\n\t   private byte[] buffer;\n\t   private int bufferPointer, bytesRead;\n\n\t   public Parserdoubt(InputStream in)\n\t   {\n\t      din = new DataInputStream(in);\n\t      buffer = new byte[BUFFER_SIZE];\n\t      bufferPointer = bytesRead = 0;\n\t   }\n\t   public String nextString() throws Exception\n\t   {\n\t\t   StringBuffer sb=new StringBuffer(\"\");\n\t\t   byte c = read();\n\t\t   while (c <= ' ') c = read();\n\t\t   do\n\t\t   {\n\t\t\t   sb.append((char)c);\n\t\t\t   c=read();\n\t\t   }while(c>' ');\n\t\t   return sb.toString();\n\t   }\n\t   public char nextChar() throws Exception\n\t   {\n\t\t   byte c=read();\n\t\t   while(c<=' ') c= read();\n\t\t   return (char)c;\n\t   }\n\t   public int nextInt() throws Exception\n\t   {\n\t      int ret = 0;\n\t      byte c = read();\n\t      while (c <= ' ') c = read();\n\t      boolean neg = c == '-';\n\t      if (neg) c = read();\n\t      do\n\t      {\n\t    \t  ret = ret * 10 + c - '0';\n\t         c = read();\n\t      } while (c > ' ');\n\t      if (neg) return -ret;\n\t      return ret;\n\t   }\n\t   public long nextLong() throws Exception\n\t   {\n\t      long ret = 0;\n\t      byte c = read();\n\t      while (c <= ' ') c = read();\n\t      boolean neg = c == '-';\n\t      if (neg) c = read();\n\t      do\n\t      {\n\t    \t  ret = ret * 10 + c - '0';\n\t         c = read();\n\t      } while (c > ' ');\n\t      if (neg) return -ret;\n\t      return ret;\n\t   }\n\t   private void fillBuffer() throws Exception\n\t   {\n\t      bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t      if (bytesRead == -1) buffer[0] = -1;\n\t   }\n\n\t   private byte read() throws Exception\n\t   {\n\t      if (bufferPointer == bytesRead) fillBuffer();\n\t      return buffer[bufferPointer++];\n\t   }\n\t}", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "\nimport com.sun.org.apache.xpath.internal.axes.SubContextList;\nimport java.util.Scanner;\n\n/**\n *\n * @author Madi\n */\npublic class Round42CC {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        String s = sc.nextLine();\n\n        int k = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == 'H') {\n                k++;\n            }\n        }\n\n        s = s + s.substring(0, k);\n        String ss = \"\";\n\n        int max = 0;\n        for (int i = 0; i < s.length() - k; i++) {\n            ss = s.substring(i, i + k);\n            int count = 0;\n            for (int j = 0; j < ss.length(); j++) {\n                if (ss.charAt(j) == 'H') {\n                    count++;\n                }\n            }\n            if (count > max) {\n                max = count;\n            }\n        }\n        \n        System.out.println(k - max);\n    }\n}\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n    static int inf = (int) 1e9 + 7;\n    static int n, m, a[][];\n    static ArrayList<Integer> used;\n    static int num[];\n    static int ans;\n\n    static void rec(int id) {\n        if (id == used.size()) {\n            check();\n            return;\n        }\n\n        for(int i = 0;i < n;i++) {\n            num[id] = i;\n            rec(id + 1);\n        }\n    }\n\n    static void check() {\n        int new_ans = 0;\n        for(int i = 0;i < n;i++) {\n            int max = 0;\n            for(int j = 0;j < used.size();j++) {\n                max = Math.max(max, a[(i + num[j]) % n][used.get(j)]);\n            }\n            new_ans += max;\n        }\n        ans = Math.max(ans, new_ans);\n    }\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n        int test = nextInt();\n        while(test-- > 0) {\n            n = nextInt();\n            m = nextInt();\n            a = new int [n][m];\n            for(int i = 0;i < n;i++) {\n                for(int j = 0;j < m;j++) a[i][j] = nextInt();\n            }\n            used = new ArrayList<>();\n            num = new int [n * m];\n            ans = 0;\n\n            pair b[] = new pair[n * m];\n\n            for(int i = 0;i < n;i++) {\n                for(int j = 0;j < m;j++) {\n                    b[i * m + j] = new pair(a[i][j], j);\n                }\n            }\n\n            Arrays.sort(b, new pair());\n\n            for(int i = b.length - 1;i >= Math.max(0, b.length - 5);i--) {\n                int v = b[i].y;\n\n                boolean bad = false;\n\n                for(int j = 0;j < used.size();j++) if (used.get(j) == v) bad = true;\n\n                if (!bad) used.add(v);\n            }\n\n            rec(0);\n\n            pw.println(ans);\n        }\n        pw.close();\n    }\n\n    static BufferedReader br;\n    static StringTokenizer st = new StringTokenizer(\"\");\n    static PrintWriter pw;\n\n    static String next() throws IOException {\n        while (!st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n}\n\nclass pair implements Comparator<pair>{\n    int x, y;\n    pair(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    pair() {}\n\n    @Override\n    public int compare(pair o1, pair o2) {\n        return Integer.compare(o1.x, o2.x);\n    }\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Objects;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pranay2516\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CBanhMi solver = new CBanhMi();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CBanhMi {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt(), q = in.nextInt();\n            char c[] = in.next().toCharArray();\n            int mod = (int) 1e9 + 7;\n            Pair<Long, Long>[] a = new Pair[n + 1];\n            a[0] = new Pair<>(0L, 0L);\n            for (int i = 1; i <= n; ++i) {\n                if (c[i - 1] == '0') {\n                    a[i] = new Pair<>(a[i - 1].x, a[i - 1].y + 1);\n                } else {\n                    a[i] = new Pair<>(a[i - 1].x + 1, a[i - 1].y);\n                }\n            }\n            while (q-- > 0) {\n                int l = in.nextInt(), r = in.nextInt();\n                long ones = a[r].x - a[l - 1].x;\n                long zeros = a[r].y - a[l - 1].y;\n                long po = func.power(2, ones, mod);\n                while (po < 0) po += mod;\n                po %= mod;\n                long pz = func.power(2, zeros, mod);\n                while (pz < 0) pz += mod;\n                pz %= mod;\n                out.println(((po - 1) % mod * pz % mod) % mod);\n            }\n        }\n\n    }\n\n    static class func {\n        public static long power(long x, long y, int mod) {\n            if (y == 0) return 1;\n            long p = power(x, y / 2, mod);\n            p = (p * p) % mod;\n            return (y % 2 == 0) ? p : (x * p) % mod;\n        }\n\n    }\n\n    static class Pair<U, V> implements Comparable<Pair<U, V>> {\n        public U x;\n        public V y;\n\n        public Pair(U x, V y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Pair<U, V> o) {\n            int value = ((Comparable<U>) x).compareTo(o.x);\n            if (value != 0) return value;\n            return ((Comparable<V>) y).compareTo(o.y);\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n            return x.equals(pair.x) && y.equals(pair.y);\n        }\n\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "1062_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.*;\n\npublic class N72A\n{\n    StreamTokenizer in;\n    PrintWriter out;\n\n    int nextInt() throws IOException\n    {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    double nextDouble() throws IOException\n    {\n        in.nextToken();\n        return in.nval;\n    }\n\n    public void init() throws Exception\n    {\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        Reader reader = oj ? new InputStreamReader(System.in) : new FileReader(new File(\"input.txt\"));\n        Writer writer = oj ? new OutputStreamWriter(System.out) : new FileWriter(new File(\"output.txt\"));\n        in = new StreamTokenizer(reader);\n        out = new PrintWriter(writer);\n    }\n\n    public void solve() throws Exception\n    {\n        int n = nextInt();\n        out.print(2*n - (n/2));\n    }\n\n    public void print() throws Exception\n    {\n        out.flush();\n    }\n\n    public void run() throws Exception\n    {\n        init();\n        solve();\n        print();\n    }\n\n    public static void main(String[] args) throws Exception\n    {\n        new N72A().run();\n    }\n}", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class B {\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tString[] split = br.readLine().split(\" \");\n\t\t\n\t\tlong n = Long.parseLong(split[0]);\n\t\tlong k = Long.parseLong(split[1]);\n\t\t\n\t\tlong left = -1;\n\t\tlong right = n + 1;\n\t\t\n\t\twhile(right - left >= 2) {\n\t\t\tlong mid = (left + right) / 2; // 10\n\t\t\t// if(mid > n) {\n\t\t\t\t// right = mid;\n\t\t\t\t// continue;\n\t\t\t// }\n\t\t\t\n\t\t\tlong newN = n - mid; //-5\n\t\t\tlong temp = newN * (newN + 1) / 2; //10\n\t\t\t\n\t\t\tlong eh = temp - k - mid;\n\t\t\t\n\t\t\tif(eh == 0) {\n\t\t\t\tpw.println(mid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(eh < 0)\n\t\t\t\tright = mid;\n\t\t\telse\n\t\t\t\tleft = mid;\n\t\t}\n\t\t\n\t\tpw.close();\n\t}\n}", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
