{"src": "n = int(input())-1\nx = 1\ny = 9\nwhile n > x * y:\n    n -= x * y\n    y *= 10\n    x += 1\na = 10 ** (x - 1)\na += n // x\nprint(str(a)[n % x])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "from string import digits\nfrom collections import Counter\na = input()\nb = input()\nca = Counter(a)\nl = list()\nif len(b) > len(a):\n    for i in digits[::-1]:\n        if i in ca:\n            l.extend(i * ca[i])\nelse:\n    def asd(i, s):\n        if i == len(b):\n            return True\n        if s:\n            for j in digits[::-1]:\n                if j in ca and ca[j] > 0:\n                    l.extend(j * ca[j])\n            return True\n        else:\n            for j in digits[:int(b[i])+1][::-1]:\n                if j in ca and ca[j] > 0:\n                    ca[j] -= 1\n                    l.append(j)\n                    if asd(i + 1, j != b[i]):\n                        return True\n                    ca[j] += 1\n                    l.pop()\n            return False\n    asd(0, False)\nprint(\"\".join(l))\n\n       \t\t  \t \t  \t \t \t \t \t   \t\t\t", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import io\nimport os\n\n\ndef solve(N,):\n\n    if N % 2 != 0:\n        return \"NO\"\n    N //= 2\n    if int(N ** 0.5) ** 2 == N:\n        return \"YES\"\n    if N % 2 != 0:\n        return \"NO\"\n    N //= 2\n    if int(N ** 0.5) ** 2 == N:\n        return \"YES\"\n    return \"NO\"\n\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    TC = int(input())\n    for tc in range(1, TC + 1):\n        (N,) = [int(x) for x in input().split()]\n        ans = solve(N,)\n        print(ans)\n", "complexity": "constant", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "# template begins\n#####################################\nfrom io import BytesIO, IOBase\nimport sys\nimport math\nimport os\nfrom collections import defaultdict\nfrom math import ceil\nfrom bisect import bisect_left, bisect_left\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\ndef mint(): return map(int, input().split())\ndef mfloat(): return map(float, input().split())\n\n\n#####################################\n# template ends\n# Use the recursion snippet if heavy recursion is needed (depth>1000)\ndef solve():\n    n, m, k = mint()\n    horizontal = [list(mint()) for i in range(n)]\n    vertical = [list(mint()) for i in range(n-1)]\n    if k%2 or max(n, m)==1:\n        for i in range(n):\n            print(*[-1]*m)\n        return\n    \"\"\"\n    does it make sense to double back on a path if k is large enough?\n    or are there cases when you need to make a loop?\n\n    proof:\n    if you have a path of length k that does not visit any edge more than once,\n    we can split it into 2 paths of length k/2\n    if one of them was cheaper than the other, we should have just back tracked on that\n    hence, both must be the same\n    in that case, you can just double any one\n\n    should ideally double back on the same path if k is big enough\n    just find the cheapest path of length k/2 and double it?\n\n    how do you find the cheapest path of length k/2?\n\n    dp?\n    store the cheapest path of length x from every node,\n    where x will be from 1 to k/2\n    yeah should work\n    dp[i][j][x] represents the cheapest path of length from g[i][j] of length x\n    \"\"\"\n    dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]\n    for length in range(1, k//2+1):\n        for i in range(n):\n            for j in range(m):\n                \"\"\"\n                we want cost_to_neighbour + dp[neigbour][length-1] to be min\n                \"\"\"\n                left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]\n                right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]\n                top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]\n                bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]\n                dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])\n    for i in range(n):\n        for j in range(m):\n            print(dp[i][j][k//2]*2, end=' ')\n        print()\n\n    \n\ndef main():\n    # t = int(input())\n    t = 1\n    for _ in range(t):\n        solve()\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nfrom decimal import *\nfrom copy import *\nfrom heapq import *\ngetcontext().prec = 30\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b):\n    return abs(a[0]-b[0])+abs(b[1]-a[1])\n\ndef charIN(x= ' '):\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN(x = ' '):\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n\ndef eld(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\ndef lgcd(a):\n    g = a[0]\n    for i in range(1,len(a)):\n        g = math.gcd(g,a[i])\n    return g\n\ndef ms(a):\n    msf = -MAX\n    meh = 0\n    st = en = be = 0\n    for i in range(len(a)):\n        meh+=a[i]\n        if msf<meh:\n            msf = meh\n            st = be\n            en = i\n        if meh<0:\n            meh = 0\n            be = i+1\n    return msf,st,en\n\ndef ncr(n,r):\n    num=den=1\n    for i in range(r):\n        num = (num*(n-i))%MOD\n        den = (den*(i+1))%MOD\n\n    return (num*(pow(den,MOD-2,MOD)))%MOD\n\n\n\ndef flush():\n    return sys.stdout.flush()\n\n\ndef fac(n):\n    ans = 1\n    for i in range(1,n+1):\n        ans*=i\n        ans%=MOD\n    return ans\n\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\nn = int(input())\na = arrIN()\na.sort()\nf = [1]*n\ncnt = 0\nfor i in range(n):\n    if f[i]:\n        cnt+=1\n        for j in range(i,n):\n            if f[j] and a[j]%a[i]==0:\n                f[j] = 0\n        f[i] = 0\nprint(cnt)\n\n\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "from collections import defaultdict\nfrom sys import setrecursionlimit,stdin\ninput=stdin.readline\nsetrecursionlimit(100000)\n\ndef dfs(r,g,b,rr,gg,bb):\n    if r<0 or g<0 or b<0:\n        return 0\n    x=0\n    y=0\n    z=0\n    \n    if dp[r][g][b]!=-1:\n        return dp[r][g][b]\n    if r!=0 and g!=0:\n        x=rr[r-1]*gg[g-1]+dfs(r-1,g-1,b,rr,gg,bb)\n    if r!=0 and b!=0:\n        y=rr[r-1]*bb[b-1]+dfs(r-1,g,b-1,rr,gg,bb)\n    if b!=0 and g!=0:\n        z=bb[b-1]*gg[g-1]+dfs(r,g-1,b-1,rr,gg,bb)\n    dp[r][g][b]=max(x,y,z)\n    return max(x,y,z)\n\nr,g,b=map(int,input().split())\nrr=list(map(int,input().split()))\ngg=list(map(int,input().split()))\nbb=list(map(int,input().split()))\nrr.sort()\ngg.sort()\nbb.sort()\ndp=[[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]\n\nprint(dfs(r,g,b,rr,gg,bb))\n\n\n\n\n\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "rnd_mod = 1234567890133\nrnd_x = 987654321098\ndef rnd():\n    global rnd_x\n    rnd_x = rnd_x**2 % rnd_mod\n    return (rnd_x>>5) % (1<<20)\ndef randrange(a):\n    return rnd() % a\n\nT = int(input())\nfor _ in range(T):\n    N, M = map(int, input().split())\n    X = []\n    for __ in range(N):\n        X.append([int(a) for a in input().split()])\n    Y = [[X[i][j] for i in range(N)] for j in range(M)]\n    ma = 0\n    for t in range(577):\n        for i in range(M):\n            a = randrange(N)\n            Y[i] = [Y[i][j-a] for j in range(N)]\n        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))\n    print(ma)\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import random\n\nn = int(input())\nv = []\nfor i in range(0, n):\n    x, y = map(int, input().split())\n    v.append([x, y, i])\n\nwhile 1>0:\n    random.shuffle(v)\n    x = y = 0\n    ans = [0]*n\n    for i in range(n):\n\n        if (x+v[i][0])**2+(y+v[i][1])**2 < (x-v[i][0])**2+(y-v[i][1])**2:\n            x += v[i][0]\n            y += v[i][1]\n            ans[v[i][2]] = 1\n        else:\n            x -= v[i][0]\n            y -= v[i][1]\n            ans[v[i][2]] = -1\n    if x*x+y*y <= 1500000**2:\n        print(*ans)\n        break\n2", "complexity": "nlogn", "problem": "0995_C", "from": "CODEFORCES", "tags": "brute force,data structures,geometry,greedy,math,sortings"}
{"src": "n=int(input())\nprint((n//2)+1)\n", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\nimport math\nfrom collections import OrderedDict\ndef input():    return sys.stdin.readline().strip()\ndef iinput():   return int(input())\ndef minput():   return map(int, input().split()) \ndef listinput(): return list(map(int, input().split()))\nn,k=minput()\nfor i in range(1,n+1):\n\tif (i*(i+1))/2 -n+i==k:\n\t\tprint(n-i)\n\t\tbreak", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n,m = map(int,input().split())\nprint(n*\"8\")\nprint((n-1)*\"1\"+\"2\")", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n \nmax_val = 0\nn, m = [int(item) for item in input().split()]\narray = []\nfor i in range(n):\n    line = [int(item) for item in input().split()]\n    array.append(line)\n    max_val = max(max_val, max(line))\n \ngood = (1 << m) - 1\nl = 0; r = max_val + 1\na = 0; b = 0\nwhile r - l > 1:\n    mid = (l + r) // 2\n    bit_array = dict() \n    for k, line in enumerate(array):\n        val = 0\n        for i, item in enumerate(line):\n            if item >= mid:\n                val |= 1 << i\n        bit_array[val] = k\n    ok = False\n    for key1 in bit_array.keys():\n        for key2 in bit_array.keys():\n            if key1 | key2 == good:\n                ok = True\n                i = bit_array[key1]\n                j = bit_array[key2]\n                break\n    if ok:\n        a = i; b = j\n        l = mid\n    else:\n        r = mid\nprint(a+1, b+1)", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "n, m = map(int, input().split())\na = map(int, input().split())\nb = list(map(int, input().split()))\nfor x in a:\n    if x in b:\n        print(x, end=' ')\n\n", "complexity": "quadratic", "problem": "0994_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "x, y, z, t1, t2, t3 = map(int, raw_input().split())\nelev = t3*3 + t2*(abs(z-x) + abs(x-y))\nstairs = t1*abs(x - y)\nif elev <= stairs:\n    print('YES')\nelse:\n    print('NO')\n", "complexity": "constant", "problem": "1054_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\nA = list(map(int, input().split()))\n\nINF = 10**3\ndp = [[INF]*(n+1) for _ in range(n+1)]\n# dp[i][j]: \u533a\u9593[i, j)\u306e\u64cd\u4f5c\u5f8c\u306e\u9577\u3055\u306e\u6700\u5c0f\u5024\nval = [[0]*(n+1) for _ in range(n+1)]\n\nfor i in range(n):\n    dp[i][i+1] = 1\n\nfor i in range(n):\n    val[i][i+1] = A[i]\n\nfor d in range(2, n+1):\n    for i in range(n+1-d):\n        j = i+d\n        for k in range(i+1, j):\n            if dp[i][k] == 1 and dp[k][j] == 1 and val[i][k] == val[k][j]:\n                dp[i][j] = min(dp[i][j], 1)\n                val[i][j] = val[i][k]+1\n            else:\n                dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j])\n\nprint(dp[0][n])\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "t = int(input())\nfor i in range(t):\n    n = int(input())\n\n    lens = sorted(map(int, input().split()))\n    cnt = len(list(filter(lambda x: x> 0, lens[:-2])))\n\n    print(min(cnt, lens[-2]-1))", "complexity": "nlogn", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "q = int(input())\nfor i in range(q):\n    x, y, k = map(int, input().split())\n    if x > y: x, y = y, x\n    m = y\n    d = y\n    if (y - x) % 2 == 1:\n        d -= 1\n    if k < m:\n        print(-1)\n        continue\n    r = k - m\n    if r % 2 != 0:\n        r -= 1\n        if d != m:\n            d += 1\n        else:\n            d -= 1\n    d += r\n    print(d)\n", "complexity": "constant", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\ndef matching(n,m,path):\n    # Hopkrocft Karp O(EV^0.5)\n    match1 = [-1]*n\n    match2 = [-1]*m\n    for node in range(n):\n        for nei in path[node]:\n            if match2[nei] == -1:\n                match1[node] = nei\n                match2[nei] = node\n                break\n    while 1:\n        bfs = [node for node in range(n) if match1[node] == -1]\n        depth = [-1]*n\n        for node in bfs:\n            depth[node] = 0\n\n        for node in bfs:\n            for nei in path[node]:\n                next_node = match2[nei]\n                if next_node == -1:\n                    break\n                if depth[next_node] == -1:\n                    depth[next_node] = depth[node]+1\n                    bfs.append(next_node)\n            else:\n                continue\n            break\n        else:\n            break\n        pointer = [len(c) for c in path]\n        dfs = [node for node in range(n) if depth[node] == 0]\n        while dfs:\n            node = dfs[-1]\n            while pointer[node]:\n                pointer[node] -= 1\n                nei = path[node][pointer[node]]\n                next_node = match2[nei]\n                if next_node == -1:\n                    while nei != -1:\n                        node = dfs.pop()\n                        match2[nei],match1[node],nei = node,nei,match1[node]\n                    break\n                elif depth[node]+1 == depth[next_node]:\n                    dfs.append(next_node)\n                    break\n            else:\n                dfs.pop()\n    return n-match1.count(-1)\n\ndef main():\n    n,m = map(int,input().split())\n    edg = [tuple(map(lambda xx:int(xx)-1,input().split())) for _ in range(m)]\n    ans = float(\"inf\")\n    for centre in range(n):\n        path = [[] for _ in range(n)]\n        cost = 2*n-1\n        extra = m\n        for u,v in edg:\n            if u == centre or v == centre:\n                cost -= 1\n                extra -= 1\n            else:\n                path[u].append(v)\n        maxMatch = matching(n,n,path)\n        extra -= maxMatch\n        cost += n-1-maxMatch+extra\n        ans = min(ans,cost)\n    print(ans)\n\n# Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic", "problem": "0387_D", "from": "CODEFORCES", "tags": "graph matchings"}
{"src": "# %matplotlib inline\n\ndef main():\n    n, k = [int(x) for x in input().split(' ')]\n    if k==1:\n        print(n)\n        return\n    a = []\n    b = {}\n    a = [int(x) for x in input().split(' ')]\n    a.sort()\n\n    a=dict(zip(a,range(n)))\n    count = {}\n\n    for x in a:\n        if x % k == 0 and int(x / k) in a:\n            b[x] = b[int(x / k)]\n            count[b[int(x / k)]] += 1\n        else:\n            b[x] = x\n            count[x] = 1\n\n    for x,y in count.items():\n        n -= int(y / 2)\n\n    print(n)\n\n\nmain()\n", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\n\"\"\"\ncreated by shhuan at 2020/3/19 13:35\n\n\"\"\"\n\n\ndef check(s, a, b, after):\n    ns, na, nb = len(s), len(a), len(b)\n    if ns < na + nb:\n        return False\n\n    dp = [[0 for _ in range(nb+1)] for _ in range(na+1)]\n    for i in range(na+1):\n        for j in range(nb+1):\n            if i == 0 and j == 0:\n                continue\n            dp[i][j] = min(after[dp[i-1][j]][a[i-1]] if i > 0 else ns, after[dp[i][j-1]][b[j-1]] if j > 0 else ns) + 1\n\n    return dp[na][nb] <= ns\n\n\ndef solve(s, t):\n    ns = len(s)\n    after = [[ns for _ in range(26)] for _ in range(ns+2)]\n    for i in range(ns-1, -1, -1):\n        for j in range(26):\n            after[i][j] = after[i+1][j]\n        after[i][s[i]] = i\n\n    for i in range(len(t)):\n        a, b = t[:i], t[i:]\n        if check(s, a, b, after):\n            return 'YES'\n\n    return 'NO'\n\n\nT = int(input())\nans = []\nfor i in range(T):\n    s = input()\n    t = input()\n    s = [ord(v) - ord('a') for v in s]\n    t = [ord(v) - ord('a') for v in t]\n    ans.append(solve(s, t))\n\nprint('\\n'.join(ans))", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "a,b=input().split()\nif(a==b):\n    print(\"0\")\nelse:\n    xor=bin(int(a)^int(b))[2:]\n    a=bin(int(a))[2:]\n    b=bin(int(b))[2:]\n    ans=\"\"\n    if a[0]==b[0]:\n        ans+=\"0\"\n    else:\n        ans+=\"1\"\n    for i in range(len(xor)):\n        ans+=\"1\"\n    print(int(ans,2))\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n = int(input())\na = list(map(int, input().split()))\ndp = [ [False,False,False,False,False] for _ in range(n) ]\ndp[0] = [True, True, True, True, True]\nfor i in range(1, n):\n\tfor j in range(5):\n\t\tif a[i] == a[i - 1]:\n\t\t\tfor k in range(5):\n\t\t\t\tif k != j:\n\t\t\t\t\tdp[i][j] = dp[i][j] or dp[i - 1][k]\n\t\telif a[i] > a[i - 1]:\n\t\t\tfor k in range(j):\n\t\t\t\tdp[i][j] = dp[i][j] or dp[i - 1][k]\n\t\telse:\n\t\t\tfor k in range(j + 1, 5):\n\t\t\t\tdp[i][j] = dp[i][j] or dp[i - 1][k]\nif dp[-1].count(True) == 0:\n\tprint(-1)\n\texit(0)\nj = 0\nfor k in range(5):\n\tif dp[-1][k]:\n\t\tj = k\nans = []\nfor i in range(n - 1, -1, -1):\n\tans.append(j + 1)\n\tif i == 0:\n\t\tbreak\n\tif a[i] == a[i - 1]:\n\t\tfor k in range(5):\n\t\t\tif k != j and dp[i - 1][k]:\n\t\t\t\tj = k\n\t\t\t\tbreak\n\telif a[i] > a[i - 1]:\n\t\tfor k in range(j):\n\t\t\tif dp[i - 1][k]:\n\t\t\t\tj = k\n\t\t\t\tbreak\n\telse:\n\t\tfor k in range(j + 1, 5):\n\t\t\tif dp[i - 1][k]:\n\t\t\t\tj = k\n\t\t\t\tbreak\nprint(*ans[::-1])", "complexity": "quadratic", "problem": "1032_C", "from": "CODEFORCES", "tags": "constructive algorithms,dp"}
{"src": "import math;\ndef f(n,s):\n    d=[-n,-n];\n    d[s]=0\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n    return d[s]\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny+=x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "def find(A):\n    from collections import defaultdict\n    A=sorted(A)\n    N=len(A)\n    dic=defaultdict(int)\n    for i in range(N):\n        dic[A[i]]+=1\n    \n    checked=[]\n    count=set([])\n    for x in A:\n        if dic[x]>2:\n            return \"cslnb\"\n        if dic[x]==2:\n            count.add(x)\n            y=x-1\n            if y in dic:\n                return \"cslnb\"\n    if len(count)>1:\n        return \"cslnb\"\n    \n    if 0 in count:\n        return \"cslnb\"\n    \n    temp=0\n    for i in range(N):\n        temp+=A[i]-i\n    if temp%2==1:\n        return \"sjfnb\"\n    return \"cslnb\"\ninput()\nA=list(map(int,input().strip().split(' ')))\nprint(find(A))", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "n=int(input())\nn+=1\n\nif n%2==0 or n==1:\n\tprint(n//2)\nelse:\n\tprint(n)", "complexity": "constant", "problem": "0979_A", "from": "CODEFORCES", "tags": "math"}
{"src": "index = int(input())\n\ntotal = 9\nn = 1\n\nwhile index > total:\n    total += (n + 1) * (10**n) * 9\n    n += 1\nlast = 10**(n - 1)\ntotal -= n * 9 * last\nindex = index - total\n\n\nr = index % (n)\nk = index // n\n\nnumber = last + k\n\n\nif r == 0:\n    print(str(number - 1)[n-1])\nelse:\n    print(str(number)[r - 1])\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "arr = [int(i) for i in filter(None, input().split(\" \"))]\nk_hodov = arr[0]\nkonf = arr[1]\nleft = 0\nright = k_hodov+100\nwhile(right-left)>1:\n    mid = (right+left)//2\n    k_give=k_hodov-mid\n    if ((k_give+1)*(k_give/2))//1-mid<konf or k_give<0:\n        right = mid\n    else:\n        left = mid\n\nk_give=k_hodov-left\nif ((k_give+1)*(k_give/2))//1-left==konf:\n    print(left)\nelse:\n    print(left-1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"i=1\nk_eat=0\nlast_give = 1\nfor i in range(arr[0]):\n    if konf>=last_give:\n        konf-=last_give\n        last_give+=1\n    else:\n        k_eat+=1\n        konf+=1\nprint(k_eat)\"\"\"", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n, m = map(int, input().split())\nx = list(list(map(int , input())) for i in range(n))\nres = [0] * m\nfor i in range(n):\n\tfor j in range(m):\n\t\tres[j] += x[i][j]\n\nfor i in range(n):\n\tok = 1\n\tfor j in range(m):\n\t\tif res[j] == 1 and x[i][j] == 1:\n\t\t\tok = 0\n\t\t\tbreak\n\tif ok:\n\t\tprint(\"YES\")\n\t\texit()\nprint(\"NO\")\n", "complexity": "quadratic", "problem": "0985_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\nimport sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log2, ceil\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom bisect import insort\nfrom collections import Counter\nfrom collections import deque\nfrom heapq import heappush,heappop,heapify\nfrom itertools import permutations,combinations\nfrom itertools import accumulate as ac\nmod = int(1e9)+7\n#mod = 998244353\n \nip = lambda : int(stdin.readline())\ninp = lambda: map(int,stdin.readline().split())\nips = lambda: stdin.readline().rstrip()\nout = lambda x : stdout.write(str(x)+\"\\n\")\n\nt = 1\nfor _ in range(t):\n    q = \"? {} {}\".format(0,0)\n    print(q,flush = True)\n    cond = ip()\n    cur_a = 0\n    cur_b = 0\n    for i in range(29,-1,-1):\n        xor = (1<<i)\n        query_a = cur_a^xor\n        query_b = cur_b^xor\n        q = \"? {} {}\".format(query_a,query_b)\n        print(q,flush = True)\n        val = ip()\n        if val != cond:\n            if cond == -1 and val == 1:\n                cur_b ^= xor\n                query_a = cur_a\n                query_b = cur_b\n                q = \"? {} {}\".format(query_a,query_b)\n                print(q,flush = True)\n                val = ip()\n                cond = val\n            else:\n                cur_a ^= xor\n                query_a = cur_a\n                query_b = cur_b\n                q = \"? {} {}\".format(query_a,query_b)\n                print(q,flush = True)\n                val = ip()\n                cond = val\n        else:\n            cond = val\n            query_a = cur_a^xor\n            query_b = cur_b\n            q = \"? {} {}\".format(query_a,query_b)\n            print(q,flush = True)\n            val = ip()\n            if val == -1:\n                cur_a ^= xor\n                cur_b ^= xor\n            else:\n                pass\n    ans = \"! {} {}\".format(cur_a,cur_b)\n    print(ans,flush = True)\n    \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    \n\n\n\n    \n                    \n                \n                \n            \n                \n            \n            \n        \n                \n                \n        \n    \n    \n    \n        \n    \n        \n            \n        \n        \n        \n        \n            \n        \n        \n    \n        \n            \n        \n                \n        \n        \n        \n        \n        \n            \n            \n            \n            \n            \n        \n    \n            \n    \n            \n            \n            \n            \n            \n            \n            \n                \n                \n                \n\n\n    \n        \n", "complexity": "constant", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "n = int(input())\n\nd = {}\n\nfor i in range(n-1):\n\ta,b = map(int,input().split())\n\n\ttry:\n\t\td[a].append(b);\n\texcept:\n\t\td[a] = [b]\n\ttry:\n\t\td[b].append(a);\n\texcept:\n\t\td[b] = [a]\n\narray = list(map(int,input().split()))\nflag=0;\n\nif array[0]==1:\n\n\ti = 1;\n\tj = 0;\n\n\twhile ( j < n and i < n ):\n\t\tif ( array[j] in d[array[i]] ):\n\t\t\ti+=1;\n\t\telse:\n\t\t\tj+=1;\n\tif j==n and i!=n:\n\t\tflag=1;\nelse:\n\tflag=1;\n\nif flag==1:\n\tprint(\"No\")\nelse:\n\tprint(\"Yes\")", "complexity": "linear", "problem": "1037_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs,shortest paths,trees"}
{"src": "import functools\nimport time\nfrom collections import Counter\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n    # @timer\n    def __init__(self):\n        pass\n\n    def __call__(self):\n        n, m = map(int, input().strip().split())\n        a = list(map(int, input().strip().split()))\n        h = Counter()\n        for ai in a:\n            h[ai] = h[ai] + 1 if ai in h else 1\n        days = 0\n        while True:\n            tot = 0\n            for key, cnt in h.items():\n                tot += cnt // (days + 1)\n            if tot < n:\n                print(days)\n                return\n            days += 1\n\nsolver()()", "complexity": "nlogn", "problem": "1011_B", "from": "CODEFORCES", "tags": "binary search,brute force,implementation"}
{"src": "n,K=map(int,input().split())\nb=sorted([int(x)for x in input().split()])\nl=cur=0\nfor i in range(1,n):\n    if b[i]==b[i-1]:continue\n    if b[i]>b[i-1]+K:l=i\n    else:cur+=(i-l);l=i\nprint(n-cur)\n", "complexity": "nlogn", "problem": "0990_B", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "from random import randint\nfor _ in range(int(input())):\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n    ans = 0\n    for _ in range(100):\n        for j in range(m):\n            x = randint(0, n - 1)\n            if x:\n                B = []\n                for i in range(n):\n                    B.append(A[i][j])\n                B = B[x:] + B[:x]\n                for i in range(n):\n                    A[i][j] = B[i]\n        c = 0\n        for i in range(n):\n            c += max(A[i])\n        ans = max(ans, c)\n    print(ans)", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nres = []\nif n == 1:\n    print(1)\n    exit(0)\n\ni = 0\nif a[0] < a[1]:\n\n    if i >= n - 2:\n        res = [1]\n        cur = 2\n    else:\n        if a[i + 1] < a[i + 2]:\n            res = [1]\n            cur = 2\n        elif a[i + 1] > a[i + 2]:\n            res = [1]\n            cur = 5\n        else:\n            res = [1]\n            cur = 2\n\nelif a[0] > a[1]:\n\n    if i >= n - 2:\n        res = [5]\n        cur = 4\n    else:\n        if a[i + 1] < a[i + 2]:\n            res = [5]\n            cur = 1\n        elif a[i + 1] > a[i + 2]:\n            res = [5]\n            cur = 4\n        else:\n            res = [5]\n            cur = 4\n\nelse:\n    if i >= n - 2:\n        res.append(1)\n        cur = 2\n    else:\n        if a[i + 1] < a[i + 2]:\n            res.append(2)\n            cur = 1\n        elif a[i + 1] > a[i + 2]:\n            res.append(4)\n            cur = 5\n        else:\n            res.append(2)\n            cur = 3\n\nfor i in range(1, n - 1):\n    if not (1 <= cur <= 5):\n        print(-1)\n        exit(0)\n    res.append(cur)\n    if a[i] > a[i + 1]:\n\n        if i >= n - 2:\n            cur -= 1\n        else:\n            if a[i + 1] < a[i + 2]:\n                cur = min(cur - 1, 1)\n            elif a[i + 1] > a[i + 2]:\n                cur -= 1\n            else:\n                cur -= 1\n\n    elif a[i] < a[i + 1]:\n\n        if i >= n - 2:\n            cur += 1\n        else:\n            if a[i + 1] < a[i + 2]:\n                cur += 1\n            elif a[i + 1] > a[i + 2]:\n                cur = max(cur + 1, 5)\n            else:\n                cur += 1\n    else:\n        if i >= n - 2:\n            if cur != 3:\n                cur = 3\n            else:\n                cur = 2\n        else:\n            if a[i + 1] < a[i + 2]:\n                if cur == 1:\n                    cur = 2\n                else:\n                    cur = 1\n            elif a[i + 1] > a[i + 2]:\n                if cur == 5:\n                    cur = 4\n                else:\n                    cur = 5\n            else:\n                if cur != 3:\n                    cur = 3\n                else:\n                    cur = 2\nif not (1 <= cur <= 5):\n    print(-1)\n    exit(0)\nres.append(cur)\nprint(*res)", "complexity": "linear", "problem": "1032_C", "from": "CODEFORCES", "tags": "constructive algorithms,dp"}
{"src": "## necessary imports\nimport sys\ninput = sys.stdin.readline\nfrom math import ceil, floor, factorial;\n\n# swap_array function\ndef swaparr(arr, a,b):\n    temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp\n\n## gcd function\ndef gcd(a,b):\n    if a == 0:\n        return b\n    return gcd(b%a, a)\n\n## nCr function efficient using Binomial Cofficient\ndef nCr(n, k): \n    if(k > n - k): \n        k = n - k \n    res = 1\n    for i in range(k): \n        res = res * (n - i) \n        res = res / (i + 1) \n    return int(res) \n\n## upper bound function code -- such that e in a[:i] e < x;\ndef upper_bound(a, x, lo=0):\n    hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x:\n            lo = mid+1\n        else:\n            hi = mid\n    return lo\n\n## prime factorization\ndef primefs(n):\n    ## if n == 1    ## calculating primes\n    primes = {}\n    while(n%2 == 0):\n        primes[2] = primes.get(2, 0) + 1\n        n = n//2\n    for i in range(3, int(n**0.5)+2, 2):\n        while(n%i == 0):\n            primes[i] = primes.get(i, 0) + 1\n            n = n//i\n    if n > 2:\n        primes[n] = primes.get(n, 0) + 1\n    ## prime factoriazation of n is stored in dictionary\n    ## primes and can be accesed. O(sqrt n)\n    return primes\n\n## MODULAR EXPONENTIATION FUNCTION\ndef power(x, y, p): \n    res = 1\n    x = x % p  \n    if (x == 0) : \n        return 0\n    while (y > 0) : \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n        y = y >> 1      \n        x = (x * x) % p \n    return res \n\n## DISJOINT SET UNINON FUNCTIONS\ndef swap(a,b):\n    temp = a\n    a = b\n    b = temp\n    return a,b\n\n# find function with path compression included (recursive)\n# def find(x, link):\n#     if link[x] == x:\n#         return x\n#     link[x] = find(link[x], link);\n#     return link[x];\n\n# find function with path compression (ITERATIVE)\ndef find(x, link):\n    p = x;\n    while( p != link[p]):\n        p = link[p];\n    \n    while( x != p):\n        nex = link[x];\n        link[x] = p;\n        x = nex;\n    return p;\n\n\n# the union function which makes union(x,y)\n# of two nodes x and y\ndef union(x, y, link, size):\n    x = find(x, link)\n    y = find(y, link)\n    if size[x] < size[y]:\n        x,y = swap(x,y)\n    if x != y:\n        size[x] += size[y]\n        link[y] = x\n\n## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES\ndef sieve(n): \n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n#### PRIME FACTORIZATION IN O(log n) using Sieve ####\nMAXN = int(1e6 + 5)\ndef spf_sieve():\n    spf[1] = 1;\n    for i in range(2, MAXN):\n        spf[i] = i;\n    for i in range(4, MAXN, 2):\n        spf[i] = 2;\n    for i in range(3, ceil(MAXN ** 0.5), 2):\n        if spf[i] == i:\n            for j in range(i*i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i;\n    ## function for storing smallest prime factors (spf) in the array\n\n################## un-comment below 2 lines when using factorization #################\n# spf = [0 for i in range(MAXN)]\n# spf_sieve() \ndef factoriazation(x):\n    ret = {};\n    while x != 1:\n        ret[spf[x]] = ret.get(spf[x], 0) + 1;\n        x = x//spf[x]\n    return ret\n    ## this function is useful for multiple queries only, o/w use\n    ## primefs function above. complexity O(log n)\n\n## taking integer array input\ndef int_array():\n    return list(map(int, input().strip().split()))\n## taking string array input\ndef str_array():\n    return input().strip().split();\n\n#defining a couple constants\nMOD = int(1e9)+7;\nCMOD = 998244353;\nINF = float('inf'); NINF = -float('inf');\n\n################### ---------------- TEMPLATE ENDS HERE ---------------- ###################\n\nn, l, r, x = int_array(); a = sorted(int_array());\nans = 0;\nfor mask in range( 1 << n):\n    mx = NINF; mn = INF; sub = 0;\n    for i in range(n):\n        if (1 << i) & mask:\n            sub += a[i];\n            mx = max(mx, a[i]);\n            mn = min(mn, a[i]);\n    if sub >= l and sub <= r:\n        if mx - mn >= x:\n            ans += 1;\nprint(ans);", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "n,k=list(map(int,input().split()))\n\nif k%2==0:\n    s=\".\"\n    s=s+\"#\"*(k//2)\n    s=s+\".\"*(n-len(s))\n    print(\"YES\")\n    print(\".\"*n)\n    print(s)\n    print(s)\n    print(\".\"*n)\n\nelse:\n    if k<=n-2:\n        a=\"#\"*k\n        s=\".\"*((n-k)//2)+a+\".\"*((n-k)//2)\n        print(\"YES\")\n        print(\".\"*n)\n        print(s)\n        print(\".\"*n)\n        print(\".\"*n)\n    else:\n        k=k-n+3\n        a=\"#\"*k\n        s=\".\"*((n-k)//2)+a+\".\"*((n-k)//2)\n        print(\"YES\")\n        print(\".\"*n)\n        print(\".\"+\"#\"*(n-2)+\".\")\n        s=list(s)\n        s[n//2]=\".\"\n        s=\"\".join(s)\n        print(s)\n        print(\".\"*n)", "complexity": "linear", "problem": "0980_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "def power(x, y, p) : \n    res = 1     # Initialize result \n  \n    # Update x if it is more \n    # than or equal to p \n    x = x % p  \n  \n    while (y > 0) : \n          \n        # If y is odd, multiply \n        # x with result \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n  \n        # y must be even now \n        y = y >> 1      # y = y/2 \n        x = (x * x) % p \n          \n    return res\n    \nx,k = map(int,input().split())\nif x==0:\n    print(0)\nelse:\n    ans = power(2,k,1000000007)\n    ans = ans * ((2*x)-1)\n    ans = ans+1\n    ans=ans%1000000007\n    print(ans)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "def main():\n    n, m, k, l = map(int, input().split())\n    d = (l + k) // m\n    if (l + k) % m:\n        d += 1\n    if m * d > n or n - k < l:\n        print(-1)\n    else:\n        print(d)\n\n\nmain()", "complexity": "constant", "problem": "1068_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int,sys.stdin.readline().strip().split()))\n\nfor i in range (0, n):\n    if a[i] >= 0:\n        a[i] = - a[i] - 1\n\nif n % 2 == 1:\n    i = a.index(min(a))\n    a[i] = - a[i] - 1\n\na = list(map(str,a))\nprint(\" \".join(a))\n\n", "complexity": "linear", "problem": "1180_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import math\ns1=str(input())\ns2=str(input())\nd1=0;d2=0;n=0\nanswer=0\nfor i in s1:\n    if i=='+':d1+=1\n    else:\n        d1-=1\nfor i in s2:\n    if i=='+':d2+=1\n    elif i=='?':n+=1\n    else:\n        d2-=1\nif n>=abs(d2-d1):\n    y=(n-abs(d1-d2))/2\n    if y%1==0:\n        answer=math.factorial(n)/math.factorial(n-y)/math.factorial(y)/2**n\nprint('%.9f'%answer)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "#!/usr/bin/python3\n\nimport sys\nimport argparse\nimport json\n\ndef main():\n    n = int(sys.stdin.readline())\n    ticket = sys.stdin.readline().rstrip()\n    integers = [int(x) for x in ticket]\n\n    zeros = 0\n    while zeros < len(integers) and integers[-1*(zeros+1)] == 0:\n        zeros += 1\n\n    if zeros > 0 and zeros >= len(integers):\n        integers = []\n    elif zeros > 0:\n        integers = integers[:-1*zeros]\n    #print(integers)\n    if not integers:\n        print(\"YES\")\n        return\n    if len(integers) == 1:\n        print(\"NO\")\n        return\n\n    total = 0\n    for i, val in enumerate(integers[:-1]):\n        total += val\n        splice = integers[i+1:]\n        if is_golden(total, splice):\n            print(\"YES\")\n            return\n    print(\"NO\")\n\ndef is_golden(total, integers):\n    current_total = 0\n\n    for i, val in enumerate(integers):\n        current_total += val\n        if current_total < total:\n            continue\n        elif current_total == total:\n            #print(\"Here: %s,%s (%s)\" % (total, val, integers[i+1:]))\n            splice = integers[i+1:]\n            return (not splice) or is_golden(total, splice)\n        elif current_total > total:\n            return False\n    return False\n\ndef get_tests():\n    tests = [(\"5\\n73452\", \"YES\"),\n             (\"4\\n1248\", \"NO\"),\n             (\"4\\n7435\", \"NO\"),\n             (\"8\\n0020200\", \"YES\"),\n             (\"99\\n999999999999999999999999999999999999999999999918888888888888888888888888888888888888888888888888887\", \"YES\"),\n             (\"84\\n123608423980567916563149282633127550576921328162851174479585123236498689270768303090\", \"YES\"),\n             (\"2\\n00\", \"YES\"),\n             (\"8\\n00020200\", \"YES\"),\n             (\"5\\n11980\", \"NO\"),\n             (\"3\\n100\", \"NO\")]\n\n    for test in tests:\n        print(json.dumps({\"input\": test[0], \"output\": test[1]}))\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--get-tests\", action=\"store_true\")\n    args = parser.parse_args()\n\n    if args.get_tests:\n        get_tests()\n    else:\n        main()\n", "complexity": "quadratic", "problem": "1030_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "#Bhargey Mehta (Junior)\n#DA-IICT, Gandhinagar\nimport sys, math, queue, bisect\n#sys.stdin = open('input.txt', 'r')\nMOD = 998244353\nsys.setrecursionlimit(1000000)\n\nn = int(input())\nif n < 10:\n    print(n)\n    exit()\nd = 1\nwhile n > 9*d*pow(10, d-1):\n    n -= 9*d*pow(10, d-1)\n    d += 1\nx = pow(10, d-1) + (n-1)//d\np = n % d\nx = str(x).zfill(d)\nprint(x[p-1])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "f=input\nD,E=dict(),[eval(f())for i in range(int(f()))]\nfor e in E:D[e]=D.get(e,0)+1\nfor e in E:print(D[e])", "complexity": "linear", "problem": "0958_D1", "from": "CODEFORCES", "tags": "expression parsing,math"}
{"src": "import math,sys,bisect,heapq\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\n#sys.setrecursionlimit(200000000)\nint1 = lambda x: int(x) - 1\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nilele = lambda: map(int,input().split())\nalele = lambda: list(map(int, input().split()))\nilelec = lambda: map(int1,input().split())\nalelec = lambda: list(map(int1, input().split()))\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n#MOD = 1000000000 + 7\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\nfrom functools import lru_cache\n\nn,l,r,x = ilele()\nA = alele()\nA.sort()\n\n@lru_cache(None)\ndef fun(pos = 0,sm = -1,la = -1,tot = 0):\n    if pos == n:\n        if tot >= l and tot <= r and la  > 0 and  (la - sm) >= x:\n            return 1\n        return 0\n    if sm == -1:\n        return fun(pos+1,A[pos],-1,A[pos]) + fun(pos+1,sm,la,tot)\n    elif la == -1:\n        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)\n    else:\n        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)\n    \nprint(fun())\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "n,m=map(int,input().split())\ns=[]\nst=set()\ncst=set()\nfor i in range(n):\n    s.append(input())\n    for j in range(len(s[i])):\n        if s[i][j]=='#':\n            st.add((i,j))\nfor i in range(1,n-1):\n    for j in range(1,m-1):\n        if s[i-1][j-1]!='#':\n            continue\n        if s[i - 1][j ] != '#':\n            continue\n        if s[i-1][j+1]!='#':\n            continue\n        if s[i][j-1]!='#':\n            continue\n        if s[i][j+1]!='#':\n            continue\n        if s[i+1][j-1]!='#':\n            continue\n        if s[i+1][j]!='#':\n            continue\n        if s[i+1][j+1]!='#':\n            continue\n        cst.add((i-1,j))\n        cst.add((i - 1, j-1))\n        cst.add((i - 1, j+1))\n        cst.add((i + 1, j))\n        cst.add((i + 1, j-1))\n        cst.add((i + 1, j+1))\n        cst.add((i , j+1))\n        cst.add((i , j-1))\nif len(cst)==len(st):\n    print('YES')\nelse:\n    print('NO')", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def nine(p) :\n    \n    s=''\n    for i in range(p) :\n        s+='9'\n    return int(s)\ndef prosh(p) :\n    ans=0\n    for i in range(1,p+1) :\n        ans+=nine(i)*9\n    return ans\n        \nn,k=map(int,input().split())\nl=[0]*29\nfor i in range(19) :\n    \n    e=nine(19-i)\n    \n    l[i]=k//e\n    \n    k-=l[i]*e\n    \n    if k==0 :\n        \n        break\n    if i==18  or k%e>prosh(19-i-1) :\n        \n        l[i]+=1\n        break\notv=0\nfor i in range(19) :\n    \n    otv+=10**(19-i)*l[i]\n\nprint(max(n-otv+1,0))\n    \n    \n    \n        \n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "n = [int(x) for x in input().split()]\na = []\nfor i in range(3):\n\ta.append([int(x) for x in input().split()])\n\ta[i].sort(reverse=True)\n\ndp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]\nans = 0\nfor i in range(n[0] + 1):\n\tfor j in range(n[1] + 1):\n\t\tfor k in range(n[2] + 1):\n\t\t\tif i < n[0] and j < n[1]:\n\t\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])\n\t\t\tif i < n[0] and k < n[2]:\n\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])\n\t\t\tif j < n[1] and k < n[2]:\n\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])\n\t\t\tans = max(ans, dp[i][j][k])\n\nprint(ans )", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "a = int(input())\nprint(a * (a - 1) * 2 + 1)", "complexity": "constant", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# ------------------- fast io --------------------\nfrom bisect import bisect_left as bsl\ndef main():\n    cur=9;count=1;tot=0\n    num=[];cc=[]\n    for s in range(11):\n        num.append(cur*count)\n        tot+=cur\n        cc.append(tot)\n        cur*=10;count+=1\n    ans=[num[0]]\n    for s in range(1,11):\n        ans.append(ans[-1]+num[s])\n    k=int(input())\n    ind=min(bsl(ans,k),10)\n    left=k\n    if ind>0:\n        left-=ans[ind-1]\n    #sort out this bit below, might be ceil instead of //\n    nums=left//(ind+1);rem=left%(ind+1)\n    if left%(ind+1)!=0:\n        nums+=1\n    if ind>0:\n        nums+=cc[ind-1]\n    answer=[int(k) for k in str(nums)]\n    print(answer[rem-1])\nmain()", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "class Combination:\n    def __init__(self, n, MOD):\n        self.f = [1]\n        for i in range(1, n + 1):\n            self.f.append(self.f[-1] * i % MOD)\n        self.inv_f = [0] * (n + 1)\n        self.inv_f[n] = pow(self.f[n], MOD - 2, MOD)\n        for i in reversed(range(n)):\n            self.inv_f[i] = self.inv_f[i + 1] * (i + 1) % MOD\n        self.MOD = MOD\n\n    def inv(self, k):\n        \"\"\"get inverse(k)\"\"\"\n        return (self.inv_f[k] * self.f[k - 1]) % self.MOD\n\n    def fact(self, k):\n        \"\"\"get k!\"\"\"\n        return self.f[k]\n\n    def inv_fact(self, k):\n        \"\"\"get inverse(k!)\"\"\"\n        return self.inv_f[k]\n\n    def perm(self, k, r):\n        \"\"\"get kPr\"\"\"\n        if k < r:\n            return 0\n        return (self.f[k] * self.inv_f[k - r]) % self.MOD\n\n    def comb(self, k, r):\n        \"\"\"get kCr\"\"\"\n        if k < r:\n            return 0\n        return (self.f[k] * self.inv_f[k - r] * self.inv_f[r]) % self.MOD\n\n\ndef combination(k, r, MOD):\n    \"\"\"kCr O(r)\"\"\"\n    if k < r:\n        return 0\n    r = min(r, k - r)\n    numer, denom = 1, 1\n    for l in range(r):\n        numer *= (k - l)\n        numer %= MOD\n        denom *= l + 1\n        denom %= MOD\n    return numer * pow(denom, MOD - 2, MOD) % MOD\n\n\nimport sys\ninput = sys.stdin.buffer.readline\n\n\nn, MOD = map(int, input().split())\ncomb = Combination(10 ** 5, MOD)\n\n\ndp = [[0] * (n + 1) for i in range(n + 1)]\ndp[0][0] = 1\nfor i in range(1, n + 1):\n    dp[i][i] = pow(2, (i - 1), MOD)\n\npows = [pow(2, i, MOD) for i in range(n + 10)]\n\nfor i in range(n + 1):\n    for times in range(max(i // 2, 1), i + 1):\n        for length in range(1, times + 1):\n            nokori = times - length\n            ptn = pows[length - 1]\n            ptn *= comb.fact(times) * comb.inv_fact(nokori) * comb.inv_fact(length)\n            if i - length == 1:\n                continue\n            dp[i][times] += ptn * dp[i - length - 1][nokori]\n            dp[i][times] %= MOD\n\nprint(sum(dp[-1]) % MOD)", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import math\n\ndef get_digit(x, pos):\n    s = []\n    \n    while x > 0:\n        s.append(x%10)\n        x //= 10\n        \n    return s[::-1][pos]    \n\ndef find_digit(x):\n    n     = 0\n    next_ = 9 * (10**n) * (n+1)\n    \n    while next_ <= x:\n        x -= next_\n   \n        n += 1\n        next_ = 9 * (10**n) * (n+1)\n    \n    if x == 0:\n        return 9\n    \n    pos_ = 10 ** n + math.ceil(x / (n+1)) - 1\n    \n    return get_digit(pos_, (x-1)%(n+1))\n\n# 123456789101112131415\nk = int(input())\nprint(find_digit(k))", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "def good(max_branch, s, n):\n    nodes = 0\n    can = 1\n    lowest_s = 0\n    depth = 1\n    while(nodes < n):\n        added = min(n - nodes, can)\n        lowest_s += added * depth\n        nodes += added\n        can *= max_branch\n        depth += 1\n    return lowest_s <= s\n\n\nn, s = map(int, input().split())\n\nif s < 2 * n - 1 or s * 2 > n * (n + 1):\n    print('No')\nelse:\n    lo, hi = 1, n\n    while lo < hi:\n        mid = (lo + hi) >> 1\n        if good(mid, s, n) == False:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    max_branch = lo\n\n    level_size = [1] * (n + 1)\n    node_level = [i for i in range(n + 1)]\n    cur_node = n\n    cur_level = 1\n    cur_sum = n * (n + 1) // 2\n    can = 1\n    while cur_sum > s:\n        if level_size[cur_level] == can:\n            cur_level += 1\n            can *= max_branch\n            \n        if cur_sum - (cur_node - cur_level) < s:\n            cur_level = cur_node - (cur_sum - s)\n                \n        node_level[cur_node] = cur_level\n        level_size[cur_level] += 1\n        cur_sum -= cur_node - cur_level\n        cur_node -= 1\n\n    #print(cur_sum)\n    #print(node_level)\n    \n    node_list = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        node_list[node_level[i]].append(i)\n\n    pre = 0\n    children = [0] * (n + 1)\n    parent = [-1] * (n + 1)\n    seen_nodes = 1\n    for level in range(2, n + 1):\n        idx = 0\n        if not node_list[level - 1]:\n            assert seen_nodes == n\n            break\n        cur_father = node_list[level - 1][0]\n        for node in node_list[level]:\n            if children[cur_father] == max_branch:\n                idx += 1\n                cur_father = node_list[level - 1][idx]\n            children[cur_father] += 1\n            parent[node] = cur_father\n            seen_nodes += 1\n            \n    print('Yes')\n    print(*parent[2:])\n", "complexity": "linear", "problem": "1098_C", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,dfs and similar,graphs,greedy,trees"}
{"src": "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nimport math\nimport heapq\nfrom itertools import accumulate\n\nQ = int(input())\n#s = input() \n#N,K = [int(x) for x in stdin.readline().split()]\n\nfour = []\n\nfor i in range(62):\n    four.append(4**i)\n\nfor i in range(Q):\n    N,K = [int(x) for x in stdin.readline().split()]\n    \n    tmp_N = N\n    if N>=60:\n        N = 60\n        \n    dk = (4**(N)-1)//3\n    if K>dk:\n        print('NO')\n        continue\n    \n    seq = []\n    block = []\n    s = 0\n    for i in range(N):\n        s += 2**(i+1) - 1\n        block.append(2**(i+1)-1)\n        seq.append(s)\n        \n    if K>=seq[-1]:\n        print('YES',0)\n        continue\n    \n    #print(seq)\n    for i in range(N-1):\n        if K>=seq[i] and K<seq[i+1]:\n            d = K-seq[i]\n            happy = tmp_N-i-1\n            round = i+1\n            break\n    \n    block = block[::-1]\n    #print(block)\n    res = 0\n    for i in range(round):\n        A = (4**(i+1)-1)//3\n        B = block[i] - 2\n        res += A*B\n        \n    #print(res)\n    \n    if d<=res:\n        print('YES',happy)\n    else:\n        print('NO')\n    \n        \n    \n    \n    \n    \n    ", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import sys\n\nn, s = map(int, input().split())\n\nok, ng = 10**18+100, -1\nwhile abs(ok - ng) > 1:\n    mid = (ok + ng) >> 1\n    if mid - sum(map(int, str(mid))) >= s:\n        ok = mid\n    else:\n        ng = mid\n\nprint(max(0, n - ok + 1))\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "R, G, B = map(int, input().split())\nr = list(map(int, input().split()))\ng = list(map(int, input().split()))\nb = list(map(int, input().split()))\nr.sort()\ng.sort()\nb.sort()\ndp = [[[0]*202 for i in range(202)] for j in range(202)]\nfor i in range(R+1):\n       for j in range(G+1):\n              for k in range(B+1):\n                     if i and j:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])\n                     if i and k:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])\n                     if k and j:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])\nans = 0\nfor i in dp:\n       for j in i:\n              ans = max(ans, max(j))\n\nprint(ans)\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "def resheto(a):\n    numbers = list(range(0, a + 1))\n    primes = set()\n    for k in range(2, a + 1):\n        if numbers[k] != 0:\n            primes.add(k)\n            for j in range(2 * k, a + 1, k):\n                numbers[j] = 0\n    return primes\n\n\nall_primes = resheto(10**6)\nn = int(input())\nfor i in range(2, n):\n    if i not in all_primes and (n - i) not in all_primes:\n        print(i, n - i)\n        break", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "list1=input()\nl=list1.split()\nl=[int(item) for item in l]\n\nn,m,k=l\n\na=input()\na1=map(int,a.split())\n\na1=list(sorted(a1))\n\ncount=0\nfor i in range(len(a1)):\n    if k>=m:\n        break\n    else:\n        k+=a1.pop()-1\n        count+=1\n\nif k>=m:    \n    print(count)\nelse:\n    print(\"-1\")", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "def solve():\n    n, k = [int(x) for x in input().split(' ')]\n    t = input()\n    j = 0\n    for i in range(1, n):\n        if t[:i] == t[-i:]:\n            j = i\n    s = t + (k - 1) * t[-(n - j):]\n    return s\n\nprint(solve())\n\n", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "import sys,os,io\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import defaultdict\n\nn,m = [int(i) for i in input().split()]\na = []\nmi = -1\nma = 10**9\nfor i in range (n):\n    a.append([int(j) for j in input().split()])\n\nans = []\nwhile(mi<ma):\n    mid = (mi+ma+1)//2\n    masks = {}\n    for i in range (n):\n        currMask = 0\n        for j in range (m):\n            if a[i][j] >= mid:\n                currMask +=  1<<j\n        masks[currMask] = i\n    req = (1<<m) - 1\n    possible = 0\n    for i in masks:\n        for j in masks:\n            if i|j == req:\n                possible = 1\n                ans = [masks[i]+1,masks[j]+1]\n                break\n        if possible:\n            break\n    if possible:\n        mi = mid\n    else:\n        ma = mid - 1\nprint(*ans)", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import math\ntemp=list(map(int,input().split()))\nN,q=temp[0],temp[1]\nfor j in range(0,q):\n    u=int(input())\n    S=input()\n    k=(N+1)//2\n    n=int(math.log((N+1),10)/math.log(2,10))-1\n    dup_n=n\n    store=[k]\n    while u!=k:\n        n-=1\n        if u>k:\n            k+=2**(n)\n        else:\n            k-=2**(n)\n        store.append(k)\n    for i in range(0,len(S)):\n        if S[i]=='R':\n            n-=1\n            if n==-1:\n                n=0\n                continue\n            k+=2**(n)\n        elif S[i]=='L':\n            n-=1\n            if n==-1:\n                n=0\n                continue\n            k-=2**(n)\n        else:\n            if n==dup_n:\n                continue\n            store.pop()\n            k=store[len(store)-1]\n            n+=1\n            continue\n        store.append(k)\n            \n    print(k)", "complexity": "np", "problem": "0792_D", "from": "CODEFORCES", "tags": "bitmasks,trees"}
{"src": "s=input()\no=len(s)\nk=0\nfor i in range(o):\n    r={0}\n    for j in range(o-i+1):\n        if s[j:j+i] in r:k=max(i,k)\n        else:r.add(s[j:j+i])\nprint(k)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "from math import sin, pi\nn, r = map(int, input().split())\nR = r*sin(pi/n)/(1-sin(pi/n))\nprint(R)\n", "complexity": "constant", "problem": "1100_C", "from": "CODEFORCES", "tags": "binary search,geometry,math"}
{"src": "def solve(x, y, n):\n    return \"White\" if (x-1 + y-1) <= (n-x + n-y) else \"Black\"\n\n\ndef main():\n    n = int(input())\n    x, y = [int(i) for i in input().split()]\n    print(solve(x, y, n))\n\n\nmain()\n", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n, s = map(int, input().split())\ntimes = []\nresult = 0 \nneed = True \nfor i in range (n):\n    h, m = map(int, input().split())\n    times.append(60*h + m)\n\nif n == 1:\n    if 0 + s + 1 <= times[0]:\n        need = False\nfor i in range(n-1):\n    if 0 + s + 1 <= times[0]:\n        need = False\n        break\n    if times[i+1] - times[i] >= 2 + 2*s:\n        result = times[i] + 1 + s\n        break \nif result == 0 and need:\n    result = times[n-1] + 1 + s\n\nhour = result // 60\nminute = result % 60\n\nprint(hour, minute)", "complexity": "linear", "problem": "0967_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "d = {\n    \"purple\": \"Power\",\n    \"green\": \"Time\",\n    \"blue\": \"Space\",\n    \"orange\": \"Soul\",\n    \"red\": \"Reality\",\n    \"yellow\": \"Mind\",\n}\n\nall_colors = list(d.keys())\n\nn = int(input())\ncolors = [input() for i in range(n)]\n\nprint(len(d) - len(colors))\nfor color in all_colors:\n    if color not in colors:\n        print(d[color])\n", "complexity": "constant", "problem": "0987_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from sys import stdin, stdout\nnmbr = lambda: int(input())\nlst = lambda: list(map(int, input().split()))\n\nfor _ in range(1):#nmbr()):\n    n,m=lst()\n    a=lst()\n    a=[0]+a+[m]\n    n=len(a)\n    suf=[0]*n\n    suf[n-2]=abs(a[-2]-a[-1])\n    for i in range(n-3, -1, -1):\n        suf[i]=a[i+1]-a[i]+suf[i+2]\n    ans=suf[0]\n    cost=0\n    for i in range(1, n):\n        if i&1:\n            v=a[i]-1-a[i-1]\n            if v!=0:ans=max(ans, cost+v+suf[i])\n            cost+=a[i]-a[i-1]\n        else:\n            v=a[i-1]+1\n            if v!=a[i]:ans=max(ans, cost+a[i]-v+(suf[i+1] if i+1<n else 0))\n    print(ans)", "complexity": "linear", "problem": "1000_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "a = input().split()\nb = [int(i) for i in a]\ninputs = []\ndiff = []\nsinComprimir = 0\nfor i in range(b[0]):\n    input1 = input().split()\n    input2 = [int(i) for i in input1]\n    inputs.append(input2)\n\ncomprimido = 0\nfor k in range(len(inputs)):\n    sinComprimir = sinComprimir + inputs[k][0]\n    diff.append(inputs[k][0] - inputs[k][1])\n    comprimido = comprimido + inputs[k][1] \n\ndifference = sorted(diff)\ninvDifference = difference[::-1]\nnewTotal = sinComprimir\niteraciones = 0\niterador = 0\nif sinComprimir <= b[1]:\n    print(\"0\")\nelif comprimido > b[1]:\n    print(\"-1\")\nelse:\n    while newTotal > b[1]:\n        iterador = iterador + 1\n        newTotal = newTotal - invDifference[iterador-1] \n        iteraciones += 1\n    print(iteraciones)", "complexity": "nlogn", "problem": "1015_C", "from": "CODEFORCES", "tags": "sortings"}
{"src": "n=int(input())\na,b=map(int,input().split())\nwhite=abs(a-1)+abs(b-1)\nblack=abs(n-a)+abs(n-b)\nif white<=black:\n    print(\"White\")\nelse:\n    print(\"Black\")", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "from collections import Counter\n\ndef solve(n, ribbons):\n\tL = len(ribbons[0])\n\ta = [Counter(r).most_common(1)[0][1] for r in ribbons]\n\n\tr = sorted([(x, i) for i, x in enumerate(a)], reverse=True)\n\n\tif n == 1:\n\t\tc = Counter(a)\n\t\tif c[L - 1] == 1:\n\t\t\tfor i in range(3):\n\t\t\t\tif a[i] == L - 1: return i\n\t\tif c[L - 1] > 1:\n\t\t\treturn 3\n\t\tif c[L] + c[L - 2] == 1:\n\t\t\tfor i in range(3):\n\t\t\t\tif a[i] == L or a[i] == L-2:\n\t\t\t\t\treturn i\n\t\tif c[L] + c[L - 2] > 1:\n\t\t\treturn 3\n\n\tif r[1][0] == r[0][0]:\n\t\treturn 3\n\tif r[1][0] + n >= L:\n\t\treturn 3\n\treturn r[0][1]\n\n\tprint(a)\n\ndef main():\n\tn = int(input())\n\tcats = ('Kuro', 'Shiro', 'Katie', 'Draw')\n\n\tribbons = [input().strip() for _ in range(3)]\n\n\t# print(ribbons)\n\tk = solve(n, ribbons)\n\tprint(cats[k])\n\nif __name__ == '__main__':\n\tmain()", "complexity": "linear", "problem": "0979_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "n = int(input())-1\nc = 0\nfor i in range(11):\n\tc += 9*(i+1)* 10**i\n\tif c > n:\n\t\tn -= (c - 9*(i+1)* 10**i)\n\t\tv = n // (i+1)\n\t\tprint(str(10**i + v)[n%(i+1)])\n\t\tbreak\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import sys\nfrom array import array  # noqa: F401\nimport typing as Tp  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\ndef output(*args):\n    sys.stdout.buffer.write(\n        ('\\n'.join(map(str, args)) + '\\n').encode('utf-8')\n    )\n\n\ndef main():\n    n, m, k = map(int, input().split())\n    a = list(map(float, input().split()))\n    add = [[0] * n for _ in range(n + 1)]\n    for xi, yi, ci in (map(int, input().split()) for _ in range(k)):\n        add[xi - 1][yi - 1] = float(ci)\n\n    minf = float('-inf')\n    dp = [[minf] * (2**n) for _ in range(n + 1)]\n    dp[n][0] = 0.0\n\n    for bitset in range(2**n):\n        if bin(bitset).count('1') >= m:\n            continue\n\n        for i in range(n + 1):\n            if dp[i][bitset] == minf:\n                continue\n            for j in range(n):\n                if (1 << j) & bitset:\n                    continue\n                dp[j][bitset | (1 << j)] = max(\n                    dp[j][bitset | (1 << j)],\n                    dp[i][bitset] + a[j] + add[i][j]\n                )\n\n    print(int(max(max(_dp) for _dp in dp) + 1e-7))\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "np", "problem": "0580_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "k=int(input())\ni=0\nr=1\nwhile(k>=r):\n    r+=9*(i+1)*10**i\n    i+=1\nr=r-(9*i*10**(i-1))\nans=str(((k-r)//i)+10**(i-1))[(k-r)%i]\nprint(ans)\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "class edge(object):\n\tdef __init__(self,ne,to,fl):\n\t\tself.ne=ne\n\t\tself.to=to\n\t\tself.fl=fl\n\ndef add(x,y,z):\n\tglobal tot\n\ttot+=1\n\te.append(edge(he[x],y,z))\n\the[x]=tot\n\ndef addedge(x,y,z):\n\tadd(x,y,z)\n\tadd(y,x,0)\n\ndef bfs():\n\tglobal deep\n\tdeep=[0 for i in range(T+1)]\n\tq=[]\n\tq.append(S)\n\tdeep[S]=1\n\tlp=0\n\twhile (len(q)>lp):\n\t\tx=q[lp]\n\t\tlp+=1\n\t\ti=he[x]\n\t\twhile (i):\n\t\t\ty=e[i].to\n\t\t\tif ((deep[y]==0)and(e[i].fl!=0)):\n\t\t\t\tdeep[y]=deep[x]+1\n\t\t\t\tq.append(y)\n\t\t\ti=e[i].ne\n\treturn deep[T]!=0\n\ndef dfs(x,flow):\n\tglobal deep\n\tif ((x==T)or(flow==0)):\n\t\treturn flow\n\tused=0\n\ti=he[x]\n\twhile (i):\n\t\ty=e[i].to\n\t\tif ((deep[y]==deep[x]+1)and(e[i].fl!=0)):\n\t\t\tnow=dfs(y,min(flow-used,e[i].fl))\n\t\t\tused+=now\n\t\t\te[i].fl-=now\n\t\t\te[i^1].fl+=now\n\t\t\tif (flow==used):\n\t\t\t\tbreak;\n\t\ti=e[i].ne\n\tif (used==0):\n\t\tdeep[x]=-1\n\treturn used\n\ndef dinic():\n\tres=0\n\twhile (bfs()):\n\t\tres+=dfs(S,INF)\n\treturn res\n\nn,m=map(int,input().split())\nans=0\nweight=[0]+list(map(int,input().split()))\n\ne=[0,0]\ntot=1\nS=n+m+1\nT=S+1\nhe=[0 for i in range(T+1)]\nINF=1000000007#\u53ea\u8981>10^9\u5c31\u8db3\u591f\u4e86\n\nfor i in range(1,n+1):\n\taddedge(S,i,weight[i]);\nfor i in range(1,m+1):\n\tx,y,w=map(int,input().split())\n\taddedge(n+i,T,w)\n\taddedge(x,n+i,INF)\n\taddedge(y,n+i,INF)\n\tans+=w\nans-=dinic()\nprint(ans)", "complexity": "cubic", "problem": "1082_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "\ndef cic(my_string):\n\tmy_hash=set();\n\tmax_v=-1<<256;\n\tfor i in range(len(my_string)):\n\t\tempty=my_string[i]+''\n\t\tif empty in my_hash:\n\t\t\tmax_v=max(max_v,len(empty))\n\t\telse:\n\t\t\tmy_hash.add(empty)\n\t\tfor j in range(i+1,len(my_string)):\n\t\t\tempty+=my_string[j]\n\t\t\tif empty not in my_hash:\n\t\t\t\tmy_hash.add(empty)\n\t\t\telse:\n\t\t\t\tmax_v=max(max_v,len(empty))\n\treturn 0 if max_v<0 else max_v\n\ndef main():\n\tmy_string=input()\n\tprint(cic(my_string))\n\n\n\nif __name__=='__main__':\n\tmain()\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "d = {}\nn = int(input())\nfor _ in range(n):\n\ta,x = map(int,input().split())\n\td[a] = x\nm = int(input())\nfor _ in range(m):\n\tb,y = map(int,input().split())\n\tif b in d:\n\t\td[b] = max(y,d[b])\n\telse:\n\t\td[b] = y\ncount = 0\nfor i in d:\n\tcount += d[i]\nprint(count)", "complexity": "nlogn", "problem": "0981_B", "from": "CODEFORCES", "tags": "sortings"}
{"src": "n = int(input())\nchess = []\nfor w in range(3):\n    chess.append([input() for i in range(n)])\n    input()\nchess.append([input() for i in range(n)])\n\nissue = {0:0, 1:0, 2:0, 3:0}\nreversed_issue = {0:0, 1:0, 3:0}\n\nfor w in range(4):\n    chessdesk = [chess[0] + chess[3]] + [chess[1] + chess[2]]\n    for s in range(2 * n):\n        chessdesk[0][s] += chessdesk[1][s]\n    chessdesk.pop(1)\n    chessdesk = chessdesk[0]\n    colour = chessdesk[0][0]\n\n    for i in range(2 * n):\n        for j in range(2 * n):\n            if (i + j) % 2 == 0:\n                if chessdesk[i][j] != colour:\n                    issue[w] += 1\n            else:\n                if chessdesk[i][j] == colour:\n                    issue[w] += 1\n\n    reversed_issue[w] = 4 * n**2 - issue[w]              \n    if w == 0:\n        chess[0], chess[3] = chess[3], chess[0]\n    elif w == 1:\n        chess[1], chess[3] = chess[3], chess[1]\n    elif w == 2:\n        chess[1], chess[2] = chess[2], chess[1]\n\nprint(min(min(issue.values()), min(reversed_issue.values())))", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\nA.sort()\n\nfrom collections import Counter\nC=Counter(A)\ndou=0\n\nfor c in C:\n    dou+=C[c]-1\n\n    if C[c]>=2 and C[c-1]!=0:\n        print(\"cslnb\")\n        sys.exit()\n        \nif dou>=2:\n    print(\"cslnb\")\n    sys.exit()\n\nANS=0\nfor i in range(n):\n    if A[i]<i:\n        print(\"cslnb\")\n        sys.exit()\n    ANS+=(A[i]-i)%2\n\nif ANS%2==0:\n    print(\"cslnb\")\n    sys.exit()\nelse:\n    print(\"sjfnb\")\n    sys.exit()\n    \n    \n", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "\ndef bin_ser(arr,curr):\n    l=0\n    r=len(arr)-1\n    ans=-1\n    while l<=r:\n        mid=(l+r)//2\n        if arr[mid]<=curr:\n            ans=mid\n            l=mid+1\n        else:\n            r=mid-1\n    return ans\n\n\ndef main():\n    n,q=map(int,input().split())\n    arr=list(map(int,input().split()))\n    brr=list(map(int,input().split()))\n    su=sum(arr)\n    curr=0\n    for i in range(1,n):\n        arr[i]=arr[i]+arr[i-1]\n    for b in brr:\n        curr+=b\n        pos=n-bin_ser(arr,curr)-1\n        if pos==0:\n            pos=n\n        print(pos)\n        if curr>=su:\n            curr=0\n\nmain()", "complexity": "nlogn", "problem": "0975_C", "from": "CODEFORCES", "tags": "binary search"}
{"src": "from math import sqrt\nn, k = map(int, input().split())\nprint(int(n - 0.5 * (sqrt(8 * (k + n) + 9) - 3)))\n", "complexity": "constant", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "x,k=[int(i) for i in input().split()]\nif x!=0:\n    print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)\nelse:\n    print(0)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "def path(x1,y1,x2,y2,hor):\n    out=[]\n    if hor:\n        for i in range(x2-x1):\n            out.append((x1+i,y1))\n        if y2>y1:\n            for i in range(y2-y1):\n                out.append((x2,y1+i))\n        else:\n            for i in range(y1-y2):\n                out.append((x2,y1-i))\n    else:\n        for i in range(x2-x1):\n            out.append((x2-i,y2))\n        if y2>y1:\n            for i in range(y2-y1):\n                out.append((x1,y2-i))\n        else:\n            for i in range(y1-y2):\n                out.append((x1,y2+i))\n    return out[1:]\na,b=map(int,input().split())\nc,d=map(int,input().split())\ne,f=map(int,input().split())\nif a>c:\n    a,b,c,d=c,d,a,b\nif c>e:\n    c,d,e,f=e,f,c,d\nif a>c:\n    a,b,c,d=c,d,a,b\nif c==e and abs(f-b)<abs(d-b):\n    c,d,e,f=e,f,c,d\ng1=path(a,b,c,d,True)\nif d>b:\n    if f<b:\n        g2=path(c,b,e,f,True)\n    elif f<d:\n        g2=path(c,f,e,f,True)\n    else:\n        g2=path(c,d,e,f,True)\nelse:\n    if f<d:\n        g2=path(c,d,e,f,True)\n    elif f<b:\n        g2=path(c,f,e,f,True)\n    else:\n        g2=path(c,b,e,f,True)\nprint(len(g1)+len(g2)+3)\nprint(a,b)\nprint(c,d)\nprint(e,f)\nfor x,y in g1:\n    print(x,y)\nfor x,y in g2:\n    print(x,y)", "complexity": "constant", "problem": "1086_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "from bisect import bisect_left\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, raw_input().split())\n    verticals = [int(raw_input()) for _ in range(n)]\n    h = [map(int, raw_input().split()) for _ in range(m)]\n    horizontals = [t[1] for t in h if t[0] == 1] \n\n    verticals.sort()\n    horizontals.sort()\n    verticals.append(10**9)\n    min_blockers = n + m\n    for i, v in enumerate(verticals):\n        cur_blockers = len(horizontals) - bisect_left(horizontals, v) + i\n        min_blockers = min(min_blockers, cur_blockers)\n\n    print(min_blockers)\n", "complexity": "nlogn", "problem": "1075_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "mod=10**9+7\nn=int(input())\nl=[]\nc=0\nfor i in range(n):\n    l.append(input())\ndp=[[0]*(n+2) for i in range(n+1)]\nfor i in range(n+2):\n    dp[n][i]=1\nfor i in range(n-1,0,-1):\n    s=0\n    for j in range(n+1):\n        s+=dp[i+1][j]\n        s%=mod\n        if l[i-1]=='f':\n            dp[i][j]=dp[i+1][j+1]\n        else:\n            dp[i][j]=s\n\nprint(dp[1][0])\n    \n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "from itertools import combinations\nn, l, r, x = map(int, input().split())\na = [int(x) for x in input().split()]\nans = 0\nfor i in range(2, n+1):\n    for p in combinations(a, i):\n        if l<=sum(p)<=r and max(p)-min(p)>=x:\n            ans += 1\nprint(ans)\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "n = int(input())\nprint(25)", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\ndef main():\n  N, M = map(int, input().split())\n  L = [tuple(map(int, input().split())) for _ in range(N)]\n  maxi = max(max(t) for t in L)+1\n  mini, res = max((min(t), i) for i, t in enumerate(L))\n  res = res, res\n  BITMASK = (1 << M)\n  while True:\n    mid = (maxi+mini)//2\n    #print(f'{mini} {mid} {maxi}')\n    if mid == mini:\n      break\n    masks = [None]*BITMASK\n    for i, t in enumerate(L):\n      tmask = 0\n      for v in t:\n        tmask *= 2\n        if v >= mid:\n          tmask += 1\n      if masks[tmask] is not None:\n        continue\n      masks[tmask] = i\n      for k in range(BITMASK):\n        if masks[k] is not None and k | tmask == BITMASK-1:\n          res = masks[k], i\n          mini = mid = min(max(a, b) for a, b in zip(L[res[0]], L[res[1]]))\n          break\n      else:\n        continue\n      break\n    else:\n      maxi = mid\n    #print(masks)\n  print(res[0]+1, res[1]+1)\n\n\nmain()\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "from sys import stdin\nfrom operator import xor\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, a, m = int(input()), [rints()], int(input())\nqur, out = [rints() for _ in range(m)], []\n\nfor i in range(1, n):\n    a.append(list(map(xor, a[-1][:-1], a[-1][1:])))\n\nfor i in range(n - 1):\n    a[i + 1] = list(map(max, a[i][:-1], a[i][1:], a[i + 1]))\n\nfor l, r in qur:\n    out.append(a[r - l][l - 1])\n\nprint('\\n'.join(map(str, out)))\n", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "def main():\n    a = sorted(input(), reverse=True)\n    b = int(input())\n    k = \"\"\n    while len(a) > 0:\n        for i in range(len(a)):\n            num = k + a[i] + \"\".join(sorted(a[:i] + a[i + 1:]))\n            if int(num) <= b:\n                k += a[i]\n                a = a[:i] + a[i + 1:]\n                break\n    print(k)\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "\n_=input()\nn=input()\nnum=int(n)\n\nlist_n=list(n)\nlist_n_int=list(map(int,n))\n\n\nlower=max(list_n_int)\ntotal=sum(list_n_int)\nupper=int(total/2)\n\nflag=False\nif lower == 0:\n    print(\"YES\")\nelse:\n    for i in range(lower,upper+1):\n        flag=True\n        p=0\n        temp=0\n        each=i\n        seg=total/each\n        if seg.is_integer():\n            while p < len(n):\n\n                temp+=list_n_int[p]\n                if temp < each:\n                    p+=1\n                elif temp == each:\n                    temp=0\n                    p+=1\n                else:\n                    flag=False\n                    break\n            if flag:\n                print(\"YES\")\n                break\n        else:\n            flag=False\n    if not flag:\n        print(\"NO\")\n", "complexity": "quadratic", "problem": "1030_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "R, G, B = list(map(lambda x: int(x), input().split()))\nr = list(map(lambda x: int(x), input().split()))\ng = list(map(lambda x: int(x), input().split()))\nb = list(map(lambda x: int(x), input().split()))\n\ndef f(t):\n    i, j, k = t\n    return (i+1)*(G+1)*(B+1) + (j+1)*(B+1) + (k+1)\n\nmax_area = [None]*((R+1)*(G+1)*(B+1)+1)\n\ndef get_max_area(i, j, k):\n    temp = f((i,j,k))\n    if max_area[temp] != None:\n        return max_area[temp]\n    x1=x2=x3=0\n    if i >= 0 and j>=0:\n        x1 = get_max_area(i-1, j-1, k) + r[i]*g[j]\n    if i >= 0 and k >= 0:\n        x2 = get_max_area(i-1, j, k-1) + r[i]*b[k]\n    if j >= 0 and k >= 0:\n        x3 = get_max_area(i, j-1, k-1) + g[j]*b[k]\n\n    max_area[temp] = max(x1, x2, x3)\n    return max_area[temp]\n\nr.sort()\ng.sort()\nb.sort()\nprint(get_max_area(R-1, G-1, B-1))\n#print(max_area)    ", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "def summing(number):\n    summa = 0\n    while number > 0:\n        summa += number % 10\n        number = number // 10\n    return summa\n\n\ndef result(n, s):\n    z = min(s, n)\n    while z <= n and z - summing(z) < s:\n        z += 1\n    return n - z + 1\n\n\na, b = [int(i) for i in input().split()]\nprint(result(a, b))\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import math\n\nl1 = input().split()\n#l2 = input().split()\n\nl1 = [int(i) for i in l1]\n\nl2 = l1[1]\nl1 = l1[0]\n\n#l2 = [[int(i)] for i in l2]\n#l2 = [0] + l2\n\nx=l1^l2;\ny=1;\nwhile(y<=x):\n  y=y*2;\n\nprint(y-1);\n\n  \t   \t  \t    \t  \t\t\t   \t\t\t\t  \t\t", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "l,r=map(int,input().split())\nif(l%2==0 and r-l>1):\n    print(l,l+1,l+2,end=\" \")\nelif(l%2!=0 and r-l>2):\n    print(l+1,l+2,l+3,end=\" \")\nelse:\n    print(\"-1\")", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "ax, ay = map(int, input().split())\nbx, by = map(int, input().split())\ncx, cy = map(int, input().split())\nif ax > bx:\n    ax, bx = bx, ax\n    ay, by = by, ay\nif ax > cx:\n    ax, cx = cx, ax\n    ay, cy = cy, ay\nif bx > cx:\n    bx, cx = cx, bx\n    by, cy = cy, by\nans = []\nfor i in range(min(ay, by, cy), max(ay, by, cy) + 1):\n    ans.append([bx, i])\nfor i in range(ax, bx):\n    ans.append([i, ay])\nfor i in range(bx + 1, cx + 1):\n    ans.append([i, cy])\nprint(len(ans))\nfor x in ans:\n    print(x[0], x[1])\n\n\t \t \t\t    \t\t \t    \t \t\t\t\t\t \t", "complexity": "constant", "problem": "1086_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "n = int(input())\ns = input()\nx = s.count('0')\nif s == '0':\n    print('0')\nelse:\n    print('1' + '0'*x)", "complexity": "linear", "problem": "0976_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import math\nn=int(input())\nprint((math.floor(n/2)+1)*math.ceil(n/2))", "complexity": "linear", "problem": "0909_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)\nk = int(input())\na = 0\nfor i in T:\n    if i - k > 0:\n        a = T.index(i)\n        break\ntemp = T[a] - k\nx = temp % a\nres = (10 ** a) - 1 - int(temp / a)\nans = int((res % (10 ** (x+1))) / (10 ** x))\nprint(ans)\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "n, m = map(int, input().split())\na = sorted(list(map(int, input().split())))\ns = sorted(list(map(int, input().split())))\nif a[-1] > s[0]:\n    print(-1)\nelse:\n    if a[-1] == s[0]:\n        print(sum(a[:-1])*m+sum(s))\n    else:\n        print(sum(a[:-2])*m+a[-2]*(m-1)+sum(s)+a[-1])\n", "complexity": "nlogn", "problem": "1159_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "l = []\nn = []\nsum = 0\nmultiply = 9\nfor i in range(1,12):\n    s = '9' * i\n    n.append(int(s))\n    sum+=i*multiply\n    multiply *= 10\n    l.append(sum)\nk = int(input())\nif(k<9):\n    print(k)\nelse:\n    t = 0\n    for i in range(len(l)):\n        if(k < l[i]):\n            t=i\n            break\n    temp = k-l[t-1]\n    offset = temp%(t+1)\n    value = temp//(t+1)\n    number = n[t-1]+value\n    if(offset == 0):\n        print(number%10)\n    else:\n        number += 1\n        offset -= 1\n        print(str(number)[offset])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "n, k = [int(i) for i in input().split()]\np = [int(i) for i in input().split()]\nans = [-1] * (max(p) + 1)\nans[0] = 0\nfor i in range(n):\n\tif ans[p[i]] < 0:\n\t\tposition = p[i] - k + 1\n\t\tfor j in range(max(0,p[i] - k + 1), p[i] + 1):\n\t\t\tif ans[j] < 0:\n\t\t\t\tposition = j\n\t\t\t\tbreak\n\t\tj = max(0, position - 1)\n\t\tkey = ans[j]\n\t\tcount = 0\n\t\twhile j >= 0:\n\t\t\tif ans[j] != key:\n\t\t\t\tposition1 = j + 1\n\t\t\t\tbreak\n\t\t\tj -= 1\n\t\t\tcount += 1\n\t\tif count + p[i] + 1 - position > k:\n\t\t\tkey = position\n\t\tfor j in range(position, p[i] + 1):\n\t\t\tans[j] = key\n\nfor i in range(n):\n\tif i != len(p) - 1:\n\t\twk1 = \" \"\n\telse:\n\t\twk1 = \"\\n\"\n\tprint(ans[p[i]], end = wk1)\n", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "n=int(input())\nl1=list(map(int,input().split()))\nif n%2==0:\n    for i in range(n):\n        if l1[i]>=0:\n            l1[i]=-1*l1[i]-1\nelse :\n    for i in range(n):\n        if l1[i]>=0:\n            l1[i]=-1*l1[i]-1\n    l1[l1.index(min(l1))]=l1[l1.index(min(l1))]*-1 -1\nprint(' '.join(str(x) for x in l1))", "complexity": "linear", "problem": "1180_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "x=input()\na=0\nfor i in range(len(x)):\n    for j in range(i,len(x)):\n        if x[i:j] in x[i+1:]:\n            if len(x[i:j])>a:\n                a=len(x[i:j])\nprint(a)\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "'''\n      Mayank Sheoran \n      BITS PILANI GOA CAMPUS \n''' \n\nn,m,k = map(int,input().split())\nright = [[9999999 for i in range(m-1)] for j in range(n)]\ndown =  [[9999999 for i in range(m)] for j in range(n-1)]\nfor i in range(n):\n    right[i] = list(map(int,input().split()))\nfor i in range(n-1):\n    down[i] = list(map(int,input().split()))\n\nif(k%2==1):\n    for i in range(n):\n        for j in range(m):\n            print(\"-1\",end=\" \")\n        print()\nelse:\n    k = k//2\n    row = n\n    col = m\n    dp  = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)]\n    for steps in range(k+1):\n        for i in range(row):\n            for j in range(col):\n                if(steps==0):\n                    dp[steps][i][j] = 0\n                    continue\n                ans = 99999999999\n                if(i>0):\n                    ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j])\n                if(i<n-1):\n                    ans = min(ans,dp[steps-1][i+1][j]+down[i][j])\n                if(j<m-1):\n                    ans = min(ans,dp[steps-1][i][j+1]+right[i][j])\n                if(j>0):\n                    ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1])\n                dp[steps][i][j] = ans\n                \n    for i in range(n):\n        for j in range(m):\n            print(2*dp[k][i][j],end=\" \")\n        print()\n    ", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from math import gcd\nfrom collections import defaultdict as dd\nm=int(input())\nd=dd(int)\nl=[]\nans=[]\nfor i in range(m):\n    s=input().split()[0]\n    a=0\n    b=0\n    c=0\n    n=len(s)\n    ind=0\n    for i in range(1,n):\n        if(s[i]=='+'):\n            ind=i+1\n            break\n        a=a*10+int(s[i])\n    for i in range(ind,n):\n        if(s[i]==')'):\n            ind1=i+2\n            break\n        b=b*10+int(s[i])\n    for i in range(ind1,n):\n        c=c*10+int(s[i])\n    a=a+b\n    g=gcd(a,c)\n    a=a//g\n    c=c//g\n    d[(a,c)]+=1\n    l.append((a,c))\nfor i in l:\n    ans.append(d[i])\nprint(*ans)", "complexity": "linear", "problem": "0958_D1", "from": "CODEFORCES", "tags": "expression parsing,math"}
{"src": "n=int(input())\nc=0\nlst=[4,7,47,74,447,474,744,477,747,774]\nif n in lst:\n    print(\"YES\")\nelse:\n    for i in lst:\n        if n%i==0:\n            print(\"YES\")\n            c=c+1\n            break\n        else:\n            continue\n    if c==0:\n        print(\"NO\")\n    \n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn, a, b = [int(i) for i in input().split()]\nh = sorted([int(i) for i in input().split()])\nVasya = h[:b]\nPetya = h[b:]\nprint(Petya[0] - Vasya[-1])\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "n = int(input())\nl = [*map(int, input().split())]\n\np = [0] * n\nfor i in range(n): p[l[i] - 1] = i\n\nres = ['?'] * n\n\nfor e in range(n, 0, -1):\n    i = p[e - 1]\n    res[i] = 'B'\n    for j in range(i % e, n, e):\n        if i != j and l[i] <= l[j] and res[j] == 'B':\n            res[i] = 'A'\n            break \nprint(''.join(res))", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "MOD=1000000007\n\ndef powr(n,N):\n    temp=1\n    while(N>0):\n        if(N%2!=0):\n            temp=(temp*n)%MOD\n        n=(n*n)%MOD\n        N=N//2\n    return (temp%MOD)\n \n\"\"\"def powr(n,N):\n    if(N==1):\n        ans=n\n        return ans\n    else:\n        ans=powr(n,N//2)\n        if(N%2==0):\n            return ((ans*ans)%MOD)\n        else:\n            return ((((ans*ans)%MOD)*n)%MOD)\"\"\"\n \ndef MODI(a,b):\n    ans=(powr(a,b)%MOD)\n    return ans\n \n\n\nx,k=map(int,input().split())\nif(x==0):\n    print(0)\nelse:\n    t1=powr(2,k+1)%MOD\n    t1=(t1*x)%MOD\n    t2=powr(2,k)%MOD\n    t2=(t2-1)%MOD\n    ans=(t1-t2)%MOD\n    print(ans)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "from os import path;import sys,time\nmod = int(1e9 + 7)\nfrom math import ceil, floor,gcd,log,log2 ,factorial,sqrt\nfrom collections import defaultdict ,Counter , OrderedDict , deque;from itertools import combinations,permutations\nfrom string import ascii_lowercase ,ascii_uppercase\nfrom bisect import *;from functools import reduce;from operator import mul;maxx = float('inf')\nI = lambda :int(sys.stdin.buffer.readline())\nlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\nS = lambda: sys.stdin.readline().strip('\\n')\ngrid = lambda  r :[lint() for i in range(r)]\nlocalsys = 0\nstart_time = time.time()\n#left shift --- num*(2**k) --(k - shift)\nnCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)\ndef ceill(n,x):\n    return (n+x -1 )//x\nT =0\n\ndef solve():\n\tarr = list(map(int , S()))\n\ts , cnt , ans = 0 , 0 ,0\n\tfor i in arr:\n\t\ts , cnt = s + i , cnt + 1\n\t\tif i % 3 ==0 or cnt % 3 ==0 or s % 3 ==0:\n\t\t\ts , cnt,ans  =0 , 0 , ans + 1\n\tprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t# n = I()\n\t# a = lint()\n\t# l , r ,ans = [1]*n , [1]*n , 1\n\t# for i in range(1 , n):\n\t# \tif a[i] > a[i-1]:\n\t# \t\tl[i] = l[i-1] + 1 #from left sort of prefix \n\t# \tans = max(ans , l[i]) \n\n\t# for i in range(n-2 ,-1 ,-1 ):\n\t# \tif a[i+1] > a[i]:\n\t# \t\tr[i] =r[i+1] +1\n\t# \tans = max(ans , r[i])\n\n\t# for i in range(1 , n - 1):\n\t# \tif a[i-1] < a[i+1]: #skipping one element\n\t# \t\tans = max(ans , l[i-1] + r[i+1])\n\t# print(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef run():\n    if (path.exists('input.txt')):\n        sys.stdin=open('input.txt','r')\n        sys.stdout=open('output.txt','w')\n\n\nrun()\nT = I() if T else 1\nfor _ in range(T):\n    solve()\n\n\nif localsys:\n    print(\"\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")\n\n\n", "complexity": "linear", "problem": "1005_D", "from": "CODEFORCES", "tags": "dp,greedy,number theory"}
{"src": "n = int(input())\np = [(-(10**6), 0)] + sorted([tuple(map(int, input().split())) for i in range(n)])\ndp = [0] * (n + 1)\nfor i in range(1, n + 1):\n    l, r = 0, i\n    while r - l > 1:\n        mid = (l + r) >> 1\n        if p[i][0] - p[i][1] <= p[mid][0]: r = mid\n        else: l = mid\n    dp[i] = i - r + dp[r - 1]\nans = min(dp[i] + (n - i) for i in range(1, n + 1))\nprint(ans)", "complexity": "linear", "problem": "0608_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    s = list(input().rstrip())\n    t = input().rstrip()\n    ok = False\n    for i in range(len(t)):\n        t1 = list(t[:i]) + [\"#\"]\n        t2 = list(t[i:]) + [\"#\"] \n        # dp[seen i-th index][match j in front] = match in back\n        dp = [[-1] * (len(t) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = 0\n        for j, ch in enumerate(s):\n            for k in range(len(t1)):\n                if dp[j][k] == -1:\n                    continue\n                dp[j+1][k] = max(dp[j+1][k], dp[j][k])\n                if ch == t1[k]:\n                    dp[j+1][k+1] = max(dp[j+1][k+1], dp[j][k])\n                if ch == t2[dp[j][k]]:\n                    dp[j+1][k] = max(dp[j+1][k], dp[j][k] + 1)\n        for k in range(len(t) + 1):\n            if dp[len(s)][k] + k >= len(t):\n                ok = True\n\n    if ok:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "import io\nimport os\n\nfrom functools import lru_cache\nfrom collections import defaultdict\n\n\ndef solve(N, A):\n    # Compute all intervals that merge down to a single value\n    # val -> leftEndpoint -> rightEndpoints\n    valToLeftRight = defaultdict(lambda: defaultdict(set))\n    # val -> rightEndpoint -> leftEndpoints\n    valToRightLeft = defaultdict(lambda: defaultdict(set))\n    # Initialize with intervals of length 1 (left and right endpoints inclusive)\n    for i, x in enumerate(A):\n        valToLeftRight[x][i].add(i)\n        valToRightLeft[x][i].add(i)\n\n    # Go from smallest to largest values\n    # Note: max val formable is with A = [1000] * 500 which should be around 1000 + lg(500)\n    maxVal = 1000 + 100\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val - 1].items():\n            for r in rights:\n                # Merge (l, r) with (l2, r2) with value (val - 1)\n                l2 = r + 1\n                if l2 in valToLeftRight[val - 1]:\n                    for r2 in valToLeftRight[val - 1][l2]:\n                        assert l <= r\n                        assert r + 1 == l2\n                        assert l2 <= r2\n                        valToLeftRight[val][l].add(r2)\n                        valToRightLeft[val][r2].add(l)\n                # Merge (l2, r2) with (l, r) with value (val - 1)\n                r2 = l - 1\n                if r2 in valToRightLeft[val - 1]:\n                    for l2 in valToRightLeft[val - 1][r2]:\n                        assert l2 <= r2\n                        assert r2 == l - 1\n                        assert l <= r\n                        valToLeftRight[val][l2].add(r)\n                        valToRightLeft[val][r].add(l2)\n\n    # Merge all left to right endpoints regardless of value formed\n    intervals = defaultdict(list)\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val].items():\n            for r in rights:\n                # print(A[l : r + 1], l, r, val)\n                intervals[l].append(r)\n\n    # DP[i] returns most area you can cover in A[i:]\n    dp = {}\n    dp[N] = 0\n    for left in range(N - 1, -1, -1):\n        best = float(\"inf\")\n        for right in intervals[left]:\n            # left to right inclusive is combined down to one character\n            best = min(best, 1 + dp[right + 1])\n        dp[left] = best\n\n    # print(intervals)\n    # print(A)\n    # print([g[i] for i in range(N + 1)])\n    return dp[0]\n\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    ans = solve(N, A)\n    print(ans)\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys,math\na,b=map(int,input().split())\nl=list(map(int,input().split()))\nt=[[-1,0] for i in range(100001)]\nfor i in range(a):\n    if t[l[i]][0]!=-1:print(0);sys.exit()\n    t[l[i]][0]=3\ns=math.inf\nfor i in range(a):\n    if t[l[i]&b][0]!=-1:\n        #print(l[i],t[l[i]&b])\n        if l[i]&b!=l[i] and t[l[i]&b][0]!=1:\n            t[l[i]&b]=[1,min(2,t[l[i]&b][1]+1)]\n        #print(l[i],t[l[i]&b])\n    else:t[l[i]&b]=[2,1]\n#for i in range(11):print(t[i])\nfor i in range(a):\n    if t[l[i]&b][1]!=0 and t[l[i]&b][0]==1:s=min(s,t[l[i]&b][1])\nif s==math.inf:\n    print(-1)\nelse:\n    print(s)\n", "complexity": "linear", "problem": "1013_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "from sys import stdin\nfrom collections import defaultdict\nimport heapq\n\nn = int(stdin.readline())\na = [[] for _ in range(n)]\nfor _ in range(n-1):\n    e = stdin.readline().split(' ')\n    u, v = int(e[0]), int(e[1])\n    a[u-1].append(v-1)\n    a[v-1].append(u-1)\n\n\nleaves = [i for i in range(n) if len(a[i]) == 1]\n\n\ndef dfs_from(root):\n    depth = defaultdict(int)\n    child = {}\n    parent = defaultdict(lambda: -1)\n    stack = [root]\n    visited = [False for _ in range(n)]\n    while len(stack) > 0:\n        crt = stack[-1]\n        if visited[crt]:\n            stack.pop(-1)\n            if len(a[crt]) > 1:  # not a leaf\n                child[crt], depth[crt] = max([(c, depth[c]+1) for c in a[crt]\n                                              if c != parent[crt]],\n                                             key=lambda x: x[1])\n            else:\n                child[crt] = -1\n                depth[crt] = 0\n            continue\n\n        visited[crt] = True\n        for next in a[crt]:\n            if next != parent[crt]:\n                stack.append(next)\n                parent[next] = crt\n\n    return depth, child\n\n\nfirst_choice = leaves[0]\nd1, child1 = dfs_from(first_choice)\n\nroot = max([(a[leaf][0], d1[a[leaf][0]]) for leaf in leaves],\n           key=lambda leaf_depth: leaf_depth[1])[0]\nwhile child1[root] != -1:\n    root = child1[root]\ndepth, child = dfs_from(root)\n\nsolution = [1]\npq = []\nfor k, v in depth.items():\n    heapq.heappush(pq, (-v, k))\n\nseen = [False for _ in range(n)]\nseen[root] = True\n\nwhile len(pq) > 0:\n    _, best = heapq.heappop(pq)\n    if seen[best]:\n        continue\n    path = []\n    c = best\n    s = 0\n    while c != -1:\n        seen[c] = True\n        c = child[c]\n        s = s+1\n    s = s + solution[-1]\n    solution.append(s)\n\n\nfor _ in range(n - min(len(solution), n)):\n    solution.append(n)\n\nprint(' '.join([str(s) for s in solution]))\n", "complexity": "nlogn", "problem": "0958_B2", "from": "CODEFORCES", "tags": "data structures,dfs and similar,graphs,greedy,trees"}
{"src": "n, m = map(int, input().split())\narr = list(map(int, input().split()))\nd = {}\ni = 1\nfor x in arr:\n\tif len(d) == m:\n\t\tbreak\n\td[x] = i\n\ti += 1\nif len(d) == m:\n\tprint(min(d.values()), max(d.values()))\nelse:\n\tprint(-1,-1)\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n########################################################################\n\nn=ri()\na=ris()\nfreq=Counter(a)\nans=0\nfor x in freq:\n  for i in range(32):\n    c=(1<<i)-x\n    if c not in freq:\n      continue\n    if c==x and freq[x]==1:\n      continue\n    break\n  else:\n    ans+=freq[x]\n\nprint(ans)\n", "complexity": "nlogn", "problem": "1005_C", "from": "CODEFORCES", "tags": "brute force,greedy,implementation"}
{"src": "import sys\n# from math import log2,floor,ceil,sqrt\n# import bisect\n# from collections import deque\n\n# from types import GeneratorType\n# def bootstrap(func, stack=[]):\n#     def wrapped_function(*args, **kwargs):\n#         if stack:\n#             return func(*args, **kwargs)\n#         else:\n#             call = func(*args, **kwargs)\n#             while True:\n#                 if type(call) is GeneratorType:\n#                     stack.append(call)\n#                     call = next(call)\n#                 else:\n#                     stack.pop()\n#                     if not stack:\n#                         break\n#                     call = stack[-1].send(call)\n#             return call\n#     return wrapped_function\n\nRi = lambda : [int(x) for x in sys.stdin.readline().split()]\nri = lambda : sys.stdin.readline().strip()\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10**8\nN = 5*10**6\n\ndef solve(n):\n    arr = []\n    while n> 0:\n        arr.append(n%2)\n        n=n//2\n    return arr\n\nl,r = Ri()\narrl = solve(l)\narrr = solve(r)\nif len(arrr) > len(arrl):\n    ans = (1<<len(arrr))-1\n    print(ans)\nelse:\n    ind = -1\n    for i in range(len(arrr)-1,-1,-1):\n        if arrr[i] != arrl[i]:\n            ind = i\n            break\n    if ind == -1:\n        print(0)\n    else:\n        ans = (1 << (ind+1)) -1\n        print(ans)\n\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import sys\n\ndef ask(x):\n    print('? %d'%x)\n    sys.stdout.flush()\n    x=int(input())\n    return x\n\nn=int(input())\nt=n//2\nif t&1:\n    print('! -1')\n    sys.stdout.flush()\n    sys.exit()\nl=1\nr=n\nwhile l<r:\n    mid=(l+r)>>1\n    if ask(mid)>=ask((mid+t-1)%n+1):\n        r=mid\n    else:\n        l=mid+1\nprint('! %d'%l)\nsys.stdout.flush()\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "n,m = map(int,input().split())\narr1 = [int(i) for i in input().split()]\narr2 = [int(i) for i in input().split()]\n# arr3 = []\nfor first in arr1:\n    for second in arr2:\n        if first == second:\n            # arr3.append(first)\n            print(first,end=\" \")", "complexity": "quadratic", "problem": "0994_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "f=input\nD,E={},[eval(f())for _ in range(int(f()))]\nfor e in E:D[e]=D.get(e,0)+1\nfor e in E:print(D[e])", "complexity": "linear", "problem": "0958_D1", "from": "CODEFORCES", "tags": "expression parsing,math"}
{"src": "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(0)\n    else:\n        max1 = max2 = -1\n        for q in a:\n            if q > max1:\n                max1, max2 = q, max1\n            elif q > max2:\n                max2 = q\n        print(max(0, min(max2-1, len(a)-2)))\n", "complexity": "linear", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\n#sys.setrecursionlimit(300000)\n#threading.stack_size(10**8)\n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------------------------------------------------------------\n#mod = 9223372036854775807  \nclass SegmentTree:\n    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n \n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n \n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n \n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n \n \nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n \n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n#-------------------------------------------------------------------------\nprime = [True for i in range(200001)] \npp=[0]*200001\ndef SieveOfEratosthenes(n=200000): \n      \n    # Create a boolean array \"prime[0..n]\" and initialize \n    #  all entries it as true. A value in prime[i] will \n    # finally be false if i is Not a prime, else true. \n    \n    p = 2\n    while (p * p <= n): \n          \n        # If prime[p] is not changed, then it is a prime \n        if (prime[p] == True): \n              \n            # Update all multiples of p \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n#---------------------------------running code------------------------------------------\ndef mergeSort(arr, n):\n    # A temp_arr is created to store\n    # sorted array in merge function\n    temp_arr = [0]*n\n    return _mergeSort(arr, temp_arr, 0, n-1)\n \n# This Function will use MergeSort to count inversions\n \ndef _mergeSort(arr, temp_arr, left, right):\n \n    # A variable inv_count is used to store\n    # inversion counts in each recursive call\n \n    inv_count = 0\n \n    # We will make a recursive call if and only if\n    # we have more than one elements\n \n    if left < right:\n \n        # mid is calculated to divide the array into two subarrays\n        # Floor division is must in case of python\n \n        mid = (left + right)//2\n \n        # It will calculate inversion \n        # counts in the left subarray\n \n        inv_count += _mergeSort(arr, temp_arr, \n                                    left, mid)\n \n        # It will calculate inversion \n        # counts in right subarray\n \n        inv_count += _mergeSort(arr, temp_arr, \n                                  mid + 1, right)\n \n        # It will merge two subarrays in \n        # a sorted subarray\n \n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\n \n# This function will merge two subarrays \n# in a single sorted subarray\ndef merge(arr, temp_arr, left, mid, right):\n    i = left     # Starting index of left subarray\n    j = mid + 1 # Starting index of right subarray\n    k = left     # Starting index of to be sorted subarray\n    inv_count = 0\n \n    # Conditions are checked to make sure that \n    # i and j don't exceed their\n    # subarray limits.\n \n    while i <= mid and j <= right:\n \n        # There will be no inversion if arr[i] <= arr[j]\n \n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            # Inversion will occur.\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            k += 1\n            j += 1\n \n    # Copy the remaining elements of left \n    # subarray into temporary array\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n \n    # Copy the remaining elements of right \n    # subarray into temporary array\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n \n    # Copy the sorted subarray into Original array\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n         \n    return inv_count\n\nn=int(input())\na=list(map(int,input().split()))\nr=mergeSort(a, n)\nif r%2==(3*n)%2:\n    print(\"Petr\")\nelse:\n    print(\"Um_nik\")", "complexity": "nlogn", "problem": "0986_B", "from": "CODEFORCES", "tags": "combinatorics,math"}
{"src": "from sys import stdin\ninput = stdin.readline\n\nn = int(input())\na = []\nfor i in range(4):\n    a.append([[int(x) for x in list(input().rstrip())] for _ in range(n)])\n    if i < 3: input()\nb = []\nfor i in range(4):\n    b.append([])\n    for j in range(2):\n        c = 0\n        for y in range(n):\n            for x in range(n):\n                if j == 1:   \n                    z = (x + y) % 2\n                else:\n                    z = 1 - (x + y) % 2\n                c += a[i][y][x] != z\n        b[-1].append(c)\nans = float(\"inf\")\nfor i in (3, 5, 6, 9, 10, 12):\n    ans = min(ans, b[0][i & 1] + b[1][i >> 1 & 1] + b[2][i >> 2 & 1] + b[3][i >> 3 & 1])\nprint(ans)", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/15/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\ndef check(val, A, M):\n    s = set()\n    for row in A:\n        v = 0\n        for u in row:\n            v <<= 1\n            if u >= val:\n                v |= 1\n        s.add(v)\n    \n    x = 1 << M\n    for u in s:\n        for v in range(x):\n            if v in s and u | v == x - 1:\n                return True\n            \n    return False\n\n\ndef getAnswer(val, A, M):\n    vi = {}\n    for i, row in enumerate(A):\n        v = 0\n        for u in row:\n            v <<= 1\n            if u >= val:\n                v |= 1\n        vi[v] = i\n        \n    x = 1 << M\n    for u in vi:\n        for v in range(x):\n            if v in vi and u | v == x - 1:\n                return vi[u], vi[v]\n    \n    return 0, 0\n\n\ndef solve(N, M, A):\n    lo, hi = 0, max([max(row) for row in A])\n    \n    while lo <= hi:\n        m = (lo + hi) // 2\n        if check(m, A, M):\n            lo = m + 1\n        else:\n            hi = m - 1\n    \n    a, b = getAnswer(hi, A, M)\n    print('{} {}'.format(a + 1, b + 1))\n\n\n\nN, M = map(int, input().split())\nA = []\nfor i in range(N):\n    row = [int(x) for x in input().split()]\n    A.append(row)\n\nsolve(N, M, A)\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "n = int(input())\na = [int(_) & 1 for _ in input().split()]\nv = [a[0]]\nfor i in range(1, n):\n    if v and v[-1] == a[i]:\n        v.pop()\n    else:\n        v.append(a[i])\nprint(\"NO\" if len(v) > 1 else \"YES\")\n", "complexity": "linear", "problem": "1092_D1", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "a, b = map(int, input().split())\n\nbitxor = a^b\n\nres = 1\nwhile bitxor:\n    bitxor >>= 1\n    res <<= 1\n\nprint(res-1)\n\n \t\t   \t\t  \t\t  \t\t   \t \t \t\t\t \t\t\t", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n, s = map(int, input().split())\n\ndef binsearch(n, s):\n    left = 0\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        digits = sum([int(i) for i in list(str(mid))])\n        if mid - digits >= s:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return right\n#print(binsearch(n, s))\nprint(max(0, n - binsearch(n, s)))\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "n,p,l,r = map(int,input().split())\nif l == 1 and r == n:\n    print(0)\nelif l==1:\n    print(abs(p-r)+1)\nelif r == n:\n    print(abs(p - l) + 1)\nelse:\n    print(min(abs(p-r),abs(p - l))+r-l+2)", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport collections\nimport itertools\nimport bisect\nimport heapq\n# sys.setrecursionlimit(100000)\n# ^^^TAKE CARE FOR MEMORY LIMIT^^^\nimport random\n\n\ndef main():\n    pass\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\n\ndef decimal(s):\n    return (int(s, 2))\n\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n //= 2\n        p += 1\n    return (p)\n\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\ndef primeFactorsCount(n):\n    cnt=0\n    while n % 2 == 0:\n        cnt+=1\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            cnt+=1\n            n = n // i\n    if n > 2:\n        cnt+=1\n    return (cnt)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\n\ndef countcon(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if (s[i] == ch):\n            c += 1\n        else:\n            break\n    return (c)\n\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\n\n\ndef isSubSequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\n\n\ndef maxfac(n):\n    root = int(n ** 0.5)\n    for i in range(2, root + 1):\n        if (n % i == 0):\n            return (n // i)\n    return (n)\n\n\ndef p2(n):\n    c = 0\n    while (n % 2 == 0):\n        n //= 2\n        c += 1\n    return c\n\n\ndef seive(n):\n    primes = [True] * (n + 1)\n    primes[1] = primes[0] = False\n    i = 2\n    while (i * i <= n):\n        if (primes[i] == True):\n            for j in range(i * i, n + 1, i):\n                primes[j] = False\n        i += 1\n    pr = []\n    for i in range(0, n + 1):\n        if (primes[i]):\n            pr.append(i)\n    return pr\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\n\ndef denofactinverse(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (pow(fac, m - 2, m))\n\n\ndef numofact(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (fac)\n\ndef sod(n):\n    s = 0\n    while (n > 0):\n        s += n % 10\n        n //= 10\n    return s\ndef chk1(i):\n    '''\n    .\n    ..\n    '''\n    if(i!=n-1 and l1[i]==l2[i]==l2[i+1]==\"0\"):\n        l1[i] = l2[i] = l2[i + 1] = \"X\"\n        return True\n    return False\ndef chk2(i):\n    '''\n    ..\n    .\n    '''\n    if(i!=n-1 and l1[i]==l1[i+1]==l2[i]==\"0\"):\n        l1[i] = l1[i + 1] = l2[i] = \"X\"\n        return True\n    return False\ndef chk3(i):\n    if (i != n - 1 and l1[i] == l1[i + 1] == l2[i+1] == \"0\"):\n        l1[i] = l1[i + 1] = l2[i+1] = \"X\"\n        return True\n    return False\ndef chk4(i):\n    if (i != n - 1 and l2[i+1] == l1[i + 1] == l2[i] == \"0\"):\n        l1[i] = l1[i + 1] = l2[i] = \"X\"\n        return True\n    return False\n\n\ndef check1(i):\n    if (i <= n - 3 and l1[i:i + 3] == l2[i:i + 3] == [\"0\",\"0\",\"0\"]):\n        for j in range(i,i+3):\n            l1[j]=l2[j]=\"X\"\n        return True\n\n\ndef check2(i):\n    if(chk1(i) or chk2(i) or chk3(i) or chk4(i)):\n        return True\n    return False\n\n\nl1=list(input())\nl2=list(input())\n#print(l1,l2)\nn=len(l1)\ni=0\nans=0\nwhile(i<n):\n    if(check1(i)):\n        #print(i)\n        ans+=2\n        i+=3\n    else:\n        if(check2(i)):\n            ans+=1\n            i+=2\n        else:\n            i+=1\nprint(ans)\n#print(l1)\n#print(l2)", "complexity": "constant", "problem": "0991_D", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "from sys import stdin\ninput = stdin.buffer.readline\n    \nn=int(input())\narr=[int(x) for x in input().split()]\n\narr.sort()\ns=set(arr)\nflag=False\nfor ele in arr:\n    for i in range(31):\n        if ((ele-2**i) in s) and ((ele+2**i) in s):\n            ans=[ele,ele-2**i,ele+2**i]\n            flag=True\n            break\n    if flag:\n        break\nif flag:\n    print(3) \n    print(*ans)    \n    exit()\nfor ele in arr:\n    for i in range(31):\n        if (ele+2**i) in s:\n            ans=[ele,ele+2**i]\n            flag=True\n            break\n    if flag:\n        break\nif flag:\n    print(2)\n    print(*ans)\nelse:\n    print(1)\n    print(arr[0])", "complexity": "nlogn", "problem": "0988_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "k=int(input(\"\"))\nt=0\nif k==0:\n    print(\"Invalid input\")\n    exit()\nd=0\ne=0\nn=5\nwhile(1):\n    u=9*n*(10**n)+1-(10**n)-9*k\n    if u>0:\n        d+=1\n        if e>0:\n            u=i\n            break\n        n=n-1\n    elif u<0:\n        i=u\n        e+=1\n        if d>0:\n            n=n+1\n            break\n        n=n+1\n    else:\n        print(9)\n        exit()\nimport math\nu=abs(u)\nu=u//9\nm=u//n\np=u%(n)\nif p==0:\n    q=10**(n-1)+m-1\n    o=q%10\nelse:\n    q = 10**(n-1) + m\n    o=((q//(10**(n-p)))%10)\nprint(o)", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "#!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    n, MOD = map(int, input().split())\n    factorial = [1]\n    for i in range(2, n + 1):\n        factorial.append(factorial[-1] * i % MOD)\n    for i in range(len(factorial)):\n        factorial[i] = pow(factorial[i], MOD - 2, MOD)\n    DP = []\n    for i in range(n):\n        DP.append([0] * n)\n    for i in range(n):\n        DP[i][0] = pow(2, i, MOD) * factorial[i]\n        for j in range(1, i // 2 + 1):\n            for k in range(0, i - 1):\n                DP[i][j] += DP[k][j - 1] * pow(2, i - k - 2, MOD) * factorial[i - k - 2]\n            DP[i][j] %= MOD\n    ans = 0\n    for i in range(len(factorial)):\n        factorial[i] = pow(factorial[i], MOD - 2, MOD)\n    for i in range(n):\n        ans += DP[n - 1][i] * factorial[n - i - 1]\n    print(ans % MOD)\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "n, k = map(int,input().split())\n\nstart = 0\ncnt = n\ncur = 1\n\nwhile start <= k:\n    start += cur\n    cnt -= 1\n    cur += 1\n    \nans = 0\n\nif start != k:\n    while cnt > 0:\n        if start == k:\n            start += cur\n            cur += 1\n            cnt -= 1\n        ans += (start - k)\n        cnt -= (start - k)\n        start = k\n\nprint(ans)\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "from sys import stdin\nfrom collections import deque\n\nn, k = map(int, stdin.readline().split())\n\ngraph = [set() for _ in range(n)]\n\nfor _ in range(n-1):\n    a,b = map(int,stdin.readline().split())\n\n    graph[a - 1].add(b - 1)\n    graph[b - 1].add(a - 1)\n\nleafs = [i for i,v in enumerate(graph) if len(v) == 1]\nnew_leafs = []\nvalid = True\ncenters = dict()\ncount = 0\n\nwhile len(leafs) > 1 and valid:\n    for leaf in leafs:\n        center = graph[leaf].pop()\n\n        try:\n            centers[center] += 1\n        except KeyError:\n            centers[center] = 1\n\n        graph[center].remove(leaf)\n\n        if len(graph[center]) == 0:\n            break\n\n        elif len(graph[center]) == 1:\n            new_leafs.append(center)\n\n    if any(mult < 3 for mult in centers.values()):\n        valid = False\n        break\n    \n    count = count + 1\n    leafs = new_leafs\n    new_leafs = []\n    centers = {}\n\nif valid and count == k:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "nlogn", "problem": "1067_B", "from": "CODEFORCES", "tags": "dfs and similar,graphs,shortest paths"}
{"src": "n = input()\nseat_rows = [int(x) for x in input().strip().split()]\naliens = input().strip()\n\neldian = \"0\"\nmarleyan = \"1\"\n\nempty = sorted(enumerate(seat_rows), key=lambda x: x[1], reverse=True)\nnon_empty = []\n\nresult = []\nfor alien in aliens:\n    if alien == eldian:\n        row = empty.pop()\n        non_empty.append(row)\n    else:\n        row = non_empty.pop()\n\n    result.append(row[0] + 1)\n\nprint(' '.join(map(str, result)))", "complexity": "nlogn", "problem": "0982_B", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "x, k = (int(x) for x in input().split())\nmod = 10 ** 9 + 7\nif x == 0:\n    print(0)\n    exit()\nif k == 0:\n    print(2 * x % mod)\n    exit()\n\n# twopow = pow(2, k, mod)\nans = pow(2, k + 1, mod)\nans *= x\nans %= mod\nans -= pow(2, k, mod)\nans += 1\nans %= mod\nans += mod\nans %= mod\n\nprint(ans)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "#Mamma don't raises quitter.................................................\nfrom collections import deque as de\nimport math\nfrom sys import stdin, stdout\nimport re\nfrom collections import Counter as cnt\nfrom functools import  reduce\n\nfrom itertools import groupby as gb\n#from fractions import Fraction as fr\nfrom bisect import bisect_left as bl, bisect_right as br\n\ndef factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n    \nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack() \n\n#decimal to binary   \ndef decimalToBinary(n): \n    return bin(n).replace(\"0b\", \"\")\n#binary to decimal\ndef binarytodecimal(n):\n    return int(n,2)\n\ndef isPrime(n) : \n\tif (n <= 1) : \n\t\treturn False\n\tif (n <= 3) : \n\t\treturn True\n\n\t\n\tif (n % 2 == 0 or n % 3 == 0) : \n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) : \n\t\tif (n % i == 0 or n % (i + 2) == 0) : \n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number / 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number / i\n\n    if number > 2:\n        prime_factors.append(int(number))\n    return prime_factors\n\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x): \n    return (math.log10(x) / \n            math.log10(2)); \n\n \n# Function to get product of digits\ndef getProduct(n):\n \n    product = 1\n \n    while (n != 0):\n        product = product * (n % 10)\n        n = n // 10\n \n    return product\n\n\n#function to find LCM of two numbers\ndef lcm(x,y):\n   lcm = (x*y)//math.gcd(x,y)\n   return lcm\n\ndef isPowerOfTwo(n): \n    return (math.ceil(Log2(n)) == math.floor(Log2(n))); \n#to check whether the given sorted sequnce is forming an AP or not....\ndef checkisap(list):\n    d=list[1]-list[0]\n    for i in range(2,len(list)):\n        temp=list[i]-list[i-1]\n        if temp !=d:\n            return False\n    return True\n        \n    \n\n#ceil  function gives wrong answer after 10^17 so i have to create my own :)\n# because i don't want to doubt on my solution of 900-1000 problem set.\ndef ceildiv(x,y): \n    return (x+y-1)//y \n  \ndef di():return map(int, input().split())\ndef ii():return int(input())\ndef li():return list(map(int, input().split()))\ndef si():return list(map(int, input()))\ndef indict():\n    dic = {}\n    for index, value in enumerate(input().split()):\n        dic[int(index)+1] = int(value)\n    return dic\ndef frqdict():\n    # by default it is for integer input. :)\n    dic={}\n    for index, value in enumerate(input().split()):\n        if int(value) not in dic:\n            dic[int(value)] =1\n        else:\n            dic[int(value)] +=1\n    return dic\n\n#inp = open(\"input.txt\",\"r\")\n#out = open(\"output.txt\",\"w\")\n#Here we go......................\n#practice like your never won\n#perform like you never lost\nn,pos, l, r=di()\nif l==1 and r==n:\n    print(0)\nelse:\n    if pos < l:\n        ans=l-pos+1\n        if r <n:\n            ans+=(r-l)\n            ans+=1\n        print(ans)\n    elif l<=pos<=r:\n        if l >1 and r<n:\n            ans=(r-l)\n            ans+=min(pos-l,r-pos)\n            ans+=2\n        elif l>1 and r==n:\n            ans=pos-l\n            ans+=1\n        else:\n            ans=r-pos\n            ans+=1\n        print(ans)\n            \n            \n    else:\n        ans=pos-r+1\n        if l>1:\n            ans+=(r-l)\n            ans+=1\n        print(ans)\n\n\n        \n        \n        \n\n        \n\n    \n            \n        \n        \n    \n        \n        \n        \n\n\n                \n                \n\n    \n\n\n        \n        \n    \n    \n    \n        \n    \n        \n    \n\n\n\n\n    \n\n                \n    \n        \n\n\n        \n    \n\n            \n        \n    \n\n                \n                \n                \n        \n        \n        \n\n            \n\n        \n\n\n\n\n\n                    \n                \n            \n        \n\n            \n    \n        \n    \n    \n\n    \n        \n    \n \n\n    \n        \n\n\n    \n        \n\n", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from math import gcd\n# region fastio\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\ndef func(l,r):\n    if l==1:\n        l+=1\n    if r-l<2:\n        return -1\n\n    if l&1:\n        if r-l>2:\n            l+=1\n            return '{} {} {}'.format(l,l+1,l+2)\n        else:\n            if gcd(l,l+2)!=1:\n                return '{} {} {}'.format(l,l+1,l+2)\n            return -1\n    return '{} {} {}'.format(l, l + 1, l + 2)\n\n\n\ndef main():\n    l,r=map(int,input().split())\n    print(func(l,r))\n    return\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import sys, math\nimport io, os\n# data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\n# from heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n# from itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\n# from fractions import Fraction\n# sys.setrecursionlimit(100000)\nINF = float('inf')\nmod = int(1e9) + 7\n\n\ndef cal(l,r):\n    if l==r:\n        dp1[l][r]=1\n        dp2[l][r]=a[l]\n    if dp1[l][r]:\n        return dp1[l][r]\n    for i in range(l,r):\n        if cal(l,i)==1 and cal(i+1,r)==1 and dp2[l][i]==dp2[i+1][r]:\n            dp1[l][r]=1\n            dp2[l][r]=dp2[l][i]+1\n    if not dp2[l][r]:\n        dp1[l][r]=2\n    return dp1[l][r]\n\ndef cal2(l,r):\n    if dp1[l][r]==1:\n        dp3[l][r]=1\n        return 1\n    elif dp3[l][r]:\n        return dp3[l][r]\n    ans=INF\n    for i in range(l,r):\n        ans=min(cal2(l,i)+cal2(i+1,r),ans)\n    dp3[l][r]=ans\n    return ans\n\n\nn=int(data())\na=mdata()\nans=[n]\ndp1=[[0]*n for i in range(n)]\ndp2=[[0]*n for i in range(n)]\ndp3=[[0]*n for i in range(n)]\ncal(0,n-1)\ncal2(0,n-1)\nout(dp3[0][n-1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=998244353\nEPS=1e-6\ndef Ceil(a,b): return a//b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n\n\n\n\nn = Int()\na = array()\nC = Counter(a)\na = set(a)\n\nans = 0\n\nfor x in a:\n    ok = True\n\n    for i in range(65):\n        \n        need = 2**i - x\n        if(need == x and C[need] > 1): ok = False \n        if(need != x and C[need] > 0): ok = False\n    \n    # print(ok,x)\n    ans += C[x]*ok\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "nlogn", "problem": "1005_C", "from": "CODEFORCES", "tags": "brute force,greedy,implementation"}
{"src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\ndef main():\n    # mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n   \n\n    tc=1\n    for _ in range(tc):\n        n=ri()\n        ans=[]\n        i=1\n        k=1\n        t=0\n        while True:\n            k=i*i\n            if k<=n:\n                t=i\n            else:\n                break\n            i+=1\n        a=[]\n        z=[]\n        for i in range(n):\n            z+=[i+1]\n            if len(z)==t:\n                a=z+a\n                z=[]\n        a=z+a\n        wia(a)\n        \n        \n\n            \n                    \n                \n        \n        \n            \n                \n        \n\n            \n        \n\n               \n            \n        \n              \n                \n        \n        \n            \n        \n        \n            \n            \n        \n        \n                \n                \n                \n                \n            \n        \n        \n            \n           \n        \n            \n                    \n\n                                 \n                \n                \n        \n\n                \n        \n        \n        \n            \n        \n        \n                \n            \n        \n        \n                    \n        \n        \n        \n            \n                    \n            \n\n                \n            \n            \n                \n            \n                \n            \n            \n            \n            \n                \n            \n        \n        \n        \n        \n        \n        \n        \n                    \n        \n        \n        \n                \n                \n        \n            \n            \n            \n        \n\n                    \n        \n                \n        \n        \n                        \n        \n                            \n\n        \n\n                \n            \n        \n\n                \n            \n                    \n                \n                \n        \n        \n         \n        \n\n                        \n                            \n                \n        \n                            \n                    \n\n                \n            \n        \n                \n            \n                \n        \n        \n        \n                             \n        \n            \n        \n        \n            \n                        \n                        \n                    \n            \n        \n        \n        \n        \n        \n                        \n       \n\n        \n                           \n        \n        \n        \n            \n        \n        \n        \n                      \n\n      \n                            \n            \n        \n        \n            \n            \n            \n            \n            \n        \n        \n        \n            \n        \n        \n        \n            \n        \n        \n        \n        \n            \n            \n        \n        \n        \n        \n        \n        \n        \n                \n                \n                    \n        \n        \n            \n            \n        \n                \n            \n            \n        \n        \n        \n        \n                \n        \n            \n        \n                \n        \n        \n            \n        \n       \n            \n\n                \n        \n        \n        \n   \n            \n        \n        \n        \n        \n            \n        \n                \n        \n        \n        \n            \n            \n        \n        \n            \n        \n        \n\n        \n        \n            \n        \n        \n            \n        \n                        \n\n        \n        \n            \n     \n        \n        \n            \n        \n        \n                \n            \n        \n        \n        \n                \n            \n        \n\n            \n             \n        \n            \n        \n        \n        \n                \n        \n            \n        \n        \n        \n        \n                \n        \n        \n            \n        \n        \n        \n        \n                \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    ", "complexity": "linear", "problem": "1017_C", "from": "CODEFORCES", "tags": "constructive algorithms,greedy"}
{"src": "import sys\n# Get out of main functoin\ndef main():\n    pass\n# decimal to binary\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n# binary to decimal\ndef decimal(s):\n    return (int(s, 2))\n# power of a number base 2\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return (p)\n# if  number is prime in \u221an time\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n# list to string ,no spaces\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n# String to list\ndef stl(s):\n    # for each character in string to list with no spaces -->\n    l = list(s)\n    # for space in string  -->\n    # l=list(s.split(\" \"))\n    return l\n# Returns list of numbers with a particular sum\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n# Sieve for prime numbers in a range\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n            # print(p)\n    return (cnt)\n# for positive integerse only\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n# 1000000007\nmod = int(1e9) + 7\ndef ssinp(): return sys.stdin.readline().strip()\n# s=input()\ndef iinp(): return int(input())\n# n=int(input())\ndef nninp(): return map(int, sys.stdin.readline().strip().split())\n# n, m, a=[int(x) for x in input().split()]\ndef llinp(): return list(map(int, sys.stdin.readline().strip().split()))\n# a=list(map(int,input().split()))\ndef p(xyz): print(xyz)\ndef p2(a, b): print(a, b)\nimport math\n#import random\n#sys.setrecursionlimit(300000)\n#from fractions import Fraction\n#from collections import OrderedDict\n#from collections import deque\n########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################\n########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################\n########################                         from collections import deque                              ########################\n########################                         ASCII of A-Z= 65-90                                        ########################\n########################                         ASCII of a-z= 97-122                                       ########################\n########################                         d1.setdefault(key, []).append(value)                       ########################\n#for __ in range(iinp()):\nn,k=nninp()\nnos=math.floor(math.sqrt(2*k))\nfor i in range(nos,12309123):\n    if((i*(i+1))//2-k+i==n):\n        print((i*(i+1))//2-k)\n        exit()\n\n\n\n\n\n\n\n\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "#Tuan_Kkura\nn = int(input())\na = list(map(int, input().split()))\n\ndp = [[505]*n for _ in range(n)]\nMax = [[0]*n for _ in range(n)]\n\nfor i in range(n):  \n    dp[i][i] = 1\n    Max[i][i] = a[i]\n\nfor len in range(1, n+1):\n    for i in range(n-len+1):\n        j = i + len - 1\n        for k in range(i, j):\n            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:\n                dp[i][j] = 1\n                Max[i][j] = Max[i][k] + 1\nprint(dp[0][n-1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "from math import log\nimport random\nspaces = (\" \",\"\\n\",\"\\t\")\nstops = (\"\",\" \",\"\\n\",\"\\t\")\nextendedPoints = set()\nstartingPoints = set()\ninterestPoints = []\n\nclass TPoint:\n\tdef __init__(self,x,y):\n\t\tself.x=x\n\t\tself.y=y\n\tdef __str__(self):\n\t\treturn \"(\"+str(self.x)+\",\"+str(self.y)+\")\"\n\tdef __eq__(self, other): \n\t\treturn self.x == other.x and self.y == other.y\n\tdef __hash__(self):\n\t\treturn self.x*20000 + self.y\n\tx=0\n\ty=0\n\th=0\t# \u044d\u0432\u0440\u0438\u0441\u0442\u0438\u043a\u0430\ndef sortKey(p):\n\treturn p.h\ndef heuristic(p, otherPoints):\n\tminH = float(\"inf\")\n\tfor point in otherPoints:\n\t\tcurrentH = abs(point.x - p.x) + abs(point.y - p.y)\n\t\tif currentH < minH:\n\t\t\tminH = currentH\n\treturn minH\n\ndef addPoint(p,pointList):\n\tif not p in extendedPoints:\n\t\tp.h = heuristic(p,startingPoints)\n\t\textendedPoints.add(p)\n\t\tpointList.append(p)\n\t\t#print(p.x,p.y,p.h)\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef extend(point,n,m,poinList):\n\tok = False\n\tif point.x>1:\n\t\tok = addPoint(TPoint(point.x-1,point.y),poinList) or ok\n\t\tif point.y>1:\n\t\t\tok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok\n\t\tif point.y<m:\n\t\t\tok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok\n\tif point.x<n:\n\t\tok = addPoint(TPoint(point.x+1,point.y),poinList) or ok\n\t\tif point.y>1:\n\t\t\tok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok\n\t\tif point.y<m:\n\t\t\tok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok\n\tif point.y>1:\n\t\tok = addPoint(TPoint(point.x,point.y-1),poinList) or ok\n\tif point.y<m:\n\t\tok = addPoint(TPoint(point.x,point.y+1),poinList) or ok\n\n\treturn ok\n\ndef ReadNext(fileObject):\n\tcurrentBuffer = \"\"\n\tcurrentRead=fileObject.read(1)\n\twhile currentRead in spaces:\n\t\tcurrentRead=fileObject.read(1)\n\tcurrentBuffer = currentBuffer + currentRead\n\twhile not currentRead in stops:\n\t\tcurrentRead=fileObject.read(1)\n\t\tcurrentBuffer = currentBuffer + currentRead\n\treturn currentBuffer.strip()\n\nw, r= open('output.txt', 'w'), open('input.txt', 'r')\n\nn = int(ReadNext(r))\nm = int(ReadNext(r))\nk = int(ReadNext(r))\nmscale = 5\n\nfor i in range(k):\n\tx = int(ReadNext(r))\n\ty = int(ReadNext(r))\n\tp = TPoint(x,y)\n\tstartingPoints.add(p)\n\textendedPoints.add(p)\n\ntmpPoints = []\ntmpPoints.append(TPoint(1,1))\ntmpPoints.append(TPoint(1,m))\ntmpPoints.append(TPoint(n,1))\ntmpPoints.append(TPoint(n,m))\nif n>2 and m>2:\n\ttmpPoints.append(TPoint(int(n/2),1))\n\ttmpPoints.append(TPoint(1,int(m/2)))\n\ttmpPoints.append(TPoint(int(n/2),m))\n\ttmpPoints.append(TPoint(n,int(m/2)))\n\ttmpPoints.append(TPoint(int(n/2),int(m/2)))\n\nfor p in tmpPoints:\n\taddPoint(p,interestPoints)\n\t#extend(p,n,m,interestPoints)\nfor p in startingPoints:\n\textend(p,n,m,interestPoints)\n\ninterestPoints.sort(reverse=True, key=sortKey)\nwhile len(interestPoints) > 3*mscale:\n\tinterestPoints.pop(len(interestPoints)-1)\n\nrandom.seed()\n\nif(len(interestPoints)>0):\n\tmaxPoint = interestPoints[0]\n\tfor p in interestPoints:\n\t\tcurrentBeam = [p]\n\t\tcanExtend = True\n\t\twhile canExtend:\n\t\t\taddPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)\n\t\t\tcanExtend = False\n\t\t\tfor i in range(len(currentBeam)):\n\t\t\t\tif extend(currentBeam[i],n,m,currentBeam):\n\t\t\t\t\tcanExtend = True\n\t\t\tcurrentBeam.sort(reverse=True, key=sortKey)\n\t\t\twhile len(currentBeam) > mscale:\n\t\t\t\tcurrentBeam.pop(len(currentBeam)-1)\n\t\tif currentBeam[0].h>maxPoint.h:\n\t\t\tmaxPoint = currentBeam[0]\n\t#print(maxPoint.x,maxPoint.y)\n\t#print(str(len(extendedPoints)))\n\tw.write(str(maxPoint.x)+\" \"+str(maxPoint.y)+\"\\n\")\nelse:\n\tw.write(str(n)+\" \"+str(m)+\"\\n\")\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "xs, ys = map(int, input().split())\nthings = [[xs, ys, 0]]\nn = int(input())\nfor i in range(n):\n    things.append(list(map(int, input().split())) + [i + 1])\n\n\ndistance = [[0 for i in range(n + 1)] for j in range(n + 1)]\nfor i in range(n + 1):\n    for j in range(i, n + 1):\n        distance[i][j] = distance[j][i] = (things[i][0] - things[j][0]) ** 2 + (things[i][1] - things[j][1]) ** 2\n\nINF = float('inf')\nDP = [INF for _ in range((1 << n) + 10)]\nPath = [None for _ in range((1 << n) + 10)]\nDP[0] = 0\n\nfor cur in range(1 << n):\n    if DP[cur] == INF:\n        continue\n    for nxt1 in range(n):\n        if cur & (1 << nxt1) != 0:\n            continue\n        \n        if DP[cur | (1 << nxt1)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]:\n            DP[cur | (1 << nxt1)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]\n            Path[cur | (1 << nxt1)] = cur\n        \n        for nxt2 in range(n):\n            if (cur | (1 << nxt1)) & (1 << nxt2) != 0:\n                continue\n            if DP[cur | (1 << nxt1) | (1 << nxt2)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]:\n                DP[cur | (1 << nxt1) | (1 << nxt2)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]\n                Path[cur | (1 << nxt1) | (1 << nxt2)] = cur\n        break\n\nprint(DP[(1 << n) - 1])\n\npath = []\ncur = (1 << n) - 1\nwhile cur != 0:\n    path.append(0)\n    father = Path[cur]\n    diff = cur ^ father\n    d1 = len(bin(diff)[2:])\n    path.append(d1)\n    diff ^= (1 << (d1 - 1))\n    if diff != 0:\n        d2 = len(bin(diff)[2:])\n        path.append(d2)\n    cur = father\npath.append(0)\npath = list(reversed(path))\nprint(' '.join(map(str, path)))", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "k=int(input())\na=[]\nfor i in range(0,12):\n    s=9*pow(10,i)*(i+1)\n    if k<=s:\n        break\n    else:\n        k-=s\npos=i+1\nnum=(pow(10,pos-1)+(k//pos)-1)\nif k%pos==0:\n    print(str(num)[-1])\nelse:\n    print(str(num+(0 if pos==1 else 1))[(k%pos)-1])\n \n", "complexity": "constant", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "base=998244353;\ndef power(x, y):\n    if(y==0):\n        return 1\n    t=power(x, y//2)\n    t=(t*t)%base\n    if(y%2):\n        t=(t*x)%base\n    return t;\ndef inverse(x):\n    return power(x, base-2)\nft=[0]\nfor i in range(0, 200000):\n    ft.append(0)\ndef get(i):\n    res=0\n    while(i<=200000):\n        res+=ft[i]\n        i+=i&-i\n    return res\ndef update(i, x):\n    while(i):\n        ft[i]+=x\n        i-=i&-i\nn=int(input())\na=[0]\na+=list(map(int, input().split()))\nneg=[0]\nnon=[0]\nfor i in range(1, n+1):\n    non.append(0)\nfor i in range(1, n+1):\n    if(a[i]!=-1):\n        non[a[i]]+=1\nfor i in range(1, n+1):\n    non[i]+=non[i-1]\nfor i in range(1, n+1):\n    if(a[i]==-1):\n        neg.append(neg[i-1]+1)\n    else: \n        neg.append(neg[i-1])\nm=neg[n]\nans=0\nfor i in range(1, n+1):\n    if(a[i]!=-1):\n        ans+=get(a[i])\n        update(a[i], 1)\nfm=1\nfs=fm\nfor i in range(1, m+1):\n    fs=fm\n    fm=(fm*i)%base\nfs=(fs*inverse(fm))%base\nfor i in range(1, n+1):\n    if(a[i]!=-1):\n        less=a[i]-non[a[i]]\n        more=m-less\n        ans=(ans+neg[i]*more*fs)%base\n        ans=(ans+(m-neg[i])*less*fs)%base\nans=(ans+m*(m-1)*inverse(4))%base\nprint(ans)", "complexity": "nlogn", "problem": "1096_F", "from": "CODEFORCES", "tags": "dp,math,probabilities"}
{"src": "from math import *\n#n,k=map(int,input().split())\n#A = list(map(int,input().split()))\nn,k = map(int,input().split())\nans = [0] * n\n#^xor\nlul = 2**k - 1\nA = list(map(int,input().split()))\nans[0]  = A[0]\nfor j in range(1, n):\n    ans[j] = ans[j-1]^A[j]\n#print(ans)\nd = dict()\nfor j in range(n):\n    if ans[j] in d:\n        d[ans[j]]+=1;\n    else:\n        d[ans[j]] = 1\n#print(d)\nans =0\ndef huy(n):\n    return n*(n-1)//2\nfor j in d:\n    now = d[j]\n    #print(d[j],j)\n    xor = lul^j\n    cur = now\n\n    if xor in d :\n\n        now2 = d[xor]\n        #print(now,xor)\n        cur += now2\n\n\n\n        ans += huy(cur//2+cur%2)\n        ans+=huy(cur//2)\n        if j ==0:\n            ans+=2*(cur//2)\n    else:\n        if(j==0 or xor ==0):\n            ans+= 2*(cur//2)\n        ans += 2*huy(cur // 2 + cur % 2)\n        ans += 2*huy(cur // 2)\nprint(huy(n+1) - ans//2)", "complexity": "linear", "problem": "1054_D", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "k = int(input())\n\nif k <= 9:\n\tprint(k)\n\nelse:\n\ts = 9\n\tn = 1\n\t\n\twhile s < k:\n\t\tn += 1\n\t\tprev_s = s\n\t\ts += (10**n - 10**(n-1)) * n\n\n\tdigit_pos = k - (prev_s + 1)\n\tnumber = 10**(n-1) + digit_pos // n\n\t\n\tif digit_pos / n != digit_pos // n:\n\t\tdigit_pos = digit_pos - (digit_pos // n) * n\n\n\n\telse:\n\t\tdigit_pos = 0\n\n\tprint(str(number)[digit_pos])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import heapq\n\n\ndef read_int():\n    return int(input().strip())\n\n\ndef read_ints():\n    return list(map(int, input().strip().split(' ')))\n\n\ndef solve():\n    '''\n    8 8 8 8 8 8\n    9 9\n    9 9\n\n    81+81\n\n    72+72+72+72\n    '''\n    R, G, B = read_ints()\n    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]\n    # dp[R][G][B]\n    Rs = read_ints()\n    Gs = read_ints()\n    Bs = read_ints()\n    Rs.sort(reverse=True)\n    Gs.sort(reverse=True)\n    Bs.sort(reverse=True)\n    answer = 0\n    for r in range(R+1):\n        for g in range(G+1):\n            for b in range(B+1):\n                if r > 0 and g > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])\n                if g > 0 and b > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])\n                if r > 0 and b > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])\n                answer = max(answer, dp[r][g][b])\n    return answer\n\n\nif __name__ == '__main__':\n    print(solve())\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "def process(S):\n    n = len(S)\n    h_count = 0\n    answer = float('inf')\n    for c in S:\n        if c=='H':\n            h_count+=1\n    current = 0\n    for i in range(h_count):\n        if S[i]=='H':\n            current+=1\n    answer = min(answer, h_count-current)\n    for i in range(h_count, n+h_count):\n        if i > n-1:\n            i1 = i-n\n        else:\n            i1 = i \n        i2 = i-h_count\n        if S[i1]=='H':\n            current+=1\n        if S[i2]=='H':\n            current-=1\n        answer = min(answer, h_count-current)\n    return answer\n\nn = int(input())\nS = input()\nprint(process(S))", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "# O(n*2^n) (however quite a few states are not visited)\n# most important optimization is not transitioning from unvisited states\n#   (only ~ 1% of states are visited) (transition is O(n))\n# other optimizations are using floats, bitwise operators, and precomputing dists/ reducing ops\nxs,ys = map(float,input().split())\n\nn = int(input())\n\ndist = [[0]*(n+1) for i in range(n+1)]\ndist2 = [[0]*(n) for i in range(n)]\n\nobjects = [list(map(float,input().split())) for i in range(n)] + [[xs,ys]] # objects[n] is handbag\n\nfor i in range(n+1):\n    for j in range(n+1):\n        dist[i][j] = (objects[i][0] - objects[j][0])**2 + (objects[i][1] - objects[j][1])**2\n\nfor i in range(n):\n    for j in range(n):\n        dist2[i][j] = dist[n][i] + dist[i][j] + dist[j][n]\n\ndp = [1e6]*(1<<n)\nvis = set([0]) #alot of states are not visited after optimization\ndp[0] = 0\n\nfor i in range((1<<n)-1):\n    if i in vis:\n        # reduce O(n^2) transition to O(n) via assuming 1 of the objects taken must be the\n        # first object not yet taken in order\n        for j in range(n):\n            if i&(1<<j) == 0:\n                # get 1 new object\n                newi = i + (1 << j)\n                dp[newi] = min(dp[newi], dp[i] + 2*dist[n][j])\n                vis.add(newi)\n\n                for k in range(j+1,n):\n                    # get 2 new objects at a time\n                    if i&(1<<k) == 0:\n                        newi |= 1<<k\n                        dp[newi] = min(dp[newi], dp[i] + dist2[j][k])\n                        vis.add(newi)\n                        newi ^= 1<<k\n\n                break\n\ncurr = (1<<n) - 1\npath = [0]\nwhile curr:\n    for i in range(n):\n        if curr & (1<<i):\n            # 1 object taken\n            if dp[curr] == dp[curr - (1<<i)] + 2*dist[n][i]:\n                path.extend([i+1,0])\n                curr ^= (1<<i)\n\n            # 2 objects taken\n            for j in range(i+1,n):\n                if curr & (1<<j):\n                    if dp[curr] == dp[curr - (1<<i) - (1<<j)] + dist2[i][j]:\n                        path.extend([j+1,i+1,0])\n                        curr ^= (1<<i) + (1<<j)\n\nprint(int(dp[(1<<n)-1]))\nprint(*path[::-1])", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import sys\nimport math\nimport collections\nimport bisect\nimport string\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n=int(input())\n    s1=list(get_string())\n    s2=list(get_string())\n    count=0\n    ans=[]\n    lower=string.ascii_lowercase\n    np=0\n    for i in lower:\n        if s1.count(i)!=s2.count(i):\n            np+=1\n            break\n    if np>0:\n        print(-1)\n        continue\n    pos=dict()\n    for i in range(n):\n        if s1[i] in pos:\n            pos[s1[i]].append(i)\n        else:\n            pos[s1[i]]=[i]\n    for i in range(n):\n        if s1[i]==s2[i]:\n            continue\n        else:\n            row=pos[s2[i]]\n            no=0\n            for j in range(len(row)):\n                if row[j]>i:\n                    no=row[j]\n                    break\n            for j in range(no,i,-1):\n                ans.append(j)\n            s1.pop(no)\n            s1.insert(i,s2[i])\n            #print(s1)\n            pos = dict()\n            for j in range(n):\n                if s1[j] in pos:\n                    pos[s1[j]].append(j)\n                else:\n                    pos[s1[j]] = [j]\n    print(len(ans))\n    print(*ans)", "complexity": "quadratic", "problem": "1015_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO,IOBase\n\ndef solve(s,t):\n    if len(t) == 1:\n        if s.count(t[0]):\n            return 'YES'\n        return 'NO'\n    for i in range(1,len(t)):\n        dp = [[-1000]*(i+1) for _ in range(len(s)+1)]\n        dp[0][0] = 0\n        for j in range(len(s)):\n            dp[j+1] = dp[j][:]\n            for k in range(i+1):\n                if k != i and s[j] == t[k]:\n                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])\n                if abs(dp[j][k]+i) < len(t) and s[j] == t[dp[j][k]+i]:\n                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)\n        for l in range(len(s)+1):\n            if dp[l][-1] == len(t)-i:\n                return 'YES'\n    return 'NO'\n\ndef main():\n    for _ in range(int(input())):\n        s = input().strip()\n        t = input().strip()\n        print(solve(s,t))\n\n#Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "import math\nimport sys\nfrom collections import deque\n\n\ndef scan() -> list:\n    return list(map(int, sys.stdin.readline().strip().split()))\n\n\ndef solution() -> None:\n    # for _ in range(int(input())):\n    n, k = scan()\n    print(round(n+1.5-math.sqrt(2*(n+k)+2.75)))\n\n\nif __name__ == '__main__':\n    solution()\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "from sys import stdin\nfrom bisect import bisect_right as br\n\nfrom collections import deque\nn,m,k=map(int,stdin.readline().strip().split())\ns=deque(map(int,stdin.readline().strip().split()))\nlim=k\nans=0\nwhile len(s)!=0:\n    x=br(s,lim)\n    for i in range(x):\n        s.popleft()\n    if x!=0:\n        ans+=1\n        lim+=x\n    else:\n        if len(s)>0:\n            x=s[0]-lim\n            if x%k==0:\n                x=x//k\n            else:\n                x=(x//k)+1\n            lim+=x*k\n        \nprint(ans)\n", "complexity": "linear", "problem": "1191_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nN, M, K = map(int, input().split())\nP = []\nD_P = {}\n\nfor i in range(N):\n\tS = input()\n\tP.append(S)\n\tD_P[S] = i\n\nadj = [[] for _ in range(N)]\nindeg = [0] * N\n\nfor _ in range(M):\n\tS, mt = input().split()\n\tmt = int(mt)-1\n\n\tfp = P[mt]\n\n\tif any(fp[i] not in (S[i], '_') for i in range(K)):\n\t\tprint('NO')\n\t\traise SystemExit\n\n\tfor bs in range(1<<K):\n\t\tpat = ''.join(S[i] if bs & (1<<i) == 0 else '_' for i in range(K))\n\t\tif pat == fp: continue\n\t\tif pat in D_P:\n\t\t\tj = D_P[pat]\n\t\t\tindeg[j] += 1\n\t\t\tadj[mt].append(j)\n\nQ = [i for i in range(N) if indeg[i] == 0]\nfor i in Q:\n\tfor j in adj[i]:\n\t\tindeg[j] -= 1\n\t\tif indeg[j] == 0:\n\t\t\tQ.append(j)\n\nif len(Q) == N:\n\tprint('YES')\n\tprint(' '.join(str(v+1) for v in Q))\nelse:\n\tprint('NO')\n", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "n = int(input())\nl = list(map(int,input().split()))\ni = 0\nans = 0\nwhile i < len(l)-1:\n    if l[i] == l[i+1]:\n        i = i+1\n        continue\n\n    j = i+1\n    ind = -1\n    while j < len(l):\n        if l[j] == l[i]:\n            ind = j\n            break\n\n        j = j+1\n\n    while ind > i+1:\n        l[ind],l[ind-1] = l[ind-1],l[ind]\n        ans += 1\n        ind -= 1\n\n    i += 1\n\nprint(ans)", "complexity": "quadratic", "problem": "0995_B", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    x,k = LI()\n    if x == 0:\n        return 0\n    t = pow(2,k+1,mod) * x % mod\n    d = pow(2,k,mod) - 1\n\n    return (t + mod - d) % mod\n\n\nprint(main())\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "from sys import stdin, stdout, exit\n\nn, m, k = map(int, stdin.readline().split())\na = list(map(int, stdin.readline().split()))\n\ndef bf(a):\n    best = 0\n    best_arg = (-1, -1)\n    for i in range(n):\n        for j in range(i, n):\n            cur = sum(a[i:j+1]) - k*((j - i) // m + 1)\n            if cur > best:\n                best = max(best, cur)\n                best_arg = (i,j)\n    return best, best_arg\n\ndef max_sum(a):\n    if len(a) == 0:\n        return 0\n    elif len(a) == 1:\n        return max(0, a[0] - k)\n    mid = len(a) // 2\n    l_rec = max_sum(a[:mid])\n    r_rec = max_sum(a[mid:])\n    l_bests = [0]*m\n    r_bests = [0]*m\n    l_sum = 0\n    for idx in range(1,mid+1):\n        l_sum += a[mid-idx]\n        if idx % m == 0:\n            l_sum -= k\n        l_bests[idx%m] = max(l_bests[idx%m], l_sum)\n    r_sum = 0\n    for idx in range(0, len(a)-mid):\n        r_sum += a[idx+mid]\n        if (idx+1) % m == 0:\n            r_sum -= k\n        r_bests[(idx+1)%m] = max(r_bests[(idx+1)%m], r_sum)\n\n #   print(\"Array:\", a, \"mid:\", mid)\n#    print(l_bests)\n  #  print(r_bests)\n    best_acr = 0\n    for i in range(m):\n        for j in range(m):\n            best_acr = max(best_acr, l_bests[i] + r_bests[j] - (k if i+j>0 else 0) - (k if i+j>m else 0))\n    ans = max(l_rec,r_rec, best_acr)\n   # print(\"Answer:\", ans)\n    return ans\n\n\nans = max_sum(a)\nstdout.write(str(ans) + \"\\n\")\n#stdout.write(str(bf(a))+\"\\n\")\n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "import math\ninput_list =   lambda:  list(map(int, input().split()))\n\nn = int(input())\na = input_list()\nrows, cols = (n+1, n+1)\ndp = [[-1 for i in range(rows)] for j in range(cols)]\nfor i in range(n):\n    dp[i][i] = a[i]\nfor last in range(1, n):\n    for first in range(last - 1, -1, -1):\n        for mid in range(last, first, -1):\n            if dp[first][mid-1]!=-1 and dp[mid][last]!=-1 and dp[first][mid-1] == dp[mid][last]:\n                dp[first][last] = dp[first][mid-1] + 1\n\nans = [0 for i in range(n)]\nfor i in range(n):\n    ans[i] = i+1\n\nfor i in range(n):\n    for j in range(i, -1, -1):\n        if (j-1>=0):\n            if (dp[j][i]!=-1):\n                ans[i] = min(ans[i], ans[j-1] + 1)\n        elif (dp[0][i]!=-1):\n            ans[i] = 1\n\n\nprint(ans[n-1])\n        \n\n\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n, m = map(int, input().split())\n\na = []\nb = []\n\nif n <= 8:\n    a = [4]\n    b = [5]\n    \nwhile n > 8:\n    a += [4,5]\n    b += [5,4]\n    n -= 8\n    \nprint(*a + [5], sep=\"\")\nprint(*b + [5], sep=\"\")", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "x2=input()\nx=x2.split(' ')\nn=int(x[0])\nk=int(x[1])\nn,k=n-1,k-1\nl=0\nr=k\ng=k*(k+1)//2\nans=-1\nwhile l<=r:\n\tm=(l+r)//2\n\tif (g-m*(m+1)//2)>=n:\n\t\tans=k-m\n\t\tl=m+1\n\telse:\n\t\tr=m-1\nprint(ans)\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "i = int(input())\ns = input().split()\n\nl = []\nfor j in s:\n    if not l or  int(j)%2 != l[-1]:\n        l.append(int(j)%2)\n    else:\n        l.pop()\n\nif len(l) < 2:\n    print('YES')\nelse:\n    print('NO')\n\n\n", "complexity": "linear", "problem": "1092_D1", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "t = int(input())\n\nfor iter in range(t):\n    n, k = map(int, input().split())\n    if n >= 50:\n        if k == 0:\n            print(\"YES \" + str(n))\n        else:\n            print(\"YES \" + str(n - 1))\n    else:\n        a = [0] * (n + 1)\n        b = [0] * (n + 1)\n        c = [0] * (n + 1)\n        a[0] = 0\n        b[n] = 1\n        c[n] = 0\n\n        for i in range(1, n + 1):\n            a[i] = 4 * a[i - 1] + 1\n        for i in range(n - 1, -1, -1):\n            b[i] = b[i + 1] * 2 + 1\n        for i in range(n - 1, -1, -1):\n            c[i] = c[i + 1] + b[i + 1]\n\n        res = -1\n        for d in range(n + 1):\n            if c[d] <= k and k <= a[n] - a[d] * b[d]:\n                res = d\n\n        if res == -1:\n            print(\"NO\")\n        else:\n            print(\"YES \" + str(res))\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "_, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nc = list(sorted(zip(a, b, range(len(b)))))\nd = [0] * len(b)\n\nif k == 0:\n    print(' '.join(map(str, b)))\nelse:\n    best = [0] * k\n    for pwr, cnt, index in c:\n        d[index] = sum(best) + cnt\n\n        if cnt > best[0]:\n            for i in range(len(best)):\n                if cnt <= best[i]:\n                    best.insert(i, cnt)\n                    best = best[1:]\n                    break\n            else:\n                best = best[1:] + [cnt]\n\n\n    print(' '.join(map(str, d)))\n", "complexity": "nlogn", "problem": "0994_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "t = int(input())\nfor i in range(t):\n    n = int(input())\n    ai = list(map(int,input().split()))\n    ai.sort()\n    print(min(n-2,ai[-2]-1))\n    \n", "complexity": "nlogn", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "# import sys\n# sys.stdin = open(\"#input.txt\", \"r\")\n\nfrom math import factorial\n\ns1 = input()\ns2 = input()\n\nfinPos=0\nfor c in s1:\n\tif c=='+': finPos+=1\n\telse: finPos-=1\n\nstPos=0\nfor c in s2:\n\tif c=='+': stPos+=1\n\telif c=='-': stPos-=1\n\nn=s2.count('?')\ndiff=abs(finPos-stPos)\nif diff > n:\n\tprint(0)\nelif n&1 != diff&1:\n\tprint(0)\nelse:\n\ti=0\n\tfor i in range(n//2,n):\n\t\tif i*2-n == diff: break\n\tif i*2-n != diff: i+=1\n\n\tprint((factorial(n)/(factorial(n-i)*factorial(i)))/(1<<n))", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "def read():\n    return int(input())\n\n\ndef readlist():\n    return list(map(int, input().split()))\n\n\ndef readmap():\n    return map(int, input().split())\n\n\nN, A, B = readmap()\n\nif N == 1:\n    print(\"YES\")\n    print(0)\n\nelif N == 2:\n    if A == 1 and B == 2:\n        print(\"YES\")\n        print(\"01\")\n        print(\"10\")\n    elif A == 2 and B == 1:\n        print(\"YES\")\n        print(\"00\")\n        print(\"00\")\n    else:\n        print(\"NO\")\n\nelif N == 3:\n    if A == 1 and B == 2:\n        print(\"YES\")\n        print(\"011\")\n        print(\"100\")\n        print(\"100\")\n    elif A == 2 and B == 1:\n        print(\"YES\")\n        print(\"001\")\n        print(\"000\")\n        print(\"100\")\n    elif A == 1 and B == 3:\n        print(\"YES\")\n        print(\"011\")\n        print(\"101\")\n        print(\"110\")\n    elif A == 3 and B == 1:\n        print(\"YES\")\n        print(\"000\")\n        print(\"000\")\n        print(\"000\")\n    else:\n        print(\"NO\")\n\nelse:\n    if A != 1 and B != 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if B == 1 and A != 1:\n            mat = []\n            for i in range(N):\n                vec = []\n                if i == 0:\n                    for j in range(N):\n                        if j >= A:\n                            vec.append(1)\n                        else:\n                            vec.append(0)\n                    mat.append(vec)\n                else:\n                    vec = [0] * N\n                    if i >= A:\n                        vec[0] = 1\n                    mat.append(vec)\n\n            for n in range(N):\n                print(\"\".join(list(map(str, mat[n]))))\n        elif A == 1 and B != 1:\n            mat = []\n            for i in range(N):\n                vec = []\n                if i == 0:\n                    for j in range(N):\n                        if j >= B:\n                            vec.append(0)\n                        else:\n                            vec.append(1)\n                    vec[i] = 0\n                    mat.append(vec)\n                else:\n                    vec = [1] * N\n                    if i >= B:\n                        vec[0] = 0\n                    vec[i] = 0\n                    mat.append(vec)\n\n            for n in range(N):\n                print(\"\".join(list(map(str, mat[n]))))\n        else:  # A == 1 and B == 1\n            mat = []\n            for i in range(N):\n                vec = []\n                if i == 0:\n                    for j in range(N):\n                        if j >= 2:\n                            vec.append(1)\n                        else:\n                            vec.append(0)\n                    mat.append(vec)\n                else:\n                    vec = [0] * N\n                    if i >= 2:\n                        vec[0] = 1\n                    mat.append(vec)\n\n            mat[1][2] = 1\n            mat[2][1] = 1\n            for n in range(N):\n                print(\"\".join(list(map(str, mat[n]))))\n", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "def dsum(n):\n    return sum([int(c) for c in str(n)])\n\n\nn, s = map(int, input().split(' '))\nl = 1\nr = n\nwhile l <= r:\n    mid = (l + r) // 2\n    delta = mid - dsum(mid)\n    if delta >= s:\n        r = mid - 1\n    else:\n        l = mid + 1\nprint(n - l + 1)\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "x, k = list(map(int,input().split()))\nm = 1000000000 +7\nif x!=0:\n    p1 = x*2 - 1\n    p2 = x*2\n    p = (p1 + p2)//2\n    print((p*pow(2,k,m) + 1)%m)\nelse:\n    print(x*2)\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "from math import factorial as fact\ns1 = input()\ns2 = input()\nplus1 = s1.count(\"+\")\nminus1 = s1.count(\"-\")\n\nplus2 = s2.count(\"+\")\nminus2 = s2.count(\"-\")\nqCount = s2.count(\"?\")\n\nif(plus1==plus2 and minus1==minus2):\n\tprint(1)\nelse:\n\tplusReq = plus1 - plus2\n\tminusReq = minus1 - minus2\n\tif(plusReq >= 0 and minusReq >= 0):\n\t\tans = (0.5**qCount)*fact(qCount)/(fact(plusReq)*fact(minusReq))\n\t\tprint(ans)\n\t\t\n\telse:\n\t\tprint(0)\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "# http://codeforces.com/problemset/problem/23/A\nleng = 0\ns = input()\nfor i in range(len(s)):\n    for j in range(i + 1, len(s) + 1):\n        sub = s[i:j]\n        if s.count(sub) >= 2 and len(sub) > leng:\n            leng = len(sub)\n        elif s.count(sub) == 1:\n            for k in range(1, len(sub)):\n                if s[i - k:j - k] == sub and len(sub) > leng:\n                    leng = len(sub)\nprint(leng)\n\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "for _ in range(int(input())):\n    n = int(input())\n    li = sorted(list(map(int, input().split())))\n    print(min(li[n - 2] - 1, n - 2))\n", "complexity": "nlogn", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    inf = -float(\"inf\")\n    for _ in range(int(input())):\n        n,m = map(int,input().split())\n        a = [list(map(int,input().split())) for _ in range(n)]\n        y = 1<<n\n        dp = [[0]+[inf]*(y-1) for _ in range(m+1)]\n        for i in range(1,m+1):\n            for shift in range(n):\n                for mask1 in range(y):\n                    for mask2 in range(y):\n                        new = mask1^mask2\n                        if new&mask1:\n                            continue\n                        mm,add = 1,0\n                        for x in range(n):\n                            if mm&new:\n                                tt = x+shift\n                                if tt >= n:\n                                    tt -= n\n                                add += a[tt][i-1]\n                            mm <<= 1\n                        dp[i][mask2] = max(dp[i][mask2],dp[i-1][mask1]+add)\n        print(dp[m][y-1])\n\n# Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right \nfrom heapq import heappop,heappush,heapify, nlargest\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n \n\nn,m = inpl()\nabc = [inpl() for _ in range(m)]\n\ndef sol(X): \n    g = [[] for _ in range(n)]\n    ny = [0]*n\n    for a,b,c in abc:\n        if c > X:\n            g[a-1].append(b-1)\n            ny[b-1] += 1\n    seen = [0]*n\n    q = deque()\n    for i,x in enumerate(ny):\n        if x==0: q.append(i); seen[i] = 1\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if seen[u]: continue\n            ny[u] -= 1\n            if ny[u] == 0:\n                q.append(u)\n                seen[u]= 1\n    return all(seen)\n\ndef sol2(X): \n    g = [[] for _ in range(n)]\n    ny = [0]*n\n    for a,b,c in abc:\n        if c > X:\n            g[a-1].append(b-1)\n            ny[b-1] += 1\n    tps = [-1]*n; T = 0\n    seen = [0]*n\n    q = deque()\n    for i,x in enumerate(ny):\n        if x==0: q.append(i); seen[i] = 1\n    while q:\n        v = q.popleft()\n        tps[v] = T; T += 1\n        for u in g[v]:\n            if seen[u]: continue\n            ny[u] -= 1\n            if ny[u] == 0:\n                q.append(u)\n                seen[u]= 1\n    return tps\n\n# print(sol(3))\nok = 10**9+10; ng = -1\nwhile abs(ok-ng)>1:\n    mid = (ok+ng)//2\n    if sol(mid): ok = mid\n    else: ng = mid\n# print(ok)\nres = []\ntps = sol2(ok)\nfor i,(a,b,c) in enumerate(abc):\n    if c <= ok:\n        if tps[a-1] > tps[b-1]: res.append(i+1)\nprint(ok,len(res))\nprint(*res)", "complexity": "nlogn", "problem": "1100_E", "from": "CODEFORCES", "tags": "binary search,dfs and similar,graphs"}
{"src": "def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res//x * (x-1)\n            while n%x==0:\n                n //= x\n    if n!=1:\n        res = res//n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n//=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):#\u6392\u4ed6\u7684\u8ad6\u7406\u548c\u306e\u968e\u4e57\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\n#O(|S|)\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matrix[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matrix[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matrix[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]+other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]-other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matrix[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m//=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matrix[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import log,gcd\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn,m = mi()\na = li()\nsize = [0 for i in range(n)]\nfor i in range(m):\n    size[a[i]-1] += 1\nprint(min(size))\n", "complexity": "quadratic", "problem": "0961_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+1)\n\n    def to_sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, x):\n        while i <= self.n:\n            self.data[i] += x\n            i += (i & -i)\n\n    def get(self, i, j):\n        #[i,j](1<=i<=j<=N)\n        return self.to_sum(j) - self.to_sum(i - 1)\n\n\ndef f(x, V):\n    if x < V:\n        return -1\n    return 1\n\n\ndef calc_median(M):\n    b = [f(v, M) for v in a]\n    res = 0\n    c = [0]\n    for x in b:\n        c.append(c[-1] + x)\n    d = [(c[i], i) for i in range(n + 1)]\n    bit = BIT(2*n + 10)\n    for value, index in d:\n        if index == 0:\n            bit.add(value + n + 1, 1)\n            continue\n        res += bit.get(1, value + n)\n        bit.add(value + n + 1, 1)\n\n    return res\n\n\nprint(calc_median(m) - calc_median(m + 1))\n\n", "complexity": "nlogn", "problem": "1005_E1", "from": "CODEFORCES", "tags": "sortings"}
{"src": "T = int(input())\nfor ti in range(T):\n    s = input().strip()\n    t = input().strip()\n    N = len(t)\n    for i in range(1, N+1):\n        # t1 : [0,i), t2 : [i,N)\u306b\u5206\u5272\n        dp = [[0]+[-1]*i for _ in range(len(s)+1)]\n        for l, c in enumerate(s):\n            for j in range(i+1):\n                dp[l+1][j] = dp[l][j]\n                # t1[0:j]\u3092\u69cb\u6210\u3057\u305f\u6642\u306bt2\u306f\u3069\u3053\u307e\u3067\u69cb\u6210\u3067\u304d\u308b\u304b\n                # c\u3092t2\u306b\u4f7f\u3046\n                if dp[l][j] != -1:\n                    if i+dp[l][j] < N and t[i+dp[l][j]] == c:\n                        dp[l+1][j] = dp[l][j]+1\n#                    print(l+1, i+dp[l][j], c, t[i+dp[l][j+1]])\n                # c\u3092t1\u306b\u4f7f\u3046\n                if j != 0 and c == t[j-1]:\n                    dp[l+1][j] = max(dp[l+1][j], dp[l][j-1])\n#                    print(l+1, j+1, dp[l][j])\n#        print(ti, i, dp, dp[-1][i])\n        if dp[-1][i] == N-i:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")\n\n", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "n,m=map(int,input().split())\ns=input()\nt=input()\nif n-1>m:\n    print('NO')\nelse:\n    try:\n        a=s.index('*')\n    except:\n        a=-1\n    if a==-1:\n        if s==t:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        f=True\n        for i in range(a):\n            if s[i]!=t[i]:\n                print('NO')\n                exit()\n        i=1\n        while m-i>=a and n-i>a:\n            if s[n-i]!=t[m-i]:\n                print('NO')\n                exit()\n            i+=1\n        print('YES')", "complexity": "linear", "problem": "1023_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "import sys\nfrom collections import deque\nimport heapq\ninput = sys.stdin.readline\n\nN=int(input())\nEDGE=[list(map(int,input().split())) for i in range(N-1)]\n\nEDGELIST=[[] for i in range(N+1)]\n\nfor i,j in EDGE:\n    EDGELIST[i].append(j)\n    EDGELIST[j].append(i)\n\n#EDGES=[[] for i in range(N+1)]\nREDG=[None for i in range(N+1)]\nQUE=deque([1])\ncheck=[0]*(N+1)\nDEPTH=[None]*(N+1)\ni=0\nwhile QUE:\n    NQUE=deque()\n    i+=1\n    \n    while QUE:\n        x=QUE.pop()\n        DEPTH[x]=i\n        check[x]=1\n        for to in EDGELIST[x]:\n            if check[to]==1:\n                continue\n            else:\n                #EDGES[x].append(to)\n                REDG[to]=x\n                NQUE.append(to)\n    QUE=NQUE\n\n\ncheck=[0]*(N+1)\ncheck[1]=1\n#NEXT=[]\n\n#for i in EDGES[1]:\n#    check[i]=1\n#    NEXT.append(i)\n\n#for j in NEXT:\n#    for k in EDGES[j]:\n#        check[k]=1\n\n\nLEAF=[]\nfor i in range(2,N+1):\n    if len(EDGELIST[i])==1:\n        LEAF.append((-DEPTH[i],i))\n\nQUE=LEAF\nheapq.heapify(QUE)\nANS=0\n\n#print(check,QUE)\n\nwhile QUE:\n    dep,x=heapq.heappop(QUE)\n    if check[x]!=0 or dep>=-3:\n        continue\n\n    if check[REDG[x]]==2:\n        continue\n\n    if check[x]==0:\n        check[x]=1\n    if check[REDG[REDG[x]]]==0:\n        check[REDG[REDG[x]]]=1\n    check[REDG[x]]=2   \n    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))\n    ANS+=1\n\n    #print(x,QUE,check)\n\nprint(ANS)\n\n\n\n", "complexity": "linear", "problem": "1029_E", "from": "CODEFORCES", "tags": "dp,graphs,greedy"}
{"src": "from itertools import accumulate\nn,m,k = map(int,input().split())\na = list(map(int,input().split()))\nals = []\nfor i in range(m):\n  ls = a[:]\n  for j in range(n):\n    if j%m == i:\n      ls[j] -= k\n  als.append(list(accumulate(ls)))\nans = 0\nfor i in range(m):\n  ls = als[i]\n  mn = 0\n  anstmp = 0\n  for j in range(n):\n    if mn > ls[j]:\n      mn = ls[j]\n    if j%m == i:\n      anstmp = max(anstmp,ls[j]-mn)\n  ans = max(ans,anstmp)\nprint(ans)", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "import random\n\nn = int(input())\n\nvec = [list(map(int, input().rstrip('\\n').split(' '))) for i in range(n)]\n\nbo = 10**6\n\ncoef = [[1, 1, 0], [1, -1, 0], [-1, 1, 0], [-1, -1, 0],\n[1, 0, 1], [1, 0, -1], [-1, 0, 1], [-1, 0, -1],\n[0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1]]\n\ndef lv(x):\n\treturn (x[0]**2 + x[1]**2)**0.5\n\nif n == 1:\n\tres = [1]\nelif n == 2:\n\tif vec[0][0]*vec[1][0] + vec[0][1]*vec[1][1] <= 0:\n\t\tres = [1, 1]\n\telse:\n\t\tres = [1, -1]\nelse:\n\tres = [0 for i in range(n)]\n\tfer = [[vec[0], vec[1], vec[2]],[[0], [1], [2]]]\n\tfor l in range(len(vec)-2):\n\t\tfor j in coef:\n\t\t\tder = [0, 0]\n\t\t\tder[0] = j[0]*fer[0][0][0] + j[1]*fer[0][1][0] + j[2]*fer[0][2][0]\n\t\t\tder[1] = j[0]*fer[0][0][1] + j[1]*fer[0][1][1] + j[2]*fer[0][2][1]\n\t\t\tif lv(der) <= bo:\n\t\t\t\tner = []\n\t\t\t\tfor i in range(3):\n\t\t\t\t\tif j[i] != 0:\n\t\t\t\t\t\tner.append(i)\n\t\t\t\tif len(fer[1][ner[0]]) == 1:\n\t\t\t\t\tres[fer[1][ner[0]][0]] = j[ner[0]]\n\t\t\t\telif j[ner[0]] == -1:\n\t\t\t\t\tfor k in fer[1][ner[0]]:\n\t\t\t\t\t\tres[k] *= -1\n\t\t\t\tfer[0][ner[0]] = der\n\t\t\t\tfer[1][ner[0]] += fer[1][ner[1]]\n\t\t\t\tif len(fer[1][ner[1]]) == 1:\n\t\t\t\t\tres[fer[1][ner[1]][0]] = j[ner[1]]\n\t\t\t\telif j[ner[1]] == -1:\n\t\t\t\t\tfor k in fer[1][ner[1]]:\n\t\t\t\t\t\tres[k] *= -1\n\t\t\t\tif l == len(vec)-3:\n\t\t\t\t\tdel fer[0][ner[1]]\n\t\t\t\t\tdel fer[1][ner[1]]\n\t\t\t\telse:\n\t\t\t\t\tfer[0][ner[1]] = vec[3+l]\n\t\t\t\t\tfer[1][ner[1]] = [3+l]\n\t\t\t\tbreak\n\tif fer[0][0][0]*fer[0][1][0] + fer[0][0][1]*fer[0][1][1] <= 0:\n\t\tif len(fer[1][0]) == 1:\n\t\t\tres[fer[1][0][0]] = 1\n\t\tif len(fer[1][1]) == 1:\n\t\t\tres[fer[1][1][0]] = 1\n\telse:\n\t\tif len(fer[1][0]) == 1:\n\t\t\tres[fer[1][0][0]] = -1\n\t\telif len(fer[1][1]) == 1:\n\t\t\tres[fer[1][1][0]] = -1\n\t\telse:\n\t\t\tfor k in fer[1][0]:\n\t\t\t\tres[k] *= -1\nres1 = ''\nfor i in res:\n\tres1 += str(i)+' '\nres1 = res1[:-1]\nprint(res1)", "complexity": "nlogn", "problem": "0995_C", "from": "CODEFORCES", "tags": "brute force,data structures,geometry,greedy,math,sortings"}
{"src": "import sys\n\ninput = sys.stdin.readline\n\nr, g, b = map(int, input().split())\nsticks, dp, ans = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)], [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 # dp[i][j][k] is i largest red, j largest green, k largest blue\n\nfor i in range(r + 1):\n    for j in range(g + 1):\n        for k in range(b + 1):\n            ans = max(ans, dp[i][j][k])\n            if i < r and j < g:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])\n            if i < r and k < b:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])\n            if j < g and k < b:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])\nprint(ans)\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "R,G,B = list(map(int, input().split()))\nr = sorted(list(map(int, input().split())), reverse =True)\ng = sorted(list(map(int, input().split())), reverse =True)\nb = sorted(list(map(int, input().split())), reverse =True)\ndef f(x,y,z):\n    m1 = 0\n    m2 = 0\n    m3 = 0\n    if(x<R and y<G):\n        if(dpt[x+1][y+1][z]==-1):\n            dpt[x+1][y+1][z] = f(x+1,y+1,z)\n        m1 = r[x]*g[y] + dpt[x+1][y+1][z]\n    if(y<G and z<B):\n        if(dpt[x][y+1][z+1]==-1):\n            dpt[x][y+1][z+1] = f(x,y+1,z+1)\n        m2 = g[y]*b[z] + dpt[x][y+1][z+1]\n    if(z<B and x<R):\n        if(dpt[x+1][y][z+1]==-1):\n            dpt[x+1][y][z+1] = f(x+1,y,z+1)\n        m3 = r[x]*b[z] + dpt[x+1][y][z+1]\n    dpt[x][y][z] = max(m1,m2,m3)\n    return dpt[x][y][z]\ndpt = [[[-1 for _ in range(B+1)]for _ in range(G+1)]for _ in range(R+1)]\nprint(f(0,0,0))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "from itertools import combinations\nn, mn, mx, diff = map(int, input().split())\narr = list(map(int, input().split()))\nprint(sum(sum(1 for x in combinations(arr, i) if sum(x)>= mn and sum(x) <= mx and max(x)-min(x)>=diff) for i in range(2, n+1)))\n\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "def main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n = read_int()\n    nums = read_int_array()\n    out = nums[0]\n    first = nums[0]\n    for i in range(1, n):\n        out = min(out, min(nums[i], first) // i)\n    last = nums[-1]\n    for i in range(n-2, 0, -1):\n        out = min(out, min(nums[i], last) // (n-1 - i))\n    write(out)\n\nmain()\n", "complexity": "linear", "problem": "1159_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "def solution(n, k):\n    ret = [['.' for _ in range(n)] for _ in range(4)]\n    if 1 == k & 1:\n        ret[1][n >> 1] = '#'\n        for i in range(1, n >> 1):\n            if k < 2:\n                break\n            k -= 2\n            ret[1][i] = '#'\n            ret[1][n - 1 - i] = '#'\n        for i in range(1, n >> 1):\n            if k < 2:\n                break\n            k -= 2\n            ret[2][i] = '#'\n            ret[2][n - 1 - i] = '#'\n    else:\n        for i in range(1, n - 1):\n            if k < 2:\n                break\n            k -= 2\n            ret[1][i] = '#'\n            ret[2][i] = '#'\n\n\n    print('YES')\n    for i in range(4):\n        print(''.join(ret[i]))\n\n\nsolution(*map(int, input().split()))\n", "complexity": "linear", "problem": "0980_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "l1=l2=-1\nr1=r2=1<<30\nfor i in range(int(input())):\n l,r=map(int,input().split())\n if l>l1:il,l1,l2=i,l,l1\n elif l>l2:l2=l\n if r<r1:ir,r1,r2=i,r,r1\n elif r<r2:r2=r\nprint(max(0,(r2-l2,max(r1-l2,r2-l1))[il!=ir]))", "complexity": "linear", "problem": "1029_C", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "kk=lambda:map(int, input().split())\nll=lambda:list(kk())\nn,l,r,d=kk()\np,t=ll(),0\nfor v in range(2**n):\n\ts = []\n\tfor i in range(n):\n\t\tif v&(2**i):\n\t\t\ts.append(p[i])\n\tif l <= sum(s)<=r and max(s)-min(s) >= d: t+=1\nprint(t)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import sys\nfrom array import array\n\nn = int(input())\nedge = [list(map(int, input().split())) for _ in range(n)]\nmod = 10**9 + 7\n\ndp_f = [array('i', [-1])*n for _ in range(n)]\ndp_g = [array('i', [-1])*n for _ in range(n)]\n\n\nfor i in range(n):\n    dp_f[i][i] = dp_g[i][i] = 1\nfor i in range(n-1):\n    dp_f[i][i+1] = dp_g[i][i+1] = 1 if edge[i][i+1] else 0\n\n\ndef f(l, r):\n    if dp_f[l][r] != -1:\n        return dp_f[l][r]\n\n    dp_f[l][r] = g(l, r) if edge[l][r] else 0\n    for m in range(l+1, r):\n        if edge[l][m]:\n            dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n\n    return dp_f[l][r]\n\n\ndef g(l, r):\n    if dp_g[l][r] != -1:\n        return dp_g[l][r]\n\n    dp_g[l][r] = f(l+1, r)\n    for m in range(l+1, r):\n        dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m+1, r)) % mod\n\n    return dp_g[l][r]\n\n\nprint(f(0, n-1))", "complexity": "cubic", "problem": "0888_F", "from": "CODEFORCES", "tags": "dp,graphs"}
{"src": "n = int(input())\nans = 1\nfor i in range(1, n):\n    ans += i * 4\nprint(ans)", "complexity": "linear", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "\nn = int(input())\n\n\np = []\nfor i in range(n):\n    la = list(map(float,input().split()))\n    p.append(la)\n\nfull_bit =  (1<<n) - 1\ndp = [0]*(full_bit) + [1]\n\nfor i in range(full_bit,0,-1):\n\n    cunt = bin(i)[2:].count('1')\n    # print(cunt)\n    if cunt == 1 or dp[i] == 0:\n        continue\n\n    mul = 1/((cunt*(cunt-1))>>1)\n\n    for x in range(n):\n        if (i & (1<<x)) == 0:\n            continue\n        for y in range(x+1,n):\n            if (i & (1<<y)) == 0:\n                continue\n\n            dp[i-(1<<y)]+=dp[i]*p[x][y]*mul\n            dp[i-(1<<x)]+=dp[i]*p[y][x]*mul\n\nans = []\nfor i in range(n):\n    ans.append(dp[1<<i])\n\nprint(*ans)\n\n\n\n\n\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "m = int(input())\nvalues = []\nidx = []\nfor i in range(m):\n    x = int(input())\n    ans = 0\n    for j,xx in enumerate(values):\n        if (xx^x) < x:\n            x^=xx\n            ans^=idx[j]\n    if x == 0:\n        anss = []\n        for j in range(i):\n            if (ans&1)!=0:\n                anss.append(j)\n            ans>>=1\n        print(len(anss),*anss)\n    else:\n        print(0)\n        values.append(x)\n        idx.append(ans^(2**i))\n", "complexity": "np", "problem": "0504_D", "from": "CODEFORCES", "tags": "bitmasks"}
{"src": "from itertools import accumulate\nfrom sys import stdin, stdout\n\n\ndef main():\n    k = int(stdin.readline())\n    a = [\n        tuple(map(int, stdin.readline().split()[1:]))\n        for _ in range(k)\n    ]\n    a2ij = {\n        aij: (i, j)\n        for i, ai in enumerate(a)\n        for j, aij in enumerate(ai)\n    }\n\n    plena = [0, ] + list(accumulate(map(len, a)))\n    suma = tuple(map(sum, a))\n    totala = sum(suma)\n\n    if totala % k != 0:\n        stdout.write(\"No\\n\")\n    else:\n        needle = totala // k\n        mask2i2cp = compute_mask2i2cp(a, a2ij, needle, plena, suma)\n        dp = compute_previous_mask(mask2i2cp)\n        output(dp, mask2i2cp)\n\n\ndef compute_mask2i2cp(a, a2ij, needle, plena, suma):\n    used = [False, ] * plena[-1]\n    number_of_masks = 1 << len(a)\n    mask2i2cp = [-1, ] * number_of_masks\n\n    for i, ai in enumerate(a):\n        for j, aij in enumerate(ai):\n            if not used[plena[i] + j]:\n                mask, i2cp = compute_mask_i2cp(a2ij, aij, i, j, needle, suma)\n\n                if i2cp != -1:\n                    mask2i2cp[mask] = i2cp\n\n    return mask2i2cp\n\n\ndef output(dp, mask2i2cp):\n    mask = len(mask2i2cp) - 1\n\n    if dp[mask] == -1:\n        stdout.write(\"No\\n\")\n    else:\n        answer = [-1, ] * len(mask2i2cp[dp[mask]])\n\n        while mask > 0:\n            current_mask = dp[mask]\n\n            for i, cp in enumerate(mask2i2cp[current_mask]):\n                if 1 == ((current_mask >> i) & 1):\n                    c, p = cp\n                    answer[i] = (c, p)\n\n            mask ^= current_mask\n\n        stdout.write('Yes\\n' + '\\n'.join('{} {}'.format(c, 1 + p) for c, p in answer))\n\n\ndef compute_mask_i2cp(a2ij, aij, i, j, needle, suma):\n    i2cp = [-1, ] * len(suma)\n    mask = 0\n    current_a = aij\n    current_i = i\n\n    try:\n        while True:\n            next_a = needle - (suma[current_i] - current_a)\n\n            next_i, next_j = a2ij[next_a]\n\n            if ((mask >> next_i) & 1) == 1:\n                return mask, -1\n\n            mask |= 1 << next_i\n            i2cp[next_i] = (next_a, current_i)\n\n            if next_i == i:\n                if next_j == j:\n                    return mask, i2cp\n\n                return mask, -1\n\n            if next_i == current_i:\n                return mask, -1\n\n            current_a = next_a\n            current_i = next_i\n    except KeyError:\n        return mask, -1\n\n\ndef compute_previous_mask(mask2cp):\n    number_of_masks = len(mask2cp)\n    dp = [-1, ] * number_of_masks\n    dp[0] = 0\n\n    for mask, cp in enumerate(mask2cp):\n        if cp != -1:\n            complement_mask = (number_of_masks - 1) & (~mask)\n            previous_mask = complement_mask\n\n            while previous_mask > 0:\n                if dp[previous_mask] != -1 and dp[previous_mask | mask] == -1:\n                    dp[previous_mask | mask] = mask\n\n                previous_mask = (previous_mask - 1) & complement_mask\n\n            if dp[mask] == -1:\n                dp[mask] = mask\n    return dp\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "def get_sign_1(fo):\n\tdef res(s, f=fo):\n\t\tif f**2+s**2 == 2*f*s+1:\n\t\t\treturn '1'\n\t\telse:\n\t\t\treturn '0'\n\treturn res\n\n\ndef get_signs_2(cf, rev):\n\tcf -= 1\n\tif rev:\n\t\tdef res(fo, cff=cf):\n\t\t\tif fo >= cff:\n\t\t\t\tdef res2(s, f=fo):\n\t\t\t\t\tif s == f:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telif s >= cff:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn '1'\n\t\t\telse:\n\t\t\t\tdef res2(s, f=fo):\n\t\t\t\t\tif s == f:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn '1'\n\t\t\treturn res2\n\telse:\n\t\tdef res(fo, cff=cf):\n\t\t\tif fo >= cff:\n\t\t\t\tdef res2(s, f=fo):\n\t\t\t\t\tif s == f:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telif s >= cff:\n\t\t\t\t\t\treturn '1'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn '0'\n\t\t\telse:\n\t\t\t\tdef res2(s):\n\t\t\t\t\treturn '0'\n\t\t\treturn res2\n\treturn res\nn, a, b = map(int, input().split())\nc = a*b\nif a+b == c+1 and (c > 1 or n == 1 or n > 3):\n\tprint(\"YES\")\n\tif c == 1:\n\t\tget_sign_f = get_sign_1\n\telse:\n\t\tget_sign_f = get_signs_2(c, c == b)\n\tfor foo in range(n):\n\t\tprint(''.join(map(get_sign_f(foo), range(n))))\nelse:\n\tprint(\"NO\")\n", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n    def __init__(self):\n        n, m = map(int, input().strip().split())\n        segs = list()\n        for i in range(m):\n            segs.append(list(map(int, input().strip().split())))\n        \n        def calc(s, segs):\n            res = 0\n            for x in segs:\n                ones = sum(s[x[0]:x[1] + 1])\n                res += ones * (x[1] - x[0] + 1 - ones)\n            return res\n\n        s1 = [0 for i in range(n)]\n        s2 = [1 for i in range(n)]\n        for i in range(n):\n            if i % 2 == 0:\n                s1[i] = 1\n                s2[i] = 0\n\n        ans = s1 if calc(s1, segs) > calc(s2, segs) else s2\n        print(''.join(map(str, ans)))\n        \nsolver()", "complexity": "linear", "problem": "1004_B", "from": "CODEFORCES", "tags": "constructive algorithms,greedy,implementation,math"}
{"src": "n = int(input())\nl = list( map( int, input().split() ) )\nans = max(l)\nfor i in range(n):\n    ans = min( ans, l[ i ] // max( i, n - i - 1 ))\nprint( ans )", "complexity": "linear", "problem": "1159_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n, k = [int(i) for i in input().split()]\n\nmid = n//2\nleftside = 1\nrightside = n\n\ncandies = n-mid\n\nwhile mid * (mid + 1)//2 - candies != k:\n    if k > mid * (mid + 1)//2 - candies:\n        leftside = mid + 1\n    else:\n        rightside = mid\n\n    mid = (leftside + rightside)//2\n    candies = n-mid\nprint(candies)", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "#---------------------------iye ha aam zindegi---------------------------------------------\nimport math\nimport heapq,bisect\nimport sys\nfrom collections import deque,defaultdict\nfrom fractions import Fraction\nmod=10**9+7\nmod1=998244353\n# ------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree1:\n    def __init__(self, data, default=9999999, func=lambda a, b: min(a , b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n#-------------------------------iye ha chutiya zindegi-------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n#--------------------------------------iye ha combinations ka zindegi---------------------------------\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n // 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n#--------------------------------------iye ha power ka zindegi---------------------------------\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n#--------------------------------------------------product----------------------------------------\ndef product(l):\n    por=1\n    for i in range(len(l)):\n        por*=l[i]\n    return por\n#--------------------------------------------------binary----------------------------------------\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) / 2)\n\n        # Check if middle element is\n        # less than or equal to key\n        if (arr[mid] <= key):\n\n            # At least (mid + 1) elements are there\n            # whose values are less than\n            # or equal to key\n            count = mid + 1\n            left = mid + 1\n\n        # If key is smaller, ignore right half\n        else:\n            right = mid - 1\n\n    return count\n#--------------------------------------------------binary----------------------------------------\ndef countdig(n):\n    c=0\n    while(n>0):\n        n//=10\n        c+=1\n    return c\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    # Stores the index of the left most element\n    # from the array which is greater than k\n    leftGreater = n\n\n    # Finds number of elements greater than k\n    while (l <= r):\n        m = int(l + (r - l) / 2)\n\n        # If mid element is greater than\n        # k update leftGreater and r\n        if (arr[m] > k):\n            leftGreater = m\n            r = m - 1\n\n        # If mid element is less than\n        # or equal to k update l\n        else:\n            l = m + 1\n\n    # Return the count of elements\n    # greater than k\n    return (n - leftGreater)\n#--------------------------------------------------binary------------------------------------\ndef findmin(h,n):\n    n.sort()\n    h=int(h)\n    ans='-1'\n    #print(h,n)\n    for i in n:\n        if int(i)>h:\n            break\n        ans=i\n    #print(ans)\n    return ans\nn=list(input())\nn1=list(input())\nif len(n)<len(n1):\n    n.sort(reverse=True)\n    print(*n,sep='')\n    sys.exit()\nn.sort()\nans=\"\"\nf=0\nfor i in range(len(n)):\n    t=i-1\n    c=0\n    r = findmin(n1[i], n)\n    if r=='-1':\n        while(r=='-1'):\n            n.append(ans[-c-1])\n            r=findmin(int(n1[t])-1,n)\n            t-=1\n            c+=1\n        ans=ans[:len(ans)-c]\n        ans+=r\n        n.remove(r)\n        f=1\n        break\n    n.remove(r)\n    if r==n1[i]:\n        ans+=r\n        continue\n    else:\n        ans+=r\n        f=1\n        break\nif f==1:\n    n.sort(reverse=True)\n    for i in n:\n        ans+=i\nprint(ans)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys,math,bisect\nfrom random import randint\ninf = float('inf')\nmod = 998244353\n\"========================================\"\ndef lcm(a,b):\n    return int((a/math.gcd(a,b))*b)\ndef gcd(a,b):\n    return int(math.gcd(a,b))\ndef tobinary(n):\n    return bin(n)[2:]\ndef binarySearch(a,x):\n    i = bisect.bisect_left(a,x)\n    if i!=len(a) and a[i]==x:\n        return i\n    else:\n        return -1\ndef lowerBound(a, x):\n    i = bisect.bisect_left(a, x)\n    if i:\n        return (i-1)\n    else:\n        return -1\ndef upperBound(a,x):\n    i = bisect.bisect_right(a,x)\n    if i!= len(a)+1 and a[i-1]==x:\n        return (i-1)\n    else:\n        return -1\ndef primesInRange(n):\n    ans = []\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n+1):\n        if prime[p]:\n            ans.append(p)\n    return ans\ndef primeFactors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            factors.append(i)\n            n = n // i\n    if n > 2:\n        factors.append(n)\n    return factors\ndef isPrime(n,k=5):\n    if (n <2):\n        return True\n    for i in range(0,k):\n        a = randint(1,n-1)\n        if(pow(a,n-1,n)!=1):\n            return False\n    return True\n\"=========================================\"\n\"\"\"\nn = int(input())\nn,k = map(int,input().split())\narr = list(map(int,input().split()))\n\"\"\"\nfrom collections import deque,defaultdict,Counter\nimport heapq,string\n\n\nn=int(input())\ns=input()\ns=[int(i) for i in s]\nflag=False\nfor i in range(0,(9*n)+1):\n    count=0\n    sum = 0\n    for j in s:\n        sum+=j\n        if sum==i:\n            count+=1\n            sum=0\n    if count>1 and sum==0:\n        print('YES')\n        exit(0)\nprint('NO')\n", "complexity": "quadratic", "problem": "1030_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\ninput=sys.stdin.readline\n\ndef count_bits(x):\n    cnt=0\n    for i in range(n):\n        if((1<<i)&x):\n            cnt+=1\n    return(cnt)\n\nn=int(input())\na=[list(map(float,input().split())) for i in range(n)]\ndp=[0 for i in range(1<<n)] #Probabilty a particular permutation of (alive) fish are acheived.\ndp[-1]=1 #We start with all fish, so the probability they all together is 1(base case)\n#We will calculate the probability of acheiving a particular permutation of k alive fish from all possible permutations of k+1 alive fish for all values of k.\nfor mask in range((1<<n)-1,-1,-1):\n    val=count_bits(mask)\n    total=val*(val-1)//2 #Used to calculate the probability of choosing two fish among the alive fish. We will take the case the first fish eats the second fish(the opposite case is dealt again in another loop, won't increase efficiency much), and add to the new permutation the probability of obtaiining it from the current permutation.\n    for i in range(n):\n        if(mask&(1<<i)==0): #We can't choose a dead/eaten fish\n            continue\n        for j in range(n): #Second fish of the pair for the above choosen fish among all other alive fish\n            if(mask&(1<<j)==0 or i==j):\n                continue\n            dp[mask^(1<<j)]+=dp[mask]*a[i][j]/total #considering ith fish eats jth fish\nfor i in range(n):\n    print(dp[1<<i])\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import sys\nif __name__=='__main__':\n    # read input\n    numCases = int(sys.stdin.readline())\n    for i in range(numCases):\n        a, b = sys.stdin.readline().split()\n        a = int(a)\n        b = int(b)\n        total = 0\n        largerNum = max(a,b)\n        smallerNum = min(a,b)\n        while True:\n            div = int(largerNum/smallerNum)\n            total += div\n            rem = int(largerNum%(smallerNum*div))\n            if rem == 0:\n                break\n            else:\n                largerNum = smallerNum\n                smallerNum = rem\n                \n        print(total)\n        \n    ", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "n=int(input())\nans=0\nfor i in range(2,n+1):\n\tfor j in range(2*i,n+1,i):\n\t\tans+=(4*(j//i))\nprint(ans)", "complexity": "nlogn", "problem": "1062_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation,math"}
{"src": "def main():\n    n = int(input())\n    arr = []\n    \n    for i in range(n):\n        arr.append(input())\n        \n    arr = sorted(arr, key=lambda x : len(x))\n    \n    for i in range(n-1):\n        if arr[i] not in arr[i+1]:\n            print('NO')\n            return;\n    \n    print('YES')\n    for pal in arr:\n        print(pal)\n\nmain()\n\t \t\t \t\t\t    \t   \t\t\t\t\t\t\t \t\t \t\t \t", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "n, m, k, l = map(int, input().split())\nif m > n:\n    print(-1)\nelif l + k > n:\n    print(-1)\nelse:\n    s = (l + k) // m + bool((l + k) % m)\n    if s * m > n:\n        print(-1)\n    else:\n        print(s)\n", "complexity": "constant", "problem": "1068_A", "from": "CODEFORCES", "tags": "math"}
{"src": "#digits sequence(Hard Edition)\n\nn = int(input())\n\ncheck = True\nt=0\ntnext=9\n\ncount=1\ni=1\nj=1\nres = 0\nwhile(check):\n    \n    if(n<=tnext):\n        res=n-t\n        check = False\n\n    else:\n        #sm1 = sm1+t\n        count = count+1\n\n        if(t!=0):\n            t=t+9*i*j\n        else:\n            t=9\n\n        tnext = tnext + 9 * (i+1)*(j*10)\n        i=i+1\n        j=j*10\n        \nnum1 = int(res/count)\nnum2 = res%count\n\n\n#print(count , t , tnext , sm1 )\n\n\ndes = pow(10,count-1)\ndespac = des + num1 \n\n\n#print(despac)\n\nif(num2 == 0):\n    despac = str(despac -1)\n    print(despac[-1])\n\nelse :\n    despac = str(despac)\n    print(despac[num2-1])\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "n, a, b = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nend_b = arr[b-1]\nstart_a = arr[b]\nif end_b < start_a:\n    print(start_a - end_b)\nelse:\n    print(0)\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "a, b = map(int, input().split())\nA = list(map(int, input().split()))\nA.append(-1)\nB = []\nZ = []\nAN = []\nx, y = A[0], A[1]\nfor i in range(a - 1):\n    Z.append((x, y))\n    if x > y:\n        B.append(y)\n        y = A[i + 2]\n    else:\n        B.append(x)\n        x, y = y, A[i + 2]\nfor i in range(b):\n    w = int(input())\n    if w <= len(Z):\n        AN.append(Z[w - 1])\n    else:\n        w = w % len(B)\n        AN.append((x, B[w - 1]))\nfor W in AN:\n    print(*W)", "complexity": "linear", "problem": "1180_C", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "import sys\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\ninput = sys.stdin.readline\n\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nif a[-1] == 1: ans = a[:-1] + [2]\nelse: ans = [1] + a[:-1]\nprint(*ans)\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "from copy import *\nn,T=map(int,raw_input().split())\ncl=set(())\ndi={(0,0,0,T):1}\nfor k in range(n):\n    t,g=map(int,raw_input().split())\n    an=deepcopy(di)\n    for k in an:\n        nc=list(k)\n        nc[3]-=t\n        nc[g-1]+=1\n        if nc[3]>=0:\n            nc=tuple(nc)\n            if nc in di:\n                di[nc] += an[k]\n            else:\n                di[nc] = an[k]\nnd={(1,0,0,0):1,(0,1,0,1):1,(0,0,1,2):1}\nmo=10**9+7\ndef nb(tu):\n    #print(tu)\n    if not(tu in nd):\n        if tu[tu[3]]==0:\n            nd[tu] =0\n        else:\n            nt=list(tu)\n            nt[tu[3]]-=1\n            nt[3]=(nt[3]+1)%3\n            nt2=nt[:]\n            nt2[3]=(nt2[3]+1)%3\n            nd[tu]=(tu[tu[3]]*(nb(tuple(nt))+nb(tuple(nt2))))%mo\n    return nd[tu]\n\n#print([(di[k],k[:3]) for k in di if k[3]==0])\nprint(sum(di[k]*(nb(k[:3]+(1,))+nb(k[:3]+(0,))+nb(k[:3]+(2,))) for k in di if k[3]==0)%mo)\n#print(nd)\n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import math\n\nn, r = map(int, input().split())\nx = list(map(int, input().split()))\ny = [r]\n\nfor i in range(1, n):\n    _y = r\n    for j in range(i):\n        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):\n            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))\n    y.append(_y)\n\nprint(' '.join(map(str, y)))\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "from math import factorial\n\n\ndef lol(n):\n    if n == 1:\n        yield [0]\n        yield [1]\n    else:\n        for p in lol(n - 1):\n            p.append(0)\n            yield p\n            p[-1] = 1\n            yield p\n            p.pop()\n\n\ndef sp(g1, g2, g3, f):\n    if g1 == 0:\n        if g2 == g3:\n            return 2\n        elif abs(g2 - g3) == 1:\n            return 1\n        else:\n            return 0\n    elif g2 == 0:\n        if g1 == g3:\n            return 2\n        elif abs(g1 - g3) == 1:\n            return 1\n        else:\n            return 0\n    elif g3 == 0:\n        if g2 == g1:\n            return 2\n        elif abs(g2 - g1) == 1:\n            return 1\n        else:\n            return 0\n    else:\n        if f == 1:\n            b = sp(g1, g2 - 1, g3, 2)\n            c = sp(g1, g2, g3 - 1, 3)\n            return b + c\n        elif f == 2:\n            a = sp(g1 - 1, g2, g3, 1)\n            c = sp(g1, g2, g3 - 1, 3)\n            return a + c\n        elif f == 3:\n            a = sp(g1 - 1, g2, g3, 1)\n            b = sp(g1, g2 - 1, g3, 2)\n            return a + b\n        else:\n            a = sp(g1 - 1, g2, g3, 1)\n            b = sp(g1, g2 - 1, g3, 2)\n            c = sp(g1, g2, g3 - 1, 3)\n            return a + b + c\n\n\nn, T = map(int, input().split())\nS = []\ncnt = 0\nM = 10 ** 9 + 7\nfor i in range(n):\n    S.append(list(map(int, input().split())))\nfor p in lol(n):\n    d = 0\n    g1, g2, g3 = 0, 0, 0\n    for i in range(n):\n        if p[i]:\n            d += S[i][0]\n            if S[i][1] == 1:\n                g1 += 1\n            elif S[i][1] == 2:\n                g2 += 1\n            elif S[i][1] == 3:\n                g3 += 1\n    if d == T:\n        cnt += factorial(g1) * factorial(g2) * factorial(g3) * sp(g1, g2, g3, 0)\n        cnt %= M\nprint(cnt)", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import sys\ninput=sys.stdin.readline\ns=list(input().rstrip())\nn=len(s)\ns.extend(s)\ncnt=0\nc=1\nfor i in range(len(s)-1):\n  if s[i]!=s[i+1]:\n    c+=1\n  else:\n    cnt=max(c,cnt)\n    c=1\ncnt=max(cnt,c)\nprint(min(cnt,n))", "complexity": "linear", "problem": "1025_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "import sys\ninput = sys.stdin.readline\n\nrr, gg, bb = map(int, input().split())\ninf = 114514\nr = list(map(int, input().split())) + [inf]\ng = list(map(int, input().split())) + [inf]\nb = list(map(int, input().split())) + [inf]\nr.sort(reverse = True)\ng.sort(reverse = True)\nb.sort(reverse = True)\ndp = []\nfor _ in range(rr + 1):\n    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])\nans = 0\nfor i in range(rr + 1):\n    ri = r[i]\n    for j in range(gg + 1):\n        gj = g[j]\n        for k in range(bb + 1):\n            bk = b[k]\n            if (i + j + k) % 2:\n                continue\n            dpijk = 0\n            if i > 0 and j > 0:\n                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)\n            if j > 0 and k > 0:\n                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)\n            if k > 0 and i > 0:\n                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)\n            dp[i][j][k] = dpijk\n            if ans < dpijk:\n                ans = dpijk\nprint(ans)", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn,m,k=map(int,input().split())\nYOKO=[list(map(int,input().split())) for i in range(n)]\nTATE=[list(map(int,input().split())) for i in range(n-1)]\n\nif k%2==1:\n    for i in range(n):\n        print(*[-1]*m)\n    exit()\n\nDP=[[0]*m for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n\n        MIN=1<<30\n\n        if j-1>=0:\n            MIN=min(MIN,YOKO[i][j-1]*2)\n        if j<m-1:\n            MIN=min(MIN,YOKO[i][j]*2)\n\n        if i-1>=0:\n            MIN=min(MIN,TATE[i-1][j]*2)\n        if i<n-1:\n            MIN=min(MIN,TATE[i][j]*2)\n\n        DP[i][j]=MIN\n\nDP0=DP[:]\n#print(DP)\n\nfor tests in range(k//2-1):\n    NDP=[[0]*m for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            MIN=DP[i][j]+DP0[i][j]\n\n            if 0<=i+1<n:\n                MIN=min(MIN,TATE[i][j]*2+DP[i+1][j])\n\n            if 0<=i-1<n:\n                MIN=min(MIN,TATE[i-1][j]*2+DP[i-1][j])\n\n            if 0<=j+1<m:\n                MIN=min(MIN,YOKO[i][j]*2+DP[i][j+1])\n\n            if 0<=j-1<m:\n                MIN=min(MIN,YOKO[i][j-1]*2+DP[i][j-1])\n\n            NDP[i][j]=MIN\n    DP=NDP\n\nfor dp in DP:\n    print(*dp)\n        \n\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "def check(x,n,k):\n    ate = x\n    rem = n-ate\n    #print(rem,ate)\n    if rem*(rem+1)//2 == k+ate and rem >= 0 and ate >= 0:\n        return True\n\n    return False\n\ndef main():\n    n,k = map(int,input().split())\n    b = -1*(2*n+3)\n    a = 1\n    c = n**2\n    c += n-(2*k)\n\n    d = ((b**2)-(4*a*c))**0.5\n    x1 = (-b+d)/2*a\n    x2 = (-b-d)/2*a\n    #print(x1,x2)\n    if check(x1,n,k):\n        print(int(x1))\n        return\n\n    print(int(x2))\n    \n\nmain()\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "def main():\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    array = []\n    array.append(a)\n\n    for i in range(n - 1):\n        aux = []\n        for j in range(1, len(array[-1])):\n            xor = (array[-1][j-1] ^ array[-1][j])\n            aux.append(xor)\n        array.append(aux)\n\n    for j in range(1, len(array)):\n        for k in range(len(array[j])):\n            maximo = max(array[j][k], array[j-1][k], array[j-1][k+1])\n            array[j][k] = maximo\n\n    q = int(input())\n    aux2 = []\n\n    for i in range(q):\n        l, r = map(int, input().split(' '))\n        aux2.append((l, r))\n\n    for i in aux2:\n        l, r = i[0], i[1]\n        print(str(array[r-l][l-1]))\n\nmain()", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "n, s = map(int, input().split())\nl = [0 for i in range(n)]\nfor i in range(n-1):\n\ta, b = map(int, input().split())\n\tl[a-1]+=1\n\tl[b-1]+=1\ncount = 0\nfor i in range(n):\n\tif(l[i]==1):\n\t\tcount+=1\nprint((s/count)*2)", "complexity": "linear", "problem": "1086_B", "from": "CODEFORCES", "tags": "greedy,implementation,trees"}
{"src": "\nfrom sys import stdin\ninput = stdin.buffer.readline\n\nn,m=map(int,input().split())\narr=[int(x) for x in input().split()]\n\ndp=[[] for i in range(m)]\nfor i in range(n):\n    dp[arr[i]%m].append(i)\n\nres=0\nk=n//m\nans=arr.copy()\ns=[]\nfor t in range(2):\n    for i in range(m):\n        if len(dp[i])<k:\n            while len(s)!=0 and len(dp[i])<k:\n                x=s.pop()\n                y=arr[x]%m\n                if i>y:\n                    ans[x]=ans[x]+(i-y)\n                    res=res+(i-y)\n                else:\n                    ans[x]=ans[x]+(m-1-y)+(i+1)\n                    res=res+(m-1-y)+(i+1)    \n                dp[i].append(\"xxx\")\n        if len(dp[i])>k:\n            while len(dp[i])>k:\n                s.append(dp[i].pop())   \n\nprint(res)\nprint(*ans)", "complexity": "linear", "problem": "0999_D", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nidx = list(range(n))\nidx.sort(key=lambda i: a[i], reverse=True)\nimin = imax = idx[0]\nfor i in idx[1:]:\n    if i == imin - 1 or i == imax + 1:\n        imin = min(imin, i)\n        imax = max(imax, i)\n    else:\n        print('NO')\n        exit(0)\nprint('YES')\n", "complexity": "nlogn", "problem": "1197_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "n,k=map(int,input().split())\nsame=[0]*(k+1)\ndiff=[0]*(k+1)\nsame[1]=2\nif k>1:\n    diff[2]=2\nfor i in range(n-1):\n    newsame=[0]*(k+1)\n    newdiff=[0]*(k+1)\n    for i in range(1,k+1):\n        newsame[i]=(same[i]+same[i-1]+2*diff[i])%998244353\n    for i in range(2,k+1):\n        newdiff[i]=(2*same[i-1]+diff[i]+diff[i-2])%998244353\n    same=newsame\n    diff=newdiff\nprint((same[-1]+diff[-1])%998244353)", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import sys\n\nsys.setrecursionlimit(10**5)\nint1 = lambda x: int(x)-1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.buffer.readline())\ndef MI(): return map(int, sys.stdin.buffer.readline().split())\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef BI(): return sys.stdin.buffer.readline().rstrip()\ndef SI(): return sys.stdin.buffer.readline().rstrip().decode()\ninf = 10**16\nmd = 10**9+7\n# md = 998244353\n\na,b=MI()\nx,y,z=MI()\nyel=x*2+y\nbul=y+z*3\nprint(max(0,yel-a)+max(0,bul-b))\n", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "x = int(input())\nlist1 = []\nfor i in range(x):\n    value = input()\n    list1.append(value)\n\nfor i in range(x):\n    value = input()\n    if value in list1:\n        list1.remove(value)\n\nprint(len(list1))\n\n", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "n = int(input())\n\ndef prefix_sums(A):\n    n = len(A)\n    P = [0] * n\n    P[0] = A[0]\n    for k in range(1, n):\n        P[k] = int((P[k - 1] + A[k]) % (1e9+7))\n    return P\n\narr = [[0] * n for _ in range(n)]\n    \n\ns = ''\nfor i in range(n):\n    inst = input()\n    s += inst\n\n    \ndef find_ans():\n    idx = 0\n    for i in range(len(arr)-1):    \n        arr[0][0] = 1\n\n        if s[i] == 'f':            \n            for j in range(0, len(arr)):    \n                arr[i+1][0] = 0\n                if j > 0:\n                    arr[i+1][j] = arr[i][j-1]\n                    idx = i+1\n\n        else:\n            val = 0\n            arr[i+1] = prefix_sums(arr[i][::-1])[::-1]\n    return arr\n\nif n == 1 or 'f' not in s:\n    if s[0] == 's':\n        print(1)\n    else:\n        print(int(sum(find_ans()[-1]) % (1e9+7)))\nelse:\n    print(int(sum(find_ans()[-1]) % (1e9+7)))\n                ", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "n=int(input())\na=list(map(int,input().split()))\na.sort()\n# print(a)\ntotal_money=sum(a)\ni_have=0\nreaming=total_money-i_have\ncnt=0\nfor i in range(n-1,-1,-1):\n    reaming=total_money-i_have\n    if i_have>reaming:\n        break\n    i_have+=a[i]\n    cnt+=1\nprint(cnt)", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import os, sys\nfrom io import BytesIO, IOBase\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: list(map(dtype, input().split()))\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\nvalid = lambda x, y: -1 < x < n and -1 < y < m\ndx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)\n\nn, m, k = inp(int)\nif k & 1:\n    [print(*([-1] * m)) for _ in range(n)]\n    exit()\n\nright, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]\nmem = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]\n\nfor _ in range(n):\n    for i, j in enumerate(inp(int)):\n        right[_][i] = j\n\nfor _ in range(n - 1):\n    for i, j in enumerate(inp(int)):\n        down[_][i] = j\n\nfor i in range(n):\n    for j in range(m):\n        mem[i][j] = 0\n\nfor k1 in range(1, k // 2 + 1):\n    mem0 = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            mem0[i][j] = min(mem[i - 1][j] + down[i - 1][j], mem[i + 1][j] + down[i][j],\n                             mem[i][j - 1] + right[i][j - 1], mem[i][j + 1] + right[i][j])\n\n    mem = mem0\n\n[print(*[mem[i][x] * 2 for x in range(m)]) for i in range(n)]\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import os\nimport sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    n,m,k = map(int,input().split())\n    a = list(map(float,input().split()))\n    tree = [[0]*n for _ in range(n)]\n    for i in range(k):\n        x,y,z = map(int,input().split())\n        tree[x-1][y-1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1]*2)\n    dp = [[0]*(po[-1]*2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = a[i]\n    for i in range(po[-1]*2):\n        for j in range(n):\n            if i&po[j]:\n                for k in range(n):\n                    if not (i&po[k]):\n                        dp[k][i+po[k]] = max(dp[k][i+po[k]],dp[j][i]+a[k]+tree[j][k])\n    ma = 0\n    for i in range(po[-1]*2):\n        if bin(i)[2:].count(\"1\") == m:\n            for j in range(n):\n                ma = max(ma,dp[j][i])\n    print(int(ma))\n\n# region fastio\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self,file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            self.newlines = b.count(b\"\\n\")+(not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd,self.buffer.getvalue())\n            self.buffer.truncate(0),self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self,file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s:self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda:self.buffer.read().decode(\"ascii\")\n        self.readline = lambda:self.buffer.readline().decode(\"ascii\")\n\nsys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)\ninput = lambda:sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "np", "problem": "0580_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "from math import log\nimport random\nspaces = (\" \",\"\\n\",\"\\t\")\nstops = (\"\",\" \",\"\\n\",\"\\t\")\nextendedPoints = set()\nstartingPoints = set()\ninterestPoints = []\n\nclass TPoint:\n\tdef __init__(self,x,y):\n\t\tself.x=x\n\t\tself.y=y\n\tdef __str__(self):\n\t\treturn \"(\"+str(self.x)+\",\"+str(self.y)+\")\"\n\tdef __eq__(self, other): \n\t\treturn self.x == other.x and self.y == other.y\n\tdef __hash__(self):\n\t\treturn self.x*20000 + self.y\n\tx=0\n\ty=0\n\th=0\t\ndef sortKey(p):\n\treturn p.h\ndef heuristic(p, otherPoints):\n\tminH = float(\"inf\")\n\tfor point in otherPoints:\n\t\tcurrentH = abs(point.x - p.x) + abs(point.y - p.y)\n\t\tif currentH < minH:\n\t\t\tminH = currentH\n\treturn minH\n\ndef addPoint(p,pointList):\n\tif not p in extendedPoints:\n\t\tp.h = heuristic(p,startingPoints)\n\t\textendedPoints.add(p)\n\t\tpointList.append(p)\n\t\t#print(p.x,p.y,p.h)\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef extend(point,n,m,poinList):\n\tok = False\n\tif point.x>1:\n\t\tok = addPoint(TPoint(point.x-1,point.y),poinList) or ok\n\t\tif point.y>1:\n\t\t\tok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok\n\t\tif point.y<m:\n\t\t\tok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok\n\tif point.x<n:\n\t\tok = addPoint(TPoint(point.x+1,point.y),poinList) or ok\n\t\tif point.y>1:\n\t\t\tok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok\n\t\tif point.y<m:\n\t\t\tok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok\n\tif point.y>1:\n\t\tok = addPoint(TPoint(point.x,point.y-1),poinList) or ok\n\tif point.y<m:\n\t\tok = addPoint(TPoint(point.x,point.y+1),poinList) or ok\n\n\treturn ok\n\ndef ReadNext(fileObject):\n\tcurrentBuffer = \"\"\n\tcurrentRead=fileObject.read(1)\n\twhile currentRead in spaces:\n\t\tcurrentRead=fileObject.read(1)\n\tcurrentBuffer = currentBuffer + currentRead\n\twhile not currentRead in stops:\n\t\tcurrentRead=fileObject.read(1)\n\t\tcurrentBuffer = currentBuffer + currentRead\n\treturn currentBuffer.strip()\n\nw, r= open('output.txt', 'w'), open('input.txt', 'r')\n\nn = int(ReadNext(r))\nm = int(ReadNext(r))\nk = int(ReadNext(r))\nmscale = 5\n\nfor i in range(k):\n\tx = int(ReadNext(r))\n\ty = int(ReadNext(r))\n\tp = TPoint(x,y)\n\tstartingPoints.add(p)\n\textendedPoints.add(p)\n\ntmpPoints = []\ntmpPoints.append(TPoint(1,1))\ntmpPoints.append(TPoint(1,m))\ntmpPoints.append(TPoint(n,1))\ntmpPoints.append(TPoint(n,m))\nif n>2 and m>2:\n\ttmpPoints.append(TPoint(int(n/2),1))\n\ttmpPoints.append(TPoint(1,int(m/2)))\n\ttmpPoints.append(TPoint(int(n/2),m))\n\ttmpPoints.append(TPoint(n,int(m/2)))\n\ttmpPoints.append(TPoint(int(n/2),int(m/2)))\n\nfor p in tmpPoints:\n\taddPoint(p,interestPoints)\n\t#extend(p,n,m,interestPoints)\nfor p in startingPoints:\n\textend(p,n,m,interestPoints)\n\ninterestPoints.sort(reverse=True, key=sortKey)\nwhile len(interestPoints) > 3*mscale:\n\tinterestPoints.pop(len(interestPoints)-1)\n\nrandom.seed()\n\nif(len(interestPoints)>0):\n\tmaxPoint = interestPoints[0]\n\tfor p in interestPoints:\n\t\tcurrentBeam = [p]\n\t\tcanExtend = True\n\t\twhile canExtend:\n\t\t\taddPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)\n\t\t\tcanExtend = False\n\t\t\tfor i in range(len(currentBeam)):\n\t\t\t\tif extend(currentBeam[i],n,m,currentBeam):\n\t\t\t\t\tcanExtend = True\n\t\t\tcurrentBeam.sort(reverse=True, key=sortKey)\n\t\t\twhile len(currentBeam) > mscale:\n\t\t\t\tcurrentBeam.pop(len(currentBeam)-1)\n\t\tif currentBeam[0].h>maxPoint.h:\n\t\t\tmaxPoint = currentBeam[0]\n\t#print(maxPoint.x,maxPoint.y)\n\t#print(str(len(extendedPoints)))\n\tw.write(str(maxPoint.x)+\" \"+str(maxPoint.y)+\"\\n\")\nelse:\n\tw.write(str(n)+\" \"+str(m)+\"\\n\")\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "n,k=map(int,input().split())\na=list(map(int,input().split()))\nb=list(a)\nb.sort()\nc=[]\nsum=0\nfor i in range(1,k+1):\n\tc.append(b[-i])\n\tsum+=b[-i]\nprint(sum)\nd=[]\nfor i in range(n):\n\tif a[i] in c:\n\t\td.append(i)\n\t\tc.remove(a[i])\n\telse:\n\t\tpass\nd.insert(0,-1)\nd[-1]=n-1\ne=[]\nfor i in range(1,len(d)):\n    e.append(d[i]-d[i-1])\nprint(\" \".join(map(str,e)))", "complexity": "nlogn", "problem": "1006_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "from bisect import insort,bisect_right,bisect_left\nfrom sys import stdout, stdin, setrecursionlimit\nfrom heapq import heappush, heappop, heapify \nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import * \nfrom string import *\nfrom queue import *\nfrom math import *\nfrom re import *\nfrom os import *\n\n# sqrt,ceil,floor,factorial,gcd,log2,log10,comb\n\n####################################---fast-input-output----#########################################\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ngraph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())\ndef getStr(): return input()\ndef getInt(): return int(input())\ndef listStr(): return list(input())\ndef getStrs(): return input().split()\ndef isInt(s): return '0' <= s[0] <= '9'\ndef input(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in input().split()]\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))\n\n\ndef getPrimes(N = 10**5):\n    SN = int(sqrt(N))\n    sieve = [i for i in range(N+1)]\n    sieve[1] = 0\n    for i in sieve:\n        if i > SN:\n            break\n        if i == 0:\n            continue\n        for j in range(2*i, N+1, i):\n            sieve[j] = 0\n    prime = [i for i in range(N+1) if sieve[i] != 0] \n    return prime\ndef primeFactor(n,prime=getPrimes()):\n    lst = []\n    mx=int(sqrt(n))+1\n    for i in prime:\n        if i>mx:break\n        while n%i==0:\n            lst.append(i)\n            n//=i\n    if n>1:\n        lst.append(n)\n    return lst    \n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\ndaysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n\n#################################################---Some Rule For Me To Follow---#################################\n\"\"\"\n    --instants of Reading problem continuously try to understand them.\n\n    --Try & again try, maybe you're just one statement away!\n\n\"\"\"\n##################################################---START-CODING---###############################################\n\n\na = getInt()\nb = getInt()\n\n\narr = list(str(a))\n\narr = sorted(arr)\nans=''\n\nwhile arr:\n    for i in range(len(arr)-1,-1,-1):\n        x=ans+arr[i]\n\n        for j in arr[:i]:\n            x+=j\n        for j in arr[i+1:]:\n            x+=j\n        if int(x)<=b:\n            ans+=arr[i]\n            arr.pop(i)\n            break\n\nprint(ans)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "mod=1000000007\ndef fastexp(base,exp):\n    if(exp==0):\n        return 1;\n    if(exp==1):\n        return base%mod;\n    t=fastexp(base,exp//2);\n    if(exp%2==0):\n        return (t%mod*t%mod)%mod;\n    else:\n        return (t%mod*t%mod*base%mod)%mod;\nx,k=map(int,input().split())\nif(x==0):\n    print(0);\nelse:\n    t=fastexp(2,k)%mod;\n    before=((2*t)%mod*x%mod)%mod-(t+mod-1)%mod\n    while(before<0):\n        before+=mod;\n    before=before%mod;\n    print(before)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "def f(k):\n    res = 1\n    a = 2\n    while k:\n        if k % 2 == 1:\n            res *= a\n            k -= 1\n        else:\n            a *= a\n            k //= 2\n        res = res % (1000000007)\n        a = a % (1000000007)\n    return res\n\n\nn, k = map(int, input().split())\nif n == 0:\n    print(0)\nelif k == 0:\n    print((n * 2) % 1000000007)\nelse:\n    first = (2 * n - 1) % 1000000007\n    first *= f(k)\n    first = (first + 1) % 1000000007\n    print(first)\n\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nwhile len(a) > 0:\n    k = a.pop(0)\n    a = [i for i in a if i % k != 0]\n    ans += 1\n\nprint(ans)\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "def MI():\n    return map(int,input().split())\ndef I():\n    return int(input())\ndef LI():\n    return [int(i) for i in input().split()]\n\nn,k=MI()\n\nb=-(2*n+3)\nc=n*n+n-2*k\nx=(-b-((b*b-4*c)**0.5))//2\ny=(-b+((b*b-4*c)**0.5))//2\nx,y=int(x),int(y)\nfor i in [x-1,x,x+1,y-1,y,y+1]:\n    if i**2+b*i+c==0 and 0<=i<=n-1:\n        print(i)\n        break", "complexity": "constant", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import sys\n\ndef main():\n\n    n,k=map(int,sys.stdin.readline().strip().split())\n    arr=list(map(int,sys.stdin.readline().strip().split()))\n    arr.sort(reverse=True)\n    dic={}\n    for a in arr:\n        if a*k not in dic:\n            dic[a]=1\n    \n    print(len(dic))\n\nmain()", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "n = int(input())\ns = list(input())\nt = list(input())\n\nif sorted(t) == sorted(s):\n    ans = []\n    for i in range(n-1, -1, -1):\n        if t[i] != s[i]:\n            j = s.index(t[i])\n            for k in range(j, i):\n                s[k], s[k+1] = s[k+1], s[k]\n                ans.append(str(k+1))\n    print(len(ans))\n    print(' '.join(ans))\nelse:\n    print(-1)\n", "complexity": "quadratic", "problem": "1015_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n, a, b = [int(i) for i in input().split()]\nlst = sorted([int(i) for i in input().split()])\nprint(lst[b]-lst[b-1])\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "n = int(input())-1\nx = 1\ny = 9\nwhile n > x * y:\n    n -= x * y\n    y *= 10\n    x += 1\na = 10 ** (x - 1)\na += n // x\nprint(str(a)[n % x])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "n = int(input())\na = list(map(int, input().split()))\n\ns = 0\ncount = dict()\nfor x in a:\n\tcount[x] = count.get(x, 0) + 1\n\ts += x\n\nanswer = 0\nfor i in range(n):\n\ttrash = 0\n\ttrash += count.get(a[i] - 1, 0) * (a[i] - 1)\n\ttrash += count.get(a[i]) * a[i]\n\ttrash += count.get(a[i] + 1, 0) * (a[i] + 1)\t\n\n\txcount = n - i\n\txcount -= count.get(a[i] - 1, 0)\n\txcount -= count.get(a[i], 0)\n\txcount -= count.get(a[i] + 1, 0)\n\n\tanswer += (s - trash) - (xcount * a[i])\n\t\n\tcount[a[i]] -= 1\n\ts -= a[i]\n\nprint(answer)", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "n,m,a,b=map(int,input().split())\nz=(n%m)*b\nx=((n//m+1)*m-n)*a\ny=min(z,x)\nprint(y if y>0 else 0)", "complexity": "linear", "problem": "0990_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "\nr,g,b = map(int,input().split())\nl1 = list(map(int,input().split()))\nl2 = list(map(int,input().split()))\nl3 = list(map(int,input().split()))\nl1.sort(reverse=True)\nl2.sort(reverse=True)\nl3.sort(reverse=True)\ndp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]\nans = 0\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            if i == 0 and j == 0:\n                dp[i][j][k] = 0\n            if j == 0 and k == 0:\n                dp[i][j][k] = 0\n            if i == 0 and k == 0:\n                dp[i][j][k] = 0\n            if i>0 and j>0 and k>0:\n                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])\n            else:\n                if i>0 and j>0:\n                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]\n                elif i>0 and k>0:\n                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]\n                elif j>0 and k>0:\n                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]\n            ans = max(ans,dp[i][j][k])\n                    \nprint(ans)\n                                   \n                \n            \n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import math\ndef nCr(n,r):\n\tf = math.factorial\n\treturn f(n) / f(r) / f(n-r)\ndict1 = {'+':0,'-':0,'?':0}\nfor i in input():\n\tdict1[i]+=1\nfor i in input():\n\tif(i=='?'):\n\t\tdict1[i]+=1\n\telse:\n\t\tdict1[i]-=1\nif dict1['+']<0 or dict1['-']<0:\n\tprint(0.000000000000)\nelif dict1['+']==0 and dict1['-']==0:\n\tprint(1.000000000000)\nelif dict1['+'] and dict1['-']:\n\tans = (nCr(dict1['?'], dict1['+'])/(2**dict1['?']))\n\tprint(\"%.12f\" %ans)\nelse:\n\tans = (1 / (2 ** dict1['?']))\n\tprint(\"%.12f\" % ans)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Dec 14 13:18:46 2020\n\n@author: yash\n\"\"\"\n\"\"\"\n __  __ _                   \n|  \\/  (_)_ __ ___  _ __    \n| |\\/| | | '__/ _ \\| '_ \\  \n| |  | | | | | (_) | | | | \n|_|  |_|_|_|  \\___/|_| |_|  \n\"\"\"\n\"\"\"\n \n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u258c\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u25d0\u25d0\u25d0\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580\u2580\u2580\u2580\ud83d\udd25\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u258c\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u258c\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2584\u2588\u2588\u2588\u2588\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u25d0\u25d0\u25d0\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580\u2580\u2580\u2580\ud83d\udd25\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\"\"\"\n\"\"\"\n \n \n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@#@@#@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##@M@M # #@@@M@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@#@@ @@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@### #@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@B@@#@@@@@#M@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@##@@M@#@@##@##@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#M@@@@@##@M@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##@@@@@@#@##@#@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#  @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@  #\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @# @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @# @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@  #\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#  @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@ @@#@@#@@@@@@@@@@@@@@@@@#@@#@#@@@@@@@@@@@@@@@@@@@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@\n @ #@@@@@@@@@@@@@@@@@@@@#@@@@@@#@@@@@@@@@@@@@@@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@ @@#@#@@@@@@@@@@@@@@@@@@#@####@@@@@@@@@@@@@@@@@M@#@@#@#@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@#@#M@@@M@@@@@@@@@@@@@@@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n#@M@#@#@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@M@@M@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@#@@#@@@@@@@@@@@@@@@@@@@@M@M@#@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@\n@@#@@#@@@@@@@@@@@@@@@@@@@@@@@M@                   @M@@#@@@@@@@@@@@@@@@@@@@@@@@@@\n@#@@@@@#@@@@@@@@@@@@@@@@@@@#@@                     @@@@M@@@@@@@@@@@@@@@@@@@@@@@@\n@@@#@@@##@@@#@@@@@#@@@@@##@@@@                     #@#@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@####@@####@@@@#@@@@M@@@#@@#                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@#@          @#@@#@@@       #@             @       #@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                            @#           @@#@@     #@@#@@@@@@@@@@@@@@@@@@@@@@@@@\n                     ##@#@@ #M           @# @@     @@M  @@@@@@@@@@@@@@@@@@@@@@@@\n                     @#@@@M #@           #@   #    @@   @@@@@@@@@@@@@@@@@@@@@@@@\n                      @@ @@#@@           ##    @##@@    @@@@@@@@@@@@@@@@@@@@@@@@\n                      @#  @@M@           @@             @@@@@@@@@@@@@@@@@@@@@@@@\n    @@@##@@@          @@@@ @@@          @@               #@#@@#@@@@@@@@@@@@@@@@@\n@@@@###@@###@@@@#@#@@@@#@@@ M@          #@    @       B  @@@#@@@@@@@@@@@@@@@@@@@\n@M@@@@@MM@@@@@M@@#@##@@@#@@M@B          @#   M@   @# #@  #@@#@@@@@@@@@@@@@@@@@@@\n@#@#@@M@@M@@#@#@#@#@@#@#@#@@@@          @#   @@   #  @M  @#@@@@@@@@@@@@@@@@@@@@@\n@@@          @@@@#@##@     #@#          @M    #  @   @   @@@@@#@@@@@@@@@@@@@@@@@\n                            @@          @@   @#@@#@@#M   #@@@@#@@@@@@@@@@@@@@@@@\n                           M@#           #@   @@@@##@@ @M@#M@@@#@@@@@@@@@@@@@@@@\n                           @@@@           @@          @@@#@@@#@#@@@@@@@@@@@@@@@@\n                          @#  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                          @@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n   @M@H@@  @#        @#@@@@#@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@#@#@##@M@@@M@ @M#@@@@@#@@#@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n#M@@@##@@@@@@@@M@@@@#@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@#@@@@@M@#@M@@B#M@@M@###@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n###@@@@@@@@@# @#@@@@@@@#@@@#@##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@#@@M@@@#@@#@#@@@@@@#@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@M@#@# \n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@#\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@##\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@M\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n \n \n\"\"\"\n\"\"\"\n                          / \\  //\\\n            |\\___/|      /   \\//  \\\\\n            /0  0  \\__  /    //  | \\ \\    \n           /     /  \\/_/    //   |  \\  \\  \n           @_^_@'/   \\/_   //    |   \\   \\ \n           //_^_/     \\/_ //     |    \\    \\\n        ( //) |        \\///      |     \\     \\\n      ( / /) _|_ /   )  //       |      \\     _\\\n    ( // /) '/,_ _ _/  ( ; -.    |    _ _\\.-~        .-~~~^-.\n  (( / / )) ,-{        _      `-.|.-~-.           .~         `.\n (( // / ))  '/\\      /                 ~-. _ .-~      .-~^-.  \\\n (( /// ))      `.   {            }                   /      \\  \\\n  (( / ))     .----~-.\\        \\-'                 .~         \\  `. \\^-.\n             ///.----..>        \\             _ -~             `.  ^-`  ^-_\n               ///-._ _ _ _ _ _ _}^ - - - - ~                     ~-- ,.-~\n                                                                  /.-~\n \n\"\"\"\n\"\"\"\n  ____          _      _____                       \n / ___|___   __| | ___|  ___|__  _ __ ___ ___  ___ \n| |   / _ \\ / _` |/ _ \\ |_ / _ \\| '__/ __/ _ \\/ __|\n| |__| (_) | (_| |  __/  _| (_) | | | (_|  __/\\__ \\\n \\____\\___/ \\__,_|\\___|_|  \\___/|_|  \\___\\___||___/\n\"\"\"\n\"\"\"\n\u2591\u2591\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\n\u2591\u2584\u2580\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2591\u2588\u2591\n\u2591\u2588\u2591\u2584\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2584\u2591\u2588\u2591\n\u2591\u2588\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2588\u2591\n\u2591\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2591\n\u2584\u2588\u2580\u2588\u2580\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2580\u2580\u2588\u2588\u2588\n\u2588\u2588\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2588\u2588\n\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2580\u2591\u2591\u2591\u2591\u2580\u2588\u2591\u2591\u2591\u2591\u2588\u2588\n\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\u2588\n\u2591\u2580\u2588\u2588\u2588\u2584\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2588\u2588\u2588\u2580\u2591\n\u2591\u2591\u2591\u2580\u2588\u2588\u2584\u2591\u2580\u2588\u2588\u2580\u2591\u2584\u2588\u2588\u2580\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\"\"\"\n\"\"\"\u2591\u2591\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\n\u2591\u2584\u2580\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2591\u2588\u2591\n\u2591\u2588\u2591\u2584\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2584\u2591\u2588\u2591\n\u2591\u2588\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2588\u2591\n\u2591\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2591\n\u2584\u2588\u2580\u2588\u2580\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2580\u2580\u2588\u2588\u2588\n\u2588\u2588\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2588\u2588\n\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2580\u2591\u2591\u2591\u2591\u2580\u2588\u2591\u2591\u2591\u2591\u2588\u2588\n\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\u2588\n\u2591\u2580\u2588\u2588\u2588\u2584\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2588\u2588\u2588\u2580\u2591\n\u2591\u2591\u2591\u2580\u2588\u2588\u2584\u2591\u2580\u2588\u2588\u2580\u2591\u2584\u2588\u2588\u2580\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\"\"\"\n\"\"\"\n# Codeforces Round #186 (Div. 2), problem: (A) Ilya and Bank Account\n\n    n = int(input())\n    if n > 0:\n        print(n)\n    else:\n        s = str(n)\n        if s[len(s)-1] < s[len(s)-2] and s[len(s)-2] != '0':\n            print(int(s[:len(s)-2] + s[len(s)-1:]))\n        elif s[len(s)-1] > s[len(s)-2] and s[len(s)-1] != '0':\n            print(int(s[:len(s)-1]))\n        else:\n            print(int(s[:len(s)-1]))\n\"\"\"\n\n\n\"\"\"\n# Codeforces Round #261 (Div. 2), problem: (A) Pashmak and Garden,\n\nx1, y1, x2, y2=map(int,input().split())\nl=abs(x1-x2)\nm=abs(y1-y2)\nif x1==x2:\n    print(x1+m,y1,x2+m,y2)\nelif y1==y2:\n    print(x1,y1+l,x2,y2+l)\nelif l!=m: \n    print(-1)\nelse: \n    print(x1,y2,x2,y1)\n\"\"\"\n\n\n\"\"\"\n# Codeforces Round #142 (Div. 2), problem: (A) Dragons\n\ndef solve():\n    s, n = map(int, input().split())\n    sets = []\n    for _ in range(n):\n        ith, bonus = map(int, input().split())\n        sets.append([ith, bonus])\n    sets.sort(key=lambda x: x[0])\n    for i in sets:  \n        if i[0] < s:\n                s += i[1]\n        else:\n            return \"NO\"\n    return \"YES\"\nprint(solve())\n\"\"\"\n\"\"\"\n# Codeforces Round #690 (Div. 3)\n\n# (A) Favorite Sequence-\n\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        ans = []\n        k = n//2\n        start = 0\n        end = len(l)-1\n        while start <= end:\n            if start != end:\n                ans.append(l[start])\n                ans.append(l[end])\n            else:\n                ans.append(l[end])\n            start += 1\n            end -= 1\n        for i in ans:\n            print(i, end=\" \")\n        print()\n\n# B) Last Year's Substring-\n\n    for _ in range(int(input())):\n        n = int(input())\n        s = input()\n        if s[0]+s[1] == '20' and s[-2]+s[-1] == '20':\n            print(\"YES\")\n        elif s[0] == '2' and s[-3]+s[-2]+s[-1] == '020':\n            print(\"YES\")\n        elif s[0]+s[1]+s[2] == '202' and s[-1] == '0':\n            print(\"YES\")\n        elif s[0]+s[1]+s[2]+s[3] == '2020':\n            print(\"YES\")\n        elif s[-4]+s[-3]+s[-2]+s[-1] == '2020':\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\"\"\"\n\"\"\"\n# Codeforces Round #251 (Div. 2)\n   \n    n, d = map(int, input().split())\n    l = list(map(int, input().split()))\n    if (sum(l) + (n-1)*10) > d:\n        print(-1)\n    else:\n        print((d-sum(l))//5)\n\"\"\"\n\"\"\"\n# Codeforces Round #290 (Div. 2)\n\nn,m=map(int,input().split())\nfor i in range(n):\n    if i % 4 == 0:\n        print('#'*m)\n    elif i % 4 == 1:\n        print('.'*(m-1)+'#')\n    elif i % 4 == 2:\n        print('#'*m)\n    else:\n        print('#'+'.'*(m-1))\n        \n        \nn,m=map(int,input().split())\nfor i in range(n):\n    print(['#'*m,'.'*(m-1)+'#','#'*m,'#'+'.'*(m-1)][i%4])\n\n\"\"\"     \n\"\"\"\n# Educational Codeforces Round 100 (Rated for Div. 2)\n\n\n# problem: (A) Dungeon\n    def solve(a, b, c):\n        s = a+b+c\n        k = s//9\n        if s % 9 == 0 and a >= k and b >=k and c >= k:\n            return \"YES\"\n        else:\n            return \"NO\"\n            \n    for _ in range(int(input())):\n        a, b, c = map(int, input().split())\n        print(solve(a, b, c)) \n\n\n# problem: (B) Find The Array\n\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        even = 0\n        odd = 0\n        for i in range(len(l)):\n            if i % 2 == 0:\n                even += l[i]\n            else:\n                odd += l[i]\n        \n        if even < odd:\n            for i in range(len(l)):\n                if i % 2 == 0:\n                    l[i] = 1\n                    print(l[i], end=\" \")\n                else:\n                    print(l[i], end=\" \")\n        else:\n             for i in range(len(l)):\n                if i % 2 == 0:\n                    print(l[i], end=\" \")\n                else:\n                    l[i] = 1\n                    print(l[i], end=\" \")\n\n\"\"\"\n\n\n\n\"\"\"\n# Codeforces Beta Round #25 (Div. 2 Only), problem: (A) IQ test\n    n = int(input())\n    nums = list(map(int, input().split()))\n    even = 0\n    odd = 0\n    counter1 = 0\n    counter2 = 0\n    for i in range(len(nums)):\n        if nums[i]%2 == 0:\n            counter1+=1\n            even = i+1\n        else:\n            counter2+=1\n            odd = i+1\n        \n    if counter1 == 1:\n        print(even)\n    else:\n        print(odd)\n\"\"\"\n\n\"\"\"\n# Codeforces Round #246 (Div. 2), problem: (A) Choosing Teams\n\n    n, k = map(int, input().split())\n    l = list(map(int, input().split()))\n    counter = 0\n    for i in range(len(l)):\n        if (5-l[i]) >= k:\n            counter += 1\n    print(counter//3)\n\"\"\"\n\n\"\"\"\n # Codeforces Round #192 (Div. 2), problem: (A)   \n    r, c = map(int, input().split())\n    a = set()\n    b = set()\n    for i in range(r):\n        d = input()\n        for j in range(len(d)):\n            if d[j] == 'S':\n                a.add(j)\n                b.add(i)\n    \n    print(r*c - len(a)*len(b))\n\"\"\"\n\n\n# n, m = map(int, input().split())\n# b = []\n# for i in range(n):\n#     if min(list(map(int, input().split()))[1:]) < m:\n#         b.append(i + 1)\n# print(len(b), '\\n', *b)\n        \n\"\"\"\n # Codeforces Round #691 (Div. 2), problem: (A) Red-Blue Shuffle,\n    for i in range(int(input())):\n        n = int(input())\n        a = input()\n        b = input()\n        counter_a = 0\n        counter_b = 0\n        for j in range(len(a)):\n            if a[j] > b[j]:\n                counter_a += 1\n            elif a[j] < b[j]:\n                counter_b += 1\n        \n        if counter_a > counter_b:\n            print(\"RED\")\n        elif counter_a < counter_b:\n            print(\"BLUE\")\n        else:\n            print(\"EQUAL\")\n    \n\"\"\"\n\"\"\"\n# Codeforces Round #263 (Div. 2), problem: (A) Appleman and Easy Task\n    x = ''\n    for _ in range(int(input())):\n        x += input()\n        \n    if x == x[::-1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\"\"\"\n\"\"\"\n # Codeforces Round #226 (Div. 2), problem: (A) Bear and Raspberry\n    n, c = map(int, input().split())\n    l = list(map(int, input().split()))\n    ans = l[0] - l[1]\n    for i in range(1, len(l)-1):\n        ans = max(ans, l[i] - l[i+1])\n    if ans - c < 0:\n        print(0)\n    else:\n        print(ans-c)\n\"\"\"\n\n# n, k = map(int, input().split())\n# joy = float(\"-inf\")\n# for _ in range(n):\n#     f, t = map(int, input().split())\n#     if t >= k:\n#         joy = max(joy, f - (t - k))\n#     else:\n#         joy =  max(joy, f)\n# print(joy)\n\n\n\"\"\"\n# Codeforces Round #260 (Div. 2), problem: (A) Laptops,   \n    for _ in range(int(input())):\n        a,b=input().split()\n        if a!=b:\n            print('Happy Alex')\n            exit()\n    print('Poor Alex')\n\"\"\"\n\"\"\"\n# Technocup 2021 - Elimination Round 3:\n    \n    problem: (A) In-game Chat\n        for _ in range(int(input())):\n            n = int(input())\n            s = input()\n            j = len(s)-1\n            count = 0\n            while j >= 0:\n                if s[j] != ')':\n                    break\n                count += 1\n                j -= 1\n        \n            if count > len(s)-count:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\"\"\"\n\n\n# def solve(x):\n#     for i in str(x):\n#         if i != '0' and x % int(i) != 0:\n#             return False\n#     return True\n     \n# t = int(input())\n# for _ in range(t):\n#     n = int(input())\n#     while not solve(n):\n#         n += 1\n#     print(n)\n    \n\"\"\"\n # Codeforces Round #222 (Div. 2), problem: (A) Playing with Dice\n    a, b = map(int, input().split())\n    a_w = 0\n    b_w = 0\n    draw = 0\n    for i in range(1, 7):\n        if abs(i-a) < abs(i-b):\n            a_w += 1\n        elif  abs(i-a) > abs(i-b):\n            b_w += 1\n        else:\n            draw += 1\n    print(a_w, draw, b_w)\n\"\"\"\n\"\"\"\n# Codeforces Round #283 (Div. 2), problem: (A) Minimum Difficulty\n    n=int(input())\n    l=list(map(int,input().split()))\n    x=max([l[i+1]-l[i] for i in range(n-1)])\n    y=min([l[i+2]-l[i] for i in range(n-2)])\n    print(max(x,y))\n\"\"\"\n\"\"\"\n # Codeforces Round #156 (Div. 2), problem: (A) Greg's Workout\n        n = int(input())\n        arr = list(map(int, input().split()))\n        chest_count = 0\n        biceps_count = 0\n        back_count = 0\n        for i in range(len(arr)):\n            if i%3 == 0:\n                chest_count += arr[i]\n            elif i%3 == 1:\n                biceps_count += arr[i]\n            elif i%3 == 2:\n                back_count += arr[i]\n            \n        ans = max(chest_count, biceps_count, back_count)\n        \n        if chest_count == ans:\n            print(\"chest\")\n        elif biceps_count == ans:\n            print(\"biceps\")\n        else:\n            print(\"back\")\n            \n               OR\n\n        input()\n        arr = [int(i) for i in input().split()]\n        b = [sum(arr[::3]), sum(arr[1::3]), sum(arr[2::3])]\n        c = ['chest', 'biceps', 'back']\n        print(c[b.index(max(b))])\n    \n\"\"\"\n\nl, r = map(int, input().split())\nif r - l + 1 < 3:\n    print(-1)\n    exit()\nif l % 2 == 0:\n    print(l, l+1, l+2)\n    exit()\nif r - l + 1 > 3:\n    print(l+1, l+2, l+3)\n    exit()\nprint(-1)\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            \n\n        \n    \n            \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n ", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "n,k=[int(x)for x in input().split()]\nns=[int(x) for x in input().split()]\ndone=[None]*256\nans=[None]*n\nfor i in range(n):\n    c=ns[i]\n    if done[c]==None:\n        j=c\n        while True:\n            if j<0 or c-j>=k or (done[j]!=None and done[j]!=-1):\n                break\n            j-=1\n        j+=1\n        for kk in range(k):\n            if kk+j>=256 or (done[kk+j]!=None and done[kk+j]!=-1):\n                break\n            if kk+j<=c:\n                done[kk+j]=j\n            else:\n                done[kk+j]=-1\n    elif done[c]==-1:\n        j=c\n        while True:\n            if done[j]!=None and done[j]!=-1:\n                break\n            j-=1\n        a=done[j]\n        for kk in range(j,c+1):\n            done[kk]=a\n    else:\n        pass\n    ans[i]=done[c]\n    # print(ans[i])\n    # print(done)\n    # if ans[i]==146:\n    #     print(ans[i])\n    #     print(done)\n    #     input()\nans=[str(x)for x in ans]\nprint(' '.join(ans))\n\n\n\n", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "import sys\ndef fastio():\n    from io import StringIO\n    from atexit import register\n    global input\n    sys.stdin = StringIO(sys.stdin.read())\n    input = lambda : sys.stdin.readline().rstrip('\\r\\n')\n    sys.stdout = StringIO()\n    register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))\nfastio()\n\ndef debug(*var, sep = ' ', end = '\\n'):\n    print(*var, file=sys.stderr, end = end, sep = sep)\n\nINF = 10**20\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\nfrom math import gcd\nfrom math import ceil\nfrom collections import defaultdict as dd, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\n\nn, l, r, x = I()\na = I()\nans = 0\nfor i in range(1, 2 ** n):\n    if i & (i - 1) == 0:\n        continue\n    mn, mx, total = INF, -INF, 0\n    for j in range(n):\n        if (i >> j) & 1:\n            mn = min(mn, a[j])\n            mx = max(mx, a[j])\n            total += a[j]\n    if l <= total <= r and mx - mn >= x:\n        ans += 1\nprint(ans)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import sys\nfrom collections import defaultdict\n# import logging\n# logging.root.setLevel(level=logging.INFO)\n\n\nexist_num,new_width = map(int,sys.stdin.readline().strip().split())\nbuildings = []\nfor _ in range(exist_num):\n    center, width = map(int,sys.stdin.readline().strip().split())\n    buildings.append((center-width/2,center+width/2))\nbuildings.sort()\npossible_loc = 2\nfor left,right in zip(buildings,buildings[1:]):\n    gap=right[0] - left[1]\n    if gap == new_width:\n        possible_loc += 1\n    elif gap > new_width:\n        possible_loc += 2\n# print(buildings)\nprint(possible_loc)\n\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Feb 15 19:45:38 2019\n\n@author: avina\n\"\"\"\n\nn = int(input())\n\nl = []\nfor _ in range(n):\n    k,m = map(int, input().strip().split())\n    l.append((k,m))\n\nl.sort(key=lambda x:x[0]+x[1])\n\nlast = 0\nans = 1\n\nfor i in range(1,n):\n   if  abs(l[i][0] - l[last][0]) >= l[i][1] + l[last][1] :\n       last = i\n       ans = ans + 1\n       \nprint(ans)\n\n#l[i][0] - l[i][1] >= l[last][0] - l[last][1] and", "complexity": "nlogn", "problem": "0528_B", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n,m=map(int,input().split())\na=[int(input(),2)for _ in range(n)]\n \ns=t=0\nfor x in a:\n    t|=s&x\n    s|=x\nprint(('YES','NO')[all(x&s&~t for x in a)])", "complexity": "quadratic", "problem": "0985_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n=int(input())\nprint(int(n/2)+1)", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "def inp1():\n    return int(input())\ndef inp2():\n    return list(map(int,input().split()))\ndef inp3():\n    return map(int,input().split())\nif 1:\n#for _ range(int(input(()))):\n    n=inp1()\n    x=int(n**0.5)\n    i=0\n    y=n\n    ans=[]\n    while(i<n):\n          arr=[]\n          for j in range(x):\n              if y==0:\n                  break\n              arr.append(y)\n              y-=1\n              i+=1\n              if y==0:\n                  break\n          arr=arr[::-1]\n          for j in arr:\n              ans.append(j)\n    print(*ans)\n", "complexity": "linear", "problem": "1017_C", "from": "CODEFORCES", "tags": "constructive algorithms,greedy"}
{"src": "#!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport threading \nfrom bisect import bisect_right\nfrom math import gcd,log\nfrom collections import Counter,defaultdict,deque\nfrom pprint import pprint\nfrom itertools import permutations \nfrom bisect import bisect_right\nfrom random import randint as rti \n# import deque\nn,m=0,0\n\n\n    \n\n\n\ndef main(tnum):\n    global n,m,d\n    n,m,k=map(int,input().split())\n    if k%2:\n        ans=[[-1]*m for i in range(n)]\n        for li in ans:\n            print(*li)\n        return \n    cost=dict()\n    dp=[[float('inf')]*m for i in range(n)] \n    crr=[]\n    rrr=[]\n    for i in range(n):\n        arr=list(map(int,input().split()))\n        for j in range(m-1):\n            dp[i][j]=min(dp[i][j],arr[j])\n            dp[i][j+1]=min(dp[i][j+1],arr[j])\n        crr.append(arr)\n\n\n    for i in range(n-1):\n        arr=list(map(int,input().split())) \n        for j in range(m):\n            dp[i][j]=min(dp[i][j],arr[j])\n            dp[i+1][j]=min(dp[i+1][j],arr[j])\n\n\n        rrr.append(arr)\n\n    for i in range(1,k//2):\n        ndp=[[float('inf')]*m for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                x,y=i,j\n                if x>0:\n                    ndp[i][j]=min(ndp[i][j],dp[x-1][y]+rrr[x-1][y])\n                if x<n-1:\n                    ndp[i][j]=min(ndp[i][j],dp[x+1][y]+rrr[x][y])\n                if y>0:\n                    ndp[i][j]=min(ndp[i][j],dp[x][y-1]+crr[x][y-1])\n                if y<m-1:\n                    ndp[i][j]=min(ndp[i][j],dp[x][y+1]+crr[x][y])\n        dp=ndp\n    for li in dp:\n        li=[2*x for x in li]\n        print(*li)  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n        \n\n\n\n\n    \n\n    \n\n\n\n\n\n\n\n\n        \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \nif __name__ == \"__main__\":\n\n    for _ in range(1): \n        main(_+1)\n\n\n\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from math import gcd\n\nn = int(input())\nd = dict()\nqs = []\nfor i in range(n):\n    s = input()\n    a = int(s[1:s.index('+')])\n    b = int(s[s.index('+') + 1: s.index(')')])\n    c = int(s[s.index(')') + 2:])\n    a = a + b\n    gc = gcd(a, c)\n    res = (a // gc, c // gc)\n    qs.append(res)\n    if res in d:\n        d[res] += 1\n    else:\n        d[res] = 1\nfor q in qs:\n    print(d[q], end=' ')\n", "complexity": "linear", "problem": "0958_D1", "from": "CODEFORCES", "tags": "expression parsing,math"}
{"src": "for _ in range(int(input())):\n    n, k = [int(x) for x in input().split()]\n    if (n == 2 and k == 3) or (n <= 30 and k > (4 ** n - 1) // 3):\n        print('NO')\n    else:\n        cn = n - 1\n        ck = k - 1\n        l = 1\n        while cn * ck != 0 and ck >= 4 * l - 1:\n            ck -= 4 * l - 1\n            cn -= 1\n            l *= 2\n        print('YES', cn)", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "n, m = map(int, input().split())\nboys = list(map(int, input().split()))\ngirls = list(map(int, input().split()))\nboys.sort(reverse=True)\ngirls.sort(reverse=True)\ns = sum(boys)\nma = max(boys)\n#print(s, m)\nres = 0\nfor i in range(0, m):\n    #print(girls[i])\n    if girls[i] < ma:\n        print(-1)\n        exit(0)\n    res += s\n    if (girls[i] == ma):\n        girls[i] = 0\nj = 0\nusage = 0\nfor i in range(0, m):\n    if (usage == m - 1):\n        j += 1\n    if (j >= n):\n        print(-1)\n        exit(0)\n  #  girls[i] -= max(0, boys[j])\n    res += max(0, girls[i] - boys[j])\n    usage += 1\nprint(res)", "complexity": "nlogn", "problem": "1159_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "\nn, m = map(int, input().split())\nc = []\nfor j in range(n):\n    d = []\n    s = input()\n    for i in s:\n        d.append(i)\n    c.append(d)\na = []\nb = []\ne=[]\ng=[]\n\nfor j in range(n):\n    k=[0]*(m)\n    e.append(k)\nfor j in range(n):\n    k=[0]*(m)\n    g.append(k)\n\ndpu = []\nfor j in range(n):\n    k=[0]*(m)\n    dpu.append(k)\ndpd = []\nfor j in range(n):\n    k=[0]*(m)\n    dpd.append(k)\ndpl = []\nfor j in range(n):\n    k=[0]*(m)\n    dpl.append(k)\ndpr = []\nfor j in range(n):\n    k=[0]*(m)\n    dpr.append(k)\nfor i in range(n):\n    for j in range(m):\n        if c[i][j] == \"*\":\n            if i>0:\n                dpu[i][j]+=dpu[i-1][j]+1\n            else:\n                dpu[i][j]=1\n            if j>0:\n                dpl[i][j]=dpl[i][j-1]+1\n            else:\n                dpl[i][j]=1\ni=n-1\nwhile(i>=0):\n    j=m-1\n    while(j>=0):\n        if c[i][j] == \"*\":\n            if i<(n-1):\n                dpd[i][j] += dpd[i + 1][j] + 1\n            else:\n                dpd[i][j] = 1\n            if j<(m-1):\n                dpr[i][j] = dpr[i][j + 1] + 1\n            else:\n                dpr[i][j] = 1\n        j+=-1\n    i+=-1\nfor i in range(1,n-1):\n    for j in range(1,m-1):\n        if c[i][j] == \"*\":\n            k=min(dpd[i][j]-1,dpu[i][j]-1,dpr[i][j]-1,dpl[i][j]-1)\n            if k==0:\n                pass\n            elif k>0:\n                a.append([i+1,j+1,k])\n                e[i-k][j]+=1\n                if (i+k)<(n-1):\n                    e[i+k+1][j]+=-1\n                g[i][j-k] += 1\n                if (j + k) < (m - 1):\n                    g[i][j+k+1] += -1\nfor i in range(m):\n    for j in range(1,n):\n        if c[j-1][i]==\"*\":\n            e[j][i]+=e[j-1][i]\nfor i in range(n):\n    for j in range(1,m):\n        if c[i][j-1]==\"*\":\n            g[i][j]+=g[i][j-1]\nf=0\nfor i in range(n):\n    for j in range(m):\n        if c[i][j]==\"*\" and e[i][j]<=0 and g[i][j]<=0:\n            f=1\n            break\nif f==1:\n    print(-1)\nelse:\n    print(len(a))\n    for j in a:\n        print(*j)\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "quadratic", "problem": "1015_E2", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "# def fibo(n):\n#     if n==0:\n#         return 0\n#     elif n==1:\n#         return 1\n#     else:\n#         return fibo(n-1)+fibo(n-2)\n#\n# n = int(input())\n#\n# if n>3:\n#     print(fibo(n-1),fibo(n-3),fibo(n-4))\n\na = [0,1]\nn = int(input())\ni=2\nr=0\nwhile r<n:\n     r = a[i-1]+a[i-2]\n     a.append(r)\n     i+=1\nl = len(a)-1\nif n>3:\n    print(a[l-4],a[l-3],a[l-1])\nelif n==3:\n    print(1,1,1)\nelif n==2:\n    print(0,1,1)\nelif n==1:\n    print(0,0,1)\nelif n==0:\n    print(0,0,0)", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import sys\ninput = sys.stdin.readline\n\n\nfrom collections import deque\nN, Q = map(int, input().split())\nque = deque([int(a) for a in input().split()])\nma = max(que)\n\nX = []\nk = -1\nc = 0\nwhile c <= k+N+5:\n    a = deque.popleft(que)\n    b = deque.popleft(que)\n    \n    X.append((a, b))\n    c += 1\n    if a > b:\n        a, b = b, a\n    if k < 0 and b == ma:\n        k = c\n    deque.appendleft(que, b)\n    deque.append(que, a)\n\nfor _ in range(Q):\n    i = int(input()) - 1\n    if i <= k:\n        print(*X[i])\n    else:\n        i = (i-k)%(N-1)+k\n        print(*X[i])\n\n", "complexity": "linear", "problem": "1179_A", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nfrom io import BytesIO, IOBase\nimport sys\nfrom collections import defaultdict, deque, Counter\nfrom math import sqrt, pi, ceil, log, inf, gcd, floor\nfrom itertools import combinations, permutations\nfrom bisect import *\nfrom fractions import Fraction\nfrom heapq import *\nfrom random import randint\n\ndef main():\n    n=int(input())\n    a=list(map(int,input().split()))\n    dp=[[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i]=a[i]\n    for i in range(n-2,-1,-1):\n        for j in range(i+1,n,1):\n            for k in range(i,j,1):\n                if dp[i][k] and dp[i][k]==dp[k+1][j]:\n                    dp[i][j]=dp[i][k]+1\n    b=[10**10]*(n+1)\n    b[0]=0\n    for i in range(1,n+1):\n        for j in range(i):\n            if dp[j][i-1]:\n                b[i]=min(b[i],b[j]+1)\n    print(b[n])\n    \n# region fastio\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "ii=lambda:int(input())\nkk=lambda:map(int, input().split())\nll=lambda:list(kk())\n \na,b,c,d,e,f=kk()\nal = [a,b,c,d,e,f]\ns = sum(al)\narea = a*b+c*d+e*f\nside = int(area**.5)\nif side**2 != area or side not in al:\n\tprint(-1)\n\texit()\nif al.count(side) == 3:\n\t# as bs cs\n\tif s == 4*side:\n\t\trest = [a for a in al if a != side]\n\t\tprint(side)\n\t\tfor _ in range(side):\n\t\t\tprint(\"\".join([\"A\"*rest[0], \"B\"*rest[1], \"C\"*rest[2]]))\nelif al.count(side) > 1:\n\tprint(-1)\nelse:\n\tx=al.index(side)\n\ty=x^1\n\tres = al[y]\n\ta,b=min(x,y),max(x,y)\n\ts1 = \"ABC\"[a//2]\n\ts23 = [s for s in \"ABC\" if s != s1]\n\trest = al[:a]+al[b+1:]\n\tres = side - res\n\ta,b=[rest[0],rest[1]],[rest[2],rest[3]]\n\tif not (res in a and res in b):\n\t\tprint(-1)\n\t\texit()\n\to1,o2 = a[a.index(res)^1],b[b.index(res)^1]\n\tprint(side)\n\tfor _ in range(al[y]):\n\t\tprint(s1*side)\n\tfor _ in range(res):\n\t\tprint(\"\".join([s23[0]*o1,s23[1]*o2]))", "complexity": "np", "problem": "0581_D", "from": "CODEFORCES", "tags": "bitmasks,brute force,constructive algorithms,geometry,implementation,math"}
{"src": "n, a, b, c, t = map(int, input().split())\nl = list(map(int, input().split()))\nf = [0] * 1001\nfor i in l: f[i] -= -1\ntmp = 0\ntmp2 = 0\nfor i in range(1, t):\n    tmp += (t - i) * f[i]\ntmp = n * a + tmp * c - tmp * b\nprint(max(n * a, tmp))", "complexity": "linear", "problem": "0964_B", "from": "CODEFORCES", "tags": "math"}
{"src": "l,r = [int(i) for i in input().split()]\nbitafter=-1;\nfor i in range(60,-1,-1):\n    if(l&(1<<i)!=r&(1<<i)):\n        bitafter = i\n        break\nres = 0\nwhile(bitafter>=0):\n    res+=1<<bitafter\n    bitafter-=1\nprint(res)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import math\nfrom decimal import Decimal, ROUND_FLOOR\n\ndef sum2(s, e):\n    return sum1(e) - sum1(s - 1) - (e - s)\n\ndef sum1(i):\n    return i * (i + 1) / 2\n\nn, k = map(Decimal, input().split())\n\nif(n == 1):\n    print(0)\nelif(k > n):\n    print(1)\nelif(sum2(Decimal(2),k) < n):\n    print(-1)\nelse:\n    c = 2 * n + k - k * k\n    discriminant = (9 - 4 * c).sqrt()\n    res1 = int(((3 + discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))\n    res2 = int(((3 - discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))\n    res1 = max(res1, res2)\n    print(k - res1 + 1);", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = map(int, input().split())\nmod = 998244353\nd = defaultdict(int)\nfor x in a:\n    d[x] += 1\nd[0] = 0\nb = list(d.items())\nb.sort()\nm = len(b)\nba = [0] * m\ncn = [0] * (m + 1)\nk = h = 0\nfor i, x in enumerate(b):\n    while h < m and x[0] >= b[h][0] * 2:\n        h += 1\n    ba[i] = h - 1\n    while k < m and x[0] * 2 > b[k][0]:\n        k += 1\n    cn[k] += x[1]\nfor i in range(m):\n    cn[i+1] += cn[i]\ndp = [0] * m\ndp[0] = 1\nb = [x[1] for x in b]\nfor i in range(n):\n    ndp = [0] * m\n    for j in range(1, m):\n        if cn[j] >= i - 1:\n            ndp[j] = dp[j] * (cn[j] - i + 1) % mod\n        dp[j] += dp[j-1]\n        if dp[j] >= mod:\n            dp[j] -= mod\n    for j in range(1, m):\n        ndp[j] += dp[ba[j]] * b[j]\n        ndp[j] %= mod\n    dp = ndp\nprint(sum(dp) % mod)", "complexity": "cubic", "problem": "1437_F", "from": "CODEFORCES", "tags": "combinatorics,dp,math,two pointers"}
{"src": "# A. Find Square\n\nn, m = map(int, input().split())\n\ntop = [-1, -1]\nbottom = [-1, -1]\n\nfor i in range(n):\n    s = input()\n    left = s.find('B')\n    if left != -1:\n        right = s.rfind('B')\n        c = (right - left) // 2 + 1\n        print(i + c, left + c)\n        break\n", "complexity": "quadratic", "problem": "1028_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def factorial(n) :\n    ans = 1\n    if (n == 0) :\n        return 1\n    for i in range(1, n + 1) :\n        ans *= i\n    return ans\ndef ncr(n , r) :\n    n = abs(n) \n    if r > n :\n        return 0 \n    ans = factorial(n)\n    ans = ans//(factorial(n-r)) \n    ans = ans//(factorial(r))\n    return ans\n\nif __name__ == \"__main__\" :\n    A = input() \n    B = input()\n    QMarks = B.count('?')   \n    TotalA = A.count('+') - A.count('-') \n    TotalB = B.count('+') - B.count('-') \n    denominator = 2**QMarks\n    if QMarks < abs(TotalA - TotalB) :  \n        print(0) \n    else :\n        x = (QMarks - abs(TotalA - TotalB))//2\n        x += abs(TotalA - TotalB)\n        num = ncr(QMarks,x) \n        print(num/denominator)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "\n\nn = int(input())\n\n\nt = list(map(int,input().split()))\n\n\nt.sort()\n\nif t[-1]==1:\n    t[-1]=2\nelse:\n    t[-1]=1\nt.sort()\nprint(*t)\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "n = int(input())\nA = [int(i) for i in input().split()]\nA = list(set(A))\nA.sort()\nif len(A)>1:\n    print(A[1])\nelse:\n    print(\"NO\")\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "n = int(input())\nprint(n**2 + (n-1)**2)\n", "complexity": "constant", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "n = int(input())\na = sorted((input() for _ in range(n)), key=lambda x: len(x))\nv = all(a[i] in a[i+1] for i in range(n-1))\nprint('YES\\n'+\"\\n\".join(a) if v else 'NO')", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "from sys import stdin\nx, k = map(int, stdin.readline().split())\nif x == 0:\n\tprint(0)\nelse:\n\tmod = 1000000007\n\ta = pow(2,k,mod)%mod\n\tb = (2*a)%mod\n\tprint((((((x%mod)*(b%mod))%mod)-(a%mod)+1)+mod)%mod)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "st=input()\nm=0\nn=len(st)\nfor i in range(n):\n    for j in range(i,n+1) :\n        if st[i:j] in st[i+1:n] and len(st[i:j])>m:\n            m=len(st[i:j])\nprint(m)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "n=input()\nn1=int(n)\nc=[]\nfor i in range(0,n1):\n    z4=0\n    p,q=input().split()\n    a=int(p)\n    b=int(q)\n    while a!=0 and b!=0:\n        z1=z3=0\n        if a<=b:\n          z=(b/a)\n          z1=int(z)\n          b=b-(z1*a) \n        if b<=a and b!=0:\n          z2=a/b\n          z3=int(z2)\n          a=a-(z3*b) \n        z4=z4+z1+z3    \n    c.append(z4)\nl=len(c)\nfor j in range(0,l):\n    print(c[j])\n    ", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "n, k = map(int, input().split())\nli = [int(num) for num in input().split(\" \", n - 1)]\nans = []\nfor i in range(0, n):\n    su = 0\n    for j in range(i, n):\n        su += li[j]\n        if (j - i + 1 >= k):\n            ans.append(su / (j - i + 1))\nprint(max(ans))", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "def suma_o_resta(a, b):\n\treturn (a & (1<<b))\n\ndef diferencia(s1, d):\n\tif s1:\n\t\ts1.sort()\n\t\t#print(*s1, sep=\" - \")\n\t\tif s1[-1] - s1[0] >= d:\n\t\t\t#print(str(s1[-1]) + \" - \" + str(s1[0]) + \" = \" + str(s1[-1] - s1[0]))\n\t\t\treturn s1\n\t\telse:\n\t\t\treturn diferencia(s1.remove(s1[-1]), d)\t\n\treturn s1\n\ndef no_sets(v, n, l, r, d):\n\ts = []\n\tcont = 0\n\tfor x in range(1<<n):\n\t\tfor i in range(n):\n\t\t\t#print(\"(\" + str(x) + \", \" + str(i) + \")\")\n\t\t\tif suma_o_resta(x, i) > 0:\n\t\t\t\t#print(str(suma_o_resta(x, i)))\n\t\t\t\ts.append(v[i])\n\t\ts = diferencia(s, d)\n\t\tif s:\n\t\t\tif sum(s) >= l and sum(s) <= r:\n\t\t\t\tcont += 1\n\t\ts = []\n\treturn cont;\n\t\n\nn, l, r, x = map(int, input().split())\n\nv = list(map(int, input().split()))\n\nprint(str(no_sets(v, n, l, r, x)))\n\n\n\t\t\t\t \t\t\t  \t\t\t\t   \t  \t \t\t \t", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "# import sys\n# sys.stdin=open(\"input.in\",\"r\")\n# sys.stdout=open(\"ot.out\",\"w\")\n\nA,B=map(int,input().split())\nx,y,z=map(int,input().split())\nsumm=0\ny1=0\nb1=0\ny1=(x*2)+y\n\nb1=y+(3*z)\n\nsumm=0\nif y1>A:\n\tsumm+=y1-A\nif b1>B:\n\tsumm+=b1-B\nprint(summ)", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def mp():\n    return map(int, input().split())\n\ndef f(i):\n    return (10 ** i - 10 ** (i - 1)) * i\n\nn = int(input())\n\ni = 1\nsum = 0\nwhile n - f(i) >= 0:\n    n -= f(i)\n    sum += f(i) // i\n    i += 1\n\nprint(str(sum + (n + i - 1) // i)[n % i - 1])", "complexity": "constant", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nfor t in range(ii()):\n    n, k = mi()\n    if n == 1:\n        ans = 'YES 0' if k == 1 else 'NO'\n    elif n == 2:\n        if k <= 2:\n            ans = 'YES 1'\n        elif k == 3 or k > 5:\n            ans = 'NO'\n        else:\n            ans = 'YES 0'\n    elif n <= 32 and k > (4 ** n - 1) // 3:\n        ans = 'NO'\n    else:\n        c, x = 0, n\n        p2 = 2\n        while x > 0:\n            if c + p2 - 1 > k:\n                break\n            c += p2 - 1\n            x -= 1\n            p2 *= 2\n        ans = 'YES %d' % (x,)\n    print(ans)\n", "complexity": "linear", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "n, a, b = map(int, input().split())\nif min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))): \n    print(\"NO\")\n    exit()\nres = [[0] * n for _ in range(n)]\nfor i in range(0, n - max(a, b)):\n    res[i][i + 1] = res[i + 1][i] = 1\nif a == 1:\n    res = [[e ^ 1 for e in l] for l in res]\n\nprint(\"YES\")\nfor i in range(n):\n    res[i][i] = 0\n    print(*res[i], sep='')", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "import sys\ndef input(): return sys.stdin.readline().strip()\n\n\nn, mod = map(int, input().split())\n\nle = 405\n\n\ndef pow(x, y):  # x**y \u306e mod \u3092\u8fd4\u3059\u3002mod\u306f\u7d20\u6570\u3067\u306a\u304f\u3066\u3082\u3088\u3044\u3002\n    ans = 1\n    while y > 0:\n        if y % 2 == 1:\n            ans = (ans * x) % mod\n        x = (x**2) % mod\n        y //= 2\n    return ans\n\n\ndef inv(x):  # x \u306e mod \u3067\u306e\u9006\u5143\u3092\u8fd4\u3059\u3002mod\u304c\u7d20\u6570\u3067\u3001x\u3068mod\u304c\u4e92\u3044\u306b\u7d20\u3067\u3042\u308b\u5fc5\u8981\u3042\u308a\u3002\n    return pow(x, mod-2)\n\n\nM = [1]  # i!\u306emod\nmul = 1\nfor i in range(1, le):\n    mul = (mul * i) % mod\n    M.append(mul)\n\nMI = [0] * (le-1) + [inv(M[le-1])]  # i!\u306e\u9006\u5143\nfor i in range(le-2, -1, -1):\n    MI[i] = MI[i+1] * (i+1) % mod\n\n\ndef C(x, y):  # \u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\uff08\u7d44\u5408\u305b\uff09\n    if y < 0 or y > x:\n        return 0\n    elif x > le:  # O(min(y, x-y))\n        y = min(y, x-y)\n        ans = 1\n        for i in range(x, x-y, -1):\n            ans = (ans * i) % mod\n        return (ans * MI[y]) % mod\n    else:  # O(1)\n        ans = M[x]\n        ans = (ans * MI[y]) % mod\n        return (ans * MI[x-y]) % mod\n\n\nM2 = [1]\nfor i in range(n+5):\n    M2.append((M2[-1]*2) % mod)\n\nCO = [[0] * (n+5) for i in range(n+5)]\nfor i in range(n+5):\n    for j in range(n+5):\n        CO[i][j] = C(i, j)\n\nD = [[0] * (n+1) for i in range(n+2)]\n# D[\u4f55\u500b\u76ee\u307e\u3067\u898b\u305f\u304b][\u305d\u306e\u3046\u3061\u624b\u52d5ON\u306e\u500b\u6570] = (\u898b\u305f\u3046\u3061\u306e\u6700\u53f3\u304c\u81ea\u52d5ON\u3067\u3042\u308b\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570)\n\nD[0][0] = 1\nfor i in range(n+2):\n    for j in range(i//2, min(n+1, i+1)):\n        # print(i, j)\n        for k in range(1, min(n+1, n-i+1, n-j+1)):\n            # print(i, j, k)\n            ind0 = i+k+1\n            ind1 = j+k\n            if ind0 <= n+1 and ind1 <= n:\n                D[ind0][ind1] += D[i][j] * CO[j+k][k] * M2[k-1]\n                D[ind0][ind1] %= mod\n\n\n# print(D)\nprint(sum(D[-1]) % mod)\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "a = list(input())\nb = int(input())\na.sort(reverse=True)\n# print(a)\nans=''\nwhile a:\n    for i in range(len(a)):\n        temp=''\n        x=ans+a[i]+temp.join(sorted(a[:i]+a[i+1:]))\n        if int(x)<=b:\n            ans+=a[i]\n            a=a[:i]+a[i+1:]\n            break\nprint(int(ans))", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n = int(input())\nx, y = list(map(int, input().strip().split()))\n\nif n-x + n-y >= x-1 + y-1:\n\tprint(\"White\")\nelse:\n\tprint(\"Black\")", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n = int(input())\nvisit = [0 for i in range(n+1)]\nres = []\nc = 0\ns,t=0,0\ndef do(i):\n\tglobal c,s,t\n\tfor j in range(i,n+1,2*i):\n\t\tres.append(i)\n\t\tc += 1\n\t\tif c >= (n-1) and n>2:\n\t\t\tif s == 0:\n\t\t\t\ts = j\n\t\t\telse:\n\t\t\t\tt = j\n\treturn res\ncurr = 0\ni = 1\nwhile(i<=n):\n\t# print(i)\n\tdo(i)\n\ti = 2*i\nif n>2:\n\tres[n-1] = max(s,t)\n# print(s,t)\nfor i in res:\n\tprint(i,end=\" \")", "complexity": "nlogn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "n,k = map(int,input().split())\na = list(map(int,input().split()))\nt = []\nfor i in range(1,n):\n    t.append(a[i]-a[i-1])\nt.sort()\nprint(sum(t[:n-k]))\n", "complexity": "nlogn", "problem": "1197_C", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "# _\n#####################################################################################################################\n\ndef main():\n    nNodes = int(input())\n    neighborsOf = {node: [] for node in map(str, range(1, nNodes+1))}\n    threeNeighborNodeExists, threeNeighborNode = False, None\n    for i in range(1, nNodes):\n        node1, node2 = input().split()\n        neighborsOf[node1].append(node2), neighborsOf[node2].append(node1)\n        if len(neighborsOf[node1]) == 3:\n            if threeNeighborNodeExists:\n                return 'No'\n            threeNeighborNodeExists, threeNeighborNode = True, node1\n        elif len(neighborsOf[node2]) == 3:\n            if threeNeighborNodeExists:\n                return 'No'\n            threeNeighborNodeExists, threeNeighborNode = True, node2\n\n    if threeNeighborNodeExists:\n        return tnnDecompositionFrom(neighborsOf, threeNeighborNode+' ')\n\n    return decompositionFrom(neighborsOf)\n\n\ndef tnnDecompositionFrom(tree, threeNeighborNode):\n    paths = tuple(threeNeighborNode + node for node in tree if len(tree[node]) == 1)\n    return f'Yes\\n{len(paths)}\\n' + '\\n'.join(paths)\n\n\ndef decompositionFrom(tree):\n    return 'Yes\\n1\\n' + ' '.join(node for node in tree if len(tree[node]) == 1)\n\n\nif __name__ == '__main__':\n    print(main())\n    # main()\n", "complexity": "linear", "problem": "0981_C", "from": "CODEFORCES", "tags": "implementation,trees"}
{"src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\n\nfor _ in range(N):\n    l,r = getIntList()\n    n = (r-l+1)\n    z = n//2\n    if l%2==0:\n        z*=-1\n    if n%2==1:\n        if r%2==0:\n            z += r\n        else:\n            z-=r\n    print(z)\n\n    \n\n\n\n\n", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "def solve():\n    n, k = list(map(lambda x: int(x), input().split()))\n    upper_bound = n+1\n    lower_bound = -1\n    while upper_bound > lower_bound + 1:\n        m = (upper_bound + lower_bound) // 2\n        if (n - m) * (n - m + 1) // 2 - m > k:\n            lower_bound = m\n        else:\n            upper_bound = m\n    print(upper_bound)\n\nsolve()\n\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n,r = map(int,input().split())\nx_coord = list(map(int,input().split()))\nd = {}\nfor i in x_coord:\n    final = r\n    for j in range(i-r,i+r+1):\n        check = d.get(j,[-1,-1])\n        if check[0] > 0:\n            potential = check[1] + ((4*r*r)-((i-check[0])**2))**.5\n            final = max(potential,final)\n    for j in range(i-r,i+r+1):\n        d[j] = (i,final)\n    print(final,end = \" \")", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "n, s = map(int, input().strip().split())\n\nnum = ''\ndiv = 9\n\nif s//10 != 0:\n\n    div = 9\n    while (s//div)//10 != 0:\n        div = div*10+9\n    while div:\n        rem = str(s//div)\n        if int(rem) > 9:\n            num = str(int(num)+1) + '0'*len(str(div))\n            div = 0\n            s = 0\n            break\n        else:\n            num += rem\n        s = s%div\n        div //= 10\n    num += str(s)\nelse:\n    num = str(s)\nmini = int(num)\nif mini%10 != 0:\n    mini += 10\n    mini -= mini%10\n\nprint(max(0, n-mini+1))\n\n# while s:\n#     num += str(s%div)\n#     s = s//div\n#     div = div*10+9\n\n# num = num[::-1]\n\n\n# print(max(0, n-mini+1))\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "\ndef solve():\n    n = int(input())\n    max_degs = [int(x) for x in input().split()]\n\n    B = [[i+1, x] for i, x in enumerate(max_degs) if x >= 2]\n    S = [[i+1, x] for i, x in enumerate(max_degs) if x < 2]\n\n    if 2 + sum(b - 2 for _, b in B) < len(S):\n        print('NO')\n        return\n\n    print('YES', len(B) + min(len(S), 2) - 1)\n    print(n-1)\n\n    # B edges\n    for k in range(len(B) - 1):\n        i, x = B[k]\n        i_n, _ = B[k+1]\n        print(i, i_n)\n        B[k][1] -= 1\n        B[k+1][1] -= 1\n\n    k = 0\n    for i, (s_idx, _) in enumerate(S):\n        if i == 0:\n            print(B[0][0], s_idx)\n            B[0][1] -= 1\n        elif i == 1:\n            print(B[-1][0], s_idx)\n            B[-1][1] -= 1\n        else:\n            while B[k][1] == 0:\n                k += 1\n            print(B[k][0], s_idx)\n            B[k][1] -= 1\n\n\nsolve()\n", "complexity": "linear", "problem": "1082_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "import sys\nimport math\n\n\ndef readlines(type=int):\n    return list(map(type, sys.stdin.readline().split()))\n\n\ndef read(type=int):\n    return type(sys.stdin.readline().strip())\n\n\njoint = lambda it, sep=\" \": sep.join(\n    [str(i) if type(i) != list else sep.join(map(str, i)) for i in it])\n\n\ndef solve_naive(n, k):\n    taken = set()\n    current_cap = 0\n    found = False\n    while current_cap != n:\n        for c in range(k, 1, -1):\n            found = False\n            if current_cap == 0:\n                if c <= n:\n                    current_cap += c\n                    taken.add(c)\n                    found = True\n                    break\n            else:\n                if c not in taken and c - 1 <= n - current_cap:\n                    current_cap += c - 1\n                    taken.add(c)\n                    found = True\n                    break\n        if not found:\n            break\n    return len(taken) if found else -1\n\n\ndef solve(n, k):\n    if n == 1:\n        return 0\n    if k >= n:\n        return 1\n    else:\n        if (3 - 2 * k) ** 2 - 8 * (n - k) < 0:\n            return -1\n        t = (-math.sqrt((3 - 2 * k) ** 2 - 8 * (n - k)) + (2 * k) - 3) / 2\n        if t == 0.0:\n            return 2\n        if t % 1 == 0:\n            return 1 + int(t)\n        else:\n            # print(f\"{t=}\")\n            return 2 + int(t)\n\n\ndef main():\n    n, k = readlines()\n    print(solve(n, k))\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import sys\nfrom functools import reduce\ninput = sys.stdin.readline\n\ndef readPair():\n  return tuple(map(int, input().split()))\n\ndef readEntry():\n  e = readPair()\n  return (e[0], e[1], e[0] - e[1])\n\n(n, m) = readPair()\nentries = [readEntry() for _ in range(0, n)]\n\nentries.sort(key=lambda x: x[2], reverse=True)\n\nsize = reduce(lambda s, e: s + e[0], entries, 0)\ncount = 0\n\nwhile (size > m and count < n):\n  size -= entries[count][2]\n  count += 1\n\nprint(-1 if size > m else count)", "complexity": "nlogn", "problem": "1015_C", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dc\nfrom collections import Counter\nfrom bisect import bisect_right, bisect_left,bisect\nimport math\nfrom operator import itemgetter\nfrom heapq import heapify, heappop, heappush\nn=int(input())\nl=list(map(int,input().split()))\nx=dc(int)\ny=dc(int)\nz=dc(int)\np=dc(int)\nq=dc(int)\nr=dc(int)\nx[l[-1]]+=1\ny[l[-1]]+=1\nz[l[-1]]+=1\nfor i in range(n-2,-1,-1):\n    p[i]=x[l[i]]\n    q[i]=y[l[i]+1]\n    r[i]=z[l[i]-1]\n    x[l[i]]+=1\n    y[l[i]]+=1\n    z[l[i]]+=1\n#print(p)\n#print(q)\n#print(r)\nx=[0]*n\nfor i in range(n-2,-1,-1):\n    x[i]=l[i+1]+x[i+1]\n#print(x)\ns=0\nfor i in range(n-2,-1,-1):\n    #print(x[i],p[i]*l[i],q[i]*(l[i]+1),r[i]*(l[i]-1))\n    c=x[i]-(p[i]*l[i])-(q[i]*(l[i]+1))-(r[i]*(l[i]-1))\n    d=n-i-1-p[i]-q[i]-r[i]\n    e=c-l[i]*d\n    #print(i,c,d,e)\n    s+=e\nprint(s)", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "n = int(input())\na = list(map(int, input().strip().split()))\n\nb = set(a)\nres = len(b)\nif 0 in b:\n    res -= 1\nprint(res)\n", "complexity": "linear", "problem": "0992_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "#n, m = map(int, input().split())\n#x = int(input())\nn, m = map(int, input().split())\nans = m // n + min(1, m % n)\nprint(ans)", "complexity": "constant", "problem": "1061_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "n,val=map(int,input().split());\na=[0]+list(map(int,input().split()));\nsuma=[0 for i in range(n+1)];\nmx=0;\ntarget=0;\nfor i in range(1,n+1):\n\tsuma[i]=suma[i-1];\n\tmx=max(mx,a[i]);\n\tif (a[i]==val):\n\t\ttarget+=1;\n\t\tsuma[i]+=1;\n\nans=0;\npre=[0 for i in range(mx+1)];\ndp=[0];\nfor i in range(1,n+1):\n\tdp.append(max(1,1+dp[pre[a[i]]]-suma[i]+suma[pre[a[i]]]));\n\tif (a[i]!=val):\n\t\tans=max(ans,dp[i]);\n\tpre[a[i]]=i;\nprint(ans+target);", "complexity": "linear", "problem": "1082_E", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "a = list(map(int,input().split()))\nif a.count(1)>=1 or a.count(2)>=2 or a.count(3)==3 or (a.count(2)==1 and a.count(4)==2):\n    print(\"YES\")\nelse:\n    print(\"NO\")", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "from sys import stdin\n\nn, m = map(int, stdin.readline().split())\nans, p, all = [], [1 << i for i in range(n - 2, -1, -1)] + [1], set(range(1, n + 1))\nnum, cur, i = 1, 0, 0\n\nwhile i < len(p) and m > 0 and num <= n:\n    cur += p[i]\n    if cur >= m:\n        m -= (cur - p[i])\n        cur = 0\n        ans.append(num)\n        all.discard(num)\n    num += 1\n    i += 1\n\nprint(' '.join(map(str, ans + sorted(all)[::-1])))\n", "complexity": "np", "problem": "0513_B1", "from": "CODEFORCES", "tags": "brute force"}
{"src": "# cook your dish here\nimport math\nn=int(input())\nif(n%2==0):\n   x=math.floor(n/2+1)*(math.floor(n/2))\nif(n%2!=0):\n   x=(math.ceil(n/2)*(math.ceil(n/2)))\nprint(x)", "complexity": "linear", "problem": "0909_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "s = input()\nres = 0\nfor i in range(len(s)):\n    for j in range(i,len(s)):\n        for f in range(i+1,len(s)):\n            if len(s) >= f + j-i:\n                if (s[i:j]== s[f:f+j-i]):\n                    res = max(res,j - i)\n                    \nprint(res)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import sys\ndef power(x, y, p) :\n    res = 1     # Initialize result\n \n    # Update x if it is more\n    # than or equal to p\n    x = x % p \n \n    while (y > 0) :\n         \n        # If y is odd, multiply\n        # x with result\n        if ((y & 1) == 1) :\n            res = (res * x) % p\n \n        # y must be even now\n        y = y >> 1      # y = y/2\n        x = (x * x) % p\n         \n    return res\nmod=(10**9)+7\nr,k=map(int,input().split())\nif r==0:\n    print(0)\n    sys.exit()\nprint((((((power(2,k+1,mod)%mod)*(r%mod))%mod)-power(2,k,mod)+1))%mod)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n,m=map(int,input().split())\nc=0;ans=str()\nfor i in range(n):\n  ans+=str(c^1)\n  c=c^1\nprint(ans)\n", "complexity": "linear", "problem": "1004_B", "from": "CODEFORCES", "tags": "constructive algorithms,greedy,implementation,math"}
{"src": "import sys\nimport os\n\ndef solve(slimes):\n    if len(slimes) == 1:\n        return slimes[0]\n\n    havePos = False\n    haveNeg = False\n\n    for s in slimes:\n        if s > 0:\n            havePos = True\n        elif s < 0:\n            haveNeg = True\n\n    if havePos and haveNeg:\n        return sum(map(abs, slimes))\n    elif not havePos:\n        m = max(slimes)\n        return sum(list(map(abs, slimes))) + 2 * m\n    elif not haveNeg:\n        m = min(slimes)\n        return sum(list(map(abs, slimes))) - 2 * m\n    else:\n        return 0\n\ndef main():\n    n = int(input())\n    slimes = list(map(int, input().split()))\n    print(solve(slimes))\n\n\nif __name__ == '__main__':\n    main()", "complexity": "linear", "problem": "1038_D", "from": "CODEFORCES", "tags": "dp,greedy,implementation"}
{"src": "n,k=map(int,input().split())\nans=0\nans+=(2*n)//k + bool((2*n)%k!=0)\nans+=(5*n)//k + bool((5*n)%k!=0)\nans+=(8*n)//k + bool((8*n)%k!=0)\nprint(ans)", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n,m=map(int,input().split())\nlst=list(map(int,input().split()))\narr=lst.copy()\narr.sort(reverse=True)\nvis=[0]*n\nsumm=0\nfor i in range(m):\n    temp=arr[i]\n    summ+=temp\n    for j in range(n):\n        if vis[j]==0 and lst[j]==temp:\n            vis[j]=1\n            \n            break\n\nprint(summ)\ncnt=0\nans=[]\nfor i in range(n):\n    if vis[i]==1:\n        ans.append(cnt+1)\n        cnt=0\n    else:\n        cnt+=1\nans[-1]+=cnt\nprint(*ans)", "complexity": "nlogn", "problem": "1006_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "n,pos,l,r = map(int, input().split())\ndl,dr = abs(pos-l) + 1, abs(pos-r) + 1\nprint(dr*(r<n) if l==1 else dl if r==n else min(dl,dr)+r-l+1)", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\nN, M = map(int, input().split())\n\nAns = [(0, 0) for  _ in range(N*M)]\nfor i in range(1, N*M+1):\n    if i % 2:\n        a, b = divmod(i//2, M)\n    else:\n        a, b = divmod(N*M - i//2, M)\n    Ans[i-1] = (a+1, b+1)\nfor a in Ans:\n    sys.stdout.write('{} {}\\n'.format(*a))", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "# cook your dish here\nn=int(input())\narr=[int(x) for x in input().split()]\nli=arr[:]\nli.sort()\nc=0\nfor i in range(n):\n    if(arr[i]!=li[i]):\n        c+=1\n    if(c>2):\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "\nclass Solver:\n    def solve(self):\n        self.num_people = int(input())\n\n        if self.num_people % 4 == 2:\n            return -1\n\n        return self.find_zero_pair()\n\n    def find_zero_pair(self):\n        begin = 1\n        end = self.num_people // 2 + 1\n\n        begin_value = self.func(begin)\n        if begin_value == 0:\n            return begin\n\n        while begin < end: \n            mid = (begin + end) // 2\n            mid_value = self.func(mid)\n            if mid_value == 0:\n                return mid\n            elif begin_value * mid_value > 0:\n                begin = mid + 1 \n            else:\n                end = mid - 1\n\n        return begin\n\n    def func(self, pos):\n        opposite = (pos - 1 + self.num_people // 2) % self.num_people + 1\n        return self.get_value(pos) - self.get_value(opposite)\n\n    def get_value(self, pos):\n        print('? {}'.format(pos))\n        value = int(input())\n        return value\n\nsolver = Solver()\npair = solver.solve()\nprint('! {}'.format(pair))\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "###############################\n# https://codeforces.com/contest/1010/problem/A\n# 2021/01/12\n# WenhuZhang\n################################\nfrom sys import stdin\nimport collections\nimport copy\nimport math\n\n\nn = int(stdin.readline())\nm = int(stdin.readline())\nup = list(map(int, stdin.readline().split()))\ndown = list(map(int, stdin.readline().split()))\n\ndef check(x):\n    weight = m + x\n    fuel = x\n    for i in range(n):\n        f = weight/up[i]\n        if fuel<f:\n            return False\n        else:\n            weight -= f\n            fuel -= f\n        f = weight/down[i]\n        if fuel<f:\n            return False\n        else:\n            weight -= f\n            fuel -= f\n    return True\n\n\nl = 0\nr = 1e9 + 1e-6\n\nfor ii in range(100):\n    mid = (r + l)/2\n    # print(mid)\n    if(check(mid)):\n        r = mid\n    else:\n        l = mid\n    if r-l <= 1e-10:\n        break\nif l >= 1e9+ 1e-6:\n    print(-1)\nelse:\n    print(\"%.10f\" %l)\n\n", "complexity": "linear", "problem": "1010_A", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nINF = 10**9\n\nn, m = [int(item) for item in input().split()]\ns = input().rstrip()\n\ncount = [[0] * m for _ in range(m)]\nord_a = ord(\"a\")\nfor c1, c2 in zip(s, s[1:]):\n    c1 = ord(c1) - ord_a\n    c2 = ord(c2) - ord_a\n    if c1 != c2:\n        count[c1][c2] += 1\n\nsum_of_subset = [[0] * (1 << m) for _ in range(m)]\nfor i in range(m):\n    for j in range(1 << m):\n        if j == 0:\n            continue\n        lsb = j & -j\n        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n\nadj_in_subset = [0] * (1 << m)\nfor i in range(1 << m):\n    for j in range(m):\n        if i & (1 << j):\n            adj_in_subset[i] += sum_of_subset[j][i]\n\ntotal_adj = adj_in_subset[-1]\ndp = [INF] * (1 << m)\ndp[0] = 0\n\nfor i in range(1 << m):\n    for j in range(m):\n        if i & 1 << j:\n            continue\n        not_i = ((1 << m) - 1) ^ i\n        val = dp[i] + (total_adj - adj_in_subset[i] - adj_in_subset[not_i])\n        dp[i | (1 << j)] = min(dp[i | (1 << j)], val)\nprint(dp[-1])", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "def size_of_group(i):\n    return long(9 * 10**(i - 1)) * i\n\ndef find_group_data(k, i = 1):\n    diff = long(k - (size_of_group(i)))\n    if diff <= 0:\n        return k, i\n    return find_group_data(diff, i + 1)\n\ndef get_sequence_number(num):\n    \"\"\"https://codeforces.com/problemset/problem/1177/B\"\"\"\n    k, g = find_group_data(num)\n    return str(long(10**(g - 1)) + (k - 1) / g)[(k - 1) % g]\n\n# run program\nif __name__ == \"__main__\":\n    print(get_sequence_number(long(input())))", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "R = lambda: map(int, input().split())\n\nn, r = R()\nxs = list(R())\nys = []\nfor i in range(n):\n    ys.append(max([((2 * r) ** 2 - abs(xs[i] - xs[j]) ** 2) ** 0.5 + ys[j] for j in range(i) if abs(xs[i] - xs[j]) <= 2 * r], default=r))\nprint(*ys)", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import sys, math\nimport io, os\n# data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\n# from heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n# from itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\n# from fractions import Fraction\n# sys.setrecursionlimit(100000)\nINF = 10001\nmod = int(1e9) + 7\n\n\ndef cal(l,r):\n    if l==r:\n        dp1[l][r]=a[l]\n        dp3[l][r] = 1\n        return dp1[l][r]\n    if dp1[l][r]!=-1:\n        return dp1[l][r]\n    for i in range(l,r):\n        if cal(l,i) == cal(i+1,r) != 0:\n            dp1[l][r]=dp1[l][i]+1\n            dp3[l][r]=1\n        dp3[l][r]=min(dp3[l][r],dp3[l][i]+dp3[i+1][r])\n    if dp1[l][r] == -1:\n        dp1[l][r] = 0\n    return dp1[l][r]\n\n\nn=int(data())\na=mdata()\nans=[n]\ndp1=[[-1]*n for i in range(n)]\ndp3=[[10001]*n for i in range(n)]\ncal(0,n-1)\nout(dp3[0][n-1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "a,b,c,n=map(int,input().split())\nif n-a-b+c>=1:\n    if a<c or b<c:\n        print(-1)\n    else:\n        print(n-a-b+c)\nelse:\n    print(-1)", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "N,U = map(int,input().strip().split())\n\nE = list(map(int,input().strip().split()))\nmaxu = -1\nj = 2\nif N < 3:\n    print(-1)\nfor i in range(N-2):\n    j = max(i+2,j)\n    if E[j] -E[i] > U:\n        continue\n    while j < N and E[j] - E[i] <= U:\n        j += 1\n    j -= 1\n    maxu = max(maxu, (E[j] - E[i+1]) / (E[j] - E[i]))\nprint(maxu)", "complexity": "nlogn", "problem": "0957_C", "from": "CODEFORCES", "tags": "binary search,greedy,math,two pointers"}
{"src": "import sys\ninput = sys.stdin.readline\nfrom collections import deque\nclass Graph:\n  def __init__(self, N, M=-1):\n    self.V = N\n    if M>=0: self.E = M\n    self.edge = [[] for _ in range(self.V)]\n    self.edge_rev = [[] for _ in range(self.V)]\n    self.order = []\n    self.to = [0]*self.V\n    self.visited = [False]*self.V\n    self.dp = [0]*self.V\n\n  def add_edge(self, a, b, dist=-1, bi=False, rev=False):\n    if dist>=0:\n      self.edge[a].append((dist, b))\n      if rev: self.edge_rev[b].append((dist, a))\n      if bi: self.edge[b].append((dist, a))\n    else:\n      self.edge[a].append(b)\n      self.to[b] += 1\n      if rev: self.edge_rev[b].append(a)\n      if bi: self.edge[b].append(a)\n\n  def topo_sort(self): #topological sort\n    updated = [0]*self.V\n    for start in range(self.V):\n      if self.to[start] or updated[start]: continue\n      stack = deque([start])\n      while stack:\n        v = stack.popleft()\n        self.order.append(v+1)\n        updated[v] = 1\n        for u in self.edge[v]:\n          self.to[u] -= 1\n          if self.to[u]: continue\n          stack.append(u)\n\nN, M, K = map(int, input().split())\n\nfrom collections import defaultdict\ndic = defaultdict(lambda: -1)\nfor i in range(N):\n  S = input()[:-1]\n  dic[S] = i\nG = Graph(N)\nfor _ in range(M):\n  t, mt = input().split()\n  mt = int(mt)-1\n  lis = []\n  for S in range(1<<K):\n    s = ''\n    for i in range(K):\n      if (S>>i)%2:\n        s += '_'\n      else:\n        s += t[i]\n    if dic[s]>=0: lis.append(dic[s])\n  if mt not in lis:\n    print('NO')\n    exit()\n  for l in lis:\n    if l!=mt:\n      G.add_edge(mt, l, bi=False, rev=False)\nG.topo_sort()\nif len(G.order)==N:\n  print('YES')\n  print(*G.order)\nelse:\n  print('NO')", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "n, v = map(int, raw_input().split())\n\nres=0\nfuel=0\nfor i in range(1,n):\n    miss = min(v-fuel, n-i-fuel)\n    res+=i*miss\n    fuel+=miss-1\n    if v-fuel==0:\n        print(res)\n        exit(0)\nprint(res)", "complexity": "linear", "problem": "1113_A", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "x,k=map(int,input().split())\nif x==0:print(\"0\")\nelse:\n    ans=(x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7)\n    print(ans)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "l,r=map(int,input().split())\nj=r-l+1\n\nif j==3:\n\tif l%2==0:\n\t\tprint(l,l+1,l+2)\n\telse:\n\t\tprint(-1)\nelif j>3:\n\tif l%2==0:print(l,l+1,l+2)\n\telse:print(l+1,l+2,l+3)\nelse:print(-1)", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "x, y, z, t1, t2, t3 = map(int, input().split())\nd1 = abs(x - y) * t1\nd2 = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3\nif d2 <= d1:\n    print('YES')\nelse:\n    print('NO')\n", "complexity": "constant", "problem": "1054_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "a=''.join(reversed(sorted(input())))\nb=int(input())\nr=''\nwhile len(a)>0:\n    for i in range(len(a)):\n        n=r+a[i]+''.join(sorted(a[:i]+a[i+1:]))\n        if int(n)<=b:\n            r+=a[i]\n            a=a[:i]+a[i+1:]\n            break\nprint(r)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n = int(input())\narr = list(map(int, input().split()))\n\nfor i in range(n):\n    arr[i] = (arr[i]-i)//n + (1 if (arr[i]-i)%n>0 else 0)\nprint(arr.index(min(arr))+1)\n", "complexity": "linear", "problem": "0996_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "n, m, k = map(int, input().split())\nDATA = [input() for i in range(n)]\n\n#dp[n_day][used_cost]\n#ans = min(dp[n_day][used_cost] for used_cost in range(k + 1))\n#dp[n_day][used_cost] := min(dp[n_day - 1][prev_cost] + cost(pay used_cost - prev_cost in n_day) for prev_cost in range(used_cost + 1))\nINF = 1 << 60\ndp = [[INF]*(k + 10) for i in range(n + 10)]\ndp[0][0] = 0\n\nCOST = [[INF]*(k + 10) for i in range(n + 10)]\nfor i, string in enumerate(DATA):\n    #COST[i + 1]\n    stack = []\n    for j in range(m):\n        if string[j] == \"1\":\n            stack.append(j)\n    L = len(stack)\n    for j in range(k + 10):\n        if j >= L:\n            COST[i + 1][j] = 0\n            continue\n        else:\n            for pos in range(j + 1):\n                l = pos\n                r = pos + L - 1 - j\n                COST[i+1][j] = min(COST[i+1][j], stack[r] - stack[l] + 1)\nfor day in range(1, n + 1):\n    for used_cost in range(k + 1):\n        dp[day][used_cost] = min(dp[day - 1][prev_cost] + COST[day]\n                                 [used_cost - prev_cost] for prev_cost in range(used_cost + 1))\n\nans = min(dp[n][used_cost] for used_cost in range(k + 1))\nprint(ans)\n", "complexity": "cubic", "problem": "0946_D", "from": "CODEFORCES", "tags": "dp"}
{"src": "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nA = list(map(int, input().split()))\n\ndp = [[-1]*(N+1) for _ in range(N+1)]\nfor l in range(N):\n    dp[l][l+1] = A[l]\n\n\nfor d in range(2, N+1):\n    for l in range(N-d+1):\n        for t in range(1, d):\n            if dp[l][l+t] == dp[l+t][l+d] and dp[l][l+t] != -1:\n                dp[l][l+d] = dp[l][l+t] + 1\n                break\n\n\ndp2 = [i for i in range(N+1)]\nfor r in range(1,N+1):\n    if dp[0][r] != -1:\n        dp2[r] = 1\nfor l in range(N):\n    for r in range(l+2, N+1):\n        if dp[l+1][r] != -1:\n            dp2[r] = min(dp2[l+1]+1, dp2[r])\n        else:\n            dp2[r] = min(dp2[l+1]+(r-l-1), dp2[r])\n\nprint(dp2[N])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "class NextStringIndex:\n    def __init__(self, string):\n        self.INF = 10 ** 9\n        self.alph = \"abcdefghijklmnopqrstuvwxyz\"\n        self.kind = len(self.alph)\n        self.to_ind = {char: ind for ind, char in enumerate(self.alph)}\n\n        self.string = string\n        self.len_s = len(string)\n        self.next_ = self.make_next()\n\n    def __getitem__(self, tup):\n        ind, char = tup\n        return self.next_[ind][self.to_ind[char]]\n\n    def make_next(self):\n        dp = [[self.INF] * self.kind for i in range(self.len_s + 1)]\n        for i in range(len_s)[::-1]:\n            for j, char in enumerate(self.alph):\n                if s[i] == char:\n                    dp[i][j] = i + 1\n                else:\n                    dp[i][j] = dp[i + 1][j]\n        return dp\n\n\ndef solve(t1, t2, len_s):\n    INF = 10 ** 9\n    len_t1 = len(t1)\n    len_t2 = len(t2)\n    dp = [[INF] * (len_t2 + 1) for i in range(len_t1 + 1)]\n    dp[0][0] = 0\n\n    for i in range(len_t1 + 1):\n        for j in range(len_t2 + 1):\n            length = dp[i][j]\n            if length > len_s:\n                continue\n            if i < len_t1 and s_next[length, t1[i]] < INF:\n                dp[i + 1][j] = min(dp[i + 1][j], s_next[length, t1[i]])\n            if j < len_t2 and s_next[length, t2[j]] < INF:\n                dp[i][j + 1] = min(dp[i][j + 1], s_next[length, t2[j]])\n\n    return dp[-1][-1] < INF\n\n\nquery = int(input())\nfor _ in range(query):\n    s = input()\n    t = input()\n    len_s = len(s)\n    len_t = len(t)\n\n    s_next = NextStringIndex(s)\n    \n    flag = False\n    for i in range(len_t + 1):\n        flag |= solve(t[0:i], t[i:], len_s)\n    if flag:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n    # @timer\n    def __init__(self):\n        pass\n\n    def __call__(self):\n        s = list(input().strip())\n        n = len(s)\n\n        res = list()\n        p = n - 1        \n        ones = 0\n        zeros = 0\n        while p >= 0:\n            if s[p] == '0':\n                zeros += 1\n            elif s[p] == '1':\n                ones += 1\n            elif s[p] == '2':\n                res.extend(['0'] * zeros)\n                res.append('2')\n                zeros = 0\n            p -= 1\n        res.extend(['1'] * ones)\n        res.extend(['0'] * zeros)\n        res.reverse()\n        print(''.join(map(str, res)))\n\nsolver()()", "complexity": "linear", "problem": "1009_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\nmod = 998244353\na.sort()\ndp = [1] + [0] * n\nfor i in range(1, n + 1):\n    x, pt = 1, i - 2\n    while pt >= 0 and 2 * a[pt] > a[i - 1]:\n        x = x * (n - pt - 2) % mod\n        pt -= 1\n    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod\nprint(dp[-1])", "complexity": "cubic", "problem": "1437_F", "from": "CODEFORCES", "tags": "combinatorics,dp,math,two pointers"}
{"src": "base = 1000000007\nn , m , k = map(int,input().split())\na = list(map(int,input().split()))\nmx = 0\ns = 0\ndp = []\ndd= []\nfor j in range(m):\n    for i in range(n+1):\n        dp.append(base)\n        dd.append(0)\n    for i in range(n):\n        dd[i+1]=dd[i]+a[i]-k*(i % m== j)\n        dp[i+1] = min(dd[i],dp[i])\n        #print(dd)\n        #print(dp)\n        if (i % m == j):\n            mx = max ( mx , dd[i+1]-dp[i+1])\nprint(mx)", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#######################################\nfrom collections import defaultdict as dd\nfor t in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    l1=dd(int)\n    a=0\n    for j in l:\n        l1[j]+=1\n        if l1[j]==4:\n            a=j\n    if a:\n        print(a,a,a,a)\n    else:\n        c=0\n        x=0\n        l2=[]\n        for j in l1:\n            if l1[j]>=2:\n                l2.append(j)\n        l2.sort()\n        for j in l2:\n                c+=1\n                if c==1:\n                    a=j\n                elif c==2:\n                    b=j\n                else:\n                    if x/j+j/x<a/b+b/a:\n                        a,b=x,j\n                x=j\n        print(a,a,b,b)", "complexity": "nlogn", "problem": "1027_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "modulo = int(1e9+7)\nn = int(input())\narr = [input() for i in range(n)]\ndp = [1]\nfor i in range(n):\n    if arr[i] == 'f':\n        dp.append(0)\n        continue;\n    for j in range(1, len(dp)):\n        dp[j] = (dp[j] + dp[j-1]) % modulo\nprint(dp[-1])", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "from bisect import insort,bisect_right,bisect_left\nfrom sys import stdout, stdin, setrecursionlimit\nfrom heapq import heappush, heappop, heapify \nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import * \nfrom string import *\nfrom queue import *\nfrom math import *\nfrom re import *\nfrom os import *\n\n# sqrt,ceil,floor,factorial,gcd,log2,log10,comb\n\n####################################---fast-input-output----#########################################\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ngraph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())\ndef getStr(): return input()\ndef getInt(): return int(input())\ndef listStr(): return list(input())\ndef getStrs(): return input().split()\ndef isInt(s): return '0' <= s[0] <= '9'\ndef input(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in input().split()]\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))\n\n\ndef getPrimes(N = 10**5):\n    SN = int(sqrt(N))\n    sieve = [i for i in range(N+1)]\n    sieve[1] = 0\n    for i in sieve:\n        if i > SN:\n            break\n        if i == 0:\n            continue\n        for j in range(2*i, N+1, i):\n            sieve[j] = 0\n    prime = [i for i in range(N+1) if sieve[i] != 0] \n    return prime\ndef primeFactor(n,prime=getPrimes()):\n    lst = []\n    mx=int(sqrt(n))+1\n    for i in prime:\n        if i>mx:break\n        while n%i==0:\n            lst.append(i)\n            n//=i\n    if n>1:\n        lst.append(n)\n    return lst    \n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\ndaysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n\n#################################################---Some Rule For Me To Follow---#################################\n\"\"\"\n    --instants of Reading problem continuously try to understand them.\n\n    --Try & again try, maybe you're just one statement away!\n\n\"\"\"\n##################################################---START-CODING---###############################################\n\n\na = int(stdin.readline())\nb = getInt()\n \nans = ''\n \nc = sorted(list(str(a)))\n \nwhile c:\n    for i in range(len(c) - 1, -1, -1):\n        if int(''.join(list(ans) + [c[i]] + c[:i] + c[i + 1:])) <= b:\n            ans += c[i]\n            c.pop(i)\n            break\n \nstdout.write(ans)\n\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\n# A. Connect Three\n\na = [tuple(mi()) for i in range(3)]\na.sort()\n\nup1 = a[1][1] >= a[0][1]\nup2 = a[2][1] >= a[0][1]\nans = {a[0]}\nx, y = a[0]\nif up1 and up2:\n    while y < min(a[1][1], a[2][1]):\n        y += 1\n        ans.add((x, y))\n    while x < a[2][0]:\n        x += 1\n        ans.add((x, y))\n    hx, hy = a[2] if a[2][1] > a[1][1] else a[1]\n    while hy > y:\n        ans.add((hx, hy))\n        hy -= 1\nelse:\n    dn1 = a[1][1] <= a[0][1]\n    dn2 = a[2][1] <= a[0][1]\n    ans = {a[0]}\n    x, y = a[0]\n    if dn1 and dn2:\n        while y > max(a[1][1], a[2][1]):\n            y -= 1\n            ans.add((x, y))\n        while x < a[2][0]:\n            x += 1\n            ans.add((x, y))\n        lx, ly = a[2] if a[2][1] < a[1][1] else a[1]\n        while ly < y:\n            ans.add((lx, ly))\n            ly += 1\n    else:\n        x, y = a[0]\n        ans = {a[0]}\n        while x < a[2][0]:\n            x += 1\n            ans.add((x, y))\n        dy = 1 if a[1][1] <= a[0][1] else -1\n        xx, yy = a[1]\n        while yy != a[0][1]:\n            ans.add((xx, yy))\n            yy += dy\n        dy = 1 if a[2][1] <= a[0][1] else -1\n        xx, yy = a[2]\n        while yy != a[0][1]:\n            ans.add((xx, yy))\n            yy += dy\n\nans = sorted(ans)\nprint(len(ans))\nprint('\\n'.join('%d %d' % (x, y) for x, y in ans))", "complexity": "constant", "problem": "1086_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import math\n\nstr1 = input()\nstr2 = input()\nvalue = 0\nvalue_2 = 0\nunknown = 0\nfor x in str1:\n    if x == '+':\n        value += 1\n    else:\n        value -= 1\nfor x in str2:\n    if x == '+':\n        value_2 += 1\n    elif x == '-':\n        value_2 -= 1\n    else:\n        unknown += 1\nplus_count = 0\nminus_count = 0\nrav = 0\nx = value - value_2\nif abs(x)<= unknown:\n    if x >= 0:\n        plus_count += x\n        rav = unknown - plus_count\n    else:\n        minus_count += x\n        rav = unknown - minus_count\n    #print(plus_count, minus_count, rav)\n    if plus_count == 0 and minus_count == 0 and rav == 0:\n        print('1.000000000000')\n    else:\n        if rav % 2 == 0:\n            rav = int(rav / 2)\n            plus_count += rav\n            minus_count += rav\n            # print(plus_count, minus_count)\n            k = max(plus_count, minus_count)\n            C = math.factorial(unknown) / (math.factorial(unknown - k) * math.factorial(k))\n            O = math.pow(2, unknown)\n            res = C / O\n            print(f'{res:.12f}')\n        else:\n            print('0.000000000000')\nelse:\n    print('0.000000000000')\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "n,k=map(int,input().split())\nmod=int(1e9+7)\n\n'''\n_2k=2**k\n\nn2k=n*_2k\n\ns=(n2k*(n2k+1))/2\nn2k_2k=n2k-_2k\n\ns=s-((n2k_2k)*(n2k_2k+1))/2\n\ns=2*s\n\ns=s/_2k\n\ns=s%mod\nprint(int(s))\n'''\n\n#simplifying above we get:-\n\n\nif n>0: \n    ans=pow(2,k+1,mod)*n-pow(2,k,mod)+1\nelse: \n    ans=0\nprint(ans%mod)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n,k = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nc = n\nj=0\nfor x in arr:\n    while(x>arr[j]):\n        if(x-arr[j]<=k):c-=1\n        j+=1\n          \nprint(c)    \n", "complexity": "nlogn", "problem": "0990_B", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO,IOBase\nfrom array import array\n\ndef main():\n    n,M = map(int,input().split())\n    comb = [[0]*(n+1) for _ in range(n+1)]\n    comb[0][0] = 1\n    for i in range(1,n+1):\n        for j in range(i+1):\n            comb[i][j] = (comb[i-1][j]+comb[i-1][j-1])%M\n\n    dp = [array('i',[0]*(n+1)) for _ in range(n+1)]\n    # number of partitions ; number of computer\n    for i in range(1,n+1):\n        dp[i][0] = pow(2,i-1,M)\n    for j in range(1,n+1):\n        for i in range(3,n+1):\n            for x in range(1,i-1):\n                dp[i][j] = (dp[i][j]+dp[i-1-x][j-1]*dp[x][0]*comb[i-j][x])%M\n    su = 0\n    for i in range(n+1):\n        su = (su+dp[n][i])%M\n    print(su)\n\n# Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self,file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            self.newlines = b.count(b\"\\n\")+(not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd,self.buffer.getvalue())\n            self.buffer.truncate(0),self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self,file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s:self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda:self.buffer.read().decode(\"ascii\")\n        self.readline = lambda:self.buffer.readline().decode(\"ascii\")\nsys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)\ninput = lambda:sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "#a = [int(i) for i in input().split()]\n#n = input()\nn,s = map(int,input().split())\n\nif s%n==0:\n\tprint(s//n)\nelse:\n\tprint(s//n+1)", "complexity": "constant", "problem": "1061_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "n=int(input())\narr=list(map(int,input().split()))\narr.sort()\nans=0\nmark=0\nfor i in range(len(arr)-2):\n\tif(arr[i]==arr[i+1]==arr[i+2]):\n\t\tprint('cslnb')\n\t\texit(0)\n\telif(arr[i+1]==arr[i+2] and arr[i]+1==arr[i+1]):\n\t\tprint('cslnb')\n\t\texit(0)\n\ncountcopy=0\nfor i in range(len(arr)-1):\n\tif(arr[i]==arr[i+1] and arr[i]==0):\n\t\tprint('cslnb')\n\t\texit(0)\n\tif(arr[i]==arr[i+1]):\n\t\tcountcopy+=1\nif(countcopy>1):\n\tprint('cslnb')\n\texit(0)\n\nfor i in range(len(arr)):\n\tif(arr[i]>=mark):\n\t\tans+=(arr[i]-mark)\n\t\tmark+=1\n\n#print(ans)\nif(ans%2==0):\n\tprint('cslnb')\nelse:\n\tprint('sjfnb')\n\n", "complexity": "nlogn", "problem": "1191_D", "from": "CODEFORCES", "tags": "games"}
{"src": "n = int(input())\nar = [int(i) for i in input().split()]\n\nif n == 1:\n    print(1)\n    exit()\n\nif ar[1] > ar[0]:\n    li = [1]\nelif ar[1] < ar[0]:\n    li = [5]\nelse:\n    li = [3]\n\nc = 1\nwhile c != n:\n    j = 0\n\n    if ar[c] > ar[c - 1]:\n        while c != n and ar[c] > ar[c - 1]:\n            c += 1\n            j += 1\n        for i in range(j-1):\n            li.append(li[-1] + 1)\n            if li[-1] == 6:\n                print(-1)\n#                print(*li)\n                exit()\n        if c != n and ar[c] == ar[c - 1]:\n            li.append(li[-1] + 1)\n        else:\n            li.append(5)\n\n    elif ar[c] < ar[c - 1]:\n        while c != n and ar[c] < ar[c - 1]:\n            c += 1\n            j += 1\n        for i in range(j-1):\n            li.append(li[-1] - 1)\n            if li[-1] == 0:\n                print(-1)\n #               print(*li)\n                exit()\n        if c != n and ar[c] == ar[c - 1]:\n            li.append(li[-1] - 1)\n        else:\n            li.append(1)\n\n    else:\n        while c != n and ar[c] == ar[c - 1]:\n            c += 1\n            j += 1\n        for i in range(j):\n            if li[-1] > 3:\n                li.append(li[-1] - 1)\n            else:\n                li.append(li[-1] + 1)\n        if c != n and ar[c] > ar[c - 1]:\n            if li[-2] == 1:\n                li[-1] = 2\n            else:\n                li[-1] = 1\n        elif c != n and ar[c] < ar[c - 1]:\n            if li[-2] == 5:\n                li[-1] = 4\n            else:\n                li[-1] = 5\n\n#print(c)\nif max(li) > 5 or min(li) < 1:\n    print(-1)\nelse:\n    print(*li)", "complexity": "quadratic", "problem": "1032_C", "from": "CODEFORCES", "tags": "constructive algorithms,dp"}
{"src": "#\"xxx\"\u304c\u9023\u7d9a\u90e8\u5206\u6587\u5b57\u5217\u3068\u3057\u3066\u3044\u304f\u3064\u542b\u307e\u308c\u308b\u304b\n#\u6587\u5b57\u3054\u3068\u3067\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u308c\u3070\u30ad\u30fc\u304cx\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u307f\u306b\u6ce8\u76ee\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\n#x\u304c\u30ad\u30fc\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u9577\u3055\u3092l\u3068\u3059\u308b\u306a\u3089max(0,l-3+1)\u304c\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\"xxx\"\u306e\u500b\u6570\nfrom itertools import groupby\nn=int(input())\ns=input()\nx=[len(list(group)) for key,group in groupby(s) if key==\"x\"]\nans=sum(max(0,l-3+1) for l in x)\nprint(ans)", "complexity": "linear", "problem": "0978_B", "from": "CODEFORCES", "tags": "greedy,strings"}
{"src": "k1,k2,k3 = map(int, input().strip().split(' '))\nl=[k1,k2,k3]\nif min(k1,k2,k3)==1:\n    print('yes')\nelif l.count(2)>=2:\n    print('yes')\nelif l.count(3)==3:\n    print('yes')\nelif l.count(4)==2 and l.count(2)==1:\n    print('yes')\nelse:\n    print('no')", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "n=int(input())\na=list(map(int,input().split()))\na.sort()\nlose=False\npair=False\nfor i in range(n-1):\n    if a[i]==a[i+1]==0:\n        lose=True\n    if a[i]==a[i+1]:\n        if pair:\n            lose=True\n        pair=True\n        if i>=1:\n            if a[i]==a[i-1]+1:\n                lose=True\nif lose:\n    print(\"cslnb\")\nelse:\n    eventual=n*(n-1)//2\n    curr=sum(a)\n    if (curr-eventual)%2==0:\n        print(\"cslnb\")\n    else:\n        print(\"sjfnb\")", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "n,m=map(int,input().split())\ns=[]\nfor i in range(n):\n\ts.append(list(map(str,input().strip())))\n#print(s)\nt=[]\nfor i in range(n):\n\tp=['.']*m\n\tt.append(p)\n\nfor i in range(1,n-1):\n\tfor j in range(1,m-1):\n\t\tf=0\n\t\tif s[i-1][j-1]=='#' and s[i-1][j]=='#' and s[i-1][j+1]=='#' and s[i][j-1]=='#' and s[i][j+1]=='#' and s[i+1][j-1]=='#' and s[i+1][j]=='#' and s[i+1][j+1]=='#':\n\t\t\tf=1\n\t\tif f==1:\n\t\t\tt[i-1][j-1]='#'\n\t\t\tt[i-1][j]='#'\n\t\t\tt[i-1][j+1]='#'\n\t\t\tt[i][j-1]='#'\n\t\t\tt[i][j+1]='#'\n\t\t\tt[i+1][j-1]='#'\n\t\t\tt[i+1][j]='#'\n\t\t\tt[i+1][j+1]='#'\nf=1\n#print(t)\nfor i in range(n):\n\tfor j in range(m):\n\t\tif s[i][j]=='#' and s[i][j]!=t[i][j]:\n\t\t\tf=0\n\t\t\tbreak\n\tif f==0:\n\t\tbreak\nif f==1:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")\n", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from sys import  stdin \ninput=stdin.readline\nfrom  collections import defaultdict\ndef num(s):\n    l,r=0,0\n    for i in s:\n        if l==0 and i==\")\":\n            r+=1\n        elif i==\"(\":\n            l+=1\n        elif l and i==\")\":\n            l-=1\n    return (l,r)\n\ndef f(mp,cnt):\n    ans=0\n    # print(mp,cnt)\n    for l in cnt:\n        # print(mp,ans)\n        if l.count(0)<1:\n            continue\n        if l!=(0,0) and l==l[::-1]:\n            continue\n        # print(\"l hai\",l)\n        t=mp[l[::-1]]\n        t2=mp[l[::-1]]\n        ans+=t\n        if t and l!=l[::-1]:\n            mp[l]-=1\n    return ans\n\ncnt=[]\nmp=defaultdict(int)\nfor i in range(int(input())):\n    s=input()\n    l=num(s)\n    # print(l,s)\n    cnt.append(l)\n    mp[l]+=1\nprint(f(mp,cnt))", "complexity": "linear", "problem": "0990_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\ns=input()\n\n\nwhile(1):\n        if(len(s)==1):\n                print(0)\n                break\n            \n        elif(s==s[::-1]):\n            \n            s=s[1:]\n        \n        \n        \n        else:\n            print(len(s))\n            break", "complexity": "linear", "problem": "0981_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "s=input()\nm=0\nn=len(s)\nfor i in range(n-1):\n    for j in range(i,n+1) :\n        if s[i:j] in s[i+1:n] and len(s[i:j])>m:\n            m=len(s[i:j])\nprint(m)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "## \nmax_ = 10**18\narr  = [0, 1]\narr2 = [0, 3] \nwhile arr[-1] < max_:\n    arr.append(arr[-1]*4)\n    arr2.append(arr2[-1]*2+1)\n    \nfor i in range(1, len(arr)):\n    arr[i] += arr[i-1]\n    \ndef solve(n, k):\n    if n==2 and k==3:\n        return 'NO'\n    if n==2 and k==4:\n        return 'YES 0'\n    if n+1<=len(arr) and k > arr[n]:\n         return 'NO'\n        \n    i=0\n    while k >= arr[i+1]:\n        i+=1\n    if k-arr[i] > arr2[i]:\n        i+=1\n    return 'YES ' +str(n-i)    \n\nfor _ in range(int(input())):\n    n, k = map(int, input().split())\n    print(solve(n, k))", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "n = int(input())\n \nif n<6:\n\tprint(-1)\nelse:\n\tprint(\"1 2\\n1 3\\n1 4\")\n\tfor i in range(5,n+1):\n\t\tprint('2 '+str(i))\nfor i in range(2, n+1):\n\tprint('1 '+str(i))", "complexity": "linear", "problem": "0959_C", "from": "CODEFORCES", "tags": "constructive algorithms,trees"}
{"src": "def cnt(s,t):\n    i,c=0,0\n    while(s.count(t)):\n        s=s[s[i:].index(t)+1:]\n        c+=1\n    return c\ns=(input())\nn=len(s)\nln=0\nfor i in range(n):\n    for j in range(i,n):\n        if(j-i+1<=ln):\n            continue\n        if(cnt(s,s[i:j+1])>=2):\n            ln=max(ln,j-i+1)\nprint(ln)\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "from __future__ import division\nfrom sys import stdin, stdout\n\n\ndef write(x):\n    stdout.write(str(x) + \"\\n\")\n\n\nn, s = map(int, stdin.readline().split())\n\nif s % n == 0:\n    write(s // n)\nelse:\n    write(s // n + 1)\n", "complexity": "constant", "problem": "1061_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "n, l, r, x = list(map(int, input().split(\" \")))\nc = sorted(list(map(int, input().split(\" \"))))\nways = 0\n\nfor i in range(0, 2 ** n):\n    temp = 0\n    m = 10 ** 9 + 1\n    M = -1\n    for j in range(0, n):\n        if i & 1 << j:\n            temp += c[j]\n            m = min(m, c[j])\n            M = max(M, c[j])\n    if temp >= l and temp <= r and (M - m) >= x:\n        ways += 1\n\nprint(ways)\n\n\n\t\t  \t \t\t\t       \t\t \t \t\t   \t\t \t", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "\n\n\nl, r, k =map(int,input().split())\n\nd = {i:2**i for i in range(10)}\n\ncache = {}\n\ndef can(i, m):\n    return d[i] & m\n\ndef calc(m):\n    b = 1\n    c = 0\n    for i in range(10):\n        if b & m:\n            c += 1\n        b *= 2\n\n    return c\n\ndef sm(ln, k, m, s='', first=False):\n    if ln < 1:\n        return 0, 1\n\n    if (ln, k, m, s, first) in cache:\n        return cache[(ln, k, m, s, first)]\n\n    ans = 0\n    count = 0\n    base = 10 ** (ln-1)\n\n    use_new = calc(m) < k\n\n    if s:\n        finish = int(s[0])+1\n    else:\n        finish = 10\n\n    for i in range(finish):\n        if use_new or can(i, m):\n            ss = s[1:]\n            if i != finish-1:\n                ss = ''\n            nm = m | d[i]\n            nfirst = False\n            if i == 0 and first:\n                nm = m\n                nfirst = True\n            nexta, nextc = sm(ln-1, k, nm, ss, nfirst)\n            ans += base * i * nextc + nexta\n            count += nextc\n\n#    print(ln, k, m, s, first, ans, count)\n    cache[(ln, k, m, s, first)] = (ans, count)\n\n    return ans, count\n\ndef call(a, k):\n    s = str(a)\n    return sm(len(s), k, 0, s, True)[0]\n\n\n#print((call(r, k) - call(l-1, k)))\nprint((call(r, k) - call(l-1, k)) % 998244353)\n", "complexity": "cubic", "problem": "1073_E", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,math"}
{"src": "__author__ = 'ruckus'\n\nn = int(input())\ns = input()\nt = input()\ndif = {}\nhem = 0\nfor i in range(n):\n    if s[i] != t[i]:\n        dif[i] = [s[i], t[i]]\n        hem += 1\n\nchange = []\nprobed = []\nk = 0\nfor i in dif.keys():\n    if dif[i] in probed:\n        continue\n    probed.append(dif[i])\n    k += 1\n    for j in list(dif.keys())[k:]:\n        if dif[i] == dif[j][::-1]:\n            print(hem - 2)\n            print(i + 1, j + 1)\n            quit()\n        if not change and (dif[i][0] == dif[j][1] or dif[j][0] == dif[i][1]):\n            change = [i, j]\n\nif change:\n    print(hem - 1)\n    print(change[0] + 1, change[1] + 1)\nelse:\n    print(hem)\n    print('-1 -1')", "complexity": "linear", "problem": "0527_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "from math import factorial\ns1=input()\ns2=input()\nn=0\nx1=0\nfor i in range(len(s1)):\n    if s1[i]=='+':\n        x1+=1\n    else:\n        x1-=1\nx2=0\nfor i in range(len(s2)):\n    if s2[i]=='+':\n        x2+=1\n    elif s2[i]=='?':\n        n+=1\n    else:\n        x2-=1\nx=abs(x1-x2)\nif x>n:\n    print(0)\nelif x==n:\n    print(1/2**n)\nelse:\n    if (n-x)%2==1:\n        print(0)\n    else:\n        print((factorial(n)//(factorial((n-x)//2)*factorial(n-(n-x)//2)))/2**n)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "# B. Preparing Olympiad\n\ndef check_combination(v):\n    sm = sum(v)\n    if l <= sm <= r:\n        if max(v) - min(v) >= x:\n            global ans\n            ans += 1\n\n\ndef go(offset, k):\n    # https://stackoverflow.com/questions/12991758/creating-all-possible-k-combinations-of-n-items-in-c/28698654\n    if k == 0:\n        check_combination(combination)\n        return\n    for i in range(offset, len(problems) - k + 1):\n        combination.append(problems[i])\n        go(i+1, k-1)\n        combination.pop()\n\n\nn, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\n\nproblems = list()\ncombination = list()\n\nans = 0\n\nfor i in range(2, len(c) + 1):\n    problems = c.copy()\n    go(0, i)\n\nprint(ans)\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "# cook your dish here\nimport math\n \nno_of_moves , no_of_candy = map(int,input().split())\n \ntotal_candy = now_candy = 1 \nnow_moves = 1 \n\n\nif(no_of_moves == 0 or (no_of_moves ==1 and no_of_candy == 1)):\n    print(0)\nelse:\n    while True:\n    \n        now_candy = now_candy + 1 \n        total_candy += now_candy \n        now_moves += 1 \n        if(total_candy -(no_of_moves - now_moves) == no_of_candy):\n            break \n    \n    print(no_of_moves - now_moves)", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n, k = map(int, input().split())\n\ndef prod(n):\n\tif n%2:\n\t\treturn n*((n+1)//2)\n\telse:\n\t\treturn (n//2)*(n+1)\n\ndef total_count(n, k):\n\tif k >= n:\n\t\treturn (0, 0, 1)\n\telse:\n\t\tcount = 0\n\t\tl = 1; r = k\n\t\ts = prod(k)\n\t\twhile l <= r:\n\t\t\tmid = (l+r)//2\n\t\t\tif n > s - prod(mid) + mid:\n\t\t\t\tr = mid-1\n\t\t\telse:\n\t\t\t\tl = mid+1\n\n\t\tn = n - (s - prod(l) + l)\n\t\tcount += (k-l+1)\n\t\tk = l-1\n\t\treturn (n, k, count)\t\t\n\nif prod(k) - (k-1) < n:\n\tprint(-1)\nelif n == 1:\n\tprint(0)\nelif k >= n:\n\tprint(1)\nelse:\n\tn = n-k\n\tk = k-2\n\tcount = 1\n\twhile n > 0:\n\t\t(n, k, temp) = total_count(n, k)\n\t\tcount += temp\n\tprint(count)", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "\nn,s=map(int,input().split())\n\ndef ver(i):\n\tt=str(i)\n\tans=0\n\tfor j in t:\n\t\tans+=int(j)\n\treturn(ans)\nl=len(str(s))\nif n<s:\n\tprint(0)\n\texit()\nif s+10*(l**2+1)<=n:\n\tans=n-s+1-10*(l**2+1)\n\tfor i in range(s,s+10*(l**2+1)):\n\t\tif s+ver(i)<=i:ans+=1\nelse:\n\tans=0\n\tfor i in range(s,n+1):\n\t\tif s+ver(i)<=i:ans+=1\nprint(ans)", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "n=int(input())\nprint('25') ", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\nfrom bisect import bisect,bisect_left\n\nfrom collections import *\nfrom heapq import *\nfrom math import gcd,ceil,sqrt,floor,inf\n\nfrom itertools import *\nfrom operator import add,mul,sub,xor,truediv,floordiv\nfrom functools import *\n\n#------------------------------------------------------------------------\nimport os\nimport sys\n\nfrom io import BytesIO, IOBase\n# region fastio\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n\n#------------------------------------------------------------------------\ndef RL(): return map(int, sys.stdin.readline().split())\ndef RLL(): return list(map(int, sys.stdin.readline().split()))\ndef N(): return int(input())\ndef A(n):return [0]*n\ndef AI(n,x): return [x]*n\ndef A2(n,m): return [[0]*m for i in range(n)]\ndef G(n): return [[] for i in range(n)]\ndef GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]\n#------------------------------------------------------------------------\n\n\nfrom types import GeneratorType\n \n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n \n    return wrappedfunc\n\nmod=10**9+7\nfarr=[1]\nifa=[]\n \ndef fact(x,mod=0):\n    if mod:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr)%mod)\n    else:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr))\n    return farr[x]\n \ndef ifact(x,mod):\n    global ifa\n    fact(x,mod)\n    ifa.append(pow(farr[-1],mod-2,mod))\n    for i in range(x,0,-1):\n        ifa.append(ifa[-1]*i%mod)\n    ifa.reverse()\n \ndef per(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return fact(i)//fact(i-j)\n    return farr[i]*ifa[i-j]%mod\n    \ndef com(i,j,mod=0):\n    if i<j: return 0\n    if not mod:        \n        return per(i,j)//fact(j)\n    return per(i,j,mod)*ifa[j]%mod\n \ndef catalan(n):\n    return com(2*n,n)//(n+1)\n \ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef floorsum(a,b,c,n):#sum((a*i+b)//c for i in range(n+1))\n    if a==0:return b//c*(n+1)\n    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2\n    m=(a*n+b)//c\n    return n*m-floorsum(c,c-b-1,a,m-1)\n\ndef inverse(a,m):\n    a%=m\n    if a<=1: return a\n    return ((1-inverse(m,a)*m)//a)%m\n \ndef lowbit(n):\n    return n&-n\n \nclass BIT:\n    def __init__(self,arr):\n        self.arr=arr\n        self.n=len(arr)-1\n        \n    def update(self,x,v):\n        while x<=self.n:\n            self.arr[x]+=v\n            x+=x&-x\n \n    def query(self,x):\n        ans=0\n        while x:\n            ans+=self.arr[x]\n            x&=x-1\n        return ans\n\nclass ST:\n    def __init__(self,arr):#n!=0\n        n=len(arr)\n        mx=n.bit_length()#\u53d6\u4e0d\u5230\n        self.st=[[0]*mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0]=arr[i]\n        for j in range(1,mx):\n            for i in range(n-(1<<j)+1):\n                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])\n    def query(self,l,r):\n        if l>r:return -inf\n        s=(r+1-l).bit_length()-1\n        return max(self.st[l][s],self.st[r-(1<<s)+1][s])\n        \nclass DSU:#\u5bb9\u91cf+\u8def\u5f84\u538b\u7f29\n    def __init__(self,n):\n        self.c=[-1]*n\n \n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n \n    def find(self,x):\n        if self.c[x]<0:\n            return x\n        self.c[x]=self.find(self.c[x])\n        return self.c[x]\n \n    def union(self,u,v):\n        u,v=self.find(u),self.find(v)\n        if u==v:\n            return False\n        if self.c[u]>self.c[v]:\n            u,v=v,u\n        self.c[u]+=self.c[v]\n        self.c[v]=u\n        return True\n \n    def size(self,x): return -self.c[self.find(x)]\n    \nclass UFS:#\u79e9+\u8def\u5f84\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n \n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n\nclass UF:#\u79e9+\u8def\u5f84+\u5bb9\u91cf\uff0c\u8fb9\u6570\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n        self.size=AI(n,1)\n        self.edge=A(n)\n \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n \n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            self.edge[pu]+=1\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            self.edge[pu]+=self.edge[pv]+1\n            self.size[pu]+=self.size[pv]\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n            self.edge[pv]+=self.edge[pu]+1\n            self.size[pv]+=self.size[pu]\n \ndef Prime(n):\n    c=0\n    prime=[]\n    flag=[0]*(n+1) \n    for i in range(2,n+1):\n        if not flag[i]:\n            prime.append(i)\n            c+=1\n        for j in range(c):\n            if i*prime[j]>n: break\n            flag[i*prime[j]]=prime[j]\n            if i%prime[j]==0: break\n    return flag\n \ndef dij(s,graph):\n    d=AI(n,inf)\n    d[s]=0\n    heap=[(0,s)]\n    vis=A(n)\n    while heap:\n        dis,u=heappop(heap)\n        if vis[u]:\n            continue\n        vis[u]=1\n        for v,w in graph[u]:\n            if d[v]>d[u]+w:\n                d[v]=d[u]+w\n                heappush(heap,(d[v],v))\n    return d\n\ndef bell(s,g):#bellman-Ford\n    dis=AI(n,inf)\n    dis[s]=0\n    for i in range(n-1):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n    change=A(n)\n    for i in range(n):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n                change[v]=1\n    return dis\n\ndef lcm(a,b): return a*b//gcd(a,b)\ndef lis(nums):\n    res=[]\n    for k in nums:\n        i=bisect.bisect_left(res,k)\n        if i==len(res):\n            res.append(k)\n        else:\n            res[i]=k\n    return len(res)\n\ndef RP(nums):#\u9006\u5e8f\u5bf9\n    n = len(nums)\n    s=set(nums)\n    d={}\n    for i,k in enumerate(sorted(s),1):\n        d[k]=i\n    bi=BIT([0]*(len(s)+1))\n    ans=0\n    for i in range(n-1,-1,-1):\n        ans+=bi.query(d[nums[i]]-1)\n        bi.update(d[nums[i]],1)\n    return ans\n \nclass DLN:\n    def __init__(self,val):\n        self.val=val\n        self.pre=None\n        self.next=None\n\ndef nb(i,j,n,m):\n    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:\n        if 0<=ni<n and 0<=nj<m:\n            yield ni,nj\n\ndef topo(n):\n    q=deque()\n    res=[]\n    for i in range(1,n+1):\n        if ind[i]==0:\n            q.append(i)\n            res.append(i)\n    while q:\n        u=q.popleft()\n        for v in g[u]:\n            ind[v]-=1\n            if ind[v]==0:\n                q.append(v)\n                res.append(v)\n    return res\n\n@bootstrap\ndef gdfs(r,p):\n    for ch in g[r]:\n        if ch!=p:\n            yield gdfs(ch,r)\n    yield None\n\n        \n#from random import randint\n'''\ndef f(n):\n    s=set()\n    for order in permutations(range(n)):\n        res=A(n)\n        cur=[]\n        for i in order:\n            if res[i]==0:\n                res[i]=1\n                if i>=2 and res[i-2]==1 and res[i-1]==0:\n                    res[i-1]=1\n                if i<n-2 and res[i+2]==1 and res[i+1]==0:\n                    res[i+1]=1\n                cur.append(i)\n        s.add(tuple(cur))\n    print(len(s))\n    for x in s:\n        print(x)\n    #print(s)'''\n\nt=1\nfor i in range(t):\n    n,mod=RL()\n    #f(n)\n    ma=(n+1)//2\n    ifact(n,mod)\n    dp=A2(n+1,ma+1)\n    f=A(n+1)\n    f[1]=1\n    f[2]=2\n    f[3]=4\n    for i in range(4,n+1):\n        f[i]=f[i-1]*2%mod\n    dp[1][1]=1\n    dp[2][1]=2\n    dp[3][1]=4\n    dp[3][2]=2\n    for i in range(4,n+1):\n        dp[i][1]=f[i]\n        for k in range(2,(i+1)//2+1):\n            for x in range(1,i-2*k+3):\n                #print(k,x)\n                dp[i][k]+=dp[i-x-1][k-1]*f[x]%mod*ifa[x]%mod*fact(i-k+1,mod)%mod*ifa[i-k-x+1]%mod\n                dp[i][k]%=mod\n    ans=0\n    for k in range(1,ma+1):\n        ans=(ans+dp[n][k])%mod\n    print(ans)\n   \n\n        \n\n\n\n                 \n    \n    \n''' \nsys.setrecursionlimit(200000)\nimport threading\nthreading.stack_size(10**8)\nt=threading.Thr\nead(target=main)\nt.start()\nt.join()\n'''\n\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "# import io.os\n# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\ndef func(n1,n2,n3):\n    global r,g,b \n    if((n1<0 and n2<0) or (n3<0 and n2<0) or (n1<0 and n3<0) ):\n        return 0 \n    if(n1<0):\n        return g[n2]*b[n3] + func(n1,n2-1,n3-1)\n    if(n2<0):\n        return r[n1]*b[n3] + func(n1-1,n2,n3-1)\n    if(n3<0):\n        return g[n2]*r[n1] + func(n1-1,n2-1,n3)\n    if(dp[n1][n2][n3]==-1):\n        dp[n1][n2][n3]= max(g[n2]*b[n3] + func(n1,n2-1,n3-1),r[n1]*b[n3] + func(n1-1,n2,n3-1),g[n2]*r[n1] + func(n1-1,n2-1,n3))\n    return dp[n1][n2][n3]\n\n# def func(n1,n2,n3):\n#     for i in range(n1):\n#         for j in range(n2):\n#             for k in range(n3):\n#                 if(i==0 and j==0 and k==0):\n#                     dp[i][j][k] = max(r[i]*g[j],g[j]*b[k],b[k]*r[i])\n#                 elif(i==0 and j==0):\n#                     dp[i][j][k]=max(g[j]*b[k] + dp[i][j-1][k-1],r[i]*b[k] + dp[i-1][j][k-1],g[j]*r[i] + dp[i-1][j-1][k])\n#                 dp[i][j][k]=max(g[j]*b[k] + dp[i][j-1][k-1],r[i]*b[k] + dp[i-1][j][k-1],g[j]*r[i] + dp[i-1][j-1][k])\n\nR,G,B=tuple(map(int,input().split()))\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr=sorted(r)\ng=sorted(g)\nb=sorted(b)\nprefix1=[0]*R \nprefix2 = [0]*G \nprefix3 = [0]*B \nprefix1[0]=r[0]\nprefix2[0] = g[0]\nprefix3[0]=b[0]\ndp=[[[-1 for i in range(B)] for j in range(G)]for k in range(R)]\n# for i in range(1,R):\n#     prefix1[i]=prefix1[i-1]*r[i]\n# for i in range(1,G):\n#     prefix2[i]=prefix2[i-1]*g[i]\n# for i in range(1,B):\n#     prefix3[i]=prefix3[i-1]*b[i]\nprint(func(R-1,G-1,B-1))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n, m = map(int, input().split())\nb = list(map(int, input().split()))\ng = list(map(int, input().split()))\n\nif max(b) > min(g):\n    print(-1)\nelse:\n    total = m*sum(b)\n    b.sort()\n    g.sort()\n    while len(g) > 0:\n        current = 0\n        count = 1\n        if len(b) > 0:\n            current = b.pop()\n        while len(g) > 0 and g[-1] > current and count < m:\n            total += g[-1] - current\n            g.pop()\n            count += 1\n        while len(g) > 0 and g[-1] == current:\n            g.pop()\n    print(total)\n", "complexity": "nlogn", "problem": "1159_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "from sys import stdin\n\nrstr = lambda: stdin.readline().strip()\nrints = lambda: [int(x) for x in stdin.readline().split()]\n\nn, m, k = rints()\na = [rstr() for _ in range(n)]\nmem = [[float('inf') if i else 0 for _ in range(k + 1)] for i in range(n + 1)]\n\nfor i in range(n):\n    ixs = []\n    for j in range(m):\n        if a[i][j] == '1':\n            ixs.append(j)\n\n    for j in range(k + 1):\n        tem = 0\n        if j < len(ixs):\n            tem, c = float('inf'), 0\n            for j1 in range(len(ixs) - j - 1, len(ixs)):\n                tem = min(tem, ixs[j1] - ixs[c] + 1)\n                c += 1\n\n        for j1 in range(k + 1 - j):\n            mem[i + 1][j1 + j] = min(mem[i + 1][j1 + j], mem[i][j1] + tem)\n\nprint(mem[n][k])\n# print(mem)\n", "complexity": "cubic", "problem": "0946_D", "from": "CODEFORCES", "tags": "dp"}
{"src": "def solve(a: int, b: int) -> int:\n    if a > b:\n        a, b = b, a\n    ba = bin(a)[2:]\n    bb = bin(b)[2:]\n    r = ''\n    if len(ba) != len(bb):\n        int('1' * len(bb), 2)\n    else:\n        for ca, cb in zip(ba, bb):\n            if ca == cb:\n                r += '0'\n            else:\n                r += '1'\n                break\n    r += '1' * (len(bb) - len(r))\n    return int(r, 2)\n\n\n# assert solve(32473107276976561, 588384394540535099) == 1152921504606846975\n# assert solve(1, 2) == 3\n# assert solve(1, 1) == 0\n# assert solve(8, 16) == 31\n# assert solve(506, 677) == 1023\n# assert solve(33, 910) == 1023\na, b = map(int, input().split())\nprint(solve(a, b))\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import math\ndef maxXor(l, r):\n  if l == r:\n    return 0\n  xor = l ^ r\n  twoPows = math.log(xor, 2)\n  return 2 ** int(math.floor(twoPows) + 1) - 1\n\nl, r = map(int, input().split())\nprint(maxXor(l, r))\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n, m = map(int, input().split())\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\nans = [0] * m\np = []\nfor i in range(n + m):\n    if t[i] == 1:\n        p.append(i)\nans[0] = p[0]\nfor i in range(m):\n    if i == m - 1:\n        ans[i] += n + m - p[i] - 1\n    else:\n        for j in range(p[i] + 1, p[i + 1]):\n            if a[j] - a[p[i]] <= a[p[i + 1]] - a[j]:\n                ans[i] += 1\n            else:\n                ans[i + 1] += 1\nprint(' '.join(map(str, ans)))\n", "complexity": "quadratic", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "def case(mid):\n    res=0\n    for k,x in enumerate(str(mid)):\n        res+=int(x)\n    return res\nn,s=map(int,input().split())\ni,j=0,n\nwhile i+1<j:\n    mid=(i+j)//2\n    result=case(mid)\n    if mid-case(mid)<s:i=mid\n    else:j=mid\nif i-case(i)>=s:print(n-i+1)\nelse:\n    if j==n:\n        if j-case(j)>=s:print(1)\n        else:print(0)\n    else:print(n-j+1)", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "def solve():\n    n, k = [int(x) for x in input().split(' ')]\n    a = [int(x) for x in input().split(' ')]\n    a_pows = []\n    a_pow_dict = [{} for u in range(11)]\n    for j in range(n):\n        x = a[j] % k\n        i = 0\n        while i < 11:\n            if x in a_pow_dict[i]:\n                a_pow_dict[i][x] += 1\n            else:\n                a_pow_dict[i][x] = 1\n            i += 1\n            x = (x * 10) % k\n\n    c = 0\n\n    for x in a:\n        m = len(str(x))\n        if (-x) % k in a_pow_dict[m]:\n            c += a_pow_dict[m][(-x) % k]\n            c -= int(int(str(x) * 2) % k == 0)\n\n    return c\n\n\nprint(solve())", "complexity": "nlogn", "problem": "1029_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "from itertools import combinations\nn,l,r,x = map(int,input().split())\na = list(map(int,input().split()))\nans = 0\nfor i in range(2,n+1):\n    for j in combinations(a,i):\n        if max(j)-min(j)>=x and l<=sum(j)<=r:\n            ans+=1\nprint(ans)\n        \n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "n = int(input())\na = iter(map(int, input().split()))\nprev_type = 3\nprev_res = 2\ncurr_a = next(a)\nres = []\nfor _ in range(1):\n\tfor next_a in a:\n\t\tif next_a > curr_a:\n\t\t\tif prev_type == 1 or prev_res == 1:\n\t\t\t\tprev_res += 1\n\t\t\t\tif prev_res == 5:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tprev_res = 1\n\t\t\tprev_type = 1\n\t\telif next_a < curr_a:\n\t\t\tif prev_type == 2 or prev_res == 5:\n\t\t\t\tprev_res -= 1\n\t\t\t\tif prev_res == 1:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tprev_res = 5\n\t\t\tprev_type = 2\n\t\telse:\n\t\t\tif prev_type == 1:\n\t\t\t\tprev_res += 1\n\t\t\telif prev_type == 2:\n\t\t\t\tprev_res -= 1\n\t\t\telif prev_res != 2:\n\t\t\t\tprev_res = 2\n\t\t\telse:\n\t\t\t\tprev_res = 3\n\t\t\tprev_type = 3\n\t\tres.append(prev_res)\n\t\tcurr_a = next_a\n\telse:\n\t\tif prev_type == 1:\n\t\t\tres.append(prev_res + 1)\n\t\telif prev_type == 2:\n\t\t\tres.append(prev_res - 1)\n\t\telif prev_res != 1:\n\t\t\tres.append(1)\n\t\telse:\n\t\t\tres.append(2)\n\t\tprint(*res)\n\t\tbreak\nelse:\n\tprint('-1')\n", "complexity": "linear", "problem": "1032_C", "from": "CODEFORCES", "tags": "constructive algorithms,dp"}
{"src": "import math\nfor _ in range (int(input())):\n    n=int(input())\n    s=1\n    ch=0\n    for i in range (1,31):\n        s*=2\n        d=math.sqrt(n//s)\n        if n%s==0 and d==int(d):\n            ch=1\n            break\n    if ch:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "complexity": "constant", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "from sys import stdin, stdout\n\ndef binary_exp(x,n,prime): #calculate x^n%p\n\tif n==0:\n\t\treturn 1\n\telif n==1:\n\t\treturn x%prime\n\telse:\n\t\ttemp=binary_exp(x,n//2,prime)\n\t\ttemp=(temp*temp)%prime\n\t\tif n%2==0:\n\t\t\treturn temp\n\t\telse:\n\t\t\treturn ((x%prime)*temp)%prime\n\nx,k = map(int, stdin.readline().rstrip().split())\nif x==0:\n\tprint(0)\nelse:\n\tval1=binary_exp(2,k+1,1000000007)\n\tval2=binary_exp(2,k,1000000007)\n\tval1=val1%1000000007\n\tval2=val2%1000000007\n\t#print(val1,val2)\n\tans=((val1*(x%1000000007))%1000000007 -(val2-1)%1000000007)%1000000007\n\tprint(ans)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "def main():\n    n, m = map(int, input().split())\n\n    r = []\n    rappend = r.append\n    for i in range(1, (n >> 1) + 1):\n        for j in range(1, m + 1):\n            rappend(str(i) + ' ' + str(j))\n            rappend(str(n + 1 - i) + ' ' + str(m + 1 - j))\n\n    if n & 1:\n        for i in range(1, (m >> 1) + 1):\n            rappend(str((n + 1) >> 1) + ' ' + str(i))\n            rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i))\n        if m & 1:\n            rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1))\n\n    print('\\n'.join(r))\n\n\nmain()\n", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "n, m = map(int, input().split())\ns = input()\nt = input()\nif \"*\" in s:\n    front, back = s.split(\"*\")\n    if len(t) >= len(s) - 1 and t.startswith(front) and t.endswith(back):\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    print(\"YES\" if s == t else \"NO\")\n", "complexity": "linear", "problem": "1023_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "c = 0\ndef backtracking(actuales,restantes,l,r,x):\n    global c\n    if sum(actuales)<=r and sum(actuales) >= l:\n        if max(actuales)- min(actuales) >= x:\n            c += 1\n    if restantes:\n        for i in range(len(restantes)):\n            backtracking(actuales+[restantes[i]], restantes[i+1:],l,r,x)\n    return 0\ndef main():\n    n,l,r,x = input().split(\" \")\n    n,l,r,x = int(n), int(l), int(r), int(x)\n    difficulties = input().split(\" \")\n    for i in range(len(difficulties)):\n        difficulties[i] = int(difficulties[i])\n    difficulties.sort()\n    backtracking([],difficulties,l,r,x) \n    global c     \n    return c\n \nif __name__ == \"__main__\":\n    print(main())", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "from sys import stdin\n\n\ndef main():\n    n = int(input())\n    aa = list(map(int, input().split()))\n    dp = [aa]\n    for i in range(n - 1, 0, -1):\n        aa = aa[:]\n        for j in range(i):\n            aa[j] ^= aa[j + 1]\n        del aa[-1]\n        dp.append(aa)\n    aa = dp[0]\n    for i, bb in enumerate(dp[1:], 1):\n        a = aa[0]\n        for j, b in enumerate(bb):\n            c = aa[j + 1]\n            bb[j] = max(a, b, c)\n            a = c\n        aa = bb\n    input()\n    res = stdin.read().splitlines()\n    for i, s in enumerate(res):\n        lo, hi = map(int, s.split())\n        res[i] = str(dp[hi - lo][lo - 1])\n    print('\\n'.join(res))\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "import math\n#import math \n#------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n#-------------------game starts now----------------------------------------------------import math\ndef calc(st,j):\n    ans=9999999999999999999999\n    #print(st)\n    if j>=len(st):\n        return 0\n    j=len(st)-j\n    for i in range(j-1,len(st)):\n        ans=min(ans,st[i]-st[i-j+1]+1)\n    return ans\nn,m,k=map(int,input().split())\ns=[]\nfor i in range(n):\n    s.append(input())\ninf=99999999999999999999\ndp=[[inf for i in range(k+1)]for j in range(n+1)]\nfor i in range(k+1):\n    dp[0][i]=0 \nfor i in range(1,n+1):\n    st=[]\n    for ik in range(len(s[i-1])):\n        if s[i-1][ik]=='1':\n            st.append(ik)\n    for j in range(k+1):\n        no=calc(st,j) \n        #print(no,j)\n        for t in range(k+1-j):\n            dp[i][t+j]=min(dp[i][t+j],no+dp[i-1][t])\n#print(dp)\nprint(dp[n][k])\n    \n        ", "complexity": "cubic", "problem": "0946_D", "from": "CODEFORCES", "tags": "dp"}
{"src": "rank = 1\nn = int(input())\nscore = sum(map(int,input().split()))\nfor i in range(n-1):\n    student = sum(map(int,input().split()))\n    if(student > score):\n        rank += 1\nprint(rank)", "complexity": "linear", "problem": "1017_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n,m=[int(x) for x in input().split()]\na=[int(x) for x in input().split()]\ns=sum(a)\nneed=0\na.sort()\nj=1\nflag=0\nk=max(a)\nif n==1:\n    print(0)\nelse:\n    for i in range(n):\n        if a[i]<j:\n            flag=1\n        else:\n            flag=0\n        if a[i]==1:\n            need+=1\n        elif a[i]>=j and i!=n-1:\n            need+=1\n        elif a[i]>=j and i==n-1 and j<=k:\n            need+=k-j+1\n        else:\n            need+=1\n        if flag!=1:\n            j+=1\n    print(s-need)\n        \n        \n", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import sys\ninput = sys.stdin.buffer.readline\nn,m=map(lambda x:int(x), input().split())\nA = []\nfor _ in range(n):\n    scores = list(map(lambda x:int(x), input().split()))\n    A.append(scores)\n\ndef solve(n,m,A):\n    # O(31*( 5*n + 4**5 ))\n    # all index from 0\n    ans = ()\n    nstats = 2**m\n    def judge(finalScore):\n        nonlocal ans\n        seen = {}\n        for i,scores in enumerate(A):\n            sta = 0\n            for e in scores:\n                sta=sta*2+(e>=finalScore)\n            # example [1,2,3,4,1], finalScore=3\n            # sta = 0b00110\n            seen[sta]=i\n        \n        for i in range(nstats):\n            for j in range(nstats):\n                if ((i|j) == nstats-1) and i in seen and j in seen:\n                    ans = (seen[i], seen[j])\n                    return True\n\n        return False\n    \n    l=0\n    r=2**31-1\n    while l<r:\n        m=l+(r-l)//2\n        if not judge(m):\n            r=m\n        else:\n            l=m+1\n    # Highest score is l-1\n    print(ans[0]+1,ans[1]+1) # answer index start from 1\n\nsolve(n,m,A)\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "x,n=map(int,input().split())\nmod=10**9+7\nif x>0: ans=pow(2,n+1,mod)*x-pow(2,n,mod)+1\nelse: ans=0\nprint(ans%mod)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "from itertools import combinations\n\nn, l, r, x = map(int, input().split())\na = list(map(int, input().split()))\n\narr = []\n\nfor i in range(2, n+1):\n    ar = combinations(a, i)\n    for j in ar:\n        arr += [(list(j))]\n\ncount = 0\nfor i in arr:\n    dif = max(i) - min(i)\n    total = sum(i)\n    if dif >= x and (total >= l and total <= r):\n        count +=1\n\nprint(count)\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "from itertools import combinations\nn,l,r,x=map(int,input().split())\n*a,=map(int,input().split())\nprint(sum([sum([max(j)-min(j)>=x and l<=sum(j)<=r for j in combinations(a,i)])for i in range(2,n+1)]))", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "n = int(input())\nans = []\nm = 1\nwhile n > 3:\n    ans += [m] * (n - n // 2)\n    n //= 2\n    m *= 2\nif n == 3:\n    ans += [m, m, m * 3]\nelif n == 2:\n    ans += [m, m * 2]\nelse:\n    ans += [m]\nprint(*ans)\n", "complexity": "nlogn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\na = li()\nlf = [(a[i], i) for i in range(n) if a[i] == 1]\nit = [(a[i], i) for i in range(n) if a[i] > 1]\nit.sort(reverse=True)\nwhile len(lf) < 2:\n    lf.append(it.pop())\n\ned = []\n_, last = lf.pop()\n\nfor i in range(len(it)):\n    cap, u = it[i]\n    if i != 0:\n        ed.append((it[i - 1][1], u))\n        cap -= 1\n    while lf and cap > 1:\n        _, l = lf.pop()\n        ed.append((u, l))\n        cap -= 1\n\nif lf:\n    ans = 'NO'\nelse:\n    ans = 'YES %d' % (len(it) + 1,)\n    ed.append((it[-1][1], last))\n    ans1 = str(len(ed))\n    ans2 = '\\n'.join('%d %d' % (u + 1, v + 1) for u, v in ed)\n    ans = '\\n'.join([ans, ans1, ans2])\nprint(ans)\n", "complexity": "nlogn", "problem": "1082_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "#!/usr/bin/env python3\n\nn, k, A = map(int, input().rstrip().split())\nsenators = []\nmx_bribe = 0\n\nfor i in range(n):\n    lvl, loy = map(int, input().rstrip().split())\n    senators.append((lvl, loy))\n    mx_bribe += (100 - loy) // 10\n\nbribe = [0] * n\n\n\ndef calc(votes):\n    bsum, cnt, p = 0, 0, 1.0\n    for i, s in enumerate(senators):\n        if votes & (1 << i):\n            p *= (s[1] + bribe[i]) / 100\n            cnt += 1\n        else:\n            p *= (100 - s[1] - bribe[i]) / 100\n            bsum += s[0]\n\n    if cnt > (n / 2):\n        return p\n    else:\n        return p * A / (A + bsum)\n\n\ndef dfs(cur, rk):\n    if cur >= n:\n        if rk > 0:\n            return 0.0\n        sm = 0.0\n        for i in range(1 << n):\n            sm += calc(i)\n\n        return sm\n\n    mx = 0.0\n    for i in range(rk + 1):\n        if i * 10 + senators[cur][1] > 100:\n            break\n        bribe[cur] = i * 10\n        tmp = dfs(cur+1, rk-i)\n        mx = max(tmp, mx)\n    return mx\n\n\nprint(dfs(0, min(k, mx_bribe)))\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "'''\n    Auther: ghoshashis545 Ashis Ghosh\n    College: jalpaiguri Govt Enggineering College\n\n'''\nfrom os import path\nimport sys\nfrom heapq import heappush,heappop,heapify\nfrom functools import cmp_to_key as ctk\nfrom collections import deque,defaultdict as dd \nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input().rstrip()\ndef mi():return map(int,input().split())\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\nmod=1000000007\n# mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef bo(i):\n    return ord(i)-ord('a')\n\nfile=1\n\n\ndef solve():\n\n    # for t in range(ii()):\n\n    n,q=mi()\n\n    x=int(log(n+1,2))\n    root=1<<(x-1)\n    for i in range(q):\n        u=ii()\n        s=si()\n        pos='U'\n        if(u<root):\n            pos='L'\n        if(u>root):\n            pos='R'\n\n        s1=bin(u)[2:]\n        s1='0'*(x-len(s1))+s1\n        s1=list(s1)\n        for j in s:\n            for k in range(x-1,-1,-1):\n                if s1[k]=='1':\n                    f=k\n                    break\n            if j=='L':\n                if(f==x-1):\n                    continue\n                s1[f]='0'\n                s1[f+1]='1'\n            elif(j=='R'):\n                if(f==x-1):\n                    continue\n                s1[f+1]='1'\n            else:\n                if f==0:\n                    continue\n                if s1[f-1]=='1':\n                    s1[f]='0'\n                else:\n                    s1[f-1]='1'\n                    s1[f]='0'\n            # print(s1)\n        s1=\"\".join(s1)\n        print(int(s1,2))\n    \n    \n    \n    \n    \n    \n    \n    \n        \n\n        \n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n        \nif __name__ ==\"__main__\":\n\n    if(file):\n\n        if path.exists('input.txt'):\n            sys.stdin=open('input.txt', 'r')\n            sys.stdout=open('output.txt','w')\n        else:\n            input=sys.stdin.readline\n    solve()", "complexity": "np", "problem": "0792_D", "from": "CODEFORCES", "tags": "bitmasks,trees"}
{"src": "rd = lambda: map(int, input())\ndef f(n, t):\n    a = sum(i + j & 1 == x for i in range(n) for j, x in enumerate(rd()))\n    if t < 3:\n        rd()\n    return a\nn = int(input())\nm = sorted([f(n, i) for i in range(4)])\nprint(2 * n * n + m[0] + m[1] - m[2] - m[3])\n", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "n,k=map(int,input().split())\nif n>=k:\n    print((k-1)//2)\nelif n*2>k:\n    print(n-k//2)\nelse: print(0)\n", "complexity": "constant", "problem": "1023_B", "from": "CODEFORCES", "tags": "math"}
{"src": "n, v = map(int, input().split())\nb = 0\nans = 0\nsss = 0\nfor i in range(1, n + 1):\n    while b < v:\n        if sss == n - 1:\n            break\n        sss += 1\n        ans += i\n        b += 1\n    b -= 1\nprint(ans)", "complexity": "quadratic", "problem": "1113_A", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "# cook your dish here\nn,m,k = map(int,input().split())\nwh=[]\n#for left to right connections\nfor j in range(n):\n    l=list(map(int,input().split()))\n    wh.append(l)\n    \nwv=[]\n#for top to bottom connections\nfor j in range(n-1):\n    l=list(map(int,input().split()))\n    wv.append(l)\n    \nif(k%2!=0):\n    ans = [[-1 for _ in range(m)]for j in range(n)]\n    for res in ans:\n        print(*res)\nelse:\n    dp = [[[0 for i in range(25)]for j in range(505)]for q in range(505)]\n    for x in range(1,k+1):\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                dp[i][j][x]=1234567890\n                if(i!=n):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1]+wv[i-1][j-1])\n                if(i!=1):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1]+wv[i-2][j-1])\n                if(j!=m):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1]+wh[i-1][j-1])\n                if(j!=1):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1]+wh[i-1][j-2])\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            ans = 1234567890\n            for x in range(1,k+1):\n                if(k%x==0 and (k//x)%2==0 ):\n                    ans = min(ans,dp[i][j][x]*(k//x))\n            print(ans,end=\" \")\n        print()", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "n,m = map(int,input().split())\nfinal = []\nfor i in range(n):\n    a,b = map(int,input().split())\n    final.append([a,b])\nfinal.sort(key = lambda x: x[0]-x[1])\ns1 = 0\ns2 = 0\nfor i in final:\n    s2+=i[1]\n    s1+=i[0]\nif s2>m:\n    print(-1)\nelse:\n    if s1<=m:\n        print(0)\n    else:\n        i = n-1\n        count = 0\n        while s1>m:\n            s1 = s1 - (final[i][0]-final[i][1])\n            count+=1\n            i-=1\n        print(count)\n", "complexity": "nlogn", "problem": "1015_C", "from": "CODEFORCES", "tags": "sortings"}
{"src": "from collections import defaultdict\nfrom math import gcd\nfrom heapq import heappop, heappush\nn = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nhp = [(0, 0)]\ndis = {0: 0}\nseen = set()\nwhile hp:\n    _, x = heappop(hp)\n    if x == 1:\n        print(dis[x])\n        break\n    if x in seen: continue\n    seen.add(x)\n    for a, b in zip(A, B):\n        y = gcd(x, a)\n        if y not in dis or dis[y] > dis[x] + b:\n            dis[y] = dis[x] + b\n            heappush(hp, (dis[y], y))\nelse:\n    print(-1)", "complexity": "np", "problem": "0510_D", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,math"}
{"src": "import os\nimport heapq\nimport sys, threading\nimport math\nimport bisect\nimport operator\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 5)\nfrom io import BytesIO, IOBase\n\n\ndef gcd(a, b):\n    if b == 0:\n\n        return a\n    else:\n        return gcd(b, a % b)\n\n\ndef power(x, p, m):\n    res = 1\n    while p:\n        if p & 1:\n            res = (res * x) % m\n        x = (x * x) % m\n        p >>= 1\n    return res\n\n\ndef inar():\n    return [int(k) for k in input().split()]\n\n\ndef lcm(num1, num2):\n    return (num1 * num2) // gcd(num1, num2)\nrr=0\ngg=0\nbb=0\ndp=[]\ndef func(x,y,z,red,green,blue):\n    if (x>=rr and y>=gg) or (y>=gg and z>=bb) or (x>=rr and z>=bb):\n        return 0\n    if dp[x][y][z]!=-1:\n        return dp[x][y][z]\n    take=0\n    if x<rr and y<gg:\n        take=max(take,red[x]*green[y]+func(x+1,y+1,z,red,green,blue))\n    if y<gg and z<bb:\n        take=max(take,green[y]*blue[z]+func(x,y+1,z+1,red,green,blue))\n    if x<rr and z<bb:\n        take=max(take,red[x]*blue[z]+func(x+1,y,z+1,red,green,blue))\n    dp[x][y][z]=take\n    return take\n\ndef main():\n    global rr,gg,bb,dp\n    # t=int(input())\n    for i in range(202):\n        temp=[]\n        for j in range(202):\n            lis=[]\n            for k in range(202):\n                lis.append(-1)\n            temp.append(lis)\n        dp.append(temp)\n    rr, gg, bb = map(int, input().split())\n    red = inar()\n    green = inar()\n    blue = inar()\n    red.sort(reverse=True)\n    green.sort(reverse=True)\n    blue.sort(reverse=True)\n    print(func(0,0,0,red,green,blue))\n\n\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()\n    # threadin.Thread(target=main).start()\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "# from typing import List, Set, Dict, Tuple, Text, Optional\nfrom collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__  # type: ignore\n\n#########\n# INPUT #\n#########\n\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n    # type: () -> str\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\n##########\n# OUTPUT #\n##########\n\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n    # type: (str) -> None\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n    # type: (str) -> None\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\n###########\n# LIBRARY #\n###########\n\n\ndef bootstrap(f, stack=[]):\n  # Deep Recursion helper.\n  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst\n  # Usage:\n\n  # @bootstrap\n  # def recur(n):\n  #   if n == 0:\n  #     yield 1\n  #   yield (yield recur(n-1)) * n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\n\n'''\narrayInit([3, 4, 5], 0):\nInitialize 3-dim array with [3][4][5] with 0 as its initial value\n\nTested with:\nhttps://codeforces.com/contest/625/problem/B\n'''\n\n\nclass MDArray(object):\n  # Faster implementation of md array, using a single array and a lot of math.\n  '''\n  >>> x = MDArray([1, 2, 5], 5)\n  >>> x.get([0, 0, 0])\n  5\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.set([0, 1, 2], 3)\n  3\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.set([0, 1, 3], 1)\n  1\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.get([0, 1, 3])\n  1\n  '''\n\n  def __init__(self, dimensions, initial_value=0):\n    # type: (Iterable[int], Any) -> None\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n    # type: (Iterable[int]) -> Any\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n    # type: (Iterable[int], Any) -> Any\n    self.arr[self._index(indexes)] = value\n    return value\n\n\n#########\n# LOGIC #\n#########\n\ndef encode(row, col, n, m):\n  return row * m + col\n\n\ndef solve(node, remain, adj, dp):\n  if remain == 0:\n    return 0\n  key = (node, remain)\n  mem = dp.get(key)\n  if mem != -1:\n    return mem\n\n  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))\n  dp.set(key, ans)\n  return ans\n\n\ndef main(inp, out):\n  # type: (Input, Output) -> any\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = [-1] * (n*m*(k/2+1))\n\n  for i in range(n*m):\n    dp[i] = 0\n\n  for t in range(1, k/2+1):\n    for i in range(n*m):\n      ans = min(map(lambda x: dp[x[0]+((t-1)*n*m)] + x[1], adj[i]))\n      dp[i+(t*n*m)] = ans\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(dp[node+(k/2*n*m)] * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\n\n###############\n# BOILERPLATE #\n###############\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from sys import stdin, stdout\nnmbr = lambda: int(input())\nlst = lambda: list(map(int, input().split()))\nfor _ in range(1):#nmbr()):\n    n, cur, l, r=lst()\n    if l==1 and r==n:\n        print(0)\n    elif l==1 and r!=n:\n        print(abs(r-cur)+1)\n    elif r==n and l!=1:\n        print(abs(cur-l)+1)\n    else:\n        disa=abs(l-cur)\n        disb=abs(r-cur)\n        ans=min(disa, disb) + (r-l) +2\n        print(ans)\n\n", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "test=int(input())\nwhile test:\n\ttest=test-1\n\tn,k = input().split()\n\tn=int(n)\n\tk=int(k)\n\ts=0\n\tcurr=1\n\tct=0\n\twhile s<k:\n\t\ts=s+curr\n\t\tcurr=4*curr\n\t\tct=ct+1\n\tif n>=35:\n\t\tprint(\"YES\",n-1)\n\t\tcontinue\n\tval=[]\n\tval.append(0)\n\tfor i in range(1,n):\n\t\tval.append(1+4*val[i-1])\n\ts=0\n\tt=2\n\trem=0\n\twhile n>0:\n\t\ts=s+t-1\n\t\tt*=2\n\t\tp=3\n\t\trem=rem+(t-3)*(val[n-1])\n\t\trem=int(rem)\n\t\tif rem+s>=k and s<=k:\n\t\t\tprint(\"YES\",n-1)\n\t\t\tn=-2\n\t\t\tbreak\n\t\tn=n-1\n\tif n != -2:\n\t\tprint(\"NO\")", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "from collections import defaultdict\nn=int(input())\na=list(map(int, input().split()))\n\nd=defaultdict(int)\ncnt=0\n\nfor i in range(n):\n    d[a[i]]+=1\n\nfor i in range(n):\n    f=0\n    for j in range(1,31):\n        p=2**j-a[i]\n        if p<=0:\n            continue\n        if p!=a[i]:\n            if d[p]>=1:\n                f=1\n        else:\n            if d[p]>=2:\n                f=1\n    if not f:\n        cnt+=1\nprint(cnt)\n", "complexity": "nlogn", "problem": "1005_C", "from": "CODEFORCES", "tags": "brute force,greedy,implementation"}
{"src": "x, y, z, t1, t2, t3 = map(int, input().split())\n\ntp = abs(x - y) * t1\npt = (abs(x - y) + abs(x - z)) * t2 + t3 + t3 + t3\nif tp >= pt:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "constant", "problem": "1054_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def pow2(n):\n    j=0\n    while(n%2==0):\n        n//=2\n        j+=1\n    return j    \nn,q=map(int,input().split())\nfor j in range(q):\n    u=int(input())\n    s=input()\n    for k in range(len(s)):\n        num=pow2(u)\n        if(s[k]==\"R\" and num!=0):\n            u=u+2**(num-1)\n        elif(s[k]==\"L\" and num!=0):\n            u=u-2**(num-1)\n        elif(s[k]==\"U\" and u!=(n+1)//2):\n            m1=u+2**(num)\n            m2=u-2**(num)\n            if(pow2(m1)==(num+1)):\n                u=m1\n            else:\n                u=m2\n    print(u)                ", "complexity": "np", "problem": "0792_D", "from": "CODEFORCES", "tags": "bitmasks,trees"}
{"src": "import sys\n\nmod = 998244353\nMAX_LENGTH = 20\nbound = [0] * MAX_LENGTH\n\ndef mul(a, b): return (a * b) % mod\ndef add(a, b):\n    a += b\n    if a < 0: a += mod\n    if a >= mod: a -= mod\n    return a\n\ndef digitize(num):\n    for i in range(MAX_LENGTH):\n        bound[i] = num % 10\n        num //= 10\n\ndef rec(smaller, start, pos, mask):\n    global k\n    if bit_count[mask] > k:\n        return [0, 0]\n    if pos == -1:\n        return [0, 1]\n\n    # if the two following lines are removed, the code reutrns correct results\n    if dp[smaller][start][pos][mask][0] != -1:\n        return dp[smaller][start][pos][mask]\n\n    res_sum = res_ways = 0\n    for digit in range(0, 10):\n        if smaller == 0 and digit > bound[pos]:\n            continue\n        new_smaller = smaller | (digit < bound[pos])\n        new_start = start | (digit > 0) | (pos == 0)\n        new_mask = (mask | (1 << digit)) if new_start == 1 else 0\n\n        cur_sum, cur_ways = rec(new_smaller, new_start, pos - 1, new_mask)\n        res_sum = add(res_sum, add(mul(mul(digit, ten_pow[pos]), cur_ways), cur_sum))\n        res_ways = add(res_ways, cur_ways)\n\n    dp[smaller][start][pos][mask][0], dp[smaller][start][pos][mask][1] = res_sum, res_ways\n    return dp[smaller][start][pos][mask]\n\ndef solve(upper_bound):\n    global dp\n    dp = [[[[[-1, -1] for _ in range(1 << 10)] for _ in range(MAX_LENGTH)] for _ in range(2)] for _ in range(2)]\n    digitize(upper_bound)\n    ans = rec(0, 0, MAX_LENGTH - 1, 0)\n    return ans[0]\n\ninp = [int(x) for x in sys.stdin.read().split()]\nl, r, k = inp[0], inp[1], inp[2]\n\nbit_count = [0] * (1 << 10)\nfor i in range(1, 1 << 10): bit_count[i] = bit_count[i & (i - 1)] + 1\nten_pow = [1]\nfor i in range(MAX_LENGTH): ten_pow.append(mul(ten_pow[-1], 10))\n\nprint(add(solve(r), -solve(l - 1)))\n", "complexity": "cubic", "problem": "1073_E", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,math"}
{"src": "def solve(n, a):\n    a = sorted(a)\n    if n == 1:\n        return a[0] > 0 and a[0] % 2 == 1\n    same_count = 0\n    for i in range(n - 1):\n        if a[i] == a[i + 1] == 0:\n            return False\n        if i < n - 2 and a[i] + 1 == a[i + 1] == a[i + 2]:\n            return False\n        if a[i] == a[i + 1]:\n            same_count += 1\n    if same_count > 1:\n        return False\n    return (sum(a) - n * (n - 1) // 2) % 2 == 1\n\n\n\nassert not solve(1, [0])\nassert not solve(2, [1, 0])\nassert solve(2, [2, 2])\nassert solve(3, [2, 3, 1])\nassert not solve(4, [1, 1, 2, 2])\nassert solve(4, [1, 1, 2, 3])\nassert not solve(4, [1, 2, 3, 4])\nassert solve(4, [0, 1, 2, 4])\nassert solve(5, [0, 1, 2, 3, 5])\n\nn = int(input())\na = map(int, input().split())\n\nr = solve(n, a)\nif r:\n\n    print('sjfnb')\nelse:\n    print('cslnb')\n", "complexity": "nlogn", "problem": "1191_D", "from": "CODEFORCES", "tags": "games"}
{"src": "n, pos, l, r=map(int, input().split())\nif l==1 and r==n:\n\tprint(0)\nelif l==1 and r!=n:\n\tprint(abs(pos-r)+1)\nelif l!=1 and r==n:\n\tprint(abs(pos-l)+1)\nelse:\n\tprint(r-l+2+min(abs(pos-l), abs(pos-r)))", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import math\nimport sys\nfrom collections import deque,defaultdict\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\ndef Extended_Euclid(n,m):\n    stack=[]\n    while m:\n        stack.append((n,m))\n        n,m=m,n%m\n    if n>=0:\n        x,y=1,0\n    else:\n        x,y=-1,0\n    for i in range(len(stack)-1,-1,-1):\n        n,m=stack[i]\n        x,y=y,x-(n//m)*y\n    return x,y\n\nclass MOD:\n    def __init__(self,p,e=1):\n        self.p=p\n        self.e=e\n        self.mod=self.p**self.e\n\n    def Pow(self,a,n):\n        a%=self.mod\n        if n>=0:\n            return pow(a,n,self.mod)\n        else:\n            assert math.gcd(a,self.mod)==1\n            x=Extended_Euclid(a,self.mod)[0]\n            return pow(x,-n,self.mod)\n\n    def Build_Fact(self,N):\n        assert N>=0\n        self.factorial=[1]\n        self.cnt=[0]*(N+1)\n        for i in range(1,N+1):\n            ii=i\n            self.cnt[i]=self.cnt[i-1]\n            while ii%self.p==0:\n                ii//=self.p\n                self.cnt[i]+=1\n            self.factorial.append((self.factorial[-1]*ii)%self.mod)\n        self.factorial_inv=[None]*(N+1)\n        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)\n        for i in range(N-1,-1,-1):\n            ii=i+1\n            while ii%self.p==0:\n                ii//=self.p\n            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod\n\n    def Fact(self,N):\n        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod\n\n    def Fact_Inv(self,N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inv[N]\n\n    def Comb(self,N,K,divisible_count=False):\n        if K<0 or K>N:\n            return 0\n        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod\n        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]\n        if divisible_count:\n            return retu,cnt\n        else:\n            retu*=pow(self.p,cnt,self.mod)\n            retu%=self.mod\n            return retu\n\ndef Bell_Numbers(N,mod,prime=False):\n    bell_numbers=[0]*(N+1)\n    bell_numbers[0]=1\n    MD=MOD(mod)\n    if prime:\n        MD.Build_Fact(min(mod-2,N-1))\n        for i in range(1,min(mod,N+1)):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n        for i in range(mod,N+1):\n            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod\n    else:\n        MD.Build_Fact(N-1)\n        for i in range(1,N+1):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n    return bell_numbers\n\nM,N=map(int,readline().split())\nS=[readline().rstrip() for i in range(N)]\ndct=defaultdict(int)\nfor i in range(M):\n    tpl=()\n    for j in range(N):\n        tpl+=(S[j][i],)\n    dct[tpl]+=1\nans=1\nmod=10**9+7\nbell=Bell_Numbers(M,mod)\nfor c in dct.values():\n    ans*=bell[c]\n    ans%=mod\nprint(ans)", "complexity": "quadratic", "problem": "0908_E", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,math"}
{"src": "def find(a,b):\n    cc=2\n    for i in range(1,(1<<len(a))):\n        sx=0\n        minn=100000000\n        maxn=-1\n        for j in range(0,len(a)):\n            if(i &(1<<j)):\n                sx+= a[j];\n                minn = min(minn, a[j])\n                maxn = max(maxn, a[j])\n        if(sx>=b[1] and sx<=b[2] and (maxn-minn)>=b[3]):\n            cc+=1\n    if(cc<2):\n        return 2\n    else:\n        return cc-2\n\n\n\n\n\nb=list(map(int,input().split()))\na=list(map(int,input().split()))\nprint(find(a,b))\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import sys\nimport math\ninput = sys.stdin.readline\nfor _ in range(1):\n    n,pos,l,r = map(int,input().split())\n    if l == 1 and r == n:\n        print(0)\n        continue\n\n    if l != 1 and r != n:\n        ans = min(abs(l-pos),abs(r-pos))+2+abs(r-l)\n\n    else:\n        if l == 1:\n            ans = abs(pos-r)+1\n\n        else:\n            ans = abs(pos-l)+1\n\n    print(ans)", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\nf0= 0\nf1 = 1\nli = [0,1]\nfor i in range(45):\n\tt = f1\n\tf1 += f0\n\tf0 = t\n\tli.append(f1)\nx = []\nfor i in range(3):\n\tfor i in range(len(li)-1, -1, -1):\n\t\tif li[i] <= n:\n\t\t\tn -= li[i]\n\t\t\tx.append(li[i])\n\t\t\tbreak\nif n == 0:\n\tprint(*x, sep = \" \")\nelse:\n\tprint(\"I'm too stupid to solve this problem\")\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import sys\n\n\ndef prepare():\n    stack = [i for i in range(n) if deg[i] == 0]\n    cnt = 0\n    while stack:\n        v = stack.pop()\n        cnt += 1\n        for dest in adj[v]:\n            deg[dest] -= 1\n            if deg[dest] == 0:\n                stack.append(dest)\n        adj[v].clear()\n\n    return cnt == n\n\n\ndef solve(st):\n    stack = [st]\n    visited = [0]*n\n    cnt = 0\n    while stack:\n        v = stack.pop()\n        cnt += 1\n        for dest in adj[v]:\n            if dest == st:\n                continue\n            visited[dest] += 1\n            if deg[dest] == visited[dest]:\n                stack.append(dest)\n\n    return cnt == m\n\n\nn, m = map(int, sys.stdin.buffer.readline().decode('utf-8').split())\nadj = [[] for _ in range(n)]\nrev = [[] for _ in range(n)]\ndeg = [0]*n\nfor u, v in (map(int, line.decode('utf-8').split()) for line in sys.stdin.buffer):\n    adj[u-1].append(v-1)\n    rev[v-1].append(u-1)\n    deg[v-1] += 1\n\nok = prepare()\nif ok:\n    print('YES')\n    exit()\n\nm = len([1 for i in range(n) if deg[i] > 0])\nfor i in range(n):\n    if deg[i] == 1 and solve(i):\n        print('YES')\n        exit()\n\nprint('NO')\n", "complexity": "quadratic", "problem": "0915_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs"}
{"src": "def f(n,s):\n    d=[-n,-n];\n    d[s]=0;\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)];\n    return d[s];\nimport math;\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny=y+x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "def GSB(x):\n\tcounter=0\n\twhile x!=0:\n\t\tcounter+=1\n\t\tx=x>>1\n\treturn counter\n\t\nproblems,minimum,maximum,difference=[int(x) for x in input().split()]\narray=[int(x) for x in input().split()]\ncombinations=[int(x) for x in range(2**problems)]\ntotal=0\n\nfor i in combinations:\n\tchecker=[x for x in array]+['a']\n\tj=0\n\tz=GSB(i)\n\tcheck=1\n\twhile j!=z and i!=0:\n\t\tif i&1==1:\n\t\t\tchecker[j]='a'\n\t\t\tcheck+=1\n\t\ti=i>>1\n\t\tj+=1\n\tfor i in range(check):\n\t\tchecker.remove('a')\n\tchecker.sort()\n\tif minimum<=sum(checker)<=maximum and len(checker)>=2 and checker[-1]-checker[0]>=difference:\n\t\ttotal+=1\nprint(total)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "n=int(input())\nif(n>=0):\n    print(n)\nelse:\n    n=abs(n)\n    rem=n%10\n    n1=n//10\n    n2=n1//10\n    n2=n2*10+rem\n    k=min(n1,n2)\n    print(-1*k)\n    \n    \n    \n    \n    \n    \n    \n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "n=int(input())+1\nif n<2:\n    print(0)\nelif n%2==0:\n    print(n//2)\nelse:\n    print(n)", "complexity": "constant", "problem": "0979_A", "from": "CODEFORCES", "tags": "math"}
{"src": "yellow, blue = map(int, input().split())\ny, g, b = map(int, input().split())\n\ncount = 0\n\nyt = y * 2 + g\nbt = g + b * 3\n\nyc = yellow - yt\nif yc < 0:\n    count += abs(yc)\n\nbc = blue - bt\nif bc < 0:\n    count += abs(bc)\n\nprint(count)\n\n\n\n\n\n# while True:\n#     if yellow > 0:\n#         y = ny * 2\n#         yellow -= y\n#         yellow = yellow - g\n#         break\n#     else:\n#         yellow += 1\n#         count += 1\n#         break\n#\n# while True:\n#     if blue > 0:\n#         blue = blue - g\n#         nb = nb * 3\n#         blue = blue - nb\n#         break\n#     else:\n#         blue += 1\n#         count += 1\n#         break\n#\n# print(count)\n", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\n\nL = list(map(int, input().split(\" \")))\nR = list(map(int, input().split(\" \")))\n\nLR = list(zip(L,R))\n\nindex_to_candies = {}\ncandy = n\n\nfor nn in range(n,0,-1):\n    if(len(index_to_candies) == n):\n        break\n\n    #print(index_to_candies)\n    #print(LR)\n\n    zero_index = []\n    for idx, (l,r) in enumerate(LR):\n        if (l,r) == (0,0) and not idx in index_to_candies:\n            index_to_candies[idx] = nn\n            zero_index.append(idx)\n\n    if len(zero_index) == 0:\n        print(\"NO\")\n        exit()\n\n    dec_left = 0\n    dec_right = len(zero_index)\n    zero_index_idx = 0\n\n    for idx, (l,r) in enumerate(LR):\n        if zero_index_idx < len(zero_index) and zero_index[zero_index_idx] == idx:\n    #        print(idx)\n            zero_index_idx += 1\n            dec_left += 1\n            dec_right -= 1\n\n        if (l,r) != (0,0):\n            LR[idx] = (l-dec_left,r-dec_right)\n            if LR[idx][0] < 0 or LR[idx][1] < 0:\n                print(\"NO\")\n                exit()\nprint(\"YES\")\nj = []\nfor i in range(n):\n    j.append(str(index_to_candies[i]))\nprint(\" \".join(j))\n", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "x, y, z, t1, t2, t3 = [int(i) for i in input().split()]\nif abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "constant", "problem": "1054_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n,m,k = [int(w) for w in input().split()]\na = [int(w) for w in input().split()]\n\ndef f(o):\n    r = e = 0\n    for i, x in enumerate(a):\n        if i < o:\n            continue\n        if i % m == o:\n            e -= k\n            if e < -k:\n                e = -k\n        e += x\n        if e > r:\n            r = e\n    return r\n\nprint(max(f(o) for o in range(m)))\n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "n=int(input())\ns=['Power','Time','Space','Soul','Reality','Mind']\nfor _ in range(n):\n    i=input()\n    if(i=='purple'):\n        s.remove('Power')\n    elif(i=='green'):\n        s.remove('Time')\n    elif(i=='blue'):\n        s.remove('Space')\n    elif(i=='orange'):\n        s.remove('Soul')\n    elif(i=='red'):\n        s.remove('Reality')\n    elif(i=='yellow'):\n        s.remove('Mind')\nprint(len(s))\nfor i in range(len(s)):\n    print(s[i])\n    ", "complexity": "constant", "problem": "0987_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n=int(input())\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\ncandies=[]\nfor i in range(n):\n    candies.append(n-l[i]-r[i])\nleft=[]\nfor i in range(n):\n    guys=0\n    for j in range(i):\n        if candies[j]>candies[i]:\n            guys+=1\n    left.append(guys)\nright=[]\nfor i in range(n):\n    guys=0\n    for j in range(i,n):\n        if candies[j]>candies[i]:\n            guys+=1\n    right.append(guys)\nif left==l and right==r:\n    print(\"YES\")\n    candiesstr=\"\"\n    for i in range(n):\n        candiesstr+=str(candies[i])+\" \"\n    print(candiesstr[:len(candiesstr)-1])\nelse:\n    print(\"NO\")", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn,m = map(int,input().split())\n\nA = [None]*n\nlo,hi = 1<<32,-1<<32\nfor i in range(n):\n    A[i] = list(map(int,input().split()))\n    lo = min(min(A[i]), lo)\n    hi = max(max(A[i]), hi)\n\nbest = -1\nans = [-1,-1]\n\ndef possible(x):\n    global best, ans\n    # is the answer at least x?\n    M = [-1]*(1<<m)\n\n    for i in range(n):\n        mask = 0\n        for j in range(m):\n            if A[i][j] >= x:\n                mask += (1<<j)\n        M[mask] = i\n\n    for m0 in range(1<<m):\n        if M[m0] == -1:\n            continue\n\n        for m1 in range(1<<m):\n            if M[m1] == -1:\n                continue\n\n            if m0 | m1 == (1<<m) - 1:\n                if best < x:\n                    best = x\n                    ans = [M[m0]+1, M[m1]+1]\n\n                return True\n    return False\n\npossible(hi)\npossible(lo)\n\nwhile lo+1 < hi:\n    mid = (lo+hi)//2\n    if possible(mid):\n        lo = mid\n    else:\n        hi = mid\n\nprint(*ans)\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "from functools import lru_cache\n\nP = 10**9+7\nN, T = map(int, input().split())\nA = [[], [], []]\nX = []\nfor _ in range(N):\n    t, g = map(int, input().split())\n    X.append((t, g))\n\n@lru_cache(maxsize=None)\ndef calc(x, pr, t):\n    if t < 0:\n        return 0\n    if t == 0:\n        return 1\n    if x == 0:\n        return 0\n    \n    ans = 0\n    for i in range(15):\n        if x & (1<<i):\n            if X[i][1] != pr:\n                y = x ^ (1<<i)\n                ans = (ans + calc(y, X[i][1], t-X[i][0])) % P\n    return ans\n    \nprint(calc(2**N-1, -1, T))", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nlst = []\nfor i in range(len(a)):\n    if (a[i] in b):\n        lst.append(a[i])\nif (len(lst) == 0):\n    pass\nelse:\n    print(*lst)\n", "complexity": "quadratic", "problem": "0994_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n,k = [int(s) for s in input().split()]\np = [int(s) for s in input().split()]\n\nmap = {}\nres = []\n\nfor pi in p:\n    if map.get(pi) is None:\n        key = pi\n        for j in range(pi, pi-k, -1):\n            if j < 0: break\n            if map.get(j) is None:\n                key = j\n            else:\n                if map[j] >= pi-k+1: key = map[j]\n                break\n        for j in range(pi, key-1, -1):\n            if map.get(j):\n                break\n            map[j] = key\n    res.append(map[pi])\n\nprint(*res, sep=\" \")\n", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "# Problem G\n\nnum = input()\nnum_list = []\nfor i in range(len(num)):\n  num_list.append(int(num[i]))\nmyMod = (10 ** 9) + 7\nlength = len(num_list)\nf = [0] * (length + 1)\nt = [1] * (length + 1)\nfor i in range(length):\n    f[i+1] = (f[i] * 10 + 1) % myMod\n    t[i+1] = (t[i] * 10) % myMod\nans = 0\nfor i in range(1, 10):\n    dp = [0] * (length + 1)\n    for j in range(length):\n        dp[j+1] = (dp[j] * i + (10 - i) * (dp[j] * 10 + t[j])) % myMod\n    c = 0\n    ctr = 0\n    for k in num_list:\n        z = min(i, k)\n        o = k - z\n        ans += o * (dp[length-1-ctr] * t[c+1] + f[c+1] * t[length-1-ctr]) % myMod\n        ans += z * (dp[length-1-ctr] * t[c] + f[c] * t[length-1-ctr]) % myMod\n        ans %= myMod\n        c += k >= i\n        ctr += 1\n    ans += f[c]\n    if ans >= myMod:\n        ans -= myMod\nprint(ans)\n \t     \t \t\t\t\t   \t  \t \t\t \t  \t\t", "complexity": "quadratic", "problem": "0908_G", "from": "CODEFORCES", "tags": "dp,math"}
{"src": "import sys, string\n\ndef swap(i, j):\n    temp = a[i]\n    a[i] = a[j]\n    a[j] = temp\n\nn = int(sys.stdin.readline())\na = list(sys.stdin.readline().rstrip())\nb = list(sys.stdin.readline().rstrip())\nres_a = dict().fromkeys(list(string.ascii_lowercase), 0)\nres_b = dict().fromkeys(list(string.ascii_lowercase), 0)\n\nfor i in a:\n    res_a[i] += 1\nfor i in b:\n    res_b[i] += 1\n\ncan = True\nfor i in res_a:\n    if res_a[i] != res_b[i]:\n        can = False\n        break\nif not can:\n    print(-1)\nelse:\n    ans = []\n    for i in range(n):\n        if a[i] == b[i]:\n            continue\n        else:\n            idx = -1\n            for j in range(i + 1, n):\n                if a[j] == b[i]:\n                    idx = j\n                    break\n            for j in range(idx, i, -1):\n                ans.append(j)\n                swap(j, j - 1)\n    print(len(ans))\n    print(' '.join(map(str, ans)))\n\n", "complexity": "quadratic", "problem": "1015_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def maxx(n):\n\treturn n&-n\nn,q=map(int,input().split())\nroot=n//2+1\nwhile q>0:\n\tx=int(input())\n\ts=input()\n\n\tfor i in s:\n\t\tif i=='U' and x!=root:\n\t\t\tp=x+maxx(x)\n\t\t\tif x==p-maxx(p)//2:\n\t\t\t\tx=p\n\t\t\telse:\n\t\t\t\tx=x-maxx(x)\n\t\telif i=='L':\n\t\t\tx=x-maxx(x)//2\n\t\telif i=='R':\n\t\t\tx=x+maxx(x)//2\n\tq=q-1\n\tprint(x)", "complexity": "np", "problem": "0792_D", "from": "CODEFORCES", "tags": "bitmasks,trees"}
{"src": "import math\ns1 = input().strip()\ns2 = input().strip()\nps1 = 0\nms1 = 0\nps2 = 0\nms2 = 0\nqs2 = 0\nfor i in s1:\n    if i=='+':\n        ps1+=1\n    if i=='-':\n        ms1+=1\nfor i in s2:\n    if i=='+':\n        ps2+=1\n    if i=='-':\n        ms2+=1\n    if i == '?':\n        qs2+=1\nif ps2<=ps1 and ms2<=ms1:\n    print(math.factorial(qs2)/math.factorial(ps1-ps2)/math.factorial(ms1-ms2)*(0.5**qs2))\nelse:\n    print(0.00000000)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "m = int(input())\n\nb = []\nk = []\nfor i in range(m):\n    x = int(input())\n    c = 0\n    for j in range(len(b)):\n        v = b[j]\n        d = k[j]\n        if (x ^ v) < x:\n            x ^= v\n            c ^= d\n\n    if x != 0:\n        print(0)\n        c ^= 2 ** i\n        b.append(x)\n        k.append(c)\n    else:\n        a = []\n        for j in range(m):\n            if c & 1 == 1:\n                a.append(j)\n            c >>= 1\n        print(len(a), end='')\n        for v in a:\n            print(' ', v, sep='', end='')\n        print()\n", "complexity": "np", "problem": "0504_D", "from": "CODEFORCES", "tags": "bitmasks"}
{"src": "#n=int(input())\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\ndef next(k,a):\n    i=k+1\n    while a[i]!=1: i+=1\n    return i\n\nans=[0]*(m+1)\n\nk=-1\nk=next(k,b)\nans[1]=k\nfor i in range(2,m+1):\n    kk=next(k,b)\n    for j in range(k+1,kk):\n        if a[j]-a[k]<=a[kk]-a[j]:\n            ans[i-1]+=1\n        else:\n            ans[i]+=1\n    k=kk\n    \n\nans[m]+=(n+m-1-k)\n\nfor i in range(1,m+1):\n    print(ans[i],end=' ')\n", "complexity": "quadratic", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import sys\n\ninput = sys.stdin.readline\n\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef lcm(a, b):\n    return (a * b) / gcd(a, b)\n\ndef main():\n    n,r=map(int, input().split())\n    a=list(map(int, input().split()))\n    ans=[]\n    ans.append(r)\n    for i in range(1,n):\n        ymax=r\n        for j in range( i):\n            if abs(a[j]-a[i])<=2*r:\n                ymax=max(ymax, ans[j]+(4*r*r-(a[i]-a[j])**2)**0.5)\n        ans.append(ymax)\n    print(*ans)\n    # for i in range(15):\n    #     print(x[i],end=' ')\n\n\n\n\n\n\n\n\n\n\n\n\n\n    return\n\nif __name__==\"__main__\":\n    main()\n\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "x1, y1, x2, y2, x3, y3 = map(int, input().split())\nrect1 = [x1, y1]\nrect2 = [x2, y2]\nrect3 = [x3, y3]\ndef func():\n    rect11 = [x1, y1]\n    rect22 = [x2, y2]\n    rect33 = [x3, y3]\n    rect1 = [x1, y1]\n    rect2 = [x2, y2]\n    rect3 = [x3, y3]\n\n    recta = [x1, y1]\n    rectb = [x2, y2]\n    rectc = [x3, y3]\n    for i in rect11:\n        for ii in rect22:\n            for iii in rect33:\n                if i==ii:\n                    rect1.remove(i)\n                    rect2.remove(ii)\n                    if rect1[0]+rect2[0]==iii:\n                        rect3.remove(iii)\n                        if i+rect3[0]==iii:\n                            print(iii)\n                            for j in range(iii):\n                                if j<rect1[0]:\n                                    print(\"C\"*rect3[0]+\"A\"*i)\n                                else:\n                                    print(\"C\"*rect3[0]+\"B\"*ii)\n                            exit()\n                rect1=recta.copy()\n                rect2=rectb.copy()\n                rect3=rectc.copy()\n\n                if i==iii:\n                    rect1.remove(i)\n                    rect3.remove(iii)\n                    if rect1[0]+rect3[0]==ii:\n                        rect2.remove(ii)\n                        if i+rect2[0]==ii:\n                            print(ii)\n\n                            for j in range(ii):\n                                if j<rect1[0]:\n                                    print(\"B\"*rect2[0]+\"A\"*i)\n                                else:\n                                    print(\"B\"*rect2[0]+\"C\"*iii)\n                            exit()\n                rect1 = recta.copy()\n                rect2 = rectb.copy()\n                rect3 = rectc.copy()\n                if ii==iii:\n                    rect2.remove(ii)\n                    rect3.remove(iii)\n                    if rect2[0]+rect3[0]==i:\n                        rect1.remove(i)\n                        if i==rect1[0]+ii:\n                            print(i)\n                            for j in range(i):\n                                if j<rect2[0]:\n                                    print(\"A\"*rect1[0]+\"B\"*ii)\n                                else:print(\"A\"*rect1[0]+\"C\"*iii)\n                            exit()\n                rect1=recta.copy()\n                rect2=rectb.copy()\n                rect3=rectc.copy()\n    return print(-1)\nfor i in rect1:\n    for ii in rect2:\n        for iii in rect3:\n            recta = [x1, y1]\n            rectb = [x2, y2]\n            rectc = [x3, y3]\n\n            if i==ii==iii:\n                rect1.remove(i)\n                rect2.remove(i)\n                rect3.remove(i)\n\n            if rect1[0]+rect2[0]+rect3[0]==i:\n                print(i)\n                for j in range(i):\n                    print(\"A\"*rect1[0]+\"B\"*rect2[0]+\"C\"*rect3[0])\n                exit()\n            rect1=recta\n            rect2=rectb\n            rect3=rectc\n\nfunc()\n", "complexity": "np", "problem": "0581_D", "from": "CODEFORCES", "tags": "bitmasks,brute force,constructive algorithms,geometry,implementation,math"}
{"src": "import math\nans = [1, 3, 15, 133, 2025, 37851, 1030367, 36362925]\nn = int(input())\n\nif (n % 2 == 1):\n\tprint(ans[n // 2] * math.factorial(n) % 1000000007)\nelse:\n\tprint(0)", "complexity": "np", "problem": "0285_D", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,implementation,meet-in-the-middle"}
{"src": "n = int(input())\n\na = list(map(int, input().split()))\n\na.sort(reverse=True)\n\ncnt = 0\nwhile a:\n    f = a.pop()\n    rm = []\n    for x in a:\n        if x % f == 0:\n            rm.append(x)\n    for x in rm:\n        a.remove(x)\n    cnt += 1\n\nprint(cnt)\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "def main():\n    n, k = map(int, input().split(' '))\n\n    if(k > 2*n): \n        return(0)\n    if(k == 2*n or k==1): \n        return(2)\n\n    iguales = [0]*(k+1)\n    diferentes = [0]*(k+1)\n\n    iguales[1] = 2\n    diferentes[2] = 2\n\n    modulo = 998244353\n\n    for i in range(1, n):\n        auxigual, auxdiff = [0]*(k+1), [0]*(k+1)\n        for j in range(k):\n            auxigual[j+1] = (iguales[j+1] + iguales[j] + 2*diferentes[j+1]) % modulo\n            if(j >= 1):\n                auxdiff[j+1] = (diferentes[j+1] + diferentes[j-1] + 2*iguales[j]) % modulo\n        \n        iguales = auxigual\n        diferentes = auxdiff\n\n    return((iguales[-1] + diferentes[-1]) % modulo)\n\nprint(main())", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "n = int(input())\nprobs = list()\nfor i in range(n): probs.append(list(map(float, input().split())))\ndp = [list([0 for i in range(1<<n)]) for i in range(n)]\ndp[0][(1<<n)-1] = 1\nak = [list() for i in range(n+1)]\nfor i in range(1<<n):\n    ak[bin(i).count(\"1\")].append(i)\nfor k in range(1, n):\n    for ele in ak[n-k+1]:\n        for j in range(n):\n            if (ele&(1<<j)):\n                for w in range(n):\n                    if (ele&(1<<w)) and j != w:\n                        dp[k][ele-(1<<j)] += (dp[k-1][ele]*probs[w][j])/(((n-k+1)*(n-k))/2)\nfor i in range(n):\n    print(dp[n-1][(1<<i)], end = \" \")\nprint()", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "n=int(input())\nf=[input().strip()==\"f\" for ii in range(n)]\nmod=10**9+7\ndef summ(a,b):\n return (a+b)%mod\ndp=[1]\nfor ii in range(1,n):\n pf=f[ii-1]\n if pf:\n  dp.insert(0,0)\n else:\n  for jj in reversed(range(1,len(dp))):\n   dp[jj-1]=summ(dp[jj-1],dp[jj])\nans=0\nfor vv in dp:\n ans=summ(ans,vv)\nprint(ans)\n\t \t\t       \t\t \t \t \t \t\t\t\t\t  \t\t", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "\ndef naiveSolve():\n    \n    \n    \n    return\n\n\n\ndef main():\n    \n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n,m=readIntArr()\n        grid=[]\n        for __ in range(n):\n            grid.append(readIntArr())\n        columns=[]\n        for col in range(m):\n            temp=[grid[i][col] for i in range(n)]\n            columns.append(temp)\n        \n        valCol=[] # (value, column)\n        for i in range(n):\n            for j in range(m):\n                valCol.append((grid[i][j],j))\n        valCol.sort(reverse=True)\n        \n        # try all possible shifts for top n columns\n        topCols=set()\n        for val,col in valCol:\n            topCols.add(col)\n            if len(topCols)==n:\n                break\n        \n        # try all configurations\n        m2=len(topCols)\n        grid2=[[-1 for __ in range(m2)] for ___ in range(n)]\n        topColsList=list(topCols)\n        for j in range(m2):\n            col=topColsList[j]\n            for i in range(n):\n                grid2[i][j]=grid[i][col]\n        ans=-inf\n        for mask in range(n**m2):\n            grid3=[[-1 for __ in range(m2)] for ___ in range(n)]\n            for col in range(m2):\n                shift=mask%n\n                for row in range(n):\n                    grid3[row][col]=grid2[(shift+row)%n][col]\n                mask//=n\n            tempAns=0\n            for row in range(n):\n                maxx=-inf\n                for col in range(m2):\n                    maxx=max(maxx,grid3[row][col])\n                tempAns+=maxx\n            ans=max(ans,tempAns)\n        allans.append(ans)\n        \n    multiLineArrayPrint(allans)\n    \n    return\n\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(r):\n    print('? {}'.format(r))\n    sys.stdout.flush()\n    return readIntArr()\n \ndef answerInteractive(adj,n):\n    print('!')\n    for u in range(1,n+1):\n        for v in adj[u]:\n            if v>u:\n                print('{} {}'.format(u,v))\n    sys.stdout.flush()\n \ninf=float('inf')\nMOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "n, d, k = map(int, input().split())\n\nif d+1 > n:\n    print('NO')\n    exit()\n\nans = []\ndist = [0]*n\ndeg = [0]*n\nfor i in range(d+1):\n    if i == 0 or i == d:\n        deg[i] = 1\n    else:\n        deg[i] = 2\n    if i != d:\n        ans.append((i+1, i+2))\n    dist[i] = max(i, d-i)\n\nfor i in range(n):\n    if deg[i] > k:\n        print('NO')\n        exit()\n\nfrom collections import deque\nq = deque(list(range(d+1)))\ncur = d+1\nwhile q and cur < n:\n    v = q.popleft()\n    if dist[v] < d and deg[v] < k:\n        deg[v] += 1\n        dist[cur] = dist[v]+1\n        deg[cur] = 1\n        ans.append((v+1, cur+1))\n        q.append(v)\n        q.append(cur)\n        cur += 1\n    else:\n        continue\nif cur != n:\n    print('NO')\nelse:\n    print('YES')\n    for i in range(len(ans)):\n        print(*ans[i])\n", "complexity": "quadratic", "problem": "1003_E", "from": "CODEFORCES", "tags": "constructive algorithms,graphs"}
{"src": "n=int(input())\npieces=[]\nblacks=[0]*4\nwhites=[0]*4\nfor i in range(4):\n    grid=[]\n    for j in range(n):\n        grid.append(input())\n    if i<3:\n        input()\n    count=0\n    for j in range(n):\n        for k in range(n):\n            if (int(grid[j][k])+j+k)%2:\n                count+=1\n    blacks[i]=count\n    whites[i]=n*n-count\nans=4*n*n\nfor white1 in range(3):\n    for white2 in range(white1+1,4):\n        for black1 in range(4):\n            if black1==white1 or black1==white2:\n                continue\n            for black2 in range(black1+1,4):\n                if black2==white1 or black2==white2:\n                    continue\n                ans=min(ans,whites[white1]+whites[white2]+blacks[black1]+blacks[black2])\nprint(ans)", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "n, a, b = map(int, input().split())\nz, o = ('01', '10')[a < b]\nn *= not (a > 1 < b or 1 < n * a * b < 4)\nl = [[z] * n for _ in range(n)]\nfor i in range(n):\n    l[i][i] = '0'\nfor i in range(n - a * b):\n    l[i][i + 1] = l[i + 1][i] = o\nprint(('YES', 'NO')[not n])\nprint('\\n'.join(map(''.join, l)))\n\n  \t\t\t      \t\t \t\t\t \t \t\t  \t\t\t\t\t\t", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "n,m=map(int,input().split())\na=[list('') for x in range(n)]\nb=[list('.'*m) for x in range(n)]\nstart=0\n#end=n-2\nfor i in range(n):\n    a[i]=list(input())\n    if (start==0):\n        if ('.' in a[i]):\n            start=((i-3)//3) *3 \nfor i in range(start):\n    b[i]=list('#'*m)\n#print(start)\nfor i in range(start,n-2):\n    for j in range(m-2):\n        ok=True\n        if a[i][j]=='#':\n            for y in range(i,i+3):\n                if ok==False:\n                    break\n                for x in range(j,j+3):\n                    if not((y==i+1)and(x==j+1)):\n                        if a[y][x]!='#':\n                            #print('lel')\n                            #print(x,y)\n                            ok=False\n                            break                      \n            if ok:\n                for y in range(i,i+3):\n                    for x in range(j,j+3):\n                        if not((y==i+1)and(x==j+1)):   \n                            b[y][x]='#'\n                        \n#for i in a:\n#    print(i)\n#print()\n#for i in b:\n#    print(i)\n    \nif a==b:\n    print('YES')\nelse:\n    print('NO')\n", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
