{"src": "import java.util.*;\npublic class HeatIntense {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tdouble prefix[] = new double[n];\n\t\tint sum = 0;\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tint a = sc.nextInt();\n\t\t\tsum = sum + a;\n\t\t\tprefix[i] = sum ;\n\t\t\t\n\t\t}\n\t\t\n\t\tdouble ans = 0;\n\t\tfor(int i = 0; i<=n-k; i++)\n\t\t{\n\t\t\tfor(int j = i+k-1 ; j<n; j++)\n\t\t\t{\n\t\t\t\tdouble avg = 0;\n\t\t\t\tif(i > 0)\n\t\t\t\t{\n\t\t\t\t\tavg = (prefix[j] - prefix[i-1])/(j-i+1); \n\t\t\t\t\t//System.out.println(prefix[j]- prefix[i-1] + \" \" + avg);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tavg = prefix[j]/(j+1);\n\t\t\t\t//\tSystem.out.println(prefix[j] + \" \" + avg);\n\t\t\t\t}\n\t\t\t\tans = Math.max(avg, ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\n}\n", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "\nimport java.util.Scanner;\n\npublic class A {\n    static long l, r, A, B, C;\n\n    static long GCD(long a, long b) {\n        if (b == 0)\n            return a;\n        return GCD(b, a % b);\n    }\n\n    static boolean gcd(long a, long b) {\n        return GCD(a, b) == 1;\n    }\n\n    static boolean found(long a, long b, long c) {\n        if (b <= a || c <= b)\n            return false;\n        if (a > r || b > r || c > r)\n            return false;\n        if (gcd(a, b) && gcd(b, c) && !gcd(a, c)) {\n            A = a;\n            B = b;\n            C = c;\n            return true;\n        }\n        if (found(a + 1, b + 1, c + 1))\n            return true;\n        if (found(a + 1, b, c + 1))\n            return true;\n        if (found(a + 1, b + 1, c))\n            return true;\n        if (found(a, b, c + 1))\n            return true;\n        if (found(a, b + 1, c + 1))\n            return true;\n        if (found(a, b + 1, c))\n            return true;\n        return found(a + 1, b, c);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        l = sc.nextLong();\n        r = sc.nextLong();\n        if (found(l, l + 1, l + 2))\n            System.out.println(A + \" \" + B + \" \" + C);\n        else\n            System.out.println(-1);\n    }\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\n\n\npublic class Solution implements Runnable {\n\n\n\n\tScanner input;\n\n\tPrintWriter output;\n\n\t\n\n\tprivate void solve() throws Exception\n\n\t{\n\n\t\tint n = nextInt();\n\n\t\tint m = nextInt();\n\n\t\tint k = nextInt();\n\n\t\tint[] r = new int[k];\n\n\t\tint[] c = new int[k];\n\n\t\tfor (int i = 0; i < k; i++)\n\n\t\t{\n\n\t\t\tr[i] = nextInt();\n\n\t\t\tc[i] = nextInt();\n\n\t\t}\n\n\t\tint best = -1;\n\n\t\tint bestr = -1;\n\n\t\tint bestc = -1;\n\n\t\tfor (int i = 1; i <= n; i++)\n\n\t\t{\n\n\t\t\tfor (int j = 1; j <= m; j++)\n\n\t\t\t{\n\n\t\t\t\tint d = n + m;\n\n\t\t\t\tfor (int q = 0; q < k; q++)\n\n\t\t\t\t{\n\n\t\t\t\t\td = Math.min(d, Math.abs(i - r[q]) + Math.abs(j - c[q]));\n\n\t\t\t\t}\n\n\t\t\t\tif (d < best) continue;\n\n\t\t\t\tbest = d;\n\n\t\t\t\tbestr = i;\n\n\t\t\t\tbestc = j;\n\n\t\t\t}\n\n\t\t}\n\n\t\tout(bestr + \" \" + bestc);\n\n\t}\n\n\n\n\tprivate int nextInt() throws Exception\n\n\t{\n\n\t\treturn input.nextInt();\n\n\t}\n\n\t\n\n\tprivate void out(String s)\n\n\t{\n\n\t\toutput.println(s);\n\n\t}\n\n\n\n\tpublic void run() {\n\n\t\ttry {\n\n\t\t\tsolve();\n\n\t\t} catch (Exception ex) {\n\n\t\t\tthrow new RuntimeException(ex);\n\n\t\t} finally {\n\n\t\t\toutput.close();\n\n\t\t}\n\n\t}\n\n\t\n\n\tpublic Solution() throws IOException {\n\n\t\tinput = new Scanner(new FileReader(\"input.txt\"));\n\n\t\toutput = new PrintWriter(\"output.txt\");\n\n\t}\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tLocale.setDefault(Locale.US);\n\n\t\tnew Thread(new Solution()).start();\n\n\t}\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\n\npublic class Task235A {\n\n\tpublic static void main(String... args) throws NumberFormatException,\n\t\t\tIOException {\n\t\tSolution.main(System.in, System.out);\n\t}\n\n\tstatic class Scanner {\n\n\t\tprivate final BufferedReader br;\n\t\tprivate String[] cache;\n\t\tprivate int cacheIndex;\n\n\t\tScanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tcache = new String[0];\n\t\t\tcacheIndex = 0;\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tif (cacheIndex >= cache.length) {\n\t\t\t\tcache = br.readLine().split(\" \");\n\t\t\t\tcacheIndex = 0;\n\t\t\t}\n\t\t\treturn Integer.parseInt(cache[cacheIndex++]);\n\t\t}\n\n\t\tlong nextLong() throws IOException {\n\t\t\tif (cacheIndex >= cache.length) {\n\t\t\t\tcache = br.readLine().split(\" \");\n\t\t\t\tcacheIndex = 0;\n\t\t\t}\n\t\t\treturn Long.parseLong(cache[cacheIndex++]);\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\tif (cacheIndex >= cache.length) {\n\t\t\t\tcache = br.readLine().split(\" \");\n\t\t\t\tcacheIndex = 0;\n\t\t\t}\n\t\t\treturn cache[cacheIndex++];\n\t\t}\n\n\t\tvoid close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\n\t}\n\n\tstatic class Solution {\n\n\t\tpublic static void main(InputStream is, OutputStream os)\n\t\t\t\tthrows NumberFormatException, IOException {\n\t\t\tPrintWriter pw = new PrintWriter(os);\n\t\t\tScanner sc = new Scanner(is);\n\n\t\t\tlong n = sc.nextInt();\n\n\t\t\tif (n < 3) {\n\t\t\t\tpw.println(n);\n\t\t\t} else {\n\t\t\t\tif (n % 2 != 0) {\n\t\t\t\t\tpw.println(n * (n - 1) * (n - 2));\n\t\t\t\t} else {\n\t\t\t\t\tif (n % 3 != 0) {\n\t\t\t\t\t\tpw.println(n * (n - 1) * (n - 3));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlong cand1 = n * (n - 1) * (n - 2) / 2;\n\t\t\t\t\t\tlong cand2 = (n - 1) * (n - 2) * (n - 3);\n\t\t\t\t\t\tpw.println(Math.max(cand1, cand2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.flush();\n\t\t\tsc.close();\n\t\t}\n\t}\n\n}", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\t\n\t// ArrayList<Integer> lis = new ArrayList<Integer>();\n\t// ArrayList<String> lis = new ArrayList<String>();\n\t//  PriorityQueue<P> que = new PriorityQueue<P>();\n\t// PriorityQueue<Integer> que = new PriorityQueue<Integer>();\n\t//  Stack<Integer> que = new Stack<Integer>();\n\t//HashMap<Long,Long> map = new HashMap<Long,Long>();\n    //\tstatic long sum=0;\n\t// 1000000007 (10^9+7)\n\tstatic int mod = 1000000007;\n\t//static int mod = 1000000009,r=0; ArrayList<Integer> l[]= new ArrayList[n];\n   // static int dx[]={1,-1,0,0};\n//\tstatic int dy[]={0,0,1,-1};\n//\tstatic int dx[]={1,-1,0,0,1,1,-1,-1};\n//  static int dy[]={0,0,1,-1,1,-1,1,-1};\n\t//static Set<Integer> set = new HashSet<Integer>();p\n\t\n\tstatic ArrayList<Integer> cd[];\n\tstatic int K=0;\n\t\npublic  static void main(String[] args)   throws Exception, IOException{\n   //String line=\"\"; throws Exception, IOException\n   //(line=br.readLine())!=null\n\t//Scanner sc =new Scanner(System.in);\n\t// !!caution!! int long //  \n\tReader sc = new Reader(System.in);\n\n\n //,a=sc.nextInt(),b=sc.nextInt();\n \t// int n=sc.nextInt(),p[]=new int[n],q[]=new int[n];\n\t//int n=sc.nextInt(),a[]=new int[n],b[]=new int[n];\n // int n=sc.nextInt(),m=sc.nextInt(),a=sc.nextInt(),b=sc.nextInt();\n\t// int r=1<<28;\n\t\n\tint n=sc.nextInt();//,k=sc.nextInt();\n    int a=sc.nextInt(),b=sc.nextInt(),d[]=new int[n];\n    HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n    ArrayList<Integer> A = new ArrayList<Integer>();\n    \n    \n    for (int i = 0; i < n ; i++) {\n    \n    \td[i]=sc.nextInt();\n    \tmap.put(d[i],i );\n    \t\n    }\n    \n    int c=1;\n\t if( a>b ){c--; int x=a; a=b; b=x;}\n\t \n\t int r[]=new int[n];\n\t \n\t if(a==b){\n\t\t\n\t\t  for (int i = 0; i < n; i++) {\n\t\t\t  if(d[i]>a || !map.containsKey(a-d[i]) ){System.out.println(\"NO\"); return;}\n\t\t  }\nSystem.out.println(\"YES\");\n\t\t  for (int i = 0; i < n; i++) {System.out.print(\"1 \");}\n\t\t  System.out.println();\n\t\t return;\n\t }\n\t \n       sort(d);\n\n    for (int j = 0; j < n; j++) {\n         int i=n-j-1;\n    \tint id=map.get(d[i]),idd=-1;\n    \tif(  id<0)continue;\n    \t\n    //\tdb(id,d[i]);\n    \t\n    \tif( d[i]<=a ){\n    \t\t if( map.containsKey(a-d[i]) && 0<=(idd=map.get(a-d[i]))  ){   \n    \t\tr[id]=r[idd]=(c+1)%2;  \n    \t\tmap.put(a-d[i], -1);\n    \t\t }\n    \t\t else if( map.containsKey(b-d[i]) && 0<=(idd=map.get(b-d[i])) ){ \n    \t    \t\tr[id]=r[idd]=c;\n    \t    \t\tmap.put(b-d[i], -1); }\n    \t\telse{ System.out.println(\"NO\"); return; }\n    \t\t \n    \t}\n     \n    \telse{\n    \t\t\n    \t\tif( map.containsKey(b-d[i]) && 0<=(idd=map.get(b-d[i]))   ){ \n    \t\t\tr[id]=r[idd]=c;\n    \t\tmap.put(b-d[i], -1); }\n    \t\telse{ System.out.println(\"NO\"); return; }\n    \t\t\n    \t}\n    \tmap.put(d[i], -1);\n\t\t\n    \n    }\n    \tSystem.out.println(\"YES\");\n         for (int j = 0; j < n; j++) {\n\t\t\tSystem.out.print(r[j]+\" \");\n\t\t}\n    \tSystem.out.println();\n    \n    \n    \n    \n    \n}\n\n\n  static class P implements Comparable<P>{\n//\timplements Comparable<Pair>\n\tint id; long  d; ;\n\tP(int id,long d){\n\t\tthis.id=id;\n\t\tthis.d=d;\n\t} \n\t\n\tpublic int compareTo(P x){\n\t\treturn  (-x.d+d)>=0?1:-1  ; // ascend long\n\t//\treturn   -x.d+d  ; // ascend\n\t//\t return   x.d-d  ; //descend\n\t   }\n \n}\n  \n\nstatic void db(Object... os){\n    System.err.println(Arrays.deepToString(os));\n\n}\n\n\n}\n\n\n\nclass Reader\n{ \n\tprivate BufferedReader x;\n\tprivate StringTokenizer st;\n\t\n\tpublic Reader(InputStream in)\n\t{\n\t\tx = new BufferedReader(new InputStreamReader(in));\n\t\tst = null;\n\t}\n\tpublic String nextString() throws IOException\n\t{\n\t\twhile( st==null || !st.hasMoreTokens() )\n\t\t\tst = new StringTokenizer(x.readLine());\n\t\treturn st.nextToken();\n\t}\n\tpublic int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(nextString());\n\t}\n\tpublic long nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(nextString());\n\t}\n\tpublic double nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(nextString());\n\t}\n}", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class test{\n    public static void main(String[] args) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            int n = Integer.parseInt(br.readLine());\n            if(n>=0) {\n                System.out.println(n);\n                return;\n            }else {\n                int p = n/10;\n                int q = -1*(-1*n/100)*10+(n%10);\n                System.out.println(Math.max(p, q));\n            }\n        } catch (Exception e) {\n            return;\n        }\n    }\n}", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashSet;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.util.Set;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n\n            int d = in.nextInt();\n\n            int[] a = new int[n];\n\n            Set<Integer> set = new HashSet<>();\n\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n\n            }\n\n\n            int ans = 2;\n            for (int i = 1; i < n; i++) {\n                if (a[i] - a[i - 1] == 2 * d) {\n                    ans++;\n                } else if (a[i] - a[i - 1] > 2 * d) {\n                    ans += 2;\n                }\n            }\n\n            out.println(ans);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.*;\n\npublic class codea{\n\tpublic static void main(String args[])\n\t{\n\t  Scanner in = new Scanner(System.in);\n\t  int n = in.nextInt();\n\t  int arr[] = new int[n];\n\t  for(int i =0;i<n;i++)\n\t   arr[i]= in.nextInt();\n\t  Arrays.sort(arr);\n\t  int max =0;\n\t  boolean check[]= new boolean [n];\n\t  int count=0;\n\t  for(int i =0;i<n;i++)\n\t  {\n\t   \n\t   if(!check[i])\n\t   {\n\t   \tcount++;\n\t   \n\t   for(int j=i;j<n;j++)\n\t   {\n\t   \n\t    if(arr[j]%arr[i]==0)\n\t     check[j]=true;\n\t   }\n\t   \n\t   }\t\n\t  }\n\t  System.out.println(count);\t\n\t}\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "\n\nimport java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class A implements Runnable{\n    \n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\")!=null;\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n    \n    void init() throws FileNotFoundException{\n        if (ONLINE_JUDGE){\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }else{\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        }\n    }\n    \n    String readString() throws IOException{\n        while(!tok.hasMoreTokens()){\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n    \n    int readInt() throws IOException{\n        return Integer.parseInt(readString());\n    }\n    \n    long readLong() throws IOException{\n        return Long.parseLong(readString());\n    }\n    \n    double readDouble() throws IOException{\n        return Double.parseDouble(readString());\n    }\n    \n    public static void main(String[] args){\n        new Thread(null, new A(), \"\", 256 * (1L << 20)).start();\n    }\n    \n    public void run(){\n        try{\n            long t1 = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \"+(t2-t1));\n        }catch (Exception e){\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n    \n    void solve() throws IOException{\n        int n = readInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++){\n            a[i] = readInt();\n        }\n        Arrays.sort(a);\n        a[n-1] = a[n-1] == 1? 2:1;\n        Arrays.sort(a);\n        for (int i = 0; i < n; i++){\n            out.print(a[i] + \" \");\n        }\n    }\n}\n\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.Scanner;\n\npublic class Problem_8C {\n  private static int dis(int x1, int y1, int x2, int y2) {\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int ox = sc.nextInt();\n    int oy = sc.nextInt();\n    int n = sc.nextInt();\n    int[] ix = new int[n];\n    int[] iy = new int[n];\n    int[] single = new int[n];\n    int[][] pair = new int[n][n];\n    for (int i = 0; i < n; i++) {\n      ix[i] = sc.nextInt();\n      iy[i] = sc.nextInt();\n      single[i] = dis(ox, oy, ix[i], iy[i]) * 2;\n      for (int j = 0; j < i; j++) {\n        pair[i][j] = pair[j][i] = dis(ix[i], iy[i], ix[j], iy[j]) + (single[i] + single[j]) / 2;\n      }\n    }\n    int[] min = new int[1 << n];\n    int[] pre = new int[1 << n];\n    for (int set = 1; set < 1 << n; set++) {\n      int i;\n      for (i = 0; i < n; i++) {\n        if ((set & (1 << i)) != 0) {\n          break;\n        }\n      }\n      min[set] = min[set ^ (1 << i)] + single[i];\n      pre[set] = set ^ (1 << i);\n      for (int j = 0; j < n; j++) {\n        if ((set & (1 << j)) == 0) {\n          continue;\n        }\n        if (min[set] > min[set ^ (1 << i) ^ (1 << j)] + pair[i][j]) {\n          min[set] = min[set ^ (1 << i) ^ (1 << j)] + pair[i][j];\n          pre[set] = set ^ (1 << i) ^ (1 << j);\n        }\n      }\n    }\n    System.out.println(min[(1 << n) - 1]);\n    for (int set = (1 << n) - 1; set != 0; set = pre[set]) {\n      System.out.print(\"0 \");\n      for (int i = 0; i < n; i++) {\n        if (((set ^ pre[set]) & (1 << i)) != 0) {\n          System.out.print((i + 1) + \" \");\n        }\n      }\n    }\n    System.out.println(\"0\");\n    sc.close();\n  }\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[])\n    {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=1;\n        while(T-->0)\n        {\n            long k=input.nextLong();\n            long v=9;\n            long s=0;\n            int x=1;\n            while(true)\n            {\n                if(s+v*x>k)\n                {\n                    break;\n                }\n                s+=v*x;\n                v*=10;\n                x++;\n            }\n            if(s==k)\n            {\n                out.println(9);\n            }\n            else\n            {\n                long d=k-s;\n                long u=d/x;\n                long rem=d%x;\n                long nu=(long)Math.pow(10,x-1);\n                nu+=u;\n                if(rem==0)\n                {\n                    nu--;\n                    out.println(nu%10);\n                }\n                else\n                {\n                    String str=String.valueOf(nu);\n                    out.println(str.charAt((int)(rem-1)));\n                }\n            }\n        }\n        out.close();\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class P111C{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint h, w;\n\n\tvoid run(){\n\t\th=sc.nextInt();\n\t\tw=sc.nextInt();\n\t\tsolve();\n\t}\n\n\tvoid shuffle(int[] is){\n\t\tRandom rand=new Random();\n\t\tfor(int i=is.length-1; i>=1; i--){\n\t\t\tint j=rand.nextInt(i+1);\n\t\t\tint t=is[i];\n\t\t\tis[i]=is[j];\n\t\t\tis[j]=t;\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tn=w*h;\n\t\tg=new long[n];\n\t\tint[] dx={0, 0, -1, 1};\n\t\tint[] dy={-1, 1, 0, 0};\n\t\tint[] _=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tshuffle(_);\n\t\tHashMap<Integer, Integer> map=new HashMap<Integer, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(_[i], i);\n\t\t}\n\t\tfor(int y=0; y<h; y++){\n\t\t\tfor(int x=0; x<w; x++){\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\tint x2=x+dx[k];\n\t\t\t\t\tint y2=y+dy[k];\n\t\t\t\t\tif(x2>=0&&x2<w&&y2>=0&&y2<h){\n\t\t\t\t\t\t// g[y*w+x]|=1L<<(y2*w+x2);\n\t\t\t\t\t\tg[map.get(y*w+x)]|=1L<<(map.get(y2*w+x2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmds=(1L<<n)-1;\n\t\tmds(0, 0, 0);\n\t\tprintln((n-Long.bitCount(mds))+\"\");\n\t}\n\n\tint n;\n\tlong[] g;\n\tlong mds;\n\tlong[] candidate;\n\n\tvoid mds(long choosed, long removed, long covered){\n\t\tif(Long.bitCount(choosed)>=Long.bitCount(mds))\n\t\t\treturn;\n\t\tif(covered==((1L<<n)-1)){\n\t\t\tif(Long.bitCount(choosed)<Long.bitCount(mds))\n\t\t\t\tmds=choosed;\n\t\t\treturn;\n\t\t}\n\n\t\tint k=-1;\n\t\t// ArrayList<Integer> list=new ArrayList<Integer>();\n\t\tfor(long remained=~removed&((1L<<n)-1); remained!=0; remained&=remained-1){\n\t\t\tint i=Long.numberOfTrailingZeros(remained);\n\t\t\tif((covered>>>i&1)==1){\n\t\t\t\tif(Long.bitCount(g[i]&~covered)==0){\n\t\t\t\t\tmds(choosed, removed|(1L<<i), covered);\n\t\t\t\t\treturn;\n\t\t\t\t}else if(Long.bitCount(g[i]&~covered)==1\n\t\t\t\t\t\t&&(g[i]&~covered&~removed)!=0){\n\t\t\t\t\tmds(choosed, removed|(1L<<i), covered);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(Long.bitCount(g[i]&~removed)==0){\n\t\t\t\t\tmds(choosed|(1L<<i), removed|(1L<<i), covered|(1L<<i)|g[i]);\n\t\t\t\t\treturn;\n\t\t\t\t}else if(Long.bitCount(g[i]&~removed)==1\n\t\t\t\t\t\t&&((g[i]&~removed)|(g[i]&~covered))==(g[i]&~removed)){\n\t\t\t\t\tint j=Long.numberOfTrailingZeros(g[i]&~removed);\n\t\t\t\t\tmds(choosed|(1L<<j), removed|(1L<<i)|(1L<<j), covered\n\t\t\t\t\t\t\t|(1L<<j)|g[j]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(k==-1||Long.bitCount(g[i]&~covered)>Long.bitCount(g[k]&~covered))\n\t\t\t\tk=i;\n\t\t\tif(false){\n\t\t\t\t/*\n\t\t\t\tif(k==-1\n\t\t\t\t\t\t||Long.bitCount(g[i]&~covered)>Long.bitCount(g[k]\n\t\t\t\t\t\t\t\t&~covered)){\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tlist.add(i);\n\t\t\t\t\tk=i;\n\t\t\t\t}else if(Long.bitCount(g[i]&~covered)==Long.bitCount(g[k]\n\t\t\t\t\t\t&~covered))\n\t\t\t\t\tlist.add(i);\n\t\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t\tif(k==-1)\n\t\t\treturn;\n\n\t\t// k=list.get((int)(list.size()*random()));\n\n\t\tmds(choosed|(1L<<k), removed|(1L<<k), covered|(1L<<k)|g[k]);\n\t\tmds(choosed, removed|(1L<<k), covered);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args){\n\t\tLocale.setDefault(Locale.US);\n\t\tnew P111C().run();\n\t}\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.io.*;\nimport java.lang.*;\npublic class CF1003E{\n    public static void main(String args[]) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int d = Integer.parseInt(s[1]);\n        int k = Integer.parseInt(s[2]);\n        StringBuffer sb = new StringBuffer();\n        int[] rem = new int[n];\n        int[] deg = new int[n];\n        int i = 0;\n        if(k == 1){\n            if(n <= 2){\n\n            }else{\n                System.out.println(\"NO\");\n                return;\n            }\n        }\n        for(i=0;i<d;i++){\n            if(i>=n-1){\n                System.out.println(\"NO\");\n                return;\n            }\n            sb.append((i+1) +\" \" + (i+2)+\"\\n\");\n            rem[i] = Math.min(i, d-i);\n            deg[i]++;\n            if(i+1<n)\n            deg[i+1]++;\n        }\n        if(i<n){\n            rem[i] = 0;\n            deg[i] = 1;\n        }\n        i++;\n        int j  = 0;\n        for(;i<n;i++){\n            //For all remaining Nodes\n            while(true){\n                if(j>=n){\n                    System.out.println(\"NO\");\n                    return;\n                }\n                if(rem[j] > 0 && deg[j]<k){\n                    deg[j]++;\n                    rem[i] = rem[j] - 1;\n                    sb.append((j+1)+\" \"+(i+1)+\"\\n\");\n                    deg[i]++;\n                    break;\n                }else{\n                    j++;\n                }\n            }\n        }\n        System.out.println(\"YES\");\n        System.out.println(sb);\n    }\n}\n", "complexity": "quadratic", "problem": "1003_E", "from": "CODEFORCES", "tags": "constructive algorithms,graphs"}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\n    PrintWriter out;\n    Scanner in;\n\n    public static void main(String[] args) throws IOException {\n        new Thread(new Main()).start();\n    }\n\n    public void run() {\n        try {\n            out = new PrintWriter(new BufferedOutputStream(System.out));\n            in = new Scanner(System.in);\n            solve();\n            out.close();\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public void solve() throws IOException {\n        int n = in.nextInt();\n        if (n >= 0) {\n            out.println(n);\n        } else {\n            String s = String.valueOf(n);\n            int l = s.length();\n            String s1 = s.substring(0, l - 2);\n            if (s.charAt(l - 1) > s.charAt(l - 2)) {\n                s1 += s.charAt(l - 2);\n            } else {\n                s1 += s.charAt(l - 1);\n            }\n            out.println(Integer.parseInt(s1));\n        }\n    }\n}", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "//package CodeforcesJava;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public void solve(InputProvider input, PrintWriter output) throws IOException {\n        int n = input.nextInt();\n        int d = input.nextInt();\n        int count = 1;\n        int current = input.nextInt();\n        for (int i = 1; i < n; i++) {\n            int x = input.nextInt();\n            if (x - current == d * 2) {\n                count++;\n            } else if (x - current > d * 2) {\n                count += 2;\n            }\n            current = x;\n        }\n        count++;\n        output.print(count);\n    }\n\n    public static void main(String[] args) throws Exception {\n        try (InputProvider input = new InputProvider(System.in);\n             PrintWriter output = new PrintWriter(System.out)) {\n            new Main().solve(input, output);\n        }\n    }\n\n    public static class InputProvider implements AutoCloseable {\n\n        private final BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputProvider(Reader reader) {\n            this.reader = new BufferedReader(reader);\n        }\n\n        public InputProvider(InputStream input) {\n            reader = new BufferedReader(new InputStreamReader(input));\n        }\n\n        public String next() throws IOException {\n            if (Objects.isNull(tokenizer) || !tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() throws IOException {\n            return reader.readLine();\n        }\n\n        @Override\n        public void close() throws Exception {\n            reader.close();\n        }\n\n    }\n\n}\n", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "//package round159;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class A {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), m = ni(), K = ni();\n\t\tint[] a = na(n);\n\t\ta = radixSort(a);\n\t\t\n\t\tif(K >= m){\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint p = 1;\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tK += a[i]-1;\n\t\t\tif(K >= m){\n\t\t\t\tout.println(p);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tout.println(-1);\n\t}\n\t\n\tpublic static int[] radixSort(int[] f)\n\t{\n\t\tint[] to = new int[f.length];\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n\t\t\tint[] d = f; f = to;to = d;\n\t\t}\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n\t\t\tint[] d = f; f = to;to = d;\n\t\t}\n\t\treturn f;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new A().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tint[] data = parseInts(in.readLine().split(\" \"));\n\tint n = data[0];\n\tint m = data[1];\n\tList<Integer> riders = new ArrayList<>(n);\n\tNavigableMap<Integer, Integer> drivers = new TreeMap<>();\t\n\t{\n\t    int[] xs = parseInts(in.readLine().split(\" \"));\n\t    int[] ts = parseInts(in.readLine().split(\" \"));\n\t    for (int i = 0; i < ts.length; i++) {\n\t\tif (ts[i] == 1) {\n\t\t    drivers.put(xs[i], 0);\n\t\t} else {\n\t\t    riders.add(xs[i]);\n\t\t}\n\t    }\n\t}\n\tfor (int r : riders) {\n\t    int distLeft = Integer.MAX_VALUE;\n\t    Integer left = drivers.lowerKey(r);\n\t    if (left != null) {\n\t\tdistLeft = r - left;\n\t    }\n\t    int distRight = Integer.MAX_VALUE;\n\t    Integer right = drivers.higherKey(r);\n\t    if (right != null) {\n\t\tdistRight = right - r;\n\t    }\n\t    if (distLeft <= distRight) {\n\t\tdrivers.put(left, drivers.get(left) + 1);\n\t    } else {\n\t\tdrivers.put(right, drivers.get(right) + 1);\n\t    }\n\t}\n\tPrintWriter out = new PrintWriter(System.out);\n\tIterator<Integer> it = drivers.values().iterator();\n\tout.print(it.next());\n\twhile (it.hasNext()) {\n\t    out.print(' ');\n\t    out.print(it.next());\n\t}\n\tout.println();\n\tout.close();\n    }\n\n    private static int[] parseInts(String[] numerals) {\n\tint[] xs = new int[numerals.length];\n\tfor (int i = 0; i < numerals.length; i++) {\n\t    xs[i] = Integer.parseInt(numerals[i]);\n\t}\n\treturn xs;\n    }\n}\n", "complexity": "linear", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tfinal static int MAXN = 100005;\n\tstatic int n;\n\tstatic Scanner cin;\n\tstatic int[] a;\n\tstatic boolean[] used;\n\tpublic static int Query(int x) {\n\t\tSystem.out.print(\"? \");\n\t\tSystem.out.println(x);\n\t\tSystem.out.flush();\n\t\tint a = cin.nextInt();\n\t\treturn a;\n\t}\n\tpublic static int Q(int x) {\n\t\tif(used[x]) return a[x];\n\t\tused[x] = true;\n\t\ta[x] = Query(x) - Query(x + n / 2);\n\t\tif(a[x] == 0) {\n\t\t\tSystem.out.print(\"! \");\n\t\t\tSystem.out.println(x);\n\t\t\tSystem.out.flush();\n\t\t\tcin.close();\n\t\t\tSystem.exit(0);\n\t\t}\n\t\treturn a[x];\n\t}\n\tpublic static void main(String[] args) {\n\t\tcin = new Scanner(System.in);\n\t\tn = cin.nextInt();\n\t\ta = new int[MAXN];\n\t\tused = new boolean[MAXN];\n\t\tif(n % 4 != 0) {\n\t\t\tSystem.out.println(\"! -1\\n\");\n\t\t\tSystem.out.flush();\n\t\t\tcin.close();\n\t\t\treturn;\n\t\t}\n\t\tint l = 1, r = n / 2, mid;\n\t\twhile(l <= r) {\n\t\t\tmid = (l + r) / 2;\n\t\t\tint x = Q(mid);\n\t\t\tif(Q(l) * x < 0) {\n\t\t\t\tr = mid - 1;\n\t\t\t} else if(x * Q(r) < 0) {\n\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"! -1\\n\");\n\t\tSystem.out.flush();\n\t\tcin.close();\n\t}\n}\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Wolfgang Beyer\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = in.readIntArray(n);\n\n            long count = 0;\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (a[j] > a[i]) count++;\n                }\n            }\n            boolean even = count % 2 == 0 ? true : false;\n\n            int m = in.nextInt();\n            for (int i = 0; i < m; i++) {\n                int left = in.nextInt();\n                int right = in.nextInt();\n                int diff = right - left;\n                if ((diff % 4 == 1) || (diff % 4 == 2)) {\n                    even = !even;\n                }\n                if (even) {\n                    out.println(\"even\");\n                } else {\n                    out.println(\"odd\");\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private static BufferedReader in;\n        private static StringTokenizer tok;\n\n        public InputReader(InputStream in) {\n            this.in = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] readIntArray(int n) {\n            int[] ar = new int[n];\n            for (int i = 0; i < n; i++) {\n                ar[i] = nextInt();\n            }\n            return ar;\n        }\n\n        public String next() {\n            try {\n                while (tok == null || !tok.hasMoreTokens()) {\n                    tok = new StringTokenizer(in.readLine());\n                    //tok = new StringTokenizer(in.readLine(), \", \\t\\n\\r\\f\"); //adds commas as delimeter\n                }\n            } catch (IOException ex) {\n                System.err.println(\"An IOException was caught :\" + ex.getMessage());\n            }\n            return tok.nextToken();\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author anand.oza\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E1RotateColumnsEasyVersion solver = new E1RotateColumnsEasyVersion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E1RotateColumnsEasyVersion {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int t = in.nextInt();\n            for (int i = 0; i < t; i++) {\n                solve(in, out);\n            }\n        }\n\n        private void solve(InputReader in, PrintWriter out) {\n            int n = in.nextInt(), m = in.nextInt();\n\n            int[][] a = new int[n][];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.readIntArray(m);\n            }\n\n            out.println(solve(n, m, a));\n        }\n\n        private int solve(int n, int m, int[][] a) {\n            Cell[] cells = new Cell[n * m];\n            for (int i = 0, index = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    cells[index++] = new Cell(i, j, a[i][j]);\n                    if (index == cells.length)\n                        break;\n                }\n            }\n\n            Arrays.sort(cells, Comparator.comparingInt(cell -> -cell.x));\n\n            HashSet<Integer> colset = new HashSet<>();\n            for (int i = 0; colset.size() < n && colset.size() < m; i++) {\n                colset.add(cells[i].j);\n            }\n\n            ArrayList<Integer> cols = new ArrayList<>();\n            cols.addAll(colset);\n\n            int answer = 0;\n            for (long perm = 0; perm < pow(n, cols.size() - 1); perm++) {\n                long p = perm;\n                int[] offset = new int[cols.size()];\n                for (int col = 0; col < cols.size(); col++) {\n                    offset[col] = (int) (p % n);\n                    p /= n;\n                }\n                int sum = 0;\n                for (int row = 0; row < n; row++) {\n                    int max = 0;\n                    for (int col = 0; col < cols.size(); col++) {\n                        int cur = a[(row + offset[col]) % n][cols.get(col)];\n                        max = Math.max(max, cur);\n                    }\n                    sum += max;\n                }\n                answer = Math.max(answer, sum);\n            }\n\n            return answer;\n        }\n\n        private long pow(int base, int exponent) {\n            long p = 1;\n            for (int i = 0; i < exponent; i++) {\n                p *= base;\n            }\n            return p;\n        }\n\n        private class Cell {\n            final int i;\n            final int j;\n            final int x;\n\n            private Cell(int i, int j, int x) {\n                this.i = i;\n                this.j = j;\n                this.x = x;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] readIntArray(int n) {\n            int[] x = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextInt();\n            }\n            return x;\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "// Don't place your source in a package\nimport javax.swing.*;\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.stream.Stream;\n\n\n// Please name your class Main\npublic class Main {\n    static FastScanner fs=new FastScanner();\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int Int() {\n            return Integer.parseInt(next());\n        }\n\n        long Long() {\n            return Long.parseLong(next());\n        }\n\n        String Str(){\n            return next();\n        }\n    }\n\n\n    public static void main (String[] args) throws java.lang.Exception {\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n        int T=1;\n        for(int t=0;t<T;t++){\n            int n=Int(),m=Int();\n\n            Solution sol=new Solution(out);\n            sol.solution(n,m);\n        }\n        out.close();\n\n    }\n\n\n    public static int Int(){\n        return fs.Int();\n    }\n    public static long Long(){\n        return fs.Long();\n    }\n    public static String Str(){\n        return fs.Str();\n    }\n\n}\n\n\n\n\n\n\nclass Solution{\n    PrintWriter out;\n    public Solution(PrintWriter out){\n        this.out=out;\n    }\n\n\n\n    public void solution(int n,int mod){\n        long res=0;\n        long ncr[][]=new long[501][501];\n        long pow[]=new long[501];\n        pow[0]=1;\n        for(int i=1;i<pow.length;i++){\n            pow[i]=(pow[i-1]*2)%mod;\n        }\n\n        ncr[0][0]=1;\n        for (int i=1;i<ncr.length;i++) {\n            ncr[i][0]=1;\n            for (int j=1;j<ncr[0].length;j++) {\n                ncr[i][j]=(ncr[i-1][j]+ncr[i-1][j-1])%mod;\n            }\n        }\n\n\n        long dp[][]=new long[n+1][n+1];\n\n\n        for(int i=1;i<dp.length;i++){\n            dp[i][i]=pow[i-1];\n            for(int j=1;j<i;j++){\n                for(int k=1;k<i;k++){\n                    //pow[cnt-1]\n                    if(i-k-1>=1&&j>=k){\n                        dp[i][j]=dp[i][j]+dp[i-k-1][j-k]*((ncr[j][k]*pow[k-1])%mod);\n                        dp[i][j]%=mod;\n                    }\n                }\n\n            }\n        }\n\n\n\n\n        for(int i=1;i<=n;i++){\n            res+=dp[n][i];\n            res%=mod;\n        }\n        out.println(res);\n    }\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n/*\n                             ;\\\n                            |' \\\n         _                  ; : ;\n        / `-.              /: : |\n       |  ,-.`-.          ,': : |\n       \\  :  `. `.       ,'-. : |\n        \\ ;    ;  `-.__,'    `-.|\n         \\ ;   ;  :::  ,::'`:.  `.\n          \\ `-. :  `    :.    `.  \\\n           \\   \\    ,   ;   ,:    (\\\n            \\   :., :.    ,'o)): ` `-.\n           ,/,' ;' ,::\"'`.`---'   `.  `-._\n         ,/  :  ; '\"      `;'          ,--`.\n        ;/   :; ;             ,:'     (   ,:)\n          ,.,:.    ; ,:.,  ,-._ `.     \\\"\"'/\n          '::'     `:'`  ,'(  \\`._____.-'\"'\n             ;,   ;  `.  `. `._`-.  \\\\\n             ;:.  ;:       `-._`-.\\  \\`.\n              '`:. :        |' `. `\\  ) \\\n      -hrr-      ` ;:       |    `--\\__,'\n                   '`      ,'\n                        ,-'\n\n\n                      free bug dog\n*/\n\n\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E2VrashayaStolbciUslozhnennayaVersiya solver = new E2VrashayaStolbciUslozhnennayaVersiya();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E2VrashayaStolbciUslozhnennayaVersiya {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int tn = in.nextInt();\n            for (int t = 0; t < tn; t++) {\n                int n = in.nextInt();\n                int m = in.nextInt();\n                Col[] a = new Col[m];\n                for (int i = 0; i < m; i++) {\n                    a[i] = new Col(n);\n                }\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < m; j++) {\n                        a[j].a[i] = in.nextInt();\n                        if (a[j].a[i] > a[j].max) {\n                            a[j].max = a[j].a[i];\n                        }\n                    }\n\n                }\n\n                Arrays.sort(a, (o1, o2) -> o2.max - o1.max);\n\n                if (m > n) {\n                    m = n;\n                }\n\n                for (int i = 0; i < m; i++) {\n                    a[i].calcMask();\n                }\n\n                int[][] dp = new int[m + 1][1 << n];\n                Arrays.fill(dp[0], -1);\n                dp[0][0] = 0;\n                for (int i = 0; i < m; i++) {\n                    for (int msk = 0; msk < (1 << n); msk++) {\n                        dp[i + 1][msk] = dp[i][msk];\n                        for (int sub = msk; sub > 0; sub = (sub - 1) & msk) {\n                            int v = dp[i][msk ^ sub] + a[i].mask[sub];\n                            if (v > dp[i + 1][msk]) {\n                                dp[i + 1][msk] = v;\n                            }\n                        }\n                    }\n                }\n\n                out.println(dp[m][(1 << n) - 1]);\n            }\n        }\n\n        class Col {\n            int n;\n            int[] a;\n            int[] mask;\n            int max;\n\n            public Col(int n) {\n                this.n = n;\n                a = new int[n];\n            }\n\n            void calcMask() {\n                mask = new int[1 << n];\n                for (int i = 0; i < (1 << n); i++) {\n                    for (int j = 0; j < n; j++) {\n                        int sum = 0;\n                        for (int k = 0; k < n; k++) {\n                            if (((1 << k) & i) != 0) {\n                                sum += a[(j + k) % n];\n                            }\n                        }\n                        if (sum > mask[i]) {\n                            mask[i] = sum;\n                        }\n                    }\n                }\n            }\n\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.util.*;\npublic class G {\n    static int n,t;\n    static int[]a;\n    static int[]g;\n    static long[][][]dp;\n    static final long MOD=1000000007;\n    public static void main(String[]args){\n        Scanner sc=new Scanner(System.in);\n        n=sc.nextInt();\n        t=sc.nextInt();\n        a=new int[n];\n        g=new int[n];\n        for(int i=0;i<n;i++) {\n            a[i] = sc.nextInt();\n            g[i] = sc.nextInt();\n        }\n        dp=new long[4][1<<(n-1)+1][t+1];\n        for(int i=0;i<4;i++)\n            for(int j=0;j<1<<(n-1)+1;j++)\n                for(int k=0;k<=t;k++)\n                    dp[i][j][k]=-1;\n        System.out.println(dp(0,0,t));\n    }\n    private static long dp(int genre,int mask,int time){\n        if(time<0)\n            return 0;\n        if(dp[genre][mask][time]!=-1)\n            return dp[genre][mask][time];\n        if(time==0)\n            return 1;\n        dp[genre][mask][time]=0;\n        for(int i=0;i<n;i++) {\n            if (g[i] != genre && ((1 << i) & mask) == 0)\n                dp[genre][mask][time] = (dp[genre][mask][time]+dp(g[i], mask | (1 << i), time - a[i]))%MOD;\n        }\n        return dp[genre][mask][time];\n    }\n}", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic final class D {\n\n    static int[][][][] g;\n    static int[][][] dp;\n    static int n;\n    static int m;\n    static int k;\n\n    public static void main(String[] args) {\n        final FastScanner fs = new FastScanner();\n        n = fs.nextInt();\n        m = fs.nextInt();\n        k = fs.nextInt();\n        g = new int[n][m][][];\n        dp = new int[n][m][1 + (k / 2)];\n        for (int[][] r1 : dp) {\n            for (int[] r2 : r1) {\n                Arrays.fill(r2, -1);\n            }\n        }\n        final int[][] size = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                size[i][j] = 4;\n                if (i == 0 || i == n - 1) {\n                    size[i][j]--;\n                }\n                if (j == 0 || j == m - 1) {\n                    size[i][j]--;\n                }\n                g[i][j] = new int[size[i][j]][3];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < (m - 1); j++) {\n                final int cost = fs.nextInt();\n                g[i][j][--size[i][j]] = new int[] { i, j + 1, cost };\n                g[i][j + 1][--size[i][j + 1]] = new int[] { i, j, cost };\n            }\n        }\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < m; j++) {\n                final int cost = fs.nextInt();\n                g[i][j][--size[i][j]] = new int[] { i + 1, j, cost };\n                g[i + 1][j][--size[i + 1][j]] = new int[] { i, j, cost };\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        if (k % 2 != 0) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    sb.append(-1);\n                    sb.append(' ');\n                }\n                sb.append('\\n');\n            }\n            System.out.println(sb);\n            return;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                dfs(i, j, k / 2);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                sb.append(2 * dp[i][j][k / 2]);\n                sb.append(' ');\n            }\n            sb.append('\\n');\n        }\n        System.out.println(sb);\n    }\n\n    private static int dfs(int i, int j, int k) {\n        if (k == 0) {\n            return 0;\n        }\n        if (dp[i][j][k] != -1) {\n            return dp[i][j][k];\n        }\n        int res = (int) 1e9;\n        for (int[] next : g[i][j]) {\n            res = Math.min(res, next[2] + dfs(next[0], next[1], k - 1));\n        }\n        return dp[i][j][k] = res;\n    }\n\n    static final class Utils {\n        private static class Shuffler {\n            private static void shuffle(int[] x) {\n                final Random r = new Random();\n\n                for (int i = 0; i <= x.length - 2; i++) {\n                    final int j = i + r.nextInt(x.length - i);\n                    swap(x, i, j);\n                }\n            }\n\n            private static void shuffle(long[] x) {\n                final Random r = new Random();\n\n                for (int i = 0; i <= x.length - 2; i++) {\n                    final int j = i + r.nextInt(x.length - i);\n                    swap(x, i, j);\n                }\n            }\n\n            private static void swap(int[] x, int i, int j) {\n                final int t = x[i];\n                x[i] = x[j];\n                x[j] = t;\n            }\n\n            private static void swap(long[] x, int i, int j) {\n                final long t = x[i];\n                x[i] = x[j];\n                x[j] = t;\n            }\n        }\n\n        public static void shuffleSort(int[] arr) {\n            Shuffler.shuffle(arr);\n            Arrays.sort(arr);\n        }\n\n        public static void shuffleSort(long[] arr) {\n            Shuffler.shuffle(arr);\n            Arrays.sort(arr);\n        }\n\n        private Utils() {}\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        private String next() {\n            while (!st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    //noinspection CallToPrintStackTrace\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int[] nextIntArray(int n) {\n            final int[] a = new int[n];\n            for (int i = 0; i < n; i++) { a[i] = nextInt(); }\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            final long[] a = new long[n];\n            for (int i = 0; i < n; i++) { a[i] = nextLong(); }\n            return a;\n        }\n    }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "/**\n * author: derrick20\n * created: 3/19/21 11:57 PM\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class E2_SquareFreeDivision2 {\n    static FastScanner sc = new FastScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n//        generate();\n        int T = sc.nextInt();\n        int MAX = (int) 1e7;\n        int[] canonical = new int[MAX + 1];\n        canonical[1] = 1;\n        for (int factor = 2; factor <= MAX; factor++) {\n            if (canonical[factor] == 0) {\n                for (int mult = factor; mult <= MAX; mult += factor) {\n                    int prev = canonical[mult / factor];\n                    if (prev % factor == 0) {\n                        canonical[mult] = prev / factor;\n                    } else {\n                        canonical[mult] = prev * factor;\n                    }\n                }\n            }\n        }\n//        System.out.println(Arrays.toString(canonical));\n        int[] freq = new int[MAX + 1];\n        while (T-->0) {\n            int N = sc.nextInt();\n            int K = sc.nextInt();\n            int[] a = new int[N + 1];\n            for (int i = 1; i <= N; i++) {\n                a[i] = canonical[sc.nextInt()];\n            }\n            int[][] transition = new int[K + 1][N + 1];\n//            HashMap<Integer, Integer> freq = new HashMap<>();\n            for (int k = 0; k <= K; k++) {\n                int l = N + 1;\n                int duplicates = 0;\n                for (int r = N; r >= 1; r--) {\n                    while (l - 1 >= 1) {\n                        int nextDuplicates = duplicates;\n                        if (freq[a[l - 1]] >= 1) {\n                            nextDuplicates++;\n                        }\n                        if (nextDuplicates <= k) {\n                            duplicates = nextDuplicates;\n                            freq[a[l - 1]]++;\n                            l--;\n                        } else {\n                            break;\n                        }\n                    }\n                    transition[k][r] = l;\n                    if (--freq[a[r]] >= 1) {\n                        duplicates--;\n                    }\n                }\n            }\n            int[][] dp = new int[K + 1][N + 1];\n            int oo = (int) 1e9;\n            for (int[] row : dp) {\n                Arrays.fill(row, oo);\n            }\n            for (int k = 0; k <= K; k++) {\n                dp[k][0] = 0;\n            }\n            for (int r = 1; r <= N; r++) {\n                for (int k = 0; k <= K; k++) {\n                    for (int delta = 0; delta <= k; delta++) {\n                        dp[k][r] = min(dp[k][r], dp[k - delta][transition[delta][r] - 1] + 1);\n                    }\n                }\n            }\n            out.println(dp[K][N]);\n        }\n        out.close();\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n    \n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n    \n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n    \n        char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n    \n        int nextInt() {\n            return (int) nextLong();\n        }\n    \n        long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n    \n        double nextDouble() {\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            double cur = nextLong();\n            if (c != '.') {\n                return neg ? -cur : cur;\n            } else {\n                double frac = nextLong() / cnt;\n                return neg ? -cur - frac : cur + frac;\n            }\n        }\n    \n        String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n    \n        String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n    \n        boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n    \n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n    \n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import java.util.Scanner;\n\npublic class A {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint in = sc.nextInt();\n\t\tSystem.out.println(in/2 + in);\n\t\tSystem.exit(0);\n\t}\n}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n    //StreamTokenizer in;\n    BufferedReader in;\n    PrintWriter out;\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    void run() throws IOException {\n        //in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        String s = in.readLine();\n        int n = s.length();\n        for(int len = n; len > 0; len--) {\n            for(int i = 0; i + len <= n; i++) {\n                for(int j = 0; j + len <= n; j++)\n                    if(i != j) {\n                        boolean f = true;\n                        for(int k = 0; k < len; k++)\n                            if(s.charAt(i + k) != s.charAt(j + k)) {\n                                f = false;\n                                break;\n                            }\n                        if(f) {\n                            out.println(len);\n                            out.flush();\n                            return;\n                        }\n                    }\n            }\n        }\n        out.println(0);\n        out.flush();\n    }\n\n    void solve() throws IOException {\n        \n    }\n    \n    //int ni() throws IOException { in.nextToken(); return (int) in.nval; }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tReader in = new Reader();\n\t\tint n = in.nextInt();\n\t\tint[] a = in.na(n);\n\t\tHashMap<Long, ArrayList<Pair>> v = new HashMap<>();\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tlong s  = 0;\n\t\t\tfor(int j = i; j<n; j++) {\n\t\t\t\ts+=a[j];\n\t\t\t\tPair p = new Pair(i+1, j+1);\n\t\t\t\tif(v.containsKey(s)) {\n\t\t\t\t\tv.get(s).add(p);\n\t\t\t\t}else {\n\t\t\t\t\tArrayList<Pair> xd = new ArrayList<>();\n\t\t\t\t\txd.add(p);\n\t\t\t\t\tv.put(s,xd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Pair> ans = new ArrayList<>();\n\t\tfor(Entry<Long,ArrayList<Pair>> e : v.entrySet()) {\n\t\t\tArrayList<Pair> pairs = e.getValue();\n\t\t\tCollections.sort(pairs);\n\t\t\tStack<Pair> st = new Stack<>();\n\t\t\tfor(int i = 0; i<pairs.size(); i++) {\n\t\t\t\tPair cur = pairs.get(i);\n\t\t\t\tif(st.isEmpty()||st.peek().r<cur.l) {\n\t\t\t\t\tst.push(cur);\n\t\t\t\t}else if(st.peek().r>cur.r) {\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t\tst.push(cur);\n\t\t\t\t}\n\t\t\t\tif(st.size()>ans.size()) ans = new ArrayList<>(st);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans.size());\n\t\tfor(Pair p : ans)\n\t\t\tSystem.out.println(p.l +\" \"+p.r);\n\t}\n\tstatic class Pair implements Comparable<Pair>{\n\t\tint l,r;\n\t\tpublic Pair(int l, int r) {\n\t\t\tthis.l = l;\n\t\t\tthis.r = r;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.l - o.l;\n\t\t}\n\t}\n\tstatic class Reader {\n\t\tstatic BufferedReader br;\n\t\tstatic StringTokenizer st;\n\n\t\tpublic Reader() {\n\t\t\tthis.br = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic int[] na(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nl(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic String[] nS(int n) {\n\t\t\tString[] a = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = next();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (st == null || !st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\treadLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\treturn Integer.parseInt(st.nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tif (st == null || !st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\treadLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\treturn Double.parseDouble(st.nextToken());\n\t\t}\n\n\t\tpublic Long nextLong() {\n\t\t\tif (st == null || !st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\treadLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\treturn Long.parseLong(st.nextToken());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (st == null || !st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\treadLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic static void readLine() {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t}\n\t\t}\n\t}\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\n/**\n * @author Egor Kulikov (egor@egork.net)\n *         Created on 14.03.2010\n */\npublic class TaskA implements Runnable {\n\tprivate InputReader in;\n\tprivate PrintWriter out;\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new TaskA()).start();\n//\t\tnew Template().run();\n\t}\n\n\tpublic TaskA() {\n//\t\tString id = getClass().getName().toLowerCase();\n//\t\ttry {\n//\t\t\tSystem.setIn(new FileInputStream(id + \".in\"));\n//\t\t\tSystem.setOut(new PrintStream(new FileOutputStream(id + \".out\")));\n//\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n//\t\t\tSystem.setOut(new PrintStream(new FileOutputStream(\"output.txt\")));\n//\t\t} catch (FileNotFoundException e) {\n//\t\t\tthrow new RuntimeException();\n//\t\t}\n\t\tin = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t}\n\n\tpublic void run() {\n//        int numTests = in.readInt();\n//        for (int testNumber = 0; testNumber < numTests; testNumber++) {\n//\t\t\tout.print(\"Case #\" + (testNumber + 1) + \": \");\n//        }\n\t\tint n = in.readInt();\n\t\tint t = in.readInt();\n\t\tfinal int[] x = new int[n];\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.readInt();\n\t\t\ta[i] = in.readInt();\n\t\t}\n\t\tInteger[] o = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\to[i] = i;\n\t\tArrays.sort(o, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn x[o1] - x[o2];\n\t\t\t}\n\t\t});\n\t\tint ans = 2;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint d = x[o[i]] - x[o[i - 1]];\n\t\t\td = 2 * d - a[o[i]] - a[o[i - 1]] - 2 * t;\n\t\t\tif (d > 0)\n\t\t\t\tans += 2;\n\t\t\telse if (d == 0)\n\t\t\t\tans++;\n\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n\n\tprivate static class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1000];\n\t\tprivate int curChar, numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int readInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long readLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuffer res = new StringBuffer();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate String readLine0() {\n\t\t\tStringBuffer buf = new StringBuffer();\n\t\t\tint c = read();\n\t\t\twhile (c != '\\n' && c != -1) {\n\t\t\t\tbuf.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\treturn buf.toString();\n\t\t}\n\n\t\tpublic String readLine() {\n\t\t\tString s = readLine0();\n\t\t\twhile (s.trim().length() == 0)\n\t\t\t\ts = readLine0();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic String readLine(boolean ignoreEmptyLines) {\n\t\t\tif (ignoreEmptyLines)\n\t\t\t\treturn readLine();\n\t\t\telse\n\t\t\t\treturn readLine0();\n\t\t}\n\n\t\tpublic BigInteger readBigInteger() {\n\t\t\ttry {\n\t\t\t\treturn new BigInteger(readString());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tpublic char readCharacter() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\treturn (char) c;\n\t\t}\n\n\t\tpublic double readDouble() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') {\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t}\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DOlyaAndMagicalSquare solver = new DOlyaAndMagicalSquare();\n        int testCount = Integer.parseInt(in.next());\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class DOlyaAndMagicalSquare {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.NextInt();\n            long k = in.NextLong();\n            if (k == 0) {\n                out.println(\"YES \" + n);\n                return;\n            }\n            long operationTillNow = 0, numberOfCubeOnTheSide = 1;\n            ArrayList<CubeCount> cubes = new ArrayList<>();\n\n            for (int i = n - 1; i >= 0; i--) {\n                cubes.add(new CubeCount(i, (numberOfCubeOnTheSide - 1) * 2 * 2 + 1));\n                operationTillNow = operationTillNow + 2 * numberOfCubeOnTheSide - 1;\n                numberOfCubeOnTheSide *= 2;\n                long operationLeft = k - operationTillNow;\n                if (operationLeft == 0) {\n                    out.println(\"YES \" + i);\n                    return;\n                } else if (operationLeft < 0) {\n                    out.println(\"NO\");\n                    return;\n                }\n                for (CubeCount c : cubes) {\n                    if (!c.hasLessThen(operationLeft)) {\n                        out.println(\"YES \" + i);\n                        return;\n                    } else {\n                        operationLeft = c.removeMeFrom(operationLeft);\n                    }\n                }\n                if (operationLeft <= 0) {\n                    out.println(\"YES \" + i);\n                    return;\n                }\n            }\n            out.println(\"NO\");\n            return;\n        }\n\n        class CubeCount {\n            int sideSizeLogScale;\n            long repeats;\n\n            public CubeCount(int sideSizeLogScale, long repeats) {\n                this.repeats = repeats;\n                this.sideSizeLogScale = sideSizeLogScale;\n            }\n\n            public boolean hasLessThen(long k) {\n                return hasLessThen(k, sideSizeLogScale, repeats);\n            }\n\n            private boolean hasLessThen(long k, int sideLog, long repeats) {\n                while (true) {\n                    if (k <= 0) return false;\n                    if (sideLog == 0) return true;\n                    k -= repeats;\n                    sideLog--;\n                    repeats *= 4;\n                }\n            }\n\n            public long removeMeFrom(long k) {\n                return removeMeFrom(k, sideSizeLogScale, repeats);\n            }\n\n            private long removeMeFrom(long k, int sideLog, long repeats) {\n                while (true) {\n                    if (sideLog == 0) return k;\n                    k -= repeats;\n                    sideLog--;\n                    repeats *= 4;\n                }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long NextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class ProblemA {\n\n\tString fileName = \"prizes\";\n\n\tpublic void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint d = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tint ans = 2;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (a[i] - a[i - 1] == 2 * d)\n\t\t\t\tans++;\n\t\t\tif (a[i] - a[i - 1] > 2 * d)\n\t\t\t\tans += 2;\n\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out, true);\n\n\t\t\t// out = new PrintWriter(fileName + \".out\");\n\t\t\t// br = new BufferedReader(new FileReader(fileName + \".in\"));\n\t\t\t// out = new PrintWriter(fileName + \".out\");\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tBufferedReader br;\n\tStringTokenizer in;\n\tstatic PrintWriter out;\n\n\tpublic String nextToken() throws IOException {\n\t\twhile (in == null || !in.hasMoreTokens()) {\n\t\t\tin = new StringTokenizer(br.readLine());\n\t\t}\n\t\treturn in.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew ProblemA().run();\n\t}\n\n}", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class C138B\n{\n\n    private static StringTokenizer st;\n    \n    public static void nextLine(BufferedReader br) throws IOException\n    {\n        st = new StringTokenizer(br.readLine());\n    }\n    \n    public static int nextInt()\n    {\n        return Integer.parseInt(st.nextToken());\n    }\n    \n    public static String next()\n    {\n        return st.nextToken();\n    }\n    \n    public static long nextLong()\n    {\n        return Long.parseLong(st.nextToken());\n    }\n    /**\n     * @param args\n     */\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        nextLine(br);\n        int n = nextInt();\n        int k = nextInt();\n        int[] a = new int[n];\n        nextLine(br);\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        \n        int bp = 0, fp = 0, count = 0;\n        boolean good = false;\n        int[] mark = new int[100001];\n        for (fp = 0; fp < n; fp++)\n        {\n            if (mark[a[fp]] == 0)\n            {\n                count++;\n            }\n            mark[a[fp]]++;\n            if (count == k)\n            {\n                good = true;\n                break;\n            }\n        }\n        if (!good)\n        {\n            System.out.println(\"-1 -1\");\n            return;\n        }\n        for (bp = 0; bp < fp; bp++)\n        {\n            if (mark[a[bp]] > 1)\n            {\n                mark[a[bp]]--;\n            }\n            else break;\n        }\n        System.out.println((bp+1) + \" \" + (fp+1));\n    }\n    \n}\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Solution\n{\n    public static void main(String ag[])\n    {\n        Scanner sc=new Scanner(System.in);\n        int i,j,k;\n        long N=sc.nextLong();\n        long S=sc.nextLong();\n        long ans=(long)1e18+5;\n        \n        long l=0;\n        long r=(long)1e18+5;\n        while(l<=r)\n        {\n            long mid=(l+r)/2;\n            if(find(mid,S))\n            {\n                ans=mid;\n                r=mid-1;\n            }\n            else \n            {\n                l=mid+1;\n            }\n        }\n        if(ans>N)\n        System.out.println(0);\n        else \n        System.out.println(N-ans+1);\n    }\n    public static boolean find(long num,long S)\n    {\n        long sum=0;\n        long N=num;\n        while(num>0)\n        {\n            sum+=num%10;\n            num/=10;\n        }\n        if(N-sum>=S)\n        return true;\n        return false;\n    }\n}", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n\npublic class C_138B {\n\tprivate static BufferedReader in;\n\tprivate static StringTokenizer st;\n\tprivate static PrintWriter out;\n\t\n\t\n\tstatic String nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\t\n\tstatic int nextInt() throws NumberFormatException, IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tst = new StringTokenizer(\"\");\n\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tint [] a = new int [n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tset.add(a[i]);\n\t\t\tif(set.size()==k){\n\t\t\t\tSet<Integer> set2 = new HashSet<Integer>();\n\t\t\t\tfor (int j = i; j >= 0; j--) {\n\t\t\t\t\tset2.add(a[j]);\n\t\t\t\t\tif(set2.size()==k){\n\t\t\t\t\t\tout.print((j+1)+\" \"+(i+1));\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.print(\"-1 -1\");\t\t\n\t\tout.close();\n\t}\n}\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class D {\n\n\tstatic StringTokenizer st;\n\tstatic BufferedReader br;\n\tstatic PrintWriter pw;\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tint n = nextInt();\n\t\tint[]a = new int[n+1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tint inv = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tif (a[j] > a[i])\n\t\t\t\t\tinv++;\n\t\t\t}\n\t\t}\n\t\tint m = nextInt();\n\t\tboolean odd = inv % 2==1;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint left = nextInt();\n\t\t\tint right = nextInt();\n\t\t\tlong k = right-left+1;\n\t\t\tif (k*(k-1)/2 % 2==1)\n\t\t\t\todd = !odd;\n\t\t\tif (odd)\n\t\t\t\tpw.println(\"odd\");\n\t\t\telse\n\t\t\t\tpw.println(\"even\");\n\t\t}\n\t\tpw.close();\n\t}\n\tprivate static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tprivate static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tprivate static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tprivate static String next() throws IOException {\n\t\twhile (st==null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;\n\nimport java.io.*;\n\nimport java.math.*;\n\npublic class q817c {\n\n\tpublic static void main(String argsp[]){\n\n\t\t//long startTime = System.currentTimeMillis();\n\n\t\tlong input;\n\n\t\t\n\n\t\tString someinp;\n\n\t\tlong count = 0;\n\n\t\tlong s;\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tinput = sc.nextLong();\n\n\t\ts = sc.nextLong();\n\n\t\t//System.out.println(Long.toString(input));\n\n\t\t//System.out.println(Long.toString(s));\n\n\t\t//input = 12345678910l;\n\n\t\tlong newi;\n\n\t\twhile(input / s >= 100){\n\n\t\t\t\n\n\t\t\tnewi = input / 10;\n\n\t\t\tcount += input - newi;\n\n\t\t\tinput = newi;\n\n\t\t}\n\n\t\t//System.out.println((double)input/(double)s);\n\n\t\t//while((double)input/(double)s >1.05 && input >10000){\n\n\t\twhile(input - s > 1000){\n\n\t\t\tif(input == 1000 + s){break;}\n\n\t\t\tnewi = input;\n\n\t\t\tinput = 1000 + s;\n\n\t\t\tif(newi >= input){\n\n\t\t\tcount += newi - input;}\n\n\t\t}\n\n\t\t\n\n\t\t\n\n\t\twhile(input > s){\n\n\t\t\tint sum = 0;\n\n\t\t\tsomeinp = Long.toString(input);\n\n\t\t\tfor(char a : someinp.toCharArray()){\n\n\t\t\t\tsum += a - '0';\n\n\t\t\t}\n\n\t\t\tif(input - sum >= s){count++;}\n\n\t\t\tinput--;\n\n\t\t}\n\n\t\tSystem.out.println(Long.toString(count));\n\n\t\t//long endTime = System.currentTimeMillis();\n\n\t\t//long finishTime = endTime - startTime;\n\n\t\t//System.out.println(Long.toString(finishTime));\n\n\t}\n\n}\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class Pilpeline {\n\tpublic static BigInteger oneTo(BigInteger n) {\n\t\treturn (n.multiply(n.add(new BigInteger(\"1\")))).divide(new BigInteger(\"2\"));\n\t}\n\tpublic static BigInteger total(BigInteger i,BigInteger j) {\n\t\treturn oneTo(i).subtract(oneTo(j)).subtract(j).add(i);\n\t}\n\tpublic static long sum(long k) {\n\t\treturn (long) (k*(k+1)/2);\n\t}\n\tpublic static long sum(long i,long j) {\n\t\treturn (long)(sum(j)-sum(i-1));\n\t}\n\tpublic static long getMin(long n,long k) {\n\t\tlong st=1,end=k;\n\t\twhile(st<end) {\n\t\t\tlong mid=(st+end)/2;\n\t\t\tlong s=sum(mid,k);\n\t\t\tif(s==n)\n\t\t\t\treturn k-mid+1;\n\t\t\telse if (s>n)\n\t\t\t\tst=mid+1;\n\t\t\telse\n\t\t\t\tend=mid;\n\t\t}\n\t\treturn k-st+2;\n\t\t\n\t}\npublic static void main(String[]args) throws NumberFormatException, IOException {\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tPrintWriter out = new PrintWriter(System.out);\n\tStringTokenizer st;\n\tst = new StringTokenizer(br.readLine());\n\tlong n=Long.parseLong(st.nextToken());\n\tlong k=Long.parseLong(st.nextToken());\n\tif(n==1) {\n\t\tout.println(0);\n\t}\n\telse if (k>=n) {\n\t\tout.println(1);\n\t}else {\n\t\tn--;k--;\n\t\tif(sum(k)<n) {\n\t\t\tout.println(-1);\n\t\t}else {\n\t\t\tout.println(getMin(n,k));\n\t\t}\n\t}\n\tout.close();\n\t\n}\n}\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] ar = new int[n];\n            for (int i = 0; i < n; i++)\n                ar[i] = in.nextInt();\n            Arrays.sort(ar);\n            boolean[] u = new boolean[n];\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (!u[i]) {\n                    u[i] = true;\n                    ans++;\n                    for (int j = 0; j < n; j++) {\n                        if (!u[j] && ar[j] % ar[i] == 0) {\n                            u[j] = true;\n                        }\n                    }\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n        ArrayList<Integer>[] g;\n        int n, m;\n        boolean[][] have;\n        int[] x;\n        int[] y;\n        boolean[] used;\n        int stop;\n        \n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n                n = in.nextInt();\n                g = new ArrayList[n];\n                for (int i = 0; i < n; i++)\n                        g[i] = new ArrayList<>();\n                have = new boolean[n][n];\n                m = in.nextInt();\n                for (int i = 0; i < m; i++) {\n                        int a = in.nextInt();\n                        int b = in.nextInt();\n                        --a;\n                        --b;\n                        g[a].add(b);\n                        have[a][b] = true;\n                }\n                int res = Integer.MAX_VALUE;\n                for (int center = 0; center < n; center++)\n                        res = Math.min(res, solve(center));\n                out.print(res);\n        }\n\n        int solve(int v) {\n                stop = v;\n                int withV = 0;\n                int add = 0;\n                for (int i = 0; i < n; i++)\n                        if (i != v)\n                                if (have[v][i])\n                                        withV++;\n                                else\n                                        add++;\n                for (int i = 0; i < n; i++)\n                        if (i != v)\n                                if (have[i][v])\n                                        withV++;\n                                else\n                                        add++;\n                if (have[v][v])\n                        withV++;\n                else\n                        add++;\n                x = new int[n];\n                y = new int[n];\n                used = new boolean[n];\n                Arrays.fill(x, -1);\n                Arrays.fill(y, -1);\n                int matched = 0;\n                for (int i = 0; i < n; i++)\n                        if (i != v && x[i] == -1) {\n                                Arrays.fill(used, false);\n                                if (dfs(i))\n                                        matched++;\n                        }\n                add += n - 1 - matched;\n                add += m - withV - matched;\n                return add;\n        }\n        \n        boolean dfs(int v) {\n                if (used[v])\n                        return false;\n                used[v] = true;\n                for (int to : g[v])\n                        if (to != stop && y[to] == -1) {\n                                x[v] = to;\n                                y[to] = v;\n                                return true;\n                        }\n                for (int to : g[v])\n                        if (to != stop && dfs(y[to])) {\n                                x[v] = to;\n                                y[to] = v;\n                                return true;\n                        }\n                return false;\n        }\n}\n\nclass FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public FastScanner(InputStream inputStream)  {\n                reader = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String nextToken() {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                        String line;\n                        try {\n                                line = reader.readLine();\n                        } catch (IOException e) {\n                                return null;\n                        }\n                        tokenizer = new StringTokenizer(line);\n                }\n                return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n                return Integer.parseInt(nextToken());\n        }\n\n        }\n\n", "complexity": "cubic", "problem": "0387_D", "from": "CODEFORCES", "tags": "graph matchings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author beginner1010\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF2 solver = new TaskF2();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF2 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n            HashMap<Integer, Integer> lastIndex = new HashMap<>();\n            HashMap<Integer, Integer> maxSize = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                int sum = 0;\n                for (int j = i; j < n; j++) {\n                    sum += a[j];\n                    if (maxSize.containsKey(sum) == false) {\n                        maxSize.put(sum, 0);\n                    }\n                    int curMaxSize = maxSize.get(sum);\n                    int curLastIndex = curMaxSize == 0 ? -1 : lastIndex.get(sum);\n                    if (curMaxSize == 0 || curLastIndex < i) {\n                        curMaxSize++;\n                        curLastIndex = j;\n                    } else if (curLastIndex >= j) {\n                        curLastIndex = j;\n                    }\n                    maxSize.put(sum, curMaxSize);\n                    lastIndex.put(sum, curLastIndex);\n                }\n            }\n\n            int bestSum = -1;\n            int bestSize = -1;\n            for (int sum : maxSize.keySet()) {\n                if (maxSize.get(sum) > bestSize) {\n                    bestSize = maxSize.get(sum);\n                    bestSum = sum;\n                }\n            }\n\n            ArrayList<Interval> best = new ArrayList<>();\n            lastIndex = new HashMap<>();\n            maxSize = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                int sum = 0;\n                for (int j = i; j < n; j++) {\n                    sum += a[j];\n                    if (sum != bestSum)\n                        continue; // consider only bestSums\n                    if (maxSize.containsKey(sum) == false) {\n                        maxSize.put(sum, 0);\n                    }\n                    int curMaxSize = maxSize.get(sum);\n                    int curLastIndex = curMaxSize == 0 ? -1 : lastIndex.get(sum);\n                    if (curMaxSize == 0 || curLastIndex < i) {\n                        curMaxSize++;\n                        curLastIndex = j;\n                        best.add(new Interval(i, j));\n                    } else if (curLastIndex >= j) {\n                        curLastIndex = j;\n                        best.set(best.size() - 1, new Interval(i, j));\n                    }\n                    maxSize.put(sum, curMaxSize);\n                    lastIndex.put(sum, curLastIndex);\n                }\n            }\n\n            out.println(bestSize);\n            for (Interval i : best) {\n                out.println((i.l + 1) + \" \" + (i.r + 1));\n            }\n        }\n\n        class Interval {\n            int l;\n            int r;\n\n            Interval(int l, int r) {\n                this.l = l;\n                this.r = r;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputStream stream;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhitespace(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isWhitespace(c));\n            return res * sgn;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n/**\n * Created by James on 1/29/2015.\n */\npublic class Driver {\n    private static int [][] distances, parents;\n    private static int [] distance, parent;\n    private static String [][] longNames;\n    private static String [] shortNames, answers;\n    private static int N;\n\n    public static void main(String [] args) throws IOException {\n        BufferedReader scanner = new BufferedReader(new InputStreamReader(System.in));\n\n        String [] pieces = scanner.readLine().split(\"\\\\s+\");\n\n        //totally had to steal the vast majority of this from http://codeforces.com/contest/8/submission/9745593\n\n        Point origin = new Point(Integer.parseInt(pieces[0]), Integer.parseInt(pieces[1]));\n\n        N = Integer.parseInt(scanner.readLine());\n\n        Point [] points = new Point[N + 1];\n        distances = new int[N  + 1][N + 1];\n        parents = new int[N + 1][N + 1];\n        longNames = new String[N][N];\n        shortNames = new String[N];\n\n        for (int i = 0; i < N; ++i) {\n            pieces = scanner.readLine().split(\"\\\\s+\");\n\n            points[i] = new Point(Integer.parseInt(pieces[0]), Integer.parseInt(pieces[1]));\n        }\n\n        points[N] = origin;\n\n        for (int i = 0; i <= N; ++i) {\n            if (i < N) {\n                shortNames[i] = (i + 1) + \" \";\n            }\n\n            for (int j = 0; j <= N; ++j) {\n                if (i < N && j < N) {\n                    longNames[i][j] = (i + 1) + \" \" + (j + 1) + \" \";\n                }\n\n                distances[i][j] = 2 * points[i].distance(points[j]);\n                parents[i][j] = points[i].distance(points[N]) + points[i].distance(points[j]) + points[j].distance(points[N]);\n            }\n        }\n\n        distance = new int[1 << N];\n        parent = new int[1 << N];\n        answers = new String[1 << N];\n        Arrays.fill(distance, -1);\n        distance[0] = 0;\n\n        int result = rec((1 << N) - 1);\n        StringBuilder answer = new StringBuilder();\n\n        for (int i = distance.length - 1; parent[i] != i; i = parent[i]) {\n            answer.append(\"0 \");\n            answer.append(answers[i]);\n        }\n\n        answer.append(\"0\");\n        System.out.println(result);\n        System.out.println(answer.toString());\n    }\n\n    private static int rec(int mask) {\n        if (distance[mask] != -1) {\n            return distance[mask];\n        }\n\n        int min = 0;\n\n        while (((1 << min) & mask) == 0) {\n            min++;\n        }\n\n        int newMask = mask & (~(1 << min));\n        distance[mask] = rec(newMask) + distances[min][N];\n        parent[mask] = newMask;\n        answers[mask] = shortNames[min];\n\n        for (int i = min + 1; i < N; i++) {\n            if (((1 << i) & mask) > 0) {\n                newMask = mask & (~(1 << i)) & (~(1 << min));\n\n                int temp = rec(newMask) + parents[i][min];\n\n                if (temp< distance[mask]) {\n                    distance[mask] = temp;\n                    parent[mask] = newMask;\n                    answers[mask] = longNames[min][i];\n                }\n            }\n        }\n\n        return distance[mask];\n    }\n\n    private static class Point {\n        int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int distance(Point p) {\n            return (int)(Math.pow(this.x - p.x, 2) + Math.pow(this.y - p.y, 2));\n        }\n    }\n}", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int[] a = new int[n];\n        boolean has_more_than_one = false;\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n            if (a[i] > 1)\n                has_more_than_one = true;\n        }\n\n        Arrays.sort(a);\n\n        if (n == 1) {\n            if (a[0] == 1)\n                out.print(2);\n            else\n                out.print(1);\n        } else {\n            out.print(1 + \" \");\n            for (int i = 1; i < n; i++) {\n                if (has_more_than_one || i < n - 1)\n                    out.print(a[i - 1] + \" \");\n                else\n                    out.println(2);\n            }\n        }\n\n        out.close();\n    }\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\n    void solve(){\n       int n=ni();\n       A=ni(); B=ni(); C=ni(); T=ni();\n       a=new int[T+1];\n       for(int i=1;i<=n;i++) a[ni()]++;\n       long ans=0;\n       for(int i=0;i<=T;i++){\n           if(a[i]==0) continue;\n           long tt=(T-i);\n           if(C>B) ans+=(A-tt*B+tt*C)*a[i];\n           else ans+=A*a[i];\n       }\n       pw.println(ans);\n    }\n    int A,B,C,T;\n    int a[];\n\n    long M=(long)1e9+7;\n    InputStream is;\n    PrintWriter pw;\n    String INPUT = \"\";\n    void run() throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        pw = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        pw.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n\n    public static void main(String[] args) throws Exception { new Main().run(); }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n\n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n) {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n\n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n\n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n\n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private void tr(Object... o) { if(INPUT.length() > 0)System.out.println(Arrays.deepToString(o)); }\n}", "complexity": "linear", "problem": "0964_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.Scanner;\n\npublic class Prob235A {\n\tpublic static void main(String[] Args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint x = scan.nextInt();\n\t\tif (x < 3) {\n\t\t\tif (x == 1)\n\t\t\t\tSystem.out.println(1);\n\t\t\telse\n\t\t\t\tSystem.out.println(2);\n\t\t} else {\n\t\t\tlong answer = x;\n\t\t\tif (x % 2 == 1) {\n\t\t\t\tanswer *= x - 1;\n\t\t\t\tanswer *= x - 2;\n\t\t\t} else if (x % 3 != 0) {\n\t\t\t\tanswer *= x - 1;\n\t\t\t\tanswer *= x - 3;\n\t\t\t} else {\n\t\t\t\tanswer = x - 1;\n\t\t\t\tanswer *= x - 2;\n\t\t\t\tanswer *= x - 3;\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n}\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n\tpublic static BufferedReader br;\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n\tpublic static void main(String[] args) throws IOException {\n\t\treadInput();\n\t\t\n\t\tint ops = 0;\n\t\tlong curheight = k;\n\t\tint pt = 0;\n\t\twhile (pt < m) {\n\t\t\t//System.out.println(curheight);\n\t\t\tlong bias = 0;\n\t\t\twhile (pt < m && s[pt]<= curheight) {\n\t\t\t\tpt++;\n\t\t\t\tbias++;\n\t\t\t}\n\t\t\tif (bias == 0) {\n\t\t\t\t// Skip to next thing that we dont end up losing pt.\n\t\t\t\t//curheight + k*x <= s[pt]\n\t\t\t\t// (s[pt]-curheight)/k;\n\t\t\t\tlong toadd = (s[pt]-curheight+k-1)/k*k;\n\t\t\t\tif (toadd == 0) break;\n\t\t\t\tcurheight += toadd;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcurheight += bias;\n\t\t\t\tops++;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tout.println(ops);\n\t\tout.close();\n\t}\n\tstatic int m;\n\tstatic long n, k;\n\tstatic long[] s;\n\tpublic static void readInput() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t// br = new BufferedReader(new FileReader(\"in.in\"));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tn  = Long.parseLong(st.nextToken());\n\t\tm = Integer.parseInt(st.nextToken());\n\t\tk = Long.parseLong(st.nextToken());\n\t\ts = new long[m];\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor (int i = 0 ;i  <m; i++)s[i] = Long.parseLong(st.nextToken());\n\t}\n}\n", "complexity": "linear", "problem": "1191_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class testD {\n    public static void main(String[] args) {\n        Scanner input =new Scanner(System.in);\n        int i,j;\n        i=input.nextInt();\n        j=input.nextInt();\n        ArrayList<String> m=new ArrayList<String>();\n        input.nextLine();\n        for(int k=0;k<i;k++){\n            m.add(input.nextLine());\n        }\n\n        ArrayList<Integer> light = new ArrayList<Integer>();\n        for(int k=0;k<j;k++){\n            light.add(0);\n        }\n\n        for(int k=0;k<m.size();k++){\n            for(int l=0;l<j;l++){\n                if (m.get(k).charAt(l)=='1'){\n                    light.set(l,light.get(l)+1);\n                }\n            }\n        }\n        for (int k=0;k<i;k++){\n            if (is(light,j,m,k)){\n                System.out.println(\"YES\");\n                return;\n            }\n        }\n        System.out.println(\"NO\");\n    }\n\n    public static Boolean is(ArrayList<Integer> light,int lightnum,ArrayList<String> button,int buttonnum){\n                for(int j=0;j<lightnum;j++) {\n                    if (button.get(buttonnum).charAt(j) == '1') {\n                        if (light.get(j) - 1 == 0) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n    }\n}\n\n\t  \t    \t\t \t \t \t \t\t \t\t\t\t\t \t\t \t", "complexity": "quadratic", "problem": "0985_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.FileInputStream;\n\nimport java.io.FileOutputStream;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.io.StreamTokenizer;\n\nimport java.util.ArrayDeque;\n\nimport java.util.Arrays;\n\n\n\npublic class Main {\n\n    private static StreamTokenizer in;\n\n    private static PrintWriter out;\n\n    private static BufferedReader inB;\n\n    \n\n    private static int nextInt() throws Exception{\n\n        in.nextToken();\n\n        return (int)in.nval;\n\n    }\n\n    \n\n    private static String nextString() throws Exception{\n\n        in.nextToken();\n\n        return in.sval;\n\n    }\n\n    \n\n    static{\n\n        \n\n        /*\n\n        inB = new BufferedReader(new InputStreamReader(System.in));\n\n        out = new PrintWriter(System.out);\n\n        /**/\n\n        //*\n\n        try {\n\n        inB = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));\n\n        out = new PrintWriter(new FileOutputStream(\"output.txt\"));\n\n        } catch(Exception e) {}\n\n        /**/\n\n        in = new StreamTokenizer(inB);\n\n    }\n\n    \n\n    private static int[][] mind;\n\n    private static boolean[][] used;\n\n    \n\n    private static int n,m;\n\n    \n\n    public static void main(String[] args)throws Exception {\n\n        n = nextInt();\n\n        m = nextInt();\n\n        int k = nextInt();\n\n        int[][] mas = new int[k][2];\n\n        \n\n        for(int i = 0; i<k; i++) {\n\n            mas[i][0] = nextInt()-1;\n\n            mas[i][1] = nextInt()-1;\n\n        }\n\n        \n\n        mind = new int[n][m];\n\n        used = new boolean[n][m];\n\n        for(int i = 0; i<n; i++) {\n\n            Arrays.fill(mind[i], Integer.MAX_VALUE);\n\n        }\n\n        \n\n        ArrayDeque<int[]> ad = new ArrayDeque<int[]>();\n\n        \n\n        for(int i = 0; i<k; i++) {\n\n            ad.add(new int[] {mas[i][0], mas[i][1], 0});\n\n        }\n\n        \n\n        while(!ad.isEmpty()) {\n\n            int[] cur = ad.remove();\n\n            \n\n            if(used[cur[0]][cur[1]])continue;\n\n            int x = cur[0]; int y = cur[1]; int d = cur[2];\n\n            mind[x][y] = ++d;\n\n            used[x][y] = true;\n\n            //if(isValid(x+1,y+1) && !used[x+1][y+1])   ad.add(new int[] {x+1,  y+1, d});\n\n            if(isValid(x+1,y)   && !used[x+1][y])   ad.add(new int[] {x+1,  y,   d});\n\n            //if(isValid(x+1,y-1) && !used[x+1][y-1])   ad.add(new int[] {x+1,  y-1, d});\n\n            if(isValid(x,y+1)   && !used[x][y+1])   ad.add(new int[] {x,    y+1, d});\n\n            if(isValid(x,y-1)   && !used[x][y-1])   ad.add(new int[] {x,    y-1, d});\n\n            //if(isValid(x-1,y+1) && !used[x-1][y+1])   ad.add(new int[] {x-1,  y+1, d});\n\n            if(isValid(x-1,y)   && !used[x-1][y])   ad.add(new int[] {x-1,  y,   d});\n\n            //if(isValid(x-1,y-1) && !used[x-1][y-1])   ad.add(new int[] {x-1,  y-1, d});\n\n        }\n\n        \n\n        int max = Integer.MIN_VALUE;\n\n        int maxx = 0, maxy = 0;\n\n        \n\n        for(int i = 0; i<n; i++) {\n\n            for(int j = 0; j<m; j++) {\n\n                if(mind[i][j] > max) {\n\n                    max = mind[i][j];\n\n                    maxx = i+1;\n\n                    maxy = j+1;\n\n                }\n\n            }\n\n        }\n\n        \n\n        out.println(maxx + \" \" + maxy);\n\n        out.flush();\n\n    }\n\n    \n\n    private static boolean isValid(int x, int y) {\n\n        return x>=0 && x<n && y>=0 && y<m;\n\n    }\n\n    \n\n    /////////////////////////////////////////////////\n\n    // pre - written\n\n    /////////////////////////////////////////////////\n\n    private static void println(Object o) throws Exception {\n\n        System.out.println(o);\n\n    }\n\n    private static void exit(Object o) throws Exception {\n\n        println(o);\n\n        exit();\n\n    }\n\n    private static void exit() {\n\n        System.exit(0);\n\n    }\n\n    /////////////////////////////////\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\n\npublic class B {\n    private static StreamTokenizer in;\n    private static PrintWriter out;\n    \n    private static int nextInt() throws Exception{\n        in.nextToken();\n        return (int)in.nval;\n    }\n    \n    private static String nextString() throws Exception{\n        in.nextToken();\n        return in.sval;\n    }\n    \n    static{\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n    }\n    \n    public static void main(String[] args)throws Exception{\n        int n = nextInt();\n        char[] c = nextString().toCharArray();\n        \n        int tc = 0, hc = 0;\n        for(int i = 0;i<c.length; i++){\n            if(c[i] == 'T')tc++; else hc++;\n        }\n//      char g = 'T';\n//      if(tc > hc){\n//          tc = hc;\n//          g = 'H';\n//      }\n        \n        int max = -1;\n        int pos = 0;\n        for(int i = 0; i<c.length; i++){\n            int a = 0;\n            for(int j = 0; j<tc;j++){\n                int k = i+j;\n                if(k>=n)k-=n;\n                if(c[k] == 'T'){\n                    a++;\n                }\n            }\n            if(a>max){\n                max = a;\n                pos = i;\n            }\n        }\n        int min1 = tc - max;\n        \n        max = -1;\n        pos = 0;\n        for(int i = 0; i<c.length; i++){\n            int a = 0;\n            for(int j = 0; j<hc;j++){\n                int k = i+j;\n                if(k>=n)k-=n;\n                if(c[k] == 'H'){\n                    a++;\n                }\n            }\n            if(a>max){\n                max = a;\n                pos = i;\n            }\n        }\n        int min2 = hc - max;\n        \n        out.println(Math.min(min1, min2));\n        out.flush();\n    }\n}\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.util.Scanner;\n\npublic class A{\n\tpublic static void main(String[] args){\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\n\t\tint prev2=0;\n\t\tint prev1=1;\n\t\tint prev=1;\n\t\tint curr = 2;\n\t\tif(n == 0) {System.out.println(\"0 0 0\"); return;}\n\t\telse if(n == 1) {System.out.println(\"0 0 1\");return;}\n\t\twhile(true){\n\t\t\tif(curr == n) break;\n\t\t\tprev2 = prev1;\n\t\t\tprev1 = prev;\n\t\t\tint temp = prev + curr;\n\t\t\tprev = curr;\n\t\t\tcurr = temp;\n\t\t}\n\t\tSystem.out.println(prev2 + \" \" + prev1 + \" \" + prev1);\n\t}\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.lang.*;\n\npublic class Main {\n    static class Pair\n    {\n        int x;\n        int y;\n        public Pair(int x, int  y)\n        {\n            this.x=x;\n            this.y=y;\n        }\n    }\n    static class Comp implements Comparator<Pair>\n    {\n        public int compare(Pair p1, Pair p2)\n        {\n            if(p1.x!=p2.x && p1.y!=p2.y)\n            {\n                return p1.x-p2.x;\n            }\n            else\n            {\n                return 0;\n            }\n        }\n    }\n\tpublic static void main(String[] args) {\n        FastReader sc =new FastReader();\n        int n = sc.nextInt();\n        char ch1[] = sc.next().toCharArray();\n        char ch2[] = sc.next().toCharArray();\n        int count=0;\n        int i=0;\n        while(i<n)\n        {\n            if(ch1[i]!=ch2[i])\n            {\n                //I can check next also;\n                if(i<n-1)\n                {\n                    if(ch1[i]==ch2[i+1] && ch1[i+1]==ch2[i])\n                    {\n                        count++;\n                        i=i+2;\n                    }\n                    else\n                    {\n                        count++;\n                        i=i+1;\n                    }\n                }\n                else\n                {\n                    count++;\n                    i++;\n                }\n            }\n            else\n            {\n                i++;\n            }\n        }\n        System.out.println(count);\n        \n            \n           \n        \n    }\n    \n    public static void swap(char ch[][], int i, int j, int l, int m)\n    {\n        char temp = ch[i][j];\n        ch[i][j]=ch[l][m];\n        ch[l][m]=temp;\n    }\n    \n    public static int bs(int num[], int x)\n    {\n        int low=0;\n        int high=num.length-1;\n        int ans=-1;\n        while(low<=high)\n        {\n            int mid = low + (high-low)/2;\n            if(num[mid]==x)\n            {\n                ans = mid;\n                high=mid-1;\n            }\n            else if(num[mid]<x)\n            {\n               // ans=mid;\n                low=mid+1;\n            }\n            else\n            {\n                ans=mid;\n                high=mid-1;\n            }\n        }\n        return ans;\n    }\n    \n    \n    public static int partition(int arr[], int low, int high) \n    { \n        int pivot = arr[high];  \n        int i = (low-1);\n        for (int j=low; j<high; j++) \n        { \n            if (arr[j] < pivot) \n            { \n                i++; \n                int temp = arr[i]; \n                arr[i] = arr[j]; \n                arr[j] = temp; \n            } \n        } \n        int temp = arr[i+1]; \n        arr[i+1] = arr[high]; \n        arr[high] = temp; \n  \n        return i+1; \n    } \n    public static void sort(int arr[], int low, int high) \n    { \n        if (low < high) \n        { \n            int pi = partition(arr, low, high); \n            sort(arr, low, pi-1); \n            sort(arr, pi+1, high); \n        } \n    } \n    \n    \n    \n    \n    \n    \n    static int gcd(int a,int b)\n    {\n        if(b==0) return a;\n        return gcd(b,a%b);\n    }\n    \n    \n    static void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n    static void sort(long[] a) {\n\t\tArrayList<Long> l=new ArrayList<>();\n\t\tfor (long i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n \n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n \n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (final IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (final IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tint[] nextIntArray(final int n) {\n\t\t\tfinal int a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = Integer.parseInt(next());\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t}\t\n}\n//private ArrayList<String[]> action = new ArrayList<String[]>();\n\n\n//Templates for Comparator and Classes - @jagrit_07\n/*\nArrays.sort(newEmployees, new Comparator<Employee>() {\n    @Override\n    public int compare(Employee emp1, Employee emp2) {\n        return emp1.getName().compareTo(emp2.getName());\n    }\n});\nclass Pair\n\t{\n\t\t\n\t\tlong i; //index;\n\t\tlong l; //left;\n\t\tlong c; //cost;\n\t\tpublic Pair(long x,long y,long z)\n\t\t{\n\t\t\tthis.i=x;\n\t\t\tthis.l=y;\n\t\t\tthis.c=z;\n\t\t}\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn this.i+\" \"+this.l+\" \"+this.c;\n\t\t}\n\t}\nclass Comp implements Comparator<Pair>\n\t{\n\t\tpublic int compare(Pair p1, Pair p2)\n\t\t{\n\t\t\tif(p1.c!=p2.c)\n\t\t\t{\n\t\t\t\treturn (int)(p1.c-p2.c); //sort acc to cost;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn (int)(p1.i-p2.i); //sort acc to index;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n*/\n\n/*\n  HashMap - Put template - d.put(a1,d.getOrDefault(a1,0)+1);\n  for (Map.Entry<String, Integer> entry : map.entrySet()) {\n        System.out.println(entry.getKey() + \":\" + entry.getValue());\n    }\n  Deque<String> deque \n            = new LinkedList<String>();  \n            \n  List<Integer> c[] = new ArrayList[3];          \n*/", "complexity": "linear", "problem": "1037_C", "from": "CODEFORCES", "tags": "dp,greedy,strings"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1517d {\n\n    public static void main(String[] args) throws IOException {\n        int n = rni(), m = ni(), k = ni(), ans[][] = new int[n][m];\n        WGraph g = wgraph(n * m);\n        for (int i = 0; i < n; ++i) {\n            r();\n            for (int j = 0; j < m - 1; ++j) {\n                g.c(i * m + j, i * m + j + 1, ni());\n            }\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            r();\n            for (int j = 0; j < m; ++j) {\n                g.c(i * m + j, (i + 1) * m + j, ni());\n            }\n        }\n        if (k % 2 == 1) {\n            for (int[] row : ans) {\n                fill(row, -1);\n                prln(row);\n            }\n            close();\n            return;\n        }\n        k >>= 1;\n        for (int l = 0; l < k; ++l) {\n            int nans[][] = new int[n][m];\n            for (int[] row : nans) {\n                fill(row, IBIG);\n            }\n            for (int i = 0; i < n * m; ++i) {\n                for (int ed[] : g.get(i)) {\n                    int j = ed[0], d = ed[1];\n                    if (ans[i / m][i % m] + d < nans[j / m][j % m]) {\n                        nans[j / m][j % m] = ans[i / m][i % m] + d;\n                    }\n                }\n            }\n            ans = nans;\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                ans[i][j] *= 2;\n            }\n        }\n        for (int[] row : ans) {\n            prln(row);\n        }\n        close();\n    }\n\n    static int solve(WGraph g, int i, int k) {\n        List<Map<Integer, Integer>> cost = new ArrayList<>();\n        for (int j = 0; j <= k; ++j) {\n            cost.add(new HashMap<>());\n        }\n        PriorityQueue<int[]> dijk = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        dijk.offer(new int[] {i, 0, 0});\n        cost.get(0).put(i, 0);\n        while (!dijk.isEmpty()) {\n            int e[] = dijk.poll(), node = e[0], dist = e[1], co = e[2];\n            if (co > cost.get(dist).get(node)) {\n                continue;\n            }\n            if (dist == k) {\n                return 2 * co;\n            }\n            if (dist < k) {\n                for (int ed[] : g.get(node)) {\n                    int j = ed[0], c = ed[1];\n                    if (co + c < cost.get(dist + 1).getOrDefault(j, IBIG)) {\n                        cost.get(dist + 1).put(j, co + c);\n                        dijk.offer(new int[] {j, dist + 1, co + c});\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    static WGraph wgraph(int n) {\n        WGraph g = new WGraph();\n        for (int i = 0; i < n; ++i) {\n            g.add(new ArrayList<>());\n        }\n        return g;\n    }\n\n    static WGraph wgraph(int n, int m) throws IOException {\n        WGraph g = wgraph(n);\n        for (int i = 0; i < m; ++i) {\n            g.c(rni() - 1, ni() - 1, ni());\n        }\n        return g;\n    }\n\n    static WGraph wdigraph(int n, int m) throws IOException {\n        WGraph g = wgraph(n);\n        for (int i = 0; i < m; ++i) {\n            g.cto(rni() - 1, ni() - 1, ni());\n        }\n        return g;\n    }\n\n    static class WGraph extends ArrayList<List<int[]>> {\n        void cto(int u, int v, int w) {\n            get(u).add(new int[] {v, w});\n        }\n\n        void c(int u, int v, int w) {\n            cto(u, v, w);\n            cto(v, u, w);\n        }\n    }\n\n    static BufferedReader __i = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __o = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __r = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final long LMAX = 9223372036854775807L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n    static long gcd(long a, long b) {return b == 0 ? a : gcd(b, a % b);}\n    static int[] exgcd(int a, int b) {if (b == 0) return new int[] {1, 0}; int[] y = exgcd(b, a % b); return new int[] {y[1], y[0] - y[1] * (a / b)};}\n    static long[] exgcd(long a, long b) {if (b == 0) return new long[] {1, 0}; long[] y = exgcd(b, a % b); return new long[] {y[1], y[0] - y[1] * (a / b)};}\n    static int randInt(int min, int max) {return __r.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __i.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__o.print(i);}\n    static void prln(int i) {__o.println(i);}\n    static void pr(long l) {__o.print(l);}\n    static void prln(long l) {__o.println(l);}\n    static void pr(double d) {__o.print(d);}\n    static void prln(double d) {__o.println(d);}\n    static void pr(char c) {__o.print(c);}\n    static void prln(char c) {__o.println(c);}\n    static void pr(char[] s) {__o.print(new String(s));}\n    static void prln(char[] s) {__o.println(new String(s));}\n    static void pr(String s) {__o.print(s);}\n    static void prln(String s) {__o.println(s);}\n    static void pr(Object o) {__o.print(o);}\n    static void prln(Object o) {__o.println(o);}\n    static void prln() {__o.println();}\n    static void pryes() {prln(\"yes\");}\n    static void pry() {prln(\"Yes\");}\n    static void prY() {prln(\"YES\");}\n    static void prno() {prln(\"no\");}\n    static void prn() {prln(\"No\");}\n    static void prN() {prln(\"NO\");}\n    static boolean pryesno(boolean b) {prln(b ? \"yes\" : \"no\"); return b;};\n    static boolean pryn(boolean b) {prln(b ? \"Yes\" : \"No\"); return b;}\n    static boolean prYN(boolean b) {prln(b ? \"YES\" : \"NO\"); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(\"hlfd\"); flush();}\n    static void flush() {__o.flush();}\n    static void close() {__o.close();}\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "/*\n * \n * @Author  Ajudiya_13(Bhargav Girdharbhai Ajudiya)\n * Dhirubhai Ambani Institute of Information And Communication Technology \n * \n */\n\n\nimport java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\npublic class Code3\n{\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tlong x = in.nextLong();\n\t\tlong k = in.nextLong();\n\t\t\n\t\tif(x==0)\n\t\t\tpw.println(0);\n\t\telse\n\t\t{\n\t\t\tlong mul = modularExponentiation(2L, k, mod);\n\t\t\tx = (x%mod * 2L%mod)%mod;\n\t\t\tx = (x%mod - 1L%mod + mod)%mod;\n\t\t\tx = (x%mod * mul%mod)%mod;\n\t\t\tx = (x%mod + 1%mod)%mod; \n\t\t\tpw.print(x);\n\t\t}\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\tstatic class InputReader \n\t{\n\t\t \n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\t\tprivate SpaceCharFilter filter;\n \n\t\tpublic InputReader(InputStream stream) \n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n \n\t\tpublic int snext() \n\t\t{\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) \n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} \n\t\t\t\tcatch (IOException e) \n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n \n\t\tpublic int nextInt() \n\t    {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) \n\t\t\t{\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-')\n\t\t    {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic long nextLong()\n\t    {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) \n\t\t\t{\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic int[] nextIntArray(int n) \n\t\t{\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t{\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic String readString()\n\t    {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) \n\t\t\t{\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic String nextLine() \n\t\t{\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic boolean isSpaceChar(int c) \n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n \n\t\tprivate boolean isEndOfLine(int c) \n\t\t{\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n \n\t\tpublic interface SpaceCharFilter\n\t    {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n\t\n\tpublic static long mod = 1000000007;\n\tpublic static int d;\n\tpublic static int p;\n\tpublic static int q;\n\t\n\tpublic static int[] suffle(int[] a,Random gen)\n\t{\n\t\tint n = a.length;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint ind = gen.nextInt(n-i)+i;\n\t\t\tint temp = a[ind];\n\t\t\ta[ind] = a[i];\n\t\t\ta[i] = temp;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic static void swap(int a, int b){\n\t\tint temp = a;\n\t\ta = b;\n\t\tb = temp;\n\t}\n\t\n\tpublic static HashSet<Integer> primeFactorization(int n)\n\t{\n\t\tHashSet<Integer> a =new HashSet<Integer>();\n\t\tfor(int i=2;i*i<=n;i++)\n\t\t{\n\t\t\twhile(n%i==0)\n\t\t\t{\n\t\t\t\ta.add(i);\n\t\t\t\tn/=i;\n\t\t\t}\n\t\t}\n\t\tif(n!=1)\n\t\t\ta.add(n);\n\t\treturn a;\n\t}\n\t\n\tpublic static void sieve(boolean[] isPrime,int n)\n\t{\n\t\tfor(int i=1;i<n;i++)\n\t\t\tisPrime[i] = true;\n\t\t\n\t\tisPrime[0] = false;\n\t\tisPrime[1] = false;\n\t\t\n\t\tfor(int i=2;i*i<n;i++)\n\t\t{\n\t\t\tif(isPrime[i] == true)\n\t\t\t{\n\t\t\t\tfor(int j=(2*i);j<n;j+=i)\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static int GCD(int a,int b)\n\t{\n\t\tif(b==0)\n\t\t\treturn a;\n\t\telse\n\t\t\treturn GCD(b,a%b);\n\t}\n\t\n\tpublic static long GCD(long a,long b)\n\t{\n\t\tif(b==0)\n\t\t\treturn a;\n\t\telse\n\t\t\treturn GCD(b,a%b);\n\t}\n\t\n\tpublic static void extendedEuclid(int A,int B)\n\t{\n\t\tif(B==0)\n\t\t{\n\t\t\td = A;\n\t\t\tp = 1 ;\n\t\t\tq = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\textendedEuclid(B, A%B);\n\t\t\tint temp = p;\n\t\t\tp = q;\n\t\t\tq = temp - (A/B)*q;\n\t\t}\n\t}\n\t\n\tpublic static long LCM(long a,long b)\n\t{\n\t\treturn (a*b)/GCD(a,b);\n\t}\n\t\n\tpublic static int LCM(int a,int b)\n\t{\n\t\treturn (a*b)/GCD(a,b);\n\t}\n\t\n\tpublic static int binaryExponentiation(int x,int n)\n\t{\n\t    int result=1;\n\t    while(n>0)\n\t    {\n\t        if(n % 2 ==1)\n\t            result=result * x;\n\t        x=x*x;\n\t        n=n/2;\n\t    }\n\t    return result;\n\t}\n\t\n\tpublic static long binaryExponentiation(long x,long n)\n\t{\n\t    long result=1;\n\t    while(n>0)\n\t    {\n\t        if(n % 2 ==1)\n\t            result=result * x;\n\t        x=x*x;\n\t        n=n/2;\n\t    }\n\t    return result;\n\t}\n\t\n\tpublic static int modularExponentiation(int x,int n,int M)\n\t{\n\t    int result=1;\n\t    while(n>0)\n\t    {\n\t        if(n % 2 ==1)\n\t            result=(result * x)%M;\n\t        x=(x*x)%M;\n\t        n=n/2;\n\t    }\n\t    return result;\n\t}\n\t\n\tpublic static long modularExponentiation(long x,long n,long M)\n\t{\n\t    long result=1;\n\t    while(n>0)\n\t    {\n\t        if(n % 2 ==1)\n\t            result=(result * x)%M;\n\t        x=(x*x)%M;\n\t        n=n/2;\n\t    }\n\t    return result;\n\t}\n\t\n\tpublic static int modInverse(int A,int M)\n\t{\n\t    return modularExponentiation(A,M-2,M);\n\t}\n\t\n\tpublic static long modInverse(long A,long M)\n\t{\n\t    return modularExponentiation(A,M-2,M);\n\t}\n\t\n\tpublic static boolean isPrime(int n)\n\t{\n\t    \n\t    if (n <= 1)  return false;\n\t    if (n <= 3)  return true;\n\t    \n\t    if (n%2 == 0 || n%3 == 0) \n\t    \treturn false;\n\t \n\t    for (int i=5; i*i<=n; i=i+6)\n\t    {\n\t        if (n%i == 0 || n%(i+2) == 0)\n\t           return false;\n\t    }\n\t    \n\t    return true;\n\t}\n\t\n\tstatic class pair implements Comparable<pair>\n\t{\n\t\tInteger x, y;\n\t\tpair(int x,int y)\n\t\t{\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t\tpublic int compareTo(pair o) {\n\t\t\tint result = x.compareTo(o.x);\n\t\t\tif(result==0)\n\t\t\t\tresult = y.compareTo(o.y);\n\t\t\t\n\t\t\treturn result;\n\t\t}  \n\t\t\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn x+\" \"+y;\n\t\t}\n\t\t\n\t\tpublic boolean equals(Object o)\n\t\t{\n\t\t\tif (o instanceof pair)\n\t\t    {\n\t\t\t\tpair p = (pair)o;\n\t\t\t\treturn p.x == x && p.y == y ;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tpublic int hashCode()\n\t\t{\n\t\t\treturn new Long(x).hashCode()*31 + new Long(y).hashCode();\n\t\t}\n\t}\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "\n// Problem : G1. Playlist for Polycarp (easy version)\n// Contest : Codeforces - Codeforces Round #568 (Div. 2)\n// URL : https://codeforces.com/contest/1185/problem/G1\n// Memory Limit : 256 MB\n// Time Limit : 5000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class a implements Runnable{\n\t\n    public static void main(String[] args) {\n        new Thread(null, new a(), \"process\", 1<<26).start();\n    }\n\tpublic void run() {\n\t\tFastReader scan = new FastReader();\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t//PrintWriter out = new PrintWriter(\"file.out\");\n\t\tTask solver = new Task();\n\t\t//int t = scan.nextInt();\n\t\tint t = 1;\n\t\tfor(int i = 1; i <= t; i++) solver.solve(i, scan, out);\n\t\tout.close();\n\t}\n\n\tstatic class Task {\n\t\tstatic final int inf = Integer.MAX_VALUE;\n\n\t\tpublic void solve(int testNumber, FastReader sc, PrintWriter pw) {\n\t\t\t//CHECK FOR QUICKSORT TLE\n\t\t\t//***********************//\n\t\t\t//CHECK FOR INT OVERFLOW\n\t\t\t//***********************//\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\ttup[] arr = new tup[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = new tup(sc.nextInt(), sc.nextInt()-1);\n\t\t\t}\n\t\t\tList<Integer>[] arr2 = Stream.generate(ArrayList::new).limit(16).toArray(List[]::new);\n\t\t\tfor(int i = 1; i < (1<<n); i++) {\n\t\t\t\tint t = i;\n\t\t\t\tint bits = 0;\n\t\t\t\twhile(t > 0) {\n\t\t\t\t\tif((t & 1) == 1) bits ++;\n\t\t\t\t\tt>>=1;\n\t\t\t\t}\n\t\t\t\tarr2[bits].add(i);\n\t\t\t}\n\t\t\tint[][] dp = new int[1<<n][3];\n\t\t\tdp[0] = new int[]{1, 1, 1};\n\t\t\tlong c = 0;\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tfor(int x : arr2[i]) {\n\t\t\t\t\tint totallen = 0;\n\t\t\t\t\tArrayList<Integer> active = new ArrayList<>();\n\t\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\t\tif((x & (1 << j)) > 0){\n\t\t\t\t\t\t\tactive.add(j);\n\t\t\t\t\t\t\ttotallen += arr[j].a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int y : active) {\n\t\t\t\t\t\tif(i == 1) dp[x][arr[y].b]++;\n\t\t\t\t\t\telse dp[x][arr[y].b] += dp[x - (1<<y)][(arr[y].b+1)%3] + dp[x - (1<<y)][(arr[y].b+2)%3];\n\t\t\t\t\t\tdp[x][arr[y].b] %= 1000000007;\n\t\t\t\t\t}\n\t\t\t\t\tif(totallen == m) {\n\t\t\t\t\t\tc += dp[x][0] + dp[x][1] + dp[x][2];\n\t\t\t\t\t\tc %= 1000000007;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpw.println(c);\n\t\t}\n\t}\n\tstatic long binpow(long a, long b, long m) {\n\t\ta %= m;\n\t\tlong res = 1;\n\t\twhile (b > 0) {\n\t\t\tif ((b & 1) == 1)\n\t\t\t\tres = res * a % m;\n\t\t\ta = a * a % m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic void sort(int[] x){\n\t\tshuffle(x);\n\t\tArrays.sort(x);\n\t}\n\tstatic void sort(long[] x){\n\t\tshuffle(x);\n\t\tArrays.sort(x);\n\t}\n\tstatic class tup implements Comparable<tup>{\n\t\tint a, b;\n\t\ttup(int a,int b){\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(tup o){\n\t\t\treturn Integer.compare(o.b,b);\n\t\t}\n\t}\n\tstatic void shuffle(int[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(i + 1);\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t}\n\n\tstatic void shuffle(long[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(i + 1);\n\t\t\tlong temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n}", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "/**\n * @author Finn Lidbetter\n */\nimport java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\n\npublic class TaskA {\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringBuilder sb = new StringBuilder();\n\n    int n = Integer.parseInt(br.readLine());\n    String[] s = br.readLine().split(\" \");\n    int[] arr = new int[n];\n    for (int i=0; i<n; i++) {\n      arr[i] = Integer.parseInt(s[i]);\n    }\n    Arrays.sort(arr);\n    boolean[] vis = new boolean[n];\n    int nColours = 0;\n    int nVis = 0;\n    int index = 0;\n    while (nVis<n) {\n      while (index<n && nVis<n) {\n        if (vis[index]) {\n          index++;\n          continue;\n        }\n        int val = arr[index];\n        nColours++;\n        while (index<n && nVis<n) {\n          if (vis[index]) {\n            index++;\n            continue;\n          }\n          if (arr[index]%val==0) {\n            vis[index] = true;\n            nVis++;\n          }\n          index++;\n        }\n        index = 0;\n      }\n    }\n    System.out.println(nColours);\n\n  }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        int kisu = 0;\n        int gusu = 0;\n        for(int i = 0 ; i < n ; i++){\n            nums[i] = sc.nextInt();\n            if(nums[i] % 2 == 0)gusu++;\n            if(nums[i] % 2 == 1)kisu++;\n        }\n        int ans = -1;\n        if(gusu == 1){\n            for(int i = 0 ; i < n ; i++){\n                if(nums[i]%2 == 0){\n                    ans = i+1;\n                    break;\n                }\n            }\n        }\n        else{\n            for(int i = 0 ; i < n ; i++){\n                if(nums[i]%2 == 1){\n                    ans = i+1;\n                    break;\n                }\n            }\n            \n        }\n        System.out.println(ans);\n    }\n\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    \n    static final int MAXN = 24;\n    int[] x = new int[MAXN];\n    int[] y = new int[MAXN];\n    int[][] dist = new int[MAXN][MAXN];\n    int[] single = new int[MAXN];\n    \n    int sqr(int x) { return x * x; }\n    \n    void run(int nT) {\n        int xs = cin.nextInt();\n        int ys = cin.nextInt();\n        int n = cin.nextInt();\n        for (int i = 0; i < n; ++i) {\n            x[i] = cin.nextInt();\n            y[i] = cin.nextInt();\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                dist[i][j] = sqr(x[i] - xs) + sqr(y[i] - ys)\n                    + sqr(x[i] - x[j]) + sqr(y[i] - y[j]) + sqr(x[j] - xs) + sqr(y[j] - ys);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            single[i] = (sqr(x[i] - xs) + sqr(y[i] - ys)) * 2;\n        }\n        int[] dp = new int[1 << n];\n        int[] pre = new int[1 << n];\n        int tot = 1 << n;\n        for (int s = 1; s < tot; ++s) {\n            int i;\n            for (i = 0; i < n; ++i) {\n                if ((s & (1 << i)) != 0) break;\n            }\n            dp[s] = dp[s^(1<<i)] + single[i];\n            pre[s] = i + 1;\n            for (int j = i + 1; j < n; ++j) {\n                if ((s & (1 << j)) != 0) {\n                    int cur = dp[s^(1 << i) ^(1<<j)] + dist[i][j];\n                    if (cur < dp[s]) {\n                        dp[s] = cur;\n                        pre[s] = (i + 1) * 100 + (j + 1);\n                    }\n                }\n            }\n        }\n        out.println(dp[tot - 1]);\n        int now = tot - 1;\n        out.print(\"0\");\n        while (now > 0) {\n            int what = pre[now];\n            int px = what % 100 - 1;\n            int py = what / 100 - 1;\n            if (px >= 0) {\n                out.print(\" \");\n                out.print(px + 1);\n                now ^= 1 << px;\n            }\n            if (py >= 0) {\n                out.print(\" \");\n                out.print(py + 1);\n                now ^= 1 << py;\n            }\n            out.print(\" \");\n            out.print(\"0\");\n        }\n        out.println(\"\");\n    }\n\n    public static void main(String[] argv) {\n        Main solved = new Main();\n        int T = 1;\n        // T = solved.cin.nextInt();\n        for (int nT = 1; nT <= T; ++nT) {\n            solved.run(nT);\n        }\n        solved.out.close();\n    }\n\n    InputReader cin = new InputReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n}\n\nclass InputReader {\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n}", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n\tstatic Scanner in = new Scanner(new BufferedInputStream(System.in));\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic double getTime(double v, double a, double l, double r) {\n\t\treturn (-v + Math.sqrt(v * v - 2 * a * (l - r))) / a;\n\t}\n\n\tstatic double getVelocity(double v, double t, double l, double r) {\n\t\treturn t == 0 ? v : (2 * (r - l)) / t - v;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tdouble a = in.nextDouble(), v = in.nextDouble(), l = in.nextDouble(),\n\t\t\t\td = in.nextDouble(), w = Math.min(v, in.nextDouble());\n\n\t\tdouble x = v * v / (2 * a), y = d - (v * v - w * w) / (2 * a),\n\t\t\t\tz = d + (v * v - w * w) / (2 * a);\n\t\t//out.println(x + \" \" + y + \" \" + z);\n\t\tdouble L, R, T = 0, V = 0, t;\n\n\t\t//OX\n\t\tL = 0;\n\t\tR = x;\n\t\tif (x > y && x < z) {\n\t\t\tR = (x + y) / 2;\n\t\t} else if (x > l) {\n\t\t\tR = l;\n\t\t}\n\t\tt = getTime(V, a, L, R);\n\t\tV = getVelocity(V, t, L, R);\n\t\t//out.println(\"l: \" + L + \", r: \" + R + \", t: \" + t + \", v: \" + V);\n\t\tT += t;\n\n\t\t//XY\n\t\tif (x < y) {\n\t\t\tT += (y - x) / v;\n\t\t}\n\t\t//out.println(\"t: \" + (T - t));\n\n\t\t//YD\n\t\tL = y;\n\t\tR = d;\n\t\tif (x > y && x < z) {\n\t\t\tL = (x + y) / 2;\n\t\t} else if (x >= z) {\n\t\t\tL = R;\n\t\t}\n\t\tt = getTime(V, -a, L, R);\n\t\tV = getVelocity(V, t, L, R);\n\t\tT += t;\n\t\t//out.println(\"l: \" + L + \", r: \" + R + \", t: \" + t + \", v: \" + V);\n\n\t\t//DZ\n\t\tL = d;\n\t\tR = z;\n\t\tif (x >= z) {\n\t\t\tR = L;\n\t\t} else if (z > l) {\n\t\t\tR = l;\n\t\t}\n\t\tt = getTime(V, a, L, R);\n\t\tV = getVelocity(V, t, L, R);\n\t\tT += t;\n\t\t//out.println(\"l: \" + L + \", r: \" + R + \", t: \" + t + \", v: \" + V);\n\n\t\t//ZL\n\t\tL = z;\n\t\tR = l;\n\t\tif (x > z) {\n\t\t\tL = x;\n\t\t}\n\t\tif (L < R) {\n\t\t\tT += (R - L) / v;\n\t\t}\n\n\t\tout.format(Locale.US, \"%.12f%n\", T);\n\t\tout.close();\n\t}\n}\n", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class CFC {\n\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    final long MOD = 1000L * 1000L * 1000L + 7;\n    int[] dx = {0, -1, 0, 1};\n    int[] dy = {1, 0, -1, 0};\n\n    void solve() throws IOException {\n        int n = nextInt();\n        long[] dp0 = new long[10 + n];\n        long[] dp1 = new long[10 + n];\n        long[] pre = new long[10 + n];\n        dp0[0] = 1;\n        String[] arr = new String[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = nextString();\n        }\n        String s = \"s\";\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp1, 0);\n\n            if (i == 0) {\n                dp0[0] = 1;\n                dp1[0] = 1;\n            }\n            else {\n                if (arr[i - 1].equals(s)) {\n                    for (int j = 0; j <= n + 5; j++) {\n                        dp1[j] = pre[j];\n                    }\n                }\n                else {\n                    for (int j = 1; j <= n + 5; j++) {\n                        dp1[j] = dp0[j - 1];\n                    }\n                }\n            }\n\n            Arrays.fill(pre, 0);\n            pre[n + 5] = dp1[n + 5];\n            for (int j = n + 4; j >= 0; j--) {\n                pre[j] = pre[j + 1] + dp1[j];\n                pre[j] %= MOD;\n            }\n\n            for (int j = 0; j <= n + 5; j++) {\n                dp0[j] = dp1[j];\n            }\n        }\n\n        long res = 0;\n        for (int j = 0; j <= n + 5; j++) {\n            res += dp0[j];\n            res %= MOD;\n        }\n\n        out(res);\n    }\n\n    void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n    int gcd(int a, int b) {\n        while(a != 0 && b != 0) {\n            int c = b;\n            b = a % b;\n            a = c;\n        }\n        return a + b;\n    }\n    private void outln(Object o) {\n        out.println(o);\n    }\n    private void out(Object o) {\n        out.print(o);\n    }\n    public CFC() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFC();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class C908 {\n\t\n\tpublic static class mPoint implements Comparable<mPoint> {\n\t\tpublic double a, b;\n\t\tpublic mPoint(int a, double b) {\n\t\t\tthis.a = a; this.b = b;\n\t\t}\n\t\tpublic int compareTo(mPoint p) {\n\t\t\treturn b < p.b ? 1 : (b > p.b) ? -1 : 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt(), r = in.nextInt();\n\t\tint[] ar = new int[n];\n\t\tArrayList<mPoint> disks = new ArrayList<>();\n\t\tdouble[] ans = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tar[i] = in.nextInt();\n\t\t\tdouble max = -1;\n\t\t\tfor (int j = 0; j < disks.size(); j++) {\n\t\t\t\tif (inRange(ar[i], disks.get(j).a, r)) {\n\t\t\t\t\tdouble h = 4*r*r - (ar[i]-disks.get(j).a) * (ar[i]-disks.get(j).a);\n\t\t\t\t\tmax = Math.max(max, Math.sqrt(h) + disks.get(j).b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmPoint p = null;\n\t\t\tif (max == -1) {\n\t\t\t\tp = new mPoint(ar[i], r);\n\t\t\t} else {\n\t\t\t\tp = new mPoint(ar[i], max);\n\t\t\t}\n\t\t\tdisks.add(p);\n\t\t\tans[i] = p.b;\n\t\t}\n\t\tfor (int i = 0; i < ans.length - 1; i++) {\n\t\t\tSystem.out.print(ans[i] + \" \");\n\t\t}\n\t\tSystem.out.println(ans[ans.length - 1]);\n\t}\n\t\n\tpublic static boolean inRange(int a, double b, int r) {\n\t\tif (Math.abs(b - a) <= 2*r) return true; return false;\n\t}\n\t\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "/*\n * Author Ayub Subhaniya\n * Institute DA-IICT\n */\n\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class A\n{\n\t\n\tInputStream in;\n\tPrintWriter out;\n\n\tvoid solve() \n\t{\n\t\tint n=ni();\n\t\tint a[]=na(n);\n\t\tint INV=0;\n\t\tfor (int i=0;i<n;i++)\n\t\t\tfor (int j=i+1;j<n;j++)\n\t\t\t\tif (a[i]>a[j])\n\t\t\t\t\tINV++;\n\t\tboolean even=INV%2==0;\n\t\tint q=ni();\n\t\twhile (q-->0)\n\t\t{\n\t\t\tint l=ni();\n\t\t\tint r=ni();\n\t\t\tint len=r-l+1;\n\t\t\tlen=(len-1)*(len)/2;\n\t\t\tif (len%2==1)\n\t\t\t\teven=!even;\n\t\t\tif (even)\n\t\t\t\tout.println(\"even\");\n\t\t\telse\n\t\t\t\tout.println(\"odd\");\n\t\t}\n\t}\n\t\n\tint MAX = (int)1e5;\n\tlong factorial[];\n\tvoid findfactorial() \n\t{\n\t\tfactorial = new long[MAX + 1];\n\t\tfactorial[0] = 1;\n\t\tfor (int i = 1; i < MAX + 1; i++) \n\t\t{\n\t\t\tfactorial[i] = mul(i,factorial[i - 1]);\n\t\t}\n\t}\n\t\n\tlong mod=(long)1e9+7;\n\tlong add(long a,long b)\n\t{\n\t\tlong x=(a+b);\n\t\twhile(x>=mod) x-=mod;\n\t\treturn x;\n\t\t\n\t}\n\t\n\t\n\tlong sub(long a,long b)\n\t{\n\t\tlong x=(a-b);\n\t\twhile(x<0) x+=mod;\n\t\treturn x;\n\t\t\n\t}\n\t\n\t\n\tlong mul(long a,long b)\n\t{\n\t\ta%=mod;\n\t\tb%=mod;\n\t\tlong x=(a*b);\n\t\treturn x%mod;\n\t\t\n\t}\n\t\n\tint max(int a,int b)\n\t{\n\t\tif(a>b)\n\t\t\treturn a;\n\t\telse\n\t\t\treturn b;\n\t}\n\t\n\tint min(int a,int b)\n\t{\n\t\tif(a>b)\n\t\t\treturn b;\n\t\telse \n\t\t\treturn a;\n\t}\n\t\n\tlong max(long a,long b)\n\t{\n\t\tif(a>b)\n\t\t\treturn a;\n\t\telse\n\t\t\treturn b;\n\t\t\n\t}\n\t\n\t\n\tlong min(long a,long b)\n\t{\n\t\tif(a>b)\n\t\t\treturn b;\n\t\telse \n\t\t\treturn a;\n\t\t\n\t}\n\t\t\n\tvoid run() throws Exception \n\t{\n\t\tString INPUT = \"C:/Users/ayubs/Desktop/input.txt\";\n\t\tin = oj ? System.in : new FileInputStream(INPUT);\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t\t\n\t}\n\tpublic static void main(String[] args) throws Exception \n\t{\n\t\tnew A().run();\n\t}\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte() \n\t{\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) \n\t\t{\n\t\t\tptrbuf = 0;\n\t\t\ttry \n\t\t\t{\n\t\t\t\tlenbuf = in.read(inbuf);\n\t\t\t}\n\t\t\tcatch (IOException e) \n\t\t\t{\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean inSpaceChar(int c) \n\t{\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\t\n\tprivate int skip() \n\t{\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && inSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\t\n\tprivate double nd() \n\t{\n\t\treturn Double.parseDouble(ns());\n\t}\n\t\n\tprivate char nc() \n\t{\n\t\treturn (char) skip();\n\t}\n\t\n\tprivate String ns() \n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(inSpaceChar(b))) \n\t\t{ // when nextLine, (inSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n) \n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(inSpaceChar(b))) \n\t\t{\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m) \n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n) \n\t{\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni() \n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') \n\t\t{\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile (true) \n\t\t{\n\t\t\tif (b >= '0' && b <= '9') \n\t\t\t{\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl() \n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') \n\t\t{\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile (true) \n\t\t{\n\t\t\tif (b >= '0' && b <= '9') \n\t\t\t{\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tprivate void tr(Object... o) \n\t{\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\npublic class GeorgeAndInterestingGraph {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        \n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        \n        int[] edgeFrom = new int[M];\n        int[] edgeTo = new int[M];\n        for (int i = 0; i < M; i++) {\n        \tedgeFrom[i] = sc.nextInt();\n        \tedgeTo[i] = sc.nextInt();\n        }\n        \n        int best = Integer.MAX_VALUE;\n    \tboolean[][] adjMat = makeAdjMat(N, edgeFrom, edgeTo);\n        for (int i = 0; i < N; i++) {\n        \tboolean[][] mat = copyOfArray2d(adjMat);\n        \tbest = Math.min(best, count(mat, M, i));\n        }\n        \n        System.out.println(best);\n    }\n    \n    public static boolean[][] copyOfArray2d(boolean[][] arr) {\n    \tint N = arr.length;\n    \tint M = arr[0].length;\n    \tboolean[][] copy = new boolean[N][M];\n    \tfor (int i = 0; i < N; i++) {\n    \t\tSystem.arraycopy(arr[i], 0, copy[i], 0, M);\n    \t}\n    \treturn copy;\n    }\n    \n    public static int count(boolean[][] mat, int M, int center) {\n    \tint N = mat.length;\n    \t\n    \tint centerCount = (mat[center][center]) ? 1 : 0;\n    \tfor (int i = 0; i < N; i++) {\n    \t\tif (i != center) {\n    \t\t\tif (mat[i][center]) {\n    \t\t\t\tcenterCount++;\n    \t\t\t}\n    \t\t\tif (mat[center][i]) {\n    \t\t\t\tcenterCount++;\n    \t\t\t}\n    \t\t}\n        \tmat[i][center] = false;\n        \tmat[center][i] = false;\n    \t}\n    \tint other = M - centerCount;\n    \t\n    \tint matches = bipartiteMatching(mat);\n    \t\n    \treturn (2 * N - 1 - centerCount + other - matches + N - 1 - matches);\n    }\n    \n    public static boolean[][] makeAdjMat(int N, int[] edgeFrom, int[] edgeTo) {\n    \tboolean[][] mat = new boolean[N][N];\n    \tfor (int i = 0; i < edgeFrom.length; i++) {\n    \t\tint from = edgeFrom[i] - 1;\n    \t\tint to = edgeTo[i] - 1;\n    \t\tmat[from][to] = true;\n    \t}\n    \treturn mat;\n    }\n    \n    /**\n     * Returns true if a matching for vertex 'u' is possible.\n     * See here for more info:  http://www.geeksforgeeks.org/maximum-bipartite-matching/\n     */\n    public static boolean bipartiteMatchingHelper(boolean[][] bpGraph, int u, boolean[] seen, int[] matchR) {\n    \tint N = bpGraph[0].length;\n    \tfor (int v = 0; v < N; v++) {\n    \t\tif (bpGraph[u][v] && !seen[v]) {\n    \t\t\tseen[v] = true;\n    \t\t\tif (matchR[v] < 0 || bipartiteMatchingHelper(bpGraph, matchR[v], seen, matchR)) {\n    \t\t\t\tmatchR[v] = u;\n    \t\t\t\treturn true;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn false;\n    }\n    \n    /**\n     * Returns the maximum bipartite matching from an an adjacency matrix.\n     * Note:  bpGraph[i][j] = true if there is an edge from i to j.\n     * Note:  matchIJ (array of length M) is an output variable containing the matchings, such that matchIJ[i] = j means that there is a match from i to j.\n     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.\n     * See here for more info:  http://www.geeksforgeeks.org/maximum-bipartite-matching/\n     */\n    public static int bipartiteMatching(boolean[][] bpGraph, int[] matchIJ, int[] matchJI) {\n    \tint ans = bipartiteMatching(bpGraph, matchJI);\n    \t\n    \tfor (int i = 0; i < matchJI.length; i++) {\n    \t\tmatchIJ[i] = -1;\n    \t}\n    \t\n    \tfor (int j = 0; j < matchJI.length; j++) {\n    \t\tint i = matchJI[j];\n    \t\tif (i >= 0) {\n    \t\t\tmatchIJ[i] = j;\n    \t\t}\n    \t}\n    \t\n    \treturn ans;\n    }\n    \n    /**\n     * Returns the maximum bipartite matching from an an adjacency matrix.\n     * Note:  bpGraph[i][j] = true if there is an edge from i to j.\n     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.\n     * See here for more info:  http://www.geeksforgeeks.org/maximum-bipartite-matching/\n     */\n    public static int bipartiteMatching(boolean[][] bpGraph, int[] matchJI) {\n    \tint M = bpGraph.length;\n    \tint N = bpGraph[0].length;\n    \t\n    \tfor (int i = 0; i < N; i++) {\n    \t\tmatchJI[i] = -1;\n    \t}\n    \t\n    \tint ans = 0;\n    \tfor (int u = 0; u < M; u++) {\n    \t\tboolean[] seen = new boolean[N];\n    \t\tif (bipartiteMatchingHelper(bpGraph, u, seen, matchJI)) {\n    \t\t\tans++;\n    \t\t}\n    \t}\n    \t\n    \treturn ans;\n    }\n    \n    /**\n     * Returns the maximum bipartite matching from an an adjacency matrix.\n     * Overload of the bipartiteMatching function without output parameters.\n     * See here for more info:  http://www.geeksforgeeks.org/maximum-bipartite-matching/\n     */\n    public static int bipartiteMatching(boolean[][] bpGraph) {\n    \tint N = bpGraph[0].length;\n    \tint[] matchJI = new int[N];\n    \treturn bipartiteMatching(bpGraph, matchJI);\n    }\n    \n    /**\n     * Overload of the bipartiteMatching function taking an adjacency matrix of int[][] instead of boolean[][].\n     */\n    public static int bipartiteMatching(int[][] intGraph) {\n    \tboolean[][] bpGraph = intToBooleanAdjMat(intGraph);\n    \treturn bipartiteMatching(bpGraph);\n    }\n\n    /**\n     * Overload of the bipartiteMatching function taking an adjacency matrix of int[][] instead of boolean[][].\n     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.\n     */\n    public static int bipartiteMatching(int[][] intGraph, int[] matchJI) {\n    \tboolean[][] bpGraph = intToBooleanAdjMat(intGraph);\n    \treturn bipartiteMatching(bpGraph, matchJI);\n    }\n\n    /**\n     * Overload of the bipartiteMatching function taking an adjacency matrix of int[][] instead of boolean[][].\n     * Note:  matchIJ (array of length M) is an output variable containing the matchings, such that matchIJ[i] = j means that there is a match from i to j.\n     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.\n     */\n    public static int bipartiteMatching(int[][] intGraph, int[] matchIJ, int[] matchJI) {\n    \tboolean[][] bpGraph = intToBooleanAdjMat(intGraph);\n    \treturn bipartiteMatching(bpGraph, matchIJ, matchJI);\n    }\n    \n    /**\n     * Converts an integer adjacency matrix of 1's and 0's to a boolean adjacency matrix.\n     * Useful with bipartiteMatching, which takes adjancency matrix of boolean[][] as input (instead of int[][]).\n     */\n    public static boolean[][] intToBooleanAdjMat(int[][] mat) {\n    \tint M = mat.length;\n    \tint N = mat[0].length;\n    \tboolean[][] bMat = new boolean[M][N];\n    \tfor (int i = 0; i < M; i++) {\n    \t\tfor (int j = 0; j < N; j++) {\n    \t\t\tbMat[i][j] = (mat[i][j] != 0);\n    \t\t}\n    \t}\n    \treturn bMat;\n    }\n\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try { str = br.readLine(); }\n            catch (IOException e) { e.printStackTrace(); }\n            return str;\n        }\n    }\n}", "complexity": "cubic", "problem": "0387_D", "from": "CODEFORCES", "tags": "graph matchings"}
{"src": "/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\n\nimport java.util.Scanner;\n\n/**\n *\n * @author dilshan\n */\npublic class Test {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        int k = 1;\n        int t = 0;\n        int y = 2;\n        int[] a = new int[100000];\n        if(n==0){\n            System.out.println(0+\" \"+0+\" \"+0);\n        }\n        else \n            if(n==1){\n            System.out.println(0+\" \"+0+\" \"+1);\n            }\n            else \n                if(n==2){\n                System.out.println(0+\" \"+1+\" \"+1);\n                }\n                else{\n                    a[0] = 0;\n                    a[1] = 1;\n                    a[y] = a[y - 2] + a[y - 1];\n                    while (a[y - 1] < n) {\n\n                        a[y] = a[y - 2] + a[y - 1];\n                        ++y;\n\n\n                    }\n                    System.out.println(a[y - 2] + \" \" + a[y - 4] + \" \" + a[y - 5]);\n            }\n        //System.out.println(y);\n        \n\n\n    }\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jaynil\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BSportMafia solver = new BSportMafia();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BSportMafia {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long n = in.nextLong();\n            long k = in.nextLong();\n            long b = 2 * n + 3;\n            long c = n * n - 2 * k + n;\n            long d = b * b - 4 * c;\n            long val = (b - (long) Math.sqrt(d)) / 2;\n\n            out.println(val);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.util.*;\n\nimport java.lang.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.*;\n \npublic class Main {\n        \n    public static void main(String[] args) throws Exception{\n        FastReader sc=new FastReader(); \n        OutputStream outputStream = System.out;\n        PrintWriter out = new PrintWriter(outputStream);\n        int n=sc.nextInt();\n        int[] font=new int[n];\n        int[] cost=new int[n];\n        for(int i=0;i<n;i++) {\n            font[i]=sc.nextInt();\n        \n        }\n        for(int i=0;i<n;i++) {\n            cost[i]=sc.nextInt();\n        }\n        int[] dou= new int[n];\n        for(int i=0;i<n;i++) {\n            int min=Integer.MAX_VALUE;\n            for(int j=0;j<i;j++) {\n                if(font[j]<font[i]) {\n                    if(min>cost[i]+cost[j]) {\n                        min=cost[i]+cost[j];\n                    }\n                }\n            }\n            dou[i]=min;\n        }\n        int ans=Integer.MAX_VALUE;\n        for(int i=0;i<n;i++) {\n            int min=Integer.MAX_VALUE;\n            for(int j=0;j<i;j++) {\n                if(dou[j]!=Integer.MAX_VALUE && font[j]<font[i]) {\n                    if(min>dou[j]+cost[i]) {\n                        min=dou[j]+cost[i];\n                    }\n                }\n            }\n            if(min<ans) {\n                ans=min;\n            }\n        }\n        if(ans==Integer.MAX_VALUE) {\n            System.out.println(-1);\n        }\n        else {\n            System.out.println(ans);\n        }\n    }\n}\n\nclass FastReader \n{ \n    BufferedReader br; \n    StringTokenizer st; \n \n    public FastReader() \n    { \n        br = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    } \n \n    String next() \n    { \n        while (st == null || !st.hasMoreElements()) \n        { \n            try\n            { \n                st = new StringTokenizer(br.readLine()); \n            } \n            catch (IOException  e) \n            { \n                e.printStackTrace(); \n            } \n        } \n        return st.nextToken(); \n    } \n \n    int nextInt() \n    { \n        return Integer.parseInt(next()); \n    } \n \n    long nextLong() \n    { \n        return Long.parseLong(next()); \n    } \n \n    double nextDouble() \n    { \n        return Double.parseDouble(next()); \n    } \n \n    String nextLine() \n    { \n        String str = \"\"; \n        try\n        { \n            str = br.readLine(); \n        } \n        catch (IOException e) \n        { \n            e.printStackTrace(); \n        } \n        return str; \n    } \n} ", "complexity": "quadratic", "problem": "0987_C", "from": "CODEFORCES", "tags": "brute force,dp,implementation"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n\tpublic static void main(String[] args) {\n        FastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int a[] = in.readArray(8);\n        int b[] = in.readArray(8);\n        for(int i=0;i<8;i++){\n        \ta[i] += 100;\n        \tb[i] += 100;\n        }\n        int graph[][] = new int[210][210];\n        int sx = a[0], sy = a[1], ex = a[2], ey = a[3];\n        int l = Math.abs(sx-a[4]);\n        //out.println(l);\n        for(int i=0;i<=l;i++){\n        \tint x = sx, y = sy;\n        \twhile(x!=ex||y!=ey){\n        \t\tgraph[x][y]++;       \n        \t\tif(x<ex)x++;\n        \t\telse if(x>ex) x--;\n        \t\tif(y<ey) y++;\n        \t\telse if(y>ey) y--;\n        \t}\n        \tgraph[x][y]++;\n        \tif(sx<a[6]){\n        \t\tsx++; ex++;\n        \t}\t\n        \telse if(sx>a[6]){\n        \t\tsx--; ex--;\n        \t} \n        \tif(sy<a[7]){\n        \t\tsy++; ey++;\n        \t}\t\n        \telse if(sy>a[7]){\n        \t\tsy--; ey--;\n        \t}\t\n        }             \n        int px = b[0], py = b[1], qx = b[4], qy = b[5];\n      \tdouble ca, cb;\n        ca = (px+qx)/2.00; cb = (py+qy)/2.00;\n        double r = Math.sqrt((px-qx)*(px-qx) + (py-qy)*(py-qy)); r/=2;\n        for(int i=0;i<=200;i++){\n        \tfor(int j=0;j<=200;j++){\n        \t\tif(Math.abs(i-ca)+Math.abs(j-cb)<=r) graph[i][j]++;\n        \t}\n        }/*\n        for(int i=98;i<=115;i++){\n        \tfor(int j=98;j<=115;j++) out.print(graph[i][j]+\" \");\n        \tout.println();\n        }\n        out.println(ca+\" \"+cb+\" \"+r);*/\n       \tboolean yes = false;\n       \tint cnt = 0;\n       \tfor(int i=0;i<=200;i++){\n       \t\tfor(int j=0;j<=200;j++) if(graph[i][j]==2){ yes = true; cnt++; }\n       \t}\n       \tout.println((yes)?\"YES\":\"NO\");\n       \t//out.println(cnt);\n        out.flush();\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t\ttry { st = new StringTokenizer(br.readLine()); }\n\t\t\t\tcatch(IOException e) {}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString nextLine(){\n\t\t\ttry{ return br.readLine(); } \n\t\t\tcatch(IOException e) { } return \"\";\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n\n\tstatic final Random random = new Random();\n\n\tstatic void ruffleSort(int[] a){\n\t\tint n = a.length;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint j = random.nextInt(n), temp = a[j];\n\t\t\ta[j] = a[i]; a[i] = temp;\n\t\t}\n\t\tArrays.sort(a); \t\n\t}\n}\n", "complexity": "constant", "problem": "0994_C", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.BufferedWriter;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.io.OutputStreamWriter;\n\nimport java.io.PrintWriter;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class B {\n\n\t\n\n\tprivate static StringTokenizer tokenizer;\n\n    private static BufferedReader bf;\n\n    private static PrintWriter out;\n\n    \n\n\tprivate static int nextInt() throws IOException {\n\n    \treturn Integer.parseInt(nextToken());\n\n    }\n\n    \n\n    @SuppressWarnings(\"unused\")\n\n\tprivate static long nextLong() throws IOException {\n\n    \treturn Long.parseLong(nextToken());\n\n    }\n\n    \n\n    private static String nextToken() throws IOException {\n\n    \twhile(tokenizer == null || !tokenizer.hasMoreTokens()) {\n\n    \t\ttokenizer = new StringTokenizer(bf.readLine());\n\n    \t}\n\n    \treturn tokenizer.nextToken();\n\n    }\n\n    \n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tbf = new BufferedReader(new InputStreamReader(System.in));\n\n    \ttokenizer = null;\n\n    \tout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n    \tlong n = nextLong(); long k = nextLong();\n\n    \tif(n > k*(k-1)/2 + 1) out.println(-1);\n\n    \telse if(n == k*(k-1)/2 + 1) out.println(k-1);\n\n    \telse if(n == 1) out.println(0);\n\n    \telse if(n <= k) out.println(1);\n\n    \telse {\n\n    \t\tlong rest = k*(k-1)/2 - n;\n\n    \t\tlong m = (long) Math.sqrt(2*rest) + 3;\n\n    \t\tlong t;\n\n    \t\tfor(t = m; t >= 1; t--) {\n\n    \t\t\tif(t*(t-3) <= 2*rest)\n\n    \t\t\t\tbreak;\n\n    \t\t}\n\n    \t\tout.println(k-t+1);\n\n    \t}\n\n    \tout.close();\n\n\t}\n\n\n\n}\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.util.Scanner;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner r = new Scanner(System.in);\n        \n        String a = r.next();\n        char[] c = a.toCharArray();\n        \n        for(int l = a.length()-1; l >= 1; l--){\n            for(int i = 0; i <= a.length()-l; i++){\n                int j = i+l-1;\n                \n                for(int s = 0; s <= a.length()-l; s++){\n                    if(i == s)continue;\n                    if(a.substring(i, i+l).equals(a.subSequence(s, s+l))){\n                        System.out.println(l);\n                        System.exit(0);\n                    }\n                        \n                }\n            }\n        }\n        \n        System.out.println(0);\n        \n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.Scanner;\n\n\npublic class Main{\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        int T = in.nextInt();\n        while(T!=0){\n            T--;\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int ans=0;\n            while(a>0&&b>0){\n                if(a>b){\n                    int c = a;\n                    a = b;\n                    b = c;\n                }\n                ans += (b-(b%a))/a;\n                b = b%a;\n            }\n            System.out.println(ans);\n        }\n    }\n    \n}\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "//package codeforces;\n\nimport java.util.*;\n\npublic class Main {\n    class team implements Comparable<team>{\n        int pro,time;\n\n        public int compareTo(team oth) {\n            if(pro>oth.pro)\n                return -1;\n            if(pro==oth.pro&&time<oth.time)\n                return -1;\n            // TODO Auto-generated method stub\n            return 1;\n        }\n        \n    }\n    Scanner scan=new Scanner(System.in);\n    void run(){\n        int n=scan.nextInt();\n        int k=scan.nextInt()-1;\n        team tm[]=new team[n];\n        for(int i=0;i<n;i++){\n            tm[i]=new team();\n            tm[i].pro=scan.nextInt();\n            tm[i].time=scan.nextInt();\n        }\n        Arrays.sort(tm);\n        int sum=0;\n        \n        for(int i=k;i>=0;i--)\n            if(tm[i].pro==tm[k].pro&&tm[i].time==tm[k].time)\n                sum++;\n        for(int i=k;i<n;i++)\n            if(tm[i].pro==tm[k].pro&&tm[i].time==tm[k].time)\n                sum++;\n        System.out.println(sum-1);\n    }\n    public static void main(String args[]) {\n         \n        new Main().run();\n    }\n\n}", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "//Author: Patel Rag\n//Java version \"1.8.0_211\"\nimport java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n      while (st == null || !st.hasMoreElements())\n      {\n        try\n        {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n      String str = \"\";\n      try\n      {\n        str = br.readLine();\n      }\n      catch (IOException e)\n      {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    //binary Modular exponentiation\n  {\n    long result = 1;\n    while(n > 0)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    if(a==0) return b;\n    return gcd(b%a,a);\n  }\n  public static void main(String[] args)\n  throws IOException\n  {\n    FastReader fr = new FastReader();\n    long n = fr.nextLong();\n    long x = fr.nextLong();\n    long y = fr.nextLong();\n    long w = Long.min(x,y) - 1 + (x - Long.min(x,y)) + (y - Long.min(x,y));\n    long b = n - Long.max(x,y) + (Long.max(x,y) - x) + (Long.max(x,y) - y);\n    if(w <= b) System.out.println(\"White\");\n    else System.out.println(\"Black\");\n\n  }\n}\nclass Pair<U, V>  // Pair class\n{\n    public final U first;       // first field of a Pair\n    public final V second;      // second field of a Pair\n\n    private Pair(U first, V second)\n    {\n      this.first = first;\n      this.second = second;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n      if (this == o) return true;\n\n      if (o == null || getClass() != o.getClass()) return false;\n\n      Pair<?, ?> pair = (Pair<?, ?>) o;\n\n      if (!first.equals(pair.first)) return false;\n      return second.equals(pair.second);\n    }\n\n    @Override\n    public int hashCode()\n    {\n      return 31 * first.hashCode() + second.hashCode();\n    }\n\n    public static <U, V> Pair <U, V> of(U a, V b)\n    {\n      return new Pair<>(a, b);\n    }\n}\nclass myComp implements Comparator<Pair>\n{\n  public int compare(Pair a,Pair b)\n  {\n    if(a.first != b.first) return ((int)a.first - (int)b.first);\n    if(a.second != b.second) return ((int)a.second - (int)b.second);\n    return 0;\n  }\n}\nclass BIT       //Binary Indexed Tree aka Fenwick Tree\n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    for(int i = 0; i < dat.length; i++)\n    {\n      m_array[i + 1] = dat[i];\n    }\n    for(int i = 1; i < m_array.length; i++)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(++i; i > 0; i = i - (i & -i))\n    {\n      result = result + m_array[i];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length; i = i + (i & -i))\n    {\n      m_array[i] = m_array[i] + add;\n    }\n  }\n}\n", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Sol{\n\nstatic class Pair implements Comparable<Pair>{\n        int x;int y;int value;\n        public Pair(int x,int y,int value) {\n         \n          this.x=x;\n          this.y=y;\n          this.value=value;\n        }\n        @Override\n        public int compareTo(Pair p){return Long.compare(y,p.y); }\n       \n   }\n\npublic static void main(String []args){\n\nint t=1;\n\nwhile(t-->0){\nint n=ni();mod=nl();\nprecomp();\nlong dp[][]=new long[405][405];dp[0][0]=1l;\nfor(int i=0;i<n;i++){\n    for(int j=0;j<=i;j++){\n       for(int k=1;k+i<=n;k++){ \n          \n          dp[i+k+1][j+k]+=((dp[i][j]*p2[k-1])%mod)*Comb[k+j][k];\n          dp[i+k+1][j+k]%=mod;\n      }\n   }\n }\n\nlong sum=0l;\nfor(int i=0;i<=n;i++)sum=(sum+dp[n+1][i])%mod;\nout.println(sum);\n\n}out.close();}\n\n//-----------------Utility--------------------------------------------\n\nstatic long Comb[][]=new long[405][405];\nstatic long p2[]=new long[405];\nstatic long inv[]=new long[405];\nstatic long factorial[]=new long[405];\nstatic void precomp(){\n\ninv[0]=1;factorial[0]=1l;\n\nfor(long i=1;i<405;i++){factorial[(int)i]=i*factorial[(int)i-1];factorial[(int)i]%=mod;}\n\nfor(int i=1;i<405;i++){ inv[i]=power(factorial[i],mod-2);}\n\nfor(int i=0;i<405;i++){\n \n   for(int j=0;j<=i;j++){\n     Comb[i][j]=(((factorial[i]*inv[j])%mod)*inv[i-j])%mod;\n   }\n }\n\nfor(int i=0;i<405;i++)p2[i]=power(2,i);\n\n}\n\nstatic int Max=Integer.MAX_VALUE; static long mod=1000000007;\nstatic int v(char c){return (int)(c-'a')+1;}\npublic static long power(long x, long y )\n    {\n        //0^0 = 1\n        long res = 1L;\n        x = x%mod;\n        while(y > 0)\n        {\n            if((y&1)==1)\n                res = (res*x)%mod;\n            y >>= 1;\n            x = (x*x)%mod;\n        }\n        return res;\n    }\n//--------------------------------------------------------------------\n\nstatic InputStream inputStream = System.in;\nstatic OutputStream outputStream = System.out;\nstatic FastReader in=new FastReader(inputStream);\nstatic PrintWriter out=new PrintWriter(outputStream);\n\nstatic class FastReader \n{ \n  BufferedReader br; \n  StringTokenizer st; \n \n        FastReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n \n  public String next() \n  { \n      while (st == null || !st.hasMoreElements()) \n      { \n          try\n          { \n              st = new StringTokenizer(br.readLine()); \n          } \n          catch (IOException  e) \n          { \n              e.printStackTrace(); \n          } \n      } \n      return st.nextToken(); \n  } \n \n  public int nextInt() \n  { \n      return Integer.parseInt(next()); \n  } \n \n  public long nextLong() \n  { \n      return Long.parseLong(next()); \n  } \n \n public  double nextDouble() \n  { \n      return Double.parseDouble(next()); \n  } \n \n \n  String nextLine() \n  { \n      String str = \"\"; \n      try\n      { \n          str = br.readLine(); \n      } \n      catch (IOException e) \n      { \n          e.printStackTrace(); \n      } \n      return str; \n  } \n}\nstatic int ni(){return in.nextInt();}\nstatic long nl(){return in.nextLong();}\nstatic String ns(){return in.nextLine();}\nstatic int[] na(int n){int a[]=new int[n];for(int i=0;i<n;i++){a[i]=ni();} return a;}\n\n}", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.util.*;\npublic class A23 {\n\tpublic static void main(String[]args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString W = sc.next();\n\t\tArrayList<String>Q = new ArrayList<String>();\n\t\tfor (int i = 0; i < W.length(); i++){\t\t\t\n\t\t\tString O = \"\";\n\t\t\tfor (int k = i; k < W.length(); k++){\n\t\t\t\tO = O + W.charAt(k);\n\t\t\t\tQ.add(O);\n\t\t\t}\t\t\t\n\t\t}\n\t\tCollections.sort(Q);\n\t\tString tmp = Q.get(0);\n\t\tint y = 0;\n\t\tfor (int i = 1; i < Q.size(); i++){\n\t\t\tif (Q.get(i).equals(tmp)){\n\t\t\t\tif (Q.get(i).length() > y){\n\t\t\t\t\ty = Q.get(i).length();\n\t\t\t\t}\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmp = Q.get(i);\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(y);\n\t}\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.stream.Collectors;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int t = sc.nextInt();\n    for (int tc = 0; tc < t; ++tc) {\n      int n = sc.nextInt();\n      int[] a = new int[n];\n      for (int i = 0; i < a.length; ++i) {\n        a[i] = sc.nextInt();\n      }\n\n      System.out.println(solve(a));\n    }\n\n    sc.close();\n  }\n\n  static String solve(int[] a) {\n    List<String> result = new ArrayList<>();\n    Stack<Integer> stack = new Stack<>();\n    for (int ai : a) {\n      if (ai != 1) {\n        while (stack.peek() + 1 != ai) {\n          stack.pop();\n        }\n\n        stack.pop();\n      }\n      stack.push(ai);\n\n      result.add(stack.stream().map(String::valueOf).collect(Collectors.joining(\".\")));\n    }\n\n    return String.join(\"\\n\", result);\n  }\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n//package CodeForces3;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n/**\n *\n * @author DELL\n */\npublic class HexadecimalsTheorem {\n\n    public void solve() {\n        Scanner sc = new Scanner(System.in);\n        long n = sc.nextLong();\n\n        ArrayList<Long> a = new ArrayList<Long>();\n\n        a.add(0l);\n        a.add(1L);\n        a.add(1L);\n\n        int i = 1, j = 2;\n\n        while ((a.get(i) + a.get(j)) <= n) {\n            a.add((a.get(i) + a.get(j)));\n            i++;\n            j++;\n        }\n\n        if (a.contains(n)) {\n            if (n == 0) {\n                System.out.println(\"0 0 0\");\n            } else if (n == 1) {\n                System.out.println(\"0 0 1\");\n            } else if (n == 2) {\n                System.out.println(\"0 1 1\");\n            } else {\n                System.out.println(a.get(j - 4) + \" \" + a.get(j - 3) + \" \" + a.get(j - 1));\n\n            }\n\n        } else {\n            System.out.println(\"I'm too stupid to solve this problem\");\n        }\n\n\n    }\n\n    public static void main(String[] args) {\n        new HexadecimalsTheorem().solve();\n    }\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.util.Scanner;\n\n/**\n * Created by mmaikovych on 18.02.16.\n */\npublic class EER_A {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        scanner.nextLine();\n        System.out.println(25);\n    }\n}\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ankur\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        long mod = (long) 1e9 + 7;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long x = in.nextLong();\n            long k = in.nextLong();\n            if (x == 0) {\n                out.print(0);\n                return;\n            }\n            long n = pow(2, k);\n            long l = (n * ((x % mod)) % mod);\n            l = l % mod;\n            long ans = 2 * l - n + 1;\n            ans = ans % mod;\n            if (ans < 0)\n                ans += mod;\n            out.print(ans);\n        }\n\n        long pow(long a, long val) {\n            if (val == 0) {\n                return 1;\n            }\n            if (val % 2 == 0) {\n                long ans = pow(a, val / 2);\n                return (ans * ans) % mod;\n            }\n            return ((a % mod) * (pow(a, val - 1))) % mod;\n        }\n\n    }\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar;\n        private int snumChars;\n\n        public InputReader(InputStream st) {\n            this.stream = st;\n        }\n\n        public int read() {\n            //*-*------clare------\n//remeber while comparing 2 non primitive data type not to use ==\n//remember Arrays.sort for primitive data has worst time case complexity of 0(n^2) bcoz it uses quick sort\n//again silly mistakes ,yr kb tk krta rhega ye mistakes\n//try to write simple codes ,break it into simple things\n//knowledge>rating\n        /*\n        public class Main\n        implements Runnable{\n    public static void main(String[] args) {\n        new Thread(null,new Main(),\"Main\",1<<26).start();\n\n    }\n    public void run() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();//chenge the name of task\n        solver.solve(1, in, out);\n        out.close();\n    }\n         */\n\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.util.Arrays.copyOf;\nimport static java.util.Arrays.deepToString;\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class C {\n\tstatic int[] dx = new int[] { 0, 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 0, -1, 0, 1 };\n\tstatic int[][] g;\n\tstatic int ans;\n\n\tstatic void fill() {\n\t\tcache[1][1] = 0;\n\t\tcache[1][1] = 0;\n\t\tcache[2][1] = 1;\n\t\tcache[1][2] = 1;\n\t\tcache[2][2] = 2;\n\t\tcache[2][2] = 2;\n\t\tcache[3][1] = 2;\n\t\tcache[1][3] = 2;\n\t\tcache[3][2] = 4;\n\t\tcache[2][3] = 4;\n\t\tcache[3][3] = 6;\n\t\tcache[3][3] = 6;\n\t\tcache[4][1] = 2;\n\t\tcache[1][4] = 2;\n\t\tcache[4][2] = 5;\n\t\tcache[2][4] = 5;\n\t\tcache[4][3] = 8;\n\t\tcache[3][4] = 8;\n\t\tcache[4][4] = 12;\n\t\tcache[4][4] = 12;\n\t\tcache[5][1] = 3;\n\t\tcache[1][5] = 3;\n\t\tcache[5][2] = 7;\n\t\tcache[2][5] = 7;\n\t\tcache[5][3] = 11;\n\t\tcache[3][5] = 11;\n\t\tcache[5][4] = 14;\n\t\tcache[4][5] = 14;\n\t\tcache[5][5] = 18;\n\t\tcache[5][5] = 18;\n\t\tcache[6][1] = 4;\n\t\tcache[1][6] = 4;\n\t\tcache[6][2] = 8;\n\t\tcache[2][6] = 8;\n\t\tcache[6][3] = 13;\n\t\tcache[3][6] = 13;\n\t\tcache[6][4] = 17;\n\t\tcache[4][6] = 17;\n\t\tcache[6][5] = 22;\n\t\tcache[5][6] = 22;\n\t\tcache[6][6] = 26;\n\t\tcache[6][6] = 26;\n\t\tcache[7][1] = 4;\n\t\tcache[1][7] = 4;\n\t\tcache[7][2] = 10;\n\t\tcache[2][7] = 10;\n\t\tcache[7][3] = 15;\n\t\tcache[3][7] = 15;\n\t\tcache[7][4] = 21;\n\t\tcache[4][7] = 21;\n\t\tcache[7][5] = 26;\n\t\tcache[5][7] = 26;\n\t\tcache[8][1] = 5;\n\t\tcache[1][8] = 5;\n\t\tcache[8][2] = 11;\n\t\tcache[2][8] = 11;\n\t\tcache[8][3] = 17;\n\t\tcache[3][8] = 17;\n\t\tcache[8][4] = 24;\n\t\tcache[4][8] = 24;\n\t\tcache[8][5] = 29;\n\t\tcache[5][8] = 29;\n\t\tcache[9][1] = 6;\n\t\tcache[1][9] = 6;\n\t\tcache[9][2] = 13;\n\t\tcache[2][9] = 13;\n\t\tcache[9][3] = 20;\n\t\tcache[3][9] = 20;\n\t\tcache[9][4] = 26;\n\t\tcache[4][9] = 26;\n\t\tcache[10][1] = 6;\n\t\tcache[1][10] = 6;\n\t\tcache[10][2] = 14;\n\t\tcache[2][10] = 14;\n\t\tcache[10][3] = 22;\n\t\tcache[3][10] = 22;\n\t\tcache[10][4] = 30;\n\t\tcache[4][10] = 30;\n\t\tcache[11][1] = 7;\n\t\tcache[1][11] = 7;\n\t\tcache[11][2] = 16;\n\t\tcache[2][11] = 16;\n\t\tcache[11][3] = 24;\n\t\tcache[3][11] = 24;\n\t\tcache[12][1] = 8;\n\t\tcache[1][12] = 8;\n\t\tcache[12][2] = 17;\n\t\tcache[2][12] = 17;\n\t\tcache[12][3] = 26;\n\t\tcache[3][12] = 26;\n\t\tcache[13][1] = 8;\n\t\tcache[1][13] = 8;\n\t\tcache[13][2] = 19;\n\t\tcache[2][13] = 19;\n\t\tcache[13][3] = 29;\n\t\tcache[3][13] = 29;\n\t\tcache[14][1] = 9;\n\t\tcache[1][14] = 9;\n\t\tcache[14][2] = 20;\n\t\tcache[2][14] = 20;\n\t\tcache[15][1] = 10;\n\t\tcache[1][15] = 10;\n\t\tcache[15][2] = 22;\n\t\tcache[2][15] = 22;\n\t\tcache[16][1] = 10;\n\t\tcache[1][16] = 10;\n\t\tcache[16][2] = 23;\n\t\tcache[2][16] = 23;\n\t\tcache[17][1] = 11;\n\t\tcache[1][17] = 11;\n\t\tcache[17][2] = 25;\n\t\tcache[2][17] = 25;\n\t\tcache[18][1] = 12;\n\t\tcache[1][18] = 12;\n\t\tcache[18][2] = 26;\n\t\tcache[2][18] = 26;\n\t\tcache[19][1] = 12;\n\t\tcache[1][19] = 12;\n\t\tcache[19][2] = 28;\n\t\tcache[2][19] = 28;\n\t\tcache[20][1] = 13;\n\t\tcache[1][20] = 13;\n\t\tcache[20][2] = 29;\n\t\tcache[2][20] = 29;\n\t\tcache[21][1] = 14;\n\t\tcache[1][21] = 14;\n\t\tcache[22][1] = 14;\n\t\tcache[1][22] = 14;\n\t\tcache[23][1] = 15;\n\t\tcache[1][23] = 15;\n\t\tcache[24][1] = 16;\n\t\tcache[1][24] = 16;\n\t\tcache[25][1] = 16;\n\t\tcache[1][25] = 16;\n\t\tcache[26][1] = 17;\n\t\tcache[1][26] = 17;\n\t\tcache[27][1] = 18;\n\t\tcache[1][27] = 18;\n\t\tcache[28][1] = 18;\n\t\tcache[1][28] = 18;\n\t\tcache[29][1] = 19;\n\t\tcache[1][29] = 19;\n\t\tcache[30][1] = 20;\n\t\tcache[1][30] = 20;\n\t\tcache[31][1] = 20;\n\t\tcache[1][31] = 20;\n\t\tcache[32][1] = 21;\n\t\tcache[1][32] = 21;\n\t\tcache[33][1] = 22;\n\t\tcache[1][33] = 22;\n\t\tcache[34][1] = 22;\n\t\tcache[1][34] = 22;\n\t\tcache[35][1] = 23;\n\t\tcache[1][35] = 23;\n\t\tcache[36][1] = 24;\n\t\tcache[1][36] = 24;\n\t\tcache[37][1] = 24;\n\t\tcache[1][37] = 24;\n\t\tcache[38][1] = 25;\n\t\tcache[1][38] = 25;\n\t\tcache[39][1] = 26;\n\t\tcache[1][39] = 26;\n\t\tcache[40][1] = 26;\n\t\tcache[1][40] = 26;\n\t}\n\n\tstatic void go(int n, int m, long used, long left) {\n\t\t// debug(Long.toBinaryString(used) + \" \" + Long.toBinaryString(left));\n\t\tif (left == 0) {\n\t\t\tans = max(ans, n * m - Long.bitCount(used));\n\t\t\treturn;\n\t\t}\n\t\tif (n * m - Long.bitCount(used) <= ans)\n\t\t\treturn;\n\t\tint who = Long.numberOfTrailingZeros(left);\n\t\t// debug(who);\n\t\tfor (int w : g[who]) {\n\t\t\tlong nused = used | (1L << w);\n\t\t\tlong nleft = left;\n\t\t\tfor (int v : g[w]) {\n\t\t\t\tnleft &= ~(1L << v);\n\t\t\t}\n\t\t\tgo(n, m, nused, nleft);\n\t\t}\n\t}\n\n\tstatic int solve(int n, int m) throws Exception {\n\t\tans = 0;\n\t\tg = new int[n * m][];\n\t\tfor (int x = 0; x < m; x++) {\n\t\t\tfor (int y = 0; y < n; y++) {\n\t\t\t\tint[] w = new int[5];\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int dir = 0; dir < 5; dir++) {\n\t\t\t\t\tint nx = x + dx[dir];\n\t\t\t\t\tint ny = y + dy[dir];\n\t\t\t\t\tif (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n\t\t\t\t\t\tw[cnt++] = ny * m + nx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg[y * m + x] = copyOf(w, cnt);\n\t\t\t}\n\t\t}\n\t\tgo(n, m, 0, (1L << (n * m)) - 1);\n\t\treturn ans;\n\t}\n\n\tstatic int[][] cache;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\t// debug(solve(1, 4));\n\t\t\t// debug(solve(6, 6));\n\n\t\t\t// debug(solve(7,5) == solve(5,7));\n//\t\t\tPrintWriter out2 = new PrintWriter(\"file.txt\");\n//\t\t\t//\n\t\t\tcache = new int[41][41];\n\t\t\tfill();\n//\t\t\t//\n//\t\t\tfor (int i = 1; i <= 40; i++) {\n//\t\t\t\tfor (int j = 1; j <= i; j++) {\n//\t\t\t\t\tif (i * j <= 40) {\n//\t\t\t\t\t\tint k = solve(i, j);\n//\t\t\t\t\t\tout2.printf(\"cache[%d][%d] = %d;\\n\", i, j, k);\n//\t\t\t\t\t\tout2.printf(\"cache[%d][%d] = %d;\\n\", j, i, k);\n//\n//\t\t\t\t\t\tcache[i][j] = solve(i, j);\n//\t\t\t\t\t\tdebug(i + \" \" + j);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tout2.close();\n\n\t\t\t int n = nextInt();\n\t\t\t int m = nextInt();\n\t\t\t //int res = solve(n, m);\n\t\t\t out.println(cache[n][m]);\n\n\t\t\t// for (int i = 1; i <= 5; i++) {\n\t\t\t// for (int j = 1; j <= 5; j++) {\n\t\t\t// assert(solve(i, j) == cache[i][j]);\n\t\t\t// //debug(i + \" \" + j + \" \" + solve(i, j));\n\t\t\t// }\n\t\t\t// }\n\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\tstatic long launchTimer;\n\n\tstatic void debug(Object... o) {\n\t\tSystem.err.println(deepToString(o));\n\t}\n\n\tstatic void setTime() {\n\t\tlaunchTimer = System.currentTimeMillis();\n\t}\n\n\tstatic void printTime() {\n\t\tSystem.err.println(System.currentTimeMillis() - launchTimer);\n\t}\n\n\tstatic void printMemory() {\n\t\tSystem.err.println((Runtime.getRuntime().totalMemory() - Runtime\n\t\t\t\t.getRuntime().freeMemory()) / 1000 + \"kb\");\n\t}\n\n\tstatic boolean hasMoreTokens() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttok = new StringTokenizer(line);\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic String next() throws IOException {\n\t\treturn hasMoreTokens() ? tok.nextToken() : null;\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic BigInteger nextBig() throws IOException {\n\t\treturn new BigInteger(next());\n\t}\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF287D2B2 {\n\n    static long n;\n    static long k;\n    static ArrayList<Long> myList;\n    static HashMap<Long, Boolean> myListCheck;\n    \n    public static void main(String[] args) throws IOException {\n        \n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer s = new StringTokenizer(bf.readLine());\n        \n        n = Long.parseLong(s.nextToken());\n        k = Integer.parseInt(s.nextToken());\n       \n        if(n == 1){\n            System.out.println(\"0\");\n            return;\n        }\n        \n        long result = minSplitters();\n//        System.out.println(\"--------------------\");\n        if(result >= k){\n            System.out.println(-1);\n        }else{\n            System.out.println(result);\n        }\n    }\n\n    private static long minSplitters() {\n        long result = -1;\n        long start = 1, end = k-1, mid;\n        mid = (start + end)/2;\n        while(start <= end && mid >= start && mid <= end){\n//            System.out.println(\"result: \"+result);\n            myListCheck = new HashMap<>();\n            myList = new ArrayList<>();\n//            System.out.println(\"start: \"+start+\"  , end: \"+end+\"  , mid: \"+mid);\n            \n            long value = (k*(k+1))/2 - ((k-mid)*((k-mid)+1))/2 - (mid-1);\n//            System.out.println(\"value: \"+value);\n            long key;\n            if(value < n){\n                key = 1;\n            }else if(value > n){\n                key = -1;\n            }else{\n                key = 0;\n            }\n            \n//            System.out.println(\"key: \"+key);\n            if(key == 1){\n                start = mid+1;\n                mid = (start + end)/2;\n            }else{\n                if(mid < k && mid >= 1){\n                    result = mid; //i found a result but i figure out if it is the smallest possible result or not;\n                }\n                if(key == -1){\n                    end = mid-1;\n                    mid = (start + end)/2;\n                }else if(key == 0){\n                    mid--;\n                }\n            }\n        }\n        return result;\n    }\n}\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n\npublic class C364C {\n\n\tstatic StringTokenizer st;\n\tstatic BufferedReader br;\n\tstatic PrintWriter pw;\n\n\tstatic int n;\n\tstatic int[] a;\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tn = nextInt();\n\t\tint ans = n, cc, cur = 0;\n\t\ta = new int [52];\n\t\tchar[] c = next().toCharArray();\n\t\tint l = 0, len = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (Character.isUpperCase(c[i])) {\n\t\t\t\tcur = 26 + c[i] - 'A';\n\t\t\t} else\n\t\t\t\tcur = c[i] - 'a';\n\t\t\tif (a[cur] == 0) {\n\t\t\t\ta[cur]++;\n\t\t\t\tlen++;\n\t\t\t\tans = i - l + 1;\n\t\t\t} else {\n\t\t\t\ta[cur]++;\n\t\t\t\tfor (; l < i; ++l) {\n\t\t\t\t\tif (Character.isUpperCase(c[l])) {\n\t\t\t\t\t\tcc = 26 + c[l] - 'A';\n\t\t\t\t\t} else\n\t\t\t\t\t\tcc = c[l] - 'a';\n\t\t\t\t\t\n\t\t\t\t\tif (a[cc] > 1) {\n\t\t\t\t\t\t--a[cc];\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t\tif (i - l + 1 < ans) {\n\t\t\t\t\tans = i - l + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/*int l = 0, r = n - 1;\n\t\tfor (l = 0; l < n; ++l) {\n\t\t\tif (Character.isUpperCase(c[l])) {\n\t\t\t\tif (a[26 + c[l] - 'A'] > 1) {\n\t\t\t\t\ta[26 + c[l] - 'A']--;\n\t\t\t\t} else break;\n\t\t\t} else {\n\t\t\t\tif (a[c[l] - 'a'] > 1) {\n\t\t\t\t\ta[c[l] - 'a']--;\n\t\t\t\t} else break;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor (r = n - 1; r >= 0; --r) {\n\t\t\tif (Character.isUpperCase(c[r])) {\n\t\t\t\tif (a[26 + c[r] - 'A'] > 1) {\n\t\t\t\t\ta[26 + c[r] - 'A']--;\n\t\t\t\t} else break;\n\t\t\t} else {\n\t\t\t\tif (a[c[r] - 'a'] > 1) {\n\t\t\t\t\ta[c[r] - 'a']--;\n\t\t\t\t} else break;\n\t\t\t\t\n\t\t\t}\n\t\t}*/\n\t\tpw.print(ans);\n\t\tpw.close();\n\t}\n\t\n\tprivate static int sumf(int[] fen, int id) {\n\t\tint summ = 0;\n\t\tfor (; id >= 0; id = (id & (id + 1)) - 1) \n \t\t\tsumm += fen[id];\n\t\treturn summ;\n\t}\n\n\tprivate static void addf(int[] fen, int id) {\n\t\tfor (; id < fen.length; id |= id + 1) \n\t\t\tfen[id]++;\n\t}\n\n\tprivate static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tprivate static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tprivate static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tprivate static String next() throws IOException {\n\t\twhile (st==null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n}", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "\nimport java.io.*;\nimport java.util.*;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    long b = 31;\n    String fileName = \"\";\n\n\n    //////////////////////    SOLUTION   SOLUTION  SOLUTION    //////////////////////////////\n    int INF = Integer.MAX_VALUE / 10;\n    long MODULO = 1000*1000*100;\n    int MAX_VALUE = 1000*1000;\n    void solve() throws IOException {\n        long l = readLong();\n        long r = readLong();\n        boolean flag = false;\n        long ans = 0;\n        int bit = 63;\n        while(checkBit(l, bit) == checkBit(r, bit)&&bit>=0) bit--;\n        if (bit==-1) out.println(0);\n        else out.println((1l<<(bit+1))-1);\n    }\n\n\n    class Number implements Comparable<Number>{\n        int x, cost;\n        Number(int x, int cost){\n            this.x = x;\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(Number o) {\n            return Integer.compare(this.cost, o.cost);\n        }\n    }\n    class Point{\n        int x, y;\n        Point(int x, int y){\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    class Vertex implements Comparable<Vertex>{\n        int num, depth, e, c;\n        Vertex(int num, int depth, int e, int c){\n            this.num = num;\n            this.e = e;\n            this.depth = depth;\n            this.c = c;\n        }\n\n        @Override\n        public int compareTo(Vertex o) {\n            return Integer.compare(this.e, o.e);\n        }\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////\n\n    class Edge{\n        int from, to, num;\n        Edge(int to, int num){\n            this.to = to;\n            this.num = num;\n        }\n    }\n\n    class SparseTable{\n        int[][] rmq;\n        int[] logTable;\n        int n;\n        SparseTable(int[] a){\n            n = a.length;\n            logTable = new int[n+1];\n            for(int i = 2; i <= n; ++i){\n                logTable[i] = logTable[i >> 1] + 1;\n            }\n            rmq = new int[logTable[n] + 1][n];\n            for(int i=0; i<n; ++i){\n                rmq[0][i] = a[i];\n            }\n\n            for(int k=1; (1 << k) < n; ++k){\n                for(int i=0; i + (1 << k) <= n; ++i){\n                    int max1 = rmq[k - 1][i];\n                    int max2 = rmq[k-1][i + (1 << (k-1))];\n                    rmq[k][i] = Math.max(max1, max2);\n                }\n            }\n        }\n\n        int max(int l, int r){\n            int k = logTable[r - l];\n            int max1 = rmq[k][l];\n            int max2 = rmq[k][r - (1 << k) + 1];\n            return Math.max(max1, max2);\n        }\n    }\n    long checkBit(long mask, int bit){\n        return (mask >> bit) & 1;\n    }\n    class Dsu{\n        int[] parent;\n        int countSets;\n        Dsu(int n){\n            countSets = n;\n            parent = new int[n];\n            for(int i=0; i<n; ++i){\n                parent[i] = i;\n            }\n        }\n        int findSet(int a){\n            if(parent[a] == a) return a;\n            parent[a] = findSet(parent[a]);\n            return parent[a];\n        }\n        void unionSets(int a, int b){\n            a = findSet(a);\n            b = findSet(b);\n            if(a!=b){\n                countSets--;\n                parent[a] = b;\n            }\n        }\n    }\n    static int checkBit(int mask, int bit) {\n        return (mask >> bit) & 1;\n    }\n    boolean isLower(char c){\n        return c >= 'a' && c <= 'z';\n    }\n\n    ////////////////////////////////////////////////////////////\n\n    class SegmentTree{\n        int[] t;\n        int n;\n        SegmentTree(int n){\n            t = new int[4*n];\n            build(new int[n+1], 1, 1, n);\n        }\n        void build (int a[], int v, int tl, int tr) {\n            if (tl == tr)\n                t[v] = a[tl];\n            else {\n                int tm = (tl + tr) / 2;\n                build (a, v*2, tl, tm);\n                build (a, v*2+1, tm+1, tr);\n            }\n        }\n\n        void update (int v, int tl, int tr, int l, int r, int add) {\n            if (l > r)\n                return;\n            if (l == tl && tr == r)\n                t[v] += add;\n            else {\n                int tm = (tl + tr) / 2;\n                update (v*2, tl, tm, l, Math.min(r,tm), add);\n                update (v*2+1, tm+1, tr, Math.max(l,tm+1), r, add);\n            }\n        }\n\n        int get (int v, int tl, int tr, int pos) {\n            if (tl == tr)\n                return t[v];\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                return t[v] + get (v*2, tl, tm, pos);\n            else\n                return t[v] + get (v*2+1, tm+1, tr, pos);\n        }\n    }\n    class Fenwik {\n        long[] t;\n        int length;\n\n        Fenwik(int[] a) {\n            length = a.length + 100;\n            t = new long[length];\n\n            for (int i = 0; i < a.length; ++i) {\n                inc(i, a[i]);\n            }\n        }\n\n        void inc(int ind, int delta) {\n            for (; ind < length; ind = ind | (ind + 1)) {\n                t[ind] = Math.max(delta, t[ind]);\n            }\n        }\n\n        long getMax(int r) {\n            long sum = 0;\n            for (; r >= 0; r = (r & (r + 1)) - 1) {\n                sum = Math.max(sum, t[r]);\n            }\n            return sum;\n        }\n    }\n    int gcd(int a, int b){\n        return b == 0 ? a : gcd(b, a%b);\n    }\n    long gcd(long a, long b){\n        return b == 0 ? a : gcd(b, a%b);\n    }\n    long binPow(long a, long b, long m) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b % 2 == 1) {\n            return ((a % m) * (binPow(a, b - 1, m) % m)) % m;\n        } else {\n            long c = binPow(a, b / 2, m);\n            return (c * c) % m;\n        }\n\n    }\n    int minInt(int... values) {\n        int min = Integer.MAX_VALUE;\n        for (int value : values) min = Math.min(min, value);\n        return min;\n    }\n\n    int maxInt(int... values) {\n        int max = Integer.MIN_VALUE;\n        for (int value : values) max = Math.max(max, value);\n        return max;\n    }\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        // TODO Auto-generated method stub\n        new Main().run();\n    }\n\n    void run() throws NumberFormatException, IOException {\n        solve();\n        out.close();\n    };\n\n    BufferedReader in;\n    PrintWriter out;\n\n    StringTokenizer tok;\n    String delim = \" \";\n    Random rnd = new Random();\n\n    Main() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } catch (Exception e) {\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new PrintWriter(fileName + \".out\");\n            }\n\n        }\n        tok = new StringTokenizer(\"\");\n    }\n\n    String readLine() throws IOException {\n        return in.readLine();\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            String nextLine = readLine();\n            if (null == nextLine) {\n                return null;\n            }\n\n            tok = new StringTokenizer(nextLine);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(readString());\n    }\n    byte readByte() throws NumberFormatException, IOException {\n        return Byte.parseByte(readString());\n    }\n    int[] readIntArray (int n) throws NumberFormatException, IOException {\n        int[] a = new int[n];\n        for(int i=0; i<n; ++i){\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    Integer[] readIntegerArray (int n) throws NumberFormatException, IOException {\n        Integer[] a = new Integer[n];\n        for(int i=0; i<n; ++i){\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    long readLong() throws NumberFormatException, IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(readString());\n    }\n}\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "\nimport java.io.*;\nimport java.util.*;\n \npublic class Kaudo {\n    static Reader in =new Reader();\n    static StringBuilder Sd=new StringBuilder();\n    static long ans,res,lot,max;\n    static List<Integer>gr[];\n    static ArrayList<Integer> A=new ArrayList();\n    static String ch[];\n     public static void main(String [] args) {\n        int n=in.nextInt(),a[]=new int [n],g=0;\n        for(int i=0;i<n;i++){\n        a[i]=in.nextInt();\n        if(a[i]==1){System.out.println(\"1\");return;}\n        }\n        ans=0;\n        Arrays.sort(a);\n        for(int i=0;i<n;i++){\n            int x=a[i];\n            if(x>0){ans++;\n        for(int u=i;u<n;u++){\n        if(a[u]%x==0){a[u]=0;}\n        \n        }}\n        \n        }\n         System.out.println(ans);\n     }\n     static int gcd(int a,int b){\n     if(b==0)return a;\n     return gcd(b,a%b);\n     }\n   static class Reader \n    {  \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public int nextInt(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; }\n    }\n    \n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n    StreamTokenizer in;\n    PrintWriter out;\n    //deb////////////////////////////////////////////////\n\n    public static void deb(String n, Object n1) {\n        System.out.println(n + \" is : \" + n1);\n    }\n\n    public static void deb(int[] A) {\n\n        for (Object oo : A) {\n            System.out.print(oo + \" \");\n        }\n        System.out.println(\"\");\n    }\n\n    public static void deb(long[] A) {\n\n        for (Object oo : A) {\n            System.out.print(oo + \" \");\n        }\n        System.out.println(\"\");\n    }\n\n    public static void deb(BigInteger[] A) {\n\n        for (Object oo : A) {\n            System.out.print(oo + \" \");\n        }\n        System.out.println(\"\");\n    }\n\n    public static void deb(int[][] A) {\n        for (int i = 0; i < A.length; i++) {\n            for (Object oo : A[i]) {\n                System.out.print(oo + \" \");\n            }\n            System.out.println(\"\");\n        }\n\n    }\n\n    public static void deb(long[][] A) {\n        for (int i = 0; i < A.length; i++) {\n            for (Object oo : A[i]) {\n                System.out.print(oo + \" \");\n            }\n            System.out.println(\"\");\n        }\n\n    }\n\n    public static void deb(String[][] A) {\n        for (int i = 0; i < A.length; i++) {\n            for (Object oo : A[i]) {\n                System.out.print(oo + \" \");\n            }\n            System.out.println(\"\");\n        }\n\n    }\n    /////////////////////////////////////////////////////////////\n\n    int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    long nextLong() throws IOException {\n        in.nextToken();\n        return (long) in.nval;\n    }\n\n    class Pair<X, Y> {\n\n        public X x;\n        public Y y;\n\n        public Pair(X x, Y y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public void setX(X x) {\n            this.x = x;\n        }\n\n        public void setY(Y y) {\n            this.y = y;\n        }\n    }\n\n    boolean inR(int x, int y) {\n        return (x >= 0) && (x < nn) && (y >= 0) && (y < nn);\n    }\n    static int nn;\n\n    void run() throws IOException {\n        //  in = new StreamTokenizer(new BufferedReader(new FileReader(\"circles.in\")));\n        //  out = new PrintWriter(new FileWriter(\"circles.out\"));\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n        solve();\n        out.flush();\n    }\n    static long MOD=1000000009;\nstatic long modPow(long a, int pow) {\n        long res = 1;\n        while (pow > 0) {\n            if ((pow & 1) != 0) {\n                res = res * a % MOD;\n            }\n            pow >>= 1;\n            a = a * a % MOD;\n        }\n        return res;\n    }\n\n    void solve() throws IOException {\n        //   BufferedReader re= new BufferedReader(new FileReader(\"C:\\\\Users\\\\ASELA\\\\Desktop\\\\A.in\"));\n       // BufferedReader re = new BufferedReader(new InputStreamReader(System.in));\n        int n=nextInt(),m=nextInt(),k=nextInt();\n        int an=(n/k)*(k-1)+n%k;\n        long ans=0;\n        if(an>=m){\n            System.out.println(m);\n            return;\n        }\n        int rem=m-an;\n        ans=modPow(2, rem+1)-2;\n        ans*=k;\n        ans+=m-rem*k;\n        ans%=MOD;\n       // System.out.println(\"sjkd\"+rem);\n        if(ans<0)ans+=MOD;\n        System.out.println(ans);\n    }\n}", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n \n \n \npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\t\n\tstatic int oo = (int)1e9;\n\tstatic int mod = 1000000007;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint n = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tArrays.sort(a);\n\t\tboolean[] color = new boolean[n];\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(!color[i]) {\n\t\t\t\tcnt++;\n\t\t\t\tfor(int j = i; j < n; j++) {\n\t\t\t\t\tif(a[j] % a[i] == 0)\n\t\t\t\t\t\tcolor[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(cnt);\n\t\t\n\t\tout.close();\n\t}\n\t\n\t\n\tstatic class SegmentTree {\n\t\tint n;\n\t\tlong[] a, seg;\n\t\tint DEFAULT_VALUE = 0;\n\t\t\n\t\tpublic SegmentTree(long[] a, int n) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.n = n;\n\t\t\tseg = new long[n * 4 + 1];\n\t\t\tbuild(1, 0, n-1);\n\t\t}\n\t\t\n\t\tprivate long build(int node, int i, int j) {\n\t\t\tif(i == j)\n\t\t\t\treturn seg[node] = a[i];\n\t\t\tlong first = build(node * 2, i, (i+j) / 2);\n\t\t\tlong second = build(node * 2 + 1, (i+j) / 2 + 1, j);\n\t\t\treturn seg[node] = combine(first, second);\n\t\t}\n\t\t\n\t\tlong update(int k, long value) {\n\t\t\treturn update(1, 0, n-1, k, value);\n\t\t}\n\t\t\n\t\tprivate long update(int node, int i, int j, int k, long value) {\n\t\t\tif(k < i || k > j)\n\t\t\t\treturn seg[node];\n\t\t\tif(i == j && j == k) {\n\t\t\t\ta[k] = value;\n\t\t\t\tseg[node] = value;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t\n\t\t\tint m = (i + j) / 2;\n\t\t\tlong first = update(node * 2, i, m, k, value);\n\t\t\tlong second = update(node * 2 + 1, m + 1, j, k, value);\n\t\t\treturn seg[node] = combine(first, second);\n\t\t}\n\t\t\n\t\tlong query(int l, int r) {\n\t\t\treturn query(1, 0, n-1, l, r);\n\t\t}\n\t\t\n\t\tprivate long query(int node, int i, int j, int l, int r) {\n\t\t\tif(l <= i && j <= r)\n\t\t\t\treturn seg[node];\n\t\t\tif(j < l || i > r)\n\t\t\t\treturn DEFAULT_VALUE;\n\t\t\tint m = (i + j) / 2;\n\t\t\tlong first = query(node * 2, i, m, l, r);\n\t\t\tlong second = query(node * 2 + 1, m+1, j, l, r);\n\t\t\treturn combine(first, second);\n\t\t}\n \n\t\tprivate long combine(long a, long b) {\n\t\t\treturn a + b;\n\t\t}\n\t}\n\t\n\tstatic class DisjointSet {\n\t\tint n;\n\t\tint[] g;\n\t\tint[] h;\n\t\tpublic DisjointSet(int n) {\n\t\t\tsuper();\n\t\t\tthis.n = n;\n\t\t\tg = new int[n];\n\t\t\th = new int[n];\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = i;\n\t\t\t\th[i] = 1;\n\t\t\t}\n\t\t}\n\t\tint find(int x) {\n\t\t\tif(g[x] == x)\n\t\t\t\treturn x;\n\t\t\treturn g[x] = find(g[x]);\n\t\t}\n\t\tvoid union(int x, int y) {\n\t\t\tx = find(x); y = find(y);\n\t\t\tif(x == y)\n\t\t\t\treturn;\n\t\t\tif(h[x] >= h[y]) {\n\t\t\t\tg[y] = x;\n\t\t\t\tif(h[x] == h[y])\n\t\t\t\t\th[x]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg[x] = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tstatic int[] getPi(char[] a) {\n\t\tint m = a.length;\n\t\tint j = 0;\n\t\tint[] pi = new int[m];\n\t\tfor(int i = 1; i < m; ++i) {\n\t\t\twhile(j > 0 && a[i] != a[j])\n\t\t\t\tj = pi[j-1];\n\t\t\tif(a[i] == a[j]) {\n\t\t\t\tpi[i] = j + 1;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn pi;\n\t}\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "\n\nimport java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n *\n * @author epiZend\n */\npublic class Cottage {\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int t = sc.nextInt();\n        List<Point> houses = new ArrayList<Point>();\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            int a = sc.nextInt();\n            houses.add(new Point(x, a));\n        }\n        Collections.sort(houses, new Comparator<Point>() {\n            \n            @Override\n            public int compare(Point o1, Point o2) {\n                return ((Integer) o1.x).compareTo(o2.x);\n            }\n        });\n        int pos = 2;\n        for (int i = 0; i < n - 1; i++) {\n            double end = houses.get(i).x + (houses.get(i).y+0.0)/2;\n            double start = houses.get(i+1).x - (houses.get(i+1).y+0.0)/2;\n            //System.out.println(\"end \"+end+\" start \"+start);\n            double diff = start-end;\n            //System.out.println(\"diff\");\n            if (Math.abs(diff-t) < 0.0000001) {\n                pos++;\n            }\n            if (diff > t) {\n                pos += 2;\n            }\n        }\n        System.out.println(pos);\n    }\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        int n;\n        int[] bitCount;\n        long neededSum;\n        long[] sums;\n        Map<Long, Integer> where;\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            n = in.nextInt();\n            int[][] a = new int[n][];\n            neededSum = 0;\n            sums = new long[n];\n            for (int i = 0; i < n; i++) {\n                int k = in.nextInt();\n                a[i] = new int[k];\n                for (int j = 0; j < k; j++) {\n                    a[i][j] = in.nextInt();\n                    neededSum += a[i][j];\n                    sums[i] += a[i][j];\n                }\n            }\n\n            if (neededSum % n != 0) {\n                out.println(\"No\");\n                return;\n            }\n            neededSum /= n;\n\n            where = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < a[i].length; j++) {\n                    where.put((long) a[i][j], i);\n                }\n            }\n            bitCount = new int[1 << n];\n            for (int i = 0; i < bitCount.length; i++) {\n                bitCount[i] = Integer.bitCount(i);\n            }\n\n            Entry[][] cycleSol = new Entry[1 << n][];\n\n            List<Entry> sol = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                for (int x : a[i]) {\n                    search(i, i, x, x, 0, 0, sol, cycleSol);\n                }\n            }\n\n            boolean[] can = new boolean[1 << n];\n            int[] via = new int[1 << n];\n            can[0] = true;\n            for (int mask = 0; mask < 1 << n; mask++) {\n                for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n                    if (cycleSol[submask] != null && can[mask ^ submask]) {\n                        can[mask] = true;\n                        via[mask] = submask;\n                    }\n                }\n            }\n\n            if (!can[(1 << n) - 1]) {\n                out.println(\"No\");\n                return;\n            }\n\n            int[][] ans = new int[n][2];\n            for (int mask = (1 << n) - 1; mask > 0; ) {\n                int sm = via[mask];\n                mask ^= sm;\n\n                for (Entry e : cycleSol[sm]) {\n                    ans[e.from][0] = e.what;\n                    ans[e.from][1] = e.to + 1;\n                }\n            }\n\n            out.println(\"Yes\");\n            for (int i = 0; i < n; i++) {\n                out.println(ans[i][0] + \" \" + ans[i][1]);\n            }\n        }\n\n        private void search(int start, int cur, long fromStart, long fromCur, int hasIn, int hasOut, List<Entry> sol, Entry[][] cycleSol) {\n            for (int i = 0; i < n; i++) {\n                if ((hasIn & (1 << i)) > 0) {\n                    continue;\n                }\n                if ((hasOut & (1 << cur)) > 0) {\n                    continue;\n                }\n                long fromI = sums[i] + fromCur - neededSum;\n                Integer w = where.get(fromI);\n                if (w == null || w != i) {\n                    continue;\n                }\n                sol.add(new Entry(cur, i, (int) fromCur));\n                int nHasIn = hasIn | (1 << i);\n                int nHasOut = hasOut | (1 << cur);\n                if (i == start && fromI == fromStart) {\n                    cycleSol[nHasOut] = sol.toArray(new Entry[0]);\n                }\n                search(start, i, fromStart, fromI, nHasIn, nHasOut, sol, cycleSol);\n                sol.remove(sol.size() - 1);\n            }\n        }\n\n        class Entry {\n            int from;\n            int to;\n            int what;\n\n            Entry(int from, int to, int what) {\n                this.from = from;\n                this.to = to;\n                this.what = what;\n            }\n\n            public String toString() {\n                return from + \" \" + to + \" \" + what;\n            }\n\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[])\n    {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=1;\n        while(T-->0)\n        {\n            int n=input.nextInt();\n            int q=input.nextInt();\n            Deque<Integer> dq=new LinkedList<>();\n            int max=0;\n            for(int i=0;i<n;i++)\n            {\n                int a=input.nextInt();\n                dq.add(a);\n                max=Math.max(max,a);\n            }\n            int arr[][]=new int[n+1][2];\n            int x=1;\n            while(true)\n            {\n                int a=dq.poll();\n                int b=dq.poll();\n                if(a==max)\n                {\n                    dq.addFirst(b);\n                    dq.addFirst(a);\n                    break;\n                }\n                else\n                {\n                    arr[x][0]=a;\n                    arr[x][1]=b;\n                    x++;\n                    if(a<=b)\n                    {\n                        dq.addLast(a);\n                        dq.addFirst(b);\n                    }\n                    else\n                    {\n                        dq.addLast(b);\n                        dq.addFirst(a);\n                    }\n                }\n            }\n            int a[]=new int[n];\n            int j=0;\n            while(!dq.isEmpty())\n            {\n                a[j]=dq.poll();\n                j++;\n            }\n            for(int i=0;i<q;i++)\n            {\n                long v=input.nextLong();\n                if(v<x)\n                {\n                    out.println(arr[(int)v][0]+\" \"+arr[(int)v][1]);\n                }\n                else\n                {\n                    v-=x;\n                    v++;\n                    int index=(int)(v%(n-1));\n                    if(index==0)\n                    {\n                        index=n-1;\n                    }\n                    out.println(max+\" \"+a[index]);\n                }\n            }\n        }\n        out.close();\n    }\n    public static void mergeSort(int a[][],int p,int r)\n    {\n        if(p<r)\n        {\n            int q=(p+r)/2;\n            mergeSort(a,p,q);\n            mergeSort(a,q+1,r);\n            merge(a,p,q,r);\n        }\n    }\n    public static void merge(int a[][],int p,int q,int r)\n    {\n        int n1=q-p+2;\n        int L[][]=new int[n1][2];\n        int n2=r-q+1;\n        int R[][]=new int[n2][2];\n        for(int i=p;i<=q;i++)\n        {\n            L[i-p]=a[i];\n        }\n        L[n1-1][0]=Integer.MAX_VALUE;\n        for(int i=q+1;i<=r;i++)\n        {\n            R[i-q-1]=a[i];\n        }\n        R[n2-1][0]=Integer.MAX_VALUE;\n        int x=0,y=0;\n        for(int i=p;i<=r;i++)\n        {\n            if(L[x][0]<=R[y][0])\n            {\n                a[i]=L[x];\n                x++;\n            }\n            else\n            {\n                a[i]=R[y];\n                y++;\n            }\n        }\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "linear", "problem": "1179_A", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "\n\nimport java.util.Scanner;\n\n\n\n/**\n\n *\n\n * @author dell\n\n */\n\npublic class B1762 {\n\n\n\n    /**\n\n     * @param args the command line arguments\n\n     */\n\n static   long bin(long k,long n){\n\n        long s=1;\n\n        long end=k;\n\n        while(s<end){\n\n            long md =(s+end)/2;\n\n            long sum=sum(md,k);\n\n            if(sum==n)\n\n                return k-md+1;\n\n            \n\n        if(sum>n)\n\n            s=md+1;\n\n        else \n\n            end=md;\n\n        }\n\n        return k-s+2;\n\n    }\n\n   \n\n    static long sum(long x,long y){\n\n      if(x<=1)\n\n          return (y*(y+1))/2;\n\n      else return y*(y+1)/2-((x-1)*x)/2;\n\n    }\n\n    public static void main(String[] args) {\n\n        // TODO code application logic here\n\n        Scanner s= new Scanner(System.in);\n\n        long n=s.nextLong();\n\n        long k=s.nextLong();\n\n         if(n==1)\n\n            System.out.println(0);\n\n       else if(n<=k)\n\n            System.out.println(1);\n\n     \n\n        else {\n\n           \n\n           k--;\n\n           n--;\n\n           if(k*(k+1)/2<n)\n\n                System.out.println(-1);\n\n           else \n\n                System.out.println(bin(k, n));\n\n               \n\n               \n\n               }\n\n    \n\n}}\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] argv) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\n\t\tin = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\ttry {\n\t\t\tsolve();\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tPrintWriter out;\n\tScanner in;\n\n\tclass Pair {\n\t\tint x;\n\t\tint y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y;\n\t\t}\n\t}\n\n\tint[] readArr(int size) {\n\t\tint[] a = new int[size];\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tPair[] a = new Pair[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = new Pair(in.nextInt(), in.nextInt());\n\t\t}\n\t\tArrays.sort(a, new Comparator<Pair>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Pair p1, Pair p2) {\n\t\t\t\tif (p2.x != p1.x) {\n\t\t\t\t\treturn p2.x - p1.x;\n\t\t\t\t}\n\t\t\t\treturn p1.y - p2.y;\n\t\t\t}\n\t\t});\n\t\tint cnt = 1;\n\t\tint ans = 0;\n\t\tint[] res = new int[n];\n\t\tres[0] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (!(a[i].x == a[i - 1].x && a[i].y == a[i - 1].y)) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tres[i] = cnt;\n\t\t\t//out.println(a[i] + \" * \" + cnt);\n\t\t}\n\t\tint el = res[k - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (res[i] == el) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\n\t}\n}", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.math.BigDecimal;\nimport java.util.*;\nimport java.math.BigInteger;\npublic class Main {\n    static Long[] a = new Long[205000];\n    static Long[] postfix=new Long[205000];\n    static HashMap<Long,Long> check=new HashMap<Long,Long>();\n    public static void main(String args[]) {\n        Scanner cin = new Scanner(System.in);\n        long k, j, p,sum,equal,bigone,lessone,cnt;\n        BigInteger ans;\n        int i,n;\n        while (cin.hasNext()) {\n            n=cin.nextInt();\n            check.clear();\n            for(i=1;i<=n;i++)\n            {\n                a[i]=cin.nextLong();\n            }\n            postfix[n+1]=0L;\n            for(i=n;i>=1;i--) {\n                postfix[i] = postfix[i + 1] + a[i];\n                if (check.containsKey(a[i]) == true) {\n                    Long v = check.get(a[i]);\n                    v += 1;\n                    check.put(a[i], v);\n                }\n                else\n                    check.put(a[i],1L);\n            }\n            ans=BigInteger.ZERO;\n            for(i=1;i<n;i++){\n                Long v=check.get(a[i]);\n                v--;\n                check.put(a[i],v);\n                equal=check.get(a[i]);\n                bigone=0L;\n                lessone=0L;\n                if(check.containsKey(a[i]+1L)==true)\n                bigone=check.get(a[i]+1L);\n                if(check.containsKey(a[i]-1L)==true)\n                lessone=check.get(a[i]-1L);\n                sum=postfix[i]-bigone*(a[i]+1L)-lessone*(a[i]-1L)-equal*a[i]-a[i];\n                cnt=n-i-bigone-lessone-equal;\n                ans=ans.add(BigInteger.valueOf(a[i]*cnt).subtract(BigInteger.valueOf(sum)));\n            }\n            System.out.println(ans.multiply(BigInteger.valueOf(-1)));\n        }\n    }\n}", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Edu_49E {\n\n\tstatic final long MOD = 998244353;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tStringTokenizer inputData = new StringTokenizer(reader.readLine());\n\t\tint N = Integer.parseInt(inputData.nextToken());\n\t\tint K = Integer.parseInt(inputData.nextToken());\n\n\t\tlong[] ans = new long[N + 1];\n\n\t\tlong[] dp = new long[N + 1];\n\n\t\tfor (int cMaxR = 1; cMaxR <= N; cMaxR++) {\n\t\t\tArrays.fill(dp, 0);\n\t\t\tdp[0] = 2;\n\t\t\tlong cSum = 2;\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tdp[i] = cSum;\n\t\t\t\tcSum = (cSum + dp[i]) % MOD;\n\t\t\t\tif (i - cMaxR >= 0) {\n\t\t\t\t\tcSum = (cSum - dp[i - cMaxR] + MOD) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[cMaxR] = dp[N];\n\t\t}\n\n\t\tlong fAns = 0;\n\t\tfor (int side1 = 1; side1 <= Math.min(K, N); side1++) {\n\t\t\tlong cntWays = (ans[side1] - ans[side1 - 1] + MOD) % MOD;\n\t\t\tlong mWays;\n\t\t\tif ((K + side1 - 1) / side1 > N) {\n\t\t\t\tmWays = ans[N];\n\t\t\t} else {\n\t\t\t\tmWays = ans[(K + side1 - 1) / side1 - 1];\n\t\t\t}\n\t\t\tfAns = (fAns + cntWays * mWays % MOD) % MOD;\n\t\t}\n\t\tfAns = (fAns * 499122177) % MOD;\n\t\tprinter.println(fAns);\n\t\tprinter.close();\n\t}\n}\n", "complexity": "quadratic", "problem": "1027_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class AMain {\n\tstatic int n;\n\tstatic int[] best;\n\tstatic int[][] dist;\n\tstatic int[] home;\n\tstatic LinkedList<Integer> ret;\n\tpublic static void main(String[] args) throws IOException\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tState curr = new State(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));\n\t\tn = Integer.parseInt(br.readLine());\n\t\tState[] list = new State[n];\n\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tlist[i] = new State(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));\n\t\t}\n\t\tdist = new int[n][n];\n\t\thome = new int[n];\n\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\thome[i] = dist(curr, list[i]);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\tdist[i][i] = 2 * home[i];\n\t\t\tfor(int j = i+1; j < n; j++)\t\t{\n\t\t\t\tdist[i][j] = dist(list[i], list[j]) + home[i] + home[j];\n\t\t\t}\n\t\t}\n\t\tbest = new int[1 << (n)];\n\t\tArrays.fill(best, -1);\n\t\tbest[0] = 0;\n\t\tSystem.out.println(solve(-1 + (1<<n)));\n\t\tret = new LinkedList<Integer>();\n\t\tresolve(-1 + (1<<n));\n\t\tfor(int x: ret)\n\t\t\tSystem.out.print(x + \" \");\n\t}\n\tpublic static int dist(State a, State b)\t{\n\t\tint x = a.x-b.x;\n\t\tint y = a.y-b.y;\n\t\treturn x*x+y*y;\n\t}\n\tpublic static void resolve(int curr)\t{\n\t\tret.addLast(0);\n\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\tif((curr & (1<<i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tfor(int j = i+1; j < n; j++)\t{\n\t\t\t\tif((curr & (1 << j)) == 0)\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dist[i][j] + solve(curr ^ (1<<i) ^ (1 << j)) == best[curr])\t{\n\t\t\t\t\tret.addLast(i+1);\n\t\t\t\t\tret.addLast(j+1);\n\t\t\t\t\tresolve(curr - (1<<i) - (1<<j));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best[curr] == dist[i][i] + solve(curr ^ (1<<i)))\t{\n\t\t\t\tret.addLast(i+1);\n\t\t\t\tresolve(curr - (1<<i));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int solve(int curr)\t{\n\t\tif(best[curr] != -1)\n\t\t\treturn best[curr];\n\t\tint ret = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\tif((curr & (1<<i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tfor(int j = i+1; j < n; j++)\t{\n\t\t\t\tif((curr & (1 << j)) == 0)\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = Math.min(ret, dist[i][j] + solve(curr ^ (1<<i) ^ (1 << j)));\n\t\t\t}\n\t\t\tret = Math.min(ret, dist[i][i] + solve(curr ^ (1<<i)));\n\t\t\tbreak;\n\t\t}\n\t\tbest[curr] = ret;\n\t\treturn ret;\n\t}\n\tstatic class State\t{\n\t\tpublic int x,y;\n\t\tpublic State(int a, int b)\t{\n\t\t\tx=a;\n\t\t\ty=b;\n\t\t}\n\t}\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class _1036_B_DiagonalWalkingV2 {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tint Q = readInt();\n\t\twhile(Q-- > 0) {\n\t\t\tlong n = readLong(), m = readLong(), k = readLong();\n\t\t\tif(Math.max(n, m) > k) println(-1);\n\t\t\telse {\n\t\t\t\tlong ans = k;\n\t\t\t\tif(n%2 != k%2) ans--;\n\t\t\t\tif(m%2 != k%2) ans--;\n\t\t\t\tprintln(ans);\n\t\t\t}\n\t\t}\n\t\texit();\n\t}\n\n\tfinal private static int BUFFER_SIZE = 1 << 16;\n\tprivate static DataInputStream din = new DataInputStream(System.in);\n\tprivate static byte[] buffer = new byte[BUFFER_SIZE];\n\tprivate static int bufferPointer = 0, bytesRead = 0;\n\tstatic PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n\tpublic static String readLine() throws IOException {\n\t\tbyte[] buf = new byte[64]; // line length\n\t\tint cnt = 0, c;\n\t\twhile ((c = Read()) != -1) {\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t\tbuf[cnt++] = (byte) c;\n\t\t}\n\t\treturn new String(buf, 0, cnt);\n\t}\n\n\tpublic static String read() throws IOException {\n\t\tbyte[] ret = new byte[1024];\n\t\tint idx = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ') {\n\t\t\tc = Read();\n\t\t}\n\t\tdo {\n\t\t\tret[idx++] = c;\n\t\t\tc = Read();\n\t\t} while (c != -1 && c != ' ' && c != '\\n' && c != '\\r');\n\t\treturn new String(ret, 0, idx);\n\t}\n\n\tpublic static int readInt() throws IOException {\n\t\tint ret = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tpublic static long readLong() throws IOException {\n\t\tlong ret = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tpublic static double readDouble() throws IOException {\n\t\tdouble ret = 0, div = 1;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\n\t\tif (c == '.') {\n\t\t\twhile ((c = Read()) >= '0' && c <= '9') {\n\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t}\n\t\t}\n\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tprivate static void fillBuffer() throws IOException {\n\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\tif (bytesRead == -1)\n\t\t\tbuffer[0] = -1;\n\t}\n\n\tprivate static byte Read() throws IOException {\n\t\tif (bufferPointer == bytesRead)\n\t\t\tfillBuffer();\n\t\treturn buffer[bufferPointer++];\n\t}\n\n\tstatic void print(Object o) {\n\t\tpr.print(o);\n\t}\n\n\tstatic void println(Object o) {\n\t\tpr.println(o);\n\t}\n\n\tstatic void flush() {\n\t\tpr.flush();\n\t}\n\n\tstatic void println() {\n\t\tpr.println();\n\t}\n\n\tstatic void exit() throws IOException {\n\t\tdin.close();\n\t\tpr.close();\n\t\tSystem.exit(0);\n\t}\n}\n", "complexity": "linear", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class c {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tlong bounty = in.nextInt(), increase = in.nextInt();\n\t\tint damage = in.nextInt();\n\t\tint[] mh = new int[n];\n\t\tint[] sh = new int[n];\n\t\tint[] reg = new int[n];\n\t\tlong countKilled = 0;\n\t\tArrayList<Event> es = new ArrayList<>();\n\t\tEvent[] regen = new Event[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tmh[i] = in.nextInt();\n\t\t\tsh[i] = in.nextInt();\n\t\t\treg[i] = in.nextInt();\n\t\t\tif(sh[i] <= damage)\n\t\t\t\tcountKilled++;\n\t\t\tif(reg[i] > 0) {\n\t\t\t\tint time = (damage+1 - sh[i]+reg[i]-1)/reg[i];\n\t\t\t\tif(time > 0 && mh[i] >= damage+1) {\n\t\t\t\t\tEvent e2 = new Event(time, i, damage+1);\n\t\t\t\t\tregen[i] = e2;\n\t\t\t\t\tes.add(e2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tEvent e = new Event(in.nextInt(), in.nextInt()-1, in.nextInt());\n\t\t\tes.add(e);\n\t\t\tif(reg[e.e] > 0) {\n\t\t\t\tint time = (damage+1 - e.h+reg[e.e]-1)/reg[e.e];\n\t\t\t\tif(time > 0 && mh[e.e] >= damage+1) {\n\t\t\t\t\tEvent e2 = new Event(e.t + time, e.e, damage+1);\n\t\t\t\t\te.regen = e2;\n\t\t\t\t\tes.add(e2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(es, (a,b) -> a.t-b.t);\n\t\tlong ans = countKilled*bounty;\n\t\tint lastTime = 0;\n\t\tfor(Event e : es) {\n\t\t\tif(e.t == -1) continue;\n\t\t\tif(regen[e.e] != e && regen[e.e] != null) {\n\t\t\t\tregen[e.e].t = -1;\n\t\t\t\tregen[e.e] = null;\n\t\t\t}\n\t\t\tif(lastTime != e.t) {\n\t\t\t\tans = Math.max(ans, countKilled*(bounty+(e.t-1)*increase));\n\t\t\t}\n\t\t\tif(sh[e.e] <= damage)\n\t\t\t\tcountKilled--;\n\t\t\tsh[e.e] = e.h;\n\t\t\tif(sh[e.e] <= damage)\n\t\t\t\tcountKilled++;\n\t\t\tif(e.regen != null) {\n\t\t\t\tregen[e.e] = e.regen;\n\t\t\t}\n\t\t\tlastTime = e.t;\n\t\t}\n\t\tif(countKilled != 0) {\n\t\t\tif(increase > 0)\n\t\t\t\tans = -1;\n\t\t\telse\n\t\t\t\tans = Math.max(ans, countKilled*bounty);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tstatic class Event {\n\t\tint t;\n\t\tint e;\n\t\tint h;\n\t\tEvent regen;\n\t\tpublic Event(int tt, int ee, int hh) {\n\t\t\tt = tt;\n\t\t\te = ee;\n\t\t\th = hh;\n\t\t}\n\t}\n\tstatic class FastScanner {\n\t    BufferedReader br;\n\t    StringTokenizer st;\n\t    public FastScanner(InputStream i) {\n\t        br = new BufferedReader(new InputStreamReader(i));\n\t        st = new StringTokenizer(\"\");\n\t    }\n\t    public String next() throws IOException {\n\t        if(st.hasMoreTokens())\n\t            return st.nextToken();\n\t        else\n\t            st = new StringTokenizer(br.readLine());\n\t        return next();\n\t    }\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    public long nextLong() throws IOException {\n\t        return Long.parseLong(next());\n\t    }\n\t    public double nextDouble() throws IOException {\n\t        return Double.parseDouble(next());\n\t    }\n\t}\n}\n", "complexity": "nlogn", "problem": "0912_C", "from": "CODEFORCES", "tags": "brute force,greedy,sortings"}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class A {\n\n\t@SuppressWarnings(\"resource\")\n\tpublic static void main(String[] args) {\n\t\tInputStream input;\n\t\tOutputStream output;\n\t\ttry {\n\t\t\tinput = new FileInputStream(\"input.txt\");\n\t\t\toutput = new FileOutputStream(\"output.txt\");\n\t\t} catch (FileNotFoundException e) {\n\t\t\tinput = System.in;\n\t\t\toutput = System.out;\n\t\t}\n\t\tKattio io = new Kattio(input, output);\n\t\t(new Solve(io)).main();\n\t\tio.close();\n\n\t\tif (input instanceof FileInputStream)\n\t\t\ttry {\n\t\t\t\tinput.close();\n\t\t\t} catch (IOException e) {\n\t\t\t}\n\t\tif (output instanceof FileOutputStream)\n\t\t\ttry {\n\t\t\t\toutput.close();\n\t\t\t} catch (IOException e) {\n\t\t\t}\n\t}\n\n}\n\nclass Solve {\n\tKattio io;\n\t\n\tlong n,k;\n\t\n\tSolve(Kattio io) {\n\t\tthis.io = io;\n\t}\n\n\tvoid main() {\n\t\tn = io.getLong();\n\t\tk = io.getLong();\n\t\tlong res = n*2/k+n*5/k+n*8/k;\n\t\tif (n*2%k!=0) res++;\n\t\tif (n*5%k!=0) res++;\n\t\tif (n*8%k!=0) res++;\n\t\tio.println(res);\n\t}\n}\n\n/** Simple yet moderately fast I/O routines.\n*\n* Example usage:\n*\n* Kattio io = new Kattio(System.in, System.out);\n*\n* while (io.hasMoreTokens()) {\n*    int n = io.getInt();\n*    double d = io.getDouble();\n*    double ans = d*n;\n*\n*    io.println(\"Answer: \" + ans);\n* }\n*\n* io.close();\n*\n*\n* Some notes:\n*\n* - When done, you should always do io.close() or io.flush() on the\n*   Kattio-instance, otherwise, you may lose output.\n*\n* - The getInt(), getDouble(), and getLong() methods will throw an\n*   exception if there is no more data in the input, so it is generally\n*   a good idea to use hasMoreTokens() to check for end-of-file.\n*\n* @author: Kattis\n*/\nclass Kattio extends PrintWriter {\n\tpublic Kattio(InputStream i) {\n\t\tsuper(new BufferedOutputStream(System.out));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic Kattio(InputStream i, OutputStream o) {\n\t\tsuper(new BufferedOutputStream(o));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic boolean hasMoreTokens() {\n\t\treturn peekToken() != null;\n\t}\n\n\tpublic int getInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double getDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long getLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic String getWord() {\n\t\treturn nextToken();\n\t}\n\n\tprivate BufferedReader r;\n\tprivate String line;\n\tprivate StringTokenizer st;\n\tprivate String token;\n\n\tprivate String peekToken() {\n\t\tif (token == null)\n\t\t\ttry {\n\t\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t}\n\t\t\t\ttoken = st.nextToken();\n\t\t\t} catch (IOException e) {\n\t\t\t}\n\t\treturn token;\n\t}\n\n\tprivate String nextToken() {\n\t\tString ans = peekToken();\n\t\ttoken = null;\n\t\treturn ans;\n\t}\n}", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Solution implements Runnable {\n    FastScanner sc;\n    PrintWriter pw;\n    \n    final class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n \n        public long nlo() {\n            return Long.parseLong(next());\n        }\n \n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return st.nextToken();\n        }\n \n        public int ni() {\n            return Integer.parseInt(next());\n        }\n \n        public String nli() {\n            String line = \"\";\n            if (st.hasMoreTokens()) line = st.nextToken();\n            else try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            while (st.hasMoreTokens()) line += \" \" + st.nextToken();\n            return line;\n        }\n \n        public double nd() {\n            return Double.parseDouble(next());\n        }\n    }\n    public static void main(String[] args) throws Exception\n    {\n        new Thread(null,new Solution(),\"codeforces\",1<<28).start();\n    }\n    public void run()\n    {\n        sc=new FastScanner();\n        pw=new PrintWriter(System.out);\n        try{\n        solve();}\n        catch(Exception e)\n        {\n            pw.println(5/0);\n        }\n        pw.flush();\n        pw.close();\n    }\n    public long gcd(long a,long b)\n    {\n        return b==0L?a:gcd(b,a%b);\n    }\n    public long ppow(long a,long b,long mod)\n    {\n        if(b==0L)\n        return 1L;\n        long tmp=1;\n        while(b>1L)\n        {\n            if((b&1L)==1L)\n            tmp*=a;\n            a*=a;\n            a%=mod;\n            tmp%=mod;\n            b>>=1;\n        }\n        return (tmp*a)%mod;\n    }\n    public long pow(long a,long b)\n    {\n        if(b==0L)\n        return 1L;\n        long tmp=1;\n        while(b>1L)\n        {\n            if((b&1L)==1)\n            tmp*=a;\n            a*=a;\n            b>>=1;\n        }\n        return (tmp*a);\n    }\n    public  int gcd(int x,int y)\n    {\n        return y==0?x:gcd(y,x%y);\n    }\n   \n    //////////////////////////////////\n    /////////////  LOGIC  ///////////\n    ////////////////////////////////\n    int ans=0;\n    public void solve() throws Exception{\n        int n=sc.ni();\n        int[] arr=new int[n];\n        for(int i=0;i<n;i++)\n        arr[i]=sc.ni();\n        invcount(arr,0,n-1);\n        n%=2;\n        ans%=2;\n        if(n==ans)\n        pw.print(\"Petr\");\n        else\n        pw.print(\"Um_nik\");\n    }\n    public ArrayList<Integer> invcount(int[] arr,int l,int r){\n        if(r<=l){\n         ArrayList<Integer> list = new ArrayList();\n         list.add(arr[l]);\n         return list;}\n        int mid=(l+r)/2,p=0,q=0;\n        ArrayList<Integer> list=invcount(arr,l,(l+r)/2);\n        ArrayList<Integer> list1=invcount(arr,(l+r)/2+1,r);\n        ArrayList<Integer> ret=new ArrayList();\n        while(list1.size()>q&&list.size()>p){\n            if(list.get(p)<list1.get(q))\n            ret.add(list.get(p++));\n            else{\n                ans=(ans+(list.size()-p)%2)%2;\n                ret.add(list1.get(q++));\n            }\n        }\n        while(p<list.size())\n        ret.add(list.get(p++));\n        while(q<list1.size())\n        ret.add(list1.get(q++));\n        return ret;\n    }\n}", "complexity": "nlogn", "problem": "0986_B", "from": "CODEFORCES", "tags": "combinatorics,math"}
{"src": "// https://codeforces.com/contest/1185/submission/55800229 (rainboy)\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1185G2 {\n\tstatic final int MD = 1000000007;\n\tstatic int[][] solve1(int[] aa, int t, int n) {\n\t\tint[][] da = new int[t + 1][n + 1];\n\t\tda[0][0] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = aa[i];\n\t\t\tfor (int s = t - 1; s >= 0; s--)\n\t\t\t\tfor (int m = 0; m < n; m++) {\n\t\t\t\t\tint x = da[s][m];\n\t\t\t\t\tif (x != 0) {\n\t\t\t\t\t\tint s_ = s + a;\n\t\t\t\t\t\tif (s_ <= t)\n\t\t\t\t\t\t\tda[s_][m + 1] = (da[s_][m + 1] + x) % MD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn da;\n\t}\n\tstatic int[][][] solve2(int[] aa, int[] bb, int t, int na, int nb) {\n\t\tint[][] da = solve1(aa, t, na);\n\t\tint[][][] dab = new int[t + 1][na + 1][nb + 1];\n\t\tfor (int s = 0; s <= t; s++)\n\t\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\t\tdab[s][ma][0] = da[s][ma];\n\t\tfor (int i = 0; i < nb; i++) {\n\t\t\tint b = bb[i];\n\t\t\tfor (int s = t - 1; s >= 0; s--)\n\t\t\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\t\t\tfor (int mb = 0; mb < nb; mb++) {\n\t\t\t\t\t\tint x = dab[s][ma][mb];\n\t\t\t\t\t\tif (x != 0) {\n\t\t\t\t\t\t\tint s_ = s + b;\n\t\t\t\t\t\t\tif (s_ <= t)\n\t\t\t\t\t\t\t\tdab[s_][ma][mb + 1] = (dab[s_][ma][mb + 1] + x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t}\n\t\treturn dab;\n\t}\n\tstatic int[][][] init(int n, int na, int nb, int nc) {\n\t\tint[][][] dp = new int[na + 1][nb + 1][nc + 1];\n\t\tint[][][][] dq = new int[na + 1][nb + 1][nc + 1][3];\n\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\tfor (int mb = 0; mb <= nb; mb++)\n\t\t\t\tfor (int mc = 0; mc <= nc; mc++)\n\t\t\t\t\tif (ma == 0 && mb == 0 && mc == 0) {\n\t\t\t\t\t\tdp[ma][mb][mc] = 1;\n\t\t\t\t\t\tdq[ma][mb][mc][0] = dq[ma][mb][mc][1] = dq[ma][mb][mc][2] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint x0 = ma > 0 ? (int) ((long) dq[ma - 1][mb][mc][0] * ma % MD) : 0;\n\t\t\t\t\t\tint x1 = mb > 0 ? (int) ((long) dq[ma][mb - 1][mc][1] * mb % MD) : 0;\n\t\t\t\t\t\tint x2 = mc > 0 ? (int) ((long) dq[ma][mb][mc - 1][2] * mc % MD) : 0;\n\t\t\t\t\t\tdp[ma][mb][mc] = (int) (((long) x0 + x1 + x2) % MD);\n\t\t\t\t\t\tdq[ma][mb][mc][0] = (x1 + x2) % MD;\n\t\t\t\t\t\tdq[ma][mb][mc][1] = (x2 + x0) % MD;\n\t\t\t\t\t\tdq[ma][mb][mc][2] = (x0 + x1) % MD;\n\t\t\t\t\t}\n\t\treturn dp;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint t = Integer.parseInt(st.nextToken());\n\t\tint[] aa = new int[n];\n\t\tint[] bb = new int[n];\n\t\tint[] cc = new int[n];\n\t\tint na = 0, nb = 0, nc = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint a = Integer.parseInt(st.nextToken());\n\t\t\tint g = Integer.parseInt(st.nextToken());\n\t\t\tif (g == 1)\n\t\t\t\taa[na++] = a;\n\t\t\telse if (g == 2)\n\t\t\t\tbb[nb++] = a;\n\t\t\telse\n\t\t\t\tcc[nc++] = a;\n\t\t}\n\t\tint[][][] dp = init(n, na, nb, nc);\n\t\tint[][][] dab = solve2(aa, bb, t, na, nb);\n\t\tint[][] dc = solve1(cc, t, nc);\n\t\tint ans = 0;\n\t\tfor (int tab = 0; tab <= t; tab++) {\n\t\t\tint tc = t - tab;\n\t\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\t\tfor (int mb = 0; mb <= nb; mb++) {\n\t\t\t\t\tint xab = dab[tab][ma][mb];\n\t\t\t\t\tif (xab == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int mc = 0; mc <= nc; mc++) {\n\t\t\t\t\t\tint xc = dc[tc][mc];\n\t\t\t\t\t\tif (xc == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tans = (int) ((ans + (long) xab * xc % MD * dp[ma][mb][mc]) % MD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.Scanner; \nimport java.util.StringTokenizer; \nimport java.util.*;\nimport java.io.*;\npublic class codeforces \n{ \n   static class Student{\n       long x,y;\n        Student(long x,long y){\n            this.x=x;\n            this.y=y;\n        }\n    }\n    static int prime[];\n    static void sieveOfEratosthenes(int n) \n    { \n        // Create a boolean array \"prime[0..n]\" and initialize \n        // all entries it as true. A value in prime[i] will \n        // finally be false if i is Not a prime, else true. \n        int pos=0;\n        prime= new int[n+1]; \n        for(int p = 2; p*p <=n; p++) \n        { \n            // If prime[p] is not changed, then it is a prime \n            if(prime[p] == 0)\n            { \n                // Update all multiples of p\n                prime[p]=p;\n                for(int i = p*p; i <= n; i += p) \n                    prime[i] = p; \n            } \n        } \n    }\nstatic    class Sortbyroll implements Comparator<Student> \n{ \n    // Used for sorting in ascending order of \n    // roll number \n    public int compare(Student c, Student b) \n    { \n        if(c.x<=b.x)\n            return -1;\n        return 1;\n    } \n} \nstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n \n    static class Edge{\n        int a,b;\n        Edge(int a,int b){\n            this.a=a;\n            this.b=b;\n        }\n    }\n    static int parent[];\n    static int rank[];\n    static int b[][];\n    //static int seg[];\n    static int ans;\n    static void solve()throws IOException{\n        FastReader sc=new FastReader();\n        int c,x,i;\n        long l,r,y=1,f=0,t1,t2;\n        int a1[]=new int[64];\n        int a2[]=new int[64];\n        int ans[]=new int[64];\n        c=-1;\n        l=sc.nextLong();\n        t1=l;\n        r=sc.nextLong();\n        t2=r;\n        while(l!=0){\n            a1[++c]=(int)(l%(long)2);\n            l=l/(long)2;\n        }\n        c=-1;\n                while(r!=0){\n            a2[++c]=(int)(r%(long)2);\n                    r=r/(long)2;\n        }\n        for(i=63;i>=0;i--){\n            ans[i]=a2[i];\n            if(a2[i]==1&&a1[i]==0)\n                break;\n        }\n        if(t1==t2)\n            System.out.println(0);\n        else\n        System.out.println((1l<<(i+1))-1);\n    }\n    public static void main(String[] args){\n        //long sum=0;\n        try {\n                codeforces.solve();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n    }\n /*static long power(long x, long y, long p) \n{ \n    long res = 1;      // Initialize result \n  \n    x = x % p;  // Update x if it is more than or  \n                // equal to p \n  \n    /*while (y > 0) \n    { \n        // If y is odd, multiply x with result \n        if ((y & (long)1)%2!=0) \n            res = (res*x) % p; \n  \n        // y must be even now \n        y = y>>1; // y = y/2 \n        x = (x*x) % p;   \n    } */\n    //return res%p; \n   static int find(int x) \n    { \n        // Finds the representative of the set \n        // that x is an element of \n        while(parent[x]!=x) \n        { \n            // if x is not the parent of itself \n            // Then x is not the representative of \n            // his set,\n            x=parent[x];\n  \n            // so we recursively call Find on its parent \n            // and move i's node directly under the \n            // representative of this set \n        } \n  \n        return x; \n    }\n    static void union(int x, int y) \n    { \n        // Find representatives of two sets \n        int xRoot = find(x), yRoot = find(y); \n  \n        // Elements are in the same set, no need \n        // to unite anything. \n        if (xRoot == yRoot) \n            return; \n  \n         // If x's rank is less than y's rank \n        if (rank[xRoot] < rank[yRoot]) \n  \n            // Then move x under y  so that depth \n            // of tree remains less \n            parent[xRoot] = yRoot; \n  \n        // Else if y's rank is less than x's rank \n        else if (rank[yRoot] < rank[xRoot]) \n  \n            // Then move y under x so that depth of \n            // tree remains less \n            parent[yRoot] = xRoot; \n  \n        else // if ranks are the same \n        { \n            // Then move y under x (doesn't matter \n            // which one goes where) \n            parent[yRoot] = xRoot; \n  \n            // And increment the the result tree's \n            // rank by 1 \n            rank[xRoot] = rank[xRoot] + 1; \n        } \n    } \n    static long gcd(long a, long b) \n    { \n        if (a == 0) \n            return b; \n        return gcd(b % a, a); \n    }\n}", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic final class PythonIndentation\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tnew PythonIndentation(System.in, System.out);\n\t}\n\n\tstatic class Solver implements Runnable\n\t{\n\t\tstatic final int MOD = (int) 1e9 + 7;\n\t\tint n;\n\t\tchar[] arr;\n\t\tlong[][] dp;\n\t\tBufferedReader in;\n\t\tPrintWriter out;\n\n\t\tvoid solve() throws IOException\n\t\t{\n\t\t\tn = Integer.parseInt(in.readLine());\n\t\t\tarr = new char[n];\n\t\t\tdp = new long[n + 1][n + 1];\n\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = in.readLine().charAt(0);\n\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tArrays.fill(dp[i], -1);\n\n\t\t\tdp[0][0] = 1;\n\n\t\t\tif (arr[0] == 's')\n\t\t\t\tout.println(find(1, 0));\n\t\t\telse\n\t\t\t\tout.println(find(1, 1));\n\n/*\t\t\tSystem.out.println(\"dp :\");\n\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t{\n\t\t\t\tSystem.out.print(\"i : \" + i + \" => \");\n\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}*/\n\t\t}\n\n\t\tlong find(int curr, int backIndents)\n\t\t{\n//\t\t\tSystem.out.println(\"curr : \" + curr + \", bI : \" + backIndents);\n\t\t\tif (backIndents < 0)\n\t\t\t\treturn 0;\n\n\t\t\tif (curr == n)\n\t\t\t\treturn dp[curr][backIndents] = 1;\n\n\t\t\tif (dp[curr][backIndents] != -1)\n\t\t\t\treturn dp[curr][backIndents];\n\n\t\t\tlong ans;\n\n\t\t\tif (arr[curr] == 's')\n\t\t\t{\n\t\t\t\tif (arr[curr - 1] == 'f')\n\t\t\t\t\tans = find(curr + 1, backIndents);\n\t\t\t\telse\n\t\t\t\t\tans = CMath.mod(find(curr + 1, backIndents) + find(curr, backIndents - 1), MOD);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans = find(curr + 1, backIndents + 1);\n\n\t\t\t\tif (arr[curr - 1] != 'f')\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"calling from curr : \" + curr + \", bI : \" + backIndents);\n\t\t\t\t\tans = CMath.mod(ans + find(curr, backIndents - 1), MOD);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dp[curr][backIndents] = ans;\n\t\t}\n\n\t\tpublic Solver(BufferedReader in, PrintWriter out)\n\t\t{\n\t\t\tthis.in = in;\n\t\t\tthis.out = out;\n\t\t}\n\n\t\t@Override public void run()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsolve();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class CMath\n\t{\n\t\tstatic long mod(long number, long mod)\n\t\t{\n\t\t\treturn number - (number / mod) * mod;\n\t\t}\n\n\t}\n\n\tprivate PythonIndentation(InputStream inputStream, OutputStream outputStream)\n\t{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(inputStream));\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tThread thread = new Thread(null, new Solver(in, out), \"PythonIndentation\", 1 << 29);\n\n\t\ttry\n\t\t{\n\t\t\tthread.start();\n\t\t\tthread.join();\n\t\t}\n\t\tcatch (InterruptedException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t}\n\t}\n\n}\n\n/*\n\n6\nf\nf\ns\ns\ns\ns\n: 10\n\n*/\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\n    public static void main(String[] args) throws IOException {\n//        out = new PrintWriter(new File(\"output.txt\"));\n//        br = new BufferedReader(new FileReader(new File(\"input.txt\")));\n        int JOPI = 1;\n        for (int NASRAL = 0; NASRAL < JOPI; NASRAL++) {\n            int n = nextInt() + 2;\n            int m = nextInt();\n            int[] a = new int[n];\n            for (int i = 1; i < n - 1; i++) {\n                a[i] = nextInt();\n            }\n            a[n - 1] = m;\n            boolean on = true;\n            if (n % 2 == 1) on = false;\n            int[] suf_on = new int[n];\n            int[] suf_off = new int[n];\n            for (int i = n - 2; i >= 0; i--) {\n                suf_off[i] = suf_off[i + 1];\n                suf_on[i] = suf_on[i + 1];\n                if (on) {\n                    suf_on[i] += a[i + 1] - a[i];\n                } else {\n                    suf_off[i] += a[i + 1] - a[i];\n                }\n                on = !on;\n            }\n            int ans = suf_on[0];\n            on = true;\n            int now = 0;\n            for (int i = 1; i < n; i++) {\n                ans = Math.max(ans, suf_on[i]);\n                if (on) {\n                    int can = a[i] - a[i - 1] - 1;\n                    int plus = suf_on[i];\n                    if (can > 0) ans = Math.max(ans, can + plus + now);\n                    now += a[i] - a[i - 1];\n                } else {\n                    int plus = 0;\n                    plus = suf_off[i];\n                    int can = a[i] - a[i - 1] - 1;\n                    if (can > 0) ans = Math.max(ans, can + plus + now);\n                }\n                on = !on;\n            }\n            out.println(ans);\n        }\n        out.close();\n    }\n\n\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter out = new PrintWriter(System.out);\n    static StringTokenizer in = new StringTokenizer(\"\");\n\n\n    public static String next() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n        return in.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n}\n\nclass Point {\n    long i;\n    long j;\n    long x;\n\n    public Point(long i, long j, long x) {\n        this.i = i;\n        this.j = j;\n        this.x = x;\n    }\n}", "complexity": "linear", "problem": "1000_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import java.awt.Point;\n\nimport java.io.BufferedReader;\n\nimport java.io.File;\n\nimport java.io.FileReader;\n\nimport java.io.FileWriter;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\n\n\npublic class Contest35_3 {\n\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader in = new BufferedReader(new FileReader(\"input.txt\"));\n\n        String[] s = in.readLine().split(\" \");\n\n        int n = Integer.parseInt(s[0]);\n\n        int m = Integer.parseInt(s[1]);\n\n        int k = Integer.parseInt(in.readLine());\n\n        s = in.readLine().split(\" \");\n\n        Point[] inp = new Point[k];\n\n        int p = 0;\n\n        for (int i = 0; i < k; i++) {\n\n            inp[i] = new Point(Integer.parseInt(s[p++]),\n\n                    Integer.parseInt(s[p++]));\n\n        }\n\n        int max = -1;\n\n        int maxx = -1;\n\n        int maxy = -1;\n\n        int i;\n\n        int j, dist;\n\n        for (i = 1; i <= n; i++) {\n\n            for (j = 1; j <= m; j++) {\n\n                dist = 1000000;\n\n                for (int l = 0; l < inp.length; l++) {\n\n                    dist = Math.min(\n\n                            Math.abs(inp[l].x - i) + Math.abs(inp[l].y - j),\n\n                            dist);\n\n                }\n\n                if (dist > max) {\n\n                    max = dist;\n\n                    maxx = i;\n\n                    maxy = j;\n\n                }\n\n            }\n\n        }\n\n        String res = maxx + \" \" + maxy + \"\\n\";\n\n        FileWriter out = new FileWriter(new File(\"output.txt\"));\n\n        out.append(res);\n\n        out.flush();\n\n        out.close();\n\n    }\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.StreamTokenizer;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\n\n\npublic class a {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\t//BufferedReader input = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t//BufferedWriter output = new BufferedWriter(new FileWriter(\"output.txt\"));\n\t\tBufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter output = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tStreamTokenizer in = new StreamTokenizer(input);\n\t\t\n\t\tin.nextToken();\n\t\tint n = (int)in.nval;\n\t\tint[] mas = new int[n];\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tin.nextToken();\n\t\t\tmas[i] = (int)in.nval;\n\t\t}\n\t\t\n\t\tArrays.sort(mas);\n\t\tint min = mas[0];\n\t\tint i = 1;\n\t\t\n\t\twhile ((i < n)&&(min == mas[i])) {\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tif (i < n) {\n\t\t\toutput.write(Integer.toString(mas[i]));\n\t\t}\n\t\telse {\n\t\t\toutput.write(\"NO\");\n\t\t}\n\t\tinput.close();\n\t\toutput.close();\n\t}\n\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author \\/\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n\n            TaskC.pair[] songs = new TaskC.pair[n];\n            long sum = 0;\n            for (int i = 0; i < n; i++) {\n                songs[i] = new TaskC.pair(in.nextInt(), in.nextInt());\n                sum += songs[i].a;\n            }\n            Arrays.sort(songs);\n\n            int res = 0;\n            int idx = n - 1;\n            while (sum > m) {\n                if (idx < 0) {\n                    break;\n                }\n                sum -= (songs[idx].a - songs[idx].b);\n\n                res++;\n                idx--;\n            }\n\n            if (sum > m) {\n                out.println(-1);\n            } else {\n                out.println(res);\n            }\n        }\n\n        static class pair implements Comparable<TaskC.pair> {\n            int a;\n            int b;\n\n            pair(int a, int b) {\n                this.a = a;\n                this.b = b;\n            }\n\n            public int compareTo(TaskC.pair p) {\n                return (this.a - this.b) - (p.a - p.b);\n            }\n\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "problem": "1015_C", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class E implements Runnable {\n\tpublic static void main (String[] args) {new Thread(null, new E(), \"_cf\", 1 << 28).start();}\n\n\tint n, m;\n\tchar[] str;\n\tint[][] occs, cost;\n\tint[] dp;\n\t\n\tpublic void run() {\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tSystem.err.println(\"\");\n\n\t\t//where's my 420??? :(\n\t\t\n\t\tn = fs.nextInt(); m = fs.nextInt();\n\t\tbyte[] str = fs.next().getBytes();\n\t\tint[] occs = new int[1<<m];\n\t\tfor(int i = 0; i < n-1; i++) {\n\t\t\tint l1 = str[i] - 'a';\n\t\t\tint l2 = str[i+1] - 'a';\n\t\t\toccs[(1<<l1) | (1<<l2)]++;\n\t\t\toccs[(1<<l2) | (1<<l1)]++;\n\t\t}\n\t\t//cost[mask][v] = numPairs with v for some all bits on in mask\n\t\tint all = (1<<m)-1;\n\t\tcost = new int[m][1<<m];\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tfor(int mask = 1; mask < all; mask++) {\n\t\t\t\tif(((1<<i)&mask) > 0) continue;\n\t\t\t\tint lb = mask & (-mask);\n\t\t\t\tint trail = Integer.numberOfTrailingZeros(lb);\n\t\t\t\tint nmask = mask ^ lb;\n\t\t\t\tcost[i][mask] = cost[i][nmask]+occs[1<<i | 1<<trail];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp = new int[1<<m];\n\t\tfor(int mask = dp.length-2; mask >= 0; mask--) {\n\t\t\tint addOn = 0;\n\t\t\tfor(int nxt = 0; nxt < m; nxt++) {\n\t\t\t\tif(((1<<nxt)&mask) > 0) continue;\n\t\t\t\taddOn += cost[nxt][mask];\n\t\t\t}\n\t\t\tint res = oo;\n\t\t\tfor(int nxt = 0; nxt < m; nxt++) {\n\t\t\t\tif(((1<<nxt)&mask) > 0) continue;\n\t\t\t\tint ret = addOn+dp[mask | (1<<nxt)];\n\t\t\t\tres = min(res, ret);\n\t\t\t}\n\t\t\tdp[mask] = res;\n\t\t}\n\t\t\n\t\tSystem.out.println(dp[0]>>1);\n\t\t\n\t\tout.close();\n\t}\n\t\n\tint oo = (int)1e9;\n\tint min(int a, int b) {\n\t\tif(a < b) return a;\n\t\treturn b;\n\t}\n\t\n\tclass FastScanner {\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\n\t\tpublic FastScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t\t}\n\t\t}\n\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}                \n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) res[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t}\n\n}", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;\nimport java.io.IOException;import java.io.PrintStream;import java.io.PrintWriter;\nimport java.security.AccessControlException;import java.util.Arrays;import java.util.Collection;\nimport java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Objects;\nimport java.util.Scanner;import java.util.TreeMap;import java.util.function.Function;\nimport java.util.stream.Collectors;import java.util.stream.IntStream;import java.util.stream.LongStream;\nimport java.util.stream.Stream;public class _p001073B {static public void main(final String[] args) \nthrows IOException{p001073B._main(args);}\nstatic private class p001073B extends Solver{public p001073B(){nameIn=\"in/1000/p001073B.in\";\nsingleTest=true;}@Override public void solve()throws IOException{int n=sc.nextInt();\nsc.nextLine();int[]positions=new int[n+1];for(int _if0=0;_if0<n;_if0++){int a=sc.nextInt();\npositions[a]=_if0+1;}sc.nextLine();int removed=0;for(int _if1=0;_if1<n;_if1++){int \nb=sc.nextInt();int pos=positions[b];if(pos>removed){pw.print((pos-removed)+\" \");\nremoved=pos;}else{pw.print(\"0 \");}}sc.nextLine();pw.println();}static public void \n_main(String[]args)throws IOException{new p001073B().run();}}static private class \nPair<K,V>{private K k;private V v;public Pair(final K t,final V u){this.k=t;this.v\n=u;}public K getKey(){return k;}public V getValue(){return v;}}static private abstract class \nSolver{protected String nameIn=null;protected String nameOut=null;protected boolean \nsingleTest=false;protected boolean preprocessDebug=false;protected boolean doNotPreprocess\n=false;protected PrintStream debugPrintStream=null;protected Scanner sc=null;protected \nPrintWriter pw=null;final static String SPACE=\" \";final static String SPACES=\"\\\\s+\";\nprivate void process()throws IOException{if(!singleTest){int t=lineToIntArray()[0];\nwhile(t-->0){solve();}}else{solve();}}abstract protected void solve()throws IOException;\nprotected String[]lineToArray()throws IOException{return sc.nextLine().trim().split(SPACES);\n}protected int[]lineToIntArray()throws IOException{return Arrays.stream(lineToArray()).mapToInt(Integer::valueOf).toArray();\n}protected long[]lineToLongArray()throws IOException{return Arrays.stream(lineToArray()).mapToLong(Long::valueOf).toArray();\n}protected void run()throws IOException{boolean done=false;try{if(nameIn!=null && \nnew File(nameIn).exists()){try(FileInputStream fis=new FileInputStream(nameIn);PrintWriter \npw0=select_output();){done=true;sc=new Scanner(fis);pw=pw0;process();}}}catch(IOException \nex){}catch(AccessControlException ex){}if(!done){try(PrintWriter pw0=select_output();\n){sc=new Scanner(System.in);pw=pw0;process();}}}private PrintWriter select_output()\nthrows FileNotFoundException{if(nameOut!=null){return new PrintWriter(nameOut);}\nreturn new PrintWriter(System.out);}public static Map<Integer,List<Integer>>mapi(final \nint[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<Integer,List<Integer>>(),\n(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static Map<Long,List<Integer>>\nmapi(final long[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<Long,\nList<Integer>>(),(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final T[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<T,List<Integer>>(),\n(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final T[]a,Comparator<T>cmp){return IntStream.range(0,a.length).collect(()->\nnew TreeMap<T,List<Integer>>(cmp),(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],\nStream.of(i).collect(Collectors.toList()));}else{res.get(a[i]).add(i);}},Map::putAll\n);}public static Map<Integer,List<Integer>>mapi(final IntStream a){int[]i=new int[]{0};\nreturn a.collect(()->new TreeMap<Integer,List<Integer>>(),(res,v)->{if(!res.containsKey(v))\n{res.put(v,Stream.of(i[0]).collect(Collectors.toList()));}else{res.get(v).add(i[0]);\n}i[0]++;},Map::putAll);}public static Map<Long,List<Integer>>mapi(final LongStream \na){int[]i=new int[]{0};return a.collect(()->new TreeMap<Long,List<Integer>>(),(res,\nv)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}i[0]++;},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final Stream<T>a,Comparator<T>cmp){int[]i=new int[]{0};return a.collect(()->\nnew TreeMap<T,List<Integer>>(cmp),(res,v)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final Stream<T>a){int[]i=new int[]{0};return a.collect(()->new TreeMap<T,List<Integer>>(),\n(res,v)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}},Map::putAll);}public static List<int[]>listi(final \nint[]a){return IntStream.range(0,a.length).mapToObj(i->new int[]{a[i],i}).collect(Collectors.toList());\n}public static List<long[]>listi(final long[]a){return IntStream.range(0,a.length).mapToObj(i\n->new long[]{a[i],i}).collect(Collectors.toList());}public static<T>List<Pair<T,\nInteger>>listi(final T[]a){return IntStream.range(0,a.length).mapToObj(i->new Pair<T,\nInteger>(a[i],i)).collect(Collectors.toList());}public static List<int[]>listi(final \nIntStream a){int[]i=new int[]{0};return a.mapToObj(v->new int[]{v,i[0]++}).collect(Collectors.toList());\n}public static List<long[]>listi(final LongStream a){int[]i=new int[]{0};return \na.mapToObj(v->new long[]{v,i[0]++}).collect(Collectors.toList());}public static<T>\nList<Pair<T,Integer>>listi(final Stream<T>a){int[]i=new int[]{0};return a.map(v->\nnew Pair<T,Integer>(v,i[0]++)).collect(Collectors.toList());}public static String \njoin(final int[]a){return Arrays.stream(a).mapToObj(Integer::toString).collect(Collectors.joining(SPACE));\n}public static String join(final long[]a){return Arrays.stream(a).mapToObj(Long::toString).collect(Collectors.joining(SPACE));\n}public static<T>String join(final T[]a){return Arrays.stream(a).map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final T[]a,final Function<T,String>toString){return \nArrays.stream(a).map(v->toString.apply(v)).collect(Collectors.joining(SPACE));}public \nstatic<T>String join(final Collection<T>a){return a.stream().map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Collection<T>a,final Function<T,String>toString)\n{return a.stream().map(v->toString.apply(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Stream<T>a){return a.map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Stream<T>a,final Function<T,String>toString){\nreturn a.map(v->toString.apply(v)).collect(Collectors.joining(SPACE));}public static\n<T>String join(final IntStream a){return a.mapToObj(Integer::toString).collect(Collectors.joining(SPACE));\n}public static<T>String join(final LongStream a){return a.mapToObj(Long::toString).collect(Collectors.joining(SPACE));\n}public static List<Integer>list(final int[]a){return Arrays.stream(a).mapToObj(Integer::valueOf).collect(Collectors.toList());\n}public static List<Integer>list(final IntStream a){return a.mapToObj(Integer::valueOf).collect(Collectors.toList());\n}public static List<Long>list(final long[]a){return Arrays.stream(a).mapToObj(Long::valueOf).collect(Collectors.toList());\n}public static List<Long>list(final LongStream a){return a.mapToObj(Long::valueOf).collect(Collectors.toList());\n}public static<T>List<T>list(final Stream<T>a){return a.collect(Collectors.toList());\n}public static<T>List<T>list(final T[]a){return Arrays.stream(a).collect(Collectors.toList());\n}}}\n", "complexity": "linear", "problem": "1073_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FElongatedMatrix solver = new FElongatedMatrix();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FElongatedMatrix {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            int[][] mat = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    mat[i][j] = in.readInt();\n                }\n            }\n\n            int[][] minDist = new int[n][n];\n            SequenceUtils.deepFill(minDist, (int) 1e9);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int k = 0; k < m; k++) {\n                        minDist[i][j] = Math.min(minDist[i][j], Math.abs(mat[i][k] - mat[j][k]));\n                    }\n                }\n            }\n            int[][] minDistBetweenHeadAndTail = new int[n][n];\n            SequenceUtils.deepFill(minDistBetweenHeadAndTail, (int) 1e9);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int k = 1; k < m; k++) {\n                        minDistBetweenHeadAndTail[i][j] = Math.min(minDistBetweenHeadAndTail[i][j], Math.abs(mat[i][k] - mat[j][k - 1]));\n                    }\n                }\n            }\n\n            Log2 log2 = new Log2();\n            BitOperator bo = new BitOperator();\n            int[][][] dp = new int[1 << n][n][n];\n            for (int i = 1; i < (1 << n); i++) {\n                if (i == Integer.lowestOneBit(i)) {\n                    dp[i][log2.floorLog(i)][log2.floorLog(i)] = (int) 1e9;\n                    continue;\n                }\n                for (int j = 0; j < n; j++) {\n                    for (int k = 0; k < n; k++) {\n                        if (bo.bitAt(i, j) == 0) {\n                            continue;\n                        }\n                        for (int t = 0; t < n; t++) {\n                            dp[i][j][k] = Math.max(dp[i][j][k],\n                                    Math.min(dp[bo.setBit(i, j, false)][t][k],\n                                            minDist[j][t]));\n                        }\n                    }\n                }\n            }\n\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    ans = Math.max(ans, Math.min(dp[(1 << n) - 1][i][j], minDistBetweenHeadAndTail[j][i]));\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n    }\n\n    static class Log2 {\n        public int floorLog(int x) {\n            return 31 - Integer.numberOfLeadingZeros(x);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class BitOperator {\n        public int bitAt(int x, int i) {\n            return (x >> i) & 1;\n        }\n\n        public int setBit(int x, int i, boolean v) {\n            if (v) {\n                x |= 1 << i;\n            } else {\n                x &= ~(1 << i);\n            }\n            return x;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "//package;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Vector;\nimport java.lang.*;\nimport java.io.*;\nimport java.awt.Point;\n\npublic class evenness {\n\t\n\tpublic static void main(String[] args){\n\t\n    try{\n\t\n      BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n      int i, n, temp=1;\n      String str = \"\";\n      int[] arr;\n      int r;\n      \n      while (temp!= '\\n'){\n\t\ttemp = System.in.read();\n\t\t//if (temp=='\\n')\n\t\t\t//break;\n\t\tstr = str.concat(Character.toString((char)temp));\n      }\n\t  str = str.replaceAll(\"[^0-9]\", \"\");\n      n = Integer.parseInt(str);\n      temp=1;\n      str=\"\";\n      \n      arr = new int[n];\n      \n      for (i=0;i<n;i++){\n\t\twhile (temp!=' ' && temp!=-1){\n\t\t\ttemp = System.in.read();\n\t\t\t//if (temp==' ' || temp==-1)\n\t\t\t\t//break;\n\t\t\tstr = str.concat(Character.toString((char)temp));\n\t\t}\n\t\tstr = str.replaceAll(\"[^0-9]\", \"\");\n\t\tarr[i] = Integer.parseInt(str);\n\t\tstr=\"\";\n\t\ttemp=1;\n      }\n      \n\t  r=(arr[2]%2);\n      if ((arr[0]%2)==(arr[1]%2)){\n\t\tr=(arr[0]%2);\n      }\n      \n      for (i=0;i<n;i++){\n\t\tif ((arr[i]%2)!=r){\n\t\t\tSystem.out.println(i+1);\n\t\t\tbreak;\n\t\t}\n      }\n      \n\t}catch (Exception e){\n\t\tSystem.out.println(\"OH NOES \" + e);\n\t}\n  }\n}", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class A {\n    public static void main(String[] args) throws FileNotFoundException {\n        Scanner s = new Scanner(System.in);\n        int T = s.nextInt();\n        System.out.println(\"0 0 \"+T);\n        /*if(T==0) {\n\n            return;\n        }\n        if(T==1) {\n            System.out.println(\"0 0 0\");\n            return;\n        }\n        System.out.println();*/\n    }\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputStreamReader in = new InputStreamReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputStreamReader inSt, PrintWriter out) {\n        InputReader in = new InputReader(inSt);\n        long a = in.nextLong();\n        long b = in.nextLong();\n\n        long result = 0;\n        while (b != 1) {\n            result += a / b;\n            long r = a % b;\n            long q = b;\n            long top = q % r;\n            long bottom = r;\n            result += q / r;\n            a = top;\n            b = bottom;\n        }\n        result += a;\n\n        out.println(result);\n    }\n\n    class InputReader {\n        public BufferedReader reader;\n        private String[] currentArray;\n        int curPointer;\n\n        public InputReader(InputStreamReader inputStreamReader) {\n            reader = new BufferedReader(inputStreamReader);\n        }\n\n        public String next() {\n            try {\n                currentArray = null;\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public void nextChars(char[] t) {\n            try {\n                currentArray = null;\n                reader.read(t);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public char nextChar() {\n            try {\n                currentArray = null;\n                return (char) reader.read();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            if ((currentArray == null) || (curPointer >= currentArray.length)) {\n                try {\n                    currentArray = reader.readLine().split(\" \");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                curPointer = 0;\n            }\n            return Integer.parseInt(currentArray[curPointer++]);\n        }\n\n        public long nextLong() {\n            if ((currentArray == null) || (curPointer >= currentArray.length)) {\n                try {\n                    currentArray = reader.readLine().split(\" \");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                curPointer = 0;\n            }\n            return Long.parseLong(currentArray[curPointer++]);\n        }\n\n    }\n}\n\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "/*Author: Satyajeet Singh, Delhi Technological University*/\n    import java.io.*;\n    import java.util.*;\n    import java.text.*; \n    import java.lang.*;\n    import java.math.*;\n \npublic class Main{\n/*********************************************Constants******************************************/\n    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));        \n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static long mod=(long)1e9+7;\n    static long mod1=998244353;\n    static boolean sieve[];\n    static ArrayList<Integer> primes;\n    static long factorial[],invFactorial[];\n    static HashSet<Pair> graph[];\n    static boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n/****************************************Solutions Begins***************************************/\n    public static void main (String[] args) throws Exception {\n        String st[]=nl();\n        int n=pi(st[0]);\n        int input[]=new int[n];\n        st=nl();\n        for(int i=0;i<n;i++){\n            input[i]=pi(st[i]);\n        }\n        int ans=0;\n        Arrays.sort(input);\n        boolean dp[]=new boolean[n];\n        for(int i=0;i<n;i++){\n            if(!dp[i]){\n                ans++;\n                for(int j=input[i];j<=200;j+=input[i]){\n                    for(int k=i;k<n;k++){\n                        if(input[k]==j&&!dp[k])dp[k]=true;\n                    }\n                }\n            }\n        }\n        out.println(ans);\n/****************************************Solutions Ends**************************************************/\n        out.flush();\n        out.close();\n    }\n/****************************************Template Begins************************************************/\n    static String[] nl() throws Exception{\n        return br.readLine().split(\" \");\n    }\n    static String[] nls() throws Exception{\n        return br.readLine().split(\"\");\n    }\n    static int pi(String str) {\n        return Integer.parseInt(str);\n    }\n    static long pl(String str){\n        return Long.parseLong(str);\n    }\n    static double pd(String str){\n        return Double.parseDouble(str);\n    }\n/***************************************Precision Printing**********************************************/\n    static void printPrecision(double d){\n        DecimalFormat ft = new DecimalFormat(\"0.000000000000000000000\"); \n        out.println(ft.format(d));\n    }\n/**************************************Bit Manipulation**************************************************/\n    static void printMask(long mask){\n        System.out.println(Long.toBinaryString(mask));\n    }\n    static int countBit(int mask){\n        int ans=0;\n        while(mask!=0){\n            if(mask%2==1){\n                ans++;\n            }\n            mask/=2;\n        }\n        return ans;\n    }\n/******************************************Graph*********************************************************/\n    static void Makegraph(int n){\n        graph=new HashSet[n];\n        for(int i=0;i<n;i++){\n            graph[i]=new HashSet<>();\n        }\n    }\n    static void addEdge(int a,int b){\n        graph[a].add(new Pair(b,1));\n    }\n    static void addEdge(int a,int b,int c){\n        graph[a].add(new Pair(b,c));\n    }    \n/*********************************************PAIR********************************************************/\n    static class PairComp implements Comparator<Pair>{\n        public int compare(Pair p1,Pair p2){\n            return p1.u-p2.u;\n        }\n    }\n    static class Pair implements Comparable<Pair> {\n        int u;\n        int v;\n        int index=-1;\n        public Pair(int u, int v) {\n            this.u = u;\n            this.v = v;\n        }\n        public int hashCode() {\n            int hu = (int) (u ^ (u >>> 32));\n            int hv = (int) (v ^ (v >>> 32));\n            return 31 * hu + hv;\n        }\n        public boolean equals(Object o) {\n            Pair other = (Pair) o;\n            return u == other.u && v == other.v;\n        }\n        public int compareTo(Pair other) {\n            if(index!=other.index)\n                return Long.compare(index, other.index);\n            return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);\n        }\n        public String toString() {\n            return \"[u=\" + u + \", v=\" + v + \"]\";\n        }\n    }\n/******************************************Long Pair*******************************************************/\n    static class PairCompL implements Comparator<Pairl>{\n        public int compare(Pairl p1,Pairl p2){\n            if(p1.u-p2.u<0){\n                return -1;\n            }\n            else if(p1.u-p2.u>0){\n                return 1;\n            }\n            else{\n                if(p1.v-p2.v<0){\n                    return -1;\n                }\n                else if(p1.v-p2.v>0){\n                    return 1;\n                }\n                else{\n                    return 0;\n                }\n            }\n        }\n    }\n    static class Pairl implements Comparable<Pairl> {\n            long u;\n            long v;\n            int index=-1;\n            public Pairl(long u, long v) {\n                this.u = u;\n                this.v = v;\n            }\n    \n            public int hashCode() {\n                int hu = (int) (u ^ (u >>> 32));\n                int hv = (int) (v ^ (v >>> 32));\n                return 31 * hu + hv;\n            }\n    \n            public boolean equals(Object o) {\n                Pairl other = (Pairl) o;\n                return u == other.u && v == other.v;\n            }\n    \n            public int compareTo(Pairl other) {\n                if(index!=other.index)\n                    return Long.compare(index, other.index);\n                return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);\n            }\n    \n            public String toString() {\n                return \"[u=\" + u + \", v=\" + v + \"]\";\n            }\n        }\n/*****************************************DEBUG***********************************************************/\n    public static void debug(Object... o) {\n        if(!oj)\n        System.out.println(Arrays.deepToString(o));\n    }\n/************************************MODULAR EXPONENTIATION***********************************************/\n    static long modulo(long a,long b,long c) {\n        long x=1;\n        long y=a;\n        while(b > 0){\n            if(b%2 == 1){\n                x=(x*y)%c;\n            }\n            y = (y*y)%c; // squaring the base\n            b /= 2;\n        }\n        return  x%c;\n    }\n/********************************************GCD**********************************************************/\n    static long gcd(long x, long y)\n    {\n        if(x==0)\n            return y;\n        if(y==0)\n            return x;\n        long r=0, a, b;\n        a = (x > y) ? x : y; // a is greater number\n        b = (x < y) ? x : y; // b is smaller number\n        r = b;\n        while(a % b != 0)\n        {\n            r = a % b;\n            a = b;\n            b = r;\n        }\n        return r;\n    }\n/******************************************SIEVE**********************************************************/\n    static void sieveMake(int n){\n        sieve=new boolean[n];\n        Arrays.fill(sieve,true);\n        sieve[0]=false;\n        sieve[1]=false;\n        for(int i=2;i*i<n;i++){\n            if(sieve[i]){\n                for(int j=i*i;j<n;j+=i){\n                    sieve[j]=false;\n                }\n            }\n        }\n        primes=new ArrayList<Integer>();\n        for(int i=0;i<n;i++){\n            if(sieve[i]){\n                primes.add(i);\n            }\n        }        \n    }\n/********************************************End***********************************************************/\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\n\n\npublic class A {\n\t\n\tpublic static double EPS = .001;\n\t\n\tpublic class House implements Comparable<House> {\n\t\tint x;\n\t\tint a;\n\t\t\n\t\tpublic House(int mx, int ma) {\n\t\t\tx = mx;\n\t\t\ta = ma;\n\t\t}\n\n\t\tpublic int compareTo(House o) {\n\t\t\treturn x - o.x;\n\t\t}\n\t\t\n\t\tpublic double right() {\n\t\t\treturn (double)x + ((double)a)/2.0;\n\t\t}\n\t\t\n\t\tpublic double left() {\n\t\t\treturn (double)x - ((double)a)/2.0;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew A().solve();\n\t}\n\t\n\t\n\tpublic void solve() {\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint t = in.nextInt();\n\t\t\n\t\tArrayList<House> houses = new ArrayList<House>();\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint x = in.nextInt();\n\t\t\tint a = in.nextInt();\n\t\t\thouses.add(new House(x,a));\n\t\t}\n\t\t\n\t\tCollections.sort(houses);\n\t\t\n\t\t\n\t\tint total = 2;\n\t\t\n\t\tfor(int i=0;i<houses.size()-1;i++) {\n\t\t\tHouse me = houses.get(i);\n\t\t\tHouse next = houses.get(i+1);\n\t\t\tdouble meright = me.right();\n\t\t\tdouble nextleft = next.left();\n\t\t\tdouble diff = nextleft - meright;\n\t\t\tif(diff-EPS > ((double)t)) {\n\t\t\t\ttotal += 2;\n\t\t\t}\n\t\t\telse if(diff+EPS > ((double)t)) {\n\t\t\t\ttotal += 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(total);\n\t}\n\t\n}\n ", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class C implements Runnable {\n\n    private static final boolean USE_FILE_IO = false;\n    private static final String FILE_IN = \"c.in\";\n    private static final String FILE_OUT = \"c.out\";\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n    public static void main(String[] args) {\n        new Thread(new C()).start();\n    }\n\n    int n, h, t;\n    char[] c;\n\n    private void solve() throws IOException {\n        n = nextInt();\n        c = nextToken().toCharArray();\n        if (c.length != n) {\n            throw new IllegalStateException();\n        }\n\n        for (char l : c)\n            if (l == 'H') {\n                h++;\n            }\n        t = n - h;\n\n        if (h == 0) {\n            out.print(0);\n            return;\n        }\n\n        int answer = Integer.MAX_VALUE;\n        for (int hLo = 0; hLo < n; hLo++)\n            if (c[hLo] == 'H') {\n                int hHi = (hLo + h) % n;\n\n                int current = 0;\n                int j = hLo;\n                while (j != hHi) {\n                    if (c[j] == 'T') {\n                        current++;\n                    }\n                    j = (j + 1) % n;\n                }\n\n                answer = Math.min(answer, current);\n            }\n\n        out.print(answer);\n    }\n\n    public void run() {\n        long timeStart = System.currentTimeMillis();\n        try {\n\n            if (USE_FILE_IO) {\n                in = new BufferedReader(new FileReader(FILE_IN));\n                out = new PrintWriter(new FileWriter(FILE_OUT));\n            } else {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(new OutputStreamWriter(System.out));\n            }\n\n            solve();\n\n            in.close();\n            out.close();\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n        long timeEnd = System.currentTimeMillis();\n        System.out.println(\"Time spent: \" + (timeEnd - timeStart) + \" ms\");\n    }\n\n    private String nextToken() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) {\n                return null;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private BigInteger nextBigInt() throws IOException {\n        return new BigInteger(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n}", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class D {\n\t\n\tpublic static class BIT {\n\t\tint[] dat;\n\t\t\n\t\tpublic BIT(int n){\n\t\t\tdat = new int[n + 1];\n\t\t}\n\t\t\n\t\tpublic void add(int k, int a){ // k : 0-indexed\n\t\t\tfor(int i = k + 1; i < dat.length; i += i & -i){\n\t\t\t\tdat[i] += a;\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int sum(int s, int t){ // [s, t)\n\t\t\tif(s > 0) return sum(0, t) - sum(0, s);\n\t\t\t\n\t\t\tint ret = 0;\n\t\t\tfor(int i = t; i > 0; i -= i & -i) {\n\t\t\t\tret += dat[i];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry (final Scanner sc = new Scanner(System.in)) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tint[] array = new int[N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tarray[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\t\n\t\t\tlong inv = 0;\n\t\t\tBIT bit = new BIT(N);\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tinv += bit.sum(array[i], N);\n\t\t\t\tbit.add(array[i], 1);\n\t\t\t}\n\t\t\t//System.out.println(inv);\n\t\t\t\n\t\t\tint mod2 = (int)(inv % 2);\n\t\t\tfinal int M = sc.nextInt();\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\n\t\t\t\tfinal long size = (r - l) + 1;\n\t\t\t\tif(size > 1){\n\t\t\t\t\t//System.out.println(size + \" \" + ((size * (size - 1) / 2)));\n\t\t\t\t\tif((size * (size - 1) / 2) % 2 == 1){\n\t\t\t\t\t\tmod2 = 1 - mod2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((mod2 == 0) ? \"even\" : \"odd\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() {\n\t\t\ttry {\n\t\t\t\twhile (!hasNext()) {\n\t\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t} catch (IOException e) { /* ignore */\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) { /* ignore */\n\t\t\t}\n\t\t}\n\t}\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class LookingForOrder {\n    private int[][] distance;\n    private int[] dp;\n    private int[] prev;\n\n    public static void main(String[] args) throws IOException {\n        new LookingForOrder().solve();\n    }\n\n    public void solve() throws IOException {\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(f.readLine());\n        int x = Integer.parseInt(tokenizer.nextToken());\n        int y = Integer.parseInt(tokenizer.nextToken());\n        int n = Integer.parseInt(f.readLine());\n        int[][] coords = new int[n + 1][2];\n        coords[0][0] = x;\n        coords[0][1] = y;\n        for (int i = 1; i <= n; i++) {\n            tokenizer = new StringTokenizer(f.readLine());\n            x = Integer.parseInt(tokenizer.nextToken());\n            y = Integer.parseInt(tokenizer.nextToken());\n            coords[i][0] = x;\n            coords[i][1] = y;\n        }\n\n        this.distance = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= n; j++) {\n                distance[i][j] += (coords[i][0] - coords[j][0]) * (coords[i][0] - coords[j][0]);\n                distance[i][j] += (coords[i][1] - coords[j][1]) * (coords[i][1] - coords[j][1]);\n            }\n        }\n\n        int lastSet = 1 << n;\n        this.prev = new int[lastSet];\n\n        this.dp = new int[lastSet];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        this.dp[0] = 0;\n       // this.getMinPath(lastSet);\n\n        for (int i = 1; i < lastSet; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) != 0 && this.dp[i ^ (1 << j)] + distance[0][j + 1] * 2 < this.dp[i]) {\n                    //System.out.println(Integer.toBinaryString(i) + \" \" + Integer.toBinaryString(j) + \" \" + this.dp[i ^ (1 << j)]);\n                    this.dp[i] = this.dp[i ^ (1 << j)] + distance[0][j + 1] * 2;\n                    this.prev[i] = i ^ (1 << j);\n                }\n            }\n            //System.out.println(this.dp[i]);\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) != 0) {\n                    for (int k = j + 1; k < n; k++) {\n                        if ((i & (1 << k)) != 0) {\n                           // System.out.println(i + \" \" + j + \" \" + (i ^ (1 << j) ^ (1 << k)));\n                            if (this.dp[i ^ (1 << j) ^ (1 << k)] + this.distance[0][j + 1] + this.distance[0][k + 1] + this.distance[j + 1][k + 1] < this.dp[i]) {\n                                this.dp[i] = this.dp[i ^ (1 << j) ^ (1 << k)] + this.distance[0][j + 1] + this.distance[0][k + 1] + this.distance[j + 1][k + 1];\n                                this.prev[i] = i ^ (1 << j) ^ (1 << k);\n                            }\n                        }\n                    }\n\n                    break;\n                }\n            }\n          //  System.out.println(this.dp[i]);\n        }\n\n        lastSet--;\n        PrintWriter out = new PrintWriter(System.out);\n        out.println(dp[lastSet]);\n        ArrayDeque<Integer> stack = new ArrayDeque<Integer>();\n        boolean started = false;\n        while (lastSet != 0) {\n            // System.out.println(lastSet);\n            stack.addFirst(0);\n            int diff = lastSet - prev[lastSet];\n            //System.out.println(diff);\n            for (int i = 1, j = 1; j <= n; j++, i *= 2) {\n                if ((diff & i) != 0) {\n                    stack.addFirst(j);\n                }\n            }\n\n            lastSet = this.prev[lastSet];\n        }\n        stack.addFirst(0);\n\n        while (!stack.isEmpty()) {\n            if (!started) {\n                out.print(stack.pop());\n                started = true;\n            } else {\n                out.print(\" \");\n                out.print(stack.pop());\n            }\n        }\n\n        out.println();\n        out.close();\n    }\n\n    /*\n    private int getMinPath(int set) {\n        if (this.dp[set] != Integer.MAX_VALUE) {\n            return this.dp[set];\n        }\n\n        for (int i = 1, j = 1; i < this.dp.length; i *= 2, j++) {\n            if ((set & i) == i) {\n                int subPath;\n                int possibleMin = getMinPath(set & (set - i)) + (this.distance[0][j] * 2);\n                if (possibleMin < this.dp[set]) {\n                    this.dp[set] = possibleMin;\n                    this.prev[set] = set - i;\n                }\n            }\n        }\n        for (int i0 = 1, j0 = 1; i0 < this.dp.length; i0 *= 2, j0++) {\n            if ((set & i0) == i0) {\n                for (int i1 = i0 * 2, j1 = j0 + 1; i1 < this.dp.length; i1 *= 2, j1++) {\n                    if ((set & i1) == i1) {\n                        //System.out.println(set + \" \" + (set & (set - i0 - i1)));\n                        int possibleMin = getMinPath(set & (set - i0 - i1)) + this.distance[0][j0] + this.distance[0][j1] + this.distance[j0][j1];\n                        if (possibleMin < this.dp[set]) {\n                            this.dp[set] = possibleMin;\n                            this.prev[set] = set - i0 - i1;\n                        }\n                    }\n                }\n                break;\n            }\n        }\n\n        // System.out.println(this.dp[set] + \" \" + Integer.toBinaryString(set));\n        return this.dp[set];\n    } */\n}", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class CC {\n\tpublic static void main(String[] args)throws Throwable {\n\t\tMyScanner sc=new MyScanner();\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\t\n\t\tn=sc.nextInt();\n\t\ts=new char [n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\ts[i]=sc.next().charAt(0);\n\t\tmem=new int [2*n+1][n+1];\n\t\tfor(int [] x : mem)\n\t\t\tArrays.fill(x, -1);\n\t\tpw.println(dp(0, 0));\n\t\t\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\tstatic int n;\n\tstatic char [] s;\n\tstatic int [][] mem;\n\t\n\tstatic int dp(int i,int j){\n\t\tif(i==n)\n\t\t\treturn j==0? 1 : 0;\n\t\tif(mem[i][j]!=-1)\n\t\t\treturn mem[i][j];\n\t\tint ans=0;\n\t\tif(s[i]=='f'){\n\t\t\tans+=dp(i+1, j+1);\n\t\t\tans%=mod;\n\t\t}else{\n\t\t\tans+=dp(i+1, j);\n\t\t\tans%=mod;\n\t\t\tif(j>0){\n\t\t\t\tans+=dp(i, j-1);\n\t\t\t\tans%=mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mem[i][j]=ans;\n\t}\n\t\n\tstatic int mod=(int)(1e9+7);\n\n\tstatic class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {while (st == null || !st.hasMoreElements()) {\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (IOException e) {e.printStackTrace();}}\n\t\treturn st.nextToken();}\n\t\tint nextInt() {return Integer.parseInt(next());}\n\t\tlong nextLong() {return Long.parseLong(next());}\n\t\tdouble nextDouble() {return Double.parseDouble(next());}\n\t\tString nextLine(){String str = \"\";\n\t\ttry {str = br.readLine();}\n\t\tcatch (IOException e) {e.printStackTrace();}\n\t\treturn str;}\n\t}\n}", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Ishu\n{\n    static Scanner scan = new Scanner(System.in);\n    static void tc()\n    {\n    int n = scan.nextInt();\n    int i;\n    boolean zero = false;\n    boolean neg = false;\n    boolean pos = false;\n    \n    int min = Integer.MAX_VALUE;\n    int max = Integer.MIN_VALUE;\n    long sum = 0l;\n    for(i=0;i<n;++i)\n        {\n        int a = scan.nextInt();\n        min = Math.min(a, min);\n        max = Math.max(a, max);\n        sum += Math.abs(a);\n        if(a == 0)\n            zero = true;\n        if(a > 0)\n            pos = true;\n        if(a < 0)\n            neg = true;\n        }\n    if(n == 1)\n        {\n        System.out.println(max);\n        return ;\n        }\n    if(zero)\n        System.out.println(sum);\n    else\n        {\n        if(neg && pos)\n            System.out.println(sum);\n        else if(!neg && pos)\n            System.out.println((sum - 2L * min));\n        else if(!pos && neg)\n            {\n            max = max * (-1);\n            System.out.println((sum - 2L * max));\n            }\n        }\n    }\n    public static void main(String[] args)\n    {\n    int t = 1;\n    //t = scan.nextInt();\n    while(t-- > 0)\n        tc();\n    }\n}\n", "complexity": "linear", "problem": "1038_D", "from": "CODEFORCES", "tags": "dp,greedy,implementation"}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n\npublic class Codeforces {\n            \n    public static void main(String[] args) throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        final double eps = 1e-7;\n        String toks[] = in.readLine().split(\" \");\n        int n = Integer.parseInt(toks[0]);\n        double r = Double.parseDouble(toks[1]);\n        double x[] = new double[n];\n        toks = in.readLine().split(\" \");\n        for (int i = 0; i < n; i++) {\n            x[i] = Double.parseDouble(toks[i]);\n        }\n        double lo, hi, mid;\n        double y[] = new double[n];\n        y[0] = r;\n        for (int i = 1; i < n; i++) {\n            y[i] = r;\n            for(int j=0; j<i; j++) {\n                lo = y[j]; hi = 2000*2000;\n                while( Math.abs(hi-lo) >= eps ) {\n                    mid = (hi+lo)/2;\n                    if( Math.sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[j]-mid)*(y[j]-mid) ) + eps > 2*r ) {\n                        hi = mid;\n                    } else {\n                        lo = mid;\n                    }\n                }\n                if(Math.sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[j]-lo)*(y[j]-lo) ) < 2*r + eps) {\n                    y[i] = Math.max(y[i], lo);\n                }\n            }\n        }\n        for (double z : y) {\n            System.out.printf(Locale.US, \"%.7f \", z);\n        }\n    }\n}\n\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1177b {\n\n    public static void main(String[] args) throws IOException {\n        long k = rl(), n = -1;\n        for (long l = 0, r = k; l <= r; ) {\n            long m = l + (r - l) / 2;\n            if (f(m) < k) {\n                n = m + 1;\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n        k -= f(n - 1);\n        char[] s = Long.toString(n).toCharArray();\n        prln(s[(int) k - 1]);\n        close();\n    }\n\n    static long f(long x) {\n        if (x < 10) {\n            return x;\n        }\n        long pow10 = 1, cnt = 1;\n        while (x >= pow10 * 10) {\n            pow10 *= 10;\n            ++cnt;\n        }\n        return cnt * (x - pow10 + 1) + f(pow10 - 1);\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // graph util\n    static List<List<Integer>> g(int n) {List<List<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new ArrayList<>()); return g;}\n    static List<Set<Integer>> sg(int n) {List<Set<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new HashSet<>()); return g;}\n    static void c(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v); g.get(v).add(u);}\n    static void cto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v);}\n    static void dc(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v); g.get(v).remove(u);}\n    static void dcto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    static List<List<Integer>> rg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<List<Integer>> rdg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rdsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(\"yes\");}\n    static void pry() {prln(\"Yes\");}\n    static void prY() {prln(\"YES\");}\n    static void prno() {prln(\"no\");}\n    static void prn() {prln(\"No\");}\n    static void prN() {prln(\"NO\");}\n    static void pryesno(boolean b) {prln(b ? \"yes\" : \"no\");};\n    static void pryn(boolean b) {prln(b ? \"Yes\" : \"No\");}\n    static void prYN(boolean b) {prln(b ? \"YES\" : \"NO\");}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(\"hlfd\"); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}}", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.io.*;\nimport java.util.*;\n\n/**\n * Problem CF287B\n */\n@SuppressWarnings(\"unchecked\")\npublic class CF287B {\n\n    static class Task extends IOHandler {\n        public void run() {\n            long n = in.nextLong();\n            long k = in.nextLong();\n            if(n==1){\n                out.println(0);\n            } else if (n<=k){\n                out.println(1);\n            } else if(n>f(k)) {\n                out.println(-1);\n            } else {\n                long l = 1;\n                long r = k;\n                long m = 0;\n                long a = 0;\n                while(l<=r){\n                    m = (l+r)/2;\n                    long p = f(k)-f(k-m) + 1;\n                    if(p>n){\n                        r = m-1;\n                    } else {\n                        l = m+1;\n                        a = m + (p==n?0:1);\n                    }\n                }\n                out.println(a);\n            }\n        }\n\n        private long f(long k) {\n            if(k<=0) return 0;\n            return (k*(k+1))/2 - k +1;\n        }\n        \n    }\n\n    /***********************************************************\n     *                        COMMONS                          *\n     ***********************************************************/\n    static class Pair<A, B> implements Comparable<Pair<A, B>> {\n        public A a;\n        public B b;\n        public Pair(Pair<A, B> p) {\n            this(p.a, p.b);\n        }\n\n        public Pair(A a, B b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        public String toString() {\n            return a+\" \"+b;\n        }\n\n        public int hashCode() {\n            return Objects.hash(a, b);\n        }\n\n        public boolean equals(Object o) {\n            if(o instanceof Pair) {\n                Pair<A,B> p = (Pair<A,B>) o;\n                return a.equals(p.a)&&b.equals(p.b);\n            }\n            return false;\n        }\n\n        @Override\n        public int compareTo(Pair<A, B> p) {\n            int cmp = ((Comparable<A>) a).compareTo(p.a);\n            if(cmp==0) {\n                return ((Comparable<B>) b).compareTo(p.b);\n            }\n            return cmp;\n        }\n    }\n\n    /***********************************************************\n     *                      BOILERPLATE                        *\n     ***********************************************************/\n    public static void main(String[] args) {\n        Task task = new Task();\n        task.run();\n        task.cleanup();\n    }\n\n    static class IOHandler  {\n        public InputReader in = new InputReader(System.in);\n        public OutputWriter out = new OutputWriter(System.out);\n\n        public void cleanup() {\n            out.close();\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        private boolean prime() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    String line = reader.readLine();\n                    if(line==null) return false; // EOF\n                    tokenizer = new StringTokenizer(line);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return true;\n        }\n        \n        public boolean hasNext() {\n            return prime();\n        }\n\n        public String next() {\n            prime();\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream out) {\n            super(out);\n        }\n\n        public void println(String format, Object... args) {\n            this.println(String.format(format, args));\n        }\n\n        public void print(String format, Object... args) {\n            this.print(String.format(format, args));\n        }\n    }\n\n}\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.*;\n\npublic class B {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tReader scan = new Reader();\n\t\tint t = scan.nextInt();\n\t\tfor(int tt = 0;tt<t;tt++) {\n\t\t\t\n\t\t\tint n = scan.nextInt();\n\t\t\tint arr[] = new int[n];\n\t\t\tfor(int i = 0;i<n;i++) arr[i] = scan.nextInt();\n\t\t\t\n\t\t\tList<Integer> list = new ArrayList<>();\n\t\t\tint j = -1;\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\tfor(int i = 0;i<n;i++) {\n\t\t\t\tif(list.isEmpty() || arr[i]==1) { //add\n\t\t\t\t\tlist.add(arr[i]);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(arr[i] == list.get(j)+1) { //replace\n\t\t\t\t\tlist.set(j, arr[i]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int k = j;k>=0;k--) {\n\t\t\t\t\t\tif(arr[i] == list.get(k)+1) {//replace\n\t\t\t\t\t\t\tlist.set(k, arr[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {//delete\n\t\t\t\t\t\t\tlist.remove(k);\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.delete(0, s.length());\n\t\t\t\tfor(Integer p:list) {\n\t\t\t\t\ts.append(p+\".\");\n\t\t\t\t}\n\t\t\t\ts.deleteCharAt(s.length()-1);\n\t\t\t\tSystem.out.println(s.toString());\n\t\t\t}\n\t\t}\n\n\t\tscan.close();\n\t\t\n\t}\n\t\n\tstatic class Reader \n\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\n\t\tpublic Reader(String file_name) throws IOException \n\t\t{ \n\t\t\tdin = new DataInputStream(new FileInputStream(file_name)); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\n\t\tpublic String readLine() throws IOException \n\t\t{ \n\t\t\tbyte[] buf = new byte[64]; // line length \n\t\t\tint cnt = 0, c; \n\t\t\twhile ((c = read()) != -1) \n\t\t\t{ \n\t\t\t\tif (c == '\\n') \n\t\t\t\t\tbreak; \n\t\t\t\tbuf[cnt++] = (byte) c; \n\t\t\t} \n\t\t\treturn new String(buf, 0, cnt); \n\t\t} \n\n\t\tpublic int nextInt() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t}  while ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic long nextLong() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic double nextDouble() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n\n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n\n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n\t\t} \n\t}\n\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class MaxMex {\n    \n    int N = (int) 2e5 + 10;\n    int LOG = 20;\n    \n    int n;\n    int[] val = new int[N], par = new int[N], deg = new int[N];\n    int[][] chd = new int[N][];\n    int[] val_to_nid = new int[N];\n    \n    int timer = 0;\n    int[] tin = new int[N], tout = new int[N];\n    int[][] anc = new int[N][LOG];\n    \n    Node[] tree = new Node[N * 4];\n    \n    int ans;\n    Node prev;\n    \n    void solve() {\n        n = in.nextInt();\n        for (int i = 0; i < n; i++) val[i] = in.nextInt();\n        par[0] = -1;\n        for (int i = 1; i < n; i++) {\n            par[i] = in.nextInt() - 1;\n            deg[par[i]]++;\n        }\n        for (int i = 0; i < n; i++) chd[i] = new int[deg[i]];\n        for (int i = 1; i < n; i++) chd[par[i]][--deg[par[i]]] = i;\n        for (int i = 0; i < n; i++) val_to_nid[val[i]] = i;\n        \n        dfs(0, 0);\n        \n        build_tree(0, 0, n);\n        \n        int Q = in.nextInt();\n        while (Q-- > 0) {\n            int type = in.nextInt();\n            if (type == 1) {\n                // swap the values and do point updates in the segment tree\n                int i = in.nextInt() - 1, j = in.nextInt() - 1;\n                if (i == j) continue;\n                swap(i, j);\n                update(0, 0, n, val[i]);\n                update(0, 0, n, val[j]);\n            } else {\n                // query the segment tree to find the MEX\n                ans = 1;\n                prev = new Node(val_to_nid[0], val_to_nid[0], val_to_nid[0]);\n                find_mex(0, 0, n);\n                out.println(ans);\n            }\n        }\n    }\n    \n    void swap(int i, int j) {\n        int tmp = val[i];\n        val[i] = val[j];\n        val[j] = tmp;\n        val_to_nid[val[i]] = i;\n        val_to_nid[val[j]] = j;\n    }\n    \n    void find_mex(int k, int l, int r) {\n        Node res = merge(prev, tree[k]);\n        if (!res.bad()) {\n            ans = r;\n            prev = res;\n            return;\n        }\n        \n        if (r - l > 1) {\n            int m = (l + r) >> 1;\n            find_mex(2 * k + 1, l, m);\n            if (ans == m) {\n                find_mex(2 * k + 2, m, r);\n            }\n        }\n    }\n    \n    void update(int k, int l, int r, int i) {\n        if (r - l == 1) {\n            tree[k].g = tree[k].a = tree[k].b = val_to_nid[i];\n            return;\n        }\n        \n        int m = (l + r) >> 1;\n        if (i < m) update(2 * k + 1, l, m, i);\n        else update(2 * k + 2, m, r, i);\n        tree[k] = merge(tree[2 * k + 1], tree[2 * k + 2]);\n    }\n    \n    void build_tree(int k, int l, int r) {\n        if (r - l == 1) {\n            tree[k] = new Node(val_to_nid[l], val_to_nid[l], val_to_nid[l]);\n            return;\n        }\n        \n        int m = (l + r) >> 1;\n        build_tree(2 * k + 1, l, m);\n        build_tree(2 * k + 2, m, r);\n        tree[k] = merge(tree[2 * k + 1], tree[2 * k + 2]);\n    }\n    \n    Node merge(Node u, Node v) {\n        if (u.bad() || v.bad()) {\n            return new Node(-1, -1, -1);\n        }\n        Node res = new Node(u.a, u.b, u.g);\n        res.add(v.a);\n        res.add(v.b);\n        return res;\n    }\n    \n    int lca(int u, int v) {\n        if (ancestor(u, v)) return u;\n        if (ancestor(v, u)) return v;\n        for (int i = LOG - 1; i >= 0; i--) {\n            if (!ancestor(anc[u][i], v)) u = anc[u][i];\n        }\n        return anc[u][0];\n    }\n    \n    boolean ancestor(int u, int v) {\n        return tin[u] <= tin[v] && tout[v] <= tout[u];\n    }\n    \n    void dfs(int u, int p) {\n        tin[u] = timer++;\n        anc[u][0] = p;\n        for (int i = 1; i < LOG; i++) anc[u][i] = anc[anc[u][i - 1]][i - 1];\n        for (int v : chd[u]) {\n            dfs(v, u);\n        }\n        tout[u] = timer++;\n    }\n    \n    boolean is_vertical(int a, int b, int c) {\n        return ancestor(a, b) && ancestor(b, c);\n    }\n    \n    class Node {\n        int a, b;\n        int g;\n        \n        Node(int a, int b, int g) {\n            this.a = a;\n            this.b = b;\n            this.g = g;\n        }\n        \n        boolean bad() {\n            return a < 0 || b < 0;\n        }\n        \n        void markBad() {\n            a = b = -1;\n        }\n        \n        void add(int x) {\n            if (bad()) return;\n            if (a == b) {\n                b = x;\n                g = lca(a, b);\n                if (a == g) {\n                    int tmp = a; a = b; b = tmp;\n                }\n            } else {\n                if (ancestor(a, x)) {\n                    a = x;\n                    return;\n                }\n                if (b == g) {\n                    if (is_vertical(b, x, a)) {\n                        return;\n                    }\n                    if (is_vertical(x, b, a)) {\n                        g = b = x;\n                        return;\n                    }\n                    g = lca(a, x);\n                    if (ancestor(g, b)) {\n                        b = x;\n                        return;\n                    }\n                    markBad();\n                    return;\n                }\n                if (ancestor(b, x)) {\n                    b = x;\n                    return;\n                }\n                if (is_vertical(g, x, a) || is_vertical(g, x, b)) {\n                    return;\n                }\n                markBad();\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new MaxMex().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "1084_F", "from": "CODEFORCES", "tags": "data structures,trees"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigDecimal;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author phantom11\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int N = in.nextInt();\n            int r = in.nextInt();\n            int i, j;\n            BigDecimal initial = new BigDecimal(10);\n            initial = initial.pow(100);\n            int x[] = new int[N];\n            BigDecimal y[] = new BigDecimal[N];\n            Arrays.fill(y, initial);\n            for (i = 0; i < N; i++) {\n                x[i] = in.nextInt();\n            }\n            for (i = 0; i < N; i++) {\n                BigDecimal y2 = new BigDecimal(r);\n                for (j = 0; j < i; j++) {\n                    if (Math.abs(x[i] - x[j]) <= 2 * r) {\n                        double xDiff = x[i] - x[j];\n                        xDiff *= xDiff;\n                        xDiff = 4 * r * r - xDiff;\n                        xDiff = Math.sqrt(xDiff);\n                        BigDecimal yNew = new BigDecimal(xDiff);\n                        yNew = yNew.add(y[j]);\n                        if (yNew.compareTo(y2) > 0) {\n                            y2 = yNew;\n                        }\n                    }\n                }\n                y[i] = y2;\n            }\n            for (i = 0; i < N; i++) {\n                out.print(y[i] + \" \");\n            }\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tokenizer = null;\n\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(in.readLine());\n                }\n                return tokenizer.nextToken();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.util.*;\npublic class Main {\n\n    public static void main(String args[]) {\n        Scanner scan = new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        int[] game=new int[n];\n        int[] bill=new int[m];\n        for (int i = 0; i <n ; i++) {\n            game[i]=scan.nextInt();\n        }\n        for (int i = 0; i <m ; i++) {\n            bill[i]=scan.nextInt();\n        }\n        int i=0;\n        int j=0;\n        int ans=0;\n        while (i<m){\n            boolean f=true;\n            for (int k = j; k <n ; k++) {\n                if (bill[i]>=game[k]){\n                    ans++;\n                    i++;\n                    j=k+1;\n                    f=false;\n                    break;\n                }\n            }\n            if (f){\n                break;\n            }\n        }\n        System.out.println(ans);\n    }\n}\n\n\n", "complexity": "linear", "problem": "1009_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new  Solution();\n        solution.solve();\n    }\n\n    private void solve() {\n        Scanner in = new Scanner(System.in);\n        int t = in.nextInt();\n        while (t -- > 0) {\n            long n = in.nextLong();\n            long k = in.nextLong();\n\n            System.out.println(solve(n, k));\n        }\n    }\n\n    private String solve(long n, long k) {\n        if (n > 31) return \"YES \" + (n - 1);\n        if (k > f(n)) return \"NO\";\n\n        long square = 1;\n        long splitDone = 0;\n        long size = n;\n        long splitLeft = 0;\n        \n        while (splitDone + square <= k && size > 0) {\n            splitDone += square;\n            --size;\n            splitLeft += (square * 2 - 1) * f(size);\n            square = square * 2 + 1;\n        }\n//        System.out.println(square + \" \" + splitDone + \" \" + size + \" \" + splitLeft);\n        if (k > splitDone + splitLeft) return \"NO\";\n        else return \"YES \" + size;\n    }\n\n    private long f(long x) {\n        return ((1L << (2 * x)) - 1) / 3;\n    }\n}\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P701A {\n\n  Map<Character, Integer> cc = new HashMap(72);\n\n  void add(char c) {\n    cc.put(c, cc.getOrDefault(c, 0) + 1);\n  }\n\n  void rem(char c) {\n    Integer cnt = cc.get(c) - 1;\n    if (cnt != 0) {\n      cc.put(c, cnt);\n    } else {\n      cc.remove(c);\n    }\n  }\n\n  public void run() throws Exception {\n    int n = nextInt();\n\n    char [] s = next().toCharArray();\n    BitSet bs = new BitSet();\n    for (char c : s) {\n      bs.set(c);\n    }\n\n    int t = bs.cardinality();\n    \n    int m = Integer.MAX_VALUE;\n    for (int i = 0, j = 0; i < n; i++) {\n      while ((j < n) && (cc.size() < t)) {\n        add(s[j]);\n        j++;\n      }\n      \n      if (cc.size() == t) {\n        m = Math.min(m, j - i);\n      }\n      \n      rem(s[i]);\n    }\n    \n    println(m);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P701A().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n}", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.util.*;\nimport java.math.*;\nimport static java.lang.Character.isDigit;\nimport static java.lang.Character.isLowerCase;\nimport static java.lang.Character.isUpperCase;\nimport static java.lang.Math.*;\nimport static java.math.BigInteger.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Character.isDigit;\n\npublic class Main{\n    public static void main(String[] args) {\n        new Main().run();\n    }\n    Scanner sc=new Scanner(System.in);\n    void run() {\n        int n=sc.nextInt();\n        char[] cs=sc.next().toCharArray();\n        int h=0;\n        for(int i=0;i<n;i++)if(cs[i]=='H')h++;\n        int res=n;\n        for(int i=0;i<n;i++) {\n            int val=0;\n            for(int j=0;j<h;j++)if(cs[(i+j)%n]=='T')val++;\n            res=min(res,val);\n        }\n        System.out.println(res);\n    }\n}\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.util.Scanner;\n\npublic class d {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tint size = in.nextInt();\n\t\t\n\t\tint[] vals = new int[size];\n\t\tlong[] cum = new long[size];\n\t\tfor(int i=0; i<size; i++){\n\t\t\tvals[i] = in.nextInt();\n\t\t\t\n\t\t\tint c = 0;\n\t\t\tfor(int j=0; j<i; j++)\n\t\t\t\tif(vals[j] > vals[i]) c++;\n\t\t\t\n\t\t\tif(i != 0) cum[i] = cum[i-1]+c;\n\t\t\telse cum[i] = c;\n\t\t}\n\t\t\n\t\tlong tot = cum[size-1];\n\t\tint q = in.nextInt();\n\n\t\tint[] nv = new int[size];\n\t\tfor(int i=0; i<q; i++)\n\t\t{\n\t\t\tint l = in.nextInt()-1;\n\t\t\tint r = in.nextInt()-1;\n\t\t\tint n = (r-l);\n\t\t\t\n\t\t\tlong add = (n*(n+1))/2 - (cum[r] - cum[l]);\n\t\t\ttot = tot - (cum[r] - cum[l]) + add;\n\t\t\t\n\t\t\tif(tot%2 == 0)\n\t\t\t\tSystem.out.println(\"even\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"odd\");\n\t\t\t\n//\t\t\tfor(int j=0; j<=r-l; j++)\n//\t\t\t\tnv[l+j] = vals[r-j];\n//\t\t\t\n//\t\t\tfor(int j=0; j<=r-l; j++)\n//\t\t\t\tvals[l+j] = nv[l+j];\n\t\t\t\n\t\t}\n\t}\n}\n/*\n3\n1 2 3\n2\n1 2\n2 3\n\n4\n1 2 4 3\n4\n1 1\n1 4\n1 4\n2 3\n\n*/\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.*;\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tJS in = new JS();\n\t\tint n = in.nextInt();\n\t\tint m1 = 0;\n\t\tint s1 = 0;\n\t\tint l1 = 0;\n\t\tint ss1 = 0;\n\t\tint sss1 = 0;\n\t\tint ssss1 = 0;\n\t\tint ll1 = 0;\n\t\tint lll1 = 0;\n\t\tint llll1 = 0;\n\t\t\n\t\tint m2 = 0;\n\t\tint s2 = 0;\n\t\tint l2 = 0;\n\t\tint ss2 = 0;\n\t\tint sss2 = 0;\n\t\tint ssss2 = 0;\n\t\tint ll2 = 0;\n\t\tint lll2 = 0;\n\t\tint llll2 = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString s = in.next();\n\t\t\tif(s.equals(\"S\")) s1++;\n\t\t\telse if(s.equals(\"M\"))m1++;\n\t\t\telse if(s.equals(\"L\"))l1++;\n\t\t\telse if(s.equals(\"XS\")) ss1++;\n\t\t\telse if(s.equals(\"XXS\")) sss1++;\n\t\t\telse if(s.equals(\"XXXS\")) ssss1++;\n\t\t\telse if(s.equals(\"XL\")) ll1++;\n\t\t\telse if(s.equals(\"XXL\")) lll1++;\n\t\t\telse if(s.equals(\"XXXL\")) llll1++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString s = in.next();\n\t\t\tif(s.equals(\"S\")) s2++;\n\t\t\telse if(s.equals(\"M\"))m2++;\n\t\t\telse if(s.equals(\"L\"))l2++;\n\t\t\telse if(s.equals(\"XS\")) ss2++;\n\t\t\telse if(s.equals(\"XXS\")) sss2++;\n\t\t\telse if(s.equals(\"XXXS\")) ssss2++;\n\t\t\telse if(s.equals(\"XL\")) ll2++;\n\t\t\telse if(s.equals(\"XXL\")) lll2++;\n\t\t\telse if(s.equals(\"XXXL\")) llll2++;\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tint res1 = 0;\n\n\t\t\n\t\tres1 += Math.abs(m2-m1);\n\t\tres1 += Math.abs(s2-s1);\n\t\tres1 += Math.abs(l2-l1);\n\t\tres += res1/2;\n\t\tres1 = 0;\n\t\t\n\t\tres1 += Math.abs(ss2-ss1);\n\t\tres1 += Math.abs(ll2-ll1);\n\t\tres += res1/2;\n\t\tres1 = 0;\n\t\t\n\t\tres1 += Math.abs(sss2-sss1);\n\t\tres1 += Math.abs(lll2-lll1);\n\t\tres += res1/2;\n\t\tres1 = 0;\n\t\t\n\t\tres1 += Math.abs(ssss2-ssss1);\n\t\tres1 += Math.abs(llll2-llll1);\n\t\tres += res1/2;\n\t\tres1 = 0;\n\t\tSystem.out.println(res);\n\t\t\n\t\t\n\t}\n\t\n\n\tstatic class JS{\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\t\t\n\t\tpublic JS() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\t\t\n\t\tpublic JS(String s) throws FileNotFoundException {\n\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t}\n\t\t\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\t\t\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t}\n}\n", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class BetaRound23_A implements Runnable {\n\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\n\tvoid init() throws IOException {\n\t\tif (ONLINE_JUDGE) {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t} else {\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t}\n\t}\n\n\tString readString() throws IOException {\n\t\twhile (!tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tint readInt() throws IOException {\n\t\treturn Integer.parseInt(readString());\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tlong t1 = System.currentTimeMillis();\n\t\t\tinit();\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t\tlong t2 = System.currentTimeMillis();\n\t\t\tSystem.err.println(\"Time = \" + (t2 - t1));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new BetaRound23_A()).start();\n\t}\n\n\tvoid solve() throws IOException {\n\t\tchar[] s = in.readLine().toCharArray();\n\t\tint n = s.length;\n\t\tfor (int ans = n - 1; ans >= 1; ans--) {\n\t\t\tfor (int i = 0; i < n - ans + 1; i++) {\n\t\t\t\tfor (int j = i + 1; j < n - ans + 1; j++) {\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor (int k = 0; k < ans; k++) {\n\t\t\t\t\t\tif (s[i + k] == s[j + k]) count++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif (count == ans) {\n\t\t\t\t\t\tout.print(ans);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.print(0);\n\t}\n\t\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class ProblemE\n{\n\n    static int mod = (int) (1e9+7);\n    static InputReader in;\n    static PrintWriter out;\n    \n    static class SegmentTree {\n        long st[];\n \n        SegmentTree(int n)  {\n            st = new long[4*n];\n            build(0, n - 1, 1);\n        }\n        \n        int getMid(int s, int e) {\n            return (s+e)>>1;\n        }\n\n        long merge(long a,long b){\n            return a+b;\n        }\n        \n        void update(int s, int e, int x, int y, long c, int si){\n            if(s == x && e == y){\n                st[si] += c;\n            }\n            else{\n                int mid = getMid(s, e);\n                if(y <= mid)    \n                    update(s, mid, x, y, c, 2*si);\n                else if(x > mid)\n                    update(mid + 1, e, x ,y ,c ,2*si + 1);\n                else{\n                    update(s, mid, x, mid, c, 2*si);\n                    update(mid + 1, e, mid + 1, y, c, 2*si + 1);\n                }\n                st[si] = merge(st[2*si],st[2*si+1]);\n            }\n        }\n\n        long  get(int s, int e, int x, int y, int si){\n\n            if(s == x && e == y){\n                return st[si];\n            }\n            int mid = getMid(s, e);\n            if(y <= mid)\n                return get(s, mid, x, y, 2*si);\n            else if(x > mid)\n                return get(mid + 1, e, x, y, 2*si + 1);\n            return merge(get(s, mid, x, mid, 2*si), get(mid + 1, e, mid + 1, y, 2*si + 1));\n        }\n\n        void build(int ss, int se, int si){\n            if (ss == se) {\n                st[si] = 0;\n                return;\n            }\n\n            int mid = getMid(ss, se);\n            build(ss, mid, si * 2 );\n            build(mid + 1, se, si * 2 + 1);\n            st[si] = merge(st[2*si],st[2*si+1]);\n        }\n        \n    }\n\n    \n    public static void main(String[] args) throws FileNotFoundException\n    {\n        in = new InputReader(System.in);\n        out = new PrintWriter(System.out);            \n        \n        int n = in.nextInt();\n        int[] arr = in.nextIntArray(n);\n        ArrayList<Integer>list = new ArrayList<>();\n        HashMap<Integer,Integer> map = new HashMap<>();\n        \n        for(int i = 0; i < n; i++){\n            list.add(arr[i]);\n            list.add(arr[i] + 1);\n            list.add(arr[i] - 1);\n        }\n        Collections.sort(list);\n        int j = 1;\n        for(int k : list){\n            if(map.containsKey(k)) continue;\n            map.put(k, j++);\n        }\n        \n        SegmentTree seg = new SegmentTree(j + 1);\n        SegmentTree seg1 = new SegmentTree(j + 1);\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger sum = BigInteger.ZERO;\n//        long ans = 0;\n//        long sum = 0;\n        for(int i = 0; i < n; i++){\n            long x = seg.get(0, j - 1, map.get(arr[i] - 1), map.get(arr[i] + 1), 1);\n            long y = seg1.get(0, j - 1, map.get(arr[i] - 1), map.get(arr[i] + 1), 1);\n            ans = ans.add(new BigInteger(\"\"+x));\n            ans = ans.subtract(sum);\n            ans = ans.add(new BigInteger(\"\"+((arr[i] * 1l *(i - y)))));\n//              ans += arr[i] * 1l * (i - y) - sum + x;\n            \n            seg.update(0, j - 1, map.get(arr[i]), map.get(arr[i]), arr[i], 1);\n            seg1.update(0, j - 1, map.get(arr[i]), map.get(arr[i]), 1, 1);\n            sum = sum.add(new BigInteger(arr[i] + \"\"));\n        }\n        \n        out.println(ans);\n        out.close();\n    }\n\n    static class Pair implements Comparable<Pair>\n    {\n\n        int x,y;\n        int i;\n        \n        Pair (int x,int y)\n        {\n                this.x = x;\n                this.y = y;\n        }\n\n        Pair (int x,int y, int i)\n        {\n                this.x = x;\n                this.y = y;\n                this.i = i;\n        }\n\n        public int compareTo(Pair o)\n        {\n            return Long.compare(this.i,o.i);\n                //return 0;\n        }\n\n        public boolean equals(Object o)\n        {\n            if (o instanceof Pair)\n            {\n                Pair p = (Pair)o;\n                return p.x == x && p.y==y;\n            }\n            return false;\n        }\n\n        @Override\n        public String toString()\n        {\n            return x + \" \"+ y + \" \"+i;\n        }\n\n        /*public int hashCode()\n        {\n            return new Long(x).hashCode() * 31 + new Long(y).hashCode();\n        }*/\n\n    } \n\n    static long gcd(long x,long y)\n    {\n        if(y==0)\n                return x;\n        else\n                return gcd(y,x%y);\n    }\n\n    static int gcd(int x,int y)\n    {\n        if(y==0)\n                return x;\n        else \n                return gcd(y,x%y);\n    }\n\n    static long pow(long n,long p,long m)\n    {\n         long  result = 1;\n          if(p==0){\n            return n;\n          }\n          \n        while(p!=0)\n        {\n            if(p%2==1)\n                result *= n;\n            if(result >= m)\n               result %= m;\n            p >>=1;\n            n*=n;\n            if(n >= m)\n                n%=m;\n        }\n        \n        return result;\n    }\n\n    static long pow(long n,long p)\n    {\n        long  result = 1;\n          if(p==0)\n            return 1;\n\n        while(p!=0)\n        {\n            if(p%2==1)\n                result *= n;\t    \n            p >>=1;\n            n*=n;\t    \n        }\n        return result;\n    }\n\n    static void debug(Object... o)\n    {\n            System.out.println(Arrays.deepToString(o));\n    }\n\n    static class InputReader\n    {\n\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream)\n        {\n                this.stream = stream;\n        }\n\n        public int snext()\n        {\n                if (snumChars == -1)\n                        throw new InputMismatchException();\n                if (curChar >= snumChars)\n                {\n                        curChar = 0;\n                        try\n                        {\n                                snumChars = stream.read(buf);\n                        } catch (IOException e)\n                        {\n                                throw new InputMismatchException();\n                        }\n                        if (snumChars <= 0)\n                                return -1;\n                }\n                return buf[curChar++];\n        }\n\n        public int nextInt()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                {\n                        c = snext();\n                }\n                int sgn = 1;\n                if (c == '-')\n                {\n                        sgn = -1;\n                        c = snext();\n                }\n                int res = 0;\n                do\n                {\n                        if (c < '0' || c > '9')\n                                throw new InputMismatchException();\n                        res *= 10;\n                        res += c - '0';\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n        }\n\n        public long nextLong()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                {\n                        c = snext();\n                }\n                int sgn = 1;\n                if (c == '-')\n                {\n                        sgn = -1;\n                        c = snext();\n                }\n                long res = 0;\n                do\n                {\n                        if (c < '0' || c > '9')\n                                throw new InputMismatchException();\n                        res *= 10;\n                        res += c - '0';\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n        }\n\n        public int[] nextIntArray(int n)\n        {\n                int a[] = new int[n];\n                for (int i = 0; i < n; i++)\n                {\n                        a[i] = nextInt();\n                }\n                return a;\n        }\n\n        public long[] nextLongArray(int n)\n        {\n                long a[] = new long[n];\n                for (int i = 0; i < n; i++)\n                {\n                        a[i] = nextLong();\n                }\n                return a;\n        }\n\n        public String readString()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                {\n                        c = snext();\n                }\n                StringBuilder res = new StringBuilder();\n                do\n                {\n                        res.appendCodePoint(c);\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res.toString();\n        }\n\n        public String nextLine()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                        c = snext();\n                StringBuilder res = new StringBuilder();\n                do\n                {\n                        res.appendCodePoint(c);\n                        c = snext();\n                } while (!isEndOfLine(c));\n                return res.toString();\n        }\n\n        public boolean isSpaceChar(int c)\n        {\n                if (filter != null)\n                        return filter.isSpaceChar(c);\n                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c)\n        {\n                return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public interface SpaceCharFilter\n        {\n                public boolean isSpaceChar(int ch);\n        }\n\n    }\n}    \n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.util.Scanner;\n\n\npublic final class b1 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner datain = new Scanner(System.in);\n\t\tlong l=datain.nextLong();\n\t\tlong r=datain.nextLong();\n\t\tif(r-l<2){System.out.print(-1);}else{\n\t\t\tif(((r-l)==2)&&(l%2==1)){System.out.print(-1);}else{\n\t\t\t\tif((l%2)==0){System.out.print(\"\"+l+\" \"+(l+1)+\" \"+(l+2));}else{\n\t\t\t\t\tSystem.out.print(\"\"+(l+1)+\" \"+(l+2)+\" \"+(l+3));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        long a = in.nextLong();\n        long b = in.nextLong();\n        long res = 0;\n        while (b > 0) {\n            res += a / b;\n            long t = a % b;\n            a = b;\n            b = t;\n        }\n        out.println(res);\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    }\n\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ZYCSwing\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        private static final int MOD = (int) 1e9 + 7;\n        private static final int N = 5000;\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] dp = new int[N];\n            Arrays.fill(dp, 0);\n            dp[0] = 1;\n            String pre = null, ch;\n            for (int i = 0; i < n; ++i) {\n                ch = in.next();\n                if (i > 0) {\n                    if (pre.equals(\"s\")) {\n                        int j = N - 1;\n                        while (dp[j] == 0) {\n                            --j;\n                        }\n                        long sum = 0;\n                        for (; j >= 0; --j) {\n                            sum += dp[j];\n                            sum %= MOD;\n                            dp[j] = (int) sum;\n                        }\n                    } else {\n                        for (int k = N - 1; k > 0; --k) {\n                            dp[k] = dp[k - 1];\n                        }\n                        dp[0] = 0;\n                    }\n                }\n                pre = ch;\n            }\n\n            long sum = 0;\n            for (int i = 0; i < N; ++i) {\n                sum += dp[i];\n                sum %= MOD;\n            }\n            out.println(sum);\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.*;\n\npublic class cf112e {\n    static int n,m,s;\n    static int[][][] memo;\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        if(n > m) {\n            int tmp = n;\n            n = m;\n            m = tmp;\n        }\n        s = (1<<n);\n        memo = new int[s][s][m];\n        for(int i=0; i<s; i++)\n            for(int j=0; j<s; j++)\n                Arrays.fill(memo[i][j], -1);\n        int ret = go(0,0,0);\n        System.out.println(n*m - ret);\n    }\n    static int go(int last, int trans, int r) {\n        if(r==m) {\n            if(trans == 0) return 0;\n            return 100;\n        }\n        if(memo[last][trans][r] != -1) return memo[last][trans][r];\n        int best = 100;\n        for(int crnt = 0; crnt < s; crnt++) {\n            if((trans & ~crnt) != 0) continue; //certain ones have to be here\n            for(int pass = 0; pass < s; pass++) {\n                int tmp = ((1<<n)-1) & ~last;   //move back the ones you can\n                if((pass & ~tmp) != 0) continue; //certain ones have to move on\n                tmp = tmp & ~pass; //find which ones stay\n                boolean fail = false;\n                for(int k=0; k<n; k++) //make sure that the ones that stay\n                    if(isSet(tmp,k) && !(isSet(crnt,k-1) || isSet(crnt,k) || isSet(crnt,k+1)))\n                        fail = true;\n                if(fail) continue;\n                best = Math.min(best, Integer.bitCount(crnt) + go(crnt,pass,r+1));\n            }\n        }\n        return memo[last][trans][r] = best;\n    }\n    static boolean isSet(int x, int p) {\n        if(p < 0 || p >= n) return false;\n        return (x & (1<<p)) != 0;\n    }\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.util.Scanner;\n\npublic class N1_CF_199A {\n    public static void main(String[] args) {\n    int n = new Scanner(System.in).nextInt();\n    if( n == 0)\n    {\n        System.out.println(0);\n        System.out.println(0);\n        System.out.println(0);\n        return;\n    }\n    int i = 0 , j = 1;\n    while(true)\n    {\n        int t = i + j;\n        if( t == n)\n        break;\n        i = j;\n        j = t;\n    }\n    System.out.println(i);\n    System.out.println(j);\n    System.out.println(0);\n    }\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n/*\n * @author Tnascimento \n */\n\npublic class MaeDosDragoes {\n\t// public static StringTokenizer tokenizer;\n\t// public static BufferedReader reader;\n\tpublic static PrintWriter saida = new PrintWriter(System.out, false);\n\t// public static String proximo() {\n\t// \twhile (tokenizer == null || !tokenizer.hasMoreElements()) {\n\t// \t\ttry {\n\t// \t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t// \t\t} catch (RuntimeException e) {\n\t// \t\t\te.printStackTrace();\n\t// \t\t}\n\t// \t}\n\t// \treturn tokenizer.nextToken();\n\t// }\n\n\tpublic static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n\n\n\n    public static void main(String[] args) {\n\t\tFastScanner fastScanner = new FastScanner();\n        int proximoInt = fastScanner.nextInt();\n        double proximoDouble = fastScanner.nextInt();\n        long[] graph = new long[proximoInt];\n        for(Integer i = 0; i < proximoInt; i++) {\n            for(Integer j =0; j < proximoInt; j++) {\n                Integer val = fastScanner.nextInt();\n                if (val.equals(1) || i.equals(j)) {\n\t\t\t\t graph[i] |= 1L << j;\n\t\t\t\t}\n            }\n        }\n\n        int szLeft = proximoInt/2;\n        int szRight = proximoInt - szLeft;\n\n        int[] dp = new int[1 << szLeft];\n        int maxMask = 1 << szLeft;\n\n        for(int mask = 1; mask <maxMask; mask++) {\n            int curMask = mask;\n\n            for(int j = 0; j < szLeft; j++) {\n                if (((1 << j) & mask) > 0) {\n                    curMask &= graph[j + szRight] >> szRight;\n                    dp[mask] = Math.max(dp[mask], dp[mask ^ (1 << j)]);\n                }\n            }\n            if (mask == curMask) {\n                dp[mask] = Math.max(dp[mask],Integer.bitCount(mask));\n            }\n        }\n        int ans = 0;\n        int rmaxMask = 1 << szRight;\n        for(int mask = 0; mask < rmaxMask; mask++) {\n            int curMask = mask;\n            int oMask = maxMask -1;\n            for(int j = 0; j < szRight; j++) {\n                if (((1 << j) & mask) > 0) {\n                    curMask &= (graph[j] & (rmaxMask-1));\n                    oMask &= graph[j] >> szRight;\n                }\n            }\n            if (curMask != mask) continue;\n            ans = Math.max(ans, Integer.bitCount(mask) + dp[oMask]);\n        }\n        proximoDouble/=ans;\n        saida.println(proximoDouble * proximoDouble * (ans * (ans-1))/2);\n        saida.flush();\n    }\n}\n", "complexity": "np", "problem": "0839_E", "from": "CODEFORCES", "tags": "brute force,graphs,math,meet-in-the-middle"}
{"src": "\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main\n{\n\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer tokenizer=null;\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tnew Main().execute();\n\t}\n\t\n\tvoid debug(Object...os)\n\t{\n\t\tSystem.out.println(Arrays.deepToString(os));\n\t}\n\t\n\tint ni() throws IOException\n\t{\n\t\treturn Integer.parseInt(ns());\n\t}\n\t\n\tlong nl() throws IOException \n\t{\n\t\treturn Long.parseLong(ns());\n\t}\n\t\n\tdouble nd() throws IOException \n\t{\n\t\treturn Double.parseDouble(ns());\n\t}\n\t\t\n\tString ns() throws IOException \n\t{\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) \n\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\treturn tokenizer.nextToken();\n\t}\n\t\n\tString nline() throws IOException\n\t{\n\t\ttokenizer=null;\n\t\treturn br.readLine();\n\t}\n\t\t\n\t\n\n\t//Main Code starts Here\n\tint totalCases, testNum;\t\n\tint sum;\n\tint n;\n\tint arr[];\n\n\tvoid execute() throws IOException\n\t{\n\t\ttotalCases = 1;\n\t\tfor(testNum = 1; testNum <= totalCases; testNum++)\n\t\t{\n\t\t\tif(!input())\n\t\t\t\tbreak;\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() throws IOException\n\t{\n\t\tArrays.sort(arr);\n\t\tint count = 0;\n\t\tint ans = 0;\n\t\tfor(int i = n-1;i>=0;i--)\n\t\t{\n\t\t\tcount+= arr[i];\n\t\t\tif(count>sum-count)\n\t\t\t{\n\t\t\t\tans = n-i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\n\tboolean input() throws IOException\n\t{\n\t\tn = ni();\n\t\tsum = 0;\n\t\tarr = new int[n];\n\t\tfor(int i = 0;i<n;i++)\n\t\t{\n\t\t\tarr[i] = ni();\n\t\t\tsum = sum+arr[i];\n\t\t}\n\t\treturn true;\n\t}\n\n\n}\n\n\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\n\n\npublic class Main {\n\n\n\n    static BufferedReader br;\n\n    static PrintWriter out;\n\n    static StringTokenizer st;\n\n    \n\n    static int[][] moves = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\n    \n\n    static boolean correct(int x, int y, int n, int m) {\n\n        return (x >= 0 && x < n && y >= 0 && y < m); \n\n    }\n\n    \n\n    static void solve() throws Exception {\n\n        int n = nextInt();\n\n        int m = nextInt();\n\n        int k = nextInt();\n\n        int[][] order = new int[n][m];\n\n        boolean[][] used = new boolean[n][m];\n\n        Queue<Integer[]> q = new LinkedList<>();\n\n        Set<String> set = new HashSet<String>();\n\n        for(int i = 0; i < k; i++) {\n\n            int x = nextInt() - 1;\n\n            int y = nextInt() - 1;\n\n            order[x][y] = 1;\n\n            used[x][y] = true;\n\n            q.add(new Integer[] {x, y});\n\n            set.add(x + \"\" + y);\n\n        }\n\n        while(!q.isEmpty()) {\n\n            Integer[] v = q.remove();\n\n            for(int[] move : moves) {\n\n                int x = v[0] + move[0];\n\n                int y = v[1] + move[1];\n\n//              if(set.contains(x + \"\" + y)) {\n\n//                  continue;\n\n//              }\n\n                if(correct(x, y, n, m) && !used[x][y]) {\n\n                    q.add(new Integer[] {x, y});\n\n                    used[x][y] = true;\n\n                    order[x][y] = order[v[0]][v[1]] + 1; \n\n                }\n\n            }\n\n        }\n\n        int max = Integer.MIN_VALUE;\n\n        int maxI = -1;\n\n        int maxJ = -1;\n\n        for(int i = 0; i < n; i++) {\n\n            for(int j = 0; j < m; j++) {\n\n                if(order[i][j] > max) {\n\n                    max = order[i][j];\n\n                    maxI = i;\n\n                    maxJ = j;\n\n                }\n\n            }\n\n        }\n\n        maxI++;\n\n        maxJ++;\n\n        out.println(maxI + \" \" + maxJ);\n\n    }\n\n    \n\n \n\n    static int nextInt() throws IOException {\n\n        return Integer.parseInt(next());\n\n    }\n\n\n\n    static long nextLong() throws IOException {\n\n        return Long.parseLong(next());\n\n    }\n\n\n\n    static double nextDouble() throws IOException {\n\n        return Double.parseDouble(next());\n\n    }\n\n\n\n    static String next() throws IOException {\n\n        while (st == null || !st.hasMoreTokens()) {\n\n            String line = br.readLine();\n\n            if (line == null) {\n\n                return null;\n\n            }\n\n            st = new StringTokenizer(line);\n\n        }\n\n        return st.nextToken();\n\n    }\n\n\n\n    public static void main(String[] args) {\n\n        try {\n\n            InputStream input = System.in;\n\n            OutputStream output = System.out;\n\n            br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"input.txt\"))));\n\n            out = new PrintWriter(new PrintStream(new File(\"output.txt\")));\n\n            solve();\n\n            out.close();\n\n            br.close();\n\n        } catch (Throwable t) {\n\n            t.printStackTrace();\n\n        }\n\n    }\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.math.BigInteger;\nimport java.util.*;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class D {\n  public static void main(String[] args) {\n    init();\n\n    int n = in.nextInt();\n\n    long total = 0L;\n\n\n\n    int arr[] = new int[n+5];\n\n    Map<Integer, Integer> freq = new HashMap<>();\n    Map<Integer, Integer> kiri = new HashMap<>();\n\n    for (int i = 1; i <= n; ++i){\n     arr[i] = in.nextInt();\n      if (freq.containsKey(arr[i])) {\n        freq.put(arr[i], freq.get(arr[i])+1);\n      } else {\n        freq.put(arr[i], 1);\n        kiri.put(arr[i], 0);\n      }\n      total += (long)arr[i];\n    }\n\n    BigInteger ans = BigInteger.valueOf(0L);\n\n    for (int i = 1; i <= n - 1; ++i) {\n      kiri.put(arr[i], kiri.get(arr[i])+1);\n      total -= arr[i];\n\n      int cnt_kanan = n - i;\n      long temp = total;\n      int cnt_sama = freq.get(arr[i]) - kiri.get(arr[i]);\n      temp -= (cnt_sama)*(long)arr[i];\n      cnt_kanan -= (cnt_sama);\n      if (freq.containsKey(arr[i]-1)) {\n        int cnt_kurang = freq.get(arr[i]-1) - kiri.get(arr[i]-1);\n        cnt_kanan -= cnt_kurang;\n        temp -= (long) cnt_kurang * (long)(arr[i]-1);\n      }\n      if (freq.containsKey(arr[i]+1)) {\n        int cnt_lebih = freq.get(arr[i]+1) - kiri.get(arr[i]+1);\n        cnt_kanan -= cnt_lebih;\n        temp -= (long)(cnt_lebih) * (long)(arr[i]+1);\n      }\n      temp -= (long)cnt_kanan * (long)arr[i];\n      ans = ans.add(BigInteger.valueOf(temp));\n    }\n\n    out.println(ans.toString());\n    out.close();\n  }\n\n  /* PrintWriter and BufferedReader Template from Codeforces */\n  public static MyScanner in;\n  public static PrintWriter out;\n\n  public static void init() {\n    in = new MyScanner();\n    out = new PrintWriter(new BufferedOutputStream(System.out));\n  }\n\n  public static class MyScanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    MyScanner() {\n      br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n      while (st == null || !st.hasMoreElements()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n      String str = \"\";\n      try {\n        str = br.readLine();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n\n}", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Dasha {\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter pw = new PrintWriter(System.out), pw2 = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        int n=sc.nextInt();\n        int[] arr=new int[101];\n        for(int i=0;i<n;i++)\n            arr[sc.nextInt()]++;\n        boolean [] vis=new boolean[101];\n        int c=0;\n        for(int i=1;i<=100;i++){\n            if(!vis[i]&&arr[i]>0){\n                c++;\n                for(int j=i+i;j<=100;j+=i)\n                    vis[j]=true;\n            }\n        }\n        pw.println(c);\n        pw.flush();\n    }\n\n    public static <E> void print2D(E[][] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i].length; j++) {\n                pw.println(arr[i][j]);\n            }\n        }\n    }\n\n    public static int digitSum(String s) {\n        int toReturn = 0;\n        for (int i = 0; i < s.length(); i++) toReturn += Integer.parseInt(s.charAt(i) + \" \");\n        return toReturn;\n    }\n\n    public static boolean isPrime(long n) {\n        if (n <= 1)\n            return false;\n        if (n <= 3)\n            return true;\n\n        if (n % 2 == 0 || n % 3 == 0)\n            return false;\n\n        for (long i = 5; i * i <= n; i = i + 6)\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n        return true;\n    }\n\n    public static long pow(long a, long pow) {\n        return pow == 0 ? 1 : pow % 2 == 0 ? pow(a * a, pow >> 1) : a * pow(a * a, pow >> 1);\n    }\n\n    public static long sumNum(long a) {\n        return a * (a + 1) / 2;\n    }\n\n    public static int gcd(int n1, int n2) {\n        return n2 == 0 ? n1 : gcd(n2, n1 % n2);\n    }\n\n    public static long factorial(long a) {\n        return a == 0 || a == 1 ? 1 : a * factorial(a - 1);\n    }\n\n    public static void sort(int arr[]) {\n        shuffle(arr);\n        Arrays.sort(arr);\n    }\n\n    public static void shuffle(int arr[]) {\n        Random rnd = new Random();\n        for (int i = arr.length - 1; i > 0; i--) {\n            int index = rnd.nextInt(i + 1);\n            int temp = arr[index];\n            arr[index] = arr[i];\n            arr[i] = temp;\n        }\n    }\n\n    public static Double[] solveQuadratic(double a, double b, double c) {\n        double result = (b * b) - 4.0 * a * c;\n        double r1;\n        if (result > 0.0) {\n            r1 = ((double) (-b) + Math.pow(result, 0.5)) / (2.0 * a);\n            double r2 = ((double) (-b) - Math.pow(result, 0.5)) / (2.0 * a);\n            return new Double[]{r1, r2};\n        } else if (result == 0.0) {\n            r1 = (double) (-b) / (2.0 * a);\n            return new Double[]{r1, r1};\n        } else {\n            return new Double[]{null, null};\n        }\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n\n    static class pair<E1, E2> implements Comparable<pair> {\n        E1 x;\n        E2 y;\n\n        pair(E1 x, E2 y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(pair o) {\n            return x.equals(o.x) ? (Integer) y - (Integer) o.y : (Integer) x - (Integer) o.x;\n        }\n\n        @Override\n        public String toString() {\n            return x + \" \" + y;\n        }\n\n        public double pointDis(pair p1) {\n            return Math.sqrt(((Integer) y - (Integer) p1.y) * ((Integer) y - (Integer) p1.y) + ((Integer) x - (Integer) p1.x) * ((Integer) x - (Integer) p1.x));\n        }\n    }\n\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tstatic final int MOD = (int)1e9 + 7;\n\tstatic int n;\n\tstatic int[] t;\n\tstatic int[] g;\t\n\tstatic int[][] memo;\n\t\n\tstatic int dp(int mask, int rem, int last)\n\t{\n\t\tif(rem == 0)\n\t\t\treturn 1;\n\t\tif(memo[last][mask] != -1)\n\t\t\treturn memo[last][mask];\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif((mask & (1 << i)) == 0 && rem >= t[i] && g[i] != last)\n\t\t\t\tans += dp(mask | 1 << i, rem - t[i], g[i]);\n\t\t\t\n\t\t\tif(ans >= MOD)\n\t\t\t\tans -= MOD;\n\t\t}\n\t\t\n\t\treturn memo[last][mask] = ans;\n\t}\n\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\t\n\t\tn = in.nextInt();\n\t\tint T = in.nextInt();\n\t\t\n\t\tt = new int[n];\n\t\tg = new int[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tt[i] = in.nextInt();\n\t\t\tg[i] = in.nextInt() - 1;\n\t\t}\n\t\t\n\t\tmemo = new int[4][1 << n];\n\t\tfor(int []x : memo)\n\t\t{\n\t\t\tArrays.fill(x, -1);\n\t\t}\n\t\t\n\t\tout.println(dp(0, T, 3));\n\t\tout.close();\n\t}\n\t\n\tstatic class InputReader\n\t{\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\t\t\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\t\t\n\t\tpublic String next()\n\t\t{\n\t\t\twhile(tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t}\n\t\t\t\tcatch(IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n}", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.io.*;\npublic class Main {\n\tpublic static class node implements Comparable<node> {\n\t\tint l,r;\n\t\tnode(){}\n\t\tnode(int l,int r) {\n\t\t\tthis.l=l;\n\t\t\tthis.r=r;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(node rhs) {\n\t\t\treturn r-rhs.r;\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tStringTokenizer sa=new StringTokenizer(in.readLine());\n\t\tint n=Integer.parseInt(sa.nextToken());\n\t\tsa=new StringTokenizer(in.readLine());\n\t\tint[] a=new int[n];\n\t\tTreeMap<Integer,ArrayList<node>> mp=new TreeMap();\n\t\tfor (int i=0;i<n;++i) a[i]=Integer.parseInt(sa.nextToken());\n\t\tArrayList<node> ans=new ArrayList<node>();\n\t\tfor (int i=0;i<n;++i) {\n\t\t\tint tmp=0;\n\t\t\tfor (int j=i;j<n;++j) {\n\t\t\t\ttmp+=a[j];\n\t\t\t\tif (!mp.containsKey(tmp)) {\n\t\t\t\t\tArrayList<node> t=new ArrayList();\n\t\t\t\t\tt.add(new node(i,j));\n\t\t\t\t\tmp.put(tmp,t);\n\t\t\t\t} else {\n\t\t\t\t\tArrayList<node> t=mp.get(tmp);\n\t\t\t\t\tint left=0,right=t.size()-1,res=t.size();\n\t\t\t\t\twhile (left<=right) {\n\t\t\t\t\t\tint mid=(left+right)>>1;\n\t\t\t\t\t\tif (t.get(mid).r>=i) {\n\t\t\t\t\t\t\tres=mid;\n\t\t\t\t\t\t\tright=mid-1;\n\t\t\t\t\t\t} else left=mid+1;\n\t\t\t\t\t}\n\t\t\t\t\tif (res==t.size()) t.add(new node(i,j));\n\t\t\t\t\telse if (t.get(res).r>j) t.set(res,new node(i,j));\n\t\t\t\t}\n\t\t\t\tif (mp.get(tmp).size()>ans.size()) ans=mp.get(tmp);\n\t\t\t}\n\t\t}\n\t\tout.println(ans.size());\n\t\tfor (int i=0;i<ans.size();++i)\n\t\t\tout.printf(\"%d %d\\n\",ans.get(i).l+1,ans.get(i).r+1);\n\t\tout.flush();\n\t}\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Created by IntelliJ IDEA.\n * User: Mirza\n * Date: 25.03.12\n * Time: 18:51\n * To change this template use File | Settings | File Templates.\n */\npublic class main {\n        static Scanner in; static int next() throws Exception {return in.nextInt();};\n    //static StreamTokenizer in; static int next() throws Exception {in.nextToken(); return (int) in.nval;}\n    //  static BufferedReader in;\n    static PrintWriter out;\n\n    public static void main(String[] args) throws Exception {\n        in = new Scanner(System.in);\n//      in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n//      in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        int n = next();\n        int a = next();\n        int b = next();\n        int k = 0;\n        int i;\n        int[] ar = new int[n];\n        for(i=0;i<n;i++)\n            ar[i]=next();\n        Arrays.sort(ar);\n        k = ar[n-a]-ar[b-1];\n        if(k<0)\n            out.print(0);\n        else out.print(k);\n        out.close();\n\n    }\n}", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.text.BreakIterator;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\npublic class palin {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tScanner scan = new Scanner(System.in);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\tif (n >= 0) {\n\t\t\tout.print(n);\n\t\t\treturn;\n\t\t}\n\t\tif (n / 10 >= (n / 100) * 10 + n % 10) {\n\t\t\tout.print(n / 10);\n\t\t\treturn;\n\t\t}\n\t\tout.print((n / 100) * 10 + n % 10);\n\t}\n}\n\nclass InputReader {\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic InputReader(InputStream in) {\n\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\tst = null;\n\t}\n\n\tpublic String next() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class ayyyyyy\n{\n\tpublic static void main(String[] args) { new ayyyyyy(); }\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint t, n;\n\tint[] a;\n\t\n\tayyyyyy()\n\t{\n\t\tt = in.nextInt();\n\t\twhile (t --> 0)\n\t\t{\n\t\t\ta = new int[n = in.nextInt()];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = in.nextInt();\n\t\t\tshuffle(a);\n\t\t\tArrays.sort(a);\n\t\t\tout.println(Math.min(n-2, a[n-2]-1));\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\t\n\tvoid shuffle(int[] x)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint swp = (int)(n*Math.random());\n\t\t\tint tmp = x[swp];\n\t\t\tx[swp] = x[i];\n\t\t\tx[i] = tmp;\n\t\t}\n\t}\n}", "complexity": "nlogn", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Rishabhdeep Singh\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        int MOD = (int) 1e9 + 7;\n\n        long power(long a, long k) {\n            long res = 1;\n            while (k > 0) {\n                if ((k & 1) != 0) {\n                    res = res * a % MOD;\n                }\n                a = a * a % MOD;\n                k /= 2;\n            }\n            return res;\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            long x = in.nextLong(), k = in.nextLong();\n            if (x == 0) {\n                out.println(0);\n                return;\n            }\n            long res = ((power(2, k + 1) % MOD) * (x % MOD)) % MOD;\n            long temp = power(2, k);\n            res = res - temp + 1;\n            while (res < 0) res += MOD;\n            out.println(res);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class D {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt(), sum = 0;\n        int [] a = new int[n+1];\n        for (int i = 1; i <= n; i++) {\n            a[i] = in.nextInt();\n        }\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j)\n                sum += a[i] > a[j] ? 1 : 0;\n        int m = in.nextInt();\n        sum &= 1;\n        for (int i = 1; i <= m; i++) {\n            int l = in.nextInt(), r = in.nextInt();\n            if (((r - l + 1) / 2) % 2 == 1)\n                sum ^= 1;\n            System.out.println(sum == 1 ? \"odd\" : \"even\");\n        }\n    }\n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tprivate FastScanner in;\n\tprivate PrintWriter out;\n\n\tpublic void solve() throws IOException {\n\t\tint N = in.nextInt();\n\t\tint M = in.nextInt();\n\n\t\tint[][] edges = new int[N][N];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a = in.nextInt() - 1;\n\t\t\tint b = in.nextInt() - 1;\n\t\t\tedges[a][b] = 1;\n\t\t\tedges[b][a] = 1;\n\t\t}\n\n\t\tint globalCountMasks = 1 << N;\n\t\tint[][] masks = new int[N + 1][];\n\t\tint[] countMasks = new int[N + 1];\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tmasks[i] = new int[combinations(N, i)];\n\t\t}\n\t\tfor (int i = 0; i < globalCountMasks; i++) {\n\t\t\tint c = countBit1(i);\n\t\t\tmasks[c][countMasks[c]] = i;\n\t\t\tcountMasks[c]++;\n\t\t}\n\n\t\tlong globalCountCycles = 0;\n\t\tlong[][] count = new long[globalCountMasks][N];\n\n\t\tfor (int a = 0; a < N - 2; a++) {\n\t\t\tint aBit = 1 << a;\n\t\t\tcount[aBit][a] = 1;\n\t\t\tlong countCycles = 0;\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tfor (int m = 0; m < countMasks[i]; m++) {\n\t\t\t\t\tint mask = masks[i][m];\n\t\t\t\t\tif ((mask & aBit) == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ((mask & (aBit - 1)) > 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcount[mask][a] = 0;\n\t\t\t\t\tfor (int v = a + 1; v < N; v++) {\n\t\t\t\t\t\tint vBit = 1 << v;\n\t\t\t\t\t\tif ((mask & vBit) == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcount[mask][v] = 0;\n\t\t\t\t\t\tfor (int t = a; t < N; t++) {\n\t\t\t\t\t\t\tif ((mask & (1 << t)) == 0 || t == v\n\t\t\t\t\t\t\t\t\t|| edges[v][t] == 0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tcount[mask][v] += count[mask ^ vBit][t];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (edges[a][v] == 1 && mask != (aBit | vBit)) {\n\t\t\t\t\t\t\tcountCycles += count[mask][v];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tglobalCountCycles += countCycles / 2;\n\t\t}\n\n\t\tout.println(globalCountCycles);\n\t}\n\n\tprivate int countBit1(int k) {\n\t\tint c = 0;\n\t\twhile (k > 0) {\n\t\t\tc += k & 1;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn c;\n\t}\n\n\tprivate int combinations(int n, int k) {\n\t\tif (k > n || k < 0) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t\tint r = 1;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tr = r * (n + 1 - i) / i;\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new FastScanner(System.in);\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tclass FastScanner {\n\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] arg) {\n\t\tnew Main().run();\n\t}\n}", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n  public static void main(String[] args) {\n       Scanner sc = new Scanner(System.in);\n       Long N = sc.nextLong();\n       Long ans;\n       sc.close();\n       if(N <= 2)\n           System.out.println(N);\n       else{\n           if(N % 6 == 0){\n                ans = (N - 1) * (N - 2) * (N - 3);}\n            else if(N % 2 == 0){\n                ans = N * (N - 1) * (N - 3);\n            }\n            else{\n                ans = N * (N - 1) * (N - 2);\n            }\n           System.out.println(ans);\n       }\n    }\n}", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class taskA {\n\n\tvoid solve() throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\n\t\tlong ans = 0;\n\t\twhile (a  != 0 && b != 0) {\n\t\t\tif (a > b) {\n\t\t\t\tans += a / b;\n\t\t\t\ta %= b;\n\t\t\t} else {\n\t\t\t\tlong c = b % a;\n\t\t\t\tans += b / a;\n\t\t\t\tb = a;\n\t\t\t\ta = c;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tBufferedReader br;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\ttry {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\t// br = new BufferedReader(new FileReader(new File(\"taskA.in\")));\n\t\t\t// out = new PrintWriter(\"taskA.out\");\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew taskA().run();\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile ((st == null) || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws NumberFormatException, IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tlong nextLong() throws NumberFormatException, IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "\nimport java.util.*;\n\n\npublic class A\n{\n   public static void main(String[] args)\n   {\n      new A(new Scanner(System.in));\n   }\n\n   public A(Scanner in)\n   {\n      int n = in.nextInt();\n      int t = in.nextInt();\n      int tt = 2*t;\n\n      rect[] rs = new rect[n];\n      for (int i=0; i<n; i++)\n         rs[i] = new rect(in.nextInt(), in.nextInt());\n      \n      Arrays.sort(rs);\n\n      int res = 2;\n      for (int i=1; i<n; i++)\n      {\n         rect a = rs[i-1];\n         rect b = rs[i];\n         int d = b.p-a.p;\n         int dd = a.t+b.t;\n         int tv = 2*d-dd;\n         if (tt == tv)\n            res++;\n         if (tv > tt)\n            res+=2;\n      }\n      System.out.printf(\"%d%n\", res);\n   }\n}\n\nclass rect implements Comparable<rect>\n{\n   int p;\n   int t;\n\n   public rect(int pp, int tt)\n   {\n      p = pp;\n      t = tt;\n   }\n\n   public int compareTo(rect rhs)\n   {\n      return p-rhs.p;\n   }\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int k = in.nextInt();\n        int[] A = new int[n];\n        for (int i = 0; i < n; i++)\n            A[i] = in.nextInt();\n        Arrays.sort(A);\n        int cnt = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            if (k >= m) {\n                System.out.println(cnt);\n                return;\n            }\n            cnt++;\n            k += A[i] - 1;\n        }\n        if (k >= m)\n            System.out.println(cnt);\n        else\n            System.out.println(-1);\n    }\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * @author khokharnikunj8\n */\npublic class Main {\n    public static void main(String[] args) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                new Main().solve();\n            }\n        }, \"1\", 1 << 26).start();\n    }\n\n    void solve() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        ACodehorsesTShirts solver = new ACodehorsesTShirts();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ACodehorsesTShirts {\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            int n = in.scanInt();\n            ArrayList<String>[] arrayLists = new ArrayList[5];\n            ArrayList<String>[] arrayLists1 = new ArrayList[5];\n            for (int i = 0; i < 5; i++) {\n                arrayLists[i] = new ArrayList<>();\n                arrayLists1[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < n; i++) {\n                String s = in.scanString();\n                arrayLists[s.length()].add(s);\n            }\n            for (int i = 0; i < n; i++) {\n                String s = in.scanString();\n                arrayLists1[s.length()].add(s);\n            }\n            long ans = 0;\n            for (int i = 0; i < 5; i++) {\n                for (int diff = 0; diff < 5; diff++) {\n\n                    for (int j = 0; j < arrayLists[i].size(); j++) {\n                        int min = Integer.MAX_VALUE;\n                        int index = -1;\n                        for (int k = 0; k < arrayLists1[i].size(); k++) {\n                            int tt = 0;\n                            for (int l = 0; l < i; l++)\n                                if (arrayLists[i].get(j).charAt(l) != arrayLists1[i].get(k).charAt(l)) tt++;\n                            if (tt < min) {\n                                min = tt;\n                                index = k;\n                            }\n\n                        }\n                        if (min == diff) {\n                            arrayLists1[i].remove(index);\n                            ans += min;\n                        }\n                    }\n                }\n            }\n            out.println(ans);\n\n\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int index;\n        private BufferedInputStream in;\n        private int total;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (index >= total) {\n                index = 0;\n                try {\n                    total = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (total <= 0) return -1;\n            }\n            return buf[index++];\n        }\n\n        public int scanInt() {\n            int integer = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    integer *= 10;\n                    integer += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * integer;\n        }\n\n        public String scanString() {\n            int c = scan();\n            if (c == -1) return null;\n            while (isWhiteSpace(c)) c = scan();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = scan();\n            } while (!isWhiteSpace(c));\n            return res.toString();\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import static java.util.Arrays.deepToString;\n\nimport java.awt.datatransfer.StringSelection;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static void solve() throws IOException {\n        int n = nextInt();\n        if (n >= 0) {\n            System.out.println(n);\n        } else {\n            String string = String.valueOf(n);\n            int v1 = Integer.valueOf(string.substring(0, string.length() - 1));\n            int v2 = Integer.valueOf(string.substring(0, string.length() - 2)\n                    + string.charAt(string.length() - 1));\n            if (v1 >= v2) {\n                System.out.println(v1);\n            } else {\n                System.out.println(v2);\n            }\n        }\n        \n    }\n\n    public static void main(String[] args) throws Exception {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n        writer = new PrintWriter(System.out);\n\n        setTime();\n        solve();\n        printTime();\n        printMemory();\n\n        writer.close();\n    }\n\n    static BufferedReader reader;\n    static PrintWriter writer;\n    static StringTokenizer tok = new StringTokenizer(\"\");\n    static long systemTime;\n\n    static void debug(Object... o) {\n        System.err.println(deepToString(o));\n    }\n\n    static void setTime() {\n        systemTime = System.currentTimeMillis();\n    }\n\n    static void printTime() {\n        System.err.println(\"Time consumed: \"\n                + (System.currentTimeMillis() - systemTime));\n    }\n\n    static void printMemory() {\n        System.err.println(\"Memory consumed: \"\n                + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime()\n                        .freeMemory()) / 1000 + \"kb\");\n    }\n\n    static String next() {\n        while (!tok.hasMoreTokens()) {\n            String w = null;\n            try {\n                w = reader.readLine();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            if (w == null)\n                return null;\n            tok = new StringTokenizer(w);\n        }\n        return tok.nextToken();\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    static double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    static BigInteger nextBigInteger() {\n        return new BigInteger(next());\n    }\n}", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Round364C {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tk = 0;\n\t\t\n\t\tString line = sc.nextLine();\n\t\t\n\t\tArrayList<Character> poks = new ArrayList<Character>();\n\t\tboolean ex[] = new boolean[256];\n\t\t\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tif(!ex[line.charAt(i)])\n\t\t\t{\n\t\t\t\tex[line.charAt(i)] = true;\n\t\t\t\tpoks.add(line.charAt(i));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint l = 0;\n\t\tint r = 0;\n\t\tint dist = 1;\n\t\tint occ[] = new int[256];\n\t\tocc[line.charAt(0)] = 1;\n\t\t\n\t\tint min = n;\n\t\twhile(r < n)\n\t\t{\n\t\t\tif(dist == poks.size())\n\t\t\t\tmin = Math.min(min, r - l + 1);\n\t\t\tif(l < r && dist == poks.size())\n\t\t\t{\n\t\t\t\t\n\t\t\t\tocc[line.charAt(l)]--;\n\t\t\t\tif(occ[line.charAt(l)] == 0)\n\t\t\t\t\tdist--;\n\t\t\t\tl++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(r < n-1){\n\t\t\t\tocc[line.charAt(r+1)]++;\n\t\t\t\tif(occ[line.charAt(r+1)] == 1)\n\t\t\t\t\tdist++;\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tSystem.out.println(min);\n\t\t\n\t}\n\t\n\tstatic int n,k;\n\tstatic int dp[][][];\n\t\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(FileReader f) {\n\t\t\tbr = new BufferedReader(f);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tScanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\npublic class Solution implements Runnable {\n    FastScanner sc;\n    PrintWriter pw;\n    \n    final class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n \n        public long nlo() {\n            return Long.parseLong(next());\n        }\n \n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return st.nextToken();\n        }\n \n        public int ni() {\n            return Integer.parseInt(next());\n        }\n \n        public String nli() {\n            String line = \"\";\n            if (st.hasMoreTokens()) line = st.nextToken();\n            else try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            while (st.hasMoreTokens()) line += \" \" + st.nextToken();\n            return line;\n        }\n \n        public double nd() {\n            return Double.parseDouble(next());\n        }\n    }\n    public static void main(String[] args) throws Exception\n    {\n        new Thread(null,new Solution(),\"codeforces\",1<<28).start();\n    }\n    public void run()\n    {\n        sc=new FastScanner();\n        pw=new PrintWriter(System.out);\n        try{\n            solve();\n        }\n        catch(Exception e)\n        {\n            pw.println(e);\n        }\n        pw.flush();\n        pw.close();\n    }\n    public long gcd(long a,long b)\n    {\n        return b==0L?a:gcd(b,a%b);\n    }\n    public long ppow(long a,long b,long mod)\n    {\n        if(b==0L)\n        return 1L;\n        long tmp=1;\n        while(b>1L)\n        {\n            if((b&1L)==1L)\n            tmp*=a;\n            a*=a;\n            a%=mod;\n            tmp%=mod;\n            b>>=1;\n        }\n        return (tmp*a)%mod;\n    }\n    public long pow(long a,long b)\n    {\n        if(b==0L)\n        return 1L;\n        long tmp=1;\n        while(b>1L)\n        {\n            if((b&1L)==1)\n            tmp*=a;\n            a*=a;\n            b>>=1;\n        }\n        return (tmp*a);\n    }\n    public  int gcd(int x,int y)\n    {\n        return y==0?x:gcd(y,x%y);\n    }\n   \n    //////////////////////////////////\n    /////////////  LOGIC  ///////////\n    ////////////////////////////////\n    public void solve() throws Exception{\n        int n=sc.ni();\n        int k=sc.ni();\n        int[] arr=new int[n];\n        for(int i=0;i<n;i++)\n            arr[i]=sc.ni();\n        HashMap<Integer,Long> map=new HashMap<Integer,Long>();\n        int xor=arr[0];\n        map.put(xor,1L);\n        for(int i=1;i<n;i++){\n            xor^=arr[i];\n            map.put(xor,map.getOrDefault(xor,0L)+1);\n        }\n        Iterator<Integer> itr=map.keySet().iterator();\n        HashSet<Integer> set=new HashSet();\n        long ans=(Long.valueOf(n)*Long.valueOf(n+1))/Long.valueOf(2);\n        while(itr.hasNext()){\n            int x=itr.next();\n            if(set.contains(x))\n            continue;\n            int y=((1<<k)-1)^x;\n            long f=map.get(x)+map.getOrDefault(y,0L),min=Long.MAX_VALUE;\n            for(long i=0;i<=f;i++){\n                long val = nc2(i)+nc2(f-i) + ((x==0L||y==0L) ? i:0L);\n                min=Math.min(min,val);\n            }\n            ans-=min;\n            set.add(x);set.add(y);\n        }\n        pw.println(ans);\n    }\n    public long nc2(long n){\n        return n*(n-1L)/2L;\n    }\n}\n", "complexity": "nlogn", "problem": "1054_D", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class DigitSeq {\n\n\tstatic class FastReader { \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n\n\t\tpublic FastReader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n\n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException  e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n\n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n\n\t\tlong nextLong() \n\t\t{ \n\t\t\treturn Long.parseLong(next()); \n\t\t} \n\n\t\tdouble nextDouble() \n\t\t{ \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n\n\t\tString nextLine() \n\t\t{ \n\t\t\tString str = \"\"; \n\t\t\ttry\n\t\t\t{ \n\t\t\t\tstr = br.readLine(); \n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{ \n\t\t\t\te.printStackTrace(); \n\t\t\t} \n\t\t\treturn str; \n\t\t} \n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tFastReader sc = new FastReader();\n\t\tOutputStream outputstream = System.out;\n\t\tPrintWriter out = new PrintWriter(outputstream);\n\n\t\tlong n = sc.nextLong();\n\t\tlong[] arr = new long[14];\n\t\tfor(int i = 1; i <= 13; i++){\n\t\t\tarr[i] = (long)Math.pow(10, i)-(long)Math.pow(10, i-1);\n\t\t}\n\t\tlong total = 0;\n\t\t/*for(int i = 1; i <= 13; i++) out.print(arr[i] + \" \");\n\t\tout.println();*/\n\t\tfor(int i = 1; i <= 13; i++){\n\t\t\tif(total+(long)i*arr[i]>=n){\n\t\t\t\tlong ans = n-total;\n\t\t\t\tlong rest = ans;\n\t\t\t\t//System.out.println(rest);\n\t\t\t\tif(ans%i!=0){\n\t\t\t\t\tans /= i;\n\t\t\t\t\tans++;\n\t\t\t\t} else {\n\t\t\t\t\tans /= i;\n\t\t\t\t}\n\t\t\t\tans += (long)Math.pow(10, i-1)-1;\n\t\t\t\tString str = Long.toString(ans);\n\t\t\t\tint ind = (rest%i==0) ? i-1 : (int)(rest%i)-1;\n\t\t\t\t//System.out.println(ind);\n\t\t\t\tout.println(str.charAt(ind));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttotal = total+(long)i*arr[i];\n\t\t\t//System.out.println(total);\n\t\t}\n\t\tout.close();\n\t}\n\n}", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class P111C{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint h, w;\n\n\tvoid run(){\n\t\th=sc.nextInt();\n\t\tw=sc.nextInt();\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tn=w*h;\n\t\tg=new long[n];\n\t\tint[] dx={0, 0, -1, 1};\n\t\tint[] dy={-1, 1, 0, 0};\n\t\tfor(int y=0; y<h; y++){\n\t\t\tfor(int x=0; x<w; x++){\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\tint x2=x+dx[k];\n\t\t\t\t\tint y2=y+dy[k];\n\t\t\t\t\tif(x2>=0&&x2<w&&y2>=0&&y2<h){\n\t\t\t\t\t\tg[y*w+x]|=1L<<(y2*w+x2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmds=(1L<<n)-1;\n\t\tmds(0, 0, 0);\n\t\tprintln((n-Long.bitCount(mds))+\"\");\n\t}\n\n\tint n;\n\tlong[] g;\n\tlong mds;\n\n\tvoid mds(long choosed, long removed, long covered){\n\t\tif(Long.bitCount(choosed)>=Long.bitCount(mds))\n\t\t\treturn;\n\t\tif(covered==((1L<<n)-1)){\n\t\t\tif(Long.bitCount(choosed)<Long.bitCount(mds))\n\t\t\t\tmds=choosed;\n\t\t\treturn;\n\t\t}\n\n\t\tint k=-1;\n\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\tfor(long remained=~removed&((1L<<n)-1); remained!=0; remained&=remained-1){\n\t\t\tint i=Long.numberOfTrailingZeros(remained);\n\t\t\tif((covered>>>i&1)==1){\n\t\t\t\tif(Long.bitCount(g[i]&~covered)==0){\n\t\t\t\t\tmds(choosed, removed|(1L<<i), covered);\n\t\t\t\t\treturn;\n\t\t\t\t}else if(Long.bitCount(g[i]&~covered)==1\n\t\t\t\t\t\t&&(g[i]&~covered&~removed)!=0){\n\t\t\t\t\tmds(choosed, removed|(1L<<i), covered);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(Long.bitCount(g[i]&~removed)==0){\n\t\t\t\t\tmds(choosed|(1L<<i), removed|(1L<<i), covered|(1L<<i)|g[i]);\n\t\t\t\t\treturn;\n\t\t\t\t}else if(Long.bitCount(g[i]&~removed)==1\n\t\t\t\t\t\t&&((g[i]&~removed)|(g[i]&~covered))==(g[i]&~removed)){\n\t\t\t\t\tint j=Long.numberOfTrailingZeros(g[i]&~removed);\n\t\t\t\t\tmds(choosed|(1L<<j), removed|(1L<<i)|(1L<<j), covered\n\t\t\t\t\t\t\t|(1L<<j)|g[j]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if(k==-1||Long.bitCount(g[i]&~covered)>Long.bitCount(g[k]&~covered))\n\t\t\t// k=i;\n\t\t\tif(k==-1||Long.bitCount(g[i]&~covered)>Long.bitCount(g[k]&~covered)){\n\t\t\t\tlist.clear();\n\t\t\t\tlist.add(i);\n\t\t\t\tk=i;\n\t\t\t}else if(Long.bitCount(g[i]&~covered)==Long.bitCount(g[k]&~covered))\n\t\t\t\tlist.add(i);\n\t\t}\n\t\tif(k==-1)\n\t\t\treturn;\n\t\t\n\t\tk=list.get((int)(list.size()*random()));\n\n\t\tmds(choosed|(1L<<k), removed|(1L<<k), covered|(1L<<k)|g[k]);\n\t\tmds(choosed, removed|(1L<<k), covered);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args){\n\t\tLocale.setDefault(Locale.US);\n\t\tnew P111C().run();\n\t}\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        new Main().run(in, out);\n        out.close();\n    }\n\n    public static long mod = 17352642619633L;\n\n    void run(FastScanner in, PrintWriter out) {\n\n        int N = in.nextInt();\n        int K = in.nextInt();\n\n        char[] ca = in.next().toCharArray();\n\n        LinkedList<Integer> ll = new LinkedList<>();\n\n        int totallen = 0;\n        // start pos, endpos length\n        LinkedList<int[]> added = new LinkedList<>();\n\n\n        for (int i = 0; i < ca.length && totallen < K; i++) {\n            if (ca[i] == '(') {\n                ll.offerLast(i);\n            } else {\n\n                int start = ll.pollLast();\n                int newlen = i-start+1;\n\n                while (!added.isEmpty() && added.peekLast()[0] > start) {\n                    int[] top = added.pollLast();\n                    newlen -= top[2];\n                }\n\n                totallen += newlen;\n                added.offerLast(new int[] {start, i, i-start+1});\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int[] t : added) {\n            for (int i = t[0]; i <= t[1]; i++) sb.append(ca[i]);\n        }\n        out.println(sb.toString());\n\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n            st = null;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "complexity": "linear", "problem": "1023_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\n    public void solve() throws IOException  {\n\n        int tt = readInt();\n        for (int t = 0; t < tt; t++) {\n            done = false;\n            n = readInt();\n            a = new int[n];\n            prefixes = new int[n][];\n            prefixes[0] = new int[0];\n            for (int i = 0; i < n; i++) {\n                a[i] = readInt();\n            }\n            int[] levels = new int[] {1};\n            find(levels, 1);\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < prefixes[i].length - 1; j++) {\n                    out.print(prefixes[i][j] + \".\");\n                }\n                out.println(a[i]);\n            }\n\n\n        }\n    }\n    int[] a;\n    int n;\n    boolean done;\n    int[][] prefixes;\n\n    void find(int[] levels, int position) {\n        if (position == n) {\n            done = true;\n            return;\n        }\n\n        int value = a[position];\n        if (value == 1) {\n            int[] newlevels = Arrays.copyOf(levels, levels.length + 1);\n            newlevels[levels.length] = 1;\n            prefixes[position] = newlevels;\n            find(newlevels, position + 1);\n        }\n        for (int i = levels.length - 1; i >= 0; i--) {\n            if (value == levels[i] + 1) {\n\n                int[] newlevels = Arrays.copyOf(levels, i + 1);\n                newlevels[i]++;\n                prefixes[position] = newlevels;\n                find(newlevels, position + 1);\n                if (done) {\n                    return;\n                }\n\n                prefixes[position] = null;\n            }\n        }\n    }\n\n\n    /////////////////////////////////////////\n\n\n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(\"input.txt\").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            solve();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n\n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    @SuppressWarnings(\"unused\")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private PrintWriter out;\n\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"\", 256 * (1L << 20)).start();\n    }\n\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Blah\n{\n    public static void main(String args[])\n    {\n\tScanner c = new Scanner(System.in);\n\tString number = c.nextLine();\n\tint i = Integer.parseInt(number);\n\tif (i == 1)\n\t    {\n\t\tSystem.out.println(\"NO\");\n\t\treturn;\n\t    }\n\tString line = c.nextLine();\n\tString[] arr = line.split(\" \");\n\tint[] array = new int[i];\n\tfor (int j = 0; j < i; j++)\n\t    {\n\t\tarray[j] = Integer.parseInt(arr[j]);\n\t    }\n        int min = array[0];\n\tint second = 0;\n\tboolean thing = false;\n\tfor (int j = 0; j < i; j++)\n\t    {\n\t\tif (!thing && array[j] > min)\n\t\t    {\n\t\t\tsecond = array[j];\n\t\t\tthing = true;\n\t\t    }\n\t\tif (array[j] < min)\n\t\t    {\n\t\t\tsecond = min;\n\t\t\tmin = array[j];\n\t\t\tthing = true;\n\t\t    }\n\t\telse if (thing && array[j] > min && array[j] < second)\n\t\t    second = array[j];\n\t    }\n\tif (!thing)\n\t    System.out.println(\"NO\");\n\telse\n\t    System.out.println(second);\n\treturn;\t     \n    }\n}", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tString next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws Exception {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() throws Exception {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() throws Exception {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tvoid solve() throws Exception {\n\t\tint n = nextInt(), k = nextInt(), s = nextInt();\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = -nextInt();\n\t\t\n\t\tArrays.sort(a);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif (s>=k)\n\t\t\t{\n\t\t\t\tout.println(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ts += -a[i];\n\t\t\ts--;\n\t\t}\n\t\tif (s<k)\n\t\t\tout.println(-1);\n\t\telse\n\t\t\tout.println(n);\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A().run();\n\t}\n\n\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport static java.lang.System.out;\n\npublic class Flatville\n{\n    public static void main( String args[] )\n    {\n        class SquareHouse implements Comparable<SquareHouse>\n        {\n            public SquareHouse( double posLeft, double sideLen )\n            { \n                _posLeft = posLeft;\n                _sideLen = sideLen;\n            }\n\n            public double posLeft()\n            { return _posLeft; }\n\n            public double posRight()\n            { return _posLeft + _sideLen; }\n\n            public int compareTo( SquareHouse house )\n            {\n                double dist = _posLeft - house.posLeft();\n                if ( dist < 0 )\n                    return -1;\n                else if ( dist > 0 )\n                    return 1;\n                else return 0;\n            }\n\n            private double _posLeft;\n            private double _sideLen;\n        }\n\n        Scanner scanner = new Scanner( System.in );\n\n        // Read the header\n        final int nHouses    = scanner.nextInt();\n        final double sideLen = scanner.nextDouble();\n\n        ArrayList<SquareHouse> houses = new ArrayList<SquareHouse>();\n\n        // Read the houses\n        for ( int iHouse = 0; iHouse < nHouses; ++iHouse )\n        {\n            double pos  = scanner.nextDouble();\n            double size = scanner.nextDouble();\n            double posLeft = pos - size / 2.0;\n            houses.add( new SquareHouse( posLeft, size ) );\n        }\n\n        // Sort the houses\n        Collections.sort( houses );\n\n        int nPositions = 2;\n        for ( int iHouse = 0; iHouse < nHouses - 1; ++iHouse )\n        {\n            double space = houses.get( iHouse + 1 ).posLeft() - houses.get( iHouse ).posRight();\n            if ( sideLen < space )\n                nPositions += 2;\n            else if ( sideLen == space )\n                nPositions++;\n        }\n\n        out.println( nPositions );\n    }\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\n\nimport java.lang.reflect.*;\n\n\n\npublic class D {\n\n\n\n\tfinal int MOD = (int)1e9 + 7;\n\n\tfinal double eps = 1e-12;\n\n\tfinal int INF = (int)1e9;\n\n\t\n\n\tpublic D () {\n\n\t\tlong L = sc.nextLong();\n\n\t\tlong R = sc.nextLong();\n\n\t\t\n\n\t\tint Z = 64 - Long.numberOfLeadingZeros(L ^ R);\n\n\t\tlong res = (1L << Z) - 1;\n\n\t\texit(res);\n\n\t}\n\n\n\n\t////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\t/* Dear hacker, don't bother reading below this line, unless you want to help me debug my I/O routines :-) */\n\n\t\n\n\tstatic MyScanner sc = new MyScanner();\n\n\t\n\n\tstatic class MyScanner {\n\n\t\tpublic String next() {\n\n\t\t\tnewLine();\n\n\t\t\treturn line[index++];\n\n\t\t}\n\n\t\t\n\n\t\tpublic char nextChar() {\n\n\t\t\treturn next().charAt(0);\n\n\t\t}\n\n\t\t\t\t\n\n\t\tpublic int nextInt() {\n\n\t\t\treturn Integer.parseInt(next());\n\n\t\t}\n\n\t\t\n\n\t\tpublic long nextLong() {\n\n\t\t\treturn Long.parseLong(next());\n\n\t\t}\n\n\t\t\n\n\t\tpublic double nextDouble() {\n\n\t\t\treturn Double.parseDouble(next());\n\n\t\t}\n\n\t\t\n\n\t\tpublic String nextLine() {\n\n\t\t\tline = null;\n\n\t\t\treturn readLine();\n\n\t\t}\n\n\t\t\n\n\t\tpublic String [] nextStrings() {\n\n\t\t\tline = null;\n\n\t\t\treturn readLine().split(\" \");\n\n\t\t}\n\n\t\t\n\n\t\tpublic char [] nextChars() {\n\n\t\t\treturn next().toCharArray();\n\n\t\t}\n\n\n\n\t\tpublic Integer [] nextInts() {\n\n\t\t\tString [] L = nextStrings();\n\n\t\t\tInteger [] res = new Integer [L.length];\n\n\t\t\tfor (int i = 0; i < L.length; ++i)\n\n\t\t\t\tres[i] = Integer.parseInt(L[i]);\n\n\t\t\treturn res;\n\n\t\t}\t\n\n\t\t\n\n\t\tpublic Long [] nextLongs() {\n\n\t\t\tString [] L = nextStrings();\n\n\t\t\tLong [] res = new Long [L.length];\n\n\t\t\tfor (int i = 0; i < L.length; ++i)\n\n\t\t\t\tres[i] = Long.parseLong(L[i]);\n\n\t\t\treturn res;\n\n\t\t}\n\n\n\n\t\tpublic Double [] nextDoubles() {\n\n\t\t\tString [] L = nextStrings();\n\n\t\t\tDouble [] res = new Double [L.length];\n\n\t\t\tfor (int i = 0; i < L.length; ++i)\n\n\t\t\t\tres[i] = Double.parseDouble(L[i]);\n\n\t\t\treturn res;\n\n\t\t}\n\n\n\n\t\tpublic String [] next (int N) {\n\n\t\t\tString [] res = new String [N];\n\n\t\t\tfor (int i = 0; i < N; ++i)\n\n\t\t\t\tres[i] = sc.next();\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t\n\n\t\tpublic Integer [] nextInt (int N) {\n\n\t\t\tInteger [] res = new Integer [N];\n\n\t\t\tfor (int i = 0; i < N; ++i)\n\n\t\t\t\tres[i] = sc.nextInt();\n\n\t\t\treturn res;\n\n\t\t}\t\t\n\n\t\t\n\n\t\tpublic Long [] nextLong (int N) {\n\n\t\t\tLong [] res = new Long [N];\n\n\t\t\tfor (int i = 0; i < N; ++i)\n\n\t\t\t\tres[i] = sc.nextLong();\n\n\t\t\treturn res;\n\n\t\t}\t\t\n\n\t\t\n\n\t\tpublic Double [] nextDouble (int N) {\n\n\t\t\tDouble [] res = new Double [N];\n\n\t\t\tfor (int i = 0; i < N; ++i)\n\n\t\t\t\tres[i] = sc.nextDouble();\n\n\t\t\treturn res;\n\n\t\t}\t\t\n\n\t\t\n\n\t\tpublic String [][] nextStrings (int N) {\n\n\t\t\tString [][] res = new String [N][];\n\n\t\t\tfor (int i = 0; i < N; ++i)\n\n\t\t\t\tres[i] = sc.nextStrings();\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t\n\n\t\tpublic Integer [][] nextInts (int N) {\n\n\t\t\tInteger [][] res = new Integer [N][];\n\n\t\t\tfor (int i = 0; i < N; ++i)\n\n\t\t\t\tres[i] = sc.nextInts();\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t\n\n\t\tpublic Long [][] nextLongs (int N) {\n\n\t\t\tLong [][] res = new Long [N][];\n\n\t\t\tfor (int i = 0; i < N; ++i)\n\n\t\t\t\tres[i] = sc.nextLongs();\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t\n\n\t\tpublic Double [][] nextDoubles (int N) {\n\n\t\t\tDouble [][] res = new Double [N][];\n\n\t\t\tfor (int i = 0; i < N; ++i)\n\n\t\t\t\tres[i] = sc.nextDoubles();\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t\n\n\t\t//////////////////////////////////////////////\n\n\t\t\n\n\t\tprivate boolean eol() {\n\n\t\t\treturn index == line.length;\n\n\t\t}\n\n\n\n\t\tprivate String readLine() {\n\n\t\t\ttry {\n\n\t\t\t\treturn r.readLine();\n\n\t\t\t} catch (Exception e) {\n\n\t\t\t\tthrow new Error(e);\n\n\t\t\t}\n\n\t\t}\n\n\t\tprivate final BufferedReader r;\n\n\n\n\t\tMyScanner () {\n\n\t\t\tthis(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\t}\n\n\t\t\n\n\t\tMyScanner(BufferedReader r) {\n\n\t\t\ttry {\n\n\t\t\t\tthis.r = r;\n\n\t\t\t\twhile (!r.ready())\n\n\t\t\t\t\tThread.sleep(1);\n\n\t\t\t\tstart();\n\n\t\t\t} catch (Exception e) {\n\n\t\t\t\tthrow new Error(e);\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\tprivate String [] line;\n\n\t\tprivate int index;\n\n\n\n\t\tprivate void newLine() {\n\n\t\t\tif (line == null || eol()) {\n\n\t\t\t\tline = readLine().split(\" \");\n\n\t\t\t\tindex = 0;\n\n\t\t\t}\n\n\t\t}\t\t\n\n\t}\n\n\t\n\n\tstatic void print(Object o, Object... a) {\n\n\t\tprintDelim(\" \", o, a);\n\n\t}\n\n\t\n\n\tstatic void cprint(Object o, Object... a) {\n\n\t\tprintDelim(\"\", o, a);\n\n\t}\n\n\t\n\n\tstatic void printDelim (String delim, Object o, Object... a) {\n\n\t\tpw.println(build(delim, o, a));\n\n\t}\n\n\n\n\tstatic void exit (Object o, Object... a) {\n\n\t\tprint(o, a);\n\n\t\texit();\n\n\t}\n\n\n\n\tstatic void exit () {\n\n\t\tpw.close();\n\n\t\tSystem.out.flush();\n\n\t\tSystem.err.println(\"------------------\");\n\n\t\tSystem.err.println(\"Time: \" + ((millis() - t) / 1000.0));\n\n\t\tSystem.exit(0);\n\n\t}\n\n\t\n\n\tvoid NO() {\n\n\t\tthrow new Error(\"NO!\");\n\n\t}\n\n\t\n\n\t////////////////////////////////////////////////////////////////////////////////////\n\n\t\n\n\tstatic String build(String delim, Object o, Object... a) {\n\n\t\tStringBuilder b = new StringBuilder();\n\n\t\tappend(b, o, delim);\n\n\t\tfor (Object p : a)\n\n\t\t\tappend(b, p, delim);\n\n\t\treturn b.toString().trim();\t\t\n\n\t}\n\n\t\n\n\tstatic void append(StringBuilder b, Object o, String delim) {\n\n\t\tif (o.getClass().isArray()) {\n\n\t\t\tint L = Array.getLength(o);\n\n\t\t\tfor (int i = 0; i < L; ++i)\n\n\t\t\t\tappend(b, Array.get(o, i), delim);\n\n\t\t} else if (o instanceof Iterable<?>) {\n\n\t\t\tfor (Object p : (Iterable<?>)o)\n\n\t\t\t\tappend(b, p, delim);\n\n\t\t} else\n\n\t\t\tb.append(delim).append(o);\t\t\n\n\t}\n\n\t\n\n\t////////////////////////////////////////////////////////////////////////////////////\n\n\t\n\n\tpublic static void main(String[] args) {\n\n\t\tnew D();\n\n\t\texit();\n\n\t}\n\n\n\n\tstatic void start() {\n\n\t\tt = millis();\n\n\t}\n\n\n\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n\n\t\n\n\tstatic long t;\n\n\t\n\n\tstatic long millis() {\n\n\t\treturn System.currentTimeMillis();\n\n\t}\t\n\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ky112233\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        APetyaAndOrigami solver = new APetyaAndOrigami();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class APetyaAndOrigami {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int red = 2 * n;\n            int green = 5 * n;\n            int blue = 8 * n;\n            double cnt = 0;\n            cnt += Math.ceil((0.0 + red) / k);\n            cnt += Math.ceil((0.0 + green) / k);\n            cnt += Math.ceil((0.0 + blue) / k);\n            out.println((long) cnt);\n        }\n\n    }\n}\n\n", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.Scanner;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author BSRK Aditya\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        long numQuestions = in.nextInt();\n        long numCorrectlyAnsweredQuestions = in.nextInt();\n        long sizeForDoublingScore = in.nextInt();\n\n        long score = 0;\n\n        long numIncorrectlyAnsweredQuestions = numQuestions - numCorrectlyAnsweredQuestions;\n\n        long numDoublings = Math.max(numQuestions / sizeForDoublingScore - numIncorrectlyAnsweredQuestions, 0);\n        score += 2*sizeForDoublingScore*Long.parseLong(new BigInteger(\"2\").modPow(new BigInteger(String.valueOf(numDoublings)), new BigInteger(\"1000000009\")).subtract(BigInteger.ONE).toString());\n        score += numCorrectlyAnsweredQuestions - sizeForDoublingScore*numDoublings;\n        score %= 1000000009;\n\n        out.println(score);\n    }\n}\n\n", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        long a=s.nextLong(), b=s.nextLong();\n        long c=0;\n        while(true)  {\n            if(a==b ){\n                System.out.println(c+a);\n                return ;\n            } else if(b==a+1){\n                c+=1;\n                b=a;\n            } else if(b<a){\n\n                long h = a/b-1;\n                if(h<=0){\n                    a-=b;c++;continue;\n                }\n                a-=b*h;\n                c+=h;\n            } else{\n                if(a==1){\n                    long t = b-a;\n                    b = t;\n                    c+=t;\n                    b = a;\n                    continue;\n                }\n                long t = b-a;\n                long h = b/a - 1 ;\n                if(h<=0){\n                    b = t;\n                    c+=1;continue;\n                }\n                c+=h;b-=h*a;\n//                b = a;\n            }\n        }\n\n//        System.out.println(c);\n    }\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\n\npublic class bignumbers {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tlong s = in.nextLong();\n\t\tin.close();\n\n\t\tlong max = (long) Math.ceil((double) s/9) * 10;\n\t\tlong min = Math.min(s, max);\n\t\tlong x = 0, sum = 0, temp = 0;\n\t\t\n\t\twhile(min + 1 < max)\n\t\t{\n\t\t\tx = (min + max)/2; \n\t\t\tsum = 0;\n\t\t\ttemp = x;\n\t\t\twhile(temp>0)\n\t\t\t{\n\t\t\t\tsum += temp%10;\n\t\t\t\ttemp /= 10;\n\t\t\t}\n\t\t\t\n\t\t\tif(x-sum >= s)\n\t\t\t\tmax = x;\n\t\t\telse\n\t\t\t\tmin = x;\n\t\t\t\n\t\t}\n\t\t\n\t\tif(max == 0)\n\t\t\tSystem.out.println(n);\n\t\telse if(n-max < 0)\n\t\t\tSystem.out.println(0);\n\t\telse\n\t\t\tSystem.out.println(n-max+1);\n\n\t}\n\n}\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class C {\n\t\n\tpublic static void main(String[] args){\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tString[] ins = new String[N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tins[i] = sc.next();\n\t\t\t}\n\t\t\t\n\t\t\tfinal long MOD = 1000000007;\n\t\t\tlong[] DP = new long[N];\n\t\t\tlong[] nextDP = new long[N];\n\t\t\t\n\t\t\tDP[0] = 1;\n\t\t\t\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tArrays.fill(nextDP, 0);\n\t\t\t\tif(\"f\".equals(ins[i - 1])){\n\t\t\t\t\tfor(int j = 0; j < N - 1; j++){\n\t\t\t\t\t\tnextDP[j + 1] += DP[j];\n\t\t\t\t\t\tnextDP[j + 1] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int j = N - 1; j >= 0; j--){\n\t\t\t\t\t\tnextDP[j] += DP[j];\n\t\t\t\t\t\tnextDP[j] %= MOD;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(j < N - 1){\n\t\t\t\t\t\t\tnextDP[j] += nextDP[j + 1];\n\t\t\t\t\t\t\tnextDP[j] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tlong[] tmp = DP;\n\t\t\t\t\tDP = nextDP;\n\t\t\t\t\tnextDP = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong answer = 0;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tanswer += DP[i];\n\t\t\t\tanswer %= MOD;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() {\n\t\t\ttry {\n\t\t\t\twhile (!hasNext()) {\n\t\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t} catch (IOException e) { /* ignore */\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) { /* ignore */\n\t\t\t}\n\t\t}\n\t}\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author madis\n */\npublic class Pjar {\n\n    static int a[][];\n\n    public static void main(String[] args) throws FileNotFoundException {\n        Scanner in = new Scanner(new File(\"input.txt\"));\n        PrintWriter out = new PrintWriter(\"output.txt\");\n\n        int N = in.nextInt();\n        int M = in.nextInt();\n\n        a = new int[N][M];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                a[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        int k = in.nextInt();\n        in.nextLine();\n        for (int i = 0; i < k; i++) {\n            int x = in.nextInt();\n            int y = in.nextInt();\n            a[x - 1][y - 1] = 1;\n            burn(x - 1, y - 1);\n        }\n        int max = Integer.MIN_VALUE;\n        int x = 0;\n        int y = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                if(a[i][j]>max){\n                    max = a[i][j];\n                    x = i+1;\n                    y = j+1;\n                }\n            }\n        }\n        out.printf(\"%d %d\",x,y);\n        out.close();\n        in.close();\n    }\n\n    static void burn(int i, int j) {\n        for(int k = 0;k<a.length;k++){\n            for(int l=0;l<a[k].length;l++){\n                if(a[k][l]>Math.abs(k-i) + Math.abs(l-j)){\n                    a[k][l]=Math.abs(k-i) + Math.abs(l-j);\n                }\n            }\n        }\n    }\n}\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.math.BigInteger.*;\nimport static java.lang.Character.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class A {\n    public void run() {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        int n = s.length();\n        String[] ss = new String[n];\n        for (int i = 0; i < n; i++)\n            ss[i] = s.substring(i);\n        sort(ss);\n        int res = 0;\n        for (int i = 1; i < n; i++)\n            res = max(res, count(ss[i - 1], ss[i]));\n        System.out.println(res);\n    }\n\n    int count(String s, String t) {\n        int ret = 0;\n        for (int i = 0; i < min(s.length(), t.length()); i++)\n            if (s.charAt(i) != t.charAt(i))\n                return ret;\n            else\n                ret++;\n        return ret;\n    }\n\n    void debug(Object... os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n\n    public static void main(String... args) {\n        new A().run();\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class node\n\t{\n\t\tint a,b,v;\n\t\tpublic node(int a,int b,int v)\n\t\t{\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t\tthis.v=v;\n\t\t}\n\t}\n\tstatic int inf=0x3f3f3f3f;\n\tpublic static void main(String[]args) throws IOException {\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in();\n\t\tint m=in();\n\t\tint num=in();\n\t\tif(num%2==1) {\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tout.print(\"-1 \");\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\tout.flush();\n\t\t\treturn;\n\t\t}\n\t\tArrayList<node>[][]map=new ArrayList[n][m];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tmap[i][0]=new ArrayList<node>();\n\t\t\tfor(int j=1;j<m;j++) {\n\t\t\t\tmap[i][j]=new ArrayList<node>();\n\t\t\t\tint v=in();\n\t\t\t\tmap[i][j-1].add(new node(i,j,v));\n\t\t\t\tmap[i][j].add(new node(i,j-1,v));\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tint v=in();\n\t\t\t\tmap[i-1][j].add(new node(i,j,v));\n\t\t\t\tmap[i][j].add(new node(i-1,j,v));\n\t\t\t}\n\t\t}\n\t\tnum>>=1;\n\t\tint [][][]dp=new int[n][m][num+1];\n\t\tfor(int k=1;k<=num;k++) {\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tdp[i][j][k]=inf;\n\t\t\t\t\tfor(node node:map[i][j]) {\n\t\t\t\t\t\tdp[i][j][k]=Math.min(dp[i][j][k],dp[node.a][node.b][k-1]+node.v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tout.print((dp[i][j][num]<<1)+\" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\tstatic PrintWriter out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\tpublic static double ind() throws IOException {\n\t\tin.nextToken();\n\t\treturn in.nval;\n\t}\n\tpublic static int in() throws IOException {\n\t\tin.nextToken();\n\t\treturn(int)in.nval;\n\t}\n\tpublic static long inl() throws IOException {\n\t\tin.nextToken();\n\t\treturn(long)in.nval;\n\t}\n\tpublic static String ins()throws IOException{\n\t\tin.nextToken();\n\t\treturn in.sval;\n\t}\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "//package round584;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class A {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(n);\n\t\tArrays.sort(a);\n\t\tboolean[] done = new boolean[n];\n\t\tint ans = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(!done[i]){\n\t\t\t\tans++;\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tif(a[j] % a[i] == 0){\n\t\t\t\t\t\tdone[j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new A().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "\nimport java.util.Scanner;\npublic class one\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tlong a = 2;\n\t\tScanner scan =new Scanner(System.in);\n\t\tint i,j,k;\n\t\ti = scan.nextInt();\n\t\tj = scan.nextInt();\n\t\tfor(k=1;k<i;k++) {\n\t\t\ta = a*2;\n\t\t\tif(a>j) {\n\t\t\t\tSystem.out.println(j);\n\t\t\t\treturn;}}\n\t\t//System.out.println(a);\n\t\t\ta = j % a;\n\t\tSystem.out.println(a);\n\t}\n}\n\n\n", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class NewYearAndCurling {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tStringTokenizer t = new StringTokenizer(in.readLine());\n\t\tint N = Integer.parseInt(t.nextToken());\n\t\tint R = Integer.parseInt(t.nextToken());\n\t\tint[] x = new int[N];\n\t\tt = new StringTokenizer(in.readLine());\n\t\tfor(int i = 0; i < N; ++i)\n\t\t\tx[i] = Integer.parseInt(t.nextToken());\n\t\tdouble[] y = new double[N];\n\t\tfor(int i = 0; i < N; ++i) {\n\t\t\tdouble max = R;\n\t\t\tfor(int j = 0; j < i; ++j ) {\n\t\t\t\tint xDiff = Math.abs(x[i] - x[j]);\n\t\t\t\tif(xDiff <= 2 * R)\n\t\t\t\t\tmax = Math.max(max, y[j] + Math.sqrt(4*R*R - xDiff*xDiff));\n\t\t\t}\n\t\t\ty[i] = max;\n\t\t}\n\t\tout.print(y[0]);\n\t\tfor(int i = 1; i < N; ++i)\n\t\t\tout.print(\" \" + y[i]);\n\t\tout.println();\n\t\tin.close();\n\t\tout.close();\n\t}\n}", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.SplittableRandom;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        final static int SAMPLES = 100;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            SplittableRandom splittableRandom = new SplittableRandom(System.currentTimeMillis());\n            int n = in.readInt();\n            int numQueries = in.readInt();\n            int[] a = IOUtils.readIntArray(in, n);\n            MiscUtils.decreaseByOne(a);\n            int aMax = ArrayUtils.maxElement(a);\n            Query[] queries = new Query[numQueries];\n            for (int i = 0; i < queries.length; i++) {\n                queries[i] = new Query(in.readInt() - 1, in.readInt() - 1, in.readInt(), i);\n            }\n            int blockSize = (int) Math.sqrt(n);\n            for (Query query : queries) {\n                query.BLOCK = query.left / blockSize;\n            }\n            Query[] originalQueries = queries.clone();\n            Arrays.sort(queries, new Comparator<Query>() {\n                public int compare(Query o1, Query o2) {\n                    if (o1.BLOCK != o2.BLOCK) {\n                        return Integer.compare(o1.BLOCK, o2.BLOCK);\n                    }\n                    return Integer.compare(o1.right, o2.right);\n//                return o1.BLOCK % 2 == 0 ? Integer.compare(o1.right, o2.right) : -Integer.compare(o1.right, o2.right);\n                }\n            });\n            int[] counts = new int[aMax + 1];\n            int leftPtr = 0, rightPtr = -1;\n            for (Query query : queries) {\n                while (leftPtr < query.left) {\n                    counts[a[leftPtr++]]--;\n                }\n                while (leftPtr > query.left) {\n                    counts[a[--leftPtr]]++;\n                }\n                while (rightPtr < query.right) {\n                    counts[a[++rightPtr]]++;\n                }\n                while (rightPtr > query.right) {\n                    counts[a[rightPtr--]]--;\n                }\n                // count * k > r - l + 1\n                int res = 1000 * 1000 * 1000;\n                for (int SAMPLE = 0; SAMPLE < SAMPLES; SAMPLE++) {\n                    int val = a[query.left + splittableRandom.nextInt(query.right - query.left + 1)];\n                    int count = counts[val];\n                    if (count * query.k > query.right - query.left + 1) {\n                        res = Math.min(res, val);\n                    }\n                }\n                if (res >= 1000 * 1000 * 1000) {\n                    query.res = -1;\n                } else {\n                    query.res = res + 1;\n                }\n            }\n            for (Query query : originalQueries) {\n                out.printLine(query.res);\n            }\n        }\n\n        class Query {\n            int left;\n            int right;\n            int k;\n            int index;\n            int BLOCK;\n            int res;\n\n            public Query(int left, int right, int k, int index) {\n                this.left = left;\n                this.right = right;\n                this.k = k;\n                this.index = index;\n            }\n        }\n    }\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n    }\n    static interface IntReversableCollection extends IntCollection {\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n    }\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n        public boolean advance();\n        public boolean isValid();\n    }\n    static class ArrayUtils {\n        public static int maxElement(int[] array) {\n            return new IntArray(array).max();\n        }\n    }\n    static class MiscUtils {\n        public static void decreaseByOne(int[]... arrays) {\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i]--;\n                }\n            }\n        }\n    }\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n        public abstract void removeAt(int index);\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n    }\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n        default public int max() {\n            int result = Integer.MIN_VALUE;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                int current = it.value();\n                if (current > result) {\n                    result = current;\n                }\n            }\n            return result;\n        }\n    }\n    static interface IntCollection extends IntStream {\n        public int size();\n    }\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public int get(int at) {\n            return data[at];\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n    }\n    static class IOUtils {\n        public static int[] readIntArray(InputReader in, int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = in.readInt();\n            }\n            return array;\n        }\n    }\n}\n\n", "complexity": "cubic", "problem": "0840_D", "from": "CODEFORCES", "tags": "data structures,probabilities"}
{"src": "// package com.prituladima;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.IntStream;\n\npublic class C {\n\n    private void solve_() {\n        int n = nextInt();\n        int[] a = nextArr(n);\n\n        LinkedList<Integer> list = new LinkedList<>();\n        list.add(a[0]);\n        println(a[0]);\n\n        for (int i = 1; i < n; i++) {\n            if (a[i] != 1) {\n                while (list.size() > 1 && !Objects.equals(list.getLast() + 1, a[i]) ) {\n                    list.removeLast();\n                }\n                list.removeLast();\n            }\n            list.addLast(a[i]);\n            StringBuilder sb = new StringBuilder();\n            for (int j : list) {\n                sb.append('.').append(j);\n            }\n            println(sb.substring(1));\n        }\n\n\n//        if (a[0] != 1) {\n//            throw new RuntimeException(\"!=1\");\n//        }\n        if (false) {\n            println(1);\n//        char[] s = new char[1020];\n            StringBuilder s = new StringBuilder();\n            s.append(\".\");\n            s.append(\"1\");\n\n            for (int i = 1; i < n; i++) {\n                if (a[i] == 1) {\n                    s.append('.');\n                    s.append('1');\n                    println(s.substring(1));\n                } else if (a[i - 1] + 1 == a[i]) {\n                    s.setLength(s.length() - 1 - String.valueOf(a[i - 1]).length());\n                    s.append('.');\n                    s.append(a[i]);\n//                println(s);\n                    println(s.substring(1));\n                } else if (a[i - 1] == a[i]) {\n                    for (int j = s.length() - 1; j >= 0; j--) {\n                        if (s.charAt(j) == '.') {\n                            s.setLength(j);\n                            break;\n                        }\n                    }\n                    for (int j = s.length() - 1; j >= 0; j--) {\n                        if (s.charAt(j) == '.') {\n                            s.setLength(j);\n                            break;\n                        }\n                    }\n\n                    s.append('.');\n                    s.append(a[i]);\n//                println(s);\n                    println(s.substring(1));\n                }\n\n            }\n        }\n//        dfs(root);\n    }\n\n    private void dfs(TreeNode treeNode) {\n        for (int i = 0; i < treeNode.val.size(); i++) {\n            if (treeNode.parent != null) {\n                print(\".\");\n            }\n            print(i + 1);\n            dfs(treeNode.val.get(i));\n            //leaf println()\n        }\n    }\n\n    class TreeNode {\n        TreeNode parent;\n        int size;\n        List<TreeNode> val = new ArrayList<>();\n\n        public TreeNode(TreeNode parent) {\n            this.parent = parent;\n            size = 1;\n        }\n\n        void put(int numb) {\n\n        }\n    }\n\n    private void solve() {\n        int t = nextInt();\n        for (int i = 0; i < t; i++) {\n            solve_();\n        }\n    }\n\n    public static void main(String[] args) {\n        new C().run();\n    }\n\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private PrintWriter writer;\n\n    private void run() {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n             PrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out))) {\n            this.reader = reader;\n            this.writer = writer;\n            this.tokenizer = null;\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n\n    private int nextInt(int radix) {\n        return Integer.parseInt(nextToken(), radix);\n    }\n\n    private int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong(int radix) {\n        return Long.parseLong(nextToken(), radix);\n    }\n\n    private long nextLong() {\n        return Long.parseLong(nextToken());\n    }\n\n    private double nextDouble() {\n        return Double.parseDouble(nextToken());\n    }\n\n    private int[] nextArr(int size) {\n        return Arrays.stream(new int[size]).map(c -> nextInt()).toArray();\n    }\n\n    private long[] nextArrL(int size) {\n        return Arrays.stream(new long[size]).map(c -> nextLong()).toArray();\n    }\n\n    private double[] nextArrD(int size) {\n        return Arrays.stream(new double[size]).map(c -> nextDouble()).toArray();\n    }\n\n    private char[][] nextCharMatrix(int n) {\n        return IntStream.range(0, n).mapToObj(i -> nextToken().toCharArray()).toArray(char[][]::new);\n    }\n\n    private int[][] nextIntMatrix(final int n, final int m) {\n        return IntStream.range(0, n).mapToObj(i -> nextArr(m)).toArray(int[][]::new);\n    }\n\n    private double[][] nextDoubleMatrix(final int n, final int m) {\n        return IntStream.range(0, n).mapToObj(i -> nextArrD(m)).toArray(double[][]::new);\n    }\n\n    private String nextToken() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    private void printf(String format, Object... args) {\n        writer.printf(format, args);\n    }\n\n    private void print(Object o) {\n        writer.print(o);\n    }\n\n    private void println() {\n        writer.println();\n    }\n\n    private void println(Object o) {\n        print(o);\n        println();\n    }\n\n    private void flush() {\n        writer.flush();\n    }\n\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class A {\n\n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    class Pointd implements Comparable<Pointd>{\n        int x, in;\n\n        @Override\n        public int compareTo(Pointd o) {\n            if(x > o.x) return 1;\n            if(x < o.x) return -1;\n            if(in < o.in) return -1;\n            if(in > o.in) return 1;\n            return 0;\n        }\n\n        public Pointd(int x, int in) {\n            super();\n            this.x = x;\n            this.in = in;\n        }\n    }\n    \n    void solve() throws IOException {\n        int n = readInt();\n        Pointd[] a = new Pointd[n];\n        for(int i = 0; i < n; i++){\n            a[i] = new Pointd(readInt(), i);\n        }\n        Arrays.sort(a);\n        \n        int count = 0;\n        for(int i = 0; i < n; i++){\n            if(a[i].x != a[a[i].in].x) count++;\n        }\n        if(count == 0 || count == 2) out.println(\"YES\");\n        else out.println(\"NO\");\n    }\n    \n\n    void init() throws FileNotFoundException {\n        if (ONLINE_JUDGE) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    int[] readArr(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = readInt();\n        }\n        return res;\n    }\n\n    long[] readArrL(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = readLong();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        new A().run();\n    }\n\n    public void run() {\n        try {\n            long t1 = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \" + (t2 - t1));\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n}", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\nimport java.text.*;\nimport java.math.*;\n\npublic class Main{\n    \n    static double EPS=1e-10;\n    static double PI=Math.acos(-1.0);\n    \n    static double p[][]=new double[25][25];\n    static double f[]=new double[1<<20];\n    static int n;\n    \n    \n    public static void PR(String s){\n        System.out.print(s);\n    }\n    \n    public static void PR(double s)\n    {\n        java.text.DecimalFormat d=new java.text.DecimalFormat(\"#.0000000\");\n        System.out.print(d.format(s));\n    }\n    \n    public static void DP()\n    {\n        int i,j,k,cnt;\n        for(i=0;i<(1<<n);i++) f[i]=0;\n        f[(1<<n)-1]=1;\n        for(k=(1<<n)-1;k>=0;k--)\n        {\n            cnt=0;\n            for(i=0;i<n;i++) if((k&(1<<i))!=0) cnt++;\n            for(i=0;i<n;i++) if((k&(1<<i))!=0)\n            {\n                for(j=0;j<n;j++) if(i!=j&&(k&(1<<j))!=0)\n                {\n                    f[k^(1<<j)]+=f[k]*p[i][j]/((cnt-1)*cnt/2);\n                }\n            }\n        }\n    }\n    \n    public static void main(String[] args){\n  \n        Scanner S=new Scanner(System.in);\n        while(S.hasNext())\n        {\n            n=S.nextInt();\n            int i,j;\n            for(i=0;i<n;i++) for(j=0;j<n;j++) p[i][j]=S.nextDouble();\n            DP();\n            for(i=0;i<n;i++) \n            {\n                if(i!=0) PR(\" \");\n                PR(f[1<<i]);\n            }\n            PR(\"\\n\");\n        }\n    }\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.awt.*;\n\nimport java.awt.geom.*;\n\nimport java.io.*;\n\nimport java.math.*;\n\nimport java.text.*;\n\nimport java.util.*;\n\n\n\n\n\n/*\n\n\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\n\tpw = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n\n\tbr = new BufferedReader(new InputStreamReader(System.in));\n\n\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n\n\n */\n\n\n\npublic class Main {\n\n\tprivate static BufferedReader br;\n\n\tprivate static StringTokenizer st;\n\n\tprivate static PrintWriter pw;\n\n\n\n\tstatic final long MAX = 1L << 50;\n\n\n\n\tpublic static void main(String[] args) throws IOException\t{\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n\t\t//int qq = 1;\n\n\t\tint qq = Integer.MAX_VALUE;\n\n\t\t//int qq = readInt();\n\n\t\tfor(int casenum = 1; casenum <= qq; casenum++)\t{\n\n\t\t\tlong n = readLong();\n\n\t\t\tint k = readInt();\n\n\t\t\tif(ans(2,k) < n)\t{\n\n\t\t\t\tpw.println(-1);\n\n\t\t\t}\n\n\t\t\telse if(n == 1) {\n\n\t\t\t\tpw.println(0);\n\n\t\t\t}\n\n\t\t\telse\t{\n\n\t\t\t\tint min = 1;\n\n\t\t\t\tint max = k-1;\n\n\t\t\t\twhile(min != max)\t{\n\n\t\t\t\t\tint mid = (min+max)/2;\n\n\t\t\t\t\tif(ans(k-mid+1,k) >= n)\t{\n\n\t\t\t\t\t\tmax = mid;\n\n\t\t\t\t\t}\n\n\t\t\t\t\telse\t{\n\n\t\t\t\t\t\tmin = mid+1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tpw.println(min);\n\n\t\t\t}\n\n\t\t}\n\n\t\tpw.close();\n\n\t}\n\n\n\n\tpublic static long ans(int min, int max)\t{\n\n\t\tint num = max-min+1;\n\n\t\tlong ret = tri(max) - tri(min-1);\n\n\t\treturn ret - (num - 1);\n\n\t}\n\n\t\n\n\tpublic static long tri(long n)\t{\n\n\t\treturn (n*n+n)/2;\n\n\t}\n\n\t\n\n\tpublic static boolean hasThree(char[][] grid, char ch)\t\t{\n\n\t\tif(grid[0][0] == ch && grid[1][1] == ch && grid[2][2] == ch)\n\n\t\t\treturn true;\n\n\t\tif(grid[0][2] == ch && grid[1][1] == ch && grid[2][0] == ch)\n\n\t\t\treturn true;\n\n\t\tif(grid[0][0] == ch && grid[0][1] == ch && grid[0][2] == ch)\n\n\t\t\treturn true;\n\n\t\tif(grid[1][0] == ch && grid[1][1] == ch && grid[1][2] == ch)\n\n\t\t\treturn true;\n\n\t\tif(grid[2][0] == ch && grid[2][1] == ch && grid[2][2] == ch)\n\n\t\t\treturn true;\n\n\t\tif(grid[0][0] == ch && grid[1][0] == ch && grid[2][0] == ch)\n\n\t\t\treturn true;\n\n\t\tif(grid[0][1] == ch && grid[1][1] == ch && grid[2][1] == ch)\n\n\t\t\treturn true;\n\n\t\tif(grid[0][2] == ch && grid[1][2] == ch && grid[2][2] == ch)\n\n\t\t\treturn true;\n\n\t\treturn false;\n\n\t}\n\n\n\n\tprivate static long readLong() throws IOException\t{\n\n\t\treturn Long.parseLong(nextToken());\n\n\t}\n\n\n\n\tprivate static double readDouble() throws IOException\t{\n\n\t\treturn Double.parseDouble(nextToken());\n\n\t}\n\n\n\n\tprivate static int readInt() throws IOException\t{\n\n\t\treturn Integer.parseInt(nextToken());\n\n\t}\n\n\n\n\tprivate static String nextToken() throws IOException\t{\n\n\t\twhile(st == null || !st.hasMoreTokens())\t{\n\n\t\t\tif(!br.ready())\t{\n\n\t\t\t\tpw.close();\n\n\t\t\t\tSystem.exit(0);\n\n\t\t\t}\n\n\t\t\tst = new StringTokenizer(br.readLine().trim());\n\n\t\t}\n\n\t\treturn st.nextToken();\n\n\t}\n\n}\n\n\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class ProblemA {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n        String[] data = s.readLine().split(\" \");\n        int n =  Integer.valueOf(data[0]);\n        int a =  Integer.valueOf(data[1]);\n        int b =  Integer.valueOf(data[2]);\n\n        long[] h = new long[n];\n        String[] line = s.readLine().split(\" \");\n        for (int i = 0 ; i < n ; i++) {\n            h[i] = Integer.valueOf(line[i]);\n        }\n        Arrays.sort(h);\n        \n        System.out.println(h[b] - h[b-1]);\n    }\n}", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A274 {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n    \n        Scanner in= new Scanner(System.in);\n        int n=in.nextInt();\n        int k=in.nextInt();\n        \n        Long a[] =new Long[n];\n        Hashtable<Long, Boolean> hash= new Hashtable<Long, Boolean>();\n        \n        \n        for (int i=0;i< n;i++){\n            a[i]=in.nextLong();\n            \n        }\n        Arrays.sort(a);\n        \n        for (int i=0;i<n;i++){\n            if (!hash.containsKey(a[i]) ){\n                hash.put(a[i]*k, true);\n            }\n            \n        }\n        System.out.println(hash.size());\n        \n        \n    }\n\n}\n", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package newpackage;\nimport java.util.*;\n/**\n *\n * @author parpaorsa\n */\npublic class NewClass {\n    static Scanner in=new Scanner(System.in);\n    public static void main(String[] args) {\n        int n = in.nextInt(),ans=Integer.MAX_VALUE,t=0;\n        String x = in.next();\n        for (int i = 0; i < n; i++) {\n            if(x.charAt(i)=='-')t--;\n            else t++;\n            ans=Math.min(ans,t);\n        }\n           if(ans <= 0) \n               System.out.println(Math.abs(ans)+t);\n           else \n               System.out.println(t);\n    }\n \n}\n", "complexity": "linear", "problem": "1159_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class cf343a {\n  static FastIO in = new FastIO(), out = in;\n\n  public static void main(String[] args) {\n    out.println(go(in.nextLong(),in.nextLong()));\n    out.close();\n  }\n  static long go(long a, long b) {\n    return b==0?0:(go(b,a%b) + a/b);\n  }\n\n  static class FastIO extends PrintWriter {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastIO() {\n      this(System.in, System.out);\n    }\n\n    public FastIO(InputStream in, OutputStream out) {\n      super(new BufferedWriter(new OutputStreamWriter(out)));\n      br = new BufferedReader(new InputStreamReader(in));\n      scanLine();\n    }\n\n    public void scanLine() {\n      try {\n        st = new StringTokenizer(br.readLine().trim());\n      } catch (Exception e) {\n        throw new RuntimeException(e.getMessage());\n      }\n    }\n\n    public int numTokens() {\n      if (!st.hasMoreTokens()) {\n        scanLine();\n        return numTokens();\n      }\n      return st.countTokens();\n    }\n\n    public String next() {\n      if (!st.hasMoreTokens()) {\n        scanLine();\n        return next();\n      }\n      return st.nextToken();\n    }\n\n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class E implements Runnable {\n\tpublic static void main (String[] args) {new Thread(null, new E(), \"_cf\", 1 << 28).start();}\n\n\tint n, m;\n\tchar[] str;\n\tint[][] occs, cost;\n\tint[] dp;\n\t\n\tpublic void run() {\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tSystem.err.println(\"\");\n\n\t\t//where's my 420???? :(\n\t\tlong tot = 0;\n\t\tfor(int i = 0; i < 19999; i++) tot += i;\n\t\tSystem.err.println(tot);\n\t\t\n\t\tn = fs.nextInt(); m = fs.nextInt();\n\t\tbyte[] str = fs.next().getBytes();\n\t\tint[] occs = new int[1<<m];\n\t\tfor(int i = 0; i < n-1; i++) {\n\t\t\tint l1 = str[i] - 'a';\n\t\t\tint l2 = str[i+1] - 'a';\n\t\t\toccs[(1<<l1) | (1<<l2)]++;\n\t\t\toccs[(1<<l2) | (1<<l1)]++;\n\t\t}\n\t\t//cost[mask][v] = numPairs with v for some all bits on in mask\n\t\tint all = (1<<m)-1;\n\t\tcost = new int[m][1<<m];\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tfor(int mask = 1; mask < all; mask++) {\n\t\t\t\tif(((1<<i)&mask) > 0) continue;\n\t\t\t\tint lb = mask & (-mask);\n\t\t\t\tint trail = Integer.numberOfTrailingZeros(lb);\n\t\t\t\tint nmask = mask ^ lb;\n\t\t\t\tcost[i][mask] = cost[i][nmask]+occs[1<<i | 1<<trail];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp = new int[1<<m];\n\t\tfor(int mask = dp.length-2; mask >= 0; mask--) {\n\t\t\tint addOn = 0;\n\t\t\tfor(int nxt = 0; nxt < m; nxt++) {\n\t\t\t\tif(((1<<nxt)&mask) > 0) continue;\n\t\t\t\taddOn += cost[nxt][mask];\n\t\t\t}\n\t\t\tint res = oo;\n\t\t\tfor(int nxt = 0; nxt < m; nxt++) {\n\t\t\t\tif(((1<<nxt)&mask) > 0) continue;\n\t\t\t\tint ret = addOn+dp[mask | (1<<nxt)];\n\t\t\t\tres = min(res, ret);\n\t\t\t}\n\t\t\tdp[mask] = res;\n\t\t}\n\t\t\n\t\tSystem.out.println(dp[0]>>1);\n\t\t\n\t\tout.close();\n\t}\n\t\n\tint oo = (int)1e9;\n\tint min(int a, int b) {\n\t\tif(a < b) return a;\n\t\treturn b;\n\t}\n\t\n\tclass FastScanner {\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\n\t\tpublic FastScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t\t}\n\t\t}\n\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}                \n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) res[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t}\n\n}", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tvoid solve(Scanner in, PrintWriter out) {\n\t\tlong a = in.nextLong();\n\t\tout.println(25);\n\t}\n\tvoid run() {\n\t\tLocale.setDefault(Locale.US);\n\t\ttry (\n\t\t\t\tScanner in = new Scanner(System.in);\n\t\t\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t) {\n\t\t\tsolve(in, out);\n\t\t  }\t\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n\n}", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\n\n\npublic class MainF {\n\n    public static void main(String[]args) throws IOException{\n\n        BufferedReader br = new BufferedReader(new FileReader(new File(\"input.txt\")));\n\n        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(\"output.txt\")));\n\n        String S = br.readLine();\n\n        String[]J = S.split(\" \");\n\n        int N = Integer.parseInt(J[0]);\n\n        int M = Integer.parseInt(J[1]);\n\n\n\n        int K = Integer.parseInt(br.readLine());\n\n        int[]x = new int[K];\n\n        int[]y = new int[K];\n\n        S = br.readLine();\n\n        J = S.split(\" \");       \n\n        for(int i = 0; i<2*K; i = i + 2){\n\n            x[i/2] = Integer.parseInt(J[i]);\n\n            y[i/2] = Integer.parseInt(J[i+1]);\n\n        }\n\n        \n\n        int ans = -1;\n\n        int ansX = -1;\n\n        int ansY = -1;\n\n        \n\n        for (int i = 1; i<=N; i++){\n\n            for (int j = 1; j<=M; j++){\n\n                int W = M + N;\n\n                for (int k = 0; k<K; k++){\n\n                    W = Math.min(W, Math.abs(i-x[k]) + Math.abs(j-y[k]));\n\n                }\n\n                if (W < ans)continue;\n\n                ans = W;\n\n                ansX = i;\n\n                ansY = j;               \n\n            }\n\n        }\n\n        bw.write(Integer.toString(ansX)+\" \"+Integer.toString(ansY));\n\n        br.close();\n\n        bw.close();     \n\n    }\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import static java.lang.Math.*;\n\nimport static java.math.BigInteger.*;\n\nimport static java.util.Arrays.*;\n\nimport static java.util.Collections.*;\n\n\n\nimport java.io.*;\n\nimport java.lang.reflect.*;\n\n\n\npublic class D {\n\n\n\n\tfinal static boolean autoflush = false;\n\n\t\n\n\tpublic D () {\n\n\t\tlong L = sc.nextLong();\n\n\t\tlong R = sc.nextLong();\n\n\t\t\n\n\t\tlong res = max(2 * Long.highestOneBit(L ^ R) - 1, 0);\n\n\t\texit(res);\n\n\t}\n\n\n\n\t////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\tstatic int [] rep(int N) { return rep(0, N); }\n\n\tstatic int [] rep(int S, int T) { int [] res = new int [T-S]; for (int i = S; i < T; ++i) res[i-S] = i; return res; }\n\n\tstatic int [] req(int S, int T) { return rep(S, T+1); }\t\n\n\n\n\t////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\t/* Dear hacker, don't bother reading below this line, unless you want to help me debug my I/O routines :-) */\n\n\t\n\n\tfinal static MyScanner sc = new MyScanner();\n\n\t\n\n\tstatic class MyScanner {\n\n\t\tpublic String next() {\n\n\t\t\tnewLine();\n\n\t\t\treturn line[index++];\n\n\t\t}\n\n\t\t\n\n\t\tpublic char nextChar() {\n\n\t\t\treturn next().charAt(0);\n\n\t\t}\n\n\t\t\t\t\n\n\t\tpublic int nextInt() {\n\n\t\t\treturn Integer.parseInt(next());\n\n\t\t}\n\n\t\t\n\n\t\tpublic long nextLong() {\n\n\t\t\treturn Long.parseLong(next());\n\n\t\t}\n\n\t\t\n\n\t\tpublic double nextDouble() {\n\n\t\t\treturn Double.parseDouble(next());\n\n\t\t}\n\n\t\t\n\n\t\tpublic String nextLine() {\n\n\t\t\tline = null;\n\n\t\t\treturn readLine();\n\n\t\t}\n\n\t\t\n\n\t\tpublic String [] nextStrings() {\n\n\t\t\tline = null;\n\n\t\t\treturn readLine().split(\" \");\n\n\t\t}\n\n\t\t\n\n\t\tpublic char [] nextChars() {\n\n\t\t\treturn next ().toCharArray ();\n\n\t\t}\n\n\n\n\t\tpublic Integer [] nextInts() {\n\n\t\t\tString [] L = nextStrings();\n\n\t\t\tInteger [] res = new Integer [L.length];\n\n\t\t\tfor (int i : rep(L.length))\n\n\t\t\t\tres[i] = Integer.parseInt(L[i]);\n\n\t\t\treturn res;\n\n\t\t}\t\n\n\t\t\n\n\t\tpublic Long [] nextLongs() {\n\n\t\t\tString [] L = nextStrings();\n\n\t\t\tLong [] res = new Long [L.length];\n\n\t\t\tfor (int i : rep(L.length))\n\n\t\t\t\tres[i] = Long.parseLong(L[i]);\n\n\t\t\treturn res;\n\n\t\t}\n\n\n\n\t\tpublic Double [] nextDoubles() {\n\n\t\t\tString [] L = nextStrings();\n\n\t\t\tDouble [] res = new Double [L.length];\n\n\t\t\tfor (int i : rep(L.length))\n\n\t\t\t\tres[i] = Double.parseDouble(L[i]);\n\n\t\t\treturn res;\n\n\t\t}\n\n\n\n\t\tpublic String [] next (int N) {\n\n\t\t\tString [] res = new String [N];\n\n\t\t\tfor (int i : rep(N))\n\n\t\t\t\tres[i] = sc.next();\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t\n\n\t\tpublic Integer [] nextInt (int N) {\n\n\t\t\tInteger [] res = new Integer [N];\n\n\t\t\tfor (int i : rep(N))\n\n\t\t\t\tres[i] = sc.nextInt();\n\n\t\t\treturn res;\n\n\t\t}\t\t\n\n\t\t\n\n\t\tpublic Long [] nextLong (int N) {\n\n\t\t\tLong [] res = new Long [N];\n\n\t\t\tfor (int i : rep(N))\n\n\t\t\t\tres[i] = sc.nextLong();\n\n\t\t\treturn res;\n\n\t\t}\t\t\n\n\t\t\n\n\t\tpublic Double [] nextDouble (int N) {\n\n\t\t\tDouble [] res = new Double [N];\n\n\t\t\tfor (int i : rep(N))\n\n\t\t\t\tres[i] = sc.nextDouble();\n\n\t\t\treturn res;\n\n\t\t}\t\t\n\n\t\t\n\n\t\tpublic String [][] nextStrings (int N) {\n\n\t\t\tString [][] res = new String [N][];\n\n\t\t\tfor (int i : rep(N))\n\n\t\t\t\tres[i] = sc.nextStrings();\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t\n\n\t\tpublic Integer [][] nextInts (int N) {\n\n\t\t\tInteger [][] res = new Integer [N][];\n\n\t\t\tfor (int i : rep(N))\n\n\t\t\t\tres[i] = sc.nextInts();\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t\n\n\t\tpublic Long [][] nextLongs (int N) {\n\n\t\t\tLong [][] res = new Long [N][];\n\n\t\t\tfor (int i : rep(N))\n\n\t\t\t\tres[i] = sc.nextLongs();\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t\n\n\t\tpublic Double [][] nextDoubles (int N) {\n\n\t\t\tDouble [][] res = new Double [N][];\n\n\t\t\tfor (int i : rep(N))\n\n\t\t\t\tres[i] = sc.nextDoubles();\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t\n\n\t\t//////////////////////////////////////////////\n\n\t\t\n\n\t\tprivate boolean eol() {\n\n\t\t\treturn index == line.length;\n\n\t\t}\n\n\n\n\t\tprivate String readLine() {\n\n\t\t\ttry {\n\n\t\t\t\treturn r.readLine();\n\n\t\t\t} catch (Exception e) {\n\n\t\t\t\tthrow new Error (e);\n\n\t\t\t}\n\n\t\t}\n\n\t\tprivate final BufferedReader r;\n\n\n\n\t\tMyScanner () {\n\n\t\t\tthis(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\t}\n\n\t\t\n\n\t\tMyScanner (BufferedReader r) {\n\n\t\t\ttry {\n\n\t\t\t\tthis.r = r;\n\n\t\t\t\twhile (!r.ready())\n\n\t\t\t\t\tThread.sleep(1);\n\n\t\t\t\tstart();\n\n\t\t\t} catch (Exception e) {\n\n\t\t\t\tthrow new Error(e);\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\tprivate String [] line;\n\n\t\tprivate int index;\n\n\n\n\t\tprivate void newLine() {\n\n\t\t\tif (line == null || eol()) {\n\n\t\t\t\tline = readLine().split(\" \");\n\n\t\t\t\tindex = 0;\n\n\t\t\t}\n\n\t\t}\t\t\n\n\t}\n\n\t\n\n\tstatic void print (Object o, Object... a) {\n\n\t\tprintDelim(\" \", o, a);\n\n\t}\n\n\t\n\n\tstatic void cprint (Object o, Object... a) {\n\n\t\tprintDelim(\"\", o, a);\n\n\t}\n\n\t\n\n\tstatic void printDelim (String delim, Object o, Object... a) {\n\n\t\tpw.println(build(delim, o, a));\n\n\t}\n\n\n\n\tstatic void exit (Object o, Object... a) {\n\n\t\tprint(o, a);\n\n\t\texit();\n\n\t}\n\n\n\n\tstatic void exit() {\n\n\t\tpw.close();\n\n\t\tSystem.out.flush();\n\n\t\tSystem.err.println(\"------------------\");\n\n\t\tSystem.err.println(\"Time: \" + ((millis() - t) / 1000.0));\n\n\t\tSystem.exit(0);\n\n\t}\n\n\t\n\n\tstatic void NO() {\n\n\t\tthrow new Error(\"NO!\");\n\n\t}\n\n\t\n\n\t////////////////////////////////////////////////////////////////////////////////////\n\n\t\n\n\tstatic String build (String delim, Object o, Object... a) {\n\n\t\tStringBuilder b = new StringBuilder();\n\n\t\tappend(b, o, delim);\n\n\t\tfor (Object p : a)\n\n\t\t\tappend(b, p, delim);\n\n\t\treturn b.toString().trim();\t\t\n\n\t}\n\n\t\n\n\tstatic void append(StringBuilder b, Object o, String delim) {\n\n\t\tif (o.getClass().isArray()) {\n\n\t\t\tint L = Array.getLength(o);\n\n\t\t\tfor (int i : rep(L))\n\n\t\t\t\tappend(b, Array.get(o, i), delim);\n\n\t\t} else if (o instanceof Iterable<?>) {\n\n\t\t\tfor (Object p : (Iterable<?>)o)\n\n\t\t\t\tappend(b, p, delim);\n\n\t\t} else\n\n\t\t\tb.append(delim).append(o);\t\t\n\n\t}\n\n\t\n\n\t////////////////////////////////////////////////////////////////////////////////////\n\n\t\n\n\tstatic void statics() {\n\n\t\tabs(0);\n\n\t\tvalueOf(0);\n\n\t\tasList(new Object [0]);\n\n\t\treverseOrder();\n\n\t}\n\n\t\n\n\tpublic static void main (String[] args) {\n\n\t\tnew D();\n\n\t\texit();\n\n\t}\n\n\n\n\tstatic void start() {\n\n\t\tt = millis();\n\n\t}\n\n\n\n\tstatic PrintWriter pw = new PrintWriter(System.out, autoflush);\n\n\t\n\n\tstatic long t;\n\n\t\n\n\tstatic long millis() {\n\n\t\treturn System.currentTimeMillis();\n\n\t}\t\n\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class A{\n\n    void solve(){\n        int n=ni();\n        int P[]=new int[n+1];\n        for(int i=1;i<=n;i++) P[i]=ni();\n        a=new int[n+1];\n        BIT=new long[n+1];\n        long cnt=0;\n\n\n        long p=0;\n        for(int i=n;i>=1;i--){\n            p+=querry(P[i]);\n            if(p>=M) p%=M;\n            update(n,P[i],1);\n        }\n        int d=0;\n        if(p%2==0) d=1;\n        int m=ni();\n        while(m-->0){\n            int l=ni(),r=ni();\n            long sz=r-l+1;\n            sz=(sz*(sz-1))/2;\n            if(d==1 && sz%2==0) d=1;\n            else if(d==1 && sz%2!=0) d=0;\n            else if(d==0 && sz%2==0) d=0;\n            else if(d==0 && sz%2!=0) d=1;\n            if(d==1) pw.println(\"even\");\n            else pw.println(\"odd\");\n        }\n    }\n    int a[];\n    long BIT[];\n    void update(int n,int x,int val){\n        a[x]=val;\n        for(;x<=n;x+=(x&-x)) BIT[x]+=val;\n    }\n    long querry(int x){\n        long ans=0;\n        for(;x>0;x-=(x&-x)) ans+=BIT[x];\n        return ans;\n\n    }\n\n    static long d, x, y;\n    static void extendedEuclid(long A, long B) {\n        if(B == 0) {\n            d = A;\n            x = 1;\n            y = 0;\n        }\n        else {\n            extendedEuclid(B, A%B);\n            long temp = x;\n            x = y;\n            y = temp - (A/B)*y;\n        }\n    }\n    static long modInverse(long A, long M)\n    {\n        extendedEuclid(A,M);\n        return (x%M+M)%M;\n    }\n    long M=(long)1e9+7;\n    InputStream is;\n    PrintWriter pw;\n    String INPUT = \"\";\n    void run() throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        pw = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        pw.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n\n    public static void main(String[] args) throws Exception { new A().run(); }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n\n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n) {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n\n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n\n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n\n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private void tr(Object... o) { if(INPUT.length() > 0)System.out.println(Arrays.deepToString(o)); }\n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Codechef\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t     Scanner SC=new Scanner(System.in);\n\t     BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\tlong k=0;\n\t     long n=0;\n\t     //int angle=0;\n\t     /*int x=0;\n\t     int y=0;\n\t     int y1=0,x1=0;*/\n\t     //String s=\"\";\n\t     //String s1=\"\";\n\t     //if(SC.hasNext())\n\t     String temps=br.readLine();\n\t     n=Long.parseLong(temps.substring(0,temps.indexOf(\" \")));\n\t\t\n\t\t//if(SC.hasNext())\n\t\tk=Long.parseLong(temps.substring(temps.indexOf(\" \")+1));\n\t\t\n\t\tlong t=0;\n\t\tlong count=0;\n\t\tlong temp=1;\n\t\tif(k!=1)\n\t\tt=((k*(k-1))/2)+1;\n\t\t\n\t\tif(t<n)\n\t\tpw.println(\"-1\");\n\t\telse if(n==1)\n\t\tpw.println(\"0\");\n\t\telse if(k==1&&n>1)\n\t\tpw.println(\"-1\");\n\t\telse if(k==n)\n\t\tpw.println(\"1\");\n\t\telse if(n>(t/2))\n\t\t{\n\t\t     temp=t;\n\t\t     count=k;\n     \t\tfor(long i=1;i<k;i++)\n     \t\t{\n     \t\t     if(temp<n)\n     \t\t     break;\n     \t\t     temp=temp-i;\n     \t\t     count--;\n     \t\t     \n     \t\t}\n     \t\t\n     \t\t//if((temp)>=n)\n     \t\tpw.println(count);\n     \t\t//else\n     \t\t//System.out.println(\"-1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t     for(long i=k;i>0;i--)\n     \t\t{\n     \t\t     temp=(temp+i)-1;\n     \t\t     count++;\n     \t\t     if(temp>=n)\n     \t\t     break;\n     \t\t}\n     \t\t\n     \t\t//if((temp)>=n)\n     \t\tpw.println(count);\n     \t\t//else\n     \t\t//System.out.println(\"-1\");\n\t\t}\n\t\t     \n\t\t\n\t\t\n\tpw.close();\n\t\t\n\t\t//System.out.println(String.format(\"%.9f\",time));\n\t}\n     \n     /*boolean Checkgood(long n,int k)\n     {\n          boolean arr[]=new boolean[k+1];\n          \n          for(int i=0;i<=k;i++)\n          {    arr[i]=false;  }\n          \n          while(n>0)\n          {\n               int temp=(int)n%10;\n               if(temp<=k)\n               arr[temp]=true;\n               n/=10;\n          }\n          for(int i=0;i<=k;i++)\n          {\n               if(arr[i]==false)\n               return false;\n          }\n          return true;\n     }\n     */\n}\n\n\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Code implements Runnable {\n\n    public static void main(String[] args) throws IOException {\n        new Thread(new Code()).start();\n    }\n\n    private void solve() throws IOException {\n        int n = nextInt(), m = nextInt();\n        if(n > m) {\n            n ^= m;\n            m ^= n;\n            n ^= m;\n        }\n\n        int[][][] dp = new int[41][64][64];\n        for(int i = 0; i < 41; ++i)\n            for(int j = 0; j < 64; ++j)\n                for(int k = 0; k < 64; ++k) dp[i][j][k] = Integer.MAX_VALUE / 2;\n\n        for(int i = 0; i < 64; ++i) dp[0][0][i] = countBit(i);\n\n        for(int i = 1; i <= m; ++i) {\n            for(int cur = 0; cur < 64; ++cur) {\n                for(int next = 0; next < 64; ++next) {\n                    for(int prev = 0; prev < 64; ++prev) {\n                        if(!isBad(prev, cur, next, n)) {\n                            dp[i][cur][next] = min(dp[i][cur][next], dp[i - 1][prev][cur] + countBit(next));\n                        }\n                    }\n                }\n            }\n        }\n\n        int ans = Integer.MAX_VALUE;\n        for(int i = 0; i < 64; ++i) ans = min(ans, dp[m][i][0]);\n\n        writer.println(n * m - ans);\n    }\n\n    private boolean isBit(int bits, int pos) {\n        return pos < 0 ? false : ((bits & (1 << pos)) != 0);\n    }\n\n    private boolean isBad(int prev, int cur, int next, int count) {\n        for(int i = 0; i < count; ++i)\n            if(!(isBit(cur, i - 1) || isBit(cur, i) || isBit(cur, i + 1) || isBit(prev, i) || isBit(next, i)))  return true;\n        return false;\n    }\n\n    private int countBit(int bits) {\n        int ans = 0;\n        for(int i = 0; i < 6; ++i)  ans += (bits & (1 << i)) > 0 ? 1 : 0;\n        return ans;\n    }\n\n    private class Pair<E extends Comparable, V extends Comparable> implements Comparable<Pair<E, V>> {\n        public Pair(E first, V second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        @Override\n        public int compareTo(Pair<E, V> obj) {\n            if(first == obj.first)  return second.compareTo(obj.second);\n            return first.compareTo(obj.first);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            Pair other = (Pair)obj;\n            return first.equals(other.first) && second.equals(other.second);\n        }\n\n        public E first;\n        public V second;\n    }\n\n    @Override\n    public void run() {\n        try {\n            if(in.equals(\"\"))   reader = new BufferedReader(new InputStreamReader(System.in));\n            else    reader = new BufferedReader(new FileReader(in));\n\n            if(out.equals(\"\"))  writer = new PrintWriter(new OutputStreamWriter(System.out));\n            else    writer = new PrintWriter(new FileWriter(out));\n            solve();\n        } catch(IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                reader.close();\n                writer.close();\n            } catch(IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private float nextFloat() throws IOException {\n        return Float.parseFloat(nextToken());\n    }\n\n    private String nextToken() throws IOException {\n        while(st == null || !st.hasMoreTokens())    st = new StringTokenizer(reader.readLine());\n        return st.nextToken();\n    }\n\n    private String in = \"\", out = \"\";\n    private BufferedReader reader;\n    private PrintWriter writer;\n    private StringTokenizer st;\n}", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\t\n\t// static int INF=1<<28;\n\t//int x,y;\n\tstatic int sum=0;\n    //static ArrayList<Integer> lis = new ArrayList<Integer>();\n\t\n\tpublic static void main(String[] args)throws Exception{\n\t//\tScanner sc =new Scanner(new File(\"input.txt\"));\n\t\tScanner sc =new Scanner(System.in);\n     // File file = new File(\"prime2.txt\");\n\t//\tPrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(file)));\n\t//\tsc.useDelimiter(\"(\\\\s)+|[,]\");\n\t//\tArrayList<Integer> lis = new ArrayList<Integer>();\n\t//ArrayList<String> lis = new ArrayList<String>();\n\t//System.out.println();\n    //  for(int i=0;i<;i++)\n\t\t\n   while(sc.hasNext()){\n\t \n\t int n=ni(sc),x[]=new int[n+1];\n\t for(int i=1;i<=n;i++)x[i]=ni(sc);\n\t sort(x);\n\t if(x[n]==1){x[n]=2;for(int i=1;i<=n;i++)System.out.print(x[i]+\" \");}\n\t else{x[0]=1;\n\t for(int i=0;i<n;i++)System.out.print(x[i]+\" \");\n\t }\n      \n   }\n\t \n\t   \n\t  \n\t}\n\t\n\t\n\t\n\tstatic void db(Object... os){\n\t         System.err.println(Arrays.deepToString(os));\n\t}\n\t\n\n\tstatic int ni(Scanner in){\n\t\treturn in.nextInt();  \n\t}\n\t\t\n}\n\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.TreeSet;\n\npublic final class CF_599_D1_C\n{\n\n\n\tstatic boolean verb=true;\n\tstatic void log(Object X){if (verb) System.err.println(X);}\n\tstatic void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+\" \");System.err.println(\"\");}}\n\tstatic void log(long[] X){if (verb) {for (long U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\n\tstatic void logWln(Object X){if (verb) System.err.print(X);}\n\tstatic void info(Object o){\tSystem.out.println(o);}\n\tstatic void output(Object o){outputWln(\"\"+o+\"\\n\");\t}\n\tstatic void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n\n\tstatic long mod=1000000007;\n\n\t// Global vars\n\tstatic BufferedWriter out;\n\tstatic InputReader reader;\n\n\n\tstatic class Composite implements Comparable<Composite>{\n\t\tint idx;\n\t\tint v;\n\n\t\tpublic int compareTo(Composite X) {\n\t\t\tif (v!=X.v)\n\t\t\t\treturn v-X.v;\n\t\t\treturn idx-X.idx;\n\n\n\t\t}\n\n\t\tpublic Composite(int idx, int v) {\n\t\t\tthis.idx = idx;\n\t\t\tthis.v = v;\n\t\t}\n\n\n\n\t}\n\n\tstatic void test() {\n\t\tlog(\"testing\");\n\n\t\tlog(\"done\");\n\n\t}\n\n\tstatic void explore(ArrayList<Integer>[] components,ArrayList<Integer> bob,int[][] move,ArrayList<int[]>[] howto,int[][] list) {\n\n\t\tfor (int x:bob) {\n\t\t\tif (components[x].size()==1) {\n\t\t\t\tint tm[]=howto[x].get(0);\n\n\n\t\t\t\tint L=howto[x].size();\n\t\t\t\thowto[x].add(tm);\n\t\t\t\tfor (int i=0;i<L;i++) {\n\t\t\t\t\tint[] cur=howto[x].get(i);\n\t\t\t\t\tint[] nx=howto[x].get(i+1);\n\t\t\t\t\tint a=cur[0];\n\t\t\t\t\tint a2=nx[0];\n\t\t\t\t\tint b2=nx[1];\n\t\t\t\t\tmove[a2][0]=list[a2][b2];\n\t\t\t\t\tmove[a2][1]=a;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\texplore(components,components[x],move,howto,list);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tstatic void process() throws Exception {\n\n\n\t\t//arrayTest();\n\n\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\treader = new InputReader(System.in);\n\n\n\t\tint k=reader.readInt();\n\t\tint[][] list=new int[k][];\n\t\tlong[] sum=new long[k];\n\t\tint[] L=new int[k];\n\t\tHashMap<Integer,int[]> target=new HashMap<Integer,int[]>();\n\t\tlong tot=0;\n\t\tfor (int i=0;i<k;i++) {\n\t\t\tL[i]=reader.readInt();\n\t\t\tlist[i]=new int[L[i]];\n\t\t\tfor (int j=0;j<L[i];j++) {\n\t\t\t\tlist[i][j]=reader.readInt();\n\t\t\t\tsum[i]+=list[i][j];\n\t\t\t\ttarget.put(list[i][j],new int[] {i,j});\n\t\t\t}\n\t\t\ttot+=sum[i];\n\t\t}\n\n\t\tint MX=1<<k;\n\t\tint AX=1000000001;\n\t\tArrayList<int[]>[] howto=new ArrayList[MX];\n\n\t\tlog(\"ok with the data\");\n\n\t\tif (tot%k!=0) {\n\t\t\toutput(\"No\");\n\t\t} else {\n\n\t\t\ttot/=k;\n\n\n\n\n\n\t\t\tfor (int i=0;i<k;i++) {\n\n\t\t\t\tif (sum[i]==tot) {\n\t\t\t\t\t//log(\"nothing to do for i:\"+i);\n\t\t\t\t\t// nothing to do\n\t\t\t\t\tint mask=1<<i;\n\t\t\t\t\tArrayList<int[]> cand=new ArrayList<int[]>();\n\t\t\t\t\tcand.add(new int[] {i,0});\n\t\t\t\t\thowto[mask]=cand;\n\t\t\t\t} else \n\n\n\t\t\t\t\tfor (int j=0;j<L[i];j++) {\n\t\t\t\t\t\tint u=i;\n\t\t\t\t\t\tint v=j;\n\t\t\t\t\t\tboolean ok=true;\n\t\t\t\t\t\tint src_u=u;\n\t\t\t\t\t\tint src_v=v;\n\t\t\t\t\t\tint mask=0;\n\t\t\t\t\t\tboolean goon=true;\n\t\t\t\t\t\tArrayList<int[]> cand=new ArrayList<int[]>();\n\t\t\t\t\t\t//log(\"start loop\");\n\t\t\t\t\t\twhile (goon) {\n\t\t\t\t\t\t\tcand.add(new int[] {u,v});\n\t\t\t\t\t\t\t//log(\"u:\"+u+\" v:\"+v);\n\t\t\t\t\t\t\tok=false;\n\t\t\t\t\t\t\tgoon=false;\n\t\t\t\t\t\t\tlong need=tot-((long)sum[u]-(long)list[u][v]);\n\t\t\t\t\t\t\tif (Math.abs(need)<=AX) {\n\t\t\t\t\t\t\t\t//log(\"need:\"+need);\n\t\t\t\t\t\t\t\tint nd=(int)need;\n\t\t\t\t\t\t\t\tint[] tm=target.get(nd);\n\t\t\t\t\t\t\t\t//log(\"tm:\"+tm);\n\t\t\t\t\t\t\t\tif (tm!=null) {\n\t\t\t\t\t\t\t\t\t//log(\"can find successor\");\n\t\t\t\t\t\t\t\t\tint nxu=tm[0];\n\t\t\t\t\t\t\t\t\tint nxv=tm[1];\n\t\t\t\t\t\t\t\t\tif ((mask&(1<<nxu))==0) {\n\t\t\t\t\t\t\t\t\t\tmask|=1<<nxu;\n\t\t\t\t\t\t\t\t\t\tif (nxu==src_u) {\n\t\t\t\t\t\t\t\t\t\t\t// looping back to source\n\t\t\t\t\t\t\t\t\t\t\tif (nxv==src_v)\n\t\t\t\t\t\t\t\t\t\t\t\tok=true;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tu=nxu;\n\t\t\t\t\t\t\t\t\t\t\tv=nxv;\n\t\t\t\t\t\t\t\t\t\t\tok=true;\n\t\t\t\t\t\t\t\t\t\t\tgoon=true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\tif (howto[mask]==null) {\n\n\t\t\t\t\t\t\t\thowto[mask]=cand;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog(\"step 1 done\");\n\n\t\t\t// now mask\n\n\t\t\tArrayList<Integer> msk=new ArrayList<Integer>();\n\t\t\tArrayList[] components=new ArrayList[MX];\n\n\t\t\tfor (int m=0;m<MX;m++) {\n\t\t\t\tif (howto[m]!=null) {\n\t\t\t\t\t//String s=Integer.toBinaryString(m);\n\t\t\t\t\t//while (s.length()<k)\n\t\t\t\t\t//\ts=\"0\"+s;\n\t\t\t\t\t//log(\"found mask:\"+s);\n\t\t\t\t\tcomponents[m]=new ArrayList<Integer>();\n\t\t\t\t\tcomponents[m].add(m);\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tint[] visited=new int[MX];\n\n\n\t\t\tfor (int a=0;a<MX;a++) {\n\t\t\t\tif (howto[a]!=null) {\n\t\t\t\t\tArrayList<Integer> add=new ArrayList<Integer>();\n\t\t\t\t\t\n\t\t\t\t\tfor (int b:msk) {\n\t\t\t\t\t\tif ((b&a)==0) {\n\n\t\t\t\t\t\t\tint c=b|a;\n\t\t\t\t\t\t\tlog(\"creating c:\"+c+\" \");\n\t\t\t\t\t\t\tif (components[c]==null) {\n\t\t\t\t\t\t\t\tcomponents[c]=new ArrayList<Integer>();\n\t\t\t\t\t\t\t\tcomponents[c].add(a);\n\t\t\t\t\t\t\t\tcomponents[c].add(b);\n\t\t\t\t\t\t\t\tadd.add(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmsk.add(a);\n\t\t\t\t\tfor (int c:add) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tmsk.add(c);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//log(\"msk:\"+msk);\n\t\t\t//log(components[MX-1]);\n\t\t\tif (components[MX-1]!=null) {\n\t\t\t\toutput(\"Yes\");\n\t\t\t\tint[][] move=new int[k][2];\n\t\t\t\texplore(components,components[MX-1],move,howto,list);\n\t\t\t\tfor (int i=0;i<k;i++) {\n\t\t\t\t\toutput(move[i][0]+\" \"+(move[i][1]+1));\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\toutput(\"No\");\n\t\t\t}\n\n\t\t}\n\n\n\t\ttry {\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t}\n\n\t}\n\n\n\n\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tprocess();\n\n\t}\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t// log(\"d:\"+d);\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t// log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t// log(\"d:\"+d);\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t// log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n}", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "\n// template : secondThread\n\nimport java.io.*;\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\n\npublic   class main2 {\n\n\n\n\n      public static void main(String[] args) {\n          try {\n\n\n              PrintWriter fop = new PrintWriter(System.out);\n              FastScanner fsca = new FastScanner();\n\n                int n = fsca.nextInt();\n                int m = Integer.MAX_VALUE ;\n              for (int i = 0; i < n; i++)\n              {\n                  int a = fsca.nextInt();\n                  m = Math.min(m, a / Math.max(i, n - 1 - i));\n              }\n\n                fop.println(m);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n              fop.flush();\n              fop.close();\n          } catch (Exception e) {\n              return;\n          }\n\n\n      }\n      /*-----------------------------------------------------------------------------------------------------------------------------------------------*/\n\n\n      static void sieve(int n) {\n          boolean[] flag = new boolean[n];\n\n          for (int i = 2; i * i < n; i++) {\n              if (flag[i])\n                  continue;\n              else\n                  for (int j = i * i; j <= n; j += i) {\n                      flag[j] = true;\n                  }\n          }\n      }\n\n\n      static int gcd(int a, int b) {\n          if (b > a) {\n              int tenp = b;\n              b = a;\n              a = tenp;\n          }\n          int temp = 0;\n          while (b != 0) {\n              a %= b;\n              temp = b;\n              b = a;\n              a = temp;\n          }\n          return a;\n      }\n\n      static long gcd_long(long a, long b) {\n          if (b > a) {\n              long tenp = b;\n              b = a;\n              a = tenp;\n          }\n          long temp = 0;\n          while (b != 0) {\n              a %= b;\n              temp = b;\n              b = a;\n              a = temp;\n          }\n          return a;\n      }\n\n\n      static final Random random = new Random();\n\n      static void ruffleSort(int[] a) {\n          int n = a.length;//shuffle, then sort\n          for (int i = 0; i < n; i++) {\n              int oi = random.nextInt(n), temp = a[oi];\n              a[oi] = a[i];\n              a[i] = temp;\n          }\n          Arrays.sort(a);\n      }\n\n\n      static class FastScanner {\n          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n          StringTokenizer st = new StringTokenizer(\"\");\n\n          String next() {\n              while (!st.hasMoreTokens())\n                  try {\n                      st = new StringTokenizer(br.readLine());\n                  } catch (IOException e) {\n                      e.printStackTrace();\n                  }\n              return st.nextToken();\n          }\n\n          int nextInt() {\n              return Integer.parseInt(next());\n          }\n\n          int[] readArray(int n) {\n              int[] a = new int[n];\n              for (int i = 0; i < n; i++) a[i] = nextInt();\n              return a;\n          }\n\n          long[] readLongArray(int n) {\n              long[] a = new long[n];\n              for (int i = 0; i < n; i++)\n                  a[i] = nextLong();\n              return a;\n          }\n\n          long nextLong() {\n              return Long.parseLong(next());\n          }\n      }\n\n\n  }\n\n\n\n\n\n\n\n\n", "complexity": "linear", "problem": "1159_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "\n\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\nimport java.lang.*;\n\npublic class Third{\n\tstatic long mod=1000000007;\n\t\n    public static void main(String[] args) throws Exception{           \t\n    \t InputReader in = new InputReader(System.in);       \n    \tPrintWriter pw=new PrintWriter(System.out);   \n    \t\n    \t\n    \t//int t=in.readInt();\n        //while(t-->0)\n        //{\n    \t\n        int n=in.readInt();\n    \t//long n=in.readLong();\n    \t/*int a[]=new int[n];\n    \tfor(int i=0;i<n;i++)\n    \t{\n    \t\ta[i]=in.readInt();\n    \t}*/\n    \tString a=in.readString();\n    \tchar c[]=a.toCharArray();\n    \tHashSet<Character>ht=new HashSet<Character>();\n    \tDeque<Character>q=new LinkedList<Character>();\n    \tHashSet<Character>hs=new HashSet<Character>();\n    \tHashMap<Character,Integer>hm=new HashMap<Character,Integer>();\n    \tfor(int i=0;i<n;i++)\n    \t{\n    \t\tht.add(c[i]);\n    \t}\n    \tint t=ht.size();\n    \tq.addLast(c[0]);\n    \ths.add(c[0]);\n    \thm.put(c[0],1);\n    \tint ans=Integer.MAX_VALUE;\n    \tif(hs.size()==t)\n\t\t{   \t\t\t\n\t\t\tans=min(ans,q.size());\n\t\t}\n    \t\n    \tfor(int i=1;i<n;i++)\n    \t{\n    \t\tq.addLast(c[i]);\n\t\t\ths.add(c[i]);\n\t\t\tif(hm.containsKey(c[i]))\n\t\t\t{\n\t\t\t\tint x=hm.get(c[i]);\n\t\t\t\thm.put(c[i],x+1);\n\t\t\t}\n\t\t\telse\n\t\t\t\thm.put(c[i],1);\n    \t\twhile(hs.size()==t)\n    \t\t{   \t\t\t\n    \t\t\tans=min(ans,q.size());\n    \t\t\tchar ch=q.peekFirst();\n    \t\t\tint x=hm.get(ch);\n    \t\t\tif(x==1)\n    \t\t\t\tbreak;\n    \t\t\telse\n    \t\t\t\t{\n    \t\t\t\thm.put(ch, x-1);\n    \t\t\t\tq.pollFirst();\n    \t\t\t\t}\n    \t\t\t\n    \t\t}\n    \t\t    \t\t\t\n    \t\t\n    \t}\n\t\tpw.println(ans);\t     \t\n    \t\n    \t//}\n    \t\n    \tpw.close();\n    }\n    \n\n\t\npublic static long gcd(long x,long y)\n{\n\tif(x%y==0)\n\t\treturn y;\n\telse\n\t\treturn gcd(y,x%y);\n}\npublic static int gcd(int x,int y)\n{\n\tif(x%y==0)\n\t\treturn y;\n\telse \n\t\treturn gcd(y,x%y);\n}\npublic static int abs(int a,int b)\n{\n\treturn (int)Math.abs(a-b);\n}\npublic static long abs(long a,long b)\n{\n\treturn (long)Math.abs(a-b);\n}\npublic static int max(int a,int b)\n{\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\npublic static int min(int a,int b)\n{\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n}\npublic static long max(long a,long b)\n{\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\npublic static long min(long a,long b)\n{\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n}\n\n\npublic static long pow(long n,long p,long m)\n{\n\t long  result = 1;\n\t  if(p==0)\n\t    return 1;\n\tif (p==1)\n\t    return n;\n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\n\t    if(result>=m)\n\t    result%=m;\n\t    p >>=1;\n\t    n*=n;\n\t    if(n>=m)\n\t    n%=m;\n\t}\n\treturn result;\n}\npublic static long pow(long n,long p)\n{\n\tlong  result = 1;\n\t  if(p==0)\n\t    return 1;\n\tif (p==1)\n\t    return n;\n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\t    \n\t    p >>=1;\n\t    n*=n;\t    \n\t}\n\treturn result;\n\n}\nstatic class Pair implements Comparable<Pair>\n{\n\tint a,b;\n\tPair (int a,int b)\n\t{\n\t\tthis.a=a;\n\t\tthis.b=b;\n\t}\n\n\tpublic int compareTo(Pair o) {\n\t\t// TODO Auto-generated method stub\n\t\tif(this.a!=o.a)\n\t\treturn Integer.compare(this.a,o.a);\n\t\telse\n\t\t\treturn Integer.compare(this.b, o.b);\n\t\t//return 0;\n\t}\n\tpublic boolean equals(Object o) {\n        if (o instanceof Pair) {\n            Pair p = (Pair)o;\n            return p.a == a && p.b == b;\n        }\n        return false;\n    }\n    public int hashCode() {\n        return new Integer(a).hashCode() * 31 + new Integer(b).hashCode();\n    }\n    \n} \n    \nstatic long sort(int a[])\n{  int n=a.length;\n\tint b[]=new int[n];\t\n\treturn mergeSort(a,b,0,n-1);}\nstatic long mergeSort(int a[],int b[],long left,long right)\n{ long c=0;if(left<right)\n {   long mid=left+(right-left)/2;\n\t c= mergeSort(a,b,left,mid);\n\t c+=mergeSort(a,b,mid+1,right);\n\t c+=merge(a,b,left,mid+1,right); }\t\n\treturn c;\t }\nstatic long merge(int a[],int  b[],long left,long mid,long right)\n{long c=0;int i=(int)left;int j=(int)mid; int k=(int)left;\nwhile(i<=(int)mid-1&&j<=(int)right)\n{ if(a[i]<=a[j]) {b[k++]=a[i++]; }\nelse\t{ b[k++]=a[j++];c+=mid-i;}}\nwhile (i <= (int)mid - 1)   b[k++] = a[i++]; \nwhile (j <= (int)right) b[k++] = a[j++];\nfor (i=(int)left; i <= (int)right; i++) \n\ta[i] = b[i];  return c;  }\n    \npublic static int[] radixSort(int[] f)\n{\n\tint[] to = new int[f.length];\n\t{\n\t\tint[] b = new int[65537];\n\t\tfor(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\tfor(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n\t\tint[] d = f; f = to;to = d;\n\t}\n\t{\n\t\tint[] b = new int[65537];\n\t\tfor(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\tfor(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n\t\tint[] d = f; f = to;to = d;\n\t}\n\treturn f;\n}    \n   static  class InputReader\n    {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream)\n        {\n            this.stream = stream;\n        }\n\n        public int read()\n        {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars)\n            {\n                curChar = 0;\n                try\n                {\n                    numChars = stream.read(buf);\n                } catch (IOException e)\n                {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n        public double readDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, readInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, readInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public boolean isSpaceChar(int c)\n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next()\n        {\n            return readString();\n        }\n\n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n  \n//BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t//StringBuilder sb=new StringBuilder(\"\");\n\t //InputReader in = new InputReader(System.in);\n\t//PrintWriter pw=new PrintWriter(System.out);\n\t//String line=br.readLine().trim();\n\t       \t\n\t//int t=Integer.parseInt(br.readLine());\n  //\twhile(t-->0)\n  \t//{\n  \t//int n=Integer.parseInt(br.readLine());\n\t//long n=Long.parseLong(br.readLine());\n\t//String l[]=br.readLine().split(\" \");\n  //int m=Integer.parseInt(l[0]);\n\t//int k=Integer.parseInt(l[1]);\n\t//String l[]=br.readLine().split(\" \");\n\t//l=br.readLine().split(\" \");\n\t/*int a[]=new int[n];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta[i]=Integer.parseInt(l[i]);\n\t}*/\n\t   //System.out.println(\" \");\t     \t\n\t\n\t//}\n}", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class C {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    \n    public static void sort(int arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(int arr[],int l1,int r1,int l2,int r2) {\n        int tmp[]=new int[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void sort(long arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(long arr[],int l1,int r1,int l2,int r2) {\n        long tmp[]=new long[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n\n    \n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        StringBuilder ans=new StringBuilder(\"\");\n        int test=input.scanInt();\n        for(int tt=1;tt<=test;tt++) {\n            int n=input.scanInt();\n            \n            ArrayList<Integer> arrli[]=new ArrayList[n];\n            for(int i=0;i<n;i++) {\n                arrli[i]=new ArrayList<>();\n            }\n            \n            for(int i=0;i<n;i++) {\n                int tmp=input.scanInt();\n                if(i==0) {\n                    arrli[0].add(1);\n                    continue;\n                }\n                if(tmp==1) {\n                    for(int j=0;j<arrli[i-1].size();j++) {\n                        arrli[i].add(arrli[i-1].get(j));\n                    }\n                    arrli[i].add(tmp);\n                    continue;\n                }\n                int indx=-1;\n                for(int j=0;j<arrli[i-1].size();j++) {\n                    if(arrli[i-1].get(j)==tmp-1) {\n                        indx=j;\n                    }\n                }\n                for(int j=0;j<indx;j++) {\n                    arrli[i].add(arrli[i-1].get(j));\n                }\n                arrli[i].add(tmp);\n            }\n            for(int i=0;i<n;i++) {\n               for(int j=0;j<arrli[i].size();j++) {\n                   ans.append(arrli[i].get(j));\n                   if(j!=arrli[i].size()-1) {\n                       ans.append(\".\");\n                   }\n               }\n               ans.append(\"\\n\");\n            }\n        }\n        System.out.println(ans);\n    }\n    \n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "//package educational.round34;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Map;\n\npublic class F {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tstatic class Datum\n\t{\n\t\tint[] hs;\n\t\tint cost;\n\t\tpublic Datum(int[] hs, int cost) {\n\t\t\tthis.hs = hs;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t\n\t\tpublic long h()\n\t\t{\n\t\t\tlong h = 0;\n\t\t\tfor(int o : hs){\n\t\t\t\th = h * 100 + o;\n\t\t\t}\n\t\t\treturn h;\n\t\t}\n\t}\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] cost = na(4);\n\t\tchar[][] map = nm(4, n);\n\t\t\n\t\tint[] w = new int[4];\n\t\t\n\t\tMap<Long, Datum> cans = new HashMap<>();\n\t\t\n\t\touter:\n\t\tdo{\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tif(i+w[i] > 4)continue outer;\n\t\t\t}\n\t\t\tint[] h = new int[4];\n\t\t\tint sc = 0;\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tif(w[i] > 0)sc += cost[w[i]-1];\n\t\t\t\tfor(int j = i;j < i+w[i];j++){\n\t\t\t\t\th[j] = Math.max(h[j], w[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDatum d = new Datum(h, sc);\n\t\t\tlong dh = d.h();\n\t\t\tif(!cans.containsKey(dh) || cans.get(dh).cost > sc){\n\t\t\t\tcans.put(dh, d);\n\t\t\t}\n\t\t}while(inc(w, 5));\n//\t\ttr(cans.size());\n\t\t\n\t\tList<Datum> ds = new ArrayList<>(cans.values());\n\t\tlong[][][][] dp = new long[4][4][4][4];\n\t\tfor(int u = 0;u < 4;u++){\n\t\t\tfor(int v = 0;v < 4;v++){\n\t\t\t\tfor(int x = 0;x < 4;x++){\n\t\t\t\t\tArrays.fill(dp[u][v][x], Long.MAX_VALUE / 3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[0][0][0][0] = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tlong[][][][] ndp = new long[4][4][4][4];\n\t\t\tfor(int u = 0;u < 4;u++){\n\t\t\t\tfor(int v = 0;v < 4;v++){\n\t\t\t\t\tfor(int x = 0;x < 4;x++){\n\t\t\t\t\t\tArrays.fill(ndp[u][v][x], Long.MAX_VALUE / 3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] a = new int[4];\n\t\t\tdo{\n\t\t\t\tlong myc = dp[a[0]][a[1]][a[2]][a[3]];\n\t\t\t\tint[] na = Arrays.copyOf(a, 4);\n\t\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\t\tif(na[k] > 0)na[k]++;\n\t\t\t\t\tif(map[k][i] == '*' && na[k] == 0)na[k] = 1;\n\t\t\t\t}\n\t\t\t\tint[] nna = new int[4];\n\t\t\t\tinner:\n\t\t\t\tfor(Datum d : ds){\n\t\t\t\t\tSystem.arraycopy(na, 0, nna, 0, 4);\n//\t\t\t\t\tint[] nna = Arrays.copyOf(na, 4);\n\t\t\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\t\t\tif(d.hs[k] >= nna[k])nna[k] = 0;\n\t\t\t\t\t\tif(nna[k] == 4)continue inner;\n\t\t\t\t\t}\n//\t\t\t\t\ttr(a, na, nna);\n\t\t\t\t\tndp[nna[0]][nna[1]][nna[2]][nna[3]] = \n\t\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\tndp[nna[0]][nna[1]][nna[2]][nna[3]], \n\t\t\t\t\t\t\tmyc + d.cost\n\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}while(inc(a, 4));\n\t\t\t\n\t\t\tdp = ndp;\n\t\t}\n\n\t\tout.println(dp[0][0][0][0]);\n\t}\n\t\n\tpublic static boolean inc(int[] a, int base) {\n\t\tint n = a.length;\n\t\tint i;\n\t\tfor (i = n - 1; i >= 0 && a[i] == base - 1; i--)\n\t\t\t;\n\t\tif (i == -1)\n\t\t\treturn false;\n\n\t\ta[i]++;\n\t\tArrays.fill(a, i + 1, n, 0);\n\t\treturn true;\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new F().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "linear", "problem": "0903_F", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n\npublic class A25 {\n\n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tint n = Integer.parseInt(in.readLine().trim());\n\t\t\tString[] toks = in.readLine().trim().split(\"[ ]+\");\n\t\t\tint counter = 0;\n\t\t\tboolean even = true;\n\t\t\tint e = -1, o = -1;\n\t\t\tint ec = 0, oc = 0;\n\t\t\tfor (int i = 0; i < toks.length; i++) {\n\t\t\t\tint x = Integer.parseInt(toks[i]);\n\t\t\t\tif (x % 2 == 0) {\n\t\t\t\t\tec ++;\n\t\t\t\t\tif (e == -1) {\n\t\t\t\t\t\te = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toc ++;\n\t\t\t\t\tif (o == -1) {\n\t\t\t\t\t\to = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ec == 1) {\n\t\t\t\tSystem.out.println(e);\n\t\t\t}\n\t\t\telse if (oc == 1) {\n\t\t\t\tSystem.out.println(o);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tnew A25().run();\n\t}\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main2 {\n    public static void main(String[] args) throws Exception {\n        new Main2().run();\n    }\n\n    public void solve() throws Exception {\n        n = nextInt();\n        int a[]= new int[n], pos = 1;\n        for(int i=0; i<n; i++)\n            a[i] = nextInt();\n        Arrays.sort(a);\n        if(n == 1){\n            out.println(\"NO\"); return;\n        }\n        boolean has = false;\n        for(; pos<n; pos++){\n            if(a[pos] != a[0]){\n                has = true;\n                break;\n            }\n        }\n        if(!has){\n            out.println(\"NO\");\n        }\n        else{\n            out.println(a[pos]);\n        }\n    }\n    public int n, m;\n\n    public void run() throws Exception {\n        inter = new StreamTokenizer(new BufferedReader(new InputStreamReader(\n                System.in)));\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n        solve();\n        out.flush();\n    }\n    public BufferedReader in;\n    public StreamTokenizer inter;\n    public PrintWriter out;\n\n    public int nextInt() throws Exception {\n        inter.nextToken();\n        return (int) inter.nval;\n    }\n    public String nextLine() throws Exception{\n        return in.readLine();\n    }\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.*;\npublic class main {\n\tpublic static void main(String[] args) {\n\t\tScanner kb=new Scanner(System.in);\n\t\twhile(kb.hasNext()){\n\t\t\tlong a=kb.nextLong();\n\t\t\tlong b=kb.nextLong();\n\t\t\tif(a<b){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}else{\n\t\t\t\tint n=0;\n\t\t\t\tlong i=0;\n\t\t\t\tfor (i = b; i <= a; i++) {\n\t\t\t\t\tint sum=0;\n\t\t\t\t\tlong aa=i;\n\t\t\t\t\twhile(aa!=0){\n\t\t\t\t\t\tsum=(int) (sum+aa%10);\n\t\t\t\t\t\taa=aa/10;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i-sum>=b){\n\t\t\t\t\t\tif(i%10==9){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(n+a-i+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \t\t \t\t\t\t\t    \t\t \t\t  \t \t\t\t \t\t\t\t", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n        double[] arr = new double[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = sc.nextInt();\n        }\n        int count = 2;\n        for(int i = 0; i < n-1; i++){\n            double temp = (arr[i+1] - arr[i]) / 2;\n            if(temp > d){\n                count += 2;\n            }else if(temp == d){\n                count++;\n            }\n        }\n        System.out.println(count);\n    }\n}\n\t\t\t\t  \t \t   \t\t  \t\t \t\t \t\t\t    \t", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n\n    static MyScanner sc;\n    private static PrintWriter out;\n    static long M2 = 1_000_000_000L + 7;\n\n    private static HashMap<Long, Long>[] mods;\n\n    public static void main(String[] s) throws Exception {\n        StringBuilder stringBuilder = new StringBuilder();\n\n//        stringBuilder.append(\"7 3\\n\" +\n//                \"1 5 2 6 3 7 4\\n\" +\n//                \"2 5 3\\n\" +\n//                \"4 4 1\\n\" +\n//                \"1 7 3\");\n\n//\n//        Random r = new Random(5);\n//        stringBuilder.append(\"100000 5000 \");\n//        for (int i = 0; i < 100000; i++) {\n//            stringBuilder.append(\" \" + (r.nextInt(2000000000) - 1000000000) + \" \");\n//\n//        }\n//        for (int k = 0; k < 5000; k++) {\n//            stringBuilder.append(\" 1 100000 777 \");\n//        }\n        if (stringBuilder.length() == 0) {\n            sc = new MyScanner(System.in);\n        } else {\n            sc = new MyScanner(new BufferedReader(new StringReader(stringBuilder.toString())));\n        }\n\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        initData();\n        solve();\n\n        out.flush();\n    }\n\n\n    private static final class X {\n        int c;\n        char l;\n\n        public X(char c) {\n            l = c;\n        }\n    }\n\n    private static void solve() throws IOException {\n        String f = sc.next();\n        ArrayList<X> xx = new ArrayList<>();\n        for (int i = 0; i < f.length(); i++) {\n            if (xx.size() == 0 || xx.get(xx.size() - 1).l != f.charAt(i)) {\n                xx.add(new X(f.charAt(i)));\n            }\n            xx.get(xx.size() - 1).c++;\n        }\n\n        int v = 0;\n        while (xx.size() > 1) {\n            ArrayList<X> next = new ArrayList<>();\n            for (int t = 0; t < xx.size(); t++) {\n                int rm = (t == 0 || t == xx.size() - 1) ? 1 : 2;\n                X dd = xx.get(t);\n                dd.c -= rm;\n                if (dd.c > 0) {\n                    if (next.size() == 0 || next.get(next.size() - 1).l != dd.l) {\n                        next.add(dd);\n                    } else {\n                        next.get(next.size() - 1).c += dd.c;\n                    }\n                }\n            }\n\n            xx = next;\n            v++;\n        }\n\n        out.println(v);\n    }\n\n    private static void initData() {\n\n\n    }\n\n    static char[][] data;\n    static String cmd;\n\n    private static final class STree {\n        private final Comparator<Integer> comparator;\n        int[] val1;\n        int[] from1;\n        int[] to1;\n        int[] max1;\n\n        public STree(int c, Comparator<Integer> comparator) {\n            this.comparator = comparator;\n            int size = Integer.highestOneBit(c);\n            if (size != c) {\n                size <<= 1;\n            }\n            int rs = size << 1;\n            val1 = new int[rs];\n            from1 = new int[rs];\n            max1 = new int[rs];\n            to1 = new int[rs];\n\n            Arrays.fill(from1, Integer.MAX_VALUE);\n            for (int r = rs - 1; r > 1; r--) {\n                if (r >= size) {\n                    from1[r] = r - size;\n                    to1[r] = r - size;\n                }\n                from1[r / 2] = Math.min(from1[r / 2], from1[r]);\n                to1[r / 2] = Math.max(to1[r / 2], to1[r]);\n            }\n        }\n\n        public int max(int from, int to) {\n            return max(1, from, to);\n        }\n\n        private int max(int cur, int from, int to) {\n            if (cur >= val1.length) return -1;\n            if (from <= from1[cur] && to1[cur] <= to) {\n                return max1[cur];\n            }\n            if (from1[cur] > to || from > to1[cur]) {\n                return -1;\n            }\n            cur <<= 1;\n\n            return max0(max(cur, from, to), max(cur + 1, from, to));\n        }\n\n\n        public void put(int x, int val) {\n            x += val1.length >> 1;\n            val1[x] = val;\n            max1[x] = val;\n            addToParent(x);\n        }\n\n\n        private void addToParent(int cur) {\n            while (cur > 1) {\n                cur >>= 1;\n                max1[cur] = max0(max1[cur << 1], max1[1 + (cur << 1)]);\n            }\n        }\n\n        private int max0(int i, int i1) {\n            if (i == -1) return i1;\n            if (i1 == -1) return i;\n            return comparator.compare(i, i1) > 0 ? i1 : i;\n        }\n    }\n\n\n    private static boolean isset(long i, int k) {\n        return (i & (1 << k)) > 0;\n    }\n\n    private static void solveT() throws IOException {\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            solve();\n        }\n    }\n\n\n    private static long gcd(long l, long l1) {\n        if (l > l1) return gcd(l1, l);\n        if (l == 0) return l1;\n        return gcd(l1 % l, l);\n    }\n\n    private static long pow(long a, long b, long m) {\n        if (b == 0) return 1;\n        if (b == 1) return a;\n        long pp = pow(a, b / 2, m);\n        pp *= pp;\n        pp %= m;\n        return (pp * (b % 2 == 0 ? 1 : a)) % m;\n    }\n\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        MyScanner(BufferedReader br) {\n            this.br = br;\n        }\n\n        public MyScanner(InputStream in) {\n            this(new BufferedReader(new InputStreamReader(in)));\n        }\n\n        void findToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        String next() {\n            findToken();\n            return st.nextToken();\n        }\n\n        Integer[] nab(int n) {\n            Integer[] k = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                k[i] = sc.fi();\n            }\n            return k;\n        }\n\n        int[] na(int n) {\n            int[] k = new int[n];\n            for (int i = 0; i < n; i++) {\n                k[i] = sc.fi();\n            }\n            return k;\n        }\n\n        long[] nl(int n) {\n            long[] k = new long[n];\n            for (int i = 0; i < n; i++) {\n                k[i] = sc.nextLong();\n            }\n            return k;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int fi() {\n            String t = next();\n            int cur = 0;\n            boolean n = t.charAt(0) == '-';\n            for (int a = n ? 1 : 0; a < t.length(); a++) {\n                cur = cur * 10 + t.charAt(a) - '0';\n            }\n            return n ? -cur : cur;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n\n}", "complexity": "linear", "problem": "0909_D", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "import java.io.PrintStream;\nimport java.util.Scanner;\n\n/**\n * @author Roman Elizarov\n */\npublic class Round_146_A {\n\tpublic static void main(String[] args) {\n\t\tnew Round_146_A().go();\n\t}\n\n\tvoid go() {\n\t\t// read input\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\n\t\t// solve\n\t\tlong result = solve(n);\n\n\t\t// write result\n\t\tPrintStream out = System.out;\n\t\tout.println(result);\n\t}\n\n\tstatic long solve(int n) {\n        if (n == 1)\n            return 1;\n        if (n == 2)\n            return 2;\n        if (n % 2 == 0) {\n            if (n % 3 == 0)\n                return (long)(n - 1) * (n - 2) * (n - 3);\n            else\n                return (long)n * (n - 1) * (n - 3);\n        } else\n\t\t    return (long)n * (n - 1) * (n - 2);\n\t}\n}\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\nimport java.util.*;\nimport java.util.regex.*;\nimport java.text.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Mulitple\n{\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString s = r.readLine();\n\n\t\tSystem.out.println(num(s));\n\t}\n\n\tpublic static int num(String s)\n\t{\n\t\tint answer = 0;\n\t\tSet<String> set = new HashSet<String>();\n\t\tfor(int j = s.length()-1; j>=1; j--)\n\t\t{\n\t\t\tfor(int i = 0; i<s.length()-j+1; i++)\n\t\t\t{\n\t\t\t\tif(set.contains(s.substring(i,i+j)))\n\t\t\t\t{\n\t\t\t\t\treturn s.substring(i,i+j).length();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tset.add(s.substring(i,i+j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0; \n\n\t}\n}\n\n\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Sol2{\n\tfinal public static int MXN = (1<<21);\n\tpublic static int good[][];\n\tpublic static void main(String[] args) throws IOException{\n\t\tFastIO sc = new FastIO(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint num[][] = new int[m][m];\n\t\tString str = sc.next();\n\t\tfor(int i=0; i<str.length()-1; i++) {\n\t\t\tint a = str.charAt(i)-'a';\n\t\t\tint b = str.charAt(i+1)-'a';\n\t\t\tnum[a][b]++;\n\t\t\tnum[b][a]++;\n\t\t}\n\t\tint lowbit[] = new int[MXN];\n\t\tint dp[] = new int[MXN];\n\t\tfor(int i=0; i<MXN; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tdp[0] = 0;\n\t\tgood = new int[MXN][m];\n\t\tfor(int msk = 0; msk<(1<<m); msk++) {\n\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\tint low = Integer.numberOfTrailingZeros(Integer.lowestOneBit(msk));\n\t\t\t\tif(low==32) low = 0;\n\t\t\t\tgood[msk][i] = good[msk^(1<<low)][i] + num[i][low];\n\t\t\t}\n\t\t}\n\t\tfor(int msk = 0; msk<(1<<m); msk++) {\n\t\t\tint bits = Integer.bitCount(msk)+1;\n\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\tif((msk&(1<<i))!=0) continue;\n\t\t\t\tint nxt = msk|(1<<i);\n\t\t\t\tdp[nxt] = Math.min(dp[nxt], dp[msk] + bits*(good[msk][i]-good[((1<<m)-1)^nxt][i]));\n\t\t\t}\n\t\t}\n\t\tout.println(dp[(1<<m)-1]);\n\t\tout.close();\n\t}\n\tstatic void shuffle(int[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t}\n\tstatic class FastIO {\n\t\t \n\t\t// Is your Fast I/O being bad?\n \n\t\tInputStream dis;\n\t\tbyte[] buffer = new byte[1 << 17];\n\t\tint pointer = 0;\n \n\t\tpublic FastIO(String fileName) throws IOException {\n\t\t\tdis = new FileInputStream(fileName);\n\t\t}\n \n\t\tpublic FastIO(InputStream is) throws IOException {\n\t\t\tdis = is;\n\t\t}\n \n\t\tint nextInt() throws IOException {\n\t\t\tint ret = 0;\n \n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\tboolean negative = false;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = nextByte();\n\t\t\t}\n\t\t\twhile (b >= '0' && b <= '9') {\n\t\t\t\tret = 10 * ret + b - '0';\n\t\t\t\tb = nextByte();\n\t\t\t}\n \n\t\t\treturn (negative) ? -ret : ret;\n\t\t}\n \n\t\tlong nextLong() throws IOException {\n\t\t\tlong ret = 0;\n \n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\tboolean negative = false;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = nextByte();\n\t\t\t}\n\t\t\twhile (b >= '0' && b <= '9') {\n\t\t\t\tret = 10 * ret + b - '0';\n\t\t\t\tb = nextByte();\n\t\t\t}\n \n\t\t\treturn (negative) ? -ret : ret;\n\t\t}\n \n\t\tbyte nextByte() throws IOException {\n\t\t\tif (pointer == buffer.length) {\n\t\t\t\tdis.read(buffer, 0, buffer.length);\n\t\t\t\tpointer = 0;\n\t\t\t}\n\t\t\treturn buffer[pointer++];\n\t\t}\n \n\t\tString next() throws IOException {\n\t\t\tStringBuffer ret = new StringBuffer();\n \n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\twhile (b > ' ') {\n\t\t\t\tret.appendCodePoint(b);\n\t\t\t\tb = nextByte();\n\t\t\t}\n \n\t\t\treturn ret.toString();\n\t\t}\n \n\t}\n}\n\n", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author Trung Pham\n */\npublic class A {\n\n    public static void main(String[] args) throws FileNotFoundException, IOException {\n        Scanner in = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n        String val = in.next();\n        ArrayList<String> list = new ArrayList();\n        for(int i = 0; i < val.length() ; i++){\n            list.add(val.substring(i));\n        }\n        Collections.sort(list);\n        int result = 0;\n        for(int i = 1; i < list.size() ; i++){\n            String other = list.get(i - 1);\n            int temp = 0;\n            for(int j = 0; j < list.get(i).length() && j < other.length() ; j++){\n                if(other.charAt(j) == list.get(i).charAt(j)){\n                    temp++;\n                }else{\n                    break;\n                }\n            }\n            if(temp > result){\n                result = temp;\n            }\n        }\n        out.println(result);\n        out.close();\n    }\n\n    public static int dist(int x0, int y0, int x1, int y1) {\n        return (x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1);\n    }\n\n    public static boolean isRight(int a, int b, int c) {\n        if (a == 0 || b == 0 || c == 0) {\n            return false;\n        }\n        if (a == b + c) {\n            return true;\n        }\n        if (b == a + c) {\n            return true;\n        }\n        if (c == a + b) {\n            return true;\n        }\n        return false;\n    }\n\n    public static int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    static class FT {\n\n        int[] data;\n\n        FT(int n) {\n            data = new int[n];\n        }\n\n        void update(int index, int val) {\n            // System.out.println(\"UPDATE INDEX \" + index);\n            while (index < data.length) {\n                data[index] += val;\n                index += index & (-index);\n\n                //    System.out.println(\"NEXT \" +index);\n            }\n        }\n\n        int get(int index) {\n            //  System.out.println(\"GET INDEX \" + index);\n            int result = 0;\n            while (index > 0) {\n                result += data[index];\n                index -= index & (-index);\n                // System.out.println(\"BACK \" + index);\n            }\n            return result;\n        }\n    }\n\n    static int pow(int a, int b) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        int val = pow(a, b / 2);\n        if (b % 2 == 0) {\n\n            return val * val;\n        } else {\n            return val * val * a;\n        }\n    }\n\n//    static Point intersect(Point a, Point b, Point c) {\n//        double D = cross(a, b);\n//        if (D != 0) {\n//            return new Point(cross(c, b) / D, cross(a, c) / D);\n//        }\n//        return null;\n//    }\n//\n//    static Point convert(Point a, double angle) {\n//        double x = a.x * cos(angle) - a.y * sin(angle);\n//        double y = a.x * sin(angle) + a.y * cos(angle);\n//        return new Point(x, y);\n//    }\n    static Point minus(Point a, Point b) {\n        return new Point(a.x - b.x, a.y - b.y);\n    }\n\n    static Point add(Point a, Point b) {\n        return new Point(a.x + b.x, a.y + b.y);\n    }\n\n    static double cross(Point a, Point b) {\n        return a.x * b.y - a.y * b.x;\n    }\n\n    static class Point {\n\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return \"Point: \" + x + \" \" + y;\n        }\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() throws FileNotFoundException {\n            //System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            //   br = new BufferedReader(new FileReader(\"input.txt\"));\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() {\n\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.Scanner;\n\n\npublic class D {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint ans = 0;\t\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i+1; j < n; ++j) {\n\t\t\t\tif(a[i] > a[j]) ans++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint m = in.nextInt();\n\t\t\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint l = in.nextInt();\n\t\t\tint r = in.nextInt();\n\t\t\t\n\t\t\tint size = r-l + 1;\n\t\t\t\n\t\t\tint x = size * size - size;\n\t\t\tx = x >> 1;\n\t\t\n\t\t\tans = ans^x;\n\t\t\tif(ans%2 == 0) System.out.println(\"even\");\n\t\t\telse System.out.println(\"odd\");\n\t\t\t\n\t\t}\n\t}\n\t\n\t\n\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int k = scan.nextInt();\n\n        int red = n*2;\n        int green = n*5;\n        int blue = n*8;\n\n        int noteBooks=0;\n\n        if(red%k==0){\n            noteBooks+=red/k;\n        }\n        if(red%k!=0){\n            noteBooks+=red/k+1;\n        }\n        if(green%k==0){\n            noteBooks+=green/k;\n        }\n        if(green%k!=0){\n            noteBooks+=green/k+1;\n        }\n        if(blue%k==0){\n            noteBooks+=blue/k;\n        }\n        if(blue%k!=0){\n            noteBooks+=blue/k+1;\n        }\n        System.out.println(noteBooks);\n    }\n}", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.lang.*;\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Solution implements Runnable{\n    private static BufferedReader br = null;\n    private static PrintWriter out = null;\n    private static StringTokenizer stk = null;\n    \n    public static void main(String[] args) {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        (new Thread(new Solution())).start();\n    }\n    \n    private void loadLine() {\n        try {\n            stk = new StringTokenizer(br.readLine());\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private String nextLine() {\n        try {\n            return br.readLine();\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    \n    private Integer nextInt() {\n        while (stk==null||!stk.hasMoreTokens()) loadLine();\n        return Integer.parseInt(stk.nextToken());\n    }\n    \n    private Long nextLong() {\n        while (stk==null||!stk.hasMoreTokens()) loadLine();\n        return Long.parseLong(stk.nextToken());\n    }\n    \n    private String nextWord() {\n        while (stk==null||!stk.hasMoreTokens()) loadLine();\n        return (stk.nextToken());\n    }\n    \n    private Double nextDouble() {\n        while (stk==null||!stk.hasMoreTokens()) loadLine();\n        return Double.parseDouble(stk.nextToken());\n    }\n    \n    public void run() {\n        int n = nextInt();\n        int k = nextInt();\n        \n        boolean[] isP = new boolean[2*n];\n        Arrays.fill(isP, true);\n        isP[0] = isP[1] = false;\n        \n        for (int i = 0; i <= n; ++i) {\n            if (isP[i]) {\n                for (int j = i+i; j <= n; j+=i) {\n                    isP[j] = false;\n                }\n            }\n        }\n        \n        ArrayList<Integer> p = new ArrayList<Integer>();\n        for (int i = 0; i <= n; ++i) {\n            if (isP[i]) {\n                p.add(i);\n            }\n        }\n        \n        int cnt = 0;\n        for (int i = 0; i < p.size(); ++i) {\n            int num = p.get(i) - 1;\n            \n            for (int j = 0; j < p.size() - 1; ++j) {\n                if (p.get(j) + p.get(j+1) == num) {\n                    ++cnt;\n                    break;\n                }\n            }\n        }\n        \n        if (cnt >= k) {\n            out.println(\"YES\");\n        }\n        else {\n            out.println(\"NO\");\n        }\n        out.flush();\n    }\n}\n\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\npublic class Codechef {\n\tPrintWriter out;\n    StringTokenizer st;\n    BufferedReader br;\n \t\n \tclass Pair implements Comparable<Pair>\n\t{\n\t    int f;\n\t    int s;\n \n\t    Pair(int t, int r) {\n\t       f = t;\n\t       s = r;\n\t    }\n\t    public int compareTo(Pair p)\n\t    {\n\t    \tif(this.f!=p.f)\n\t    \t\treturn this.f-p.f;\n \n\t    \treturn this.s-p.s;\n\t    }\n \t}\n // \tclass Sort implements Comparator<String> \n\t// { \n\t//     public int compare(String a, String b) \n\t//     { \n\t//     \treturn (a+b).compareTo(b+a);\n\t//     } \n\t// }\n \n\tString ns() {\n        while (st == null || !st.hasMoreElements()) {\n \n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n \n    String nextLine() throws Exception {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            throw new Exception(e.toString());\n        }\n        return str;\n    }\n \n    int nextInt() {\n        return Integer.parseInt(ns());\n    }\n \n    long nextLong() {\n        return Long.parseLong(ns());\n    }\n \n    double nextDouble() {\n        return Double.parseDouble(ns());\n    }\n\t\n\tint upperBound(ArrayList<Integer> a,int key)\n\t{\n\t\tint l=0,r=a.size()-1;\n\t\tint i=-1;\n \n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=(l+r)/2;\n \n\t\t\tif(a.get(mid)<=key)\t\n\t\t\t\tl=mid+1;\n\t\t\t\n \n\t\t\telse{\n\t\t\t\ti=mid;\n\t\t\t\tr=mid-1;\n\t\t\t}\n\t\t}\n\t\tif(i!=-1)\n\t\t\treturn a.get(i);\n\t\treturn i;\n\t}\n \n\tlong power(long x,long y)\n\t{\n\t    long ans=1;\n\t    \n\t    while(y!=0)\n\t    {\n\t        if(y%2==1) ans=(ans*x)%mod;\n\t        x=(x*x)%mod;\n\t        y/=2;\n\t    }\n\t    return ans%mod;\n\t}\n\t\n \n\tlong mod= 1000000007;\n\tlong gcd(long x ,long y)\n\t{\n\t\tif(y==0)\n\t\t\treturn x;\n\t\treturn gcd(y,x%y);\n\t}\n \n\t// ArrayList a[];\n\t// int vis[];\n\t// ArrayList<Integer> list;\n\t// int dfs(int ver)\n\t// {\n\t// \tArrayList<Integer> l=a[ver];\n\t// \tint cnt=0;\n\t// \tfor(int v:l)\n\t// \t{\n\t// \t\tif(vis[v]==0){\n\t// \t\t\tvis[v]=vis[ver]+1;\n\t// \t\t\tcnt+=dfs(v)+1;\n\t// \t\t}\n\t// \t}\n\t// \tlist.add(vis[ver]-cnt-1);\n\t// \treturn cnt;\n\t// }\n \n \tlong digitSum(long n)\n \t{\n \t\tlong sum=0;\n \t\twhile(n!=0)\n \t\t{\n \t\t\tsum+=n%10;\n \t\t\tn/=10;\n \t\t}\n \t\treturn sum;\n \t}\n\tvoid solve() throws IOException{\n\t\tlong n=nextLong();\n\t\tlong sum=nextLong();\n\n\t\tlong l=0,r=n,ans=n+1;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tlong mid=(l+r)/2;\n\t\t\tlong d=digitSum(mid);\n\t\t\tif(mid-d<sum)\n\t\t\t\tl=mid+1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tans=mid;\n\t\t\t\tr=mid-1;\n\t\t\t}\n\t\t}\n\t\tout.println(n-ans+1);\n\t}\n\t\n    void run() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n \n\t\tout.close();\n\t}\n \n\tpublic static void main(String args[]) throws IOException {\n\t\tnew Codechef().run();\n\t}\n  \n}", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        long K = Long.valueOf(br.readLine());\n        long n = 0;\n        long k = 0; //len * Math.pow(10, len) * 0.9;\n        long len = 0;\n        while(true){\n            len++;\n            long preK = k;\n            long preN = n;\n            k += len * Math.pow(10, len) * 0.9;\n            n += Math.pow(10, len) * 0.9;\n            if(K < k) {\n                k = preK;\n                n = preN;\n                break;\n            }\n        }\n        long step = len - 1;\n        while(true){\n            while(k <= K){\n                long preK = k;\n                long preN = n;\n                if(step == 0){\n                    k += len;\n                    n++;\n                }else{\n                    k += len * Math.pow(10, step) * 0.9;\n                    n += Math.pow(10, step) * 0.9;\n                }\n                if(k == K || (k >= K && k - K < len)){\n                    //System.out.println(k);\n                    //System.out.println(n);\n                    String nStr = Long.toString(n);\n                    System.out.println(nStr.charAt(nStr.length() - (int)(k-K) - 1));\n                    return;\n                }\n                if(K < k){\n                    k = preK;\n                    n = preN;\n                    break;\n                }\n            }\n            step--;\n        }\n    }\n}\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.*;\n\npublic class Main {\n\n    static int N;\n    static int [][] dp;\n    static int M = (int)(1e9 + 7);\n    static ArrayList<Integer> l;\n\n    static int f(int idx, int b) {\n        if(idx == l.size())\n            return 1;\n        if(dp[idx][b] != -1)\n            return dp[idx][b];\n        long ret = f(idx + 1, b + l.get(idx));\n        if(b > 0)\n            ret += f(idx, b - 1);\n        return dp[idx][b] = (int) (ret % M);\n    }\n\n    public static void main(String[] args) throws IOException{\n\t    Scanner sc = new Scanner();\n\t    N = sc.nextInt();\n        int [] val = new int[N];\n        for(int i = 0; i < N; ++i)\n            if(sc.next().charAt(0) == 's')\n                val[i] = 0;\n            else\n                val[i] = 1;\n        l = new ArrayList<Integer>();\n        l.add(val[0]);\n\n        for(int i = 1; i < N; ++i)\n            if(val[i] == val[i - 1] && val[i] == 1) {\n                int prev = l.get(l.size() - 1);\n                l.set(l.size() - 1, ++prev);\n            } else if(val[i - 1] == 0){\n                l.add(val[i]);\n            }\n\n//        System.out.println(l);\n        dp = new int[l.size() + 1][N + 1];\n        for(int i = 0; i <= l.size(); ++i)\n            Arrays.fill(dp[i], -1);\n        System.out.println(f(0, 0));\n\n    }\n\n\n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n    }\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tstatic class MultiTreeSet<T extends Comparable<T>> {\n\t\tprivate TreeMap<T, Integer> map = new TreeMap<>();\n\n\t\tpublic int count(T x) {\n\t\t\tInteger ret = map.get(x);\n\t\t\treturn ret == null ? 0 : ret;\n\t\t}\n\n\t\tvoid add(T x) {\n\t\t\tmap.put(x, count(x) + 1);\n\t\t}\n\n\t\tT first() {\n\t\t\treturn map.firstKey();\n\t\t}\n\n\t\tT last() {\n\t\t\treturn map.lastKey();\n\t\t}\n\n\t\tboolean remove(T x) {\n\t\t\tint prev = count(x);\n\t\t\tif (prev == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (prev == 1) {\n\t\t\t\tmap.remove(x);\n\t\t\t} else {\n\t\t\t\tmap.put(x, prev - 1);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tvoid go(int x, TreeSet<Integer> pos, MultiTreeSet<Integer> sz,\n\t\t\tMultiTreeSet<Integer> otherSz) {\n\t\tif (!pos.contains(x)) {\n\t\t\tint prev = pos.lower(x);\n\t\t\tint next = pos.higher(x);\n\t\t\tsz.remove(next - prev);\n\t\t\tsz.add(x - prev);\n\t\t\tsz.add(next - x);\n\t\t\tpos.add(x);\n\t\t}\n\t\tlong ret = (long) sz.last() * otherSz.last();\n\t\tout.println(ret);\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint w = nextInt();\n\t\tint h = nextInt();\n\t\tint n = nextInt();\n\t\tTreeSet<Integer> ww = new TreeSet<>();\n\t\tTreeSet<Integer> hh = new TreeSet<>();\n\t\tww.add(0);\n\t\tww.add(w);\n\t\thh.add(0);\n\t\thh.add(h);\n\t\tMultiTreeSet<Integer> szW = new MultiTreeSet<>();\n\t\tMultiTreeSet<Integer> szH = new MultiTreeSet<>();\n\t\tszW.add(w);\n\t\tszH.add(h);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tchar type = nextToken().charAt(0);\n\t\t\tint x = nextInt();\n\t\t\tif (type == 'H') {\n\t\t\t\tgo(x, hh, szH, szW);\n\t\t\t} else {\n\t\t\t\tgo(x, ww, szW, szH);\n\t\t\t}\n\t\t}\n\t}\n\n\tA() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew A();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "complexity": "nlogn", "problem": "0528_A", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "import java.util.Scanner;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author codeKNIGHT\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n\tpublic void solve(int testNumber, Scanner in, PrintWriter out) {\n        int n=in.nextInt(),k=in.nextInt()-1,i;\n        scores a[]=new scores[n];\n        for(i=0;i<n;i++)\n            a[i]=new scores(in.nextInt(),in.nextInt());\n        Arrays.sort(a);\n        \n        int c=1;\n        for(i=k-1;i>=0;i--)\n        {\n            if(a[i].p==a[k].p&&a[i].t==a[k].t)\n                c++;\n            else break;\n        }\n        for(i=k+1;i<n;i++)\n        {\n            if(a[i].p==a[k].p&&a[i].t==a[k].t)\n                c++;\n            else break;\n        }\n        out.println(c);\n\n\t}\n    class scores implements Comparable<scores>\n    {\n        int p,t;\n        public scores(int p,int t)\n        {\n            this.p=p;\n            this.t=t;\n        }\n        public int compareTo(scores a)\n        {\n            if(a.p>this.p)\n                return 1;\n            if(a.p==this.p&&a.t<this.t)\n                return 1;\n            return -1;\n        }\n    }\n}\n\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Houses implements Runnable {\n    private void solve() throws IOException {\n        int n = nextInt();\n        int t = nextInt();\n        int[] x = new int[n];\n        int[] a = new int[n];\n        for (int i = 0; i < n; ++i) {\n            x[i] = nextInt() * 2;\n            a[i] = nextInt();\n        }\n        Set<Integer> res = new HashSet<Integer>();\n        for (int i = 0; i < n; ++i) {\n            if (valid(n, t, x, a, x[i] + a[i] + t))\n                res.add(x[i] + a[i] + t);\n            if (valid(n, t, x, a, x[i] - a[i] - t))\n                res.add(x[i] - a[i] - t);\n        }\n        writer.println(res.size());\n    }\n\n    private boolean valid(int n, int t, int[] x, int[] a, int pos) {\n        for (int i = 0; i < n; ++i) {\n            if (Math.abs(pos - x[i]) < a[i] + t)\n                return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        new Houses().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class _1523_C {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        int t = Integer.parseInt(in.readLine());\n        while(t-- > 0) {\n            int n = Integer.parseInt(in.readLine());\n            int[] a = new int[n];\n            for(int i = 0; i < n; i++) {\n                a[i] = Integer.parseInt(in.readLine());\n            }\n            boolean[][] used = new boolean[n][n + 1];\n            boolean[] used2 = new boolean[n];\n            String[][] res = new String[n][2];\n            res[0][0] = \"1\";\n            res[0][1] = \"\";\n            for(int i = 1; i < n; i++) {\n                if(a[i] == 1) {\n                    for(int j = i - 1; j >= 0; j--) {\n                        if(!used[j][a[i]] && !used2[j]) {\n                            res[i][0] = res[j][0] + \".1\";\n                            res[i][1] = res[j][0];\n                            used[j][a[i]] = true;\n                            break;\n                        }\n                    }\n                }else {\n                    for(int j = i - 1; j >= 0; j--) {\n                        if(!used[j][a[i]] && !used2[j] && a[j] == a[i] - 1) {\n                            if(res[j][1].equals(\"\")) {\n                                res[i][0] = \"\" + a[i];\n                            }else {\n                                res[i][0] = res[j][1] + \".\" + a[i];\n                            }\n                            res[i][1] = res[j][1];\n                            used[j][a[i]] = true;\n                            break;\n                        }\n                        used2[j] = true;\n                    }\n                }\n            }\n            for(int i = 0; i < n; i++) {\n                out.println(res[i][0]);\n            }\n        }\n        in.close();\n        out.close();\n    }\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class trafficerules {\n \t\n \tpublic static void main(String[] args) throws Exception {\n \t\tif (\"Satayev\".equals(System.getProperty(\"user.name\"))) {\n\t\t\tlong start = System.nanoTime();\n\t\t\tnew trafficerules().solve(new FileInputStream(\"input\"));\n\t\t\tSystem.err.printf(\"Time elapsed: %d ms.\\n\", (System.nanoTime()-start)/1000000);\n\t\t}\n\t\telse\n\t\t\tnew trafficerules().solve(System.in);\n \t}\n\n \tvoid solve(InputStream is) throws Exception {\n\t\tScanner in = new Scanner(is);\n\t\t\n\t\tdouble a = in.nextDouble(), maxv = in.nextDouble(), s = in.nextDouble(), d = in.nextDouble(), w = in.nextDouble();\n\t\t\n\t\tif (maxv < w)\n\t\t\tw = maxv;\n\t\t\n\t\tdouble t = 0;\n\t\t\n\t\t// v = at\n\t\t// s = att/2\n\t\tdouble t1 = w / a;\n\t\tdouble s1 = a*t1*t1/2;\n\t\tdouble v1 = w;\n\t\tif ( s1 < d ) {\n\t\t\tv1 = w;\n\t\t\t\n\t\t\tif (v1 >= maxv)\n\t\t\t\tt1 += (d-s1)/v1;\n\t\t\telse {\n\t\t\t\tdouble tt = (maxv - v1)/a;\n\t\t\t\tdouble ss = v1*tt+a*tt*tt/2;\n\t\t\t\tss *= 2;\n\t\t\t\tif (s1 + ss < d)\n\t\t\t\t\tt1 += tt*2 + (d-s1-ss)/maxv;\n\t\t\t\telse {\n\t\t\t\t\tss = (d-s1)/2;\n\t\t\t\t\t// ss = v1*t + a*t*t/2;\n\t\t\t\t\tdouble A = a/2;\n\t\t\t\t\tdouble B = v1;\n\t\t\t\t\tdouble C = -ss;\n\t\t\t\t\tdouble D = B*B - 4 * A * C;\n\t\t\t\t\ttt = (-B + Math.sqrt(D))/2/A;\n\t\t\t\t\tt1 += tt*2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ts1 = d;\n\t\t}\n\t\tif (s1 > d) {\n\t\t\ts1 = d;\n\t\t\tt1 = Math.sqrt(2*s1/a);\n\t\t\tv1 = a * t1;\n\t\t}\n\t\t\n\t\tt += t1;\n\t\t\n\t\tdouble t2 = (maxv - v1) / a;\n\t\tdouble s2 = v1*t2 + a*t2*t2/2;\n\t\tdouble v2 = maxv;\n\t\tif (s1 + s2 < s) {\n\t\t\tv2 = maxv;\n\t\t\tt2 += (s-s1-s2)/v2;\n\t\t}\n\t\tif (s1 + s2 > s) {\n\t\t\ts -= s1;\n\t\t\t// v = v1 + a*t\n\t\t\t// s = v1*t + a*t*t/2\n\t\t\tdouble A = a/2;\n\t\t\tdouble B = v1;\n\t\t\tdouble C = -s;\n\t\t\tdouble D = B*B - 4*A*C;\n\t\t\t\n\t\t\tt2 = (-B + Math.sqrt(D))/2/A;\n\t\t}\n\t\t\n\t\tt += t2;\n\t\t\n\t\tSystem.out.println(t);\n \t}\n\n}", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class E {\n    static double[] dp;\n    static int[] oneCount;\n    static int end;\n    static int n;\n    static double[][] prob;\n    public static double solve(int mask) {\n        if(mask==end) return 1;\n        int oneC=0,zeroC=0;\n        for(int i=0;i<n;i++) {\n            if((mask|(1<<i))==mask) oneC++;\n            else zeroC++;\n        }\n        double res=0;\n        for(int i=0;i<n;i++) {\n            if((mask|(1<<i))!=mask) continue;\n            for(int j=0;j<n;j++) {\n                //\n                if((mask|(1<<j))==mask) continue;\n                //System.out.println(i+\" \"+j+\" \"+prob[i][j]+\" \"+Integer.toBinaryString(mask)+\" \"+oneC+\" \"+zeroC);\n                res+=(1.0/((oneC*(oneC+1))/2))*prob[i][j]*solve(mask|(1<<j));\n            }\n        }\n        return dp[mask]=res;\n    }\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        n=sc.nextInt();\n        prob=new double[n][n];\n        for(int i=0;i<n;i++) \n            for(int j=0;j<n;j++)\n                prob[i][j]=sc.nextDouble();\n        dp=new double[1<<n];\n        oneCount=new int[1<<n];\n        int c;\n        for(int i=0;i<dp.length;i++) {\n            c=0;\n            for(int j=0;j<n;j++) {\n                if((i|(1<<j))==i) c++;\n            }\n            oneCount[i]=c;\n        }\n        end=(1<<n)-1;\n        double res,rad;\n        int count;\n        for(int k=end;k>0;k--) {\n            if(k==end) dp[k]=1;\n            else {\n                res=0;\n                count=oneCount[k];\n                count=count*(count+1);\n                count>>=1;\n                rad=1.0/count;\n                //System.out.println(rad+\" \"+count);\n                for(int i=0;i<n;i++) {\n                    if((k|(1<<i))!=k) continue;\n                    for(int j=0;j<n;j++) {\n                        //\n                        if((k|(1<<j))==k) continue;\n                        //System.out.println(i+\" \"+j+\" \"+prob[i][j]+\" \"+Integer.toBinaryString(mask)+\" \"+oneC+\" \"+zeroC);\n                        res+=rad*prob[i][j]*dp[k|(1<<j)];\n                    }\n                }\n                dp[k]=res;\n            }\n        }\n        //Arrays.fill(dp, -1);\n        for(int i=0;i<n;i++)\n            System.out.print(dp[1<<i]+\" \");\n            //System.out.print(solve(1<<i)+\" \");\n//      for(int i=0;i<18;i++){\n//          for(int k=0;k<18;k++)\n//              System.out.print(Math.random()+\" \");\n//          System.out.println();\n//      }\n    }\n}", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.*;\nimport java.util.*;\n\n/*\n * And now I wonder if I should delete these comments cause they might throw me off. \n * Lol who cares though?\n */\n\npublic class R364C {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tScanner s = new Scanner(System.in);\n\t\tBufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = Integer.parseInt(f.readLine());\n\t\tchar[] a = f.readLine().toCharArray();\n\t\tint difTypes = 0;\n\t\tTreeSet<Character> types = new TreeSet<Character>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!types.contains(a[i])) {\n\t\t\t\ttypes.add(a[i]);\n\t\t\t}\n\t\t}\n\t\tint i = 0, j = 0;\n\t\tdifTypes = types.size();\n\t\tint curTypes = 0;\n\t\tint min = Integer.MAX_VALUE;\n\t\tTreeSet<Character> has = new TreeSet<Character>();\n\t\tHashMap<Character, Integer> freq = new HashMap<Character, Integer>();\n\t\twhile(i < n && j < n) {\n//\t\t\tSystem.out.println(i + \" \" + j);\n\t\t\thas.add(a[j]);\n\t\t\tif(!freq.containsKey(a[j])) {\n\t\t\t\tfreq.put(a[j], 1);\n\t\t\t} else {\n\t\t\t\tfreq.put(a[j], freq.get(a[j])+1);\n\t\t\t}\n\t\t\tj++;\n\t\t\tcurTypes = has.size();\n\t\t\tif(curTypes == difTypes) min = Math.min(min, j-i);\n//\t\t\tSystem.out.println(freq.toString());\n//\t\t\tSystem.out.println(curTypes);\n//\t\t\tSystem.out.println();\n\t\t\twhile(i < n && has.size() == difTypes) {\n\t\t\t\tint Freq = freq.get(a[i]);\n//\t\t\t\tSystem.out.println(Freq);\n\t\t\t\tif(Freq - 1 == 0) {\n\t\t\t\t\thas.remove(a[i]);\n\t\t\t\t\tfreq.put(a[i], freq.get(a[i])-1);\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfreq.put(a[i], freq.get(a[i])-1);\n\t\t\t\ti++;\n\t\t\t\tif(curTypes == difTypes) min = Math.min(min, j-i);\n\t\t\t}\n\t\t\tcurTypes = has.size();\n\t\t}\n//\t\tif(curTypes == difTypes) min = Math.min(min, j-i);\n\t\tSystem.out.println(min);\n\t}\n}", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tvoid solve() throws IOException {\n\t\tString s = nextToken();\n\t\tint res = Integer.parseInt(s);\n\t\t\n\t\tString s1 = s.substring(0, s.length() - 1);\n\t\tres = Math.max(res, Integer.parseInt(s1));\n\t\t\n\t\tString s2 = s.substring(0, s.length() - 2) + s.charAt(s.length() - 1);\n\t\tres = Math.max(res, Integer.parseInt(s2));\n\t\t\n\t\tout.println(res);\n\t}\n\n\tA() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew A();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew A().run();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tboolean eof;\n\t\tString buf;\n\n\t\tpublic FastScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t\tnextToken();\n\t\t}\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(stream));\n\t\t\tnextToken();\n\t\t}\n\n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\teof = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString ret = buf;\n\t\t\tbuf = eof ? \"-1\" : st.nextToken();\n\t\t\treturn ret;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (Exception e) {\n\n\t\t\t}\n\t\t}\n\n\t\tboolean isEOF() {\n\t\t\treturn eof;\n\t\t}\n\t}\n\n\tFastScanner sc;\n\tPrintWriter out;\n\n\tpublic void run() {\n\t\tLocale.setDefault(Locale.US);\n\t\ttry {\n\t\t\tsc = new FastScanner(System.in);\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tsc.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn sc.nextInt();\n\t}\n\n\tString nextToken() {\n\t\treturn sc.nextToken();\n\t}\n\n\tlong nextLong() {\n\t\treturn sc.nextLong();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn sc.nextDouble();\n\t}\n\n\tclass House {\n\t\tint x, t;\n\n\t\tpublic House(int x, int t) {\n\t\t\tthis.x = x;\n\t\t\tthis.t = t;\n\t\t}\n\n\t}\n\n\tvoid solve() {\n\t\tint n = nextInt();\n\t\tint t = nextInt();\n\t\tHouse[] h = new House[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\th[i] = new House(nextInt(), nextInt());\n\t\t}\n\t\tArrays.sort(h, new Comparator<House>() {\n\t\t\t@Override\n\t\t\tpublic int compare(House o1, House o2) {\n\t\t\t\treturn o1.x < o2.x ? -1 : o1.x > o2.x ? 1 : 0;\n\t\t\t}\n\t\t});\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i == 0\n\t\t\t\t\t|| (h[i].x - h[i - 1].x) * 2 - h[i].t - h[i - 1].t >= 2 * t) {\n\t\t\t\t++ans;\n\t\t\t}\n\t\t\tif (i == n - 1\n\t\t\t\t\t|| (h[i + 1].x - h[i].x) * 2 - h[i + 1].t - h[i].t > 2 * t) {\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*; \n\nimport java.util.*;\n\n\n\n\n\npublic class C {\n\n    private static boolean marked[][] ; \n\n    \n\n    \n\n    public static void main(String[] args) throws Exception {\n\n//        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n//        InputStream inputStream = System.in;\n\n//        OutputStream outputStream = System.out;\n\n//        InputReader s = new InputReader(inputStream);\n\n//        PrintWriter out = new PrintWriter(outputStream);\n\n        \n\n        \n\n         // input.txt / output.txt\n\n         File file = new File(\"input.txt\") ; \n\n         Scanner s = new Scanner(file) ; \n\n        \n\n        int n = s.nextInt();\n\n        int m = s.nextInt(); \n\n        \n\n        marked = new boolean [n + 1 ][m + 1] ; \n\n        \n\n        int k = s.nextInt();\n\n        \n\n        Queue<Point> queue = new LinkedList<Point>(); \n\n        \n\n        \n\n        for(int i =0 ; i < k ; ++i){\n\n            int tempX = s.nextInt() ;\n\n            int tempY = s.nextInt() ; \n\n            marked[tempX][tempY] = true ; \n\n            queue.add(new Point(tempX , tempY));             \n\n        }\n\n        \n\n         Point c = null ;\n\n        \n\n         while(!queue.isEmpty()){\n\n             c = queue.poll() ; \n\n            \n\n            if(c.x>1 && !marked[c.x-1][c.y]){\n\n                marked[c.x -1 ][c.y] = true ; \n\n                queue.add(new Point(c.x-1,c.y));\n\n            }\n\n            \n\n            if(c.y>1 && !marked[c.x][c.y-1]){\n\n                marked[c.x][c.y-1] = true ; \n\n                queue.add(new Point(c.x,c.y-1));\n\n            }\n\n            \n\n            if(c.x < n  && !marked[c.x+1][c.y]){\n\n                marked[c.x + 1 ][c.y] = true ; \n\n                queue.add(new Point(c.x + 1,c.y));\n\n            }\n\n            \n\n            if(c.y < m && !marked[c.x][c.y+1]){\n\n                marked[c.x][c.y+1] = true ; \n\n                queue.add(new Point(c.x,c.y+1));\n\n            }\n\n        }\n\n        PrintWriter out = new PrintWriter(new File(\"output.txt\"));\n\n        out.println(c.x+\" \"+c.y); \n\n        out.close();\n\n\n\n    }\n\n    \n\n    static class Point {\n\n        int x ; \n\n        int y ; \n\n        public Point(int x  ,int y ){\n\n            this.x = x  ; \n\n            this.y = y ;\n\n        }\n\n    }\n\n}\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n\n\n\n\nclass InputReader {\n\n\n\n    public BufferedReader reader;\n\n    public StringTokenizer tokenizer;\n\n\n\n    public InputReader(InputStream stream) {\n\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n\n        tokenizer = null;\n\n    }\n\n\n\n    public String next() {\n\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\n            try {\n\n                tokenizer = new StringTokenizer(reader.readLine());\n\n            } catch (IOException e) {\n\n                throw new RuntimeException(e);\n\n            }\n\n        }\n\n        return tokenizer.nextToken();\n\n    }\n\n\n\n    public int nextInt() {\n\n        return Integer.parseInt(next());\n\n    }\n\n\n\n    public long nextLong() {\n\n        return Long.parseLong(next());\n\n    }\n\n\n\n    public double nextDouble() {\n\n        return Double.parseDouble(next());\n\n    }\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kanak893\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskC {\n\t\tpublic void solve(int testNumber, InputReader fi, PrintWriter out) {\n\t\t\tlong n, k;\n\t\t\tn = fi.nextLong();\n\t\t\tk = fi.nextLong();\n\t\t\tlong ans = 2 * n;\n\t\t\tlong mod = (long) Math.pow(10, 9) + 7;\n\n\t\t\tif (k > 0) {\n\t\t\t\tans = (modulus(modulus(pow(2, k + 1, mod), mod) * modulus(n, mod), mod));\n\t\t\t\tlong temp = modulus(pow(2, k, mod) - 1, mod);\n\t\t\t\tans = modulus(modulus(ans, mod) - modulus(temp, mod), mod);\n\n\t\t\t}\n\t\t\tif (n == 0) {\n\t\t\t\tans = 0;\n\t\t\t}\n\t\t\tans=ans%mod;\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tstatic long pow(long x, long y, long mod) {\n\t\t\tif (y == 0) return 1 % mod;\n\t\t\tif (y == 1) return x % mod;\n\t\t\tlong res = 1;\n\t\t\tx = x % mod;\n\t\t\twhile (y > 0) {\n\t\t\t\tif ((y % 2) != 0) {\n\t\t\t\t\tres = (res * x) % mod;\n\t\t\t\t}\n\t\t\t\ty = y / 2;\n\t\t\t\tx = (x * x) % mod;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic long modulus(long a, long mod) {\n\t\t\treturn (a % mod + mod) % mod;\n\t\t}\n\n\t}\n\n\tstatic class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[8192];\n\t\tprivate int curChar;\n\t\tprivate int snumChars;\n\t\tprivate InputReader.SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\n\t\t}\n\n\t}\n}\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tstatic int n,t[],g[],MOD=(int)1e9+7;\n\tstatic int [][][]memo1,memo2[],memo3[];\n\tstatic int dp1(int idx,int remCnt,int remSum) {\n\t\tif(remCnt==0)\n\t\t\treturn remSum==0?1:0;\n\t\tif(remSum==0 || idx==n)\n\t\t\treturn 0;\n\t\tif(memo1[idx][remCnt][remSum]!=-1)\n\t\t\treturn memo1[idx][remCnt][remSum];\n\t\tint ans=dp1(idx+1,remCnt,remSum);\n\t\tif(g[idx]==0 && t[idx]<=remSum)\n\t\t{\n\t\t\tans+=dp1(idx+1,remCnt-1,remSum-t[idx]);\n\t\t\tif(ans>=MOD)\n\t\t\t\tans-=MOD;\n\t\t}\n\t\treturn memo1[idx][remCnt][remSum]=ans;\n\t}\n\tstatic int dp2(int idx,int remCnt1,int remCnt2,int remSum) {\n\t\tint all=remCnt1+remCnt2;\n\t\tif(all==0)\n\t\t\treturn remSum==0?1:0;\n\t\tif(idx==n || remSum==0)\n\t\t\treturn 0;\n\t\tif(memo2[idx][remCnt1][remCnt2][remSum]!=-1)\n\t\t\treturn memo2[idx][remCnt1][remCnt2][remSum];\n\t\tint ans=dp2(idx+1,remCnt1,remCnt2,remSum);\n\t\tif(t[idx]<=remSum) {\n\t\t\tif(g[idx]==1 && remCnt1>0)\n\t\t\t\tans+=dp2(idx+1,remCnt1-1,remCnt2,remSum-t[idx]);\n\t\t\telse if(g[idx]==2 && remCnt2>0)\n\t\t\t\tans+=dp2(idx+1,remCnt1,remCnt2-1,remSum-t[idx]);\n\t\t\t\t\n\t\t}\n\t\t\n\t\treturn memo2[idx][remCnt1][remCnt2][remSum]=ans;\n\t}\n\tprivate static int dp3(int cnt0, int cnt1, int cnt2,int last) {\n\t\tif(cnt0+cnt1+cnt2==0)\n\t\t\treturn 1;\n\t\tif(memo3[last][cnt0][cnt1][cnt2]!=-1)\n\t\t\treturn memo3[last][cnt0][cnt1][cnt2];\n\t\tlong ans=0;\n\t\tif(cnt0>0 && last!=0)\n\t\t\tans+=dp3(cnt0-1,cnt1,cnt2,0);\n\t\tif(cnt1>0 && last!=1)\n\t\t\tans+=dp3(cnt0,cnt1-1,cnt2,1);\n\t\tif(cnt2>0 && last!=2)\n\t\t\tans+=dp3(cnt0,cnt1,cnt2-1,2);\n\t\treturn  memo3[last][cnt0][cnt1][cnt2]=(int) (ans%MOD);\n\t\t\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tn=sc.nextInt();\n\t\tint []fac=new int [n+1];\n\t\tt=new int [n];\n\t\tg=new int [n];\n\t\tint []cnt=new int [3];\n\t\tfac[0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfac[i]=(int) (i*1L*fac[i-1]%MOD);\n\t\tint T=sc.nextInt();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tt[i]=sc.nextInt();\n\t\t\tg[i]=sc.nextInt()-1;\n\t\t\tcnt[g[i]]++;\n\t\t\t\n\t\t}\n\t\tmemo1=new int [n][cnt[0]+1][T+1];\n\t\tmemo2=new int [n][cnt[1]+1][cnt[2]+1][T+1];\n\t\tmemo3=new int [4][cnt[0]+1][cnt[1]+1][cnt[2]+1];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<=cnt[0];j++) \n\t\t\t\tArrays.fill(memo1[i][j], -1);\n\t\t\tfor(int j=0;j<=cnt[1];j++) \n\t\t\t\tfor(int k=0;k<=cnt[2];k++)\n\t\t\t\t\tArrays.fill(memo2[i][j][k], -1);\n\t\t\t\n\t\t}\n\t\tfor(int i=0;i<4;i++)\n\t\t\tfor(int j=0;j<=cnt[0];j++)\n\t\t\t\tfor(int k=0;k<=cnt[1];k++)\n\t\t\t\t\tArrays.fill(memo3[i][j][k], -1);\n\t\tint ans=0;\n\t\tfor(int cnt0=0;cnt0<=cnt[0];cnt0++)\n\t\t\tfor(int sum0=0;sum0<=T;sum0++)\n\t\t\t\tfor(int cnt1=0;cnt1<=cnt[1];cnt1++)\n\t\t\t\t\tfor(int cnt2=0;cnt2<=cnt[2];cnt2++) {\n\t\t\t\t\t\tlong ways= dp1(0,cnt0,sum0)*1L*dp2(0,cnt1,cnt2,T-sum0)%MOD;\n\t\t\t\t\t\tways=ways*dp3(cnt0,cnt1,cnt2,3)%MOD;\n\t\t\t\t\t\tways*=fac[cnt0];\n\t\t\t\t\t\tways%=MOD;\n\t\t\t\t\t\tways*=fac[cnt1];\n\t\t\t\t\t\tways%=MOD;\n\t\t\t\t\t\tways*=fac[cnt2];\n\t\t\t\t\t\tways%=MOD;\n\t\t\t\t\t\tans+=ways;\n\t\t\t\t\t\tif(ans>=MOD)\n\t\t\t\t\t\t\tans-=MOD;\n\t\t\t\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\n\t}\n\n\t\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tboolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "complexity": "cubic", "problem": "1185_G2", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = in.nextIntArray(n);\n            Arrays.sort(a);\n            int count = 0;\n            boolean[] used = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                if (!used[i]) {\n                    count++;\n                    for (int j = i; j < n; j++) {\n                        if (a[j] % a[i] == 0) {\n                            used[j] = true;\n                        }\n                    }\n                }\n            }\n            out.println(count);\n        }\n\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\npublic class C111A{\n    static BufferedReader br;\n    public static void main(String args[])throws Exception{\n        br=new BufferedReader(new InputStreamReader(System.in));\n        int n = toInt();\n        int nm[] = toIntArray();\n        double a=0.0;\n        double sum=0;\n        for(int i=0;i<n;i++){\n            sum+=nm[i];\n        }\n        a=sum/2;\n        Arrays.sort(nm);\n        int cur=0;\n        int count=0;\n        for(int i=nm.length-1;i>=0;i--){\n            cur+=nm[i];\n            count++;\n            if(cur>a){\n                break;\n            }\n        }\n        System.out.println(count);\n\n\n    }\n\n\n    /****************************************************************/\n    public static int[] toIntArray()throws Exception{\n       String str[]=br.readLine().split(\" \");\n       int k[]=new int[str.length];\n       for(int i=0;i<str.length;i++){\n            k[i]=Integer.parseInt(str[i]);\n       }\n       return k;\n    }\n    public static int toInt()throws Exception{\n       return Integer.parseInt(br.readLine());\n    }\n    public static long[] toLongArray()throws Exception{\n       String str[]=br.readLine().split(\" \");\n       long k[]=new long[str.length];\n       for(int i=0;i<str.length;i++){\n            k[i]=Long.parseLong(str[i]);\n       }\n       return k;\n    }\n    public static long toLong()throws Exception{\n       return Long.parseLong(br.readLine());\n    }\n    public static double[] toDoubleArray()throws Exception{\n       String str[]=br.readLine().split(\" \");\n       double k[]=new double[str.length];\n       for(int i=0;i<str.length;i++){\n            k[i]=Double.parseDouble(str[i]);\n       }\n       return k;\n    }\n    public static double toDouble()throws Exception{\n       return Double.parseDouble(br.readLine());\n    }\n    public static String toStr()throws Exception{\n       return br.readLine();\n    }\n    public static String[] toStrArray()throws Exception{\n       String str[]=br.readLine().split(\" \");\n       return str;\n    }\n    /****************************************************************/\n\n}\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "\nimport java.util.Scanner;\n\npublic class A {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong l = sc.nextLong(), r = sc.nextLong();\n\t\tif (l % 2 == 0 && r - l >= 2) {\n\t\t\tSystem.out.println(l + \" \" + (l + 1) + \" \" + (l + 2));\n\t\t} else if (l % 2 == 1 && r - l >= 3) {\n\t\t\tSystem.out.println(l + 1 + \" \" + (l + 2) + \" \" + (l + 3));\n\t\t} else {\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t}\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "\n\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\n\n@SuppressWarnings(\"Duplicates\")\n\npublic class solveLOL {\n    FastScanner in;\n    PrintWriter out;\n    boolean systemIO = true, multitests = false;\n    int INF = Integer.MAX_VALUE / 2;\n\n\n    void solve() {\n        int n = in.nextInt();\n        int arr[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n        }\n        Arrays.sort(arr);\n        boolean used[] = new boolean[n];\n        int k = 0;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                for (int j = i + 1; j < n; j++) {\n                    if (!used[j] && arr[j] % arr[i] == 0) {\n                        used[j] = true;\n                    }\n                }\n                k++;\n            }\n        }\n        System.out.println(k);\n\n\n\n    }\n\n    class pair implements Comparable<pair> {\n        int a;\n        int b;\n\n        pair(int A, int B) {\n            this.a = A;\n            this.b = B;\n        }\n\n        public int compareTo(pair o) {\n            return a != o.a ? Double.compare(a, o.a) : b - o.b;\n        }\n    }\n\n    void shuffleArray(long[] ar) {\n        Random rnd = ThreadLocalRandom.current();\n        for (int i = ar.length - 1; i > 0; i--) {\n            int index = rnd.nextInt(i + 1);\n            long a = ar[index];\n            ar[index] = ar[i];\n            ar[i] = a;\n        }\n    }\n\n    void printArray(long[] ar) {\n        for (long k : ar) {\n            System.out.print(k + \" \");\n        }\n        System.out.println();\n    }\n\n    void reverseArray(long[] ar) {\n        for (int i = 0, j = ar.length - 1; i < j; i++, j--) {\n            long a = ar[i];\n            ar[i] = ar[j];\n            ar[j] = a;\n        }\n    }\n\n    private void run() throws IOException {\n        if (systemIO) {\n            in = new solveLOL.FastScanner(System.in);\n            out = new PrintWriter(System.out);\n        } else {\n            in = new solveLOL.FastScanner(new File(\"input.txt\"));\n            out = new PrintWriter(new File(\"output.txt\"));\n        }\n        for (int t = multitests ? in.nextInt() : 1; t-- > 0; )\n            solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String nextLine() {\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n    public static void main(String[] arg) throws IOException {\n        new solveLOL().run();\n    }\n\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer;\n\tstatic PrintWriter writer;\n\n\tstatic int nextInt() throws NumberFormatException, IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tstatic long nextLong() throws NumberFormatException, IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tstatic double nextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tstatic String nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\twriter = new PrintWriter(System.out);\n\t\tpineapple();\n\t\treader.close();\n\t\twriter.close();\n\t}\n\n\tstatic void pineapple() throws NumberFormatException, IOException {\n\t\tint n = nextInt();\n\t\tint a = nextInt();\n\t\tint b = nextInt();\n\t\tTreeSet<Integer> al = new TreeSet<Integer>();\n\t\tTreeMap<Integer, Integer> mp = new TreeMap<Integer, Integer>();\n\t\tint[] ans = new int[n];\n\t\tArrays.fill(ans, -1);\n\t\tTreeSet<Integer> used = new TreeSet<Integer>();\n\t\tint[] mas = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = nextInt();\n\t\t\tal.add(t);\n\t\t\tmas[i] = t;\n\t\t\tmp.put(t, i);\n\t\t}\n\n\t\tfor (int st : al) {\n\t\t\tif (used.contains(st))\n\t\t\t\tcontinue;\n\n\t\t\t{\n\t\t\t\tint pr = st;\n\t\t\t\tint cc = -1;\n\t\t\t\tTreeSet<Integer> u2 = new TreeSet<Integer>();\n\t\t\t\tu2.add(pr);\n\t\t\t\tif (al.contains(a - pr) && !u2.contains(a - pr))\n\t\t\t\t\tcc = a - pr;\n\t\t\t\telse if (al.contains(b - pr) && !u2.contains(a - pr))\n\t\t\t\t\tcc = b - pr;\n\t\t\t\tif (cc != -1) {\n\t\t\t\t\tu2.add(cc);\n\t\t\t\t\tboolean bGo = true;\n\t\t\t\t\twhile (bGo) {\n\t\t\t\t\t\tbGo = false;\n\t\t\t\t\t\tint nxt = -1;\n\t\t\t\t\t\tif (al.contains(a - cc) && !u2.contains(a - cc))\n\t\t\t\t\t\t\tnxt = a - cc;\n\t\t\t\t\t\telse if (al.contains(b - cc) && !u2.contains(b - cc))\n\t\t\t\t\t\t\tnxt = b - cc;\n\t\t\t\t\t\tif (nxt != -1) {\n\t\t\t\t\t\t\tbGo = true;\n\t\t\t\t\t\t\tu2.add(nxt);\n\t\t\t\t\t\t\tcc = nxt;\n\t\t\t\t\t\t\tpr = cc;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tst = cc;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint x = st;\n\t\t\twhile (x != -1) {\n\t\t\t\tint curr = x;\n\t\t\t\tused.add(curr);\n\t\t\t\tx = -1;\n\t\t\t\tint next1 = a - curr;\n\t\t\t\tif (al.contains(next1)) {\n\t\t\t\t\tif (!used.contains(next1)) {\n\t\t\t\t\t\tx = next1;\n\t\t\t\t\t\tint ci = mp.get(curr);\n\t\t\t\t\t\tint ni = mp.get(next1);\n\t\t\t\t\t\tif (ans[ci] == -1 && ans[ni] == -1) {\n\t\t\t\t\t\t\tans[ni] = 0;\n\t\t\t\t\t\t\tans[ci] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint next2 = b - curr;\n\t\t\t\tif (al.contains(next2)) {\n\t\t\t\t\tif (!used.contains(next2)) {\n\t\t\t\t\t\tx = next2;\n\t\t\t\t\t\tint ci = mp.get(curr);\n\t\t\t\t\t\tint ni = mp.get(next2);\n\t\t\t\t\t\tif (ans[ci] == -1 && ans[ni] == -1) {\n\t\t\t\t\t\t\tans[ni] = 1;\n\t\t\t\t\t\t\tans[ci] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (ans[i] == -1) {\n\t\t\t\tif (2 * mas[i] == a) {\n\t\t\t\t\tans[i] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (2 * mas[i] == b) {\n\t\t\t\t\tans[i] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twriter.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\twriter.println(\"YES\");\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twriter.print(ans[i] + \" \");\n\t\t}\n\t}\n}", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\npublic class B {\n\tstatic int ourLevel;\n\tpublic static void main(String[] args) throws IOException\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint k = Integer.parseInt(st.nextToken());\n\t\tourLevel = Integer.parseInt(st.nextToken());\n\t\tState[] list = new State[n];\n\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tlist[i] = new State(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())/10);\n\t\t}\n\t\tSystem.out.println(solve(list, 0, k));\n\t}\n\tpublic static double solve(State[] s, int index, int left)\t\t{\n\t\tif(index == s.length)\n\t\t\treturn prob(s);\n\t\tdouble ret = 0;\n\t\tfor(int c = 0; c <= left && s[index].prob + c <= 10; c++)\t{\n\t\t\ts[index].prob += c;\n\t\t\tret = Math.max(ret, solve(s, index+1, left-c));\n\t\t\ts[index].prob -= c;\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static double prob(State[] s)\t{\n\t\tdouble win = 1;\n\t\tfor(int i = 0; i < (1<<s.length); i++)\t{\n\t\t\tint numLose = s.length - Integer.bitCount(i);\n\t\t\tif(2*numLose >= s.length)\t{\n\t\t\t\tint level = 0;\n\t\t\t\tdouble p = 1;\n\t\t\t\tfor(int j = 0; j < s.length; j++)\t{\n\t\t\t\t\tif((i&(1<<j)) == 0)\t{\n\t\t\t\t\t\tp *= (10-s[j].prob)/10.;\n\t\t\t\t\t\tlevel += s[j].level;\n\t\t\t\t\t}\n\t\t\t\t\telse\t{\n\t\t\t\t\t\tp *= s[j].prob/10.;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdouble lose = level * 1.0 / (ourLevel + level);\n\t\t\t\twin -= p * lose;\n\t\t\t}\n\t\t}\n\t\treturn win;\n\t}\n\tstatic class State\t{\n\t\tpublic int level,prob;\n\t\tpublic State(int a, int b)\t{\n\t\t\tlevel = a;\n\t\t\tprob = b;\n\t\t}\n\t}\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.util.*;\n \npublic class Solution_1 {\n\tpublic static void main(String[] args) {\n//\t\tsolution start :-)\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong n = sc.nextLong();\n\t\tlong m = sc.nextLong();\n\t\tlong a = sc.nextLong();\n\t\tlong b = sc.nextLong();\n\t\tif(n%m==0) System.out.println(\"0\");\n\t\telse{\n\t\t    if(m>n){\n\t\t        long res = (long)Math.min((n*b),((m-n)*a));\n\t\t        System.out.println(res);\n\t\t    }\n\t\t    else{\n\t\t        long div1 = n/m;\n\t\t        long div2 = div1+1;\n\t\t        long diff1 = n-div1*m;\n\t\t        long diff2 = div2*m-n;\n\t\t        long pro1 = diff1*b;\n\t\t        long pro2 = diff2*a;\n\t\t        long res1 = Math.min(pro1,pro2);\n\t\t      //  System.out.println(\"pro=\"+pro1+\" pro2 = \"+pro2);\n\t\t        System.out.println(res1);\n\t\t    }\n\t\t}\n\t\t\n//\t\tsolution end \\(^-^)/\n//\t\t                |\n//\t\t               / \\\n\t\t}\n\t}", "complexity": "linear", "problem": "0990_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class C {\n    private static BufferedReader in;\n    private static StringTokenizer st;\n    private static PrintWriter out;\n    \n    public static void main(String[] args) throws NumberFormatException, IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        st = new StringTokenizer(\"\");\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n = nextInt();\n        int m = nextInt();\n        int k = nextInt();\n        int mod = (int) (1e9+9);\n        int correct = n - n / k;\n        int carry = n % k;\n        long ans;\n        if(correct >= m){\n            ans = m;\n        }else{\n            m -= correct;\n            int block = n / k;\n            BigInteger pow = BigInteger.valueOf(2).modPow(BigInteger.valueOf(m + 1), BigInteger.valueOf(mod));\n            ans = (pow.longValue() - 2 + mod) % mod;\n            ans = (ans * (long) k) % mod;\n            ans = (ans + (long)(block - m)* (long)(k-1) + carry) % mod;\n        }\n        System.out.println(ans);\n        \n    }\n\n    static String next() throws IOException{\n        while(!st.hasMoreTokens()){\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n    static int nextInt() throws NumberFormatException, IOException{\n        return Integer.parseInt(next());\n    }\n    static long nextLong() throws NumberFormatException, IOException{\n        return Long.parseLong(next());\n    }\n    \n    static double nextDouble() throws NumberFormatException, IOException{\n        return Double.parseDouble(next());\n    }\n\n}\n", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String input = in.nextLine();\n        if (input.equals(\"1\"))\n            System.out.println(\"NO\");\n        else {\n            if (checkNum(input))\n                System.out.println(\"YES\");\n            else {\n                int i = 2;\n                while (i < Integer.parseInt(input)) {\n                    if (checkNum(i + \"\")) {\n                        if (Integer.parseInt(input) % i != 0)\n                            i++;\n                        else\n                            break;\n                    } else\n                        i++;\n                }\n                if (i == Integer.parseInt(input))\n                    System.out.println(\"NO\");\n                else\n                    System.out.println(\"YES\");\n            }\n        }\n    }\n\n    public static boolean checkNum(String s) {\n        int i = 0;\n        int flag = 0;\n        while (i < s.length()) {\n            if (s.charAt(i) == '4' || s.charAt(i) == '7') {\n                flag = 1;\n                i++;\n            } else\n                return false;\n        }\n        if (flag == 1)\n            return true;\n        return false;\n    }\n}\n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Contest200C {\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t//BufferedReader in = new BufferedReader(new FileReader(\"200C.in\"));\n\t\tStringTokenizer st = new StringTokenizer(in.readLine());\n\t\tlong a = Long.parseLong(st.nextToken());\n\t\tlong b = Long.parseLong(st.nextToken());\n\t\t\n\t\tSystem.out.println(min(a,b));\n\t}\n\t\n\tstatic long min(long a, long b) {\n\t\tif (a <= 0 || b <= 0) return 0;\n\t\treturn a/b+min(b,a%b);\n\t}\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    long fast_pow(long a, long b) {\n        if(b == 0)\n            return 1L;\n        long val = fast_pow(a, b / 2);\n        if(b % 2 == 0)\n            return val * val % mod;\n        else\n            return val * val % mod * a % mod;\n    }\n    long mod = (long)1e9 + 7;\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n\n        long x = sc.nextLong();\n        long k = sc.nextLong();\n\n        if(x == 0) {\n            w.print(\"0\");\n            w.close();\n            return;\n        }\n\n        x = x % mod;\n\n        long pkp1 = fast_pow(2, k + 1L);\n        long pk = fast_pow(2, k);\n\n        long sub = (pk - 1 + mod) % mod * pk % mod;\n        long add = x * pkp1 % mod * pk % mod;\n        long num = (add - sub + mod) % mod;\n        long deninv = fast_pow(pk, mod - 2);\n        long ans = num * deninv % mod;\n        w.print(ans);\n\n        w.close();      \n    }\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\n\tstatic {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out, true);\n\t\t\tif (System.getProperty(\"ONLINE_JUDGE\") == null) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(new FileInputStream(\"input\")));\n\t\t\t\t//out = new PrintWriter(new FileOutputStream(\"output\"), true);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t//\n\t\t}\n\t}\n\n\tpublic static Integer readInt() {\n\t\ttry {\n\t\t\treturn Integer.parseInt(in.readLine());\n\t\t} catch (IOException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static int[] readIntArray() {\n\t\treturn Arrays\n\t\t\t.stream(readString().split(\" \"))\n\t\t\t.mapToInt(Integer::parseInt)\n\t\t\t.toArray();\n\t}\n\n\tpublic static Long readLong() {\n\t\ttry {\n\t\t\treturn Long.parseLong(in.readLine());\n\t\t} catch (IOException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static String readString() {\n\t\ttry {\n\t\t\treturn in.readLine();\n\t\t} catch (IOException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint[] nmk = readIntArray();\n\t\tint n = nmk[0];\n\t\tint m = nmk[1];\n\t\tint k = nmk[2];\n\t\tif (k % 2 == 1) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tout.print(-1 + (j < m  - 1 ? \" \" : \"\"));\n\t\t\t\t}\n\t\t\tout.println();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tk /= 2;\n\t\tint[][] x = new int[n][m - 1];\n\t\tint[][] y = new int[n - 1][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = readIntArray();\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ty[i] = readIntArray();\n\t\t}\n\t\tint[][][] z = new int[n][m][k + 1];\n\t\tint mx = (int) 1e9;\n\t\tfor (int kk = 1; kk <= k; kk++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tz[i][j][kk] = mx;\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tz[i][j][kk] = Math.min(z[i][j][kk], z[i - 1][j][kk - 1] + y[i - 1][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tz[i][j][kk] = Math.min(z[i][j][kk], z[i][j - 1][kk - 1] + x[i][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (i < n - 1) {\n\t\t\t\t\t\tz[i][j][kk] = Math.min(z[i][j][kk], z[i + 1][j][kk - 1] + y[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (j < m - 1) {\n\t\t\t\t\t\tz[i][j][kk] = Math.min(z[i][j][kk], z[i][j + 1][kk - 1] + x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tout.print(2 * z[i][j][k] + (j < m  - 1 ? \" \" : \"\"));\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class Test {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String s = in.readLine();\n        String[] p = in.readLine().split(\" \");\n        List<Integer> a = new ArrayList<Integer>();\n        for (String k : p) {\n            a.add(Integer.parseInt(k));\n        }\n        int n = a.size();\n        int c1 = 0;\n        int c2 = 0;\n        int c1p = 0;\n        int c2p = 0;\n        for (int i = 0; i < n; i++) {\n            if (a.get(i) % 2 == 0) {\n                c1++;\n                c1p = i;\n            } else {\n                c2++;\n                c2p = i;\n            }\n        }\n        if (c1 < c2) {\n            System.out.println(c1p + 1);\n        }  else {\n            System.out.println(c2p + 1);\n        }\n    }\n    \n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "/**\n * Created at 22:05 on 2019-09-14\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static FastScanner sc = new FastScanner();\n  static Output out = new Output(System.out);\n\n  static final int[] dx = {0, 1, 0, -1};\n  static final int[] dy = {-1, 0, 1, 0};\n\n  static final long MOD = (long) (1e9 + 7);\n  static final long INF = Long.MAX_VALUE / 2;\n\n  static final int e5 = (int) 1e5;\n\n  public static class Solver {\n    public Solver() {\n\n      int N = sc.nextInt();\n\n      boolean[] flag = new boolean[101];\n      for (int i=0; i<N; i++) {\n        flag[sc.nextInt()] = true;\n      }\n\n      int ans = 0;\n      for (int i=1; i<=100; i++) {\n        if (flag[i]) {\n          ans++;\n          for (int j=i*2; j<=100; j+=i) {\n            flag[j] = false;\n          }\n        }\n      }\n\n      out.println(ans);\n\n    }\n\n    public static void sort(int[] a) {\n      shuffle(a);\n      Arrays.sort(a);\n    }\n\n    public static void sort(long[] a) {\n      shuffle(a);\n      Arrays.sort(a);\n    }\n\n    public static void shuffle(int[] arr){\n      int n = arr.length;\n      Random rnd = new Random();\n      for(int i=0; i<n; ++i){\n        int tmp = arr[i];\n        int randomPos = i + rnd.nextInt(n-i);\n        arr[i] = arr[randomPos];\n        arr[randomPos] = tmp;\n      }\n    }\n\n    public static void shuffle(long[] arr){\n      int n = arr.length;\n      Random rnd = new Random();\n      for(int i=0; i<n; ++i){\n        long tmp = arr[i];\n        int randomPos = i + rnd.nextInt(n-i);\n        arr[i] = arr[randomPos];\n        arr[randomPos] = tmp;\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    new Solver();\n    out.flush();\n  }\n\n  static class FastScanner {\n    private InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n\n    public void load() {\n      try {\n        in = new FileInputStream(next());\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int N, boolean oneBased) {\n      if (oneBased) {\n        int[] array = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      } else {\n        int[] array = new int[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      }\n    }\n\n    public long[] nextLongArray(int N, boolean oneBased) {\n      if (oneBased) {\n        long[] array = new long[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      } else {\n        long[] array = new long[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      }\n    }\n  }\n\n  static class Output extends PrintWriter {\n\n    private long startTime;\n\n    public Output(PrintStream ps) {\n      super(ps);\n    }\n\n    public void print(int[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(long[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(String[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(ArrayList a, String separator) {\n      for (int i = 0; i < a.size(); i++) {\n        if (i == 0) print(a.get(i));\n        else print(separator + a.get(i));\n      }\n      println();\n    }\n\n    public void start() {\n      startTime = System.currentTimeMillis();\n    }\n\n    public void time(String s) {\n      long time = System.currentTimeMillis() - startTime;\n      println(s + \"(\" + time + \")\");\n    }\n\n  }\n\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args)throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\t//idea 1 : K/2\ubc88\uae4c\uc9c0\ub9cc \uc2e4\ud589\ud574\uc11c, \uadf8 \ucd5c\uc19f\uac12 *2\ub97c \ud558\uba74 \ub41c\ub2e4\n\t\t//bfs\ub85c i,j\uce78\uc5d0 \ud06c\uac70\ub098 \uac19\uc740 \uac12\uc744 \uac00\uc9c0\uace0 \uc9c4\uc785\ud558\uba74, \uc989\uc2dc cut\n\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\n\t\tn = pint(st.nextToken());\n\t\tm = pint(st.nextToken());\n\t\tk = pint(st.nextToken());\n\t\t\n\t\t//up down left right\n\t\t//0 is wall\n\t\tmap = new int[n][m][4];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst = new StringTokenizer(br.readLine(), \" \");\n\t\t\tfor (int j = 0; j < m-1; j++) {\n\t\t\t\tint temp = pint(st.nextToken());\n\t\t\t\tmap[i][j][3]=temp;\n\t\t\t\tmap[i][j+1][2]=temp;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tst = new StringTokenizer(br.readLine(), \" \");\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tint temp = pint(st.nextToken());\n\t\t\t\tmap[i][j][1]=temp;\n\t\t\t\tmap[i+1][j][0]=temp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = new int[n][m][k/2+1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif(k%2==1) {\n\t\t\t\t\tsb.append(\"-1 \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint min=rec(i,j,0,k/2);\n\t\t\t\t\n\t\t\t\tsb.append(min*2).append(\" \");\n\t\t\t\t\n\t\t\t}sb.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.println(sb);\n\t\t\n\t}\n\tstatic int n,m,k;\n\t//up down left right\n\tstatic int[]dx = {-1,1, 0, 0};\n\tstatic int[]dy = {0, 0, -1,1};\n\tstatic int[][][]map;\n\tstatic int[][][]ans;\n\t\n\tstatic int rec(int x, int y, int cost, int cnt) {\n\t\tif(cnt==0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif(ans[x][y][cnt]!=0)return ans[x][y][cnt];\n\t\t\n\t\tint temp=Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint tx=x+dx[i], ty=y+dy[i];\n\t\t\t\n\t\t\tif(tx<0||tx>=n||ty<0||ty>=m)continue;\n\t\t\t\n\t\t\tif(map[x][y][i]!=0) {\n\t\t\t\ttemp=Math.min(temp, rec(tx, ty, cost, cnt-1)+map[x][y][i]);\n\t\t\t}\n\t\t}\n\t\tans[x][y][cnt]=temp;\n\t\t\n\t\treturn ans[x][y][cnt];\n\t}\n\t\n\tstatic int pint(String s) {\n\t\treturn Integer.parseInt(s);\n\t}\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "    import java.awt.Point;\n\nimport java.io.*;\n\n    import java.text.*;\n\n    import java.util.*;\n\nimport java.util.regex.*;\n\n\n\n    public class Main{\n\n        static class Run implements Runnable{\n\n            //TODO parameters\n\n            final boolean consoleIO = false;\n\n            final String inFile = \"input.txt\";\n\n            final String outFile = \"output.txt\";\n\n            \n\n            int n,m,k;\n\n            int[][] field;\n\n            boolean[][] visited;\n\n            \n\n            LinkedList<Point> queue;\n\n            int[][] steps = {{0,1},{1,0},{0,-1},{-1,0}};\n\n            \n\n            void wave() {\n\n                for(Point p:queue)\n\n                    visited[p.y][p.x] = true;\n\n                \n\n                while(!queue.isEmpty()) {\n\n                    Point cur = queue.removeFirst();\n\n                    for(int i = 0; i < steps.length; ++i) {\n\n                        Point tmp = new Point(cur.x+steps[i][0],cur.y+steps[i][1]);\n\n                        \n\n                        if(ok(tmp)&&!visited[tmp.y][tmp.x]) {\n\n                            queue.add(tmp);\n\n                            visited[tmp.y][tmp.x] = true;\n\n                            field[tmp.y][tmp.x] = field[cur.y][cur.x]+1;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            \n\n            boolean ok(Point p) { \n\n                return p.x>=0 && p.y>=0 && p.x<n && p.y<m;\n\n            }\n\n            \n\n            @Override\n\n            public void run() {\n\n                n = nextInt();\n\n                m = nextInt();\n\n                k = nextInt();\n\n                \n\n                queue = new LinkedList<Point>();\n\n                for(int i = 0; i < k; ++i) \n\n                    queue.add(new Point(nextInt()-1,nextInt()-1));\n\n                \n\n                field = new int[m][n];\n\n                visited = new boolean[m][n];\n\n                wave();\n\n                \n\n                Point maxP = new Point(0,0);\n\n                int maxV = Integer.MIN_VALUE;\n\n                \n\n                for(int i = 0; i < m; ++i)\n\n                    for(int j = 0; j < n; ++j) \n\n                        if(field[i][j] > maxV) {\n\n                            maxV = field[i][j];\n\n                            maxP = new Point(j,i);\n\n                        }\n\n                \n\n                print((maxP.x+1)+\" \"+(maxP.y+1));\n\n                close();\n\n            }\n\n        //=========================================================================================================================\n\n            BufferedReader in;\n\n            PrintWriter out;\n\n            StringTokenizer strTok;\n\n           \n\n            Run() {\n\n                if (consoleIO) {\n\n                    initConsoleIO();\n\n                }\n\n                else {\n\n                    initFileIO();\n\n                }\n\n            }\n\n           \n\n            void initConsoleIO() {\n\n                in = new BufferedReader(new InputStreamReader(System.in));\n\n                out = new PrintWriter(new OutputStreamWriter(System.out));\n\n            }\n\n           \n\n            void initFileIO() {\n\n                try {\n\n                    in = new BufferedReader(new FileReader(inFile));\n\n                    out = new PrintWriter(new FileWriter(outFile));\n\n                } catch (FileNotFoundException e) {\n\n                    e.printStackTrace();\n\n                } catch (IOException e) {\n\n                    e.printStackTrace();\n\n                }\n\n            }\n\n           \n\n            void close() {\n\n                try {\n\n                    in.close();\n\n                    out.close();\n\n                } catch (IOException e) {\n\n                    e.printStackTrace();\n\n                }\n\n            }\n\n           \n\n            int nextInt() {\n\n                return Integer.parseInt(nextToken());\n\n            }\n\n           \n\n            double nextDouble() {\n\n                return Double.parseDouble(nextToken());\n\n            }\n\n           \n\n            float nextFloat() {\n\n                return Float.parseFloat(nextToken());\n\n            }\n\n           \n\n            long nextLong() {\n\n                return Long.parseLong(nextToken());\n\n            }\n\n           \n\n            String nextLine() {\n\n                try {\n\n                    return in.readLine();\n\n                } catch (IOException e) {\n\n                    return \"__NULL\";\n\n                }\n\n            }\n\n           \n\n            boolean hasMoreTokens() {\n\n                return (strTok == null) || (strTok.hasMoreTokens());\n\n            }\n\n           \n\n            String nextToken() {\n\n                while (strTok == null || !strTok.hasMoreTokens()) {\n\n                    String line;\n\n                    try {\n\n                        line = in.readLine();\n\n                        strTok = new StringTokenizer(line);\n\n                    } catch (IOException e) {\n\n                        e.printStackTrace();\n\n                    }\n\n                }\n\n               \n\n                return strTok.nextToken();\n\n            }\n\n           \n\n            void cout(Object o){\n\n                System.out.println(o);\n\n            }\n\n           \n\n            void print(Object o) {\n\n                out.write(o.toString());\n\n            }\n\n            \n\n            void println(Object o) {\n\n                out.write(o.toString() + '\\n');\n\n            }\n\n           \n\n            void printf(String format, Object... args) {\n\n                out.printf(format, args);\n\n            }\n\n           \n\n            String sprintf(String format, Object... args) {\n\n            return MessageFormat.format(format, args);\n\n        }\n\n        }\n\n       \n\n        static class Pair<A, B> {\n\n            A a;\n\n            B b;\n\n           \n\n            A f() {\n\n                return a;\n\n            }\n\n           \n\n            B s() {\n\n                return b;\n\n            }\n\n           \n\n            Pair(A a, B b) {\n\n                this.a = a;\n\n                this.b = b;\n\n            }\n\n           \n\n            Pair(Pair<A, B> p) {\n\n                a = p.f();\n\n                b = p.s();\n\n            }\n\n        }\n\n       \n\n        public static void main(String[] args) throws IOException {\n\n            Run run = new Run();\n\n            Thread thread = new Thread(run);\n\n            thread.run();\n\n        }\n\n    }", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE2 solver = new TaskE2();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE2 {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int t = in.nextInt();\n            while (t-- > 0) {\n                int n = in.nextInt(), m = in.nextInt();\n                int[][] a = new int[m][n];\n                int[] bestMask = new int[1 << n];\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < m; j++) {\n                        a[j][i] = in.nextInt();\n                    }\n                }\n                int[] dp = new int[1 << n];\n                for (int i = 0; i < m; i++) {\n                    int[] array = a[i];\n                    for (int j = 0; j < n; j++) {\n                        int val = array[j];\n                        for (int mask = 0; mask < 1 << n; mask++) {\n                            if ((mask & (1 << j)) == 0) {\n                                dp[mask | (1 << j)] = Math.max(dp[mask | (1 << j)], dp[mask] + val);\n                            }\n                        }\n                    }\n                    for (int mask = 0; mask < 1 << n; mask++) {\n                        int best = 0;\n                        int cur = mask;\n                        for (int j = 0; j < n; j++) {\n                            best = Math.max(best, dp[cur]);\n                            cur = (cur >> 1) | ((cur & 1) << (n - 1));\n                        }\n                        for (int j = 0; j < n; j++) {\n                            dp[cur] = best;\n                            cur = (cur >> 1) | ((cur & 1) << (n - 1));\n                        }\n                    }\n                }\n                out.println(dp[(1 << n) - 1]);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.fill;\nimport static java.util.Arrays.binarySearch;\nimport static java.util.Arrays.sort;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry {\n\t\t\tif (new File(\"input.txt\").exists()) {\n\t\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n\t\t\t}\n\t\t} catch (SecurityException e) {\n\t\t}\n\t\t\n\t\tnew Main().run();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st = new StringTokenizer(\"\");\n\t\n\tboolean[] erat = new boolean [1000 + 1];\n\tint[] primes = new int [1000 + 1];\n\tint pNum = 0;\n\t\n\tvoid run() throws IOException {\n\t\t\n\t\tfor (int i = 2; i <= 1000; i++) {\n\t\t\tif (!erat[i]) {\n\t\t\t\tprimes[pNum++] = i;\n\t\t\t\tfor (int j = i * i; j <= 1000; j += i)\n\t\t\t\t\terat[j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] cnt = new int [1000 + 1];\n\t\tcnt[2] = 0;\n\t\t\n\t\tfor (int i = 3; i <= 1000; i++) {\n\t\t\tcnt[i] = cnt[i - 1];\n\t\t\tif (!erat[i]) {\n\t\t\t\tint r = i - 1;\n\t\t\t\tfor (int j = 1; j < pNum; j++) {\n\t\t\t\t\tif (r == primes[j - 1] + primes[j]) {\n\t\t\t\t\t\tcnt[i]++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\t\n\t\tout.println(k <= cnt[n] ? \"YES\" : \"NO\");\n\t\t\n\t\tout.close();\n\t}\n\t\n\tString nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\t\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\t\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\t\n\tString nextLine() throws IOException {\n\t\tst = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\t\n\tboolean EOF() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString s = in.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn true;\n\t\t\tst = new StringTokenizer(s);\n\t\t}\n\t\treturn false;\n\t}\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashSet;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), d = in.nextInt();\n            long a[] = in.parseLong1D(n);\n            int cnt = 0;\n            HashSet<Long> ans = new HashSet<>();\n            for (long v : a) {\n                long c = v - d;\n                if (isPos(a, c, d)) ans.add(c);\n                c = v + d;\n                if (isPos(a, c, d)) ans.add(c);\n            }\n            out.println(ans.size());\n        }\n\n        private boolean isPos(long a[], long c, long d) {\n            for (long v : a) {\n                if (Math.abs(v - c) < d) return false;\n            }\n            return true;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int nextInt() {\n            return readInt();\n        }\n\n        public long[] parseLong1D(int n) {\n            long r[] = new long[n];\n            for (int i = 0; i < n; i++) {\n                r[i] = readLong();\n            }\n            return r;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.OutputStream;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.PrintWriter;\n\nimport java.util.Arrays;\n\nimport java.util.Random;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.util.StringTokenizer;\n\nimport java.io.BufferedReader;\n\nimport java.util.Comparator;\n\nimport java.io.InputStream;\n\n\n\n/**\n\n * Built using CHelper plug-in\n\n * Actual solution is at the top\n\n */\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        InputStream inputStream = System.in;\n\n        OutputStream outputStream = System.out;\n\n        InputReader in = new InputReader(inputStream);\n\n        PrintWriter out = new PrintWriter(outputStream);\n\n        TaskD solver = new TaskD();\n\n        solver.solve(1, in, out);\n\n        out.close();\n\n    }\n\n\n\n    static class TaskD {\n\n        int BUBEN = 120;\n\n\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n\n            // zz\n\n            Random random = new Random(94739534513L + System.currentTimeMillis());\n\n            int n = in.nextInt();\n\n            int q = in.nextInt();\n\n            int[] a = new int[n];\n\n            for (int i = 0; i < n; ++i) {\n\n                a[i] = in.nextInt();\n\n            }\n\n            int buben = (int) Math.round(Math.sqrt(n));\n\n            TaskD.Query[] queries = new TaskD.Query[q];\n\n            for (int i = 0; i < q; ++i) {\n\n                queries[i] = new TaskD.Query();\n\n                queries[i].l = in.nextInt() - 1;\n\n                queries[i].r = in.nextInt();\n\n                queries[i].k = in.nextInt();\n\n                queries[i].bucket = queries[i].l / buben;\n\n            }\n\n            TaskD.Query[] originalQueries = queries.clone();\n\n            Arrays.sort(queries, new Comparator<TaskD.Query>() {\n\n\n\n                public int compare(TaskD.Query o1, TaskD.Query o2) {\n\n                    if (o1.bucket != o2.bucket) return o1.bucket - o2.bucket;\n\n                    if (o1.r != o2.r) {\n\n                        if ((o1.bucket & 1) == 0) return o1.r - o2.r;\n\n                        else return o2.r - o1.r;\n\n                    }\n\n                    return o1.l - o2.l;\n\n                }\n\n            });\n\n            int[] counts = new int[n + 1];\n\n            int cl = 0;\n\n            int cr = 0;\n\n            for (TaskD.Query qq : queries) {\n\n                while (cr < qq.r) {\n\n                    ++counts[a[cr++]];\n\n                }\n\n                while (cl > qq.l) {\n\n                    ++counts[a[--cl]];\n\n                }\n\n                while (cr > qq.r) {\n\n                    --counts[a[--cr]];\n\n                }\n\n                while (cl < qq.l) {\n\n                    --counts[a[cl++]];\n\n                }\n\n                int res = -1;\n\n                int need = (qq.r - qq.l) / qq.k + 1;\n\n                for (int attempt = 0; attempt < BUBEN; ++attempt) {\n\n                    int x = a[qq.l + random.nextInt(qq.r - qq.l)];\n\n                    if (counts[x] >= need) {\n\n                        if (res < 0 || res > x) res = x;\n\n                    }\n\n                }\n\n                qq.answer = res;\n\n            }\n\n            for (TaskD.Query qq : originalQueries) {\n\n                out.println(qq.answer);\n\n            }\n\n        }\n\n\n\n        static class Query {\n\n            int l;\n\n            int r;\n\n            int k;\n\n            int answer;\n\n            int bucket;\n\n\n\n        }\n\n\n\n    }\n\n\n\n    static class InputReader {\n\n        public BufferedReader reader;\n\n        public StringTokenizer tokenizer;\n\n\n\n        public InputReader(InputStream stream) {\n\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n\n            tokenizer = null;\n\n        }\n\n\n\n        public String next() {\n\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\n                try {\n\n                    tokenizer = new StringTokenizer(reader.readLine());\n\n                } catch (IOException e) {\n\n                    throw new RuntimeException(e);\n\n                }\n\n            }\n\n            return tokenizer.nextToken();\n\n        }\n\n\n\n        public int nextInt() {\n\n            return Integer.parseInt(next());\n\n        }\n\n\n\n    }\n\n}\n\n//truc3", "complexity": "cubic", "problem": "0840_D", "from": "CODEFORCES", "tags": "data structures,probabilities"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\n\n\npublic class Main implements Runnable {\n\n\n\n\tpublic void _main() throws IOException {\n\n\t\tint height = nextInt();\n\n\t\tint width = nextInt();\t\t\n\n\t\tint k = nextInt();\n\n\t\tint[] r = new int[k];\n\n\t\tint[] c = new int[k];\n\n\t\tfor (int i = 0; i < k; i++) {\n\n\t\t\tr[i] = nextInt() - 1;\n\n\t\t\tc[i] = nextInt() - 1;\t\t\t\n\n\t\t}\n\n\t\tint res = 0, R = r[0], C = c[0];\n\n\t\tfor (int i = 0; i < height; i++)\n\n\t\t\tfor (int j = 0; j < width; j++) {\n\n\t\t\t\tint cur = Integer.MAX_VALUE;\n\n\t\t\t\tfor (int z = 0; z < k; z++)\n\n\t\t\t\t\tcur = Math.min(cur, Math.abs(i - r[z]) + Math.abs(j - c[z]));\n\n\t\t\t\tif (res < cur) {\n\n\t\t\t\t\tres = cur;\n\n\t\t\t\t\tR = i;\n\n\t\t\t\t\tC = j;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\tout.print((R + 1) + \" \" + (C + 1));\n\n\t}\n\n\n\n\tprivate BufferedReader in;\n\n\tprivate PrintWriter out;\n\n\tprivate StringTokenizer st;\n\n\n\n\tprivate String next() throws IOException {\n\n\t\twhile (st == null || !st.hasMoreTokens())\n\n\t\t\tst = new StringTokenizer(in.readLine());\n\n\t\treturn st.nextToken();\n\n\t}\n\n\n\n\tprivate int nextInt() throws IOException {\n\n\t\treturn Integer.parseInt(next());\n\n\t}\n\n\n\n\tprivate long nextLong() throws IOException {\n\n\t\treturn Long.parseLong(next());\n\n\t}\n\n\n\n\tprivate double nextDouble() throws IOException {\n\n\t\treturn Double.parseDouble(next());\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Thread(new Main()).start();\n\n\t}\n\n\n\n\tpublic void run() {\n\n\t\ttry {\n\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\n\t\t\tout = new PrintWriter(new FileWriter(\"output.txt\"));\n\n\n\n\t\t\t_main();\n\n\n\n\t\t\tout.close();\n\n\t\t} catch (Exception e) {\n\n\t\t\te.printStackTrace();\n\n\t\t\tSystem.exit(202);\n\n\t\t}\n\n\t}\n\n\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class B {\n    public static void main(String[] args) throws Exception {\n        new B().solve();\n    }\n    \n    void solve() throws IOException {\n        BufferedReader in = new BufferedReader(new\n                InputStreamReader(System.in));\n        // Scanner sc = new Scanner(System.in);\n        \n        String[] sp = in.readLine().split(\" \");\n        \n        int n = Integer.parseInt(sp[0]);\n        int k = Integer.parseInt(sp[1]);\n        int[] a = new int[n];\n        sp = in.readLine().split(\" \");\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(sp[i]);\n        }\n        \n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        int r = 0;\n        map.put(a[r], 1);\n        while (map.size() < k) {\n            r++;\n            if (r == n) {\n                // ng\n                System.out.println(\"-1 -1\");\n                return;\n            }\n            if (map.containsKey(a[r])) {\n                map.put(a[r], map.get(a[r]) + 1);\n            } else {\n                map.put(a[r], 1);\n            }\n        }\n        int l = 0;\n        while (map.get(a[l]) > 1) {\n            map.put(a[l], map.get(a[l]) - 1);\n            l++;\n        }\n        System.out.println((l + 1) + \" \" + (r + 1));\n    }\n}\n\n\n\n\n//\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Aman Kumar Singh\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BSportMafia solver = new BSportMafia();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BSportMafia {\n        int MAXN = 200005;\n        PrintWriter out;\n        InputReader in;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.out = out;\n            this.in = in;\n            long n = nl();\n            long k = nl();\n            long i = 0;\n            k += n;\n            for (i = 0; i < MAXN; i++) {\n                long x = (i * (i + 3)) / 2;\n                if (k == x) {\n                    pn(n - i);\n                    return;\n                }\n            }\n\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.util.Scanner;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] s =sc.nextLine().split(\" \");\n\t\tlong a = Long.parseLong(s[0]);\n\t\tlong b = Long.parseLong(s[1]);\n\n\t\tlong count = 0;\n\t\tlong c = 0;\n\n\t\twhile(true) {\n\t\t\tcount += (a / b);\n\t\t\tc = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t\tif(c == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}\n\t\t\t\t\t\t \t\t\t    \t\t \t   \t    \t\t\t\t\t", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main\n{\n    public static long gcd(long a, long b)\n    {\n        return b==0? a:gcd(b, a%b);\n    }\n    public static long lcm(long a, long b, long c)\n    {\n        long d=a/gcd(a, b)*b;\n        return c/gcd(c, d)*d;\n    }\n    public static long max(long a, long b)\n    {\n        return a>b? a:b;\n    }\n    public static void main(String[] args)\n    {\n        InputReader in = new InputReader();\n        PrintWriter out = new PrintWriter(System.out);\n        long n=in.nextLong();\n        if(n<=2)\n            out.println(n);\n        else\n            out.println(max(lcm(n, n-1, n-2), max(lcm(n, n-1, n-3), lcm(n-1, n-2, n-3))));\n        out.close();\n    }\n}\n\nclass InputReader\n{\n    BufferedReader buf;\n    StringTokenizer tok;\n    InputReader()\n    {\n        buf = new BufferedReader(new InputStreamReader(System.in));\n    }\n    boolean hasNext()\n    {\n        while(tok == null || !tok.hasMoreElements()) \n        {\n            try\n            {\n                tok = new StringTokenizer(buf.readLine());\n            } \n            catch(Exception e) \n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    String next()\n    {\n        if(hasNext()) \n            return tok.nextToken();\n        return null;\n    }\n    int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n    long nextLong()\n    {\n        return Long.parseLong(next());\n    }\n    double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n    BigInteger nextBigInteger()\n    {\n        return new BigInteger(next());\n    }\n    BigDecimal nextBigDecimal()\n    {\n        return new BigDecimal(next());\n    }\n}", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class EdC {\n\tstatic long[] mods = {1000000007, 998244353, 1000000009};\n\tstatic long mod = mods[0];\n\tpublic static MyScanner sc;\n    public static PrintWriter out;\n    static char[][] grid;\n    static int n;\n    static int t;\n    static int[][] dp;\n    static int[] times;\n    static int[] genre;\n\tpublic static void main(String[] omkar) throws Exception{\n\t\t// TODO Auto-generated method stub\n \t\tsc = new MyScanner();\n \t\tout = new PrintWriter(System.out);\n \t\tn = sc.nextInt();\n \t\tt = sc.nextInt();\n \t\ttimes = new int[n];\n \t\tgenre = new int[n];\n \t\tfor(int j =0 ;j<n;j++){\n \t\t\ttimes[j] = sc.nextInt();\n \t\t\tgenre[j] = sc.nextInt();\t\t\n \t\t}\n \t\tdp = new int[1<<n][4];\n \t\tfor(int j = 0;j<1<<n;j++)\n \t\t\tArrays.fill(dp[j],  -1);\n \t\tfor(int j=0;j<1<<n;j++){\n \t\t\tletsgodp(j, 1);\n \t\t\tletsgodp(j, 2);\n \t\t\tletsgodp(j, 3);\n \t\t}\n \t\tint ans = 0;\n \t\tfor(int j=0;j<1<<n;j++){\n \t\t\tint time = 0;\n \t\t\tfor(int k = 0;k<n;k++){\n \t\t\t\tif (((1<<k) & j) != 0){\n \t\t\t\t\ttime+=times[k];\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (time == t){\n \t\t\t\tans+=dp[j][1];\n \t\t\t\tans%=mod;\n \t\t\t\tans+=dp[j][2];\n \t\t\t\tans%=mod;\n \t\t\t\tans+=dp[j][3];\n \t\t\t\tans%=mod;\n \t\t\t}\n \t\t}\n \t\tout.println(ans);\n \t\tout.close();\t\n \t}\n\tpublic static void letsgodp(int mask, int dg){\n\t\tif (dp[mask][dg] != -1)\n\t\t\treturn;\n\t\tdp[mask][dg] = 0;\n\t\tfor(int j = 0;j<n;j++){\n\t\t\tif (((1<<j) & mask) != 0 && genre[j] == dg){\n\t\t\t\tint submask = mask - (1<<j);\n\t\t\t\tint og1 = genre[j]+1 > 3 ? genre[j]-2 : genre[j]+1;\n\t\t\t\tint og2 = genre[j]+2 > 3 ? genre[j]-1 : genre[j]+2;\n\t\t\t\tif (submask != 0){\n\t\t\t\t\tletsgodp(submask, og1);\n\t\t\t\t\tletsgodp(submask, og2);\n\t\t\t\t\tdp[mask][dg] +=(dp[submask][og1] + dp[submask][og2]);\n\t\t\t\t\tdp[mask][dg] %=mod;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[mask][dg] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void sort(int[] array){\n\t\tArrayList<Integer> copy = new ArrayList<Integer>();\n\t\tfor (int i : array)\n\t\t\tcopy.add(i);\n\t\tCollections.sort(copy);\n\t\tfor(int i = 0;i<array.length;i++)\n\t\t\tarray[i] = copy.get(i);\n\t}\n\tstatic String[] readArrayString(int n){\n\t\tString[] array = new String[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.next();\n\t\treturn array;\n\t}\n\tstatic int[] readArrayInt(int n){\n    \tint[] array = new int[n];\n    \tfor(int j = 0;j<n;j++)\n    \t\tarray[j] = sc.nextInt();\n    \treturn array;\n    }\n\tstatic int[] readArrayInt1(int n){\n\t\tint[] array = new int[n+1];\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tarray[j] = sc.nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\tstatic long[] readArrayLong(int n){\n\t\tlong[] array = new long[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextLong();\n\t\treturn array;\n\t}\n\tstatic double[] readArrayDouble(int n){\n\t\tdouble[] array = new double[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextDouble();\n\t\treturn array;\n\t}\n\tstatic int minIndex(int[] array){\n\t\tint minValue = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(long[] array){\n\t\tlong minValue = Long.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(double[] array){\n\t\tdouble minValue = Double.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic long power(long x, long y){\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y%2 == 1)\n\t\t\treturn (x*power(x, y-1))%mod;\n\t\treturn power((x*x)%mod, y/2)%mod;\n\t}\n\tstatic void verdict(boolean a){\n        out.println(a ? \"YES\" : \"NO\");\n    }\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try{\n                str = br.readLine();\n            } \n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n    }\t\n}\n\n//StringJoiner sj = new StringJoiner(\" \"); \n//sj.add(strings)\n//sj.toString() gives string of those stuff w spaces or whatever that sequence is", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer st;\n    \n        \n    void solve() throws IOException {\n        int n=ni();//have bult yet\n        int t=ni();//new house\n        \n        int[] center=new int[n];\n        int[] width=new int[n];\n        for(int i=0;i<n;i++){\n            center[i]=ni();\n            width[i]=ni();\n        }\n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n                if(center[i]>center[j]){\n                    int cent=center[i];\n                    int wid=width[i];\n                    center[i]=center[j];\n                    width[i]=width[j];\n                    center[j]=cent;\n                    width[j]=wid;\n                }\n            }\n        }\n        int count=2;\n        for(int i=0;i<n-1;i++){\n            //min way\n            double ideal=(double)width[i]/2+(double)width[i+1]/2+t;\n\n            //real way\n            double real=center[i+1]-center[i];\n            //out.println(ideal);\n            //out.println(real);\n            if(ideal==real)count++;\n            else{\n                if(ideal<real)count=count+2;\n            }\n        }\n        out.println(count);\n        \n    }\n    \n    public Main() throws IOException {\n        Locale.setDefault(Locale.US);\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        in.close();\n        out.close();\n    }\n\n    String ns() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.valueOf(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.valueOf(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.valueOf(ns());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main();\n    }\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class B {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tlong n = sc.nextInt(), k = sc.nextInt();\n\t\t\n\t\t\n\t\tlong start = 1, end = n;\n\t\t\n\t\twhile(start <= end) {\n\t\t\tlong mid = (start + end) >> 1;\n\t\t\tif(calc(mid) - (n - mid) == k) {\n\t\t\t\tSystem.out.println(n - mid);\n\t\t\t\treturn;\n\t\t\t} else if (calc(mid) - (n - mid) > k) {\n\t\t\t\tend = mid - 1;\n\t\t\t} else {\n\t\t\t\tstart = mid + 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static long calc(long n) {\n\t\treturn (n * n + n) / 2;\n\t}\n}\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.util.Scanner;\n\npublic class LearningMethods {\n\n\tpublic static void main(String[] args) {\n\t\t \n\n    \n    Scanner sc = new Scanner(System.in) ;\n    \n    String number = sc.nextLine();\n  \n  System.out.println(25);\n    \n   \n  \n            \n\t}\n\t\n}", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import static java.util.Arrays.sort;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.SortedSet;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class SecondOrderStatistics implements Runnable\n{\n  public static void main(String[] args) throws Exception\n  {\n    new SecondOrderStatistics().run();\n  }\n\n  private void solve() throws Exception\n  {\n    int n = nextInt();\n    SortedSet<Integer> sset = new TreeSet<Integer>();\n    for (int i = 0; i < n; i++)\n    {\n      int a = nextInt();\n      sset.add(a);\n    }\n\n    if (sset.size() < 2)\n      out.println(\"NO\");\n    else\n    {\n      Integer v[] = (Integer[]) sset.toArray(new Integer[sset.size()]);\n      sort(v);\n      out.println(v[1]);\n    }\n  }\n\n  // -------------- Input/Output routines below ---------------//\n  private BufferedReader in;\n  PrintWriter out;\n  StringTokenizer tokenizer;\n\n  public void run()\n  {\n    // String problem = this.getClass().getName();\n    try\n    {\n      in = new BufferedReader(new InputStreamReader(System.in));\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      solve();\n      out.flush();\n      in.close();\n      out.close();\n    }\n    catch (Exception e)\n    {\n      e.printStackTrace();\n      // System.exit(1);\n    }\n  }\n\n  String nextToken() throws IOException\n  {\n    while (tokenizer == null || !tokenizer.hasMoreTokens())\n    {\n      tokenizer = new StringTokenizer(in.readLine());\n    }\n    return tokenizer.nextToken();\n  }\n\n  int nextInt() throws IOException\n  {\n    return Integer.parseInt(nextToken());\n  }\n\n  long nextLong() throws IOException\n  {\n    return Long.parseLong(nextToken());\n  }\n\n  double nextDouble() throws IOException\n  {\n    return Double.parseDouble(nextToken());\n  }\n\n}", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "/**\n * @author derrick20\n */\nimport java.io.*;\nimport java.util.*;\n\npublic class PetyaSpiders implements Runnable {\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new PetyaSpiders(), \": )\", 1 << 28).start();\n    }\n\n    public void run() {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        N = sc.nextInt();\n        M = sc.nextInt();\n        if (N > M) {\n            int temp = N;\n            N = M;\n            M = temp;\n        }\n        // if the max is 1, then 1x1. Else, one dimension is at least 2, so\n        // our idea of sliding forward a 2xN window works\n        if (M == 1) {\n            out.println(0);\n        } else {\n            int[][][] dp = new int[M][1 << N][1 << N];\n            // N, M are at least 2. N <= 6\n            // base case: try all prev and curr masks, let next = 0\n            for (int prev = 0; prev < 1 << N; prev++) {\n                // we cannot allow the previous to have anything except for 0's.\n                // this matters for M = 2, since at the end of the dp we are\n                // doing a special case for the final column where we need to\n                // ensure both curr AND next are validly covered\n                if (prev == 0) {\n                    for (int curr = 0; curr < 1 << N; curr++) {\n                        // all of these will satisfy the nonexistent columns, of course\n                        dp[0][prev][curr] = Integer.bitCount(curr);\n                    }\n                } else {\n                    // not allowed to have nonzero previous spiders\n                    Arrays.fill(dp[0][prev], oo);\n                }\n            }\n            for (int prev = 0; prev < 1 << N; prev++) {\n                for (int curr = 0; curr < 1 << N; curr++) {\n                    if (isValid(0, prev, curr)) {\n                        dp[1][prev][curr] = Integer.bitCount(prev) + Integer.bitCount(curr);\n                    } else {\n                        dp[1][prev][curr] = oo;\n                    }\n                }\n            }\n            for (int col = 2; col <= M - 2; col++) {\n                for (int next = 0; next < 1 << N; next++) {\n                    for (int curr = 0; curr < 1 << N; curr++) {\n                        dp[col][curr][next] = oo;\n                        for (int prev = 0; prev < 1 << N; prev++) {\n                            if (dp[col - 1][prev][curr] != oo && isValid(prev, curr, next)) {\n                                dp[col][curr][next] = Math.min(dp[col][curr][next], dp[col - 1][prev][curr] + Integer.bitCount(next));\n                            }\n                        }\n                    }\n                }\n            }\n            // to get the answer, we need to act on the last column by trying to\n            // ensure that both the prev row AND the current row are valid\n            // basically, isValid(prev, curr, next) && isValid(curr, next, 0)\n            int ans = oo;\n            for (int next = 0; next < 1 << N; next++) {\n                for (int curr = 0; curr < 1 << N; curr++) {\n                    dp[M - 1][curr][next] = oo;\n                    for (int prev = 0; prev < 1 << N; prev++) {\n                        if (dp[M - 2][prev][curr] != oo && isValid(prev, curr, next) && isValid(curr, next, 0)) {\n                            dp[M - 1][curr][next] = Math.min(dp[M - 1][curr][next], dp[M - 2][prev][curr] + Integer.bitCount(next));\n                            ans = Math.min(ans, dp[M - 1][curr][next]);\n                        }\n                    }\n                }\n            }\n//            for (int c = 1; c < M; c++) {\n//                System.out.println(\"For col = \" + c);\n//                for (int prev = 0; prev < 1 << N; prev++) {\n//                    System.out.println(\"Prev = \" + Integer.toBinaryString(prev));\n//                    for (int curr = 0; curr < 1 << N; curr++) {\n//                        System.out.println(\"Curr = \" + Integer.toBinaryString(curr) + \" gives \" + dp[c][prev][curr] + \" \");\n//                    }\n//                }\n//            }\n            out.println(N * M - ans);\n        }\n        out.close();\n    }\n\n    static int N, M;\n    static int oo = 999;\n    static int[] dr = {1, 0, -1, 0}, dc = {0, 1, 0, -1};\n\n    static boolean isValid(int prev, int curr, int next) {\n        boolean[][] grid = new boolean[N][3];\n        int[] subsets = {prev, curr, next};\n        for (int r = 0; r < N; r++) {\n            for (int c = 0; c < 3; c++) {\n                if ((subsets[c] & 1) > 0) {\n                    grid[r][c] = true;\n                    for (int k = 0; k < 4; k++) {\n                        int r2 = r + dr[k];\n                        int c2 = c + dc[k];\n                        if (0 <= r2 && r2 <= N - 1 && 0 <= c2 && c2 <= 2) {\n                            grid[r2][c2] = true;\n                        }\n                    }\n                }\n                subsets[c] >>= 1;\n            }\n        }\n        for (int r = 0; r < N; r++) {\n            if (!grid[r][1]) {\n                // we only need to ensure the middle is safe\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n\n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n\n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n\n        private char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public int[] nextInts(int N) {\n            int[] res = new int[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = (int) nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongs(int N) {\n            long[] res = new long[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n\n        public double nextDouble() {\n            double cur = nextLong();\n            return c != '.' ? cur : cur + nextLong() / cnt;\n        }\n\n        public double[] nextDoubles(int N) {\n            double[] res = new double[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n\n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n\n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n\n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.util.Scanner;\n\n\n\npublic class Main {\n\n\n\n\tpublic static void main(String[] args) {\n\n\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tlong n = sc.nextLong();\n\n\t\tlong m = sc.nextLong();\n\n\n\n\t\tlong x = 2;\n\n\n\n\t\tfor (; m >= x && n > 1; x <<= 1, n--)\n\n\t\t\t;\n\n\t\tSystem.out.println(m % x);\n\n\n\n\t}\n\n\n\n}\n\n", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.*;\npublic class Main{\n    public static void main(String args[]){\n     Scanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a[]=new int[n];\n    for(int i=0;i<n;i++)\n    a[i]=sc.nextInt();\n    Arrays.sort(a);\n    //boolean \n    int t=1,c=0;\n    for(int i=1;i<n;i++){\n        if(a[i]==a[i-1])\n        {\n            if(i-2>=0&&a[i-2]==a[i-1]-1){\n                System.out.println(\"cslnb\");\n                return;\n            }\n            c++;\n        }\n        if(a[i]==a[i-1]&&a[i]==0){\n        System.out.println(\"cslnb\");\n        return;\n        }\n    }\n    if(c>1)\n    {\n        System.out.println(\"cslnb\");\n        return;\n    }\n    for(int i=0;i<n;i++){\n        if((a[i]-i)%2!=0)\n        t=t^1;\n    }\n    if(t==1)\n    System.out.println(\"cslnb\");\n    else\n    System.out.println(\"sjfnb\");\n    \n    \n    \n    }\n    \n}", "complexity": "linear", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(final String[] args) throws IOException {\n        try(Scanner scan = new Scanner(System.in);\n            PrintWriter print = new PrintWriter(System.out)) {\n            final int n = scan.nextInt();\n            final int m = scan.nextInt();\n            final Pair<Integer, Integer>[] arcs = new Pair[m];\n            for(int k = 0; k < m; ++k) {\n                int i = scan.nextInt();\n                int j = scan.nextInt();\n                --i; --j;\n                arcs[k] = new Pair(i, j);\n            }\n            print.println(calcMinNumStepsToCenterPermGraph(new DirectedGraph(n, arcs)));\n        }\n    }\n\n    public static int calcMinNumStepsToCenterPermGraph(final DirectedGraph graph) {\n        int result = Integer.MAX_VALUE;\n        for(DirectedGraph.Vertex center : graph.vertices) {\n            int num = 2 * graph.vertices.length - 1 - graph.getOutcomingArcs(center).size() -\n                    graph.getIncomingArcs(center).size() + (graph.containsArc(center, center) ? 1 : 0);\n            final int n = graph.vertices.length - 1;\n            final List<Pair<Integer, Integer>> edges = CollectionFactory.createArrayList();\n            for(DirectedGraph.Arc arc : graph.arcs) {\n                if(!center.equals(arc.from) && !(center.equals(arc.to))) {\n                    int i = arc.from.index;\n                    int j = arc.to.index;\n                    if(i > center.index) {\n                        --i;\n                    }\n                    if(j > center.index) {\n                        --j;\n                    }\n                    edges.add(new Pair(i, j));\n                }\n            }\n            final int matching = GraphUtils.calcNumMatchingBipartite(n, n, edges);\n            num += edges.size() - matching;\n            num += n - matching;\n            result = Math.min(result, num);\n        }\n        return result;\n    }\n\n    public static class GraphUtils {\n        public static int calcNumMatchingBipartite(final int n, final int m, final List<Pair<Integer, Integer>> edges) {\n            final MatchingBipartiteSolver solver = new MatchingBipartiteSolver(n, m, edges);\n            return solver.solve();\n        }\n\n        private static class MatchingBipartiteSolver {\n            private final int n;\n            private final int m;\n            private final List<Integer>[] edges;\n            private final Integer[] match;\n            private final boolean[] visited;\n\n            public MatchingBipartiteSolver (final int n, final int m, final List<Pair<Integer, Integer>> edges) {\n                this.n = n;\n                this.m = m;\n                this.edges = new List[n];\n                for(int i = 0; i < n; ++i) {\n                    this.edges[i] = CollectionFactory.createArrayList();\n                }\n                for(final Pair<Integer, Integer> edge: edges) {\n                    this.edges[edge.first].add(edge.second);\n                }\n                match = new Integer[n + m];\n                visited = new boolean[n + m];\n            }\n\n            public int solve() {\n                int result = 0;\n                for(;;) {\n                    Arrays.fill(visited, false);\n                    int gain = 0;\n                    for(int i = 0; i < n; ++i) {\n                        if(match[i] == null && !visited[i] && tryMatch(i)) {\n                            ++gain;\n                        }\n                    }\n                    if(gain > 0) {\n                        result += gain;\n                    } else {\n                        break;\n                    }\n                }\n                return result;\n            }\n\n            private boolean tryMatch(final int i) {\n                visited[i] = true;\n                for(int j : edges[i]) {\n                    if(!visited[j + n]) {\n                        visited[j + n] = true;\n                        final Integer k = match[j + n];\n                        if(k == null || (!visited[k] && tryMatch(k))) {\n                            match[j + n] = i;\n                            match[i] = j + n;\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n        }\n    }\n\n    public static class DirectedGraph {\n        public static class Vertex {\n            public final int index;\n\n            public Vertex(int index) {\n                this.index = index;\n            }\n\n            @Override\n            public boolean equals(Object o) {\n                if (this == o) return true;\n                if (o == null || getClass() != o.getClass()) return false;\n\n                Vertex vertex = (Vertex) o;\n\n                if (index != vertex.index) return false;\n\n                return true;\n            }\n\n            @Override\n            public int hashCode() {\n                return index;\n            }\n        }\n\n        public static class Arc {\n            public final Vertex from;\n            public final Vertex to;\n\n            public Arc(Vertex from, Vertex to) {\n                this.from = from;\n                this.to = to;\n            }\n\n            @Override\n            public boolean equals(Object o) {\n                if (this == o) return true;\n                if (o == null || getClass() != o.getClass()) return false;\n\n                Arc arc = (Arc) o;\n\n                if (!from.equals(arc.from)) return false;\n                if (!to.equals(arc.to)) return false;\n\n                return true;\n            }\n\n            @Override\n            public int hashCode() {\n                int result = from.hashCode();\n                result = 31 * result + to.hashCode();\n                return result;\n            }\n        }\n\n        final public Vertex[] vertices;\n        final public Arc[] arcs;\n\n        public DirectedGraph(final int n, final Pair<Integer, Integer>[] arcs) {\n            vertices = new Vertex[n];\n            this.arcs = new Arc[arcs.length];\n            for(int i = 0; i < n; ++i) {\n                vertices[i] = new Vertex(i);\n            }\n            for(int i = 0; i < arcs.length; ++i) {\n                this.arcs[i] = new Arc(vertices[arcs[i].first], vertices[arcs[i].second]);\n            }\n        }\n\n        public List<Arc> getOutcomingArcs(final Vertex v) {\n            final List<Arc> result = CollectionFactory.createArrayList();\n            for(Arc arc : arcs) {\n                if(arc.from.equals(v)) {\n                    result.add(arc);\n                }\n            }\n            return result;\n        }\n\n        public List<Arc> getIncomingArcs(final Vertex v) {\n            final List<Arc> result = CollectionFactory.createArrayList();\n            for(Arc arc : arcs) {\n                if(arc.to.equals(v)) {\n                    result.add(arc);\n                }\n            }\n            return result;\n        }\n\n        public boolean containsArc(final Vertex from, final Vertex to) {\n            for(Arc arc : arcs) {\n                if(arc.from.equals(from) && arc.to.equals(to)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n\n    public static class MatrixIntMod {\n        final int mod;\n        final int[][] data;\n\n        public MatrixIntMod(final int n, final int m, final int mod) {\n            this.mod = mod;\n            this.data = new int[n][m];\n            for(int i = 0; i < n; ++i) {\n                Arrays.fill(data[i], 0);\n            }\n        }\n\n        public MatrixIntMod(final int[][] data, final int mod) {\n            this(data.length, data[0].length, mod);\n            for(int i = 0; i < data.length; ++i) {\n                for(int j = 0; j < data[i].length; ++j) {\n                    this.data[i][j] = ModNumberUtils.norm(mod, data[i][j]);\n                }\n            }\n        }\n\n        public MatrixIntMod(final int[] data, final int mod) {\n            this(data.length, 1, mod);\n            for(int i = 0; i < data.length; ++i) {\n                this.data[i][0] = ModNumberUtils.norm(mod, data[i]);\n            }\n        }\n\n        public int[] all() {\n            int n = data.length;\n            int m = data[0].length;\n            final int[] res = new int[n * m];\n            int k = 0;\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < m; ++j) {\n                    res[k++] = data[i][j];\n                }\n            }\n            return res;\n        }\n\n        public MatrixIntMod mult(final MatrixIntMod val) {\n            if(data[0].length != val.data.length) throw new RuntimeException(\"dimensions for mult are wrong\");\n            final int n = data.length;\n            final int m = data[0].length;\n            final int l = val.data[0].length;\n            final MatrixIntMod res = new MatrixIntMod(n, l, mod);\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < l; ++j) {\n                    for(int k = 0; k < m; ++k) {\n                        res.data[i][j] = ModNumberUtils.add(mod, res.data[i][j],\n                                ModNumberUtils.mult(mod, data[i][k], val.data[k][j]));\n                    }\n                }\n            }\n            return res;\n        }\n\n        public int[] mult(final int[] ar) {\n            return mult(new MatrixIntMod(ar, mod)).all();\n        }\n\n        public MatrixIntMod power(final long t) {\n            if(t == 0) return eye(data.length, mod);\n            MatrixIntMod res = power(t >> 1);\n            res = res.mult(res);\n            if((t & 1) == 1) {\n                res = res.mult(this);\n            }\n            return res;\n        }\n\n        public static MatrixIntMod eye(final int n, final int mod) {\n            final MatrixIntMod res = new MatrixIntMod(n, n, mod);\n            if(mod > 1) {\n                for(int i = 0; i < n; ++i) {\n                    res.data[i][i] = 1;\n                }\n            }\n            return res;\n        }\n    }\n\n    public static class ModNumberUtils {\n        public static int add(int mod, int a, int b) {\n            a += b;\n            if(a >= mod) {\n                a -= mod;\n            }\n            return a;\n        }\n\n        public static int norm(int mod, int a) {\n            a %= mod;\n            if(a < 0) {\n                a += mod;\n            }\n            return a;\n        }\n\n        public static int mult(int mod, int a, int b) {\n            return (int)((long)a * b % mod);\n        }\n    }\n\n    public static class Pair<X, Y>{\n        public X first;\n        public Y second;\n\n        public Pair(final X first, final Y second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n\n\n    public static class NumberUtils {\n        public static interface Factorizer {\n            List<Integer> factorize(int number);\n        }\n\n        /**\n         * thread safe Factorizer\n         */\n        public static Factorizer createSmallNumberFactorizer(final int upperBound) {\n            return new SmallNumberFactorizer(upperBound);\n        }\n\n        /**\n         * thread safe\n         */\n        private static class SmallNumberFactorizer implements Factorizer {\n            private int[] divisors;\n            private final int upperBound;\n            private boolean prepared = false;\n\n            /**\n             * lazy\n             * time complexity O(n * log(n) * log(log(n))\n             * memory complexity O(n)\n             */\n            public SmallNumberFactorizer(final int upperBound) {\n                this.upperBound = upperBound;\n            }\n\n            private synchronized void prepare() {\n                divisors = new int[upperBound];\n                Arrays.fill(divisors, 0);\n                for(int i = 2; i * i < upperBound; ++i) {\n                    if(divisors[i] == 0) {\n                        for(int j = i * i; j < upperBound; j += i) {\n                            if(divisors[j] == 0) {\n                                divisors[j] = i;\n                            }\n                        }\n                    }\n                }\n                prepared = true;\n            }\n\n            /**\n             * complexity O(result)\n             */\n            public List<Integer> factorize(int number) {\n                synchronized (this) {\n                    if(!prepared) {\n                        prepare();\n                    }\n                }\n                final List<Integer> result = CollectionFactory.createArrayList();\n                if(number < 2) return result;\n                if(number >= upperBound) throw new RuntimeException(\"number should be less than upper bound\");\n                while(divisors[number] > 0) {\n                    result.add(divisors[number]);\n                    number /= divisors[number];\n                }\n                result.add(number);\n                return result;\n            }\n        }\n    }\n\n    public static class CollectionFactory {\n        public static<T> List<T> createArrayList() {\n            return new ArrayList<>();\n        }\n\n        public static<T> List<T> createArrayList(final int capacity) {\n            return new ArrayList<>(capacity);\n        }\n    }\n\n    public static class CollectionUtils {\n        public static<T> List<T> unique(final List<T> list) {\n            final List<T> result = CollectionFactory.createArrayList();\n            T p = null;\n            for(T elem : list) {\n                if(!elem.equals(p)) {\n                    result.add(elem);\n                    p = elem;\n                }\n            }\n            return result;\n        }\n\n        public static<T extends Comparable<T>> T max(final List<T> list, final T lowerBound) {\n            T result = lowerBound;\n            for(T elem : list) {\n                if(elem.compareTo(result) > 0) {\n                    result = elem;\n                }\n            }\n            return result;\n        }\n    }\n\n}\n", "complexity": "cubic", "problem": "0387_D", "from": "CODEFORCES", "tags": "graph matchings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.math.BigInteger;\nimport java.util.HashMap;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ZYCSwing\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n\n            BigInteger sum = new BigInteger(\"0\");\n            for (int i = 0; i < n; ++i) {\n                a[i] = in.nextInt();\n                long tmp = ((long) (2 * i + 1 - n)) * a[i];\n                sum = sum.add(BigInteger.valueOf(tmp));\n            }\n\n            Map<Integer, Integer> cnt = new HashMap<>();\n\n            for (int i = n - 1; i >= 0; --i) {\n                if (cnt.containsKey(a[i] + 1)) {\n                    sum = sum.subtract(BigInteger.valueOf(cnt.get(a[i] + 1)));\n                }\n                if (cnt.containsKey(a[i] - 1)) {\n                    sum = sum.add(BigInteger.valueOf(cnt.get(a[i] - 1)));\n                }\n                if (cnt.containsKey(a[i])) {\n                    cnt.put(a[i], cnt.get(a[i]) + 1);\n                } else {\n                    cnt.put(a[i], 1);\n                }\n            }\n\n            out.println(sum);\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws FileNotFoundException {\n        ConsoleIO io = new ConsoleIO(new InputStreamReader(System.in), new PrintWriter(System.out));\n\n//        String fileName = \"C-large-practice\";\n//        ConsoleIO io = new ConsoleIO(new FileReader(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + fileName + \".in\"), new PrintWriter(new File(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + fileName + \".out\")));\n\n        new Main(io).solve();\n//        new Main(io).solveLocal();\n\n        io.close();\n    }\n\n    ConsoleIO io;\n\n    Main(ConsoleIO io) {\n        this.io = io;\n    }\n\n    ConsoleIO opt;\n\n    Main(ConsoleIO io, ConsoleIO opt) {\n        this.io = io;\n        this.opt = opt;\n    }\n\n    List<List<Integer>> gr = new ArrayList<>();\n\n    long MOD = 1_000_000_007;\n\n    public void solve() {\n        StringBuilder sb = new StringBuilder();\n        int q = io.ri();\n        for(int i = 0; i < q; i++){\n            long n = io.readLong();\n            long k = io.readLong();\n            if(i>0)sb.append(System.lineSeparator());\n            boolean done = false;\n\n            if(n==2 && k == 3){\n                sb.append(\"NO\");\n                done = true;\n            }\n\n            for(int p = 0;n>0 && !done;p++, n--){\n                long count = (1L << (p*2));\n                if(k>count){\n                    k-=count;\n                }else{\n\n                    long path = p==0?1:(1L<<(p-1))*2+((1L<<(p-1))-1)*2+1;\n\n                    if(k<path){\n                        sb.append(\"YES \" + n);\n                    }else{\n                        sb.append(\"YES \" + (n-1));\n                    }\n                    done = true;\n                }\n            }\n\n\n            if(!done){\n                sb.append(\"NO\");\n            }\n\n        }\n        io.writeLine(sb.toString());\n    }\n\n}\n\n\nclass ConsoleIO {\n\n    BufferedReader br;\n    PrintWriter out;\n    public ConsoleIO(Reader reader, PrintWriter writer){br = new BufferedReader(reader);out = writer;}\n    public void flush(){this.out.flush();}\n    public void close(){this.out.close();}\n    public void writeLine(String s) {this.out.println(s);}\n    public void writeInt(int a) {this.out.print(a);this.out.print(' ');}\n    public void writeWord(String s){\n        this.out.print(s);\n    }\n    public void writeIntArray(int[] a, int k, String separator) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < k; i++) {\n            if (i > 0) sb.append(separator);\n            sb.append(a[i]);\n        }\n        this.writeLine(sb.toString());\n    }\n    public void writeLongArray(long[] a, int k, String separator) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < k; i++) {\n            if (i > 0) sb.append(separator);\n            sb.append(a[i]);\n        }\n        this.writeLine(sb.toString());\n    }\n    public int read(char[] buf, int len){try {return br.read(buf,0,len);}catch (Exception ex){ return -1; }}\n    public String readLine() {try {return br.readLine();}catch (Exception ex){ return \"\";}}\n    public long[] readLongArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");long[]r=new long[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Long.parseLong(n[i]);\n        return r;\n    }\n    public int[] readIntArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");int[]r=new int[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Integer.parseInt(n[i]);\n        return r;\n    }\n    public int[] readIntArray(int n) {\n        int[] res = new int[n];\n        char[] all = this.readLine().toCharArray();\n        int cur = 0;boolean have = false;\n        int k = 0;\n        boolean neg = false;\n        for(int i = 0;i<all.length;i++){\n            if(all[i]>='0' && all[i]<='9'){\n                cur = cur*10+all[i]-'0';\n                have = true;\n            }else if(all[i]=='-') {\n                neg = true;\n            }\n            else if(have){\n                res[k++] = neg?-cur:cur;\n                cur = 0;\n                have = false;\n                neg = false;\n            }\n        }\n        if(have)res[k++] = neg?-cur:cur;\n        return res;\n    }\n    public int ri() {\n        try {\n            int r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public long readLong() {\n        try {\n            long r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public String readWord() {\n        try {\n            boolean start = false;\n            StringBuilder sb = new StringBuilder();\n            while (true) {\n                int c = br.read();\n                if (c!= ' ' && c!= '\\r' && c!='\\n' && c!='\\t') {\n                    sb.append((char)c);\n                    start = true;\n                } else if (start || c == -1) return sb.toString();\n            }\n        } catch (Exception ex) {\n            return \"\";\n        }\n    }\n    public char readSymbol() {\n        try {\n            while (true) {\n                int c = br.read();\n                if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t') {\n                    return (char) c;\n                }\n            }\n        } catch (Exception ex) {\n            return 0;\n        }\n    }\n//public char readChar(){try {return (char)br.read();}catch (Exception ex){ return 0; }}\n}\nclass Pair {\n    public Pair(int a, int b) {this.a = a;this.b = b;}\n    public int a;\n    public int b;\n}\nclass PairLL {\n    public PairLL(long a, long b) {this.a = a;this.b = b;}\n    public long a;\n    public long b;\n}\nclass Triple {\n    public Triple(int a, int b, int c) {this.a = a;this.b = b;this.c = c;}\n    public int a;\n    public int b;\n    public int c;\n}\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class AA {\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tpublic int x, y;\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic int compareTo(Pair p) {\n\t\t\tif (p.x != x)\n\t\t\t\treturn x - p.x;\n\t\t\treturn y - p.y;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint t = in.nextInt() * 2;\n\t\tList<Pair> l = new ArrayList<Pair>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c = in.nextInt() * 2;\n\t\t\tint a = in.nextInt();\n\t\t\tl.add(new Pair(c - a, c + a));\n\t\t}\n\t\tCollections.sort(l);\n\t\tint ret = 2;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (l.get(i).x - l.get(i-1).y > t)\n\t\t\t\tret += 2;\n\t\t\telse if (l.get(i).x - l.get(i-1).y == t)\n\t\t\t\tret += 1;\n\t\t}\n\t\tSystem.out.println(ret);\n\t}\n\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\n\n/**\n * Created by Tejas on 18-10-2018.\n */\npublic class Main {\n\n    static HashSet<Integer> adjList[];\n    public static void main(String[]args)throws IOException{\n        BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder stringBuilder=new StringBuilder();\n\n        String temp[]=bufferedReader.readLine().split(\" \");\n        int V=Integer.parseInt(temp[0]);\n        int E=Integer.parseInt(temp[1]);\n        adjList=new HashSet[V];\n        for(int i=0;i<V;i++)\n            adjList[i]=new HashSet<>();\n        for(int i=0;i<E;i++){\n            temp=bufferedReader.readLine().split(\" \");\n            int x=Integer.parseInt(temp[0])-1;\n            int y=Integer.parseInt(temp[1])-1;\n            adjList[y].add(x);\n            adjList[x].add(y);\n        }\n        stringBuilder.append(solve(V)+\"\\n\");\n        System.out.println(stringBuilder);\n    }\n\n    private static long solve(int V) {\n\n        long dp[][]=new long[(1<<V)][V];\n        long count=0;\n        for(int i=0;i<V;i++)\n            dp[(1<<i)][i]=1;\n        for(int mask=1;mask<(1<<V);mask++){\n            // HW starting at pos first and ending at j.\n            int first = Integer.numberOfTrailingZeros(mask);\n            for(int i=0;i<V;i++){\n                if((mask&(1<<i))==0 || first==i) continue;\n                for (int j = 0; j < V; j++)\n                    if (adjList[i].contains(j) && (mask & (1<<j))!=0)\n                        dp[mask][i] += dp[mask ^ (1 << i)][j];\n                //Calculating simple cycles\n                if (Integer.bitCount(mask)>=3)\n                    if(adjList[first].contains(i))\n                        count+=dp[mask][i];\n            }\n        }\n        return count/2;\n    }\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n/**\n * @author thesparkboy\n *\n */\npublic class Pipeline {\n\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new InputReader(System.in);\n\t\tOutputWriter out = new OutputWriter(System.out);\n\t\tlong n = in.readLong();\n\t\tlong k = in.readLong();\n\t\tlong mxsum = (k - 1) * (k - 1 + 1) / 2 + 1;\n\t\tif (n == 1) {\n\t\t\tSystem.out.println(0);\n\t\t} else if (mxsum < n) {\n\t\t\tSystem.out.println(-1);\n\t\t} else {\n\t\t\tlong low = 0, high = k, ans = k;\n\t\t\twhile (low <= high) {\n\t\t\t\tlong mid = (low + high) / 2;\n\t\t\t\tlong sum = mxsum - ((mid - 1) * (mid - 1 + 1) / 2);\n\t\t\t\tif (sum >= n) {\n\t\t\t\t\tans = k - mid;\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tout.close();\n\t}\n\n\tprivate static class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic long readLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tlong sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int readInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuffer res = new StringBuffer();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tstatic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\treturn readString();\n\t\t}\n\t}\n\n\tprivate static class OutputWriter {\n\t\tprivate final PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream outputStream) {\n\t\t\twriter = new PrintWriter(outputStream);\n\t\t}\n\n\t\tpublic OutputWriter(Writer writer) {\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n\n\t\tpublic void print(Object... objects) {\n\t\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(objects[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void printLine(Object... objects) {\n\t\t\tprint(objects);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void close() {\n\t\t\twriter.close();\n\t\t}\n\t}\n}", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport static java.lang.Math.*;\n\n// Solution is at the bottom of code\n\npublic class B implements Runnable{\n\t\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tBufferedReader in;\n\tOutputWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\t\n\tpublic static void main(String[] args){\n\t\tnew Thread(null, new B(), \"\", 128 * (1L << 20)).start();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid init() throws FileNotFoundException{\n\t\tLocale.setDefault(Locale.US);\n\t\t\n\t\tif (ONLINE_JUDGE){\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new OutputWriter(System.out);\n\t\t}else{\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new OutputWriter(\"output.txt\");\n\t\t}\n\t}\n\t\n\t////////////////////////////////////////////////////////////////\n\t\n\tlong timeBegin, timeEnd;\n\n\tvoid time(){\n\t\ttimeEnd = System.currentTimeMillis();\n\t\tSystem.err.println(\"Time = \" + (timeEnd - timeBegin));\n\t}\n\t\n\tvoid debug(Object... objects){\n\t\tif (ONLINE_JUDGE){\n\t\t\tfor (Object o: objects){\n\t\t\t\tSystem.err.println(o.toString());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tpublic void run(){\n\t\ttry{\n\t\t\ttimeBegin = System.currentTimeMillis();\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\t\n\t\t\tinit();\n\t\t\tsolve();\n\t\t\t\n\t\t\tout.close();\n\t\t\ttime();\n\t\t}catch (Exception e){\n\t\t\te.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tString delim = \" \";\n\t\n\tString readString() throws IOException{\n\t\twhile(!tok.hasMoreTokens()){\n\t\t\ttry{\n\t\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t\t}catch (Exception e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn tok.nextToken(delim);\n\t}\n\t\n\tString readLine() throws IOException{\n\t\treturn in.readLine();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tfinal char NOT_A_SYMBOL = '\\0';\n\t\n\tchar readChar() throws IOException{\n\t\tint intValue = in.read();\n\t\t\n\t\tif (intValue == -1){\n\t\t\treturn NOT_A_SYMBOL;\n\t\t}\n\t\t\n\t\treturn (char) intValue;\n\t}\n\t\n\tchar[] readCharArray() throws IOException{\n\t\treturn readLine().toCharArray();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tint readInt() throws IOException {\n\t\treturn Integer.parseInt(readString());\n\t}\n\t\n\tint[] readIntArray(int size) throws IOException {\n\t\tint[] array = new int[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\ttry {\n\t\t\t\tarray[index] = readInt();\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.err.println(index);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\tint[] readSortedIntArray(int size) throws IOException {\n\t\tInteger[] array = new Integer[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = readInt();\n\t\t}\n\t\tArrays.sort(array);\n\t\t\n\t\tint[] sortedArray = new int[size];\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tsortedArray[index] = array[index];\n\t\t}\n\t\t\n\t\treturn sortedArray;\n\t}\n\t\n\tint[] readIntArrayWithDecrease(int size) throws IOException {\n\t\tint[] array = readIntArray(size);\n\t\t\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tarray[i]--;\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tint[][] readIntMatrix(int rowsCount, int columnsCount) throws IOException {\n\t\tint[][] matrix = new int[rowsCount][];\n\t\t\n\t\tfor (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n\t\t\tmatrix[rowIndex] = readIntArray(columnsCount);\n\t\t}\n\t\t\n\t\treturn matrix;\n\t}\n\t\n\tint[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) throws IOException {\n\t\tint[][] matrix = new int[rowsCount][];\n\t\t\n\t\tfor (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n\t\t\tmatrix[rowIndex] = readIntArrayWithDecrease(columnsCount);\n\t\t}\n\t\t\n\t\treturn matrix;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tlong readLong() throws IOException{\n\t\treturn Long.parseLong(readString());\n\t}\n\t\n\tlong[] readLongArray(int size) throws IOException{\n\t\tlong[] array = new long[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readLong();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\n\tdouble readDouble() throws IOException{\n\t\treturn Double.parseDouble(readString());\n\t}\n\t\n\tdouble[] readDoubleArray(int size) throws IOException{\n\t\tdouble[] array = new double[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readDouble();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\t\n\tBigInteger readBigInteger() throws IOException {\n\t\treturn new BigInteger(readString());\n\t}\n\t\n\tBigDecimal readBigDecimal() throws IOException {\n\t\treturn new BigDecimal(readString());\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tPoint readPoint() throws IOException{\n\t\tint x = readInt();\n\t\tint y = readInt();\n\t\treturn new Point(x, y);\n\t}\n\t\n\tPoint[] readPointArray(int size) throws IOException{\n\t\tPoint[] array = new Point[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readPoint();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tList<Integer>[] readGraph(int vertexNumber, int edgeNumber)\n\tthrows IOException{\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<Integer>[] graph = new List[vertexNumber];\n\t\t\n\t\tfor (int index = 0; index < vertexNumber; ++index){\n\t\t\tgraph[index] = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\twhile (edgeNumber-- > 0){\n\t\t\tint from = readInt() - 1;\n\t\t\tint to = readInt() - 1;\n\t\t\t\n\t\t\tgraph[from].add(to);\n\t\t\tgraph[to].add(from);\n\t\t}\n\t\t\n\t\treturn graph;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class IntIndexPair {\n\t\t\n\t\tstatic Comparator<IntIndexPair> increaseComparator = new Comparator<B.IntIndexPair>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {\n\t\t\t\tint value1 = indexPair1.value;\n\t\t\t\tint value2 = indexPair2.value;\n\t\t\t\t\n\t\t\t\tif (value1 != value2) return value1 - value2;\n\t\t\t\t\n\t\t\t\tint index1 = indexPair1.index;\n\t\t\t\tint index2 = indexPair2.index;\n\t\t\t\t\n\t\t\t\treturn index1 - index2;\n\t\t\t}\n\t\t};\n\t\t\n\t\tstatic Comparator<IntIndexPair> decreaseComparator = new Comparator<B.IntIndexPair>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {\n\t\t\t\tint value1 = indexPair1.value;\n\t\t\t\tint value2 = indexPair2.value;\n\t\t\t\t\n\t\t\t\tif (value1 != value2) return -(value1 - value2);\n\t\t\t\t\n\t\t\t\tint index1 = indexPair1.index;\n\t\t\t\tint index2 = indexPair2.index;\n\t\t\t\t\n\t\t\t\treturn index1 - index2;\n\t\t\t}\n\t\t};\n\t\t\n\t\tint value, index;\n\n\t\tpublic IntIndexPair(int value, int index) {\n\t\t\tsuper();\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\t\t\n\t\t\n\t\tpublic int getRealIndex() {\n\t\t\treturn index + 1;\n\t\t}\n\t}\n\t\n\tIntIndexPair[] readIntIndexArray(int size) throws IOException {\n\t\tIntIndexPair[] array = new IntIndexPair[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = new IntIndexPair(readInt(), index);\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class OutputWriter extends PrintWriter {\n\n\t\tfinal int DEFAULT_PRECISION = 12;\n\t\t\n\t\tprotected int precision;\n\t\tprotected String format, formatWithSpace;\n\t\t\n\t\t{\n\t\t\tprecision = DEFAULT_PRECISION;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tpublic OutputWriter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\n\t\tpublic OutputWriter(String fileName) throws FileNotFoundException {\n\t\t\tsuper(fileName);\n\t\t}\n\t\t\n\t\tpublic int getPrecision() {\n\t\t\treturn precision;\n\t\t}\n\n\t\tpublic void setPrecision(int precision) {\n\t\t\tprecision = max(0, precision);\n\t\t\tthis.precision = precision;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tprivate String createFormat(int precision){\n\t\t\treturn \"%.\" + precision + \"f\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void print(double d){\n\t\t\tprintf(format, d);\n\t\t}\n\t\t\n\t\tpublic void printWithSpace(double d){\n\t\t\tprintf(formatWithSpace, d);\n\t\t}\n\n\t\tpublic void printAll(double...d){\n\t\t\tfor (int i = 0; i < d.length - 1; ++i){\n\t\t\t\tprintWithSpace(d[i]);\n\t\t\t}\n\t\t\t\n\t\t\tprint(d[d.length - 1]);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void println(double d){\n\t\t\tprintlnAll(d);\n\t\t}\n\t\t\n\t\tpublic void printlnAll(double... d){\n\t\t\tprintAll(d);\n\t\t\tprintln();\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; \n\tstatic final int[][] steps8 = {\n\t\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1},\n\t\t\t{-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n\t};\n\t\n\tstatic final boolean check(int index, int lim){\n\t\treturn (0 <= index && index < lim);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final boolean checkBit(int mask, int bit){\n\t\treturn (mask & (1 << bit)) != 0;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final long getSum(int[] array) {\n\t\tlong sum = 0;\n\t\tfor (int value: array) {\n\t\t\tsum += value;\n\t\t}\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tstatic final Point getMinMax(int[] array) {\n\t\tint min = array[0];\n\t\tint max = array[0];\n\t\t\n\t\tfor (int index = 0, size = array.length; index < size; ++index, ++index) {\n\t\t\tint value = array[index];\n\t\t\t\n\t\t\tif (index == size - 1) {\n\t\t\t\tmin = min(min, value);\n\t\t\t\tmax = max(max, value);\n\t\t\t} else {\n\t\t\t\tint otherValue = array[index + 1];\n\t\t\t\t\n\t\t\t\tif (value <= otherValue) {\n\t\t\t\t\tmin = min(min, value);\n\t\t\t\t\tmax = max(max, otherValue);\n\t\t\t\t} else {\n\t\t\t\t\tmin = min(min, otherValue);\n\t\t\t\t\tmax = max(max, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new Point(min, max);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid solve() throws IOException {\n\t\tint n = readInt();\n\t\t\n\t\tint a = readInt();\n\t\tint b = readInt();\n\t\t\n\t\tMap<Integer, Integer> numbers = new HashMap<>();\n\t\tint[] p = readIntArray(n);\n\t\tfor (int index = 0; index < n; ++index) {\n\t\t\tnumbers.put(p[index], index);\n\t\t}\n\t\t\n\t\tSet<Integer> used = new HashSet<Integer>();\n\t\tDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\n\t\tint[] answers = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (used.contains(p[i])) continue;\n\t\t\t\n\t\t\tint leftSize = 0;\n\t\t\tfor (int number = p[i], cur = a, next = b;\n\t\t\t\t\tnumbers.containsKey(number) && !used.contains(number);\n\t\t\t\t\tnumber = cur - number, cur = (a ^ b ^ cur), next = (a ^ b ^ next)) {\n\t\t\t\tq.addFirst(number);\n\t\t\t\tused.add(number);\n\t\t\t\t\n\t\t\t\t++leftSize;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int number = b - p[i], cur = a, next = b;\n\t\t\t\t\tnumbers.containsKey(number) && !used.contains(number);\n\t\t\t\t\tnumber = cur - number, cur = (a ^ b ^ cur), next = (a ^ b ^ next)) {\n\t\t\t\tq.addLast(number);\n\t\t\t\tused.add(number);\n\t\t\t}\n\t\t\t\n\t\t\tint curColor = (leftSize & 1);\n\t\t\tif ((q.size() & 1) == 1) {\n\t\t\t\tint first = q.peekFirst();\n\t\t\t\t\n\t\t\t\t// 0 - a, 1 - b\n\t\t\t\tif (curColor == 0 && (first << 1) == b\n\t\t\t\t\t\t||\n\t\t\t\t\tcurColor == 1 && (first << 1) == a) {\n\t\t\t\t\tq.poll();\n\t\t\t\t\t\n\t\t\t\t\tcurColor ^= 1;\n\t\t\t\t\t\n\t\t\t\t\tint firstIndex = numbers.get(first);\n\t\t\t\t\tanswers[firstIndex] = curColor;\n\t\t\t\t} else {\n\t\t\t\t\tint last = q.peekLast();\n\t\t\t\t\t\n\t\t\t\t\t// 0 - b, 1 - a\n\t\t\t\t\tif (curColor == 0 && (last << 1) == a\n\t\t\t\t\t\t\t||\n\t\t\t\t\t\tcurColor == 1 && (first << 1) == b) {\n\t\t\t\t\t\tq.poll();\n\t\t\t\t\t\t\n\t\t\t\t\t\tint firstIndex = numbers.get(first);\n\t\t\t\t\t\tanswers[firstIndex] = curColor;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(\"NO\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (q.size() > 0) {\n\t\t\t\tint first = q.poll();\n\t\t\t\tint second = q.poll();\n\t\t\t\t\n\t\t\t\tint firstIndex = numbers.get(first);\n\t\t\t\tint secondIndex = numbers.get(second);\n\t\t\t\t\n\t\t\t\tanswers[firstIndex] = curColor;\n\t\t\t\tanswers[secondIndex] = curColor;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(\"YES\");\n\t\tfor (int answer : answers) {\n\t\t\tout.print(answer + \" \");\n\t\t}\n\t\tout.println();\n\t}\n}\n\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class C{\n    static PrintWriter out;\n    static InputReader in;\n    public static void main(String args[]){\n        out = new PrintWriter(System.out);\n        in = new InputReader();\n        new C();\n        out.flush(); out.close();\n    }   \n    C(){\n       int a = solve();\n       out.print(a == 0 ? \"tokitsukaze\" : a == 1 ? \"quailty\" : \"once again\");\n    }\n    int n, k;\n    char ch[]; int a[], c0 = 0, c1 = 0;\n    TreeSet<Integer> ts[] = new TreeSet[2];\n    boolean check(){\n        int min = 0, max = n;\n        if(!ts[0].isEmpty()){\n            min = ts[0].first(); max = ts[0].last();\n            if(max - min + 1 > k)return true;\n        }\n        if(!ts[1].isEmpty()){\n            min = ts[1].first(); max = ts[1].last();\n            if(max - min + 1 > k)return true;   \n        }\n        return false;\n    }\n    int solve(){\n        n  = in.nextInt(); k = in.nextInt();\n        ch = in.next().trim().toCharArray(); a = new int[n];\n        for(int i = 0; i < n; i++)c1 += a[i] = ch[i] - '0';\n        c0 = n - c1;\n        for(int i = 0; i < k; i++){\n            if(a[i] == 0)c0--; else c1--;\n        }\n        if(c0 == 0 || c1 == 0)return 0;\n        for(int i = k; i < n; i++){\n            if(a[i] == 0)c0--; else c1--;\n            if(a[i - k] == 0)c0++; else c1++;\n            if(c0 == 0 || c1 == 0)return 0;\n        }\n\n        for(int i = 0; i < 2; i++)ts[i] = new TreeSet<>();\n        for(int i = 0; i < n; i++){\n            ts[a[i]].add(i);\n        }\n        for(int i = 0; i < k; i++){\n            ts[a[i]].remove(i);\n        }\n        if(check())return 2;\n        for(int i = k; i < n; i++){\n            ts[a[i]].remove(i); ts[a[i - k]].add(i - k);\n            if(check())return 2;\n        }\n        return 1;\n    }\n    public static class InputReader{\n        BufferedReader br;\n        StringTokenizer st;\n        InputReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        public String next(){\n            while(st == null || !st.hasMoreTokens()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch(IOException e){}\n            }\n            return st.nextToken();\n        }\n    }\n}\n        ", "complexity": "linear", "problem": "1190_C", "from": "CODEFORCES", "tags": "brute force,games,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class ProblemF {\n    private static boolean debug = false;\n\n    private static int N;\n    private static int[] A;\n\n    private static void solveProblem(InputStream instr) throws Exception {\n        InputReader sc = new InputReader(instr);\n        int testCount = 1;\n        if (debug) {\n            testCount = sc.nextInt();\n        }\n\n        for (int t = 1; t <= testCount; t++) {\n            printDebug(\"------ \" + t + \" ------\");\n            N = sc.nextInt();\n            A = readInts(sc, N);\n            Object result = solveTestCase();\n            System.out.println(result);\n        }\n    }\n\n    private static Object solveTestCase() {\n        int sum[] = new int[N];\n        sum[0] = A[0];\n        for (int i = 1; i < N; i++) {\n            sum[i] = sum[i - 1] + A[i];\n        }\n        TreeMap<Integer, List<int[]>> map = new TreeMap<>();\n        for (int i = 0; i < N; i++) {\n            for (int j = i; j < N; j++) {\n                int groupSum = sum[j] - (i == 0 ? 0 : sum[i - 1]);\n                map.putIfAbsent(groupSum, new ArrayList<>());\n                map.get(groupSum).add(new int[]{i, j});\n            }\n        }\n        int max = -1;\n        List<int[]> maxAnswer = null;\n        for (Map.Entry<Integer, List<int[]>> entry : map.entrySet()) {\n            List<int[]> values = entry.getValue();\n            if (values.size() <= max) {\n                continue;\n            }\n            List<int[]> curr = findMax(values);\n            if (curr.size() > max) {\n                max = curr.size();\n                maxAnswer = curr;\n\n            }\n        }\n        List<String> answer = new ArrayList<>();\n        for (int[] value : maxAnswer) {\n            answer.add((value[0] + 1) + \" \" + (value[1] + 1));\n        }\n        return max + \"\\n\" + joinValues(answer, \"\\n\");\n    }\n\n    private static List<int[]> findMax(List<int[]> values) {\n        values.sort(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                return o1[1] - o2[1];\n            }\n        });\n        List<int[]> answer = new ArrayList<>();\n        int right = -1;\n        for (int i = 0; i < values.size(); i++) {\n            int[] value = values.get(i);\n            if (value[0] > right) {\n                answer.add(value);\n                right = value[1];\n            }\n        }\n        return answer;\n    }\n\n    private static int[] readInts(InputReader sc, int N) throws Exception {\n        int[] arr = new int[N];\n        for (int i = 0; i < N; i++) {\n            arr[i] = sc.nextInt();\n        }\n        return arr;\n    }\n\n    private static String joinValues(List<? extends Object> list, String delim) {\n        return list.stream().map(Object::toString).collect(Collectors.joining(delim));\n    }\n\n    private static String joinValues(int[] arr, String delim) {\n        List<Object> list = new ArrayList<>();\n        for (Object value : arr) {\n            list.add(value);\n        }\n        return list.stream().map(Object::toString).collect(Collectors.joining(delim));\n    }\n\n    public static void printDebug(Object str) {\n        if (debug) {\n            System.out.println(\"DEBUG: \" + str);\n        }\n    }\n\n    private static final class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int curChar;\n        private int Chars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() throws Exception {\n            if (curChar >= Chars) {\n                curChar = 0;\n                Chars = stream.read(buf);\n                if (Chars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public final int nextInt() throws Exception {\n            return (int)nextLong();\n        }\n\n        public final long nextLong() throws Exception {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n                if (c == -1)\n                    throw new IOException();\n            }\n            boolean negative = false;\n            if (c == '-') {\n                negative = true;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += (c - '0');\n                c = read();\n            } while (!isSpaceChar(c));\n            return negative ? (-res) : (res);\n        }\n\n        public final int[] nextIntBrray(int size) throws Exception {\n            int[] arr = new int[size];\n            for (int i = 0; i < size; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n\n        public final String next() throws Exception {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char)c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public final String nextLine() throws Exception {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char)c);\n                c = read();\n            } while (c != '\\n' && c != -1);\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        long currTime = System.currentTimeMillis();\n        if (debug) {\n            solveProblem(new FileInputStream(new File(\"input.in\")));\n            System.out.println(\"Time: \" + (System.currentTimeMillis() - currTime));\n        } else {\n            solveProblem(System.in);\n        }\n    }\n\n}\n", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class A {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tList<Integer> list = new ArrayList<Integer>(), list2;\n\t\tfor (; n-- > 0;) {\n\t\t\tlist.add(scan.nextInt());\n\t\t}\n\t\tlist2 = new ArrayList<Integer>(list);\n\t\tCollections.sort(list2, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn o1 % 2 - o2 % 2;\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(list.indexOf(list2.get(list2.get(1) % 2 > 0 ? 0\n\t\t\t\t: list2.size() - 1)) + 1);\n\t}\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.*;\n\npublic class C {\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        char[] s = new char[n];\n        String line = in.next();\n        int ct=0,ht=0;\n        for(int i=0;i<n;i++) //count animals\n            if(line.charAt(i)=='T')\n                ct++;\n            else\n                ht++;\n        \n        int cnt = 1000000000;\n        int[] c = new int[2];\n        char[] cc = new char[2];\n        if(ct<ht)\n        {\n            c[0] = ct;\n            c[1] = ht;\n            cc[0] = 'T';\n            cc[1] = 'H';\n        }else{\n            c[0] = ht;\n            c[1] = ct;\n            cc[0] = 'H';\n            cc[1] = 'T';\n        }\n        \n        for(int i=0;i<n;i++)\n        {\n            int ptr = i;\n            for(int j=0;j<c[0];j++) //fill First\n            {\n                s[ptr] = cc[0];\n                ptr = (ptr+1)%n;\n            }\n            for(int j=0;j<c[1];j++) //fill Second\n            {\n                s[ptr] = cc[1];\n                ptr = (ptr+1)%n;\n            }\n            //check\n            int ch = 0;\n            for(int j=0;j<n;j++) //difference\n                if(s[j]!=line.charAt(j)&&s[j]==cc[0])\n                    ch++;\n            cnt = Math.min(cnt,ch);\n        }\n        \n        System.out.print(cnt);\n    }\n}\n\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.awt.Point;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\nimport java.io.BufferedReader;\n\nimport java.io.FileNotFoundException;\n\nimport java.io.FileReader;\n\nimport java.io.FileWriter;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class Main {\n\n\t\n\n\n\n\tpublic static void main(String[] args) throws IOException{\n\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner scan = new Scanner(\"input.txt\");\n\n\t\tPrintWriter out = new PrintWriter(new FileWriter(\"output.txt\"));\n\n\t\t\n\n\t\tint n,m;\n\n\t\tn = scan.nextInt();\n\n\t\tm = scan.nextInt();\n\n\n\n\t\tboolean visited[][] = new boolean[n][m];\n\n    \n\n\t\tint numOfStartingPoints;\n\n\t\tnumOfStartingPoints = scan.nextInt();\n\n\t\t    \t\t\n\n\t\tint resX = 0, resY = 0;\n\n\t\t\n\n\t\tQueue<Point> que = new LinkedList<Point>();\n\n\t\tfor (int i = 0; i < numOfStartingPoints; i++) {\n\n\t\t\tint x = scan.nextInt() - 1;\n\n\t\t\tint y = scan.nextInt() - 1;\n\n\t\t\tque.add(new Point(x, y));\n\n\t\t\tvisited[x][y] = true;\n\n\t\t}\n\n\t\t\n\n\t\twhile (true) {\n\n\t\t\tPoint current = que.poll();\n\n\n\n\t\t\tif (current == null) {\n\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\n\t\t\t\tresX = current.x;\n\n\t\t\t\tresY = current.y;\n\n\t\t\t\t\n\n\t\t\t\tif (current.x + 1 < n && !visited[current.x + 1][current.y])\n\n\t\t\t\t{\n\n\t\t\t\t\tque.add(new Point(current.x + 1, current.y));\n\n\t\t\t\t\tvisited[current.x + 1][current.y] = true;\n\n\n\n\n\n\t\t\t\t}\n\n\t\t\t\tif (current.y + 1 < m && !visited[current.x][current.y + 1])\n\n\t\t\t\t{\n\n\t\t\t\t\tque.add(new Point(current.x, current.y + 1));\n\n\t\t\t\t\tvisited[current.x][current.y + 1] = true;\n\n\t\t\n\n\n\n\t\t\t\t}\n\n\t\t\t\tif (current.x - 1 >= 0 && !visited[current.x - 1][current.y])\n\n\t\t\t\t{\n\n\t\t\t\t\tque.add(new Point(current.x - 1, current.y));\n\n\t\t\t\t\tvisited[current.x - 1][current.y] = true;\n\n\t\t\t\t\n\n\t\t\t\t}\n\n\t\t\t\tif (current.y - 1 >= 0 && !visited[current.x][current.y - 1])\n\n\t\t\t\t{\n\n\t\t\t\t\tque.add(new Point(current.x, current.y - 1));\n\n\t\t\t\t\tvisited[current.x][current.y - 1] = true;\n\n\t\t\t\t\n\n\t\t\t\t}\n\n\n\n\t\t\t\t\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\t\n\n\t\tout.printf(\"%d %d\\n\", ++resX, ++resY);\n\n\t\tout.close();\n\n\t\t    \n\n\t}\n\n\tstatic class Scanner \n\n\t{\n\n\t\tStringTokenizer st;\n\n\t\tBufferedReader br;\n\n\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\t\n\n\t\tpublic Scanner(String s) throws FileNotFoundException{\tbr = new BufferedReader(new FileReader(s));}\n\n\n\n\t\tpublic String next() throws IOException \n\n\t\t{\n\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\n\t\t}\n\n\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\n\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(next()); }\n\n\n\n\t\tpublic boolean ready() throws IOException {return br.ready();} \n\n\t}\n\n}\n\n\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[])\n    {\n        long start=System.currentTimeMillis();\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=1;\n        while(T-->0)\n        {\n            long n=input.nextLong();\n            int m=input.nextInt();\n            long k=input.nextLong();\n            long p[]=new long[(int)m];\n            for(int i=0;i<m;i++)\n            {\n                p[i]=input.nextLong();\n            }\n            long sum=0;\n            int i=0;\n            int count=0;\n            while(i<m)\n            {\n                HashSet<Long> set=new HashSet<>();\n                int ind=-1;\n                for(int j=i;j<m;j++)\n                {\n                    long x=p[j]-sum;\n                    long y=0;\n                    if(x%k==0)\n                    {\n                        y=x/k;\n                    }\n                    else\n                    {\n                        y=x/k;\n                        y++;\n                    }\n                    set.add(y);\n                    if(set.size()>1)\n                    {\n                        ind=j;\n                        break;\n                    }\n                }\n                count++;\n                if(ind==-1)\n                {\n                    break;\n                }\n                sum+=ind-i;\n                i=ind;\n            }\n            out.println(count);\n        }\n        out.close();\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "linear", "problem": "1191_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class d {\n\n\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int n = in.nextInt();\n        long[] arr = new long[n];//in.nextLongArray(n);\n        for (int i = 0; i < n; i++) {\n            //if (i < n / 2) arr[i] = 1;\n            //else arr[i] = 1000000000;\n            arr[i] = in.nextLong();\n        }\n        long sum = 0;\n        long count = 0;\n        \n        TreeSet<Long> ts = new TreeSet<>();\n        ts.add(1L);\n        long oo = 1000000000 + 100;\n        ts.add(oo);\n        for (long a : arr) {\n            a += 10;\n            ts.add(a);\n            ts.add(a - 2);\n            ts.add(a + 2);\n        }\n        \n        long[] inds = new long[ts.size()];\n        int idx = 0;\n        for (long a : ts) {\n            inds[idx++] = a;\n        }\n        \n        SuperBIT bit1 = new SuperBIT(inds);\n        SuperBIT bit2 = new SuperBIT(inds);\n        BigInteger ans = BigInteger.valueOf(0);\n        \n        for (long a : arr) {\n            a += 10;\n            \n            long countLess = bit1.queryCompr(1, a - 2);\n            long sumLess = bit2.queryCompr(1, a - 2);\n            \n            long countMore = bit1.queryCompr(a + 2, oo);\n            long sumMore = bit2.queryCompr(a  + 2, oo);\n            \n            //System.out.println(a + \"  \" + countLess + \"  \" + sumLess + \"  \" + countMore + \"  \" + sumMore);\n            bit1.updateCompr(a, 1);\n            bit2.updateCompr(a, a);\n            \n            long tmp = 0;\n            tmp += countLess * a - sumLess;\n            tmp -= sumMore - countMore * a;\n            ans = ans.add(BigInteger.valueOf(tmp));\n        }\n        \n        out.println(ans);\n        \n        \n        out.close();\n    }\nstatic class SuperBIT {\n  long[] dataMul, dataAdd;\n  SuperBIT(int n) {\n    dataMul = new long[n];\n    dataAdd = new long[n];\n  }\n  void update(int left, int right, long val) {\n    internalUpdate(left, val, -val * (left-1));\n    internalUpdate(right, -val, val * right);\n  }\n  void internalUpdate(int at, long mul, long add) {\n    while (at < dataMul.length) {\n      dataMul[at] += mul;\n      dataAdd[at] += add;\n      at |= (at + 1);\n    }\n  }\n  long query(int at) {\n    long mul = 0;\n    long add = 0;\n    int start = at;\n    while(at >= 0) {\n      mul += dataMul[at];\n      add += dataAdd[at];\n      at = (at & (at + 1)) -1;\n    }\n    return mul * start + add;\n  }\n  long query(int left, int right) {\n    if (left > right) {\n      int temp = left;\n      left = right;\n      right = temp;\n    }\n    return query(right) - (left > 0 ? query(left-1) : 0);\n  }\n  long[] indices; // Used for compressed BIT\n  // Compressed BIT constructor\n  // A BIT that only stores the values that will be updated. \n  // indices is a sorted array of all the unique indices \n  // that would be used for this BIT.\n  public SuperBIT(long[] indices) {\n    this.indices = indices;\n    dataMul = new long[indices.length];\n    dataAdd = new long[indices.length];\n  }\n \n  // Search for the index in the array. If the index was not found, \n  // return the first index lower than the search index.\n  int binSearch(long ind) {\n    int low = 0;\n    int high = dataMul.length-1;\n    while(low < high) {\n      int mid = (low + high+1)/2;\n      if(indices[mid] == ind)\n        return mid;\n      else if(indices[mid] < ind) \n        low = mid;\n      else if(indices[mid] > ind) \n        high = mid-1;\n    }\n    if(indices[low] > ind)\n      --low;\n    return low;\n  }\n  \n  // Read the largest index less than or equal to the given index.\n  long queryCompr(long index) {\n    return query(binSearch(index));\n  }\n  long queryCompr(long left, long right) {\n    return query(binSearch(left), binSearch(right));\n  }\n  // Update a specific index by a value. If the index is not in this \n  // compressed BIT, the index below will be updated.\n  void updateCompr(long index, long val) {\n    int ind = binSearch(index);\n    update(ind, ind, val);\n  }\n  void updateCompr(long left, long right, long val) {\n    update(binSearch(left), binSearch(right), val);\n  } \n}\n    static Random rand = new Random();\n    static void sort(int[] a) {\n        int n = a.length;\n        for (int i = a.length - 1; i > 0; i--) {\n            int j = rand.nextInt(i + 1);\n            int tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n        Arrays.sort(a);\n    }\n    static void sort(long[] a) {\n        int n = a.length;\n        for (int i = a.length - 1; i > 0; i--) {\n            int j = rand.nextInt(i + 1);\n            long tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n        Arrays.sort(a);\n    }\n    static void sort(double[] a) {\n        int n = a.length;\n        for (int i = a.length - 1; i > 0; i--) {\n            int j = rand.nextInt(i + 1);\n            double tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n        Arrays.sort(a);\n    }\n    static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }\n    static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    static long[] eEuclid(long a, long b) {\n        if (b == 0) return new long[] { a, 1, 0 };\n        long[] ans = eEuclid(b, a % b);\n        long temp = ans[1] - ans[2] * (a / b);\n        ans[1] = ans[2];  ans[2] = temp;\n        return ans;\n    }\n    static long modInverse(long a, long m) {\n        return ((eEuclid(a, m)[1] % m) + m) % m;\n    }\n    static class IntList {\n        static int[] EMPTY = {};\n        int[] a = EMPTY;\n        int n = 0;\n        void add(int v) {\n            if (n >= a.length)\n                a = Arrays.copyOf(a, (n << 2) + 8);\n            a[n++] = v;\n        }\n        int get(int idx) {\n            return a[idx];\n        }\n        int size() {\n            return n;\n        }\n    }\n    static class DisjointSet {\n        int[] s, r;\t\n\tpublic DisjointSet(int n) {\n            s = new int[n]; r = new int[n];\n            for (int i = 0; i < n; i++) s[i] = i;\n        }\t\n        public int find(int i) { return s[i] == i ? i : (s[i] = find(s[i])); }\n\tpublic void union(int a, int b) {\n            if(r[a = find(a)] == r[b = find(b)]) r[a]++;\n            if(r[a] >= r[b]) s[b] = a; else s[a] = b;\n        }\n    }\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastScanner(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n        public String next() throws IOException {\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n        public int[] nextOffsetIntArray(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextInt() - 1;\n            return arr;\n        }\n        public int[] nextIntArray(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n        public int[][] nextIntArray(int n, int m) throws IOException {\n            int[][] arr = new int[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    arr[i][j] = nextInt();\n            return arr;\n        }\n        public long[] nextLongArray(int n) throws IOException {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextLong();\n            return arr;\n        }\n        public long[][] nextLongArray(int n, int m) throws IOException {\n            long[][] arr = new long[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    arr[i][j] = nextLong();\n            return arr;\n        }\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] arr = new double[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextDouble();\n            return arr;\n        }\n        public double[][] nextDoubleArray(int n, int m) throws IOException {\n            double[][] arr = new double[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    arr[i][j] = nextDouble();\n            return arr;\n        }\n        public char[][] nextCharArray(int n, int m) throws IOException {\n            char[][] arr = new char[n][];\n            for (int i = 0; i < n; i++)\n                arr[i] = next().toCharArray();\n            return arr;\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Solve{\n    public static void main(String[] args) throws Exception{\n        Scanner sc=new Scanner(System.in);\n        PrintWriter out =new PrintWriter(System.out);\n        int size=(int)1e7+1;\n        int[] pr=new int[size];\n        for(int i=0;i<size;i++){\n            pr[i]=i;\n        }\n        for(int i=2;i*i<size;i++){\n           if(pr[i]==i){int val=i*i;\n            for(int j=val;j<=size;j+=val){\n                 pr[j]=j/val;\n            }\n           }\n        }\n        int t=sc.nextInt();\n        int[] dp=new int[size];\n        Arrays.fill(dp,-1);\n        while(t-->0){\n            int n=sc.nextInt();\n            int k=sc.nextInt();\n            int[] ar=new int[n];\n            for(int i=0;i<n;i++){\n                int a=sc.nextInt();\n                ar[i]=pr[a];\n            }\n            int[] ans=new int[k+1];\n            int[] ind=new int[k+1];\n            for(int i=0;i<n;i++){\n                for(int h=k;h>=0;h--){\n                    if(dp[ar[i]]>=ind[h]){\n                        ans[h]++;\n                        ind[h]=i;\n                    }\n                    if(h>0 && (ans[h-1]<ans[h] ||(ans[h-1]==ans[h] && ind[h-1]>ind[h])))\n                    {\n                        ans[h]=ans[h-1];\n                        ind[h]=ind[h-1];\n                    }\n                }\n                dp[ar[i]]=i;\n            }\n            out.println(ans[k]+1);\n            for(int i=0;i<n;i++)dp[ar[i]]=-1;\n        }\n        out.close();\n    }\n}", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\n/*\n\n */\npublic class C455 {\n\tstatic int N;\n\tstatic final int mod = 1_000_000_007;\n\tstatic int[][] memo;\n\tstatic int[] list;\n\tpublic static void main(String[] args) {\n\t\tFS scan = new FS(System.in);\n\t\t\n\t\tN = scan.nextInt();\n\t\tlist = new int[N];\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tlist[i] = scan.next().equals(\"s\")?0:1;\n\t\t}\n\t\tif(list[N-1] == 1) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tmemo = new int[N+1][N+2];\n\t\tArrays.fill(memo[N], 1);\n\t\tint[] sum = new int[N+2];\n\t\t\n\t\tfor(int i=N-1;i>=0;i--) {\n\t\t\tsum[0] = memo[i+1][0];\n\t\t\tfor(int j=1;j<sum.length;j++) {\n\t\t\t\tsum[j] = sum[j-1] + memo[i+1][j];\n\t\t\t\tsum[j] %= mod;\n\t\t\t}\n\t\t\tfor(int j=0;j<=N;j++) {\n\t\t\t\tif (list[i]==1 && (i==0 || list[i-1]==1))\n\t\t\t\t\tmemo[i][j] = memo[i+1][j+1];\n\t\t\t\telse if(i==0 || list[i-1] == 1)\n\t\t\t\t\tmemo[i][j] = memo[i+1][j];\n\t\t\t\telse if (list[i]==1){\n//\t\t\t\t\tfor(int k=0;k<=j;k++) {\n//\t\t\t\t\t\tmemo[i][j] += memo[i+1][k+1];\n//\t\t\t\t\t}\n\t\t\t\t\tmemo[i][j] = sum[j+1] - sum[0] + mod;\n\t\t\t\t\tmemo[i][j] %= mod;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (list[i]==0) {\n\t\t\t\t\tmemo[i][j] = sum[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tfor(int i=0;i<=N;i++) {\n//\t\t\tfor(int j=0;j<=N;j++) {\n//\t\t\t\tSystem.out.print(memo[i][j]+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n//\t\tSystem.out.println();\n\t\tSystem.out.println(memo[0][0]);\n\t}\n\t\n\tprivate static class FS {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FS(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tString next(){\n\t\t\twhile(st==null||!st.hasMoreElements()){\n\t\t\t\ttry{st = new StringTokenizer(br.readLine());}\n\t\t\t\tcatch(IOException e){e.printStackTrace();}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {return Integer.parseInt(next());}\n\t\tlong nextLong() {return Long.parseLong(next());}\n\t\tdouble nextDouble() { return Double.parseDouble(next());}\n\t}\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.*;\n\npublic class Solution {\n\n\n    public static void main(String[] args) {\n\n        class Pair {\n            int start;\n            int end;\n\n            public Pair(int start, int end) {\n                this.start = start;\n                this.end = end;\n            }\n        }\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] array = new int[n];\n        for (int i=0; i<n; i++) array[i] = sc.nextInt();\n\n\n        int maxLen = 0;\n        int key = -1;\n        HashMap<Integer, List<Pair>> ans = new HashMap<>();\n        for (int i=0; i<n; i++){\n            int currSum = 0;\n            for (int j=i; j>=0; j--){\n                currSum = currSum + array[j];\n                if (!ans.containsKey(currSum)){\n                    ans.put(currSum, new ArrayList<>());\n                }\n                List<Pair> pairs = ans.get(currSum);\n                if (pairs.size() == 0 || pairs.get(pairs.size()-1).end <= j){\n                    pairs.add(new Pair(j+1, i+1));\n                }\n                if (pairs.size() > maxLen){\n                    maxLen = pairs.size();\n                    key = currSum;\n                }\n            }\n\n        }\n\n        System.out.println(maxLen);\n        for (Pair pair : ans.get(key)){\n            System.out.println(pair.start + \" \" + pair.end);\n        }\n\n    }\n\n}\n\n", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n    void solve() throws IOException {\n        in = new InputReader(\"__std\");\n        out = new OutputWriter(\"__std\");\n\n        int n = in.readInt();\n        int a = in.readInt();\n        int b = in.readInt();\n        int ma = 0;\n        int mb = 1;\n        if (a < b) {\n            int t = a; a = b; b = t;\n            t = ma; ma = mb; mb = t;\n        }\n        final int[] p = new int[n];\n        Integer id[] = new Integer[n];\n        Map<Integer, Integer> pos = new HashMap<Integer, Integer>();\n        for (int i = 0; i < n; ++i) {\n            p[i] = in.readInt();\n            id[i] = i;\n            pos.put(p[i], i);\n        }\n        Arrays.sort(id, new Comparator<Integer>() {\n            public int compare(Integer i, Integer j) {\n                return p[i] - p[j];\n            }\n        });\n        int[] mask = new int[n];\n        Arrays.fill(mask, -1);\n        boolean flag = true;\n        for (int i = 0; i < n && flag; ++i) {\n            if (mask[id[i]] == -1) {\n                if (p[id[i]] < a) {\n                    if (pos.containsKey(a - p[id[i]])) {\n                        int j = pos.get(a - p[id[i]]);\n                        if (mask[j] != mb) {\n                            mask[id[i]] = mask[j] = ma;\n                            continue;\n                        }\n                    }\n                    if (p[id[i]] < b && pos.containsKey(b - p[id[i]])) {\n                        int j = pos.get(b - p[id[i]]);\n                        if (mask[j] != ma) {\n                            mask[id[i]] = mask[j] = mb;\n                            continue;\n                        }\n                    }\n                }\n                flag = false;\n            }\n        }\n        if (flag) {\n            out.println(\"YES\");\n            for (int m : mask) {\n                out.print(m + \" \");\n            }\n        } else {\n            out.println(\"NO\");\n        }\n\n        exit();\n    }\n\n    void exit() {\n        //System.err.println((System.currentTimeMillis() - startTime) + \" ms\");\n        out.close();\n        System.exit(0);\n    }\n\n    InputReader in;\n    OutputWriter out;\n\n    //long startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) throws IOException {\n        new B().solve();\n    }\n\n    class InputReader {\n\n        private InputStream stream;\n\n        private byte[] buffer = new byte[1024];\n        private int pos, len;\n\n        private int cur;\n\n        private StringBuilder sb = new StringBuilder(32);\n\n        InputReader(String name) throws IOException {\n            if (name.equals(\"__std\")) {\n                stream = System.in;\n            } else {\n                stream = new FileInputStream(name);\n            }\n            cur = read();\n        }\n\n        private int read() throws IOException {\n            if (len == -1) {\n                throw new EOFException();\n            }\n            if (pos >= len) {\n                pos = 0;\n                len = stream.read(buffer);\n                if (len == -1) return -1;\n            }\n            return buffer[pos++];\n        }\n\n        char readChar() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            char res = (char) cur;\n            cur = read();\n            return res;\n        }\n\n        int readInt() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            while (whitespace()) {\n                cur = read();\n            }\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            int sign = 1;\n            if (cur == '-') {\n                sign = -1;\n                cur = read();\n            }\n            int res = 0;\n            while (!whitespace()) {\n                if (cur < '0' || cur > '9') {\n                    throw new NumberFormatException();\n                }\n                res *= 10;\n                res += cur - '0';\n                cur = read();\n            }\n            return res * sign;\n        }\n\n        long readLong() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            return Long.parseLong(readToken());\n        }\n\n        double readDouble() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            return Double.parseDouble(readToken());\n        }\n\n        String readLine() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            sb.setLength(0);\n            while (cur != -1 && cur != '\\r' && cur != '\\n') {\n                sb.append((char) cur);\n                cur = read();\n            }\n            if (cur == '\\r') {\n                cur = read();\n            }\n            if (cur == '\\n') {\n                cur = read();\n            }\n            return sb.toString();\n        }\n\n        String readToken() throws IOException {\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            while (whitespace()) {\n                cur = read();\n            }\n            if (cur == -1) {\n                throw new EOFException();\n            }\n            sb.setLength(0);\n            while (!whitespace()) {\n                sb.append((char) cur);\n                cur = read();\n            }\n            return sb.toString();\n        }\n\n        boolean whitespace() {\n            return cur == ' ' || cur == '\\t' || cur == '\\r' || cur == '\\n' || cur == -1;\n        }\n\n        boolean eof() {\n            return cur == -1;\n        }\n    }\n\n    class OutputWriter {\n\n        private PrintWriter writer;\n\n        OutputWriter(String name) throws IOException {\n            if (name.equals(\"__std\")) {\n                writer = new PrintWriter(System.out);\n            } else {\n                writer = new PrintWriter(name);\n            }\n        }\n\n        void print(String format, Object ... args) {\n            writer.print(new Formatter(Locale.US).format(format, args));\n        }\n\n        void println(String format, Object ... args) {\n            writer.println(new Formatter(Locale.US).format(format, args));\n        }\n\n        void print(Object value) {\n            writer.print(value);\n        }\n\n        void println(Object value) {\n            writer.println(value);\n        }\n\n        void println() {\n            writer.println();\n        }\n\n        void close() {\n            writer.close();\n        }\n    }\n}\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lucasr\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyScanner in = new MyScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tBPhoenixAndPuzzle solver = new BPhoenixAndPuzzle();\n\t\tint testCount = Integer.parseInt(in.next());\n\t\tfor (int i = 1; i <= testCount; i++)\n\t\t\tsolver.solve(i, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class BPhoenixAndPuzzle {\n\t\tpublic static MyScanner sc;\n\t\tpublic static PrintWriter out;\n\n\t\tpublic void solve(int testNumber, MyScanner sc, PrintWriter out) {\n\t\t\tBPhoenixAndPuzzle.sc = sc;\n\t\t\tBPhoenixAndPuzzle.out = out;\n\t\t\tlong n = sc.nextLong();\n\t\t\tboolean can = true;\n\t\t\tif (n % 2 != 0) can = false;\n\t\t\tn /= 2;\n\t\t\twhile (n > 1 && n % 2 == 0) n /= 2;\n\t\t\tlong sq = Math.round(Math.pow(n, 0.5));\n\t\t\tif (sq * sq != n) can = false;\n\n\t\t\tout.println(can ? \"YES\" : \"NO\");\n\t\t}\n\n\t}\n\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t}\n}\n\n", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class CF_2020_GlobalRound_E {\n\tstatic boolean verb=true;\n\tstatic void log(Object X){if (verb) System.err.println(X);}\n\tstatic void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+\" \");System.err.println(\"\");}}\n\tstatic void log(long[] X){if (verb) {for (long U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\n\tstatic InputReader reader;\n\n\tstatic long[][] binom;\n\n\tstatic void buildBinom(int N){\n\t\tint MAX=N+1;\n\t\tbinom=new long[MAX+1][];\n\t\tfor (int i=0;i<MAX+1;i++)\n\t\t\tbinom[i]=new long[i+1];\n\t\tbinom[0][0]=1;\n\t\tfor (int i=1;i<MAX;i++){\n\t\t\tbinom[i][0]=1;\n\t\t\tbinom[i][i]=1;\n\t\t\tfor (int j=0;j<i;j++) {\n\t\t\t\tbinom[i+1][j+1]=(binom[i][j]+binom[i][j+1])%mod;\n\t\t\t}\n\t\t\t//log(binom[i]);\n\t\t}\n\t\tlog(\"binom done\");\n\t}\n\tstatic long mod;\n\t\n\tstatic long solve(int n) {\n\t\tlong[] pow2=new long[n+1];\n\t\tpow2[0]=1;\n\t\tfor (int i=1;i<=n;i++) {\n\t\t\tpow2[i]=pow2[i-1]<<1;\n\t\t\twhile (pow2[i]>=mod)\n\t\t\t\tpow2[i]-=mod;\n\t\t}\n\t\tbuildBinom(n);\n\t\t\n\t\n\t\tlong[][] dp=new long[n+1][n+1];\n\t\tdp[1][1]=1;\n\t\tfor (int i=1;i<=n;i++) {\n\t\t\tdp[i][i]=pow2[i-1];\n\t\t\t//log(\"base:\"+dp[i][i]);\n\t\t\tfor (int j=1;j<i-1;j++){\n\t\t\t\tint me=i-j-1;\n\t\t\t\tfor (int cn=1;cn<=j;cn++) {\n\t\t\t\t\t//log(\"j:\"+j+\" cn:\"+cn+\" dp:\"+dp[j][cn]);\n\t\t\t\t\t//log(\"perm:\"+binom[cn+me][cn]);\n\t\t\t\t\tlong a=dp[j][cn]*binom[cn+me][cn];\n\t\t\t\t\tif (a>=mod)\n\t\t\t\t\t\ta%=mod;\n\t\t\t\t\ta*=pow2[me-1];\n\t\t\t\t\tif (a>=mod)\n\t\t\t\t\t\ta%=mod;\n\t\t\t\t\tdp[i][cn+me]+=a;\n\t\t\t\t\tif (dp[i][cn+me]>=mod)\n\t\t\t\t\t\tdp[i][cn+me]-=mod;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor (int i=n/2;i<=n;i++) {\n\t\t\tans+=dp[n][i];\n\t\t\tans%=mod;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void main(String[] args) throws Exception  {\n\n\t\tlog(400*400*400);\n\t\treader=new InputReader(System.in);\n\t\tint n=reader.readInt();\n\t\tmod=reader.readInt();\n\t\t\n\t\tSystem.out.println(solve(n));\n\n\t}\n\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res=new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char)c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg=false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d=(char)c;\n\t\t\t//log(\"d:\"+d);\n\t\t\tif (d=='-') {\n\t\t\t\tneg=true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t//log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg=false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d=(char)c;\n\t\t\t//log(\"d:\"+d);\n\t\t\tif (d=='-') {\n\t\t\t\tneg=true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t//log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n}\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class cf2 {\n\tstatic final double EPS = 1e-9;\n\n  public static void main(String[] args) throws IOException {\n\t Scanner sc = new Scanner(System.in);\n\t\n\t //rec\n\t int xr1=sc.nextInt(), yr1=sc.nextInt(), xr2=sc.nextInt(),yr2=sc.nextInt();\n\t int xr3=sc.nextInt(), yr3=sc.nextInt(), xr4=sc.nextInt(),yr4=sc.nextInt();\n\t\n\t Point pr1 = new Point(xr1, yr1);\n\t Point pr2 = new Point(xr2, yr2);\n\t Point pr3 = new Point(xr3, yr3);\n\t Point pr4 = new Point(xr4, yr4);\n\t \n\t LineSegment lr1 = new LineSegment(pr1, pr2);\n\t LineSegment lr2 = new LineSegment(pr2, pr3);\n\t LineSegment lr3 = new LineSegment(pr3, pr4);\n\t LineSegment lr4 = new LineSegment(pr4, pr1);\n\t \n\t //diamond\n\t int xd1=sc.nextInt(), yd1=sc.nextInt(), xd2=sc.nextInt(),yd2=sc.nextInt();\n\t int xd3=sc.nextInt(), yd3=sc.nextInt(), xd4=sc.nextInt(),yd4=sc.nextInt();\n\t \n\t Point p1 = new Point(xd1, yd1);\n\t Point p2 = new Point(xd2, yd2);\n\t Point p3 = new Point(xd3, yd3);\n\t Point p4 = new Point(xd4, yd4);\n\t \n\t Point [] pt = new Point [5];\n\t pt[0]=p1;  pt[1]=p2;  pt[2]=p3;  pt[3]=p4;  pt[4]=p1;\n\t Polygon pg = new Polygon(pt);\n\t \n\t if(pg.inside(pr1)||pg.inside(pr2)||pg.inside(pr3)||pg.inside(pr4)) {\n\t\t System.out.println(\"YES\");\n\t\t return;\n\t }\n\t\n\t \n\t LineSegment ld1 = new LineSegment(p1, p2);\n\t LineSegment ld2 = new LineSegment(p2, p3);\n\t LineSegment ld3 = new LineSegment(p3, p4);\n\t LineSegment ld4 = new LineSegment(p4, p1);\n\t \n\t Rectangle rec = new Rectangle(new Point(Math.min(Math.min(xr3,xr4),Math.min(xr1,xr2)), Math.min(Math.min(yr3,yr4),Math.min(yr1,yr2))), \n\t\t\t new Point(Math.max(Math.max(xr3,xr4),Math.max(xr1,xr2)), Math.max(Math.max(yr3,yr4),Math.max(yr1,yr2))) );\n\t \n\t if(rec.contains(p1)||rec.contains(p2)||rec.contains(p3)||rec.contains(p4)) {\n\t\t System.out.println(\"YES\");\n\t     return;\n\t }\n\t \n\t if(ld1.intersect(lr1)||ld1.intersect(lr3)||ld1.intersect(lr3)||ld1.intersect(lr4)) {\n\t\t System.out.println(\"YES\");\n\t     return;\n\t }\n\t \n\t if(ld2.intersect(lr1)||ld2.intersect(lr3)||ld2.intersect(lr3)||ld2.intersect(lr4)) {\n\t\t System.out.println(\"YES\");\n\t     return;\n\t }\n\t \n\t if(ld3.intersect(lr1)||ld3.intersect(lr3)||ld3.intersect(lr3)||ld3.intersect(lr4)) {\n\t\t System.out.println(\"YES\");\n\t     return;\n\t }\n\t \n\t if(ld4.intersect(lr1)||ld4.intersect(lr3)||ld4.intersect(lr3)||ld4.intersect(lr4)) {\n\t\t System.out.println(\"YES\");\n\t     return;\n\t }\n\t \n\t System.out.println(\"NO\");\n\t \n\t \n\t \n\t \n}\n  \n  public static class Polygon { \n\t\t// Cases to handle: collinear points, polygons with n < 3\n\n\t\tstatic final double EPS = 1e-9;\n\t\t\n\t\tPoint[] g; \t\t\t//first point = last point, counter-clockwise representation\n\t\t\n\t\tPolygon(Point[] o) { g = o; }\n\n\t\tdouble perimeter()\n\t\t{\n\t\t\tdouble sum = 0.0;\n\t\t\tfor(int i = 0; i < g.length - 1; ++i)\n\t\t\t\tsum += g[i].dist(g[i+1]);\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tdouble area() \t\t//clockwise/anti-clockwise check, for convex/concave polygons\n\t\t{\n\t\t\tdouble area = 0.0;\n\t\t\tfor(int i = 0; i < g.length - 1; ++i)\n\t\t\t\tarea += g[i].x * g[i+1].y - g[i].y * g[i+1].x;\n\t\t\treturn Math.abs(area) / 2.0;\t\t\t//negative value in case of clockwise\n\t\t}\n\n\t\n\t\t\n\t\tboolean inside(Point p)\t//for convex/concave polygons - winding number algorithm \n\t\t{\n\t\t\tdouble sum = 0.0;\n\t\t\tfor(int i = 0; i < g.length - 1; ++i)\n\t\t\t{\n\t\t\t\tdouble angle = Point.angle(g[i], p, g[i+1]);\n\t\t\t\tif((Math.abs(angle) < EPS || Math.abs(angle - Math.PI) < EPS) && p.between(g[i], g[i+1]))\n\t\t\t\t\treturn true;\n\t\t\t\tif(Point.ccw(p, g[i], g[i+1]))\n\t\t\t\t\tsum += angle;\n\t\t\t\telse\n\t\t\t\t\tsum -= angle;\n\t\t\t}\n\n\t\t\treturn Math.abs(2 * Math.PI - Math.abs(sum)) < EPS;\t\t//abs makes it work for clockwise\n\t\t}\n\t\t/*\n\t\t * Another way if the polygon is convex\n\t\t * 1. Triangulate the poylgon through p\n\t\t * 2. Check if sum areas == poygon area\n\t\t * 3. Handle empty polygon\n\t\t */\n\t\t\n\t\t\n\n\t\n\t\tPoint centroid()\t\t//center of mass\n\t\t{\n\t\t\tdouble cx = 0.0, cy = 0.0;\n\t\t\tfor(int i = 0; i < g.length - 1; i++)\n\t\t\t{\n\t\t\t\tdouble x1 = g[i].x, y1 = g[i].y;\n\t\t\t\tdouble x2 = g[i+1].x, y2 = g[i+1].y;\n\n\t\t\t\tdouble f = x1 * y2 - x2 * y1;\n\t\t\t\tcx += (x1 + x2) * f;\n\t\t\t\tcy += (y1 + y2) * f;\n\t\t\t}\n\t\t\tdouble area = area();\t\t//remove abs\n\t\t\tcx /= 6.0 * area;\n\t\t\tcy /= 6.0 * area;\n\t\t\treturn new Point(cx, cy);\n\t\t}\n\t}\n  \n   static class LineSegment {\n\n\t\tPoint p, q;\n\t\t\n\t\tLineSegment(Point a, Point b) { p = a; q = b; }\n\t\t\n\n\t\tboolean intersect(LineSegment ls)\n\t\t{\n\t\t\tLine l1 = new Line(p, q), l2 = new Line(ls.p, ls.q);\n\t\t\tif(l1.parallel(l2))\n\t\t\t{\n\t\t\t\tif(l1.same(l2))\n\t\t\t\t\treturn p.between(ls.p, ls.q) || q.between(ls.p, ls.q) || ls.p.between(p, q) || ls.q.between(p, q);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tPoint c = l1.intersect(l2);\n\t\t\treturn c.between(p, q) && c.between(ls.p, ls.q);\n\t\t}\n\n\t}\n  \n   static class Rectangle {\n\n\t\tstatic final double EPS = 1e-9;\n\t\t\n\t\tPoint ll, ur;\n\n\t\tRectangle(Point a, Point b) { ll = a; ur = b; }\n\n\t\tdouble area() { return (ur.x - ll.x) * (ur.y - ll.y); }\n\n\t\tboolean contains(Point p)\n\t\t{\n\t\t\treturn p.x <= ur.x + EPS && p.x + EPS >= ll.x && p.y <= ur.y + EPS && p.y + EPS >= ll.y;\n\t\t}\n\n\t\tRectangle intersect(Rectangle r)\n\t\t{\n\t\t\tPoint ll = new Point(Math.max(this.ll.x, r.ll.x), Math.max(this.ll.y, r.ll.y));\n\t\t\tPoint ur = new Point(Math.min(this.ur.x, r.ur.x), Math.min(this.ur.y, r.ur.y));\n\t\t\tif(Math.abs(ur.x - ll.x) > EPS && Math.abs(ur.y - ll.y) > EPS && this.contains(ll) && this.contains(ur) && r.contains(ll) && r.contains(ur))\n\t\t\t\treturn new Rectangle(ll, ur);\n\t\t\treturn null;\n\t\t}\n\n\t}\n   static class Line {\n\n\t\tstatic final double INF = 1e9, EPS = 1e-9;\n\t\t\n\t\tdouble a, b, c;\n\t\t\n\t\tLine(Point p, Point q)\n\t\t{\n\t\t\tif(Math.abs(p.x - q.x) < EPS) {\ta = 1; b = 0; c = -p.x;\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta = (p.y - q.y) / (q.x - p.x);\n\t\t\t\tb = 1.0;\n\t\t\t\tc = -(a * p.x + p.y);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t}\n\t\t\n\t\tLine(Point p, double m) { a = -m; b = 1; c =  -(a * p.x + p.y); } \n\t\t\n\t\tboolean parallel(Line l) { return Math.abs(a - l.a) < EPS && Math.abs(b - l.b) < EPS; }\n\t\t\n\t\tboolean same(Line l) { return parallel(l) && Math.abs(c - l.c) < EPS; }\n\t\t\n\t\tPoint intersect(Line l)\n\t\t{\n\t\t\tif(parallel(l))\n\t\t\t\treturn null;\n\t\t\tdouble x = (b * l.c - c * l.b) / (a * l.b - b * l.a);\n\t\t\tdouble y;\n\t\t\tif(Math.abs(b) < EPS)\n\t\t\t\t y = -l.a * x - l.c;\n\t\t\telse\n\t\t\t\ty = -a * x - c;\n\t\t\t\n\t\t\treturn new Point(x, y);\n\t\t}\n\t\t\n\t\tPoint closestPoint(Point p)\n\t\t{\n\t\t\tif(Math.abs(b) < EPS) return new Point(-c, p.y);\n\t\t\tif(Math.abs(a) < EPS) return new Point(p.x, -c);\n\t\t\treturn intersect(new Line(p, 1 / a));\n\t\t}\n\t\t\t\t\n\t}\n\n   public static class Vector {\n\n\t\tdouble x, y; \n\n\t\tVector(double a, double b) { x = a; y = b; }\n\n\t\tVector(Point a, Point b) { this(b.x - a.x, b.y - a.y); }\n\n\t\tVector scale(double s) { return new Vector(x * s, y * s); }              //s is a non-negative value\n\n\t\tdouble dot(Vector v) { return (x * v.x + y * v.y); }\n\n\t\tdouble cross(Vector v) { return x * v.y - y * v.x; }\n\n\t\tdouble norm2() { return x * x + y * y; }\n\n\t\tVector reverse() { return new Vector(-x, -y); }\n\n\t\tVector normalize() \n\t\t{ \n\t\t\tdouble d = Math.sqrt(norm2());\n\t\t\treturn scale(1 / d);\n\t\t}\t\t\n\t}\n   \n   static class Point implements Comparable<Point>{\n\n\t\tstatic final double EPS = 1e-9;\n\n\t\tdouble x, y;                  \n\n\t\tPoint(double a, double b) { x = a; y = b; }  \n\t\t\n\t\tpublic int compareTo(Point p)\n\t\t{\n\t\t\tif(Math.abs(x - p.x) > EPS) return x > p.x ? 1 : -1;\n\t\t\tif(Math.abs(y - p.y) > EPS) return y > p.y ? 1 : -1;\n\t\t\treturn 0;\n\t\t}\n\t\tstatic double angle(Point a, Point o, Point b)  // angle AOB\n\t\t{\n\t\t\tVector oa = new Vector(o, a), ob = new Vector(o, b);\n\t\t\treturn Math.acos(oa.dot(ob) / Math.sqrt(oa.norm2() * ob.norm2()));\n\t\t}\n\t\tstatic boolean ccw(Point p, Point q, Point r)\n\t\t{\n\t\t\treturn new Vector(p, q).cross(new Vector(p, r)) > 0;\n\t\t}\n\t\t\n\t\tpublic double dist(Point p) { return Math.sqrt(sq(x - p.x) + sq(y - p.y)); }\n\t\t\n\t\tstatic double sq(double x) { return x * x; }\n\t\t\n\t\tPoint rotate(double angle)\n\t\t{\n\t\t\tdouble c = Math.cos(angle), s = Math.sin(angle);\n\t\t\treturn new Point(x * c - y * s, x * s + y * c);\n\t\t}\n\t\t// for integer points and rotation by 90 (counterclockwise) : swap x and y, negate x\n\t\t\n\t\n\t\t\n\t\tboolean between(Point p, Point q)\n\t\t{\n\t\t\treturn x < Math.max(p.x, q.x) + EPS && x + EPS > Math.min(p.x, q.x)\n\t\t\t\t\t&& y < Math.max(p.y, q.y) + EPS && y + EPS > Math.min(p.y, q.y);\n\t\t}\n\t\t\n\t\t//returns true if it is on the line defined by a and b\n\t\n\t\t//returns true if it is on the ray whose start point is a and passes through b\n\t\t// Another way: find closest point and calculate the distance between it and p\n\t}\n  \n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic Scanner(String file) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic long nextlong() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tlong res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n}\n", "complexity": "constant", "problem": "0994_C", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        F solver = new F();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class F {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int[] a = in.readIntArray(n);\n            int[] b = new int[n - k + 1];\n            int[] queue = new int[n];\n            int start = 0;\n            int end = 0;\n            for (int i = 0; i < k - 1; i++) {\n                while (start < end && a[queue[end - 1]] <= a[i]) {\n                    end--;\n                }\n                queue[end++] = i;\n            }\n            for (int i = k - 1; i < n; i++) {\n                while (start < end && a[queue[end - 1]] <= a[i]) {\n                    end--;\n                }\n                queue[end++] = i;\n                if (queue[start] == i - k) {\n                    start++;\n                }\n                b[i - k + 1] = a[queue[start]];\n            }\n            long answer = 0;\n            int[] c = new int[n];\n            for (int i = 1; i < k; i++) {\n                int at = b.length - i;\n                int length = 0;\n                for (int pos = at; pos >= 0; pos -= k - 1) {\n                    c[length++] = b[pos];\n                }\n                end = 0;\n                long currentSum = 0;\n                for (int j = 0; j < length; j++) {\n                    while (0 < end && c[queue[end - 1]] <= c[j]) {\n                        long last = end == 1 ? -1 : queue[end - 2];\n                        currentSum -= c[queue[end - 1]] * (queue[end - 1] - last);\n                        currentSum %= MiscUtils.MOD7;\n                        end--;\n                    }\n                    long last = end == 0 ? -1 : queue[end - 1];\n                    currentSum += c[j] * (j - last);\n                    currentSum %= MiscUtils.MOD7;\n                    answer += currentSum;\n                    queue[end++] = j;\n                }\n            }\n            answer %= MiscUtils.MOD7;\n            if (answer < 0) {\n                answer += MiscUtils.MOD7;\n            }\n            out.printLine(answer);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n}\n\n", "complexity": "linear", "problem": "1037_F", "from": "CODEFORCES", "tags": "combinatorics,data structures,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.FileReader;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class Fish extends Thread {\n\n    public Fish() {\n        this.input = new BufferedReader(new InputStreamReader(System.in));\n        this.output = new PrintWriter(System.out);\n        this.setPriority(Thread.MAX_PRIORITY);\n    }\n\n\n    private void solve() throws Throwable {\n        int n = nextInt();\n        double[][] a = new double[n][n];\n        double[] dp = new double[(1 << n)];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                a[i][j] = nextDouble();\n            }\n        }\n        int limit = (1 << n) - 1;\n        //dp[mask] = probability of current subset (mask) to remain in the end\n        dp[limit] = 1.0;\n        for (int mask = limit; mask > 0; --mask) {\n            int cardinality = Integer.bitCount(mask);\n            int probability = cardinality * (cardinality - 1) / 2;\n            for (int first = 0; first < n; ++first) {\n                if ((mask & powers[first]) != 0) {\n                    for (int second = first + 1; second < n; ++second) {\n                        if ((mask & powers[second]) != 0) {\n                            dp[mask - powers[first]] += dp[mask] * a[second][first] / probability;\n                            dp[mask - powers[second]] += dp[mask] * a[first][second] / probability;\n                        }\n\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            output.printf(\"%.10f \", dp[powers[i]]);\n        }\n    }\n\n    public void run() {\n        try {\n            solve();\n        } catch (Throwable e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace();\n            System.exit(666);\n        } finally {\n            output.flush();\n            output.close();\n        }\n    }\n\n\n    public static void main(String[] args) {\n        new Fish().start();\n    }\n\n    private String nextToken() throws IOException {\n        while (tokens == null || !tokens.hasMoreTokens()) {\n            tokens = new StringTokenizer(input.readLine());\n        }\n        return tokens.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    static int powers[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144};\n    private BufferedReader input;\n    private PrintWriter output;\n    private StringTokenizer tokens = null;\n}", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.util.Scanner;\npublic class Main {\n    public static void main(String args[]) {\n        Scanner s = new Scanner(System.in);\n        int t = s.nextInt();\n        while(t-- != 0){\n            int n = s.nextInt();\n            int k = s.nextInt();\n            String str = s.next();\n            String append = \"RGB\";\n            StringBuilder sb1 = new StringBuilder();\n            for(int i = 0; i < k; i++){\n                sb1.append(append.charAt(i % 3));\n            }\n            append = \"GBR\";\n            StringBuilder sb2 = new StringBuilder();\n            for(int i = 0; i < k; i++){\n                sb2.append(append.charAt(i % 3));\n            }\n            append = \"BRG\";\n            StringBuilder sb3 = new StringBuilder();\n            for(int i = 0; i < k; i++){\n                sb3.append(append.charAt(i % 3));\n            }\n            int ans = Math.min(solve(str,sb1,k,n),Math.min(solve(str,sb2,k,n),solve(str,sb3,k,n)));\n            System.out.println(ans);\n\n        \n        }\n    }\n    public static int solve(String str,StringBuilder sb,int k,int n){\n        int min = n;\n            String check = sb.toString();\n            for(int i = 0; i < n - k + 1; i++){\n                int w = 0,opt = 0;\n                for(int j = i; j < i + k; j++){\n                    if(str.charAt(j) != check.charAt(w)){\n                        opt++;\n                    }\n                    w++;\n                }\n                min = Math.min(min,opt);\n            }\n            return min;\n    }\n}", "complexity": "quadratic", "problem": "1196_D1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskG2 solver = new TaskG2();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskG2 {\n        static final int MOD = 1000000000 + 7;\n        static final int MAXN = 51;\n\n        int getWays(int i, int j, int k, int l, int[][][][] ways, boolean[][][][] cached) {\n            if (i + j + k == 0) return l == -1 ? 1 : 0;\n            if (l < 0) return 0;\n            if (cached[i][j][k][l]) return ways[i][j][k][l];\n            int s = i + j + k;\n            long value = 0;\n            if (l == 0 && i != 0) {\n                for (int x = -1; x < 3; x++)\n                    if (x != l) {\n                        value += getWays(i - 1, j, k, x, ways, cached);\n                    }\n            }\n            if (l == 1 && j != 0) {\n                for (int x = -1; x < 3; x++)\n                    if (x != l) {\n                        value += getWays(i, j - 1, k, x, ways, cached);\n                    }\n            }\n            if (l == 2 && k != 0) {\n                for (int x = -1; x < 3; x++)\n                    if (x != l) {\n                        value += getWays(i, j, k - 1, x, ways, cached);\n                    }\n            }\n            ways[i][j][k][l] = (int) (value % MOD);\n            cached[i][j][k][l] = true;\n            return ways[i][j][k][l];\n        }\n\n        int totalWays(int i, int j, int k, int[][][][] ways, boolean[][][][] cached, int[] factorial) {\n            long ret = 0;\n            for (int l = 0; l < 3; l++) ret += getWays(i, j, k, l, ways, cached);\n            ret *= factorial[i];\n            ret %= MOD;\n\n            ret *= factorial[j];\n            ret %= MOD;\n\n            ret *= factorial[k];\n            ret %= MOD;\n\n            return (int) ret;\n        }\n\n        int add(int type, int value, int[] sizes, int sum, int[][][][] dp) {\n            sizes[type]++;\n            if (type == 0) {\n                for (int s = sum + value; s >= value; s--) {\n                    for (int i = 1; i <= sizes[0]; i++)\n                        for (int j = 0; j <= sizes[1]; j++)\n                            for (int k = 0; k <= sizes[2]; k++) {\n                                dp[i][j][k][s] += dp[i - 1][j][k][s - value];\n                                if (dp[i][j][k][s] >= MOD)\n                                    dp[i][j][k][s] -= MOD;\n                            }\n                }\n            }\n\n            if (type == 1) {\n                for (int s = sum + value; s >= value; s--) {\n                    for (int i = 0; i <= sizes[0]; i++)\n                        for (int j = 1; j <= sizes[1]; j++)\n                            for (int k = 0; k <= sizes[2]; k++) {\n//                            System.out.println(i + \" \" + j + \" \" + k + \" \" + s + \" \" + dp.length + \" \" + dp[0].length + \" \" + dp[0][0].length + \" \" + dp[0][0][0].length);\n                                dp[i][j][k][s] += dp[i][j - 1][k][s - value];\n                                if (dp[i][j][k][s] >= MOD)\n                                    dp[i][j][k][s] -= MOD;\n                            }\n                }\n            }\n\n            if (type == 2) {\n                for (int s = sum + value; s >= value; s--) {\n                    for (int i = 0; i <= sizes[0]; i++)\n                        for (int j = 0; j <= sizes[1]; j++)\n                            for (int k = 1; k <= sizes[2]; k++) {\n//                            System.out.println(i + \" \" + j + \" \" + k + \" \" + s + \" \" + dp.length + \" \" + dp[0].length + \" \" + dp[0][0].length + \" \" + dp[0][0][0].length);\n                                dp[i][j][k][s] += dp[i][j][k - 1][s - value];\n                                if (dp[i][j][k][s] >= MOD)\n                                    dp[i][j][k][s] -= MOD;\n                            }\n                }\n            }\n\n            return sum + value;\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int[][][][] ways = new int[MAXN][MAXN][MAXN][3];\n            boolean[][][][] cached = new boolean[MAXN][MAXN][MAXN][3];\n//        Arrays.fill(ways, -1);\n\n            int n = in.nextInt(), T = in.nextInt();\n\n            ArrayList<Integer>[] ar = new ArrayList[3];\n            for (int i = 0; i < 3; i++) ar[i] = new ArrayList<Integer>();\n            int total_sum = 0;\n            for (int i = 0; i < n; i++) {\n                int t = in.nextInt(), g = in.nextInt();\n                ar[g - 1].add(t);\n                total_sum += t;\n            }\n\n            if (T > total_sum) {\n                out.println(0);\n                return;\n            }\n            int min_index = 0, mn = 0;\n\n            for (int i = 0; i < 3; i++) {\n                if (ar[i].size() > mn) {\n                    mn = ar[i].size();\n                    min_index = i;\n                }\n            }\n\n            int[][][][] dp = new int[ar[(1 + min_index) % 3].size() + 1][ar[(2 + min_index) % 3].size() + 1][1][total_sum + 1];\n            int[][][][] dp2 = new int[1][1][mn + 1][total_sum + 1];\n            dp[0][0][0][0] = dp2[0][0][0][0] = 1;\n            int[] sizes = {0, 0, 0};\n            int sum = 0;\n            int[] order = {(min_index + 1) % 3, (min_index + 2) % 3};\n            int type = 0;\n            for (int i : order) {\n                for (int v : ar[i])\n                    sum = add(type, v, sizes, sum, dp);\n                type++;\n            }\n            sum = 0;\n            sizes[0] = sizes[1] = sizes[2] = 0;\n            for (int i : ar[min_index])\n                sum = add(2, i, sizes, sum, dp2);\n            int[] factorial = new int[MAXN];\n            factorial[0] = 1;\n            for (int i = 1; i < MAXN; i++)\n                factorial[i] = (int) ((factorial[i - 1] * 1L * i) % MOD);\n\n            long answer = 0;\n            for (int i = 0; i < dp.length; i++)\n                for (int j = 0; j < dp[0].length; j++)\n                    for (int k = 0; k <= mn; k++)\n                        for (int s = 0; s <= T; s++) {\n\n                            long x = (dp[i][j][0][s] * 1L * totalWays(i, j, k, ways, cached, factorial)) % MOD;\n                            x *= dp2[0][0][k][T - s];\n                            x %= MOD;\n                            answer += x;\n\n                        }\n            out.println(answer % MOD);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void println(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n            writer.print('\\n');\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n", "complexity": "cubic", "problem": "1185_G2", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "/**\n * BaZ :D\n */\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\npublic class Main\n{\n    static MyScanner scan;\n    static PrintWriter pw;\n    static long MOD = 1_000_000_007;\n    static long INF = 1_000_000_000_000_000_000L;\n    static long inf = 2_000_000_000;\n    public static void main(String[] args) {\n        new Thread(null, null, \"BaZ\", 1 << 27) {\n            public void run() {\n                try {\n                    solve();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n    static int n,m,need,a[][],dp[][][],real[][];\n    static void solve() throws IOException\n    {\n        //initIo(true);\n        initIo(false);\n        StringBuilder sb = new StringBuilder();\n        int t = ni();\n        while(t-->0) {\n            n = ni();\n            m = ni();\n            a = new int[n][m];\n            for(int i=0;i<n;++i) {\n                for(int j=0;j<m;++j) {\n                    a[i][j] = ni();\n                }\n            }\n            need = min(n,m);\n            Pair max_in_cols[] = new Pair[m];\n            for(int COL=0;COL<m;++COL) {\n                int max = 0;\n                for(int i=0;i<n;++i) {\n                    max = max(max, a[i][COL]);\n                }\n                max_in_cols[COL] = new Pair(max, COL);\n            }\n            real = new int[n][need];\n            Arrays.sort(max_in_cols);\n            for(int i=0;i<need;++i) {\n                int COL = max_in_cols[m-1-i].y;\n                for(int j=0;j<n;++j) {\n                    real[j][i] = a[j][COL];\n                }\n            }\n//            pl(\"need : \"+need);\n//            pa(\"Real\", real);\n            dp = new int[need][n+1][(1<<n)];\n            for(int i=0;i<need;++i) {\n                for(int j=0;j<=n;++j) {\n                    for(int k=0;k<(1<<n);++k) {\n                        dp[i][j][k] = -1;\n                    }\n                }\n            }\n            pl(f(0, n, 0));\n        }\n        pw.flush();\n        pw.close();\n    }\n    static int f(int idx, int bias, int mask) {\n        //pl(\"idx: \"+idx+\" bias : \"+bias + \" mask : \"+mask);\n        if(idx==need) {\n            return 0;\n        }\n        if(dp[idx][bias][mask]!=-1) {\n            return dp[idx][bias][mask];\n        }\n\n        //didn't fix bias yet\n        if(bias==n) {\n            int max = 0;\n            for(int b=0;b<n;++b) {\n                max = max(max, f(idx, b, mask));\n            }\n            //pl(\"maxxxxxxx : \"+max);\n            dp[idx][bias][mask] = max;\n            return max;\n        }\n        else {\n            int max = f(idx+1, n, mask);\n            for(int i=0;i<n;++i) {\n                if((mask&(1<<i))==0) {\n                    max = max(max, real[(i-bias+n)%n][idx] + f(idx, bias, mask | (1<<i)));\n                }\n            }\n            //pl(\"max : \"+max);\n            dp[idx][bias][mask] = max;\n            return max;\n        }\n    }\n    static class Pair implements Comparable<Pair>\n    {\n        int x,y;\n        Pair(int x,int y)\n        {\n            this.x=x;\n            this.y=y;\n        }\n        public int compareTo(Pair other)\n        {\n            if(this.x!=other.x)\n                return this.x-other.x;\n            return this.y-other.y;\n        }\n        public String toString()\n        {\n            return \"(\"+x+\",\"+y+\")\";\n        }\n    }\n    static void initIo(boolean isFileIO) throws IOException {\n        scan = new MyScanner(isFileIO);\n        if(isFileIO) {\n            pw = new PrintWriter(\"/Users/amandeep/Desktop/output.txt\");\n        }\n        else {\n            pw = new PrintWriter(System.out, true);\n        }\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static String ne() throws IOException\n    {\n        return scan.next();\n    }\n    static String nel() throws IOException\n    {\n        return scan.nextLine();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class MyScanner\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        MyScanner(boolean readingFromFile) throws IOException\n        {\n            if(readingFromFile) {\n                br = new BufferedReader(new FileReader(\"/Users/amandeep/Desktop/input.txt\"));\n            }\n            else {\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n        }\n        String nextLine()throws IOException\n        {\n            return br.readLine();\n        }\n        String next() throws IOException\n        {\n            if(st==null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        int nextInt() throws IOException\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong() throws IOException\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble() throws IOException\n        {\n            return Double.parseDouble(next());\n        }\n    }\n}", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int a[] = new int[1501];\n              for(int i = 0; i < 3; i++){\n                     a[sc.nextInt()]++;\n              }\n              if(a[1] > 0 || a[2] > 1 || a[3] > 2 || (a[4] == 2 && a[2] == 1)){\n                     System.out.println(\"YES\");\n              }else{\n                     System.out.println(\"NO\");\n              }\n      }\n}", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "/**\n * Created by IntelliJ IDEA.\n * User: Taras_Brzezinsky\n * Date: 8/13/11\n * Time: 6:10 PM\n * To change this template use File | Settings | File Templates.\n */\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.IOException;\n\npublic class DarkAssembly extends Thread {\n\n    public DarkAssembly() {\n        this.input = new BufferedReader(new InputStreamReader(System.in));\n        this.output = new PrintWriter(System.out);\n        this.setPriority(Thread.MAX_PRIORITY);\n    }\n\n    static class Senator {\n        int loyalty;\n        int level;\n\n        public Senator(int level, int loyalty) {\n            this.level = level;\n            this.loyalty = loyalty;\n        }\n    }\n\n    private static double doIt(Senator[] senators, int A) {\n        double probability = .0;\n        for (int mask = 0; mask < (1 << senators.length); ++mask) {\n            int sum = A;\n            double current = 1.0;\n            for (int i = 0; i < senators.length; ++i) {\n                if ((mask & (1 << i)) != 0) {\n                    current *= .01 * senators[i].loyalty;\n                } else {\n                    current *= .01 * (100 - senators[i].loyalty);\n                    sum += senators[i].level;\n                }\n            }\n            if (Integer.bitCount(mask) > senators.length / 2) {\n                probability += current;\n            } else {\n                probability += current * (double) A / sum;\n            }\n        }\n        return probability;\n    }\n\n    private static double go(Senator[] senators, int candies, int A, int current) {\n        if (current == senators.length) {\n            return doIt(senators, A);\n        } else {\n            double result = go(senators, candies, A, current + 1);\n            if (candies > 0 && senators[current].loyalty < 100) {\n                senators[current].loyalty += 10;\n                result = Math.max(result, go(senators, candies - 1, A, current));\n                senators[current].loyalty -= 10;\n            }\n            return result;\n        }\n    }\n\n\n\n\n    private void solve() throws Throwable {\n        int n = nextInt();\n        int k = nextInt();\n        int A = nextInt();\n        Senator[] senators = new Senator[n];\n        for (int i = 0; i < n; ++i) {\n            senators[i] = new Senator(nextInt(), nextInt());\n        }\n        output.printf(\"%.10f\", go(senators, k, A, 0));\n    }\n\n    public void run() {\n        try {\n            solve();\n        } catch (Throwable e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace();\n        } finally {\n            output.flush();\n            output.close();\n        }\n\n    }\n\n\n    public static void main(String[] args) {\n        new DarkAssembly().start();\n    }\n\n    private String nextToken() throws IOException {\n        while (tokens == null || !tokens.hasMoreTokens()) {\n            tokens = new StringTokenizer(input.readLine());\n        }\n        return tokens.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n\n    private BufferedReader input;\n    private PrintWriter output;\n    private StringTokenizer tokens = null;\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class C {\n\n\t//dp[firstInLoop][index][indentLevel]\n\tprivate static int[][][] dp;\n\tprivate static boolean[] wasLoop;\n\tprivate static int MOD=1000000007;\n\tprivate static int n;\n\t\n\tpublic static void solve(FastScanner fs) {\t\n\t\tn=fs.nextInt();\n\t\tdp=new int[2][n][n];\n\t\tfor (int i=0; i<dp.length; i++)\n\t\t\tfor (int j=0; j<dp[i].length; j++)\n\t\t\t\tArrays.fill(dp[i][j], -1);\n\t\twasLoop=new boolean[n];\n\t\tfor (int i=0; i<n; i++)\n\t\t\twasLoop[i]=fs.next().equals(\"f\");\n\t\t\n\t\tint ans=go(0, 0, 0);\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tprivate static int go(int firstInLoop, int index, int indentLevel) {\n\t\tif (index>=n)//base case\n\t\t\treturn 1;\n\t\tif (dp[firstInLoop][index][indentLevel]!=-1)\n\t\t\treturn dp[firstInLoop][index][indentLevel];\n\t\t\n\t\t//if I am forced, just do it\n\t\tif (firstInLoop==1)\n\t\t\treturn dp[firstInLoop][index][indentLevel]=go(wasLoop[index]?1:0, index+1, indentLevel+(wasLoop[index]?1:0));\n\t\t\n\t\t//if I am on the end level, I don't have a choice\n\t\tif (indentLevel==0) {\n\t\t\treturn dp[firstInLoop][index][indentLevel]=go(wasLoop[index]?1:0, index+1, wasLoop[index]?1:0);\n\t\t}\n\t\telse {\n\t\t\t//otherwise, add all the possibilities\n\t\t\tint total=0;\n\t\t\ttotal+=go(firstInLoop, index, indentLevel-1);\n\t\t\ttotal+=go(wasLoop[index]?1:0, index+1, indentLevel+(wasLoop[index]?1:0));\n\t\t\ttotal%=MOD;\n\t\t\treturn dp[firstInLoop][index][indentLevel]=total;\n\t\t}\n\t}\n\n\t\n\t\n\t\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tFastScanner scanner = new FastScanner(System.in);\n\t\tsolve(scanner);\n\t}\n\t\n\n\tprivate static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastScanner(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++)\n\t\t\t\ta[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}\n\n\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Contest {\n\n\tstatic final Random random = new Random();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n//\tScanner sc = new Scanner(new File(\"src/input.txt\"));\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\t\n\t\tif(n == 1) {\n\t\t\tSystem.out.println(sc.nextLong());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong ans = 0, minval = Long.MAX_VALUE;\n\t\tboolean pos = false, neg = false;\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tlong a = sc.nextLong();\n\t\t\tminval = Math.min(minval, Math.abs(a));\n\t\t\tans += Math.abs(a);\n\t\t\tpos |=(a>=0);\n\t\t\tneg |= (a < 0);\n\t\t}\n\t\t\n\t\tif(pos && neg) {\n\t\t\tout.println(ans);\n\t\t}else\n\t\t\tout.println(ans - 2*minval);\n\n\t\tout.flush();\n\t}\n\n\tstatic void Arrayssort(int[] a) {\n\t\tint n = a.length;// shuffle, then sort\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint oi = random.nextInt(n);\n\t\t\tint temp = a[oi];\n\t\t\ta[oi] = a[i];\n\t\t\ta[i] = temp;\n\t\t}\n\t\tjava.util.Arrays.sort(a);\n\t}\n\n\tprivate static class Scanner {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer st;\n\n\t\tpublic Scanner(InputStream file) throws FileNotFoundException {\n\t\t\treader = new BufferedReader(new InputStreamReader(file));\n\t\t\tst = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString line = reader.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow (new RuntimeException());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn reader.readLine();\n\t\t}\n\t}\n\n}", "complexity": "linear", "problem": "1038_D", "from": "CODEFORCES", "tags": "dp,greedy,implementation"}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    public static void main(String[] args) {\n        \n        var sc = new Scanner(System.in);\n        var pw = new PrintWriter(System.out);\n        \n        int T = Integer.parseInt(sc.next());\n        for(int t = 0; t < T; t++){\n            int n = Integer.parseInt(sc.next());\n            boolean ok = false;\n            if(n%2 == 0){\n                int a = n/2;\n                int b = (int) Math.sqrt(a);\n                if(b*b == a){\n                    ok = true;\n                }\n            }\n            if(n%4 == 0){\n                int a = n/4;\n                int b = (int) Math.sqrt(a);\n                if(b*b == a){\n                    ok = true;\n                }\n            }\n            if(ok){\n                pw.println(\"YES\");\n            }else{\n                pw.println(\"NO\");\n            }\n        }\n        pw.flush();\n    }\n}", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static String conv(String str) {\n\t\tboolean[] Arr = new boolean[26];\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tArr[str.charAt(i) - 'a'] = true;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (Arr[i])\n\t\t\t\tsb.append((char) (i + 'a'));\n\t\t}\n\t\treturn \"\" + sb;\n\t}\n\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashSet<String> hs = new HashSet<String>();\n\t\tint[] Arr = new int[14];\n\t\tlong max = 0;\n\t\tfor (int i = 0; i < 14; i++) {\n\t\t\tArr[i] = sc.nextInt();\n\t\t}\n\n\t\tfor (int i = 0; i < 14; i++) {\n\t\t\tint[] arr = Arr.clone();\n\n\t\t\tlong sum = 0;\n\t\t\tint r = arr[i];\n\t\t\tarr[i] = 0;\n\t\t\tfor (int j = i + 1; j < arr.length && r > 0; j++) {\n\t\t\t\tarr[j]++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tfor (int j = 0; j < arr.length; j++) {\n\t\t\t\tarr[j] +=( r / 14);\n\t\t\t\tif (j + 1 <= (r % 14)) {\n\t\t\t\t\tarr[j]++;\n\t\t\t\t}\n\t\t\t\tif (arr[j] % 2 == 0) {\n\t\t\t\t\tsum += arr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, sum);\n\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n}\n", "complexity": "constant", "problem": "0975_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "import java.io.*;\nimport java.util.*;\n\n/*\n * Raudel Ravelo Suarez\n * Problem: \n */\n\npublic class C \n{\n\tScanner sc;\n\tBufferedReader in;\n\tPrintStream out;\n\tStringTokenizer tok;\n\t\n\tpublic C() throws NumberFormatException, IOException\n\t{\n\t\t//sc = new Scanner(System.in);\n\t\t//sc = new Scanner(new FileReader(\"in.txt\"));\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t//in = new BufferedReader(new FileReader(\"in.txt\"));\n\t\tout = System.out;\n\t\trun();\n\t}\n\tvoid run() throws NumberFormatException, IOException\n\t{\n\t\t//Add your code here\n\t\tint[] array;\n\t\tint n = nextInt();\n\t\tarray = new int[n];\n\t\tint max = 0;\n\t\tint pos = 0;\n\t\tfor(int i = 0; i <n; i++)\n\t\t{\n\t\t\tint l = nextInt();\n\t\t\tif(l > max)\n\t\t\t{\n\t\t\t\tpos = i;\n\t\t\t\tmax = l;\n\t\t\t}\n\t\t\tarray[i] = l;\n\t\t}\n\t\tif(max == 1)array[pos] = 2;\n\t\telse array [pos] = 1;\n\t\tArrays.sort(array);\n\t\tout.print(array[0]);\n\t\tfor(int i = 1; i < n; i++)\n\t\t\tout.print(\" \" + array[i]);\n\t\tout.println();\n\t}\n\tpublic static void main(String[] args) throws NumberFormatException, IOException \n\t{\n\t\tnew C();\n\t}\n\tString nextToken() throws IOException\n\t{\n\t\tif(tok ==null || !tok.hasMoreTokens()) tok = new StringTokenizer(in.readLine());\n\t\treturn tok.nextToken();\n\t}\n\tint nextInt() throws NumberFormatException, IOException\n\t{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tlong nextLong() throws NumberFormatException, IOException\n\t{\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tdouble nextDouble() throws NumberFormatException, IOException\n\t{\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n\npublic class A {\n\t\n\tstatic class Scanner{\n\t\tBufferedReader br=null;\n\t\tStringTokenizer tk=null;\n\t\tpublic Scanner(){\n\t\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tpublic String next() throws IOException{\n\t\t\twhile(tk==null || !tk.hasMoreTokens())\n\t\t\t\ttk=new StringTokenizer(br.readLine());\n\t\t\treturn tk.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws NumberFormatException, IOException{\n\t\t\treturn Integer.valueOf(next());\n\t\t}\n\t\tpublic double nextDouble() throws NumberFormatException, IOException{\n\t\t\treturn Double.valueOf(next());\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) throws NumberFormatException, IOException{\n\t\tScanner sc = new Scanner();\n\t\tint T = sc.nextInt();\n\t\tif ( T > 0)\n\t\t\tSystem.out.println(T);\n\t\telse{\n\t\t\tString cad = (T + \"\");\n\t\t\tint min = Math.min(cad.charAt(cad.length() - 1) - '0', cad.charAt(cad.length() - 2) - '0');\n\t\t\tif (min == 0 && cad.length() == 3)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(cad.substring(0, cad.length() - 2) + \"\" + min);\n\t\t}\n\t}\n\n\t\n}\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n    static int[][][] dp; \n    public static void main(String[] args) {\n        Scanner r = new Scanner(System.in);\n        \n        int n = r.nextInt();\n        int m = r.nextInt();\n        \n        if(n > m){int t = n; n = m; m = t;}\n        \n        dp = new int[m+1][1 << 7][1 << 7];\n        for(int[][] i : dp)\n            for(int[] j : i)\n                Arrays.fill(j, -1);\n        int min = go(m, 0, (1<<n) -1, n, m);\n        \n        System.out.println(n * m - min);\n    }\n    private static int go(int rem, int prev, int need, int n, int m) {\n//      for(int i = rem; i < m; i++)\n//          System.out.print(\" \");\n//      System.out.println(rem + \": \" + prev +\",\"+need);\n        if(rem == 0)return prev == 0?0:1 << 20;\n        if(dp[rem][prev][need] != -1)return dp[rem][prev][need];\n        \n        int min = 1 << 20;\n        for(int now = 0; now < 1 << n; now++){\n            if((~now & prev) != 0)continue;\n            \n            int after = need & ~(now) & ~(now << 1) & ~(now >> 1);\n            int next = ~(now) & ((1 << n)-1);\n            int current = Integer.bitCount(now) + go(rem-1, after ,next, n, m);\n            min = Math.min(min, current);\n        }\n        return dp[rem][prev][need] = min;\n    }\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class AA implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new AA()).run();\n\n\t}\n\n\tstatic class Utils {\n\n\t\tprivate Utils() {\n\t\t}\n\n\t\tpublic static void mergeSort(int[] a) {\n\t\t\tmergeSort(a, 0, a.length - 1);\n\t\t}\n\n\t\tprivate static void mergeSort(int[] a, int leftIndex, int rightIndex) {\n\t\t\tfinal int MAGIC_VALUE = 50;\n\t\t\tif (leftIndex < rightIndex) {\n\t\t\t\tif (rightIndex - leftIndex <= MAGIC_VALUE) {\n\t\t\t\t\tinsertionSort(a, leftIndex, rightIndex);\n\t\t\t\t} else {\n\t\t\t\t\tint middleIndex = (leftIndex + rightIndex) / 2;\n\t\t\t\t\tmergeSort(a, leftIndex, middleIndex);\n\t\t\t\t\tmergeSort(a, middleIndex + 1, rightIndex);\n\t\t\t\t\tmerge(a, leftIndex, middleIndex, rightIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void merge(int[] a, int leftIndex, int middleIndex,\n\t\t\t\tint rightIndex) {\n\t\t\tint length1 = middleIndex - leftIndex + 1;\n\t\t\tint length2 = rightIndex - middleIndex;\n\t\t\tint[] leftArray = new int[length1];\n\t\t\tint[] rightArray = new int[length2];\n\t\t\tSystem.arraycopy(a, leftIndex, leftArray, 0, length1);\n\t\t\tSystem.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n\t\t\tfor (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n\t\t\t\tif (i == length1) {\n\t\t\t\t\ta[k] = rightArray[j++];\n\t\t\t\t} else if (j == length2) {\n\t\t\t\t\ta[k] = leftArray[i++];\n\t\t\t\t} else {\n\t\t\t\t\ta[k] = leftArray[i] <= rightArray[j] ? leftArray[i++]\n\t\t\t\t\t\t\t: rightArray[j++];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void insertionSort(int[] a, int leftIndex, int rightIndex) {\n\t\t\tfor (int i = leftIndex + 1; i <= rightIndex; i++) {\n\t\t\t\tint current = a[i];\n\t\t\t\tint j = i - 1;\n\t\t\t\twhile (j >= leftIndex && a[j] > current) {\n\t\t\t\t\ta[j + 1] = a[j];\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\ta[j + 1] = current;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tBufferedReader br;\n\tStringTokenizer str = new StringTokenizer(\"\");\n\tPrintWriter pw;\n\n\tpublic Integer ni() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic Double nd() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic Long nl() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic boolean EOF() {\n\t\ttry {\n\t\t\tif (!br.ready() && !str.hasMoreTokens()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String nextToken() {\n\t\twhile (!str.hasMoreTokens())\n\t\t\ttry {\n\t\t\t\tstr = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\treturn str.nextToken();\n\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t// try {\n\t\t// br = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t// } catch (FileNotFoundException e) {\n\t\t// e.printStackTrace();\n\t\t// }\n\t\t// try {\n\t\t// pw = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t// } catch (IOException e) {\n\t\t// // TODO Auto-generated catch block\n\t\t// e.printStackTrace();\n\t\t// }\n\t\tsolve();\n\t\tpw.close();\n\t}\n\n\tpublic void solve() {\n\n\t\tint n = ni();\n\t\tint[] a = new int[n];\n\t\tint total = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = ni();\n\t\t\ttotal+=a[i];\n\t\t}\n\t\tArrays.sort(a);\n\t\tint c =0;\n\t\tint left=0;\n\t\tfor(int i=n-1; i>=0;i--){\n\t\t\tif (left<=total){\n\t\t\t\tc++;\n\t\t\t\tleft+=a[i];\n\t\t\t\ttotal-=a[i];\n\t\t\t}\n\t\t}\n\t\tpw.print(c);\n\t}\n}", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.util.*;\n\npublic class Task25a {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint a1 = 0, a2 = 0;\n\t\tint n1 = 0, n2 = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint c = sc.nextInt();\n\t\t\tif (c % 2 == 1) {\n\t\t\t\ta1 = i;\n\t\t\t\tn1++;\n\t\t\t} else {\n\t\t\t\ta2 = i;\n\t\t\t\tn2++;\n\t\t\t}\n\t\t}\n\t\tif (n1 == 1) {\n\t\t\tSystem.out.println(a1);\n\t\t} else {\n\t\t\tSystem.out.println(a2);\n\t\t}\n\t}\n\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class MainClass\n{\n    public static void main(String[] args)throws IOException\n    {\n        Reader in = new Reader();\n//        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder stringBuilder = new StringBuilder();\n        int t = 1;\n        while (t -- > 0)\n        {\n            int n = in.nextInt();\n            long[] A = new long[n];\n            for (int i=n - 1;i>=n / 2;i--)\n                A[i] = in.nextLong();\n            long min = Long.MAX_VALUE;\n            for (int i=n - 1;i>=n / 2;i--)\n            {\n                if (A[i] > min)\n                {\n                    A[n - 1 - i] = A[i] - min;\n                    A[i] = min;\n                    if (n - 1 - i > 0 && A[n - 1 - i] < A[n - i - 2])\n                    {\n                        long diff = A[n - 2 - i] - A[n - 1 - i];\n                        A[n - 1 - i] += diff;\n                        A[i] -= diff;\n                    }\n                }\n                else\n                {\n                    if (n - 1 - i > 0 && A[n - 1 - i] < A[n - i - 2])\n                    {\n                        long diff = A[n - 2 - i] - A[n - 1 - i];\n                        A[n - 1 - i] += diff;\n                        A[i] -= diff;\n                    }\n                }\n                min = Math.min(min, A[i]);\n            }\n            for (int i=1;i<n;i++)\n                if (A[i] < A[i - 1])\n                    throw new ArithmeticException();\n            for (long x : A)\n                stringBuilder.append(x).append(\" \");\n            stringBuilder.append(\"\\n\");\n        }\n        System.out.println(stringBuilder);\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64]; // line length\n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}", "complexity": "linear", "problem": "1093_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class StringRepeat\n{\n\tstatic Scanner in = new Scanner( new BufferedReader( new InputStreamReader( System.in ) ) );\n\n\tpublic static void main( String[] args )\n\t{\n\t\tString s = in.next();\n\t\tint n = s.length(), ans = 0;\n\t\tfor( int i = 0; i < n; i++ ) for( int j = i+1; j < n; j++ )\n\t\t{\n\t\t\tint l = 0;\n\t\t\twhile( j+l<n && s.charAt(i+l)==s.charAt(j+l) ) l++;\n\t\t\tans = Math.max( ans, l );\n\t\t}\n\t\tSystem.out.println( ans );\n\t}\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\n\npublic class Main\n{\n\tstatic int MAX = 1000;\n\t\n\tstatic BitSet P = new BitSet(MAX + 1);\n\t\t\n\tpublic static boolean Noldbach(int n)\n\t{\n\t\tn--;\n\t\t\n\t\tint j;\n\t\t\n\t\tfor(int i=2; i<=n; i++)\n\t\t{\n\t\t\tif(!P.get(i))\n\t\t\t{\n\t\t\t\tj = i + 1;\n\t\t\t\t\n\t\t\t\twhile(P.get(j))\n\t\t\t\t\tj++;\n\t\t\t\t\n\t\t\t\tif(i+j == n)\n\t\t\t\t{\n\t\t\t\t\tif(!P.get(i+j+1))\n\t\t\t\t\t{\n\t\t\t\t\t\t//System.out.println((n+1)+\" = \"+i+\" + \"+(n-i)+\" + 1\");\n\t\t\t\t\t\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner lee = new Scanner(System.in);\t\n\n\t\tfor(int i=2; i*i<=MAX; i++)\n\t\t{\n\t\t    if(!P.get(i))\n\t\t    {\n\t\t    \tfor(int j=i+i; j<=MAX; j+=i)\n\t\t    \t\tP.set(j);\n\t\t    }\n\t\t}\n\t\t\n\t\tint n, k, c;\n\t\t\n\t\tn = lee.nextInt();\n\t\tk = lee.nextInt();\n\t\t\n\t\tc = 0;\n\t\t\n\t\tfor(int i=2; i<=n; i++)\n\t\t{\n\t\t\tif(Noldbach(i))\n\t\t\t\tc++;\n\t\t\t\n\t\t\tif(c == k)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(c == k)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n}", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\n\n\npublic class B {\n\t\n\t// -- DEBUG switch --\n\tstatic final boolean DBG = false;\n\tstatic StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\tstatic PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n\tstatic int[] e = new int[100001];\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = i(), k = i(), cnt = 0;\n\t\tint[] a = new int[n+1];\n\t\tfor (int i=1; i<=n; i++){\n\t\t\ta[i] = i();\n\t\t\tif (e[a[i]] == 0)\n\t\t\t\tcnt++;\n\t\t\te[a[i]]++;\n\t\t}\n\t\tif (k > cnt){\n\t\t\tpw.println(\"-1 -1\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif (cnt == n){\n\t\t\tpw.print(\"1 \" + k);\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif (k == 1){\n\t\t\tpw.println(\"1 1\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tArrays.fill(e, 0);\n\t\tint i = 1, j = 0, unik = 0, start = 0, end = 0, len = n, m = 0;\n\n\n\t\tif (e[a[i]] == 0){\n\t\t\tunik++;\n\t\t}\n\t\te[a[i]]++;\n\t\twhile (i+1<=n && a[i+1] == a[i]){\n\t\t\ti = i+1;\n\t\t}\t\t\n\t\t\n\t\tj = i+1;\n\t\t\n\t\twhile (j <= n){\n\t\t\tif (e[a[j]] == 0){\n\t\t\t\tunik++;\n\t\t\t\tif (unik == k){\n\t\t\t\t\twhile (e[a[i]] > 1){\n\t\t\t\t\t\te[a[i]]--;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\twhile (i+1<=n && a[i+1] == a[i]){\n\t\t\t\t\t\t\ti = i+1;\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}\n\t\t\t\t\tm = j - i + 1;\n\t\t\t\t\tif (m < len){\n\t\t\t\t\t\tstart = i; end = j; len = m;\n\t\t\t\t\t\tif (m == k)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\twhile (i <=n && unik == k){\n\t\t\t\t\t\te[a[i]]--;\n\t\t\t\t\t\tif (e[a[i]] == 0)\n\t\t\t\t\t\t\tunik--;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile (i+1<=n && a[i+1] == a[i]){\n\t\t\t\t\t\t\ti = i+1;\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\te[a[j]]++;\n\t\t\twhile (j+1<=n && a[j+1] == a[j]){\n\t\t\t\tj++;\n\t\t\t}\t\t\t\n\t\t\tj++;\n\n\t\t}\n\t\tpw.println(start + \" \" + end);\t\n\t\tpw.close();\n\t}\n\t\n\tstatic int i() throws IOException{\n\t\tst.nextToken();\n\t\treturn (int)st.nval;\n\t}\n\t\n\tstatic long l() throws IOException {\n\t\tst.nextToken();\n\t\treturn (long)st.nval;\n\t}\n\n\tstatic double d() throws IOException {\n\t\tst.nextToken();\n\t\treturn st.nval;\n\t}\n\tstatic String s() throws IOException{\n\t\tst.nextToken();\n\t\treturn st.sval;\n\t}\n}\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author gaidash\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            final int SIZE = 256;\n            final int UNDEF = -1;\n\n            int nPixels = in.nextInt();\n            int groupSize = in.nextInt();\n            int[] a = in.nextIntArray(nPixels);\n            boolean[] exists = new boolean[SIZE];\n            int[] left = new int[SIZE];\n            int[] right = new int[SIZE];\n            int[] ret = new int[nPixels];\n            Arrays.fill(ret, UNDEF);\n\n            for (int i = 0; i < nPixels; i++) {\n                for (int p = 0; p < SIZE; p++) {\n                    if (exists[p] && left[p] <= a[i] && a[i] <= right[p]) {\n                        ret[i] = left[p];\n                        left[a[i]] = left[p];\n                        right[a[i]] = right[p];\n                        break;\n                    }\n                }\n                if (ret[i] == UNDEF) {\n                    int l = Math.max(a[i] - groupSize + 1, 0);\n                    int r = l + groupSize - 1;\n                    for (int p = a[i] - 1; p >= 0; p--) {\n                        if (exists[p]) {\n                            if (p >= l) {\n                                int d = p - l;\n                                l = p + 1;\n                                r += d + 1;\n                            }\n                            if (right[p] >= l) {\n                                right[p] = l - 1;\n                            }\n                        }\n                    }\n                    for (int p = a[i] + 1; p < SIZE; p++) {\n                        if (exists[p] && left[p] <= r) {\n                            r = left[p] - 1;\n                        }\n                    }\n                    left[a[i]] = l;\n                    right[a[i]] = r;\n                    ret[i] = l;\n                }\n                exists[a[i]] = true;\n            }\n//        for (int p : a) {\n//            System.out.println(\"Segment for pixel \" + p + \" = \" + \"(\" + left[p] + \" , \" + right[p] + \")\");\n//        }\n\n            out.print(ret);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.zip.CRC32;\n\npublic class Solution {\n\n    static File inputfile = new File(\"C:\\\\Users\\\\IbrahimE6\\\\Downloads\\\\logs.csv\");\n    static Scanner scan;\n    static {\n        scan = new Scanner(System.in);\n//        try {\n//            scan = new Scanner(inputfile);\n//        } catch (FileNotFoundException e) {\n//            e.printStackTrace();\n//        }\n    }\n\n\n    public static long getPipes(long splitter, long number){\n        return (splitter * (splitter+1) / 2) - (number * (number-1) / 2) - (splitter - number);\n    }\n    public static void main(String[] args) {\n        // write your code here\n        long n = scan.nextLong(), k = scan.nextLong();\n        if(n == 1){\n            System.out.println(0);\n            return;\n        }\n        long start = 1, end = k-1;\n        while(true){\n            if(start > end){\n                System.out.println(-1);\n                break;\n            }else if(start == end){\n                if(getPipes(k, k - start + 1) >= n){\n                    System.out.println(start);\n                }else{\n                    System.out.println(-1);\n                }\n                break;\n            }else{\n                long mid = start + (end-start)/2;\n                long pipes = getPipes(k, k - mid + 1);\n                if(pipes < n){\n                    start = mid + 1;\n                }else{\n                    end = mid;\n                }\n            }\n        }\n\n    }\n\n\n\n}", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.util.Scanner;\n\npublic class A {\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        \n        System.out.println(n/2*3);\n    }\n}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class code\n{\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n    \n    public static void main(String args[])throws IOException\n\t{\n        FastReader scn = new FastReader();\n\n        long a_ = scn.nextLong();\n        long b_ = scn.nextLong();\n\n        String a_str = Long.toBinaryString(a_);\n        String b_str = Long.toBinaryString(b_);\n\n        int a_str_length = a_str.length();\n        int b_str_length = b_str.length();\n\n        StringBuilder a = new StringBuilder();\n        StringBuilder b = new StringBuilder();\n        StringBuilder max_xor = new StringBuilder();\n\n        while(a_str_length++ < 64)\n            a.append(0);\n        while(b_str_length++ < 64)\n            b.append(0);\n        a.append(a_str);\n        b.append(b_str);\n\n\n        boolean equality = true;\n        boolean max_gave_up = false;\n        boolean min_gave_up = false;\n\n        for(int i = 0; i < 64; i++)\n        {\n\n            if((a.charAt(i) == b.charAt(i)) && equality)\n            {\n                max_xor.append('0');\n                continue;\n            }   \n\n            if(equality)\n                equality = false;\n\n            max_xor.append('1');\n        }\n        //System.out.println(max_xor.toString());\n        System.out.println(Long.parseLong(max_xor.toString(), 2));\n\t}\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Array {\n\t\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\t/*\n\t\tif ( k == 1 ){ \n\t\t\tSystem.out.println(\"1 1\"); return;\n\t\t}\n\t\t*/\n\t\tint last[] = new int[100001];\n\t\tint distinct = 0;\n\t\tfor ( int i = 0 ; i < n ; ++i ) {\n\t\t\tint t = in.nextInt();\n\t\t\tif ( last[t] == 0 ) ++distinct;\n\t\t\tlast[t] = i+1;\n\t\t\tif ( distinct == k ) {\n\t\t\t\tint min = i+1;\n\t\t\t\tfor ( int j = 0 ; j < last.length ; ++j ) {\n\t\t\t\t\tif ( last[j] != 0 ) min = min>last[j]?last[j]:min;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(min+\" \"+(i+1)); return;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"-1 -1\"); \n\t}\n\t\n}\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class E {\n\n\tstatic int R,C;\n\tstatic int [][] grid;\n\t\n\tstatic int[] colsToRot, rot;\n\t\n\tstatic int res;\n\t\n\tpublic static void main(String args[]) {\n\t\tFS in = new FS();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\t// Put all numbers in a list sorted by large to small\n\t\t// Pick numbers until R different columns selected\n\t\t// Fix 1st column, brute force remaining ones\n\t\t\n\t\tint T = in.nextInt();\n\t\tfor(int runs = 1; runs <= T; runs++) {\n\t\t\tR = in.nextInt();\n\t\t\tC = in.nextInt();\n\t\t\tgrid = new int[R][C];\n\t\t\tNum nums[] = new Num[R*C];\n\t\t\tint ni = 0;\n\t\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\tfor(int j = 0; j < C; j++) {\n\t\t\t\t\tgrid[i][j] = in.nextInt();\n\t\t\t\t\tnums[ni++] = new Num(grid[i][j], j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(nums);\n\t\t\t\n\t\t\tint have = 0;\n\t\t\tboolean[] used = new boolean[C];\n\t\t\tfor(int i = 0; i < nums.length; i++) {\n\t\t\t\tif(!used[nums[i].column]) {\n\t\t\t\t\tused[nums[i].column] = true;\n\t\t\t\t\thave++;\n\t\t\t\t\tif(have >= R) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Now brute force positions of all of the rows\n\t\t\tcolsToRot = new int[have];\n\t\t\trot = new int[have];\n\t\t\tint hi = 0;\n\t\t\tfor(int i = 0; i < C; i++) {\n\t\t\t\tif(used[i]) colsToRot[hi++] = i;\n\t\t\t}\n//\t\t\tSystem.out.println(Arrays.toString(colsToRot));\n\t\t\tres = 0;\n\t\t\tdfs(1);\n\t\t\tout.println(res);\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic void dfs(int id) {\n\t\tif(id >= colsToRot.length) {\n\t\t\tint[] max = new int[R];\n\t\t\tfor(int i = 0; i < colsToRot.length; i++) {\n\t\t\t\tfor(int j = 0; j < R; j++) {\n\t\t\t\t\tmax[(j+rot[i])%R] = Math.max(max[(j+rot[i])%R], grid[j][colsToRot[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cur = 0;\n\t\t\tfor(int ii : max) cur += ii;\n\t\t\tres = Math.max(res, cur);\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tfor(int ro = 0; ro < R; ro++) {\n\t\t\t\trot[id] = ro;\n\t\t\t\tdfs(id+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Num implements Comparable<Num>{\n\t\tint val, column;\n\t\tpublic Num(int vv, int cc) {\n\t\t\tval=vv;\n\t\t\tcolumn=cc;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Num o) {\n\t\t\treturn o.val-val;\n\t\t}\n\t}\n\t\n\tstatic class FS{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FS() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {\n\t\t\twhile(st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\t\tcatch(Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() { return Integer.parseInt(next());}\n\t\tlong nextLong() { return Long.parseLong(next());}\n\t\tdouble nextDouble() { return Double.parseDouble(next());}\n\t}\n}\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author beginner1010\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            TreeSet<Integer> set = new TreeSet<>();\n            int n = in.nextInt();\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt();\n                set.add(x);\n            }\n            int ans = 0;\n            while (!set.isEmpty()) {\n                ans++;\n                int minimal = set.first();\n                int cur = minimal;\n                while (cur <= 100) {\n                    set.remove(cur);\n                    cur += minimal;\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class InputReader {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputStream stream;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhitespace(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isWhitespace(c));\n            return res * sgn;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class ProblemB3 {\n    Map<Integer, List<int[]>> dest;\n\n    private ProblemB3() throws IOException {\n        BufferedReader rd = new BufferedReader(new InputStreamReader(System.in));\n        String h = rd.readLine();\n        String[] q = h.split(\"\\\\s+\");\n        int a = Integer.parseInt(q[1]);\n        int b = Integer.parseInt(q[2]);\n        h = rd.readLine();\n        q = h.split(\" \");\n        int n = q.length;\n        int[] p = new int[n];\n        for(int i=0;i<n;i++) {\n            p[i] = Integer.parseInt(q[i]);\n        }\n        Set<Integer> pset = new HashSet<>();\n        for(int x: p) {\n            pset.add(x);\n        }\n        dest = new HashMap<>();\n        boolean res = true;\n        for(int x: p) {\n            boolean aOk = pset.contains(a-x);\n            boolean bOk = pset.contains(b-x);\n            if(!aOk && !bOk) {\n                res = false;\n                break;\n            } else {\n                if(aOk) {\n                    addEdgeAndBack(x,a-x,0);\n                }\n                if(bOk) {\n                    addEdgeAndBack(x,b-x,1);\n                }\n            }\n        }\n        Set<Integer> aSet = new HashSet<>();\n\n        if(res && a != b) {\n            for(int x: p) {\n                List<int[]> e = getEdges(x);\n                if(e.size() == 1) {\n                    int[] edge = e.get(0);\n                    boolean odd = true;\n                    int curA = edge[1];\n                    int prev = x;\n                    while(true) {\n                        int cur = edge[0];\n                        if(curA == 0 && odd) {\n                            aSet.add(prev);\n                            aSet.add(cur);\n                        }\n                        e = getEdges(cur);\n                        if(e.size() == 1) {\n                            if(!odd && e.get(0)[0] != cur) {\n                                res = false;\n                            }\n                            break;\n                        }\n                        int other = e.get(0)[0] == prev?1:0;\n                        edge = e.get(other);\n                        if(edge[1] == curA) {\n                            res = false;\n                            break;\n                        }\n                        curA = 1-curA;\n                        prev = cur;\n                        odd = !odd;\n                    }\n                    if(!res) {\n                        break;\n                    }\n                }\n            }\n        }\n        out(res?\"YES\":\"NO\");\n        if(res) {\n            StringBuilder buf = new StringBuilder();\n            for(int i=0;i<n;i++) {\n                if(i>0) {\n                    buf.append(' ');\n                }\n                buf.append(aSet.contains(p[i])?'0':'1');\n            }\n            out(buf);\n        }\n    }\n\n    private void addEdgeAndBack(int from, int to, int u) {\n        addEdge(from, to, u);\n        addEdge(to, from, u);\n    }\n\n    private void addEdge(int from, int to, int u) {\n        List<int[]> edges = getEdges(from);\n        for(int[] edge: edges) {\n            if(edge[0] == to) {\n                return;\n            }\n        }\n        edges.add(new int[]{to, u});\n    }\n\n    private List<int[]> getEdges(int from) {\n        List<int[]> ds = dest.get(from);\n        if(ds == null) {\n            ds = new ArrayList<>();\n            dest.put(from, ds);\n        }\n        return ds;\n    }\n\n    private static void out(Object x) {\n        System.out.println(x);\n    }\n\n    public static void main(String[] args) throws IOException {\n        new ProblemB3();\n    }\n}\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.util.*;\nimport java.io.*;\n/*\n * Heart beats fast\n * \t\tColors and promises\n * \t\t\tHow to be brave\n * \t\t\t\tHow can I love when I am afraid...\n */\npublic class Main\n{\n\tpublic static void main(String[]args) throws Exception\n\t{\n\t\t\tint n=ni();\n\t\t\tdouble ke=ni();\n\t\t\tboolean[][]a=new boolean[n][n];\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\tfor(int j=0; j<n; j++)\n\t\t\t\t\ta[i][j]=ni()==0;\n\t\t\tint left=n/2;\n\t\t\tint[]ldp=new int[1<<left];\n\t\t\tint[]rdp=new int[1<<(n-left)];\n\t\t\tint[]pow=new int[25];\n\t\t\tpow[0]=1;\n\t\t\tfor(int i=1; i<25; i++)\n\t\t\t\tpow[i]=pow[i-1]<<1;\n\t\t\tfor(int i=0; i<pow[left]; i++)\n\t\t\t\tou:for(int j=0; j<left; j++)\n\t\t\t\t\tif((i>>j)%2==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint te=i;\n\t\t\t\t\t\tfor(int k=0; te>0; k++,te>>=1)\n\t\t\t\t\t\t\tif(a[j][k]&&(te&1)!=0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tldp[i+pow[j]]=max(ldp[i+pow[j]],ldp[i]);\n\t\t\t\t\t\t\t\tcontinue ou;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tldp[i+pow[j]]=max(ldp[i+pow[j]],ldp[i]+1);\n\t\t\t\t\t}\n\t\t\tint right=n-left;\n\t\t\tfor(int i=0; i<pow[right]; i++)\n\t\t\t\tou:for(int j=0; j<right; j++)\n\t\t\t\t\tif((i>>j)%2==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint lul=j+left;\n\t\t\t\t\t\tint te=i;\n\t\t\t\t\t\tfor(int k=left; te>0; k++,te>>=1)\n\t\t\t\t\t\t\tif(a[lul][k]&&(te&1)!=0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trdp[i+pow[j]]=max(rdp[i+pow[j]],rdp[i]);\n\t\t\t\t\t\t\t\tcontinue ou;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\trdp[i+pow[j]]=max(rdp[i+pow[j]],rdp[i]+1);\n\t\t\t\t\t}\n\t\t\tint maxi=0;\n\t\t\tfor(int i=0; i<pow[left]; i++)\n\t\t\t{\n\t\t\t\tint lol=0;\n\t\t\t\tint te=i;\n\t\t\t\tfor(int j=0; te>0; j++,te>>=1)\n\t\t\t\t\tif((te&1)!=0)\n\t\t\t\t\t\tfor(int k=0; k<right; k++)\n\t\t\t\t\t\t\tif(a[j][k+left])\n\t\t\t\t\t\t\t\tlol|=pow[k];\n\t\t\t\tmaxi=max(maxi,ldp[i]+rdp[pow[right]-1-lol]);\n\t\t\t}\n\t\t\tpr((ke*ke*(maxi-1))/(2*maxi));\n\t\tSystem.out.println(output);\n\t}\n\t///////////////////////////////////////////\n\t///////////////////////////////////////////\n\t///template from here\n//\tstatic final int mod=998_244_353;\n\tstatic final int mod=1000_000_007;\n\tstatic final double eps=1e-7;\n\tstatic final long inf=1000_000_000_000_000_000L;\n\tstatic class pair\n\t{\n\t\tint a,b;\n\t\tpair(){}\n\t\tpair(int c,int d){a=c;b=d;}\n\t\t@Override\n\t\tpublic int hashCode()\n\t\t{\n\t\t\treturn (a+\" \"+b).hashCode();\n\t\t}\n\t\tpublic boolean equals(Object c)\n\t\t{\n\t\t\treturn (a==(((pair)c).a)&&b==(((pair)c).b));\n\t\t}\n\t}\n\tpublic static void sort(int[][]a)\n\t{\n\t\tArrays.sort(a, new Comparator<int[]>()\n\t\t\t\t{\n\t\t\tpublic int compare(int[]a,int[]b)\n\t\t\t{\n\t\t\t\tif(a[0]>b[0])\n\t\t\t\t\treturn 1;\n\t\t\t\tif(a[0]<b[0])\n\t\t\t\t\treturn -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\t});\n\t}\n\tstatic interface combiner\n\t{\n\t\tpublic int combine(int a, int b);\n\t}\n\tstatic void pr(Object a){output.append(a+\"\\n\");}\n\tstatic void pr(){output.append(\"\\n\");}\n\tstatic void p(Object a){output.append(a);}\n\tstatic void pra(int[]a){for(int i:a)output.append(i+\" \");output.append(\"\\n\");}\n\tstatic void pra(long[]a){for(long i:a)output.append(i+\" \");output.append(\"\\n\");}\n\tstatic void pra(String[]a){for(String i:a)output.append(i+\" \");output.append(\"\\n\");}\n\tstatic void pra(double[]a){for(double i:a)output.append(i+\" \");output.append(\"\\n\");}\n\tstatic void sop(Object a){System.out.println(a);}\n\tstatic void flush(){System.out.print(output);output=new StringBuilder();}\n\tstatic int ni(){return Integer.parseInt(in.next());}\n\tstatic long nl(){return Long.parseLong(in.next());}\n\tstatic String ns(){return in.next();}\n\tstatic double nd(){return Double.parseDouble(in.next());}\n\tstatic int[] nia(int n){int a[]=new int[n];for(int i=0; i<n; i++)a[i]=ni();return a;}\n\tstatic int[] pnia(int n){int a[]=new int[n+1];for(int i=1; i<=n; i++)a[i]=ni();return a;}\n\tstatic long[] nla(int n){long a[]=new long[n];for(int i=0; i<n; i++)a[i]=nl();return a;}\n\tstatic String[] nsa(int n){String a[]=new String[n];for(int i=0; i<n; i++)a[i]=ns();return a;}\n\tstatic double[] nda(int n){double a[]=new double[n];for(int i=0; i<n; i++)a[i]=nd();return a;}\n\tstatic Reader in=new Reader();\n\tstatic StringBuilder output=new StringBuilder();\n\tstatic Random rn=new Random();\n\tstatic void reverse(int[]a){for(int i=0; i<a.length/2; i++){a[i]^=a[a.length-i-1];a[a.length-i-1]^=a[i];a[i]^=a[a.length-i-1];}}\n\tstatic int log2n(long a)\n\t{\n\t\tint te=0;\n\t\twhile(a>0)\n\t\t{\n\t\t\ta>>=1;\n\t\t\t++te;\n\t\t}\n\t\treturn te;\n\t}\n\tstatic class vectorl implements Iterable<Long>\n\t{\n\t\tlong a[];\n\t\tint size;\n\t\tvectorl(){a=new long[10];size=0;}\n\t\tvectorl(int n){a=new long[n];size=0;}\n\t\tpublic void add(long b){if(++size==a.length)a=Arrays.copyOf(a, 2*size);a[size-1]=b;}\n\t\tpublic void sort(){Arrays.sort(a, 0, size);}\n\t\tpublic void sort(int l, int r){Arrays.sort(a, l, r);}\n\t\t@Override\n\t\tpublic Iterator<Long> iterator() {\n\t\t\tIterator<Long> hola=new Iterator<Long>()\n\t\t\t\t\t{\n\t\t\t\tint cur=0;\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\treturn cur<size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Long next() {\n\t\t\t\t\t\t\treturn a[cur++];\n\t\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\t};\n\t\t\treturn hola;\n\t\t}\n\t}\n\tstatic class vector implements Iterable<Integer>\n\t{\n\t\tint a[],size;\n\t\tvector(){a=new int[10];}\n\t\tvector(int n){a=new int[n];}\n\t\tpublic void add(int b){if(++size==a.length)a=Arrays.copyOf(a, 2*size);a[size-1]=b;}\n\t\tpublic void sort(){Arrays.sort(a, 0, size);}\n\t\tpublic void sort(int l, int r){Arrays.sort(a, l, r);}\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\tIterator<Integer> hola=new Iterator<Integer>()\n\t\t\t\t\t{\n\t\t\t\tint cur=0;\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\treturn cur<size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Integer next() {\n\t\t\t\t\t\t\treturn a[cur++];\n\t\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\t};\n\t\t\treturn hola;\n\t\t}\n\t}\n\tstatic void exit(){System.out.print(output);System.exit(0);}\n\tstatic int min(int... a){int min=a[0];for(int i:a)min=Math.min(min, i);return min;}\n\tstatic int max(int... a){int max=a[0];for(int i:a)max=Math.max(max, i);return max;}\t\n\tstatic int gcd(int... a){int gcd=a[0];for(int i:a)gcd=gcd(gcd, i);return gcd;}\t\n\tstatic long min(long... a){long min=a[0];for(long i:a)min=Math.min(min, i);return min;}\n\tstatic long max(long... a){long max=a[0];for(long i:a)max=Math.max(max, i);return max;}\t\n\tstatic long gcd(long... a){long gcd=a[0];for(long i:a)gcd=gcd(gcd, i);return gcd;}\t\n\tstatic String pr(String a, long b){String c=\"\";while(b>0){if(b%2==1)c=c.concat(a);a=a.concat(a);b>>=1;}return c;}\n\tstatic long powm(long a, long b, long mod2){long an=1;long c=a%mod2;while(b>0){if(b%2==1)an=(an*c)%mod2;c=(c*c)%mod2;b>>=1;}return an;}\n\tstatic long pow(long a, long b){long an=1;long c=a;while(b>0){if(b%2==1)an*=c;c*=c;b>>=1;}return an;}\n\tstatic int gcd(int a, int b){if(b==0)return a;return gcd(b, a%b);}\n\tstatic long gcd(long a, long b){if(b==0)return a;return gcd(b, a%b);}\n\tstatic class Reader{\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public Reader() {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n    }\n} ", "complexity": "np", "problem": "0839_E", "from": "CODEFORCES", "tags": "brute force,graphs,math,meet-in-the-middle"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n    public static void main(String ...args) throws Throwable {\n        Scanner in = new Scanner(System.in);\n        String init = in.nextLine();\n        HashSet<String> h = new HashSet<String>();\n        for (int len = init.length() - 1; len >= 1; --len)  {\n            h.clear();\n            for (int pos = 0; pos + len <= init.length(); ++pos) {\n                String now = init.substring(pos, pos + len);\n                if (h.contains(now)) {\n                    System.out.println(len);\n                    return;\n                }\n                h.add(now);\n            }\n\n        }\n\n        System.out.println(0);\n    }\n}\n        ", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "//package hello2018;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class E3 {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tString[] cs = \"!x&x, !(x|y|z), !x&!y&z, !x&!y, !x&!z&y, !x&!z, !(!y&!z|x|y&z), !(x|y&z), !x&y&z, !(!y&z|!z&y|x), !x&z, !(!z&y|x), !x&y, !(!y&z|x), !x&(y|z), !x, !y&!z&x, !y&!z, !(!x&!z|x&z|y), !(x&z|y), !(!x&!y|x&y|z), !(x&y|z), !(!x&!y|x&y|z)|!x&!y&z, !((x|y)&z|x&y), !x&y&z|!y&!z&x, !x&y&z|!y&!z, !x&z|!y&!z&x, !x&z|!y&!z, !x&y|!y&!z&x, !x&y|!y&!z, !x&(y|z)|!y&!z&x, !x|!y&!z, !y&x&z, !(!x&z|!z&x|y), !y&z, !(!z&x|y), !x&!z&y|!y&x&z, !x&!z|!y&x&z, !x&!z&y|!y&z, !x&!z|!y&z, !x&y&z|!y&x&z, !(!x&z|!z&x|y)|!x&y&z, !(x&y)&z, !(!z&x|y)|!x&z, !x&y|!y&x&z, !(!y&z|x)|!y&x&z, !x&y|!y&z, !x|!y&z, !y&x, !(!x&z|y), !y&(x|z), !y, !x&!z&y|!y&x, !x&!z|!y&x, !x&!z&y|!y&(x|z), !x&!z|!y, !x&y&z|!y&x, !(!x&z|y)|!x&y&z, !x&z|!y&x, !x&z|!y, !x&y|!y&x, !(!x&!y&z|x&y), !x&(y|z)|!y&x, !x|!y, !z&x&y, !(!x&y|!y&x|z), !x&!y&z|!z&x&y, !x&!y|!z&x&y, !z&y, !(!y&x|z), !x&!y&z|!z&y, !x&!y|!z&y, !x&y&z|!z&x&y, !(!x&y|!y&x|z)|!x&y&z, !x&z|!z&x&y, !(!z&y|x)|!z&x&y, !(x&z)&y, !(!y&x|z)|!x&y, !x&z|!z&y, !x|!z&y, !z&x, !(!x&y|z), !x&!y&z|!z&x, !x&!y|!z&x, !z&(x|y), !z, !x&!y&z|!z&(x|y), !x&!y|!z, !x&y&z|!z&x, !(!x&y|z)|!x&y&z, !x&z|!z&x, !(!x&!z&y|x&z), !x&y|!z&x, !x&y|!z, !x&(y|z)|!z&x, !x|!z, !y&x&z|!z&x&y, !(!x&y|!y&x|z)|!y&x&z, !y&z|!z&x&y, !(!z&x|y)|!z&x&y, !y&x&z|!z&y, !(!y&x|z)|!y&x&z, !y&z|!z&y, !(!y&!z&x|y&z), !x&y&z|!y&x&z|!z&x&y, !(!x&y|!y&x|z)|!x&y&z|!y&x&z, !(x&y)&z|!z&x&y, !(!z&x|y)|!x&z|!z&x&y, !(x&z)&y|!y&x&z, !(!y&x|z)|!x&y|!y&x&z, !(x&y)&z|!z&y, !x|!y&z|!z&y, !(y&z)&x, !(!x&y|z)|!y&x, !y&z|!z&x, !y|!z&x, !y&x|!z&y, !y&x|!z, !y&(x|z)|!z&y, !y|!z, !(y&z)&x|!x&y&z, !(!x&y|z)|!x&y&z|!y&x, !(x&y)&z|!z&x, !x&z|!y|!z&x, !(x&z)&y|!y&x, !x&y|!y&x|!z, !x&y|!y&z|!z&x, !(x&y&z), x&y&z, !(x|y|z)|x&y&z, !x&!y&z|x&y&z, !x&!y|x&y&z, !x&!z&y|x&y&z, !x&!z|x&y&z, !(!y&!z|x|y&z)|x&y&z, !(x|y&z)|x&y&z, y&z, !(x|y|z)|y&z, !x&z|y&z, !x&!y|y&z, !x&y|y&z, !x&!z|y&z, !x&(y|z)|y&z, !x|y&z, !y&!z&x|x&y&z, !y&!z|x&y&z, !(!x&!z|x&z|y)|x&y&z, !(x&z|y)|x&y&z, !(!x&!y|x&y|z)|x&y&z, !(x&y|z)|x&y&z, !(!x&!y|x&y|z)|!x&!y&z|x&y&z, !((x|y)&z|x&y)|x&y&z, !y&!z&x|y&z, !y&!z|y&z, !x&z|!y&!z&x|y&z, !(x&z|y)|y&z, !x&y|!y&!z&x|y&z, !(x&y|z)|y&z, !x&(y|z)|!y&!z&x|y&z, !x|!y&!z|y&z, x&z, !(x|y|z)|x&z, !y&z|x&z, !x&!y|x&z, !x&!z&y|x&z, !x&!z|x&z, !x&!z&y|!y&z|x&z, !(x|y&z)|x&z, (x|y)&z, !(x|y|z)|(x|y)&z, z, !x&!y|z, !x&y|x&z, !(!y&z|x)|x&z, !x&y|z, !x|z, !y&x|x&z, !y&!z|x&z, !y&(x|z)|x&z, !y|x&z, !x&!z&y|!y&x|x&z, !(x&y|z)|x&z, !x&!z&y|!y&(x|z)|x&z, !x&!z|!y|x&z, !y&x|y&z, !(!x&z|y)|y&z, !y&x|z, !y|z, !x&y|!y&x|x&z, !x&!z|!y&x|y&z, !x&y|!y&x|z, !x|!y|z, x&y, !(x|y|z)|x&y, !x&!y&z|x&y, !x&!y|x&y, !z&y|x&y, !x&!z|x&y, !x&!y&z|!z&y|x&y, !(x|y&z)|x&y, (x|z)&y, !(x|y|z)|(x|z)&y, !x&z|x&y, !(!z&y|x)|x&y, y, !x&!z|y, !x&z|y, !x|y, !z&x|x&y, !y&!z|x&y, !x&!y&z|!z&x|x&y, !(x&z|y)|x&y, !z&(x|y)|x&y, !z|x&y, !x&!y&z|!z&(x|y)|x&y, !x&!y|!z|x&y, !z&x|y&z, !(!x&y|z)|y&z, !x&z|!z&x|x&y, !x&!y|!z&x|y&z, !z&x|y, !z|y, !x&z|!z&x|y, !x|!z|y, (y|z)&x, !(x|y|z)|(y|z)&x, !y&z|x&y, !(!z&x|y)|x&y, !z&y|x&z, !(!y&x|z)|x&z, !y&z|!z&y|x&y, !x&!y|!z&y|x&z, (x|y)&z|x&y, !(x|y|z)|(x|y)&z|x&y, x&y|z, !x&!y|x&y|z, x&z|y, !x&!z|x&z|y, y|z, !x|y|z, x, !y&!z|x, !y&z|x, !y|x, !z&y|x, !z|x, !y&z|!z&y|x, !y|!z|x, x|y&z, !y&!z|x|y&z, x|z, !y|x|z, x|y, !z|x|y, x|y|z, !x|x\".split(\", \");\n\t\t\n\t\tfor(int Q = ni();Q > 0;Q--){\n\t\t\tchar[] s = ns().toCharArray();\n\t\t\tint x = 0;\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\tx = x | s[i]-'0'<<i;\n\t\t\t}\n\t\t\tout.println(cs[x]);\n\t\t}\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new E3().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "quadratic", "problem": "0913_E", "from": "CODEFORCES", "tags": "bitmasks,dp,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class D11 {\n\tstatic HashMap<State, Integer> map;\n\tstatic long[][] ans;\n\tstatic boolean[][] connect;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tmap = new HashMap<State, Integer>();\n\t\tconnect = new boolean[n][n];\n\t\tans = new long[n][1<<n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tArrays.fill(ans[i], -1);\n\t\tint m = Integer.parseInt(st.nextToken());\n\t\twhile(m-- > 0)\t{\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint a = Integer.parseInt(st.nextToken());\n\t\t\tint b = Integer.parseInt(st.nextToken());\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tconnect[a][b] = connect[b][a] = true;\n\t\t}\n\t\tlong ret = 0;\n\t\tint mask = 1 << n;\n\t\tmask--;\n\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\tfor(int out = i+1; out < n; out++)\t{\n\t\t\t\tif(connect[i][out])\t{\n\t\t\t\t\tret += solve(mask - (1<<out), out, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmask -= (1<<i);\n\t\t}\n\t\tSystem.out.println(ret/2);\n\t}\n\tpublic static long solve(int mask, int start, boolean a)\t{\n\t\tif(ans[start][mask] != -1)\n\t\t\treturn ans[start][mask];\n\t\tint end = 0;\n\t\twhile((mask & (1<<end)) == 0)\n\t\t\tend++;\n\t\tlong ret = 0;\n\t\tfor(int out = 0; out < connect.length; out++)\t{\n\t\t\tif(connect[start][out] && (mask & (1 << out)) != 0)\t{\n\t\t\t\tif(out == end)\t{\n\t\t\t\t\tif(!a)\n\t\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tret += solve(mask - (1<<out), out, false);\n\t\t\t}\n\t\t}\n\t\tans[start][mask] = ret;\n\t\treturn ret;\n\t}\n\tstatic class State\t{\n\t\tpublic byte start, go;\n\t\tpublic int mask;\n\t\tpublic State(byte a, byte b, int c)\t{\n\t\t\tstart = a;\n\t\t\tgo = b;\n\t\t\tmask = c;\n\t\t}\n\t\tpublic int hashCode()\t{\n\t\t\treturn 10007*mask + 43 * start + go;\n\t\t}\n\t\tpublic boolean equals(Object o)\t{\n\t\t\tState s = (State)o;\n\t\t\treturn start == s.start && go == s.go && mask == s.mask;\n\t\t}\n\t}\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class Quiz {\n    public static long pow(long base, long power) {\n        if (power == 0)\n            return 1;\n        long half = pow(base, power / 2) % mod;\n        half *= half;\n        half %= mod;\n        if (power % 2 == 1)\n            half *= base;\n        return half % mod;\n    }\n\n    static long mod = (long) (1e9 + 9);\n\n    public static void main(String[] args) {\n        InputReader r = new InputReader(System.in);\n        int n = r.nextInt();\n        int m = r.nextInt();\n        int k = r.nextInt();\n        int buckets = n / k;\n        int rem = n - buckets * k;\n        long low = 0, high = buckets, itr = 30;\n        while (itr-- > 0) {\n            long mid = (low + high) / 2;\n            long correct = mid * k + rem + (buckets - mid) * (k - 1);\n            if (correct < m)\n                low = mid;\n            else\n                high = mid;\n        }\n        long pow = (pow(2, high + 1) - 2 + mod) % mod;\n        pow *= k;\n        pow %= mod;\n        long res = m - (high * k) + pow + 10 * mod;\n        res %= mod;\n        System.out.println(res);\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public InputReader(FileReader stream) {\n            reader = new BufferedReader(stream);\n            tokenizer = null;\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n/**\n * @author Son-Huy TRAN\n * \n */\npublic class P122A_LuckyDivision {\n\n\tprivate static boolean isLuckyNumber(int number) {\n\t\twhile (number > 0) {\n\t\t\tint digit = number % 10;\n\n\t\t\tif (digit != 4 && digit != 7) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tnumber /= 10;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static boolean isAlmostLuckyNumber(int number) {\n\t\tint max = (int) Math.sqrt(number);\n\t\tint i = 1;\n\n\t\twhile (i <= max) {\n\t\t\tif (number % i == 0\n\t\t\t\t\t&& (isLuckyNumber(i) || isLuckyNumber(number / i))) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\t// begin reading inputs\n\t\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\t\tBufferedReader reader = new BufferedReader(isr);\n\n\t\t\t// reading inputs\n\t\t\tint input = Integer.parseInt(reader.readLine());\n\n\t\t\treader.close();\n\t\t\tisr.close();\n\t\t\t// end reading inputs\n\n\t\t\tboolean result = isAlmostLuckyNumber(input);\n\t\t\tSystem.out.println(result ? \"YES\" : \"NO\");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "//package goodbye2018;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class F {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tlong[] L = new long[n];\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tL[i] = nl();\n\t\t}\n\t\tchar[] te = ns(n);\n\t\t\n\t\tlong s1 = 0, s2 = 0;\n\t\tlong xslope = 5;\n\t\tlong ans = 0;\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tif(te[i] == 'G') {\n\t\t\t\tlong need = L[i];\n\t\t\t\t{\n\t\t\t\t\tlong use = Math.min(s1, need);\n\t\t\t\t\tans += 2*use;\n\t\t\t\t\ts1 -= use; need -= use;\n\t\t\t\t}\n\t\t\t\tans += 3*need;\n\t\t\t\ts2 += L[i]-need+L[i];\n\t\t\t}else if(te[i] == 'W') {\n\t\t\t\tans += 2*L[i];\n\t\t\t\ts1 += L[i];\n\t\t\t\txslope = 3;\n\t\t\t}else {\n\t\t\t\tlong need = L[i];\n\t\t\t\tans += L[i];\n\t\t\t\t{\n\t\t\t\t\tlong use = Math.min(s1, need);\n\t\t\t\t\ts1 -= use; need -= use;\n\t\t\t\t\tans += use;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tlong use = Math.min(s2, need);\n\t\t\t\t\ts2 -= use; need -= use;\n\t\t\t\t\tans += 2*use;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tans += xslope*need;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new F().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "linear", "problem": "1091_F", "from": "CODEFORCES", "tags": "constructive algorithms,greedy"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tPrintWriter out = new PrintWriter(System.out);\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok = new StringTokenizer(\"\");\n    String next() throws IOException {\n        if (!tok.hasMoreTokens()) { tok = new StringTokenizer(in.readLine()); }\n        return tok.nextToken();\n    }\n    int ni() throws IOException { return Integer.parseInt(next()); }\n    long nl() throws IOException { return Long.parseLong(next()); }\n  \n    void solve() throws IOException {\n        int n=ni(),k=ni();\n        int puts=(int)Math.sqrt(2*k);\n        int t=(puts*(puts+1))/2;\n        puts++;\n        while (t<k) { t+=puts; puts++; }\n        \n        int turns=puts-1;\n        while (t-k!=n-turns) {\n            t+=puts;\n            puts++;\n            turns++;\n        }\n        System.out.println(t-k);\n    }\n    \n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n    }\n}", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.text.DecimalFormat;\nimport java.util.Scanner;\n\npublic class A {\n    public static void main(String[] args){\n        try{\n            Scanner scanner = new Scanner(System.in);\n            String in = scanner.next();\n            int max = 0;\n            for(int j=0;j<in.length()-1;j++){\n                for(int i=j;i<in.length();i++){\n                    if(in.indexOf(in.substring(j, i)) != in.lastIndexOf(in.substring(j, i)) && (i-j)>max){\n                        max = i-j;\n                    }\n                }\n            }\n            System.out.println(max);\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.Scanner;\n\n\n\npublic class Ivan{\n\n\n\n  public static boolean check(long s,long n){\n\n    long big = 0;\n\n    long u = s;\n\n    while (s != 0){\n\n      long amari = s % 10;\n\n      big = big + s % 10;\n\n      s = (s - amari) / 10;\n\n    }\n\n    if (u - big >= n){\n\n      return true;\n\n    }else return false;\n\n  }\n\n  public static void main(String args[]){\n\n      Scanner scan = new Scanner(System.in);\n\n      long s = scan.nextLong();\n\n      long n = scan.nextLong();\n\n      long r =0;\n\n        if ( s > n){\n\n          for (long i = n;i<s+1;i++){\n\n          if (check(i,n)){\n\n            r=i;\n\n            break;\n\n          }else r = s+1;\n\n          }\n\n        System.out.print(s-r+1);\n\n      }else System.out.print(\"0\");\n\n  }\n\n}\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.util.Scanner;\n\n\npublic class f {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n\t\tHashtable<Long, Boolean> d = new Hashtable<Long, Boolean>();\n\t\tint n = in.nextInt(), k = in.nextInt(), size = 0, a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) a[i] = in.nextInt();\n\t\tArrays.sort(a);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong x = a[i];\n\t\t\tif (!d.containsKey(x)) {\n\t\t\t\td.put(x * k, true);\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(size);\n\t}\n\n}\n\n  \t \t\t   \t\t\t\t\t\t\t  \t\t \t  \t \t", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "import java.util.*;\n\npublic class test \n{  \n    public static void main(String[] args) \n    {\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        int t=in.nextInt();\n        \n        House[] houses=new House[n];\n        \n        for(int i=0;i<n;i++)\n        {\n            houses[i]=new House(in.nextInt(),in.nextInt());\n        }\n        \n        Arrays.sort(houses);\n        \n        int count=2;\n        \n        for(int i=0;i<n-1;i++)\n        {\n            double start=houses[i].x+(double)houses[i].a/2;\n            double end=houses[i+1].x-(double)houses[i+1].a/2;\n            \n            if(end-start==t)\n        \tcount++;\n            if(end-start>t)\n        \tcount+=2;\n        }\n        \n        System.out.println(count);\n \n    }\n}\n\nclass House implements Comparable<House>\n{\n    int x;\n    int a;\n    \n    public House(int _x, int _a)\n    {\n\tx=_x;\n\ta=_a;\n    }\n\n    @Override\n    public int compareTo(House o) {\n\treturn x-o.x;\n    }\n    \n}\n\n\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer; \n\t\t  \n\t\t\n\t\tpublic class temp4 {\n\t\t\tstatic class FastReader \n\t\t    { \n\t\t        BufferedReader br; \n\t\t        StringTokenizer st; \n\t\t  \n\t\t        public FastReader() \n\t\t        { \n\t\t            br = new BufferedReader(new\n\t\t                     InputStreamReader(System.in)); \n\t\t        } \n\t\t  \n\t\t        String next() \n\t\t        { \n\t\t            while (st == null || !st.hasMoreElements()) \n\t\t            { \n\t\t                try\n\t\t                { \n\t\t                    st = new StringTokenizer(br.readLine()); \n\t\t                } \n\t\t                catch (IOException  e) \n\t\t                { \n\t\t                    e.printStackTrace(); \n\t\t                } \n\t\t            } \n\t\t            return st.nextToken(); \n\t\t        } \n\t\t  \n\t\t        int nextInt() \n\t\t        { \n\t\t            return Integer.parseInt(next()); \n\t\t        } \n\t\t  \n\t\t        long nextLong() \n\t\t        { \n\t\t            return Long.parseLong(next()); \n\t\t        } \n\t\t  \n\t\t        double nextDouble() \n\t\t        { \n\t\t            return Double.parseDouble(next()); \n\t\t        } \n\t\t  \n\t\t        String nextLine() \n\t\t        { \n\t\t            String str = \"\"; \n\t\t            try\n\t\t            { \n\t\t                str = br.readLine(); \n\t\t            } \n\t\t            catch (IOException e) \n\t\t            { \n\t\t                e.printStackTrace(); \n\t\t            } \n\t\t            return str; \n\t\t        } \n\t\t    } \n\t\t\t\n\t\t/*\tstatic class Reader \n\t\t    { \n\t\t        final private int BUFFER_SIZE = 1 << 16; \n\t\t        private DataInputStream din; \n\t\t        private byte[] buffer; \n\t\t        private int bufferPointer, bytesRead; \n\t\t  \n\t\t        public Reader() \n\t\t        { \n\t\t            din = new DataInputStream(System.in); \n\t\t            buffer = new byte[BUFFER_SIZE]; \n\t\t            bufferPointer = bytesRead = 0; \n\t\t        } \n\t\t  \n\t\t        public Reader(String file_name) throws IOException \n\t\t        { \n\t\t            din = new DataInputStream(new FileInputStream(file_name)); \n\t\t            buffer = new byte[BUFFER_SIZE]; \n\t\t            bufferPointer = bytesRead = 0; \n\t\t        } \n\t\t  \n\t\t        public String readLine() throws IOException \n\t\t        { \n\t\t            byte[] buf = new byte[64]; // line length \n\t\t            int cnt = 0, c; \n\t\t            while ((c = read()) != -1) \n\t\t            { \n\t\t                if (c == '\\n') \n\t\t                    break; \n\t\t                buf[cnt++] = (byte) c; \n\t\t            } \n\t\t            return new String(buf, 0, cnt); \n\t\t        } \n\t\t  \n\t\t        public int nextInt() throws IOException \n\t\t        { \n\t\t            int ret = 0; \n\t\t            byte c = read(); \n\t\t            while (c <= ' ') \n\t\t                c = read(); \n\t\t            boolean neg = (c == '-'); \n\t\t            if (neg) \n\t\t                c = read(); \n\t\t            do\n\t\t            { \n\t\t                ret = ret * 10 + c - '0'; \n\t\t            }  while ((c = read()) >= '0' && c <= '9'); \n\t\t  \n\t\t            if (neg) \n\t\t                return -ret; \n\t\t            return ret; \n\t\t        } \n\t\t  \n\t\t        public long nextLong() throws IOException \n\t\t        { \n\t\t            long ret = 0; \n\t\t            byte c = read(); \n\t\t            while (c <= ' ') \n\t\t                c = read(); \n\t\t            boolean neg = (c == '-'); \n\t\t            if (neg) \n\t\t                c = read(); \n\t\t            do { \n\t\t                ret = ret * 10 + c - '0'; \n\t\t            } \n\t\t            while ((c = read()) >= '0' && c <= '9'); \n\t\t            if (neg) \n\t\t                return -ret; \n\t\t            return ret; \n\t\t        } \n\t\t  \n\t\t        public double nextDouble() throws IOException \n\t\t        { \n\t\t            double ret = 0, div = 1; \n\t\t            byte c = read(); \n\t\t            while (c <= ' ') \n\t\t                c = read(); \n\t\t            boolean neg = (c == '-'); \n\t\t            if (neg) \n\t\t                c = read(); \n\t\t  \n\t\t            do { \n\t\t                ret = ret * 10 + c - '0'; \n\t\t            } \n\t\t            while ((c = read()) >= '0' && c <= '9'); \n\t\t  \n\t\t            if (c == '.') \n\t\t            { \n\t\t                while ((c = read()) >= '0' && c <= '9') \n\t\t                { \n\t\t                    ret += (c - '0') / (div *= 10); \n\t\t                } \n\t\t            } \n\t\t  \n\t\t            if (neg) \n\t\t                return -ret; \n\t\t            return ret; \n\t\t        } \n\t\t  \n\t\t        private void fillBuffer() throws IOException \n\t\t        { \n\t\t            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t            if (bytesRead == -1) \n\t\t                buffer[0] = -1; \n\t\t        } \n\t\t  \n\t\t        private byte read() throws IOException \n\t\t        { \n\t\t            if (bufferPointer == bytesRead) \n\t\t                fillBuffer(); \n\t\t            return buffer[bufferPointer++]; \n\t\t        } \n\t\t  \n\t\t        public void close() throws IOException \n\t\t        { \n\t\t            if (din == null) \n\t\t                return; \n\t\t            din.close(); \n\t\t        } \n\t\t    } */\n\t\t\tstatic class Print\n\t\t{\n\t\t\t    private final BufferedWriter bw;\n\t\t\t    public Print()\n\t\t\t    {\n\t\t\t        bw=new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t\t    }\n\t\t    public void print(String str)throws IOException\n\t\t\t    {\n\t\t\t        bw.append(str);\n\t\t\t    }\n\t\t\t    public void println(String str)throws IOException\n\t\t\t    {\n\t\t\t        print(str);\n\t\t\t        bw.append(\"\\n\");\n\t\t\t    }\n\t\t\t    public void close()throws IOException\n\t\t\t    {\n\t\t\t        bw.close();\n\t\t\t    }} \n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\t\tpublic static void main(String[] args) throws IOException {\t\t\t\n\t\t\t\t\tFastReader scn=new FastReader();\n\t\t\t\t\tPrint pr=new Print();\n\t\t\t\t\tint n=scn.nextInt(),m=scn.nextInt();\n\t\t\t\t\tArrayList<Integer>[] gr=new ArrayList[n+1];\n\t\t\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\t\t\tgr[i]=new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t\tint[][] input=new int[m+1][3];\n\t\t\t\t\tint[] dfn=new int[n+1];\n\t\t\t\t\tint[] deg=new int[n+1];\n\t\t\t\t\n\t\t\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\t\t\tinput[i][0]=scn.nextInt();\n\t\t\t\t\t\tinput[i][1]=scn.nextInt();\n\t\t\t\t\t\tinput[i][2]=scn.nextInt();\n\t\t\t\t\t}\n\t\t\t\t\tint l=0,r=(int) 1e9;\n\t\t\t\t\twhile(l<r){\n\t\t\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\t\tif(sol(mid,input,gr,dfn,deg,n,m)>0) r=mid;\n\t\t\t\t\telse l=mid+1;\n\t\t\t\t\t}\n\t\t\t\t\tsol(l,input,gr,dfn,deg,n,m);\n\t\t\t\t\tArrayList<Integer> ans=new ArrayList<Integer>();\n\t\t\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\t\t\tif(dfn[input[i][1]]<dfn[input[i][0]])ans.add(i);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tpr.println(l+\" \"+ans.size());\n\t\t\t\t\tfor(Integer val:ans){\n\t\t\t\t\t\tpr.print(val+\" \");\n\t\t\t\t\t}\n\t\t\t\t\tpr.close();\n\t\t\t\t}\n\t\t\t\tpublic static int sol(int val,int[][] input,ArrayList<Integer>[] gr,int[] dfn,int[] deg,int n,int m){\n\t\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\t\tgr[i].clear();\n\t\t\t\t\t\tdfn[i]=0;deg[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\t\t\tif(input[i][2]>val){\n\t\t\t\t\t\t\tgr[input[i][0]].add(input[i][1]);\n\t\t\t\t\t\t\tdeg[input[i][1]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tQueue<Integer> q=new LinkedList<>();\n\t\t\t\t\tfor(int i=1;i<=n;i++)if(deg[i]==0)q.add(i);\n\t\t\t\t\tint count=0;\n\t\t\t\t\twhile(q.size()>0){\n\t\t\t\t\t\tint x=q.poll();\n\t\t\t\t\t\tdfn[x]=++count;\n\t\t\t\t\t\tfor(int i=0;i<gr[x].size();i++){\n\t\t\t\t\t\t\tdeg[gr[x].get(i)]--;\n\t\t\t\t\t\t\tif(deg[gr[x].get(i)]==0)q.add(gr[x].get(i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn count==n?1:0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tpublic static class node{\n\t\t\t\t\tint val;\n\t\t\t\t\tint idx;\n\t\t\t\t\tpublic node(int val,int idx){\n\t\t\t\t\t\tthis.val=val;this.idx=idx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\t", "complexity": "nlogn", "problem": "1100_E", "from": "CODEFORCES", "tags": "binary search,dfs and similar,graphs"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.math.BigInteger;\n\n\npublic class Main {\n\tpublic static int a[] = new int[200005];\n\tpublic static int b[] = new int[200005];\n\tpublic static int c[] = new int[200005];\n\tBigInteger x;\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint t,ca,i;\n\t\tString line = br.readLine();\n\t\tString[] my = myutils.allsub(line);\n\t   // System.out.println(Arrays.toString(my));\n\t    int ans = 0;\n\t    HashMap<String,Integer> data = new HashMap<String,Integer>();\n\t    for(i=0;i<my.length;i++)\n\t    {\n\t        if(data.get(my[i])==null)data.put(my[i],1);\n\t        else {\n\t            int fr = data.get(my[i]);\n\t            data.put(my[i],fr+1);\n\t        }\n\t    }\n\t    Iterator<Map.Entry<String,Integer>> iterator = data.entrySet().iterator();\n\t    while(iterator.hasNext())\n\t    {\n\t        int fr,len;\n\t        Map.Entry<String,Integer> cur =  iterator.next();\n\t        if(cur.getValue()>1){\n\t            String kk = cur.getKey();\n\t            if(kk.length()>ans)ans = kk.length();\n\t        }\n\t        \n\t    }\n\t    System.out.println(ans);\n\t}\n\n}\nclass myutils{\n    public static String[] allsub(String a)\n    {\n        int n = a.length();\n        String ans[] = new String[(n*(n+1))/2];\n        int i,j,in = 0;\n        for(i=0;i<n;i++)\n        for(j=i;j<n;j++)\n        ans[in++] = a.substring(i,j+1);\n        return ans;\n    }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            boolean[] isF = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                isF[i] = in.readCharacter() == 'f';\n            }\n            FenwickTree[] fenwickTrees = new FenwickTree[n + 1];\n            for (int i = 0; i < fenwickTrees.length; i++) {\n                fenwickTrees[i] = new FenwickTree(n + 1);\n            }\n            fenwickTrees[n].add(0, 1);\n            for (int idx = n - 1; idx >= 0; idx--) {\n                for (int indentLevel = 0; indentLevel < n; indentLevel++) {\n                    long fenwickRes;\n                    if (isF[idx]) {\n                        fenwickRes = fenwickTrees[idx + 1].get(indentLevel + 1, indentLevel + 1);\n                    } else {\n                        fenwickRes = fenwickTrees[idx + 1].get(0, indentLevel);\n                    }\n                    fenwickTrees[idx].add(indentLevel, fenwickRes % MiscUtils.MOD7);\n                }\n            }\n            out.printLine(fenwickTrees[0].get(0, 0));\n        }\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public char readCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n    }\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n    }\n    static class FenwickTree {\n        private final long[] value;\n\n        public FenwickTree(int size) {\n            value = new long[size];\n        }\n\n        public long get(int from, int to) {\n            return get(to) - get(from - 1);\n        }\n\n        private long get(int to) {\n            to = Math.min(to, value.length - 1);\n            long result = 0;\n            while (to >= 0) {\n                result += value[to];\n                to = (to & (to + 1)) - 1;\n            }\n            return result;\n        }\n\n        public void add(int at, long value) {\n            while (at < this.value.length) {\n                this.value[at] += value;\n                at = at | (at + 1);\n            }\n        }\n    }\n}\n\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        BigInteger x = sc.nextBigInteger();\n        BigInteger y = sc.nextBigInteger();\n\n\n        if(x.equals(y)){\n            System.out.println(0);\n            return;\n        }\n\n        // get 1st set bit position ||         // get the no of bits in the numbers\n        int firstSetBitPosX = 0;\n        int firstSetBitPosY = 0;\n        BigInteger tempX = x;\n        BigInteger tempY = y;\n        while(tempX.getLowestSetBit() != -1){\n            firstSetBitPosX++;\n            tempX = tempX.shiftRight(1);\n        }\n        while(tempY.getLowestSetBit() != -1){\n            firstSetBitPosY++;\n            tempY = tempY.shiftRight(1);\n        }\n\n\n        // flips between since 1st bit\n        int bitsToCheck = Math.max(firstSetBitPosX,firstSetBitPosY);\n        int firstDiffBit = firstSetBitPosY;\n        if(firstSetBitPosX == firstSetBitPosY){\n            //find the 1st diff bit pos;\n            while(x.getLowestSetBit() > -1){\n                int bitx = x.testBit(firstDiffBit) ? 1 : 0;\n                int bity = y.testBit(firstDiffBit) ? 1 : 0;\n                if(bitx == bity){\n                    firstDiffBit--;\n                }\n                else{\n                    bitsToCheck = firstDiffBit;\n                    break;\n                }\n            }\n        }\n        else{\n            bitsToCheck = firstDiffBit;\n        }\n        while(bitsToCheck-- > 0){\n            int bitX = x.testBit(bitsToCheck) ? 1 : 0;\n            int bitY = y.testBit(bitsToCheck) ? 1 : 0;\n            if((bitX ^ bitY ) != 1){\n                if(bitX == 0)\n                    x = x.flipBit(bitsToCheck);\n                else\n                    y = y.flipBit(bitsToCheck);\n            }\n        }\n        System.out.println(x.xor(y));\n\n\n\n    }\n}\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.List;\n import java.util.*;\n public class realfast implements Runnable \n  {\n    private static final int INF = (int) 1e9;\n    long in= 1000000007;\n    long fac[]= new long[1000001];\n    long inv[]=new long[1000001];\n    public  void solve() throws IOException \n    {\n\n        //int t = readInt();\n\n        int n = readInt();\n\n        long m  = readInt();\n\n        long method[][]=new long [n+1][n+1];\n\n        for(int i=0;i<=n;i++)\n        {\n            method[0][i]=1;\n            method[i][0]=1;\n        }\n\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=n;j++)\n            {\n                 for(int k=i;k>=0;k--)\n                 {\n                      method[i][j]= (method[i][j]%m+method[k][j-1]%m)%m;\n                 }\n            }\n        }\n         // index , total , cont\n        //long dp[][][]=new  long[n+2][n+2][n+2];\n        long sum[][]=new long[n+2][n+2];\n        sum[0][0]=1;\n      //  dp[0][0][0]=1;\n\n        long len[][]=new long[n+1][n+1];\n        for(int i=0;i<=n;i++)\n        {\n            len[i][0]=1;\n            len[0][i]=1;\n        }\n\n        for(int i=2;i<=n;i++)\n        {\n            for(int j=1;j<i;j++)\n            {\n                 len[j][i-j]= (len[j-1][i-j]%m+len[j][i-j-1]%m)%m;\n            }\n        }\n\n        long gal[]=new long[2*n+1];\n\n        for(int i=0;i<=n;i++)\n        {\n            for(int j=0;j<=n;j++)\n            {\n                gal[i+j]= (gal[i+j]+ len[i][j])%m; \n            }\n        }\n\n\n\n\n\n        for(int i=1;i<=n;i++)\n        {\n            if(i==n-1)\n                continue;\n            for(int j=1;j<=i;j++)\n            {\n                    \n                   for(int k=1;k<=j;k++)\n                   {\n                          \n                          \n                              long val =sum[i-k][j-k];\n                              val = (val*method[j-k][k])%m;\n                            \n                              val =(val*gal[k-1])%m;\n                              sum[i+1][j]= (sum[i+1][j]+val)%m;\n                          \n\n                   }\n            }\n        }\n\n        long ans =0;\n\n        for(int i=1;i<=n;i++)\n        {\n            ans = (ans + sum[n+1][i])%m;\n\n        }\n\n        out.println(ans);\n\n\n\n\n       \n\n    }\n    \n    public int value (int seg[], int left , int right ,int index, int l, int r)\n    {\n            \n            if(left>right)\n            {\n              return -100000000;\n            }\n            if(right<l||left>r)\n                return -100000000;\n            if(left>=l&&right<=r)\n                return seg[index];\n            int mid = left+(right-left)/2;\n            int val = value(seg,left,mid,2*index+1,l,r);\n            int val2 = value(seg,mid+1,right,2*index+2,l,r);\n            return Math.max(val,val2);\n\n    }\n   \n    public int gcd(int a , int b )\n    {\n      if(a<b)\n      {\n        int t =a;\n        a=b;\n        b=t;\n      }\n      if(a%b==0)\n        return b ;\n      return gcd(b,a%b);\n    }\n    public long pow(long n , long p,long m)\n    {\n         if(p==0)\n            return 1;\n        long val = pow(n,p/2,m);;\n        val= (val*val)%m;\n        if(p%2==0)\n            return val;\n        else\n            return (val*n)%m;\n    }\n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    public static void main(String[] args) {\n        new Thread(null, new realfast(), \"\", 128 * (1L << 20)).start();\n    }\n \n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private PrintWriter out;\n \n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(\"input.txt\").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            solve();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n \n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n \n    @SuppressWarnings(\"unused\")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n}\nclass edge implements Comparable<edge>{\n    int u ;\n    int v;\n    \n    edge(int u, int v)\n    {\n       this.u=u;\n       this.v=v;\n    }\n    public int compareTo(edge e)\n    {\n        return this.v-e.v;\n    }\n}", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.util.Scanner;\n\npublic class Main{\n    public static void main(String[] args){\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int a = in.nextInt();\n        int b = in.nextInt();\n        \n        int[] h = new int[3000];\n        \n        for(int i = 0; i<n; i++)\n            h[i] = in.nextInt();\n        \n        int l = 0, r = 1000000000, m = 0;\n        int ansl = 0, ansr = 0;\n        \n        while(l<=r){\n            m = (l+r)/2;\n            \n            int ca=0;\n            \n            for(int i = 0;i<n;i++)\n                if (h[i]>m) ca++;\n            \n            if (ca == a) ansl=m;\n            if (ca <= a) r=m-1; else l=m+1;\n        }\n        l = 0; r = 1000000000;\n        while(l<=r){\n            m = (l+r)/2;\n            \n            int ca=0;\n            \n            for(int i = 0;i<n;i++)\n                if (h[i]>m) ca++;\n            \n            if (ca == a) ansr=m;\n            if (ca < a) r=m-1; else l=m+1;\n        }\n        if (ansl == 0 || ansr==0) System.out.print(0); else\n        System.out.print(ansr-ansl+1);\n    }\n}", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main implements Runnable {\n\n    // ////////////////////////////////////////////////////\n    // Solution\n\n    private int n;\n    private int nn;\n    private int[][] D;\n    private int[] dp;\n    private int[] prev;\n\n    private void solve() throws Throwable {\n        int xs = nextInt(), ys = nextInt();\n        n = nextInt();\n        int[][] pts = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            pts[i][0] = nextInt();\n            pts[i][1] = nextInt();\n        }\n        D = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    D[i][i] = 2 * (sqr(pts[i][0] - xs) + sqr(pts[i][1] - ys));\n                } else {\n                    D[i][j] = sqr(pts[i][0] - xs) + sqr(pts[i][1] - ys)\n                            + sqr(pts[i][0] - pts[j][0])\n                            + sqr(pts[i][1] - pts[j][1]) + sqr(pts[j][0] - xs)\n                            + sqr(pts[j][1] - ys);\n                }\n            }\n        }\n        nn = 1 << n;\n        dp = new int[nn];\n        prev = new int[nn];\n        Arrays.fill(dp, -1);\n        Arrays.fill(prev, -1);\n        dp[0] = 0;\n        Dp(nn - 1);\n        pw.println(dp[nn - 1]);\n        pw.print(0);\n        for (int p = nn - 1; p != -1 && prev[p] != -1; p = prev[p]) {\n            int vv = p ^ prev[p];\n            for (int j = 0; j < n; j++) {\n                int jj = 1 << j;\n                if ((vv & jj) == 0)\n                    continue;\n                pw.print(' ');\n                pw.print(j + 1);\n            }\n            pw.print(\" 0\");\n        }\n        pw.println();\n    }\n\n    private int Dp(int i) {\n        if (dp[i] != -1)\n            return dp[i];\n        int ans = 107374182, p = -1;\n        int j1 = 1, pos1 = 0;\n        for (; pos1 < n && j1 < nn; j1 *= 2, pos1++) {\n            if ((i & j1) == 0)\n                continue;\n            int a = D[pos1][pos1] + Dp(i ^ j1);\n            if (a < ans) {\n                ans = a;\n                p = i ^ j1;\n            }\n            int j2 = j1 * 2, pos2 = pos1 + 1;\n            for (; pos2 < n && j2 < nn; j2 *= 2, pos2++) {\n                if ((i & j2) == 0)\n                    continue;\n                a = D[pos1][pos2] + Dp(i ^ (j1 | j2));\n                if (a < ans) {\n                    ans = a;\n                    p = i ^ (j1 | j2);\n                }\n            }\n            break;\n        }\n        dp[i] = ans;\n        prev[i] = p;\n        return ans;\n    }\n\n    private int sqr(int i) {\n        return i * i;\n    }\n\n    // ////////////////////////////////////////////////////\n    // Utility functions\n\n    private void initstreams() throws Throwable {\n        //System.setIn(new FileInputStream(\"1\"));\n        in = new BufferedReader(new InputStreamReader(System.in, \"ISO-8859-1\"));\n        pw = new PrintWriter(System.out);\n    }\n\n    BufferedReader in;\n    PrintWriter pw;\n    StringTokenizer st;\n\n    String nextString() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(nextString());\n    }\n\n    long nextLong() throws NumberFormatException, IOException {\n        return Long.parseLong(nextString());\n    }\n\n    double nextDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(nextString());\n    }\n\n    @Override\n    public void run() {\n        try {\n            initstreams();\n            solve();\n        } catch (Throwable e) {\n            sError = e;\n        } finally {\n            if (pw != null)\n                pw.close();\n        }\n    }\n\n    private static Throwable sError;\n\n    public static void main(String[] args) throws Throwable {\n        Thread t = new Thread(new Main());\n        t.start();\n        t.join();\n        if (sError != null)\n            throw sError;\n    }\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Div1_526C {\n\n\tstatic int nV;\n\n\tstatic ArrayList<Integer>[] chldn;\n\n\tstatic int root;\n\n\tstatic int[][] anc;\n\tstatic int[] depth;\n\n\tstatic int[] num;\n\n\tstatic int[] nLoc;\n\n\tstatic int[][] tree;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tnV = Integer.parseInt(reader.readLine());\n\n\t\tchldn = new ArrayList[nV];\n\t\tfor (int i = 0; i < nV; i++) {\n\t\t\tchldn[i] = new ArrayList<>();\n\t\t}\n\n\t\tanc = new int[nV][21];\n\t\tdepth = new int[nV];\n\n\t\tnum = new int[nV];\n\t\tnLoc = new int[nV];\n\t\ttree = new int[nV * 4][2];\n\t\tfor (int[] a : tree) {\n\t\t\ta[0] = a[1] = -1;\n\t\t}\n\n\t\troot = 0;\n\n\t\tStringTokenizer inputData = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0; i < nV; i++) {\n\t\t\tnum[i] = Integer.parseInt(inputData.nextToken());\n\t\t\tnLoc[num[i]] = i;\n\t\t}\n\n\t\tinputData = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 1; i < nV; i++) {\n\t\t\tanc[i][0] = Integer.parseInt(inputData.nextToken()) - 1;\n\t\t\tchldn[anc[i][0]].add(i);\n\t\t}\n\n\t\tpreprocess();\n\n\t\tbuild(1, 0, nV - 1);\n\n\t\tint nQ = Integer.parseInt(reader.readLine());\n\n\t\twhile (nQ-- > 0) {\n\t\t\tinputData = new StringTokenizer(reader.readLine());\n\t\t\tif (inputData.nextToken().equals(\"1\")) {\n\t\t\t\tint a = Integer.parseInt(inputData.nextToken()) - 1;\n\t\t\t\tint b = Integer.parseInt(inputData.nextToken()) - 1;\n\n\t\t\t\tint temp = num[a];\n\t\t\t\tnum[a] = num[b];\n\t\t\t\tnum[b] = temp;\n\n\t\t\t\tnLoc[num[a]] = a;\n\t\t\t\tnLoc[num[b]] = b;\n\n\t\t\t\tupdate(1, 0, nV - 1, num[a]);\n\t\t\t\tupdate(1, 0, nV - 1, num[b]);\n\t\t\t} else {\n\t\t\t\tprinter.println(query(1, 0, nV - 1, nLoc[0], nLoc[0]) + 1);\n\t\t\t}\n\t\t}\n\t\tprinter.close();\n\t}\n\n\tstatic void build(int nI, int cL, int cR) {\n\t\tif (cL == cR) {\n\t\t\ttree[nI][0] = nLoc[cL];\n\t\t\ttree[nI][1] = nLoc[cL];\n\t\t} else {\n\t\t\tint mid = (cL + cR) >> 1;\n\t\t\tbuild(nI * 2, cL, mid);\n\t\t\tbuild(nI * 2 + 1, mid + 1, cR);\n\t\t\tif (tree[nI * 2][0] != -1 && tree[nI * 2 + 1][0] != -1) {\n\t\t\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], tree[nI * 2 + 1][0], tree[nI * 2 + 1][1]);\n\t\t\t\ttree[nI][0] = mResp[0];\n\t\t\t\ttree[nI][1] = mResp[1];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int query(int nI, int cL, int cR, int e1, int e2) {\n\t\tif (cL == cR) {\n\t\t\tmerge(e1, e2, nLoc[cL], nLoc[cL]);\n\t\t\tif (mResp[0] != -1) {\n\t\t\t\treturn cL;\n\t\t\t} else {\n\t\t\t\treturn cL - 1;\n\t\t\t}\n\t\t}\n\t\tint mid = (cL + cR) >> 1;\n\n\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], e1, e2);\n\t\tif (mResp[0] != -1) {\n\t\t\treturn query(nI * 2 + 1, mid + 1, cR, mResp[0], mResp[1]);\n\t\t}\n\t\treturn query(nI * 2, cL, mid, e1, e2);\n\t}\n\n\tstatic void update(int nI, int cL, int cR, int uI) {\n\t\tif (cL == cR) {\n\t\t\ttree[nI][0] = nLoc[cL];\n\t\t\ttree[nI][1] = nLoc[cL];\n\t\t} else {\n\t\t\tint mid = (cL + cR) >> 1;\n\t\t\tif (uI <= mid) {\n\t\t\t\tupdate(nI * 2, cL, mid, uI);\n\t\t\t} else {\n\t\t\t\tupdate(nI * 2 + 1, mid + 1, cR, uI);\n\t\t\t}\n\t\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], tree[nI * 2 + 1][0], tree[nI * 2 + 1][1]);\n\t\t\ttree[nI][0] = mResp[0];\n\t\t\ttree[nI][1] = mResp[1];\n\t\t}\n\t}\n\n\tstatic int[] mResp = new int[2];\n\n\tstatic void merge1(int... a) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (a[i] == -1) {\n\t\t\t\tmResp[0] = mResp[1] = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (onPath(a[0], a[1], a[2])) {\n\t\t\tmResp[0] = a[0];\n\t\t\tmResp[1] = a[1];\n\t\t\treturn;\n\t\t}\n\t\tif (onPath(a[0], a[2], a[1])) {\n\t\t\tmResp[0] = a[0];\n\t\t\tmResp[1] = a[2];\n\t\t\treturn;\n\t\t}\n\t\tif (onPath(a[1], a[2], a[0])) {\n\t\t\tmResp[0] = a[1];\n\t\t\tmResp[1] = a[2];\n\t\t\treturn;\n\t\t}\n\t\tmResp[0] = mResp[1] = -1;\n\t}\n\n\tstatic void merge(int... a) {\n\t\tmerge1(a[0], a[1], a[2]);\n\t\tmerge1(mResp[0], mResp[1], a[3]);\n\t}\n\n\tstatic boolean onPath(int a, int b, int c) {\n\t\tif (a == c || b == c) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (depth[a] > depth[c]) {\n\t\t\ta = jump(a, depth[a] - depth[c] - 1);\n\t\t}\n\t\tif (depth[b] > depth[c]) {\n\t\t\tb = jump(b, depth[b] - depth[c] - 1);\n\t\t}\n\t\tif (a == b) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (anc[a][0] == c || anc[b][0] == c) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// good for depth of up to 1_048_576 = 2^20\n\n\tstatic void preprocess() {\n\t\tanc[root][0] = root;\n\t\tfParent(root);\n\n\t\tfor (int k = 1; k <= 20; k++) {\n\t\t\tfor (int i = 0; i < nV; i++) {\n\t\t\t\tanc[i][k] = anc[anc[i][k - 1]][k - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void fParent(int cV) {\n\t\tfor (int aV : chldn[cV]) {\n\t\t\tanc[aV][0] = cV;\n\t\t\tdepth[aV] = depth[cV] + 1;\n\t\t\tfParent(aV);\n\t\t}\n\t}\n\n\tstatic int fLCA(int a, int b) {\n\t\tif (depth[a] > depth[b]) {\n\t\t\tint temp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\t\tb = jump(b, depth[b] - depth[a]);\n\t\tif (a == b) {\n\t\t\treturn a;\n\t\t}\n\t\tfor (int i = 20; i >= 0; i--) {\n\t\t\tif (anc[a][i] != anc[b][i]) {\n\t\t\t\ta = anc[a][i];\n\t\t\t\tb = anc[b][i];\n\t\t\t}\n\t\t}\n\t\treturn anc[a][0];\n\t}\n\n\tstatic int jump(int cV, int d) {\n\t\tfor (int i = 0; i <= 20; i++) {\n\t\t\tif ((d & (1 << i)) != 0) {\n\t\t\t\tcV = anc[cV][i];\n\t\t\t}\n\t\t}\n\t\treturn cV;\n\t}\n\n\tstatic Comparator<Integer> BY_DEPTH = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn -Integer.compare(depth[o1], depth[o2]); // greatest depth first\n\t\t}\n\t};\n}", "complexity": "nlogn", "problem": "1084_F", "from": "CODEFORCES", "tags": "data structures,trees"}
{"src": "import com.sun.org.apache.xerces.internal.util.SynchronizedSymbolTable;\nimport jdk.management.cmm.SystemResourcePressureMXBean;\n\nimport java.awt.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.List;\nimport java.math.*;\n\npublic class Newbie {\n\n    static InputReader sc = new InputReader(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        solver s = new solver();\n        int t = 1;\n        while (t > 0) {\n            s.solve();\n            t--;\n        }\n        out.close();\n    }\n\n   /* static class descend implements Comparator<pair1> {\n        public int compare(pair1 o1, pair1 o2) {\n            if (o1.pop != o2.pop)\n                return (int) (o1.pop - o2.pop);\n            else\n                return o1.in - o2.in;\n        }\n    }*/\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n            token = null;\n        }\n\n        public String next() {\n            while (token == null || !token.hasMoreTokens()) {\n                try {\n                    token = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class card {\n        long a;\n        int cnt;\n        int i;\n\n        public card(long a, int cnt, int i) {\n            this.a = a;\n            this.cnt = cnt;\n            this.i = i;\n        }\n    }\n\n    static class ascend implements Comparator<pair> {\n        public int compare(pair o1, pair o2) {\n            return o1.a - o2.a;\n        }\n    }\n\n    static class extra {\n\n        static boolean v[] = new boolean[100001];\n        static List<Integer> l = new ArrayList<>();\n        static int t;\n\n        static void shuffle(long a[]) {\n            List<Long> l = new ArrayList<>();\n            for (int i = 0; i < a.length; i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for (int i = 0; i < a.length; i++)\n                a[i] = l.get(i);\n        }\n\n        static long gcd(long a, long b) {\n            if (b == 0)\n                return a;\n            else\n                return gcd(b, a % b);\n        }\n\n        static boolean valid(int i, int j, int r, int c) {\n            if (i >= 0 && i < r && j >= 0 && j < c)\n                return true;\n            else\n                return false;\n        }\n\n        static void seive() {\n            for (int i = 2; i < 100001; i++) {\n                if (!v[i]) {\n                    t++;\n                    l.add(i);\n                    for (int j = 2 * i; j < 100001; j += i)\n                        v[j] = true;\n                }\n            }\n        }\n\n        static int binary(long a[], long val, int n) {\n            int mid = 0, l = 0, r = n - 1, ans = 0;\n            while (l <= r) {\n                mid = (l + r) >> 1;\n                if (a[mid] == val) {\n                    r = mid - 1;\n                    ans = mid;\n                } else if (a[mid] > val)\n                    r = mid - 1;\n                else {\n                    l = mid + 1;\n                    ans = l;\n                }\n            }\n            return (ans + 1);\n        }\n\n        static long fastexpo(int x, int y) {\n            long res = 1;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res *= x;\n                }\n                y = y >> 1;\n                x = x * x;\n            }\n            return res;\n        }\n\n        static long lfastexpo(int x, int y, int p) {\n            long res = 1;\n            x = x % p;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res = (res * x) % p;\n                }\n                y = y >> 1;\n                x = (x * x) % p;\n            }\n            return res;\n        }\n    }\n\n    static class pair {\n        int a;\n        int b;\n\n        public pair(int a, int i) {\n            this.a = a;\n            this.b = i;\n        }\n    }\n\n    static class pair1 {\n        pair p;\n        int in;\n\n        public pair1(pair a, int n) {\n            this.p = a;\n            this.in = n;\n        }\n    }\n\n    static long m = (long) 1e9 + 7;\n\n    static class solver {\n        void solve() {\n            int n = sc.nextInt();\n            int ans=0;\n            int a[]=new int[2*n];\n            for (int i = 0; i < 2 * n; i++) {\n               a[i]=sc.nextInt();\n            }\n            for(int i=0;i<2*n;i++)\n            {\n                if(a[i]>0)\n                {\n                    int j=0;\n                    for(j=i+1;a[i]!=a[j];j++)\n                    {\n                        if(a[j]>0)\n                            ans++;\n                    }\n                    a[j]=0;\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n}", "complexity": "quadratic", "problem": "0995_B", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class A\n{\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i;\n        long N,K;\n\n        String s[]=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        K=Integer.parseInt(s[1]);\n\n        long count=0;\n\n        long tmp=2*N;\n        count+=tmp/K;\n        tmp%=K;\n\n        if(tmp>0)\n            count++;\n\n\n        tmp=5*N;\n        count+=tmp/K;\n\n        tmp%=K;\n\n        if(tmp>0)\n            count++;\n\n        tmp=8*N;\n        count+=tmp/K;\n\n        tmp%=K;\n\n        if(tmp>0)\n            count++;\n\n        System.out.println(count);\n    }\n}", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "//package deltix2021;\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class C {\n\tInputStream is;\n\tFastWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tfor(int T = ni();T > 0;T--)go();\n\t}\n\n\tvoid go()\n\t{\n\t\tint n = ni();\n\t\tint[] st = new int[n];\n\t\tint sp = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint x = ni();\n\t\t\tif(x == 1){\n\t\t\t\tst[sp++] = 1;\n\t\t\t}else{\n\t\t\t\twhile(sp > 0){\n\t\t\t\t\tif(st[sp-1] + 1 == x){\n\t\t\t\t\t\tst[sp-1]++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsp--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < sp;j++){\n\t\t\t\tif(j > 0)out.print(\".\");\n\t\t\t\tout.print(st[j]);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new FastWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new C().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic static class FastWriter\n\t{\n\t\tprivate static final int BUF_SIZE = 1<<13;\n\t\tprivate final byte[] buf = new byte[BUF_SIZE];\n\t\tprivate final OutputStream out;\n\t\tprivate int ptr = 0;\n\n\t\tprivate FastWriter(){out = null;}\n\n\t\tpublic FastWriter(OutputStream os)\n\t\t{\n\t\t\tthis.out = os;\n\t\t}\n\n\t\tpublic FastWriter(String path)\n\t\t{\n\t\t\ttry {\n\t\t\t\tthis.out = new FileOutputStream(path);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"FastWriter\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter write(byte b)\n\t\t{\n\t\t\tbuf[ptr++] = b;\n\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(char c)\n\t\t{\n\t\t\treturn write((byte)c);\n\t\t}\n\n\t\tpublic FastWriter write(char[] s)\n\t\t{\n\t\t\tfor(char c : s){\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(String s)\n\t\t{\n\t\t\ts.chars().forEach(c -> {\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(int l) {\n\t\t\tif (l >= 1000000000) return 10;\n\t\t\tif (l >= 100000000) return 9;\n\t\t\tif (l >= 10000000) return 8;\n\t\t\tif (l >= 1000000) return 7;\n\t\t\tif (l >= 100000) return 6;\n\t\t\tif (l >= 10000) return 5;\n\t\t\tif (l >= 1000) return 4;\n\t\t\tif (l >= 100) return 3;\n\t\t\tif (l >= 10) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(int x)\n\t\t{\n\t\t\tif(x == Integer.MIN_VALUE){\n\t\t\t\treturn write((long)x);\n\t\t\t}\n\t\t\tif(ptr + 12 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(long l) {\n\t\t\tif (l >= 1000000000000000000L) return 19;\n\t\t\tif (l >= 100000000000000000L) return 18;\n\t\t\tif (l >= 10000000000000000L) return 17;\n\t\t\tif (l >= 1000000000000000L) return 16;\n\t\t\tif (l >= 100000000000000L) return 15;\n\t\t\tif (l >= 10000000000000L) return 14;\n\t\t\tif (l >= 1000000000000L) return 13;\n\t\t\tif (l >= 100000000000L) return 12;\n\t\t\tif (l >= 10000000000L) return 11;\n\t\t\tif (l >= 1000000000L) return 10;\n\t\t\tif (l >= 100000000L) return 9;\n\t\t\tif (l >= 10000000L) return 8;\n\t\t\tif (l >= 1000000L) return 7;\n\t\t\tif (l >= 100000L) return 6;\n\t\t\tif (l >= 10000L) return 5;\n\t\t\tif (l >= 1000L) return 4;\n\t\t\tif (l >= 100L) return 3;\n\t\t\tif (l >= 10L) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(long x)\n\t\t{\n\t\t\tif(x == Long.MIN_VALUE){\n\t\t\t\treturn write(\"\" + x);\n\t\t\t}\n\t\t\tif(ptr + 21 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(double x, int precision)\n\t\t{\n\t\t\tif(x < 0){\n\t\t\t\twrite('-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tx += Math.pow(10, -precision)/2;\n\t\t\t//\t\tif(x < 0){ x = 0; }\n\t\t\twrite((long)x).write(\".\");\n\t\t\tx -= (long)x;\n\t\t\tfor(int i = 0;i < precision;i++){\n\t\t\t\tx *= 10;\n\t\t\t\twrite((char)('0'+(int)x));\n\t\t\t\tx -= (int)x;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(char c){\n\t\t\treturn write(c).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(int x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(double x, int precision){\n\t\t\treturn write(x, precision).writeln();\n\t\t}\n\n\t\tpublic FastWriter write(int... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(int x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(long... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(long x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln()\n\t\t{\n\t\t\treturn write((byte)'\\n');\n\t\t}\n\n\t\tpublic FastWriter writeln(int... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[] line)\n\t\t{\n\t\t\treturn write(line).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[]... map)\n\t\t{\n\t\t\tfor(char[] line : map)write(line).writeln();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(String s)\n\t\t{\n\t\t\treturn write(s).writeln();\n\t\t}\n\n\t\tprivate void innerflush()\n\t\t{\n\t\t\ttry {\n\t\t\t\tout.write(buf, 0, ptr);\n\t\t\t\tptr = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"innerflush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic void flush()\n\t\t{\n\t\t\tinnerflush();\n\t\t\ttry {\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"flush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter print(byte b) { return write(b); }\n\t\tpublic FastWriter print(char c) { return write(c); }\n\t\tpublic FastWriter print(char[] s) { return write(s); }\n\t\tpublic FastWriter print(String s) { return write(s); }\n\t\tpublic FastWriter print(int x) { return write(x); }\n\t\tpublic FastWriter print(long x) { return write(x); }\n\t\tpublic FastWriter print(double x, int precision) { return write(x, precision); }\n\t\tpublic FastWriter println(char c){ return writeln(c); }\n\t\tpublic FastWriter println(int x){ return writeln(x); }\n\t\tpublic FastWriter println(long x){ return writeln(x); }\n\t\tpublic FastWriter println(double x, int precision){ return writeln(x, precision); }\n\t\tpublic FastWriter print(int... xs) { return write(xs); }\n\t\tpublic FastWriter print(long... xs) { return write(xs); }\n\t\tpublic FastWriter println(int... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(long... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(char[] line) { return writeln(line); }\n\t\tpublic FastWriter println(char[]... map) { return writeln(map); }\n\t\tpublic FastWriter println(String s) { return writeln(s); }\n\t\tpublic FastWriter println() { return writeln(); }\n\t}\n\n\tpublic void trnz(int... o)\n\t{\n\t\tfor(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+\":\"+o[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n\t// print ids which are 1\n\tpublic void trt(long... o)\n\t{\n\t\tQueue<Integer> stands = new ArrayDeque<>();\n\t\tfor(int i = 0;i < o.length;i++){\n\t\t\tfor(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n\t\t}\n\t\tSystem.out.println(stands);\n\t}\n\n\tpublic void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(long[]... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long[] r : b) {\n\t\t\t\tfor (long x : r) {\n\t\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic void tf(long... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long x : b) {\n\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "// Author : RegalBeast\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n  static final FastReader FR = new FastReader();\n  static final BufferedWriter BW = new BufferedWriter(new OutputStreamWriter(System.out));\n\n  public static void main(String[] args) throws IOException {\n    StringBuilder solution = new StringBuilder();\n    int rows = FR.nextInt();\n    int cols = FR.nextInt();\n    int moves = FR.nextInt();\n\n    Map<Integer, Integer> horizontalEdgeWeights = new HashMap<Integer, Integer>();\n    for (int r = 0; r < rows; r++) {\n      for (int c = 0; c < cols - 1; c++) {\n        int hash = getHash(r, c);\n        horizontalEdgeWeights.put(hash, FR.nextInt());\n      }\n    }\n\n    Map<Integer, Integer> verticalEdgeWeights = new HashMap<Integer, Integer>();\n    for (int r = 0; r < rows - 1; r++) {\n      for (int c = 0; c < cols; c++) {\n        int hash = getHash(r, c);\n        verticalEdgeWeights.put(hash, FR.nextInt());\n      }\n    }\n    \n    List<List<Integer>> result = getResult(rows, cols, moves, horizontalEdgeWeights, verticalEdgeWeights);\n    for (int r = 0; r < rows; r++) {\n      for (int c = 0; c < cols; c++) {\n        int value = (result != null ? result.get(r).get(c) : -1);\n        solution.append(value + \" \");\n      }\n      solution.append(\"\\n\");\n    }\n\n\t\tBW.write(solution.toString());\n    BW.close();\n  }\n\n  static List<List<Integer>> getResult(int rows, int cols, int moves, Map<Integer, Integer> horizontalEdgeWeights, Map<Integer, Integer> verticalEdgeWeights) {\n    if ((moves & 1) == 1) {\n      return null;\n    }\n\n    int mid = moves >> 1;\n    List<List<List<Integer>>> minForDistance = new ArrayList<List<List<Integer>>>(rows);\n    for (int r = 0; r < rows; r++) {\n      minForDistance.add(new ArrayList<List<Integer>>(cols));\n\n      for (int c = 0; c < cols; c++) {\n        minForDistance.get(r).add(new ArrayList<Integer>(Collections.nCopies(mid+1, Integer.MAX_VALUE)));\n        minForDistance.get(r).get(c).set(0, 0);\n      }\n    }\n\n    for (int m = 1; m <= mid; m++) {\n      for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n          int minBoredom = minForDistance.get(r).get(c).get(m);\n          int hash = getHash(r, c);\n\n          if (r > 0) {\n            if (minForDistance.get(r-1).get(c).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r-1).get(c).get(m-1) + verticalEdgeWeights.get(getHash(r-1, c));\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n\n          if (c > 0) {\n            if (minForDistance.get(r).get(c-1).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r).get(c-1).get(m-1) + horizontalEdgeWeights.get(getHash(r, c-1));\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n          \n          if (r + 1 < rows) {\n            if (minForDistance.get(r+1).get(c).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r+1).get(c).get(m-1) + verticalEdgeWeights.get(hash);\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n   \n          if (c + 1 < cols) {\n            if (minForDistance.get(r).get(c+1).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r).get(c+1).get(m-1) + horizontalEdgeWeights.get(hash);\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n\n          minForDistance.get(r).get(c).set(m, minBoredom);\n        }\n      }\n    }\n\n    List<List<Integer>> result = new ArrayList<List<Integer>>(rows);\n    for (int r = 0; r < rows; r++) {\n      result.add(new ArrayList<Integer>(cols));\n\n      for (int c = 0; c < cols; c++) {\n        result.get(r).add(minForDistance.get(r).get(c).get(mid) << 1);\n      }\n    }\n\n    return result;\n  }\n\n  static int getHash(int row, int col) {\n    return (row * 1000 + col);\n  }\n  static int getRow(int hash) {\n    return hash / 1000;\n  }\n  static int getCol(int hash) {\n    return hash % 1000;\n  }\n\n  static class FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n      br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n      while (st == null || !st.hasMoreElements()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        } catch (IOException  e) {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n      String str = \"\";\n      try {\n        str = br.readLine();\n      } catch (IOException e)  {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "\n\n\nimport static java.util.Arrays.*;\n\nimport java.io.*;\nimport java.lang.reflect.*;\nimport java.util.*;\n\npublic class A {\n\n\tfinal int MOD = (int)1e9 + 7;\n\tfinal double eps = 1e-12;\n\tfinal int INF = (int)1e9;\n\t\n\tpublic A () {\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tLong [] A = sc.nextLongs();\n\n\t\tsort(A);\n\t\tTreeSet<Long> S = new TreeSet<Long>();\n\t\t\n\t\tfor (long a : A) {\n\t\t\tif (a % K == 0 && S.contains(a/K))\n\t\t\t\tcontinue;\n\t\t\tS.add(a);\n\t\t}\n\t\t\n\t\tint res = S.size();\n\t\texit(res);\n\t}\n\n\t////////////////////////////////////////////////////////////////////////////////////\n\n\t/* Dear hacker, don't bother reading below this line, unless you want to help me debug my I/O routines :-) */\n\t\n\tstatic MyScanner sc = new MyScanner();\n\t\n\tstatic class MyScanner {\n\t\tpublic String next() {\n\t\t\tnewLine();\n\t\t\treturn line[index++];\n\t\t}\n\t\t\n\t\tpublic char nextChar() {\n\t\t\treturn next().charAt(0);\n\t\t}\n\t\t\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic String nextLine() {\n\t\t\tline = null;\n\t\t\treturn readLine();\n\t\t}\n\t\t\n\t\tpublic String [] nextStrings() {\n\t\t\tline = null;\n\t\t\treturn readLine().split(\" \");\n\t\t}\n\t\t\n\t\tpublic char [] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic Integer [] nextInts() {\n\t\t\tString [] L = nextStrings();\n\t\t\tInteger [] res = new Integer [L.length];\n\t\t\tfor (int i = 0; i < L.length; ++i)\n\t\t\t\tres[i] = Integer.parseInt(L[i]);\n\t\t\treturn res;\n\t\t}\t\n\t\t\n\t\tpublic Long [] nextLongs() {\n\t\t\tString [] L = nextStrings();\n\t\t\tLong [] res = new Long [L.length];\n\t\t\tfor (int i = 0; i < L.length; ++i)\n\t\t\t\tres[i] = Long.parseLong(L[i]);\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic Double [] nextDoubles() {\n\t\t\tString [] L = nextStrings();\n\t\t\tDouble [] res = new Double [L.length];\n\t\t\tfor (int i = 0; i < L.length; ++i)\n\t\t\t\tres[i] = Double.parseDouble(L[i]);\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic String [] next (int N) {\n\t\t\tString [] res = new String [N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tres[i] = sc.next();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tpublic Integer [] nextInt (int N) {\n\t\t\tInteger [] res = new Integer [N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tres[i] = sc.nextInt();\n\t\t\treturn res;\n\t\t}\t\t\n\t\t\n\t\tpublic Long [] nextLong (int N) {\n\t\t\tLong [] res = new Long [N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tres[i] = sc.nextLong();\n\t\t\treturn res;\n\t\t}\t\t\n\t\t\n\t\tpublic Double [] nextDouble (int N) {\n\t\t\tDouble [] res = new Double [N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tres[i] = sc.nextDouble();\n\t\t\treturn res;\n\t\t}\t\t\n\t\t\n\t\tpublic String [][] nextStrings (int N) {\n\t\t\tString [][] res = new String [N][];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tres[i] = sc.nextStrings();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tpublic Integer [][] nextInts (int N) {\n\t\t\tInteger [][] res = new Integer [N][];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tres[i] = sc.nextInts();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tpublic Long [][] nextLongs (int N) {\n\t\t\tLong [][] res = new Long [N][];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tres[i] = sc.nextLongs();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tpublic Double [][] nextDoubles (int N) {\n\t\t\tDouble [][] res = new Double [N][];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tres[i] = sc.nextDoubles();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////\n\t\t\n\t\tprivate boolean eol() {\n\t\t\treturn index == line.length;\n\t\t}\n\n\t\tprivate String readLine() {\n\t\t\ttry {\n\t\t\t\treturn r.readLine();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\n\t\tprivate final BufferedReader r;\n\n\t\tMyScanner () {\n\t\t\tthis(new BufferedReader(new InputStreamReader(System.in)));\n\t\t}\n\t\t\n\t\tMyScanner(BufferedReader r) {\n\t\t\ttry {\n\t\t\t\tthis.r = r;\n\t\t\t\twhile (!r.ready())\n\t\t\t\t\tThread.sleep(1);\n\t\t\t\tstart();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate String [] line;\n\t\tprivate int index;\n\n\t\tprivate void newLine() {\n\t\t\tif (line == null || eol()) {\n\t\t\t\tline = readLine().split(\" \");\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\tstatic void print(Object o, Object... a) {\n\t\tprintDelim(\" \", o, a);\n\t}\n\t\n\tstatic void cprint(Object o, Object... a) {\n\t\tprintDelim(\"\", o, a);\n\t}\n\t\n\tstatic void printDelim (String delim, Object o, Object... a) {\n\t\tpw.println(build(delim, o, a));\n\t}\n\n\tstatic void exit (Object o, Object... a) {\n\t\tprint(o, a);\n\t\texit();\n\t}\n\n\tstatic void exit () {\n\t\tpw.close();\n\t\tSystem.out.flush();\n\t\tSystem.err.println(\"------------------\");\n\t\tSystem.err.println(\"Time: \" + ((millis() - t) / 1000.0));\n\t\tSystem.exit(0);\n\t}\n\t\n\tvoid NO() {\n\t\tthrow new Error(\"NO!\");\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////////\n\t\n\tstatic String build(String delim, Object o, Object... a) {\n\t\tStringBuilder b = new StringBuilder();\n\t\tappend(b, o, delim);\n\t\tfor (Object p : a)\n\t\t\tappend(b, p, delim);\n\t\treturn b.toString().trim();\t\t\n\t}\n\t\n\tstatic void append(StringBuilder b, Object o, String delim) {\n\t\tif (o.getClass().isArray()) {\n\t\t\tint L = Array.getLength(o);\n\t\t\tfor (int i = 0; i < L; ++i)\n\t\t\t\tappend(b, Array.get(o, i), delim);\n\t\t} else if (o instanceof Iterable<?>) {\n\t\t\tfor (Object p : (Iterable<?>)o)\n\t\t\t\tappend(b, p, delim);\n\t\t} else\n\t\t\tb.append(delim).append(o);\t\t\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////////\n\t\n\tpublic static void main(String[] args) {\n\t\tnew A();\n\t\texit();\n\t}\n\n\tstatic void start() {\n\t\tt = millis();\n\t}\n\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n\t\n\tstatic long t;\n\t\n\tstatic long millis() {\n\t\treturn System.currentTimeMillis();\n\t}\t\n}\n", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tSystem.out.println(input.nextInt() / 2 + 1);\n\t}\n}", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.Scanner;\n\npublic class DarkAssembly {\n\tstatic int n, A;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tA = sc.nextInt();\n\t\t\n\t\tint[][] sen = new int[n][2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsen[i][0] = sc.nextInt();\n\t\t\tsen[i][1] = sc.nextInt();\n\t\t}\n\t\t\n\t\t//Simple:\n\t\tsen = sort(sen);\n\t\tint tmp = k, cnt = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint canTake = (100-sen[i][1])/10;\n\t\t\tif (canTake <= tmp) {tmp-=canTake; cnt++;}\n\t\t}\n\t\t\n\t\tif (cnt > n/2) {System.out.println(1); return;}\n\t\t\n\t\t//Less simple\n\t\tSystem.out.println(distribute(0, k, sen));\n\t}\n\t\n\tprivate static double distribute(int id, int k, int[][] sen) {\n\t\tif (id < n) {//distribute\n\t\t\tdouble max = 0;\t\t\t\n\t\t\tfor (int i=0;i<=k;i++) {\n\t\t\t\t\tsen[id][1]+=10*i;\n\t\t\t\t\tmax = Math.max(max, distribute(id+1, k-i,sen));\n\t\t\t\t\tsen[id][1]-=10*i;\n\t\t\t}\n\n\t\t\treturn max;\n\t\t}\n\t\telse return compute(sen);\n\t\t\n\t}\n\t\n\tprivate static double compute(int[][] sen) {\n\t\tdouble rez = 0;\n\t\t\n\t\tint dist = 1<<n;\n\t\tfor (int i = 0; i < dist; i++) {\n\t\t\tdouble p = 1;\n\t\t\tint B = 0, cnt = 0;\n\t\t\tfor (int j = 0; j < n; j++) { \n\t\t\t\tdouble sL = Math.min(sen[j][1]/100.0, 1);  \n\t\t\t\tif ((i & (1<<j)) == 1<<j) { //yes \n\t\t\t\t\tp *= sL;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\telse { //no\n\t\t\t\t\tB+=sen[j][0];\n\t\t\t\t\tp *= (1-sL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt <= n/2) p *= (double) A/(A+B);\n\t\t\trez +=p;\n\t\t}\n\t\treturn rez;\n\t}\n\t\n\tprivate static int[][] sort(int[][] sen) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint[] min = sen[i];\n\t\t\tint minI = i;\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tif (sen[j][1] > min[1]) {\n\t\t\t\t\tminI = j;\n\t\t\t\t\tmin = sen[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] tmp = sen[i];\n\t\t\tsen[i] = min;\n\t\t\tsen[minI] = tmp;\n\t\t}\n\t\t\n\t\treturn sen;\n\t}\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n// Jonathan\n// cpt_fwiffo\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = in.readLine().split(\" \");\n        int Xs = Integer.parseInt(line[0]);\n        int Ys = Integer.parseInt(line[1]);\n        int n = Integer.parseInt(in.readLine());\n        \n        int[][] points = new int[n+1][2];\n        points[n][0] = Xs;//set starting point as last point for finding distances\n        points[n][1] = Ys;\n        \n        for(int i=0; i< n ; i++)\n        {\n            line = in.readLine().split(\" \");\n            points[i][0] = Integer.parseInt(line[0]);\n            points[i][1] = Integer.parseInt(line[1]);\n        }\n        \n        \n        int[][] distances = new int[n+1][n+1];\n        ComputeDistances(points, distances, n);\n        \n        int[] dp = new int[1<<n];\n        int[] path = new int[1<<n];\n        ComputeLowestPath(dp, path, distances, n);\n        OutputLowestAndPath(dp, path, n);\n        \n    }\n    \n    \n\n    private static void ComputeLowestPath(int[] dp, int[] path, int[][] distances, int n)\n    {\n        for(int i = 1; i < 1<<n; i++)\n        {\n            int j = 0;\n            while(true) //find first 1 (LSB)\n            {\n                if((i&(1<<j))!=0) //check for a bit equal to 1 in location j\n                {\n                    break;\n                }\n                j++;\n            }\n            \n            int pastEntry = i & ~(1<<j); //remove first 1 from i\n            path[i] = pastEntry; //set the path we came from to trace later\n            int distance = distances[j][n] * 2; //distance from origin to the point being removed, and back\n            dp[i] = dp[pastEntry] + distance; //set minimum distance if just this point is added to the collection\n            \n            for(int m = j +1; m < n; m++)\n            {\n                if((i & (1<<m))!=0)\n                {\n                    int entry = i & ~((1<<j)|(1<<m)); //remove both 1 at position j and 1 at position m from i\n                    distance = distances[j][n] + distances[j][m] + distances[m][n]; //calculate round-trip distance to grab 2 points\n                    \n                    if(dp[i] > dp[entry] + distance) // check if this new option is a better choice.  If it is, update our value and our path.\n                    {\n                        dp[i] = dp[entry] + distance;\n                        path[i] = entry;\n                    }\n                }\n            }\n            \n        }\n    }\n    \n    private static void OutputLowestAndPath(int[] dp, int[] path, int n)\n    {\n        \n        StringBuilder out = new StringBuilder();\n        out.append(dp[(1<<n)-1]);//output min value of traversal\n        out.append(\"\\n\");\n        out.append(\"0 \");\n        int index = (1<<n)-1; //start at our min value\n        while(index != 0)\n        {\n            int j = path[index];\n            int k = index ^ j; //find the one or two values that were added at this step\n            for(int m = 0; m < n; m++)\n            {\n                if((k & (1 << m)) != 0)\n                {\n                    out.append(m+1);\n                    out.append(\" \");\n                }\n            }\n            out.append(\"0 \");\n            index = j;\n        }\n        System.out.println(out.toString());\n    }\n    \n    private static void ComputeDistances(int[][] points, int[][] distances, int n)\n    {\n        for(int i = 0; i <= n; i++) //calculate distances between all points so that we don't have to compute later\n        {\n            for(int j=i+1; j<=n; j++)\n            {\n                int x= points[i][0] - points[j][0];\n                int y= points[i][1] - points[j][1];\n                distances[i][j] = x*x + y*y;\n            }\n        }\n    }\n    \n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\tfinal String filename = new String(\"C\").toLowerCase();\n\n\tvoid solve() throws Exception {\n\t\tint n = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tif (isSorted(a)) {\n\t\t\tout.println(\"YES\");\n\t\t\treturn;\n\t\t}\n\t\tint pos1 = -1;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif (a[i] > a[i + 1]) {\n\t\t\t\tint j = i;\n\t\t\t\twhile (j >= 0 && a[j] == a[i]) {\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tpos1 = j + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tint pos2 = -1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (a[i] > a[i + 1]) {\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile (j < n && a[j] == a[i + 1]) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tpos2 = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint tmp = a[pos1];\n\t\ta[pos1] = a[pos2];\n\t\ta[pos2] = tmp;\n\t\tif (isSorted(a)) {\n\t\t\tout.println(\"YES\");\n\t\t} else {\n\t\t\tout.println(\"NO\");\n\t\t}\n\t}\n\n\tboolean isSorted(int[] a) {\n\t\tfor (int i = 0; i < a.length - 1; i++) {\n\t\t\tif (a[i] > a[i + 1]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t// out = new PrintWriter(\"output.txt\");\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tString nextToken() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A().run();\n\t}\n\n}\n", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "/*\n\tAuthor\t:\tImran Khan\n\tLanguage:\tJava\n\t\n*/\n\nimport java.io.*;\nimport java.util.*;\npublic class Main\n{\n\tpublic class BasicInputOutput\n\t{\n\n\t\tprivate StringTokenizer strtoken;\n\t\tprivate BufferedReader bufferReader;\n\t\tprivate BufferedWriter bufferWriter;\n\t\tprivate String delim = \" \\t\\n\\r\\f\";\n\t\tBasicInputOutput()\n\t\t{\n\t\t\tdelim = \" \\t\\n\\r\\f\";\n\t\t\tinitialize();\n\t\t}\n\t\tBasicInputOutput( String s )\n\t\t{\n\t\t\tdelim = s;\n\t\t\tinitialize();\n\t\t}\n\t\tprivate void initialize()\n\t\t{\n\t\t\tbufferReader = new BufferedReader( new InputStreamReader( System.in ));\n\t\t\tbufferWriter = new BufferedWriter( new PrintWriter( System.out ));\n\t\t\tstrtoken = null;\n\t\t}\n\t\tprivate void checkStringTokenizer()throws IOException\n\t\t{\n\t\t\tif ( strtoken == null || strtoken.hasMoreTokens() == false )\n\t\t\t\tstrtoken = new StringTokenizer( bufferReader.readLine(), delim );\n\t\t}\n\t\tpublic int getNextInt()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn Integer.parseInt( strtoken.nextToken());\n\t\t}\n\n\t\tpublic long getNextLong()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn Long.parseLong( strtoken.nextToken());\n\t\t}\n\n\t\tpublic double getNextDouble()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn Double.parseDouble( strtoken.nextToken());\n\t\t}\n\n\t\tpublic float getNextFloat()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn Float.parseFloat( strtoken.nextToken());\n\t\t}\n\n\t\tpublic String getNextString()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn strtoken.nextToken();\n\t\t}\n\n\t\tpublic String getNextLine()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn bufferReader.readLine();\n\t\t}\n\n\t\tpublic void skipCurrentLine()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\tstrtoken = null;\n\t\t}\n\t\tpublic void write( String var )throws IOException\n\t\t{\n\t\t\tbufferWriter.write( var );\n\t\t}\n\n\t\tpublic < T > void write( char sep, T... var )throws IOException\n\t\t{\n\t\t\tif ( var.length == 0 )\n\t\t\t\treturn ;\n\t\t\tbufferWriter.write( var[0].toString());\n\t\t\tfor ( int i = 1; i < var.length; i++ )\n\t\t\t\tbufferWriter.write( sep + var[i].toString());\n\t\t}\n\n\t\tpublic void flush()throws IOException\n\t\t{\n\t\t\tbufferWriter.flush();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args)\n\t{\n\t\ttry\n\t\t{\n\t\t\tnew Main().run();\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tex.printStackTrace();\n\t\t}\n\t}\n\tprivate BasicInputOutput iohandler;\n\tprivate int n;\n\tprivate double[][] mat;\n\tprivate double[][] sum;\n\tprivate double[] dp;\n\tprivate int tolive;\n\tprivate void run()throws Exception\n\t{\n\t\tinitialize();\n\t\tsolve();\n\t}\n\tprivate void initialize() throws Exception\n\t{\n\t\tiohandler=new BasicInputOutput();\n\t\tn=iohandler.getNextInt();\n\t\tmat=new double[n][n];\n\t\tsum=new double[(1<<n)+10][n];\n\t\tdp=new double[1<<n];\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++)\n\t\t{\n\t\t\tmat[i][j]=iohandler.getNextDouble();\n\t\t}\n\t}\n\tprivate int bitCount(int mask)\n\t{\n\t\tint ret=0;\n\t\twhile(mask>0) {\n\t\t\tret++;\n\t\t\tmask&=(mask-1);\n\t\t}\n\t\treturn ret;\n\t}\n\tprivate void solve() throws Exception\n\t{\n\t\tdouble[] ans=new double[n];\n\t\tint ub=1<<n;\n\t\tfor(int i=1;i<ub;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tsum[i][j]=0;\n\t\t\t\tfor(int k=0;k<n;k++) if ((i&(1<<k))!=0) sum[i][j]+=mat[k][j];\n\t\t\t\tint cntbit=bitCount(i);\n\t\t\t\tif (cntbit>1)\n\t\t\t\tsum[i][j]/=((double)cntbit*(cntbit-1.))/2.;\n\t\t\t}\n\t\t}\n\t\tdp[ub-1]=1.;\n\t\tfor(int mask=ub-1;mask>=1;mask--) {\n\t\t\tif (dp[mask]==0.) continue;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif ((mask&(1<<i))==0) continue;\n\t\t\t\tdp[mask-(1<<i)]+=sum[mask][i]*dp[mask];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\tans[i]=dp[1<<i];\n\t\t/*\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int mask=1;mask<ub;mask++) {\n\t\t\t\tdp[mask]=0;\n\t\t\t\tif ((mask&(1<<i))==0) continue;\n\t\t\t\tif (bitCount(mask)==1)\n\t\t\t\t{\n\t\t\t\t\tdp[mask]=1.;\n\t\t\t\t} else\n\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\tif ((mask&(1<<k))==0) continue;\n\t\t\t\t\tif (i==k) continue;\n\t\t\t\t\tdp[mask]+=sum[mask][k]*dp[mask-(1<<k)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[i]=dp[ub-1];\n\t\t}*/\n\t\tiohandler.write(ans[0]+\"\");\n\t\tfor(int i=1;i<n;i++) iohandler.write(\" \"+ans[i]);\n\t\tiohandler.write(\"\\n\");\n\t\tiohandler.flush();\n\t}\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "//package sept;\n \nimport java.io.*;\nimport java.util.*;\n \npublic class TimePass {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n    //boolean codechef=true;\n    // String prodKey = \"Av#/lL{OyEKiLR+/Ce%(w]^J65;XZe8FVb]]<931_=80E[BVnU^@4xu*J%KG3,CRqIZrUN~JJ+*6QC*CyBd>'$;>O\"onO.bQ%{L}\";\n    boolean codechef=true;\n    \n    void solve()\n    {\n        int t=ni();\n        while(t-->0) {\n            int n=ni();\n            int root=(int)Math.sqrt(n/2);\n            int rootn = (int)Math.sqrt(n);\n            if (n==1 || n%2!=0) {\n                out.println(\"NO\");\n                continue;\n            }\n            if (root*root == n/2 || (rootn*rootn == n && rootn%2==0)) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n        }\n    }\n    \n    static int comp(int a,int b){\n        return a+1097*b;\n    }\n    \n    static long printNcR(int n, int r)\n    {\n \n        // p holds the value of n*(n-1)*(n-2)...,\n        // k holds the value of r*(r-1)...\n        long p = 1, k = 1;\n \n        // C(n, r) == C(n, n-r),\n        // choosing the smaller value\n        if (n - r < r) {\n            r = n - r;\n        }\n \n        if (r != 0) {\n            while (r > 0) {\n                p *= n;\n                k *= r;\n \n                // gcd of p, k\n                long m = __gcd(p, k);\n \n                // dividing by gcd, to simplify\n                // product division by their gcd\n                // saves from the overflow\n                p /= m;\n                k /= m;\n \n                n--;\n                r--;\n            }\n \n            // k should be simplified to 1\n            // as C(n, r) is a natural number\n            // (denominator should be 1 ) .\n        }\n        else {\n            p = 1;\n        }\n \n        // if our approach is correct p = ans and k =1\n        return p;\n    }\n \n    static long __gcd(long n1, long n2)\n    {\n        long gcd = 1;\n \n        for (int i = 1; i <= n1 && i <= n2; ++i) {\n            // Checks if i is factor of both integers\n            if (n1 % i == 0 && n2 % i == 0) {\n                gcd = i;\n            }\n        }\n        return gcd;\n    }\n    static long[][] dp;\n    \n    static long desc(int[] a,int l,int r) {\n        if (l==r) return 0;\n        if (dp[l][r]!=-1) return dp[l][r];\n        dp[l][r] = a[r]-a[l] + Math.min(desc(a,l+1,r),desc(a,l,r-1));\n        return dp[l][r];\n    }\n    \n    static int getMax(int arr[], int n)\n    {\n        int mx = arr[0];\n        for (int i = 1; i < n; i++)\n            if (arr[i] > mx)\n                mx = arr[i];\n        return mx;\n    }\n \n    // A function to do counting sort of arr[] according to\n    // the digit represented by exp.\n    static void countSort(int arr[], int n, int exp)\n    {\n        int output[] = new int[n]; // output array\n        int i;\n        int count[] = new int[10];\n        Arrays.fill(count, 0);\n \n        // Store count of occurrences in count[]\n        for (i = 0; i < n; i++)\n            count[(arr[i] / exp) % 10]++;\n \n        // Change count[i] so that count[i] now contains\n        // actual position of this digit in output[]\n        for (i = 1; i < 10; i++)\n            count[i] += count[i - 1];\n \n        // Build the output array\n        for (i = n - 1; i >= 0; i--) {\n            output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n            count[(arr[i] / exp) % 10]--;\n        }\n \n        // Copy the output array to arr[], so that arr[] now\n        // contains sorted numbers according to curent digit\n        for (i = 0; i < n; i++)\n            arr[i] = output[i];\n    }\n \n    // The main function to that sorts arr[] of size n using\n    // Radix Sort\n    static void radixsort(int arr[], int n)\n    {\n        // Find the maximum number to know number of digits\n        int m = getMax(arr, n);\n \n        // Do counting sort for every digit. Note that\n        // instead of passing digit number, exp is passed.\n        // exp is 10^i where i is current digit number\n        for (int exp = 1; m / exp > 0; exp *= 10)\n            countSort(arr, n, exp);\n    }\n \n    static int MAX=1500;\n    \n    static int prime[], countdiv[]; \n    \n    static int[] getDivisorsArray() {\n        int n=20000005;\n        int[] mind = new int[n];\n        Arrays.fill(mind, -1);\n        for(int i=2;i<n;i++){\n            if (mind[i]==-1){\n                for(int j=i;j<n;j+=i){\n                    if (mind[j]==-1){\n                        mind[j]=i;\n                    }\n                }\n            }\n        }\n        // int[] nod = new int[n];\n        // for(int i=2;i<n;i++){\n        //     int prod = i/mind[i];\n        //     if (mind[i] != mind[prod]) {\n        //         nod[i] = nod[prod] + 1;\n        //     } else {\n        //         nod[i] = nod[prod];\n        //     }\n        // }\n        return mind;\n    }\n      \n    // Simple sieve to find smallest prime factors of numbers \n    // smaller than MAX \n    void SieveOfEratosthenes() \n    { \n        for (int i = 2; i * i < MAX; ++i) \n        { \n            if (prime[i]==0) \n                for (int j = i * i; j < MAX; j += i) \n                    prime[j] = i; \n        } \n      \n        // Prime number will have same divisor \n        for (int i = 1; i < MAX; ++i) \n            if (prime[i]==0) \n                prime[i] = i; \n    } \n      \n    // Returns length of the largest subsequence \n    // with GCD more than 1. \n    int largestGCDSubsequence(int arr[], int n) \n    { \n        int ans = 0; \n        for (int i=0; i < n; ++i) \n        { \n            int element = arr[i]; \n      \n            // Fetch total unique prime divisor of element \n            while (element > 1) \n            { \n                int div = prime[element]; \n      \n                // Increment count[] of Every unique divisor \n                // we get till now \n                ++countdiv[div]; \n      \n                // Find maximum frequency of divisor \n                ans = Math.max(ans, countdiv[div]); \n      \n                while (element % div==0) \n                    element /= div; \n            } \n        } \n      \n        return ans; \n    } \n      \n    \n    static boolean check(int x)\n    {\n        char[] a=(\"\"+x).toCharArray();\n        int s=0;\n        for(int i=0;i<a.length;i++)\n        {\n            s+=a[i]-'0';\n            s%=3;\n        }\n        if(s==0)return true;\n        return false;\n    }\n    \n    \n    static int[][] packD(int n,int[] from,int[] to)\n    {\n        int[][] g=new int[n][];\n        int[] p=new int[n];\n        for(int f:from)\n        {\n            p[f]++;\n        }\n        int m=from.length;\n        for(int i=0;i<n;i++)\n        {\n            g[i]=new int[p[i]];\n        }\n        for(int i=0;i<m;i++)\n        {\n            g[from[i]][--p[from[i]]]=to[i];\n        }\n        return g;\n    }\n    \n    static class Pair3\n    {\n        int a,b,c;\n        public Pair3(int a,int b,int c)\n        {\n            this.a=a;\n            this.b=b;\n            this.c=c;\n        }\n    }\n        \n    static class Pair\n    {\n        int a,b;\n        public Pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    \n    static long lcm(long a,long b)\n    {\n        long val=a;\n        val*=b;\n        return (val/gcd(a,b));\n    }\n    \n    static long gcd(long a,long b)\n    {\n        if(a==0)return b;\n        return gcd(b%a,a);\n    }\n    \n    static int pow(int a, int b, int p)\n    {\n        long ans = 1, base = a;\n        while (b!=0)\n        {\n            if ((b & 1)!=0)\n            {\n                ans *= base;\n                ans%= p;\n            }\n            base *= base;\n            base%= p;\n            b >>= 1;\n        }\n        return (int)ans;\n    }\n \n    static int inv(int x, int p)\n    {\n        return pow(x, p - 2, p);\n    }\n \n    \n    void run() throws Exception\n    {\n        if(codechef)oj=true;\n        is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        \n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception {new TimePass().run();}\n    \n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\nimport java.util.Scanner;\n\n/**\n *\n * @author RezaM\n */\npublic class A {\n\n    public static void main(String[] args) {\n\n        Scanner scan = new Scanner(System.in);\n\n        int n = scan.nextInt();\n\n        if (n % 2 == 0) {\n            System.out.println(4 + \" \" + (n - 4));\n        } else {\n            System.out.println(9 + \" \" + (n - 9));\n        }\n\n    }\n\n}\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "/**\n * author: derrick20\n * created: 3/19/21 11:57 PM\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class E2_SquareFreeDivision2 {\n    static FastScanner sc = new FastScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n//        generate();\n        int MAX = (int) 1e7;\n        int[] spf = new int[MAX + 1];\n        for (int i = 2; i <= MAX; i++) {\n            if (spf[i] == 0) {\n                spf[i] = i;\n                for (int j = i + i; j <= MAX; j += i) {\n                    if (spf[j] == 0) {\n                        spf[j] = i;\n                    }\n                }\n            }\n        }\n        int[] freq = new int[MAX + 1];\n        int T = sc.nextInt();\n        while (T-->0) {\n            int N = sc.nextInt();\n            int K = sc.nextInt();\n            int[] a = new int[N + 1];\n            for (int i = 1; i <= N; i++) {\n                a[i] = sc.nextInt();\n                int canonical = 1;\n                while (a[i] > 1) {\n                    int factor = spf[a[i]];\n                    int parity = 0;\n                    while (a[i] % factor == 0) {\n                        a[i] /= factor;\n                        parity ^= 1;\n                    }\n                    if (parity == 1) {\n                        canonical *= factor;\n                    }\n                }\n                a[i] = canonical;\n            }\n            int[][] transition = new int[K + 1][N + 1];\n//            HashMap<Integer, Integer> freq = new HashMap<>();\n            for (int k = 0; k <= K; k++) {\n                int l = N + 1;\n                int duplicates = 0;\n                for (int r = N; r >= 1; r--) {\n                    while (l - 1 >= 1) {\n                        int nextDuplicates = duplicates;\n                        if (freq[a[l - 1]] >= 1) {\n                            nextDuplicates++;\n                        }\n                        if (nextDuplicates <= k) {\n                            duplicates = nextDuplicates;\n                            freq[a[l - 1]]++;\n                            l--;\n                        } else {\n                            break;\n                        }\n                    }\n                    transition[k][r] = l;\n                    if (--freq[a[r]] >= 1) {\n                        duplicates--;\n                    }\n                }\n            }\n            int[][] dp = new int[K + 1][N + 1];\n            int oo = (int) 1e9;\n            for (int[] row : dp) {\n                Arrays.fill(row, oo);\n            }\n            for (int k = 0; k <= K; k++) {\n                dp[k][0] = 0;\n            }\n            for (int r = 1; r <= N; r++) {\n                for (int k = 0; k <= K; k++) {\n                    for (int delta = 0; delta <= k; delta++) {\n                        dp[k][r] = min(dp[k][r], dp[k - delta][transition[delta][r] - 1] + 1);\n                    }\n                }\n            }\n            out.println(dp[K][N]);\n        }\n        out.close();\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n    \n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n    \n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n    \n        char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n    \n        int nextInt() {\n            return (int) nextLong();\n        }\n    \n        long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n    \n        double nextDouble() {\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            double cur = nextLong();\n            if (c != '.') {\n                return neg ? -cur : cur;\n            } else {\n                double frac = nextLong() / cnt;\n                return neg ? -cur - frac : cur + frac;\n            }\n        }\n    \n        String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n    \n        String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n    \n        boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n    \n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n    \n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\npublic class Main\n{\n      @SuppressWarnings(\"unchecked\")\n      public static void main(String args[])throws IOException\n    {\n         Reader ob=new Reader();\n        Writer out=new Writer(System.out);\n        Random oo=new Random();\n        long k=ob.nL(),ans=0,p=9,num=0;\n        for(int i=1;i<18;i++)\n        {\n            if(num+i*p<k)\n            {\n                num+=i*p;p*=10;\n                ans=0;\n                for(int j=0;j<i;j++)\n                ans=9+ans*10;\n            }\n            else\n            {\n                long left=k-num;\n                long r=left/i;\n                left-=r*i;\n                ans+=r;\n                if(left>0)\n                {\n                 String s=Long.toString(ans+1);\n                \n                out.pln(s.charAt((int)left-1));\n            }\n            else\n            {\n                \n                String s=Long.toString(ans);\n                \n                out.pln(s.charAt(i-1-(int)left));\n            }\n                break;\n            }\n            \n        }\nout.flush();\n}\nstatic void sort(int a[])\n{\n    RA(a);\n    Arrays.sort(a);\n}\n public static Pairs[] RA(Pairs [] array){\n\t\tRandom rgen = new Random();  // Random number generator\t\t\t\n \n\t\tfor (int i=0; i<array.length; i++) {\n\t\t    int randomPosition = rgen.nextInt(array.length);\n\t\t    Pairs temp = array[i];\n\t\t    array[i] = array[randomPosition];\n\t\t    array[randomPosition] = temp;\n\t\t}\n \n\t\treturn array;\n\t}\n\t\n public static int[] RA(int [] array){\n\t\tRandom rgen = new Random();  // Random number generator\t\t\t\n \n\t\tfor (int i=0; i<array.length; i++) {\n\t\t    int randomPosition = rgen.nextInt(array.length);\n\t\t    int temp = array[i];\n\t\t    array[i] = array[randomPosition];\n\t\t    array[randomPosition] = temp;\n\t\t}\n \n\t\treturn array;\n\t}\n\tstatic void sort(long a[])\n{\n    RA(a);\n    Arrays.sort(a);\n}\n public static long[] RA(long [] array){\n\t\tRandom rgen = new Random();  // Random number generator\t\t\t\n \n\t\tfor (int i=0; i<array.length; i++) {\n\t\t    int randomPosition = rgen.nextInt(array.length);\n\t\t    long temp = array[i];\n\t\t    array[i] = array[randomPosition];\n\t\t    array[randomPosition] = temp;\n\t\t}\n \n\t\treturn array;\n\t}\n\tstatic void sort(String a[])\n{\n    RA(a);\n    Arrays.sort(a);\n}\n public static String[] RA(String [] array){\n\t\tRandom rgen = new Random();  // Random number generator\t\t\t\n \n\t\tfor (int i=0; i<array.length; i++) {\n\t\t    int randomPosition = rgen.nextInt(array.length);\n\t\t    String temp = array[i];\n\t\t    array[i] = array[randomPosition];\n\t\t    array[randomPosition] = temp;\n\t\t}\n \n\t\treturn array;\n\t}\nstatic long inverse(long x, long p)\n    {\n        return pow(x, p - 2, p);\n    }\nstatic boolean isPrime(long n)\n{\n    long h=(long)Math.sqrt(n);\n    for(long i=2;i<=h;i++)\n    if(n%i==0)\n    return false;\n    return true&&n!=1;\n}\n    static long gcd(long a,long b)\n    {\n        if(a<b)\n        return gcd(b,a);\n        else if(b==0)\n        return a;\n        else\n        return gcd(b,a%b);\n    }\n    static long pow(long a,long b,long mod){\n\t\tif(b == 0)\treturn 1;\n\t\tlong t = pow(a,b>>1,mod);\n\t\tt = (t * t) % mod;\n\t\tif((b & 1) == 1)\tt = (t * a);\n\t\tif(t >= mod)\tt %= mod;\n\t\treturn t;\n}\n    static long pow(long a,long b){\n\t\tif(b == 0)\treturn 1;\n\t\tlong t = pow(a,b>>1);\n\t\tt = (t * t);\n\t\tif((b & 1) == 1)\tt = (t * a);\n\t\treturn t;\n}\n    static void seive(int n,int prime[])//1 for prime -1 for not prime\n    {\n        for(int i=2;i<=n;i++)\n            if(prime[i]==0)\n            {\n                prime[i]=1;\n                for(int j=2;j*i<=n;j++)\n                prime[j*i]=-1;\n            }\n    }\n    static int max(int ...a)\n    {\n        int m=a[0];\n        for(int i=0;i<a.length;i++)\n        m=Math.max(m,a[i]);\n        return m;\n        \n    }\n    static long max(long ...a)\n    {\n        long m=a[0];\n        for(int i=0;i<a.length;i++)\n        m=Math.max(m,a[i]);\n        return m;\n    }\n    static int min(int ...a)\n    {\n        int m=a[0];\n        for(int i=0;i<a.length;i++)\n        m=Math.min(m,a[i]);\n        return m;\n    }\n    static long min(long ...a)\n    {\n        long m=a[0];\n        for(int i=0;i<a.length;i++)\n        m=Math.min(m,a[i]);\n        return m;\n    }\n    static class Pair<T1,T2>\n    {\n        T1 x;T2 y;\n        Pair(T1 xx,T2 yy)\n        {\n            x=xx;\n            y=yy;\n        }\n    }\n    \n\tstatic class Writer {\n\t\tprivate final PrintWriter p;\n\t\tWriter(OutputStream o) {\n\t\t\tp = new PrintWriter(new BufferedWriter(new OutputStreamWriter(o)));\n\t\t}\n\t\tvoid p(Object... o1) {\n\t\t\tfor (Object o11 : o1) {\n\t\t\t\tp.print(o11 + \"\" );\n\t\t\t}\n\t\t}\n\t\t<T>void pa(T a[])\n\t\t{\n\t\t    for(T i:a)\n\t\t    System.out.print(i+\" \");\n\t\t    System.out.println();\n\t\t  }\n\t\tvoid p(String s) {\n\t\t\tp.print(s);\n\t\t}\n\t\tvoid pln(Object... o1) {\n\t\t\tp(o1);\n\t\t\tp.println();\n\t\t}\n\t\tvoid flush() {\n\t\t\tp.flush();\n\t\t}\n\t\tvoid close() {\n\t\t\tp.close();\n\t\t}\n\t}\n    static class Reader {\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int snumChars;\n\t\tint flag=0;\n\t\tFileReader file;\n\t\tReader()\n\t\t{\n\t\t  }\n\t\t  Reader(String x)throws IOException\n\t\t  {\n\t\t      flag=1;\n\t\t      file=new FileReader(x);\n\t\t  }\n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = System.in.read(buf);\n\t\t\t\t\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t\tpublic String nl() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\t\tpublic String n() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\t\tpublic long nL() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\t\tpublic int nI() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\t\tpublic int[] NIA(int n) //nextINtArray\n\t\t{\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nI();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\tpublic int[] NIA1(int n) //nextINtArray\n\t\t{\n\t\t\tint[] arr = new int[n+1];\n\t\t\tfor (int i = 1; i <=n; i++) {\n\t\t\t\tarr[i] = nI();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\t\n\t\tpublic long[] NLA(int n) //nextLongArray\n\t\t{\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nL();\n\t\t\t}\n\t\t\treturn arr;\n}\n\t\tpublic long[] NLA1(int n) //nextLongArray\n\t\t{\n\t\t\tlong[] arr = new long[n+1];\n\t\t\tfor (int i = 1; i <=n; i++) {\n\t\t\t\tarr[i] = nL();\n\t\t\t}\n\t\t\treturn arr;\n}\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\t}\nstatic class DSU\n{\n    int a[],size[],c=1,m;\n    HashMap<String,Integer> hm=new HashMap<String,Integer>();\n    DSU(int n)\n    {\n        a=new int[n+1];\n        m=n;\n        size=new int[n+1];\n        for(int i=1;i<=n;i++)\n    {\n        a[i]=i;\n        size[i]=1;\n    }\n    }\n    void add(String x,int i)\n    {\n        hm.put(x,i);\n    }\n    int find(int n)\n    {\n        while(a[n]!=n)\n        {\n            a[n]=a[a[n]];\n        n=a[n];\n    }\n        return n;\n    }\n    int[] eval()\n    {\n       int y[]=new int[m+1];\n       for(int i=1;i<=m;i++)\n       y[find(i)]++;\n       return y;\n    }\n    void union(int a1,int b)\n    {\n        int x=find(a1);\n        int y=find(b);\n        if(size[x]>size[y])\n    {\n        a[y]=x;\n        size[x]+=size[y];\n    }\n    else\n    {\n       a[x]=y;\n       size[y]+=size[x];\n    }\n}\n        //System.out.println(Arrays.toString(a));\n}\nclass Segment\n{\n    int sum[];\n    void build(int a[],int v,int l,int r)\n    {\n        if(l==r)\n        sum[v]=a[l];\n        else\n        {\n            int m=(l+r)/2;\n            build(a,v*2,l,m);\n            build(a,2*v+1,m+1,r);\n            sum[v]=sum[v*2]+sum[2*v+1];\n        }\n    }\n    void update(int a[],int l,int r,int x,int v,int y)\n    {\n        if(l==r&&r==y)\n            sum[v]+=x;\n        else if(l>y||y>r)\n        return;\n        else\n        {\n            int m=(l+r)/2;\n            update(a,l,m,x,2*v,y);\n            update(a,m+1,r,x,2*v+1,y);\n            sum[v]=sum[2*v]+sum[2*v+1];\n        }\n    }\n    int query(int v,int l,int r,int x,int y)\n    {\n        if(x>r||y<l)\n        return 0;\n        else if(x<=l&&r<=y)\n        return sum[v];\n        else\n        {\n            int m=(l+r)/2;\n        return query(2*v,l,m,x,y)+query(2*v+1,m+1,r,x,y);  \n    }\n}\n}\n\nstatic class Trie\n  {\n      Trie child[]=new Trie[26];\n      int count=0;\n    }\n   /* void insert(String a)\n    {\n        Trie tmp=root;\n        for(int i=0;i<a.length();i++)\n        {\n            int v=a.charAt(i)-'a';\n            if(tmp.child[v]==null)\n            {\n                tmp.child[v]=new Trie();\n                \n            }\n                tmp=tmp.child[v];\n            }\n            if(tmp.count==0)\n            r++;\n            tmp.count=1;\n        }*/\n    }\n    class Pairs implements Comparable<Pairs>\n    {\n        int x,y;String z;\n        Pairs(int a,int b)\n        {\n            x=a;y=b;\n        }\n        @Override\n         public int compareTo(Pairs a)\n            {\n            \n            if(a.x>this.x||(a.x==this.x&&a.y<this.y)||(a.x==this.x&&a.y==this.y&&(a.z).equals(\"BhayanakMaut\")))\n            return 1;\n            else\n            return -1;\n        }\n    }", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "/*\n * Hopefully this is AC :D\n */\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\nimport java.util.Arrays;\n\npublic class TwoSets {\n\n\tstatic ArrayList<Integer> g[];\n\tstatic boolean visited[];\n\tstatic int ans[],p[],orig[];\n\tstatic int n,a,b;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String args[] ) throws Exception {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t    PrintWriter w = new PrintWriter(System.out);\n\t        \n\t    StringTokenizer st1 = new StringTokenizer(br.readLine());\n\t    n = ip(st1.nextToken());\n\t    a = ip(st1.nextToken());\n\t    b = ip(st1.nextToken());\n\t    \n\t    g = new ArrayList[n];\n\t    visited = new boolean[n];\n\t    ans = new int[n];\n\t    p = new int[n];\n\t    orig = new int[n];\n\t    \n\t    StringTokenizer st2 = new StringTokenizer(br.readLine());\n\t    for(int i=0;i<n;i++){\n\t    \tp[i] = ip(st2.nextToken());\n\t    \torig[i] = p[i];\n\t    \tg[i] = new ArrayList<Integer>();\n\t    }\n\t    \n\t    Arrays.sort(p);\n\t    \n\t    boolean impossible = false;\n\t    \n\t    for(int i=0;i<n;i++){\n\t    \tint i1 = Arrays.binarySearch(p, a-p[i]);\n\t    \tint i2 = Arrays.binarySearch(p, b-p[i]);\n\t    \tif(i1 < 0 || i1 >= n)\ti1 = -1;\n\t    \tif(i2 < 0 || i2 >= n)\ti2 = -1;\n\t    \t\n\t    \tif(i1 == -1 && i2 != -1) //if only (b-x) present then both must belong to set 1\n\t    \t\tg[i].add(i2);\n\t    \t\n\t    \telse if(i1 != -1 && i2 == -1) //if only (a-x) present then both must belong to set 0\n\t    \t\tg[i].add(i1);\n\t    \t\n\t    \telse if(i1 != -1 && i2 != -1){ //both present hence all 3 should be in same set,doesn't matter which\n\t    \t\tg[i].add(i1);\n\t    \t\tg[i].add(i2);\n\t    \t}\n\t    \telse{ //if none present then not possible to be in any set\n\t    \t\timpossible = true;\n\t    \t\tbreak;\n\t    \t}\n\t    }\n\t   \n\t    if(impossible){//if any element without both a-x and b-x found\n\t    \tSystem.out.println(\"NO\");\n\t    \treturn;\n\t    }\n\t    \n\t    //Edge between a and b means they must be present in same set\n\t    //ans[i] =0 or ans[i] =1 means it must be compulsory be present in that set\n\t    //ans[i] = -1 means no restrictions on it's set number\n\t    \n\t    LinkedList<Integer>\tq = new LinkedList();//Queue\n\t    for(int i=0;i<n;i++){\n\t    \t\n\t    \tif(visited[i] == false){\n\t    \t\t\n\t    \t\tArrayList<Integer>\tcurq = new ArrayList<Integer>();      //contains indices of all nodes in this connected component\n\t    \t\t\n\t    \t\tcurq.add(i);\n\t    \t\tq.add(i);\n\t    \t\tvisited[i] = true;\n\t    \n\t    \t\twhile(!q.isEmpty()){\n\t    \t\t\tint curr = q.remove();\n\t    \t\t\tint s = g[curr].size();\n\t    \t\t\tfor(int j=0;j<s;j++){\n\t    \t\t\t\tif(!visited[g[curr].get(j)]){\n\t    \t\t\t\t\tvisited[g[curr].get(j)] = true;\n\t    \t\t\t\t\tcurq.add(g[curr].get(j));\n\t    \t\t\t\t\tq.add(g[curr].get(j));\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t}\n\t    \n\t    \t\tboolean  found = true;\n\t    \t\t\n    \t\t\tint s = curq.size();\n\t    \t\tint temp[] = new int[s];\n    \t\t\tfor(int j=0;j<s;j++)\n    \t\t\t\ttemp[j] = p[curq.get(j)];\n    \t\t\tArrays.sort(temp);\n    \t\t\t\n    \t\t\tint anss = -1;\n    \t\t\t\n\t    \t\tfor(int j=0;j<s;j++){\n\t    \t\t\tint i3 = Arrays.binarySearch(temp, a - temp[j]);\n\t    \t\t\tif(i3 < 0 || i3 >= n){\n\t   \t\t\t\t\tfound = false;\n\t   \t\t\t\t\tbreak;\n\t   \t\t\t\t}\n\t   \t\t\t}\n\t    \t\t\t\n\t    \t\tif(!found){\n\t    \t\t\tfound = true;\n\t    \t\t\t\t\n\t    \t\t\tfor(int j=0;j<s;j++){\n\t\t    \t\t\tint i3 = Arrays.binarySearch(temp, b - temp[j]);\n\t\t   \t\t\t\tif(i3 < 0 || i3 >= n){\n\t\t   \t\t\t\t\tfound = false;\n\t\t   \t\t\t\t\tbreak;\n\t\t   \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t\t\n\t    \t\t\tif(found)\n\t    \t\t\t\tanss = 1;\n\t    \t\t\telse{\n\t    \t\t\t\timpossible = true;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t\t\t    \t\t\t\n\t    \t\t}\n\t    \t\telse\n\t    \t\t\tanss = 0;\n\t    \t\t\n\t    \t\tfor(int j=0;j<s;j++)\n\t    \t\t\tans[curq.get(j)] = anss;\n\t    \t\n\t    \t}\n\t    \t\n\t    \t\n\t    }\n\t    \n\t    if(!impossible){\n\t    \tw.println(\"YES\");\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tint i1 = Arrays.binarySearch(p, orig[i]);\n    \t\t\tif(ans[i1] == -1)\tans[i1] = 1;\n    \t\t\tw.print(ans[i1] + \" \");\n    \t\t}\n    \t\tw.println();\n    \t}\n\t    else\n\t    \tw.println(\"NO\");\n\t    \n\t    w.close(); \n\t}\n\t\n\tpublic static int ip(String s){\n\t\treturn Integer.parseInt(s);\n\t}\n}\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1187G extends PrintWriter {\n\tCF1187G() { super(System.out); }\n\tstatic class Scanner {\n\t\tScanner(InputStream in) { this.in = in; } InputStream in;\n\t\tint k, l; byte[] bb = new byte[1 << 15];\n\t\tbyte getc() {\n\t\t\tif (k >= l) {\n\t\t\t\tk = 0;\n\t\t\t\ttry { l = in.read(bb); } catch (IOException e) { l = 0; }\n\t\t\t\tif (l <= 0) return -1;\n\t\t\t}\n\t\t\treturn bb[k++];\n\t\t}\n\t\tint nextInt() {\n\t\t\tbyte c = 0; while (c <= 32) c = getc();\n\t\t\tint a = 0;\n\t\t\twhile (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n\t\t\treturn a;\n\t\t}\n\t}\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1187G o = new CF1187G(); o.main(); o.flush();\n\t}\n\n\tstatic final int INF = 0x3f3f3f3f;\n\tArrayList[] aa_;\n\tint n_, m_;\n\tint[] pi, dd, bb;\n\tint[] uu, vv, uv, cost;\n\tint[] cc;\n\tvoid init() {\n\t\taa_ = new ArrayList[n_];\n\t\tfor (int u = 0; u < n_; u++)\n\t\t\taa_[u] = new ArrayList<Integer>();\n\t\tpi = new int[n_];\n\t\tdd = new int[n_];\n\t\tbb = new int[n_];\n\t\tqq = new int[nq];\n\t\tiq = new boolean[n_];\n\t\tuu = new int[m_];\n\t\tvv = new int[m_];\n\t\tuv = new int[m_];\n\t\tcost = new int[m_];\n\t\tcc = new int[m_ * 2];\n\t\tm_ = 0;\n\t}\n\tvoid link(int u, int v, int cap, int cos) {\n\t\tint h = m_++;\n\t\tuu[h] = u;\n\t\tvv[h] = v;\n\t\tuv[h] = u ^ v;\n\t\tcost[h] = cos;\n\t\tcc[h << 1 ^ 0] = cap;\n\t\taa_[u].add(h << 1 ^ 0);\n\t\taa_[v].add(h << 1 ^ 1);\n\t}\n\tint[] qq;\n\tint nq = 1 << 20, head, cnt;\n\tboolean[] iq;\n\tvoid enqueue(int v) {\n\t\tif (iq[v])\n\t\t\treturn;\n\t\tif (head + cnt == nq) {\n\t\t\tif (cnt * 4 <= nq)\n\t\t\t\tSystem.arraycopy(qq, head, qq, 0, cnt);\n\t\t\telse {\n\t\t\t\tint[] qq_ = new int[nq *= 2];\n\t\t\t\tSystem.arraycopy(qq, head, qq_, 0, cnt);\n\t\t\t\tqq = qq_;\n\t\t\t}\n\t\t\thead = 0;\n\t\t}\n\t\tqq[head + cnt++] = v; iq[v] = true;\n\t}\n\tint dequeue() {\n\t\tint u = qq[head++]; cnt--; iq[u] = false;\n\t\treturn u;\n\t}\n\tboolean spfa(int s, int t) {\n\t\tArrays.fill(pi, INF);\n\t\tpi[s] = 0;\n\t\thead = cnt = 0;\n\t\tenqueue(s);\n\t\twhile (cnt > 0) {\n\t\t\tint u = dequeue();\n\t\t\tint d = dd[u] + 1;\n\t\t\tArrayList<Integer> adj = aa_[u];\n\t\t\tfor (int h_ : adj)\n\t\t\t\tif (cc[h_] > 0) {\n\t\t\t\t\tint h = h_ >> 1;\n\t\t\t\t\tint p = pi[u] + ((h_ & 1) == 0 ? cost[h] : -cost[h]);\n\t\t\t\t\tint v = u ^ uv[h];\n\t\t\t\t\tif (pi[v] > p || pi[v] == p && dd[v] > d) {\n\t\t\t\t\t\tpi[v] = p;\n\t\t\t\t\t\tdd[v] = d;\n\t\t\t\t\t\tbb[v] = h_;\n\t\t\t\t\t\tenqueue(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn pi[t] != INF;\n\t}\n\tvoid push(int s, int t) {\n\t\tint c = INF;\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tc = Math.min(c, cc[h_]);\n\t\t}\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_] -= c; cc[h_ ^ 1] += c;\n\t\t}\n\t}\n\tvoid push1(int s, int t) {\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_]--; cc[h_ ^ 1]++;\n\t\t}\n\t}\n\tint edmonds_karp(int s, int t) {\n\t\twhile (spfa(s, t))\n\t\t\tpush1(s, t);\n\t\tint c = 0;\n\t\tfor (int h = 0; h < m_; h++)\n\t\t\tc += cost[h] * cc[h << 1 ^ 1];\n\t\treturn c;\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tint[] ii = new int[k];\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tii[h] = sc.nextInt() - 1;\n\t\tArrayList[] aa = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = new ArrayList<Integer>();\n\t\tfor (int h = 0; h < m; h++) {\n\t\t\tint i = sc.nextInt() - 1;\n\t\t\tint j = sc.nextInt() - 1;\n\t\t\taa[i].add(j);\n\t\t\taa[j].add(i);\n\t\t}\n\t\tint t = n + k + 1;\n\t\tn_ = n * t + 1;\n\t\tm_ = k + (m * 2 * k + n) * (t - 1);\n\t\tinit();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrayList<Integer> adj = aa[i];\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s;\n\t\t\t\tfor (int j : adj) {\n\t\t\t\t\tint v = j * t + s + 1;\n\t\t\t\t\tfor (int x = 1; x <= k; x++)\n\t\t\t\t\t\tlink(u, v, 1, c + (x * 2 - 1) * d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s, v = u + 1;\n\t\t\t\tlink(u, v, k, i == 0 ? 0 : c);\n\t\t\t}\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tlink(n_ - 1, ii[h] * t + 0, 1, 0);\n\t\tprintln(edmonds_karp(n_ - 1, 0 * t + t - 1));\n\t}\n}\n", "complexity": "cubic", "problem": "1187_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "import java.util.*; \nimport java.io.*;\n \npublic class Main {\n\t\n\tpublic static int mod = 1000000007;\n\t\n\tpublic static void solve(InputReader in) {\n\t\tint inf = (int) 1e9; \n\t\tint n = in.readInt(); int m = in.readInt();\n\t\tchar s[][] = new char[n][m]; \n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tchar temp[] = in.readString().toCharArray(); \n\t\t\tfor(int j = 0; j<m; j++) {\n\t\t\t\ts[i][j] = temp[j]; \n\t\t\t}\n\t\t}\n\t\tint maxX = -inf; \n\t\tint minX = inf;\n\t\tint maxY = -inf; \n\t\tint minY = inf; \n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tfor(int j = 0; j<m; j++) {\n\t\t\t\tif(s[i][j] == 'B') {\n\t\t\t\t\t minX = Math.min(minX, i);\n                     minY = Math.min(minY, j);\n                     maxX = Math.max(maxX, i);\n                     maxY = Math.max(maxY, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.print((minX + maxX) / 2 + 1);\n        System.out.print(' ');\n        System.out.println((minY + maxY) / 2 + 1);\n\t}\n \n\tpublic static void main(String[] args) {\n\t\t// jai shree krishna\n\t\tInputReader in = new InputReader(System.in); \n\t\tint t = 1;\n\t\twhile (t-- > 0)\n\t\t\tsolve(in);\n\t}\n}\n \n \nclass InputReader{\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n \n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n \n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic long readLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9') {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\t\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n     \n\tpublic String next() {\n\t\treturn readString();\n\t}\n    \n    public interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n \n \n \nclass pair implements Comparable<pair> {\n\tlong first;\n\tlong second;\n \n\tpair(long a, long b) {\n\t\tthis.first = a;\n\t\tthis.second = b;\n\t}\n \n\tpublic long getFirst() {\n\t\treturn first;\n\t}\n \n\tpublic long getSecond() {\n\t\treturn second;\n\t}\n \n\tpublic String toString() {\n\t\treturn first + \" \" + second;\n\t}\n \n\tpublic boolean equals(Object o) {\n\t\treturn o instanceof pair && ((pair) o).first == first && ((pair) o).second == second;\n\t}\n \n\tpublic int compareTo(pair a) {\n\t\treturn Long.compare(first, a.first);\n\t}\n \n\tpublic int hashCode() {\n\t\treturn (31 * (int) first + (int) second);\n\t}\n}\n", "complexity": "quadratic", "problem": "1028_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.sql.Time;\nimport java.util.*;\n\nimport java.math.BigInteger;\n\nimport static java.lang.Math.*;\nimport static java.math.BigInteger.*;\nimport static java.util.Arrays.*;\n\n\npublic class Main{\n\n    void run(){\n        Locale.setDefault(Locale.US);\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n//        boolean oj = true;\n        try{\n            if( oj ){\n                sc  = new FastScanner( new InputStreamReader(System.in  ) );\n                out = new PrintWriter(   new OutputStreamWriter(System.out) );\n            } else{\n                sc  = new FastScanner(new FileReader(\"in.txt\") );\n//                sc  = new FastScanner(new FileReader(\"D:\\\\JavaOlymp\\\\FatalError\\\\output.txt\") );\n                out = new PrintWriter(   new FileWriter(\"out.txt\") );\n            }\n        } catch (Exception e) {\n            System.exit(-1);\n        }\n        long tB = System.currentTimeMillis();\n        solve();\n        if( !oj ) System.err.println( \"Time: \" + (System.currentTimeMillis()-tB)/1e3 );\n        out.flush();\n    }\n\n\n    class FastScanner{\n        BufferedReader br;\n        StringTokenizer st = new StringTokenizer(\"\");\n        FastScanner( InputStreamReader a ){\n            br = new BufferedReader(a);\n        }\n        FastScanner( FileReader a ){\n            br = new BufferedReader(a);\n        }\n        String next(){\n            while( !st.hasMoreTokens() )\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    return null;\n                }\n            return st.nextToken();\n        }\n        String readLine(){\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        int nextInt(){ return Integer.parseInt(next()); }\n        long nextLong(){ return Long.parseLong(next()); }\n    }\n\n    FastScanner sc;\n    PrintWriter out;\n\n\n\n    public static void main(String[] args){\n        new Main().run();\n//        new Thread( null, new Runnable() {\n//            @Override\n//            public void run() {\n//                new Main().run();\n//            }\n//            }, \"LOL\", 256L * 1024 * 1024 / 2 ).run();\n//        }, \"LOL\", 2000 * 1024 * 1024 ).run();\n    }\n\n\n\n    void TLE(){ for(;;); }\n\n    void MLE(){\n        int[][] adj = new int[1024*1024][];\n        for( int i = 0; i < adj.length; ++i )\n            adj[i] = new int[1024*1024];\n    }\n\n    void exit( int val ){\n        out.flush();\n        System.exit(val);\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////\n\n    int n, m;\n    boolean[][] grid;\n    ArrayList<Integer>[] gr;\n    int c;\n    int[] mt;\n    boolean[] u;\n\n\n    boolean try_kuhn( int v ){\n        if( u[v] ) return false;\n        u[v] = true;\n        for( int to : gr[v] ){\n            if( to == c || !grid[v][to] ) continue;\n            if( mt[to]==-1 || try_kuhn(mt[to]) ){\n                mt[to] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void solve(){\n        n = sc.nextInt();\n        m = sc.nextInt();\n        grid = new boolean[n+1][n+1];\n        gr = new ArrayList[n+1];\n        for( int v = 1; v <= n; ++v ) gr[v] = new ArrayList<Integer>();\n        for( int it = 0; it < m; ++it ){\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            grid[a][b] = true;\n            gr[a].add(b);\n        }\n\n        int ans = Integer.MAX_VALUE;\n        for( c = 1; c <= n; ++c ){\n            int curAns = 0;\n            for( int v = 1; v <= n; ++v )\n                if( v != c ){\n                    if( !grid[c][v] ) ++curAns;\n                    if( !grid[v][c] ) ++curAns;\n                }\n            if( !grid[c][c] ) ++curAns;\n\n            mt = new int[n+1];\n            fill( mt, -1 );\n            for( int i = 1; i <= n; ++i )\n                if( i != c ){\n                    u = new boolean[n+1];\n                    try_kuhn(i);\n                }\n\n            int szMt = 0;\n            for( int i = 1; i <= n; ++i )\n                if( mt[i] != -1 )\n                    ++szMt;\n            curAns += n - 1 - szMt;\n\n            for( int a = 1; a <= n; ++a ){\n            for( int b : gr[a] ){\n                if( a==c || b==c || !grid[a][b]\n                ) continue;\n                if(!( a==mt[b] ))\n                    ++curAns;\n            }\n            }\n\n//            out.printf( \"%d %d\\n\", c, curAns );\n            ans = min( ans, curAns );\n        }\n        out.println( ans );\n    }\n\n\n\n}\n", "complexity": "cubic", "problem": "0387_D", "from": "CODEFORCES", "tags": "graph matchings"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tFastReader sc=new FastReader();\n\t\tlong n=sc.L();\n\t\tlong s=sc.L();\n\t\t\n\t\t    long m=binarysearch(1,n,s);\n\t\t    if(rbn(m,s))\n\t\t    System.out.println(n-m+1);\n\t\t    else\n\t\t    System.out.println(n-m);\n\t\t\n\t//\tSystem.out.println(n+1-binarysearch(1,n,s));\n        \n\t }\n\t static boolean rbn(long n,long s)\n\t {\n\t     long a=n,sum=0;\n\t     while(a>0)\n\t\t{\n\t\t    sum+=a%10;\n\t\t    a/=10;\n\t\t}\n\t\tif(n-sum>=s)\n\t\treturn true;\n\t\telse\n\t\treturn false;\n\t }\n\t static long binarysearch(long s,long e,long m)\n\t {\n\t     while(s!=e)\n\t     {\n\t         if(rbn((s+e)/2,m))\n\t         e=(s+e)/2-1;\n\t         else{\n\t         s=(s+e)/2+1;\n\t         if(rbn(s,m))\n\t         return s;\n\t         }\n\t     }\n\t     return s;\n\t }\n\t  static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int I() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long L() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double D() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n    static int gcd(int a,int b)\n\t\t{\n\t\t    if(a%b==0)\n\t\t    return b;\n\t\t    return gcd(b,a%b);\n\t\t}\n\tstatic float power(float x, int y) \n    { \n        float temp; \n        if( y == 0) \n            return 1; \n        temp = power(x, y/2);  \n          \n        if (y%2 == 0) \n            return temp*temp; \n        else\n        { \n            if(y > 0) \n                return x * temp * temp; \n            else\n                return (temp * temp) / x; \n        } \n    } \n    static long pow(int a,int b)\n    {\n        long result=1;\n        if(b==0)\n        return 1;\n        long x=a;\n        while(b>0)\n        {\n            if(b%2!=0)\n            result*=x;\n            \n            x=x*x;\n            b=b/2;\n        }\n        return result;\n    }\n    \n    static ArrayList<Integer> sieveOfEratosthenes(int n) \n    { \n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        boolean prime[] = new boolean[n+1]; \n        for(int i=2;i<n;i++) \n            prime[i] = true; \n          \n        for(int p = 2; p*p <=n; p++) \n        { \n            if(prime[p] == true) \n            { \n                arr.add(p);\n                for(int i = p*p; i <= n; i += p) \n                    prime[i] = false; \n            } \n        } \n        return arr;\n    } \n}", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\t\n\tclass Segment {\n\t\tint l, r;\n\t\tSegment(int l, int r) {\n\t\t\tthis.l = l;\n\t\t\tthis.r = r;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tSegment o = (Segment)obj;\n\t\t\treturn l == o.l && r == o.r;\n\t\t}\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn 1000 * l + r;\n\t\t}\n\t}\n\n\tpublic void _main() throws IOException {\n\t\tint n = nextInt();\n\t\tint t = nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nextInt();\n\t\t\ta[i] = nextInt();\n\t\t}\t\t\n\t\tSet<Segment> set = new HashSet<Segment>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint l = 2 * x[i] + a[i];\n\t\t\tint r = 2 * x[i] + a[i] + 2 * t;\n\t\t\tboolean ok = true;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tint L = Math.max(l, 2 * x[j] - a[j]);\n\t\t\t\tint R = Math.min(r, 2 * x[j] + a[j]);\t\t\t\t\n\t\t\t\tif (L < R) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok)\n\t\t\t\tset.add(new Segment(l, r));\n\t\t\t\n\t\t\tl = 2 * x[i] - a[i] - 2 * t;\n\t\t\tr = 2 * x[i] - a[i];\t\t\t\n\t\t\tok = true;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tint L = Math.max(l, 2 * x[j] - a[j]);\n\t\t\t\tint R = Math.min(r, 2 * x[j] + a[j]);\n\t\t\t\tif (L < R) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok)\n\t\t\t\tset.add(new Segment(l, r));\n\t\t}\n\t\tout.print(set.size());\n\t}\n\n\tprivate BufferedReader in;\n\tprivate PrintWriter out;\n\tprivate StringTokenizer st;\n\n\tprivate String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString rl = in.readLine();\n\t\t\tif (rl == null)\n\t\t\t\treturn null;\n\t\t\tst = new StringTokenizer(rl);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new Main()).start();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\t_main();\n\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(202);\n\t\t}\n\t}\n\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class DivRound584ProblemA {\n\tstatic FastReader sc=new FastReader();\n\t\n\tpublic static void main(String args[]) throws IOException {\n\t\tint n = sc.nextInt();\n\t\t\n\t\tint a[]=new int[n];\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=sc.nextInt();\n\t\t\n\t\tArrays.sort(a);\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(a[i]<0) continue;\n\t\t\tc=c-1;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif(a[j]<0) continue;\n\t\t\t\tif(a[j]%a[i]==0) {\n\t\t\t\t\t//System.out.println(a[i]+\" : \"+a[j]);\n\t\t\t\t\ta[j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(c);\n\t\t}\n\t\tSystem.out.println(Math.abs(c));\n\t}\n\t\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collection;\nimport java.util.List;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author AlexFetisov\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n\n    private double[][][] dp;\n    private int n;\n    private int k;\n    private int[] loyalty;\n    private int[] level;\n    double[] P;\n    private int a;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        n = in.nextInt();\n        k = in.nextInt();\n        a = in.nextInt();\n        level = new int[n];\n        loyalty = new int[n];\n        for (int i = 0; i < n; ++i) {\n            level[i] = in.nextInt();\n            loyalty[i] = in.nextInt();\n        }\n\n        P = new double[1 << n];\n        for (int mask = 0; mask < (1 << n); ++mask) {\n            if (Integer.bitCount(mask) * 2 > n) {\n                P[mask] = 1.;\n            } else {\n                double sumB = 0;\n                for (int i = 0; i < n; ++i) {\n                    if (!BitUtils.checkBit(mask, i)) {\n                        sumB += level[i];\n                    }\n                }\n                P[mask] = (double)a / (sumB + a);\n            }\n        }\n\n        dp = new double[1 << n][n + 1][k + 1];\n        ArrayUtils.fill(dp, -1);\n        newLoyalty = new int[n];\n        //double res = rec(0, 0, k, 0);\n        brute(0, k);\n        out.println(best);\n    }\n\n    int[] newLoyalty;\n    double best = 0;\n\n    void brute(int id, int leftCandies) {\n        if (id == n) {\n            double cur = calcCur();\n            if (best < cur) {\n                best = cur;\n            }\n            return;\n        }\n        for (int candies = 0; candies <= leftCandies; ++candies) {\n            newLoyalty[id] = loyalty[id] + candies * 10;\n            if (newLoyalty[id] > 100) {\n                break;\n            }\n            brute(id + 1, leftCandies - candies);\n        }\n    }\n\n    private double calcCur() {\n        double sum = 0;\n        for (int mask = 0; mask < (1 << n); ++mask) {\n            double p = getP(mask) * P[mask];\n            sum += p;\n        }\n        return sum;\n    }\n\n    private double getP(int mask) {\n        double p = 1;\n        for (int i = 0; i < n; ++i) {\n            if (BitUtils.checkBit(mask, i)) {\n                p *= (newLoyalty[i] * 1.) / 100.;\n            } else {\n                p *= (100. - newLoyalty[i]) / 100.;\n            }\n        }\n        return p;\n    }\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer stt;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine().trim();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public String nextString() {\n        while (stt == null || !stt.hasMoreTokens()) {\n            stt = new StringTokenizer(nextLine());\n        }\n        return stt.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n}\n\nclass BitUtils {\n    public static boolean checkBit(int mask, int bit) {\n        return (mask & (1 << bit)) > 0;\n    }\n\n}\n\nclass ArrayUtils {\n\n    public static void fill(double[][][] f, double value) {\n        for (int i = 0; i < f.length; ++i) {\n            for (int j = 0; j < f[i].length; ++j) {\n                Arrays.fill(f[i][j], value);\n            }\n        }\n    }\n\n}\n\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int best = 1;\n        int bestTime = Integer.MAX_VALUE;\n        for(int i=0;i<n;i++) {\n            int time;\n            int a = sc.nextInt();\n            time = (a%n==0 || a%n<=i) ? a/n : (a+n)/n;\n            if(time < bestTime) {\n                best = i + 1;\n                bestTime = time;\n            }\n        }\n\n        pw.println(best);\n        pw.close();\n    }\n}\n", "complexity": "linear", "problem": "0996_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.Comparator;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int count = in.readInt();\n        int[] array = IOUtils.readIntArray(in, count);\n        int[] sorted = array.clone();\n        ArrayUtils.sort(sorted, IntComparator.DEFAULT);\n        int differs = 0;\n        for (int i = 0; i < count; i++) {\n            if (array[i] != sorted[i])\n                differs++;\n        }\n        if (differs <= 2)\n            out.printLine(\"YES\");\n        else\n            out.printLine(\"NO\");\n    }\n}\n\nclass InputReader {\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n    }\n\nclass IOUtils {\n\n    public static int[] readIntArray(InputReader in, int size) {\n        int[] array = new int[size];\n        for (int i = 0; i < size; i++)\n            array[i] = in.readInt();\n        return array;\n    }\n\n    }\n\nclass ArrayUtils {\n    private static int[] tempInt = new int[0];\n\n    public static int[] sort(int[] array, IntComparator comparator) {\n        return sort(array, 0, array.length, comparator);\n    }\n\n    public static int[] sort(int[] array, int from, int to, IntComparator comparator) {\n        ensureCapacityInt(to - from);\n        System.arraycopy(array, from, tempInt, 0, to - from);\n        sortImpl(array, from, to, tempInt, 0, to - from, comparator);\n        return array;\n    }\n\n    private static void ensureCapacityInt(int size) {\n        if (tempInt.length >= size)\n            return;\n        size = Math.max(size, tempInt.length << 1);\n        tempInt = new int[size];\n    }\n\n    private static void sortImpl(int[] array, int from, int to, int[] temp, int fromTemp, int toTemp, IntComparator comparator) {\n        if (to - from <= 1)\n            return;\n        int middle = (to - from) >> 1;\n        int tempMiddle = fromTemp + middle;\n        sortImpl(temp, fromTemp, tempMiddle, array, from, from + middle, comparator);\n        sortImpl(temp, tempMiddle, toTemp, array, from + middle, to, comparator);\n        int index = from;\n        int index1 = fromTemp;\n        int index2 = tempMiddle;\n        while (index1 < tempMiddle && index2 < toTemp) {\n            if (comparator.compare(temp[index1], temp[index2]) <= 0)\n                array[index++] = temp[index1++];\n            else\n                array[index++] = temp[index2++];\n        }\n        if (index1 != tempMiddle)\n            System.arraycopy(temp, index1, array, index, tempMiddle - index1);\n        if (index2 != toTemp)\n            System.arraycopy(temp, index2, array, index, toTemp - index2);\n    }\n\n    }\n\ninterface IntComparator {\n    public static final IntComparator DEFAULT = new IntComparator() {\n        public int compare(int first, int second) {\n            if (first < second)\n                return -1;\n            if (first > second)\n                return 1;\n            return 0;\n        }\n    };\n\n    public int compare(int first, int second);\n}", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.Scanner;\n\npublic class SportMafia {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\t\n\t\tint next = 1;\n\t\tint current = 0;\n\t\tint result = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(current < k) {\n\t\t\t\tcurrent += next++;\n\t\t\t} else {\n\t\t\t\tcurrent--;\n\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(result);\n\t\t\n\t\tsc.close();\n\t}\n}\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tFastReader sc=new FastReader();\n\t\tlong n=sc.L();\n\t\tlong k=sc.L();\n\t\tlong x=8*(n+k);\n\t\tx+=9;\n\t\tx=(long)Math.sqrt(x)-3;\n\t\tx/=2;\n\t\t\n\t\tSystem.out.println(n-x);\n\t }\n\t static int binarysearch(int x,int[] b,int n)\n\t {\n\t     int l=0,r=n-1,m=(l+r)/2;\n\t     if(x<b[0]||x>b[r])\n\t     return -1;\n\t     while(l<=r)\n\t     {\n\t         m=(l+r)/2;\n\t         if(b[m]==x)\n\t         return m;\n\t         if(b[m]>x)\n\t         r=m-1;\n\t         else\n\t         l=m+1;\n\t     }\n\t     return -1;\n\t }\n\t static int lower(int x,int b[],int n)\n\t {\n\t     if(x<b[0])\n\t     return -1;\n\t     else if(x==b[0])\n\t     return 0;\n\t     if(x>=b[n-1])\n\t     return n-1;\n\t     int l=0,r=n-1,m=(l+r)/2;\n\t     while(l<=r)\n\t     {\n\t         m=(l+r)/2;\n\t         if(b[m]<=x&&b[m+1]>x)\n\t         return m;\n\t         else if(b[m]>x&&b[m-1]<=x)\n\t         return m-1;\n\t         if(b[m]>x)\n\t         r=m-1;\n\t         else if(b[m]<x)\n\t         l=m+1;\n\t     }\n\t     return -1;\n\t }\n\t static int upper(int x,int b[],int n)\n\t {\n\t     if(x<=b[0])\n\t     return 0;\n\t     else if(x==b[n-1])\n\t     return n-1;\n\t     if(x>b[n-1])\n\t     return -1;\n\t     int l=0,r=n-1,m=(l+r)/2;\n\t     while(l<=r)\n\t     {\n\t         m=(l+r)/2;\n\t         if(b[m]<x&&b[m+1]>=x)\n\t         return m+1;\n\t         else if(b[m]>=x&&b[m-1]<x)\n\t         return m;\n\t         if(b[m]>x)\n\t         r=m-1;\n\t         else if(b[m]<x)\n\t         l=m+1;\n\t     }\n\t     return -1;\n\t }\n\t \n\t static long power(long x, long y, long p) \n    { \n        // Initialize result \n        long res = 1;      \n         \n        // Update x if it is more   \n        // than or equal to p \n        x = x % p;  \n      \n        while (y > 0) \n        { \n            // If y is odd, multiply x \n            // with result \n            if((y & 1)==1) \n                res = (res * x) % p; \n      \n            // y must be even now \n            // y = y / 2 \n            y = y >> 1;  \n            x = (x * x) % p;  \n        } \n        return res; \n    } \n\t  static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int I() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long L() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double D() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n    static int gcd(int a,int b)\n\t\t{\n\t\t    if(a%b==0)\n\t\t    return b;\n\t\t    return gcd(b,a%b);\n\t\t}\n\tstatic float power(float x, int y) \n    { \n        float temp; \n        if( y == 0) \n            return 1; \n        temp = power(x, y/2);  \n          \n        if (y%2 == 0) \n            return temp*temp; \n        else\n        { \n            if(y > 0) \n                return x * temp * temp; \n            else\n                return (temp * temp) / x; \n        } \n    } \n    static long pow(int a,int b)\n    {\n        long result=1;\n        if(b==0)\n        return 1;\n        long x=a;\n        while(b>0)\n        {\n            if(b%2!=0)\n            result*=x;\n            \n            x=x*x;\n            b=b/2;\n        }\n        return result;\n    }\n    \n    static ArrayList<Integer> sieveOfEratosthenes(int n) \n    { \n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        boolean prime[] = new boolean[n+1]; \n        for(int i=2;i<n;i++) \n            prime[i] = true; \n          \n        for(int p = 2; p*p <=n; p++) \n        { \n            if(prime[p] == true) \n            { \n                arr.add(p);\n                for(int i = p*p; i <= n; i += p) \n                    prime[i] = false; \n            } \n        } \n        return arr;\n    } \n}", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "    import java.io.*;\n    import java.util.*;\n    import java.math.*;\n    import java.lang.*;\n     \n     //@Manan Parmar\n\n    public class Solution2 implements Runnable {\n\n\n        public void run() {\n            \n            InputReader sc = new InputReader(System.in);\n            PrintWriter out = new PrintWriter(System.out);\n            \n            int n=sc.nextInt();\n            out.println((n/2)+1);\n\n            out.close();\n        }\n     \n\n    //========================================================================\n        void quickSort(int a[],int l,int r)\n        {\n            if(l<r)\n            {\n                int pindex=partition(a,l,r);\n                quickSort(a,l,pindex-1);\n                quickSort(a,pindex+1,r);\n            }\n\n        }\n        int partition(int a[],int l,int r)\n        {\n            int pivot = a[r],pindex=l;\n            for(int i=l;i<r;i++)\n            {\n                if(a[i]<pivot)\n                {\n                    int temp=a[i];\n                    a[i]=a[pindex];\n                    a[pindex]=temp;\n                    pindex++;\n                }\n            }\n            int temp1=a[r];\n            a[r]=a[pindex];\n            a[pindex]=temp1;\n            return pindex;\n        }\n        int binarySearch(int arr[], int x) \n        { \n            int l = 0, r = arr.length - 1; \n            while (l <= r) { \n                int m = l + (r - l) / 2; \n      \n                // Check if x is present at mid \n                if (arr[m] >= x)\n                    if(m!=0&&arr[m-1]<x) \n                        return m;\n                    else if(m==0)\n                        return m; \n      \n                // If x greater, ignore left half \n                if (arr[m] < x) \n                    l = m + 1; \n      \n                // If x is smaller, ignore right half \n                else\n                    r = m - 1; \n            } \n      \n            // if we reach here, then element was \n            // not present \n            return -1; \n        } \n        boolean check(char a,char b)\n        {\n            if(a==b)\n                return true;\n            else\n                return false;\n        }\n        long binarySearch(long arr[], long x) \n        { \n            int l = 0, r = arr.length - 1,q=0; \n            while (l<=r) { \n                int m = l + (r - l) / 2; \n                if (arr[l] >=x) \n                {\n                    q=1;\n                    return l; \n                }\n                if (arr[m] < x) \n                    l=m+1; \n                else\n                    r=m;\n            } \n            return -1;\n        }\n\n        static class InputReader {\n            private InputStream stream;\n            private byte[] buf = new byte[1024];\n            private int curChar;\n            private int numChars;\n            private SpaceCharFilter filter;\n            private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n     \n            public InputReader(InputStream stream) {\n                this.stream = stream;\n            }\n           \n            public int read() {\n                if (numChars==-1)\n                    throw new InputMismatchException();\n               \n                if (curChar >= numChars) {\n                    curChar = 0;\n                    try {\n                        numChars = stream.read(buf);\n                    }\n                    catch (IOException e) {\n                        throw new InputMismatchException();\n                    }\n                   \n                    if(numChars <= 0)              \n                        return -1;\n                }\n                return buf[curChar++];\n            }\n         \n            public String nextLine() {\n                String str = \"\";\n                try {\n                    str = br.readLine();\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return str;\n            }\n            public int nextInt() {\n                int c = read();\n               \n                while(isSpaceChar(c))\n                    c = read();\n               \n                int sgn = 1;\n               \n                if (c == '-') {\n                    sgn = -1;\n                    c = read();\n                }\n               \n                int res = 0;\n                do {\n                    if(c<'0'||c>'9')\n                        throw new InputMismatchException();\n                    res *= 10;\n                    res += c - '0';\n                    c = read();\n                }\n                while (!isSpaceChar(c));\n               \n                return res * sgn;\n            }\n           \n            public long nextLong() {\n                int c = read();\n                while (isSpaceChar(c))\n                    c = read();\n                int sgn = 1;\n                if (c == '-') {\n                    sgn = -1;\n                    c = read();\n                }\n                long res = 0;\n               \n                do {\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    res *= 10;\n                    res += c - '0';\n                    c = read();\n                }\n                while (!isSpaceChar(c));\n                    return res * sgn;\n            }\n           \n            public double nextDouble() {\n                int c = read();\n                while (isSpaceChar(c))\n                    c = read();\n                int sgn = 1;\n                if (c == '-') {\n                    sgn = -1;\n                    c = read();\n                }\n                double res = 0;\n                while (!isSpaceChar(c) && c != '.') {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    res *= 10;\n                    res += c - '0';\n                    c = read();\n                }\n                if (c == '.') {\n                    c = read();\n                    double m = 1;\n                    while (!isSpaceChar(c)) {\n                        if (c == 'e' || c == 'E')\n                            return res * Math.pow(10, nextInt());\n                        if (c < '0' || c > '9')\n                            throw new InputMismatchException();\n                        m /= 10;\n                        res += (c - '0') * m;\n                        c = read();\n                    }\n                }\n                return res * sgn;\n            }\n           \n            public String readString() {\n                int c = read();\n                while (isSpaceChar(c))\n                    c = read();\n                StringBuilder res = new StringBuilder();\n                do {\n                    res.appendCodePoint(c);\n                    c = read();\n                }\n                while (!isSpaceChar(c));\n               \n                return res.toString();\n            }\n         \n            public boolean isSpaceChar(int c) {\n                if (filter != null)\n                    return filter.isSpaceChar(c);\n                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n            }\n         \n            public String next() {\n                return readString();\n            }\n           \n            public interface SpaceCharFilter {\n                public boolean isSpaceChar(int ch);\n            }\n        }\n\n        public static void main(String args[]) throws Exception {\n            new Thread(null, new Solution2(),\"Main\",1<<27).start();\n        }\n    }\n", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1187G extends PrintWriter {\n\tCF1187G() { super(System.out); }\n\tstatic class Scanner {\n\t\tScanner(InputStream in) { this.in = in; } InputStream in;\n\t\tint k, l; byte[] bb = new byte[1 << 15];\n\t\tbyte getc() {\n\t\t\tif (k >= l) {\n\t\t\t\tk = 0;\n\t\t\t\ttry { l = in.read(bb); } catch (IOException e) { l = 0; }\n\t\t\t\tif (l <= 0) return -1;\n\t\t\t}\n\t\t\treturn bb[k++];\n\t\t}\n\t\tint nextInt() {\n\t\t\tbyte c = 0; while (c <= 32) c = getc();\n\t\t\tint a = 0;\n\t\t\twhile (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n\t\t\treturn a;\n\t\t}\n\t}\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1187G o = new CF1187G(); o.main(); o.flush();\n\t}\n\n\tstatic final int INF = 0x3f3f3f3f;\n\tArrayList[] aa_;\n\tint n_, m_;\n\tint[] pi, dd, bb;\n\tint[] uu, vv, uv, cost;\n\tboolean[] iq;\n\tint[] cc;\n\tvoid init() {\n\t\taa_ = new ArrayList[n_];\n\t\tfor (int u = 0; u < n_; u++)\n\t\t\taa_[u] = new ArrayList<Integer>();\n\t\tpi = new int[n_];\n\t\tdd = new int[n_];\n\t\tbb = new int[n_];\n\t\tiq = new boolean[n_];\n\t\tuu = new int[m_];\n\t\tvv = new int[m_];\n\t\tuv = new int[m_];\n\t\tcost = new int[m_];\n\t\tcc = new int[m_ * 2];\n\t\tm_ = 0;\n\t}\n\tvoid link(int u, int v, int cap, int cos) {\n\t\tint h = m_++;\n\t\tuu[h] = u;\n\t\tvv[h] = v;\n\t\tuv[h] = u ^ v;\n\t\tcost[h] = cos;\n\t\tcc[h << 1 ^ 0] = cap;\n\t\taa_[u].add(h << 1 ^ 0);\n\t\taa_[v].add(h << 1 ^ 1);\n\t}\n\tboolean dijkstra(int s, int t) {\n\t\tArrays.fill(pi, INF);\n\t\tpi[s] = 0;\n\t\tTreeSet<Integer> pq = new TreeSet<>((u, v) -> pi[u] != pi[v] ? pi[u] - pi[v] : dd[u] != dd[v] ? dd[u] - dd[v] : u - v);\n\t\tpq.add(s); iq[s] = true;\n\t\tInteger first;\n\t\twhile ((first = pq.pollFirst()) != null) {\n\t\t\tint u = first;\n\t\t\tiq[u] = false;\n\t\t\tint d = dd[u] + 1;\n\t\t\tArrayList<Integer> adj = aa_[u];\n\t\t\tfor (int h_ : adj)\n\t\t\t\tif (cc[h_] > 0) {\n\t\t\t\t\tint h = h_ >> 1;\n\t\t\t\t\tint p = pi[u] + ((h_ & 1) == 0 ? cost[h] : -cost[h]);\n\t\t\t\t\tint v = u ^ uv[h];\n\t\t\t\t\tif (pi[v] > p || pi[v] == p && dd[v] > d) {\n\t\t\t\t\t\tif (iq[v]) {\n\t\t\t\t\t\t\tpq.remove(v); iq[v] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpi[v] = p;\n\t\t\t\t\t\tdd[v] = d;\n\t\t\t\t\t\tbb[v] = h_;\n\t\t\t\t\t\tpq.add(v); iq[v] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn pi[t] != INF;\n\t}\n\tvoid push(int s, int t) {\n\t\tint c = INF;\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tc = Math.min(c, cc[h_]);\n\t\t}\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_] -= c; cc[h_ ^ 1] += c;\n\t\t}\n\t}\n\tvoid push1(int s, int t) {\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_]--; cc[h_ ^ 1]++;\n\t\t}\n\t}\n\tint edmonds_karp(int s, int t) {\n\t\twhile (dijkstra(s, t))\n\t\t\tpush1(s, t);\n\t\tint c = 0;\n\t\tfor (int h = 0; h < m_; h++)\n\t\t\tc += cost[h] * cc[h << 1 ^ 1];\n\t\treturn c;\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tint[] ii = new int[k];\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tii[h] = sc.nextInt() - 1;\n\t\tArrayList[] aa = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = new ArrayList<Integer>();\n\t\tfor (int h = 0; h < m; h++) {\n\t\t\tint i = sc.nextInt() - 1;\n\t\t\tint j = sc.nextInt() - 1;\n\t\t\taa[i].add(j);\n\t\t\taa[j].add(i);\n\t\t}\n\t\tint t = n + k + 1;\n\t\tn_ = n * t + 1;\n\t\tm_ = k + (m * 2 * k + n) * (t - 1);\n\t\tinit();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrayList<Integer> adj = aa[i];\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s;\n\t\t\t\tfor (int j : adj) {\n\t\t\t\t\tint v = j * t + s + 1;\n\t\t\t\t\tfor (int x = 1; x <= k; x++)\n\t\t\t\t\t\tlink(u, v, 1, c + (x * 2 - 1) * d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s, v = u + 1;\n\t\t\t\tlink(u, v, k, i == 0 ? 0 : c);\n\t\t\t}\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tlink(n_ - 1, ii[h] * t + 0, 1, 0);\n\t\tprintln(edmonds_karp(n_ - 1, 0 * t + t - 1));\n\t}\n}\n", "complexity": "cubic", "problem": "1187_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int[] ar = new int[n];\n        for (int i = 0; i < n; i++) {\n            ar[i] = sc.nextInt();\n        }\n        Arrays.sort(ar);\n        if (ar[b-1] == ar[b ]) {\n            System.out.println(0);\n        } else {\n            System.out.println(ar[b ] - ar[b-1]);\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.util.*;\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++) a[i] = s.nextInt();\n\t\tint r = 0, an = 0;\n\t\tArrays.sort(a);\n\t\tint t = 0;\n\t\tfor(int z : a) t += z;\n\t\tfor(int i=a.length-1;i>=0;i--){\n\t\t\tr += a[i];\n\t\t\tan++;\n\t\t\tif (r > t - r) break;\n\t\t}\n\t\tSystem.out.println(an);\n\t}\n}", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "/*\nRoses are red\nMemes are neat\nAll my test cases time out\nLmao yeet\n*/\nimport java.util.*;\nimport java.io.*;\n\n   public class x1185G1b\n   {\n      static long MOD = 1000000007L;\n      public static void main(String args[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));  \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int T = Integer.parseInt(st.nextToken());\n         Song[] arr = new Song[N];\n         for(int i=0; i < N; i++)\n         {\n            st = new StringTokenizer(infile.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken())-1;\n            arr[i] = new Song(a, b);\n         }\n         //bitmask\n         long[][] dp = new long[1 << N][3];\n         Arrays.fill(dp[0], 1L);\n         for(int mask=0; mask < dp.length; mask++)\n         {\n            for(int i=0; i < N; i++)\n               if((mask & (1 << i)) == 0)\n               {\n                  Song c = arr[i];\n                  //continue all dp if mask == 0\n                  if(mask == 0 && c.t <= T)\n                  {\n                     dp[mask|(1 << i)][c.g]++;\n                     dp[mask|(1 << i)][c.g] %= MOD;\n                  }\n                  //continue dp if not same genre\n                  else\n                  {\n                     for(int gen=0; gen < 3; gen++)\n                        if(gen != c.g)\n                        {\n                           dp[mask|(1 << i)][c.g] += dp[mask][gen];\n                           dp[mask|(1 << i)][c.g] %= MOD;\n                        }\n                        //optimize?\n                  }\n               }\n         }\n         long res = 0L;\n         for(int mask=1; mask < dp.length; mask++)\n            for(int i=0; i < 3; i++)\n            {\n               int sum = 0;\n               for(int b=0; b < N; b++)\n                  if((mask & (1 << b)) > 0)\n                     sum += arr[b].t;\n               if(sum == T)\n                  res = (res+dp[mask][i])%MOD;\n            }\n         System.out.println(res);\n      }\n   }\n   class Song\n   {\n      public int t;\n      public int g;\n      \n      public Song(int a, int b)\n      {\n         t = a;\n         g = b;\n      }\n   }\n   //cheerios are good for your heart, but are they good for your brain?", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "//package timus;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.StreamTokenizer;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class Abra {\n    public static void main(String[] args) throws IOException {\n        new Abra().run();\n    }\n\n    StreamTokenizer in;\n    PrintWriter out;\n    boolean oj;\n\n    void init() throws IOException {\n        oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        Reader reader = oj ? new InputStreamReader(System.in) : new FileReader(\n                \"input.txt\");\n        Writer writer = oj ? new OutputStreamWriter(System.out)\n                : new FileWriter(\"output.txt\");\n        in = new StreamTokenizer(new BufferedReader(reader));\n        out = new PrintWriter(writer);\n    }\n\n    void run() throws IOException {\n        long beginTime = System.currentTimeMillis();\n        init();\n        solve();\n        out.flush();\n    }\n\n    void printMem() {\n        if (!oj) {\n            System.out.println(\"Memory used = \"\n                    + (Runtime.getRuntime().totalMemory() - Runtime\n                            .getRuntime().freeMemory()));\n        }\n    }\n\n    int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    long nextLong() throws IOException {\n        in.nextToken();\n        return (long) in.nval;\n    }\n\n    String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    double nextDouble() throws IOException {\n        in.nextToken();\n        return in.nval;\n    }\n\n    long deg(long x, long y) {\n        long a = x;\n        for (long i = 2; i <= y; i++) {\n            a *= x;\n        }\n        return a;\n    }\n\n    long fact(long x) {\n        long a = 1;\n        for (long i = 2; i <= x; i++) {\n            a *= i;\n        }\n        return a;\n    }\n\n    long digitSum(String x) {\n        long a = 0;\n        for (int i = 0; i < x.length(); i++) {\n            a += x.codePointAt(i) - 48;\n        }\n        return a;\n    }\n\n    long digitSum(long x) {\n        long a = 0;\n        while (x > 0) {\n            a += x % 10;\n            x /= 10;\n        }\n        return a;\n    }\n\n    long digitMul(long x) {\n        long a = 1;\n        while (x > 0) {\n            a *= x % 10;\n            x /= 10;\n        }\n        return a;\n    }\n    \n    int digitCubesSum(int x) {\n        int a = 0;\n        while (x > 0) {\n            a += (x % 10) * (x % 10) * (x % 10);\n            x /= 10;\n        }\n        return a;\n    }\n\n    double pif(double ax, double ay, double bx, double by) {\n        return Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by));\n    }\n\n    double getPosPart(double x) {\n        if (x <= 0)\n            return 0;\n        else\n            return x;\n    }\n\n    double max(double x, double y) {\n        if (x > y)\n            return x;\n        else\n            return y;\n    }\n\n    long gcd(long a, long b) {\n        if (a < b) {\n            long c = b;\n            b = a;\n            a = c;\n        }\n        while (a % b != 0) {\n            a = a % b;\n            if (a < b) {\n                long c = b;\n                b = a;\n                a = c;\n            }\n        }\n        return b;\n    }\n\n    int gcd(int a, int b) {\n        if (a < b) {\n            int c = b;\n            b = a;\n            a = c;\n        }\n        while (a % b != 0) {\n            a = a % b;\n            if (a < b) {\n                int c = b;\n                b = a;\n                a = c;\n            }\n        }\n        return b;\n    }\n\n    long lcm(long a, long b) throws IOException {\n        return a * b / gcd(a, b);\n    }\n\n    int lcm(int a, int b) throws IOException {\n        return a * b / gcd(a, b);\n    }\n\n    int countOccurences(String x, String y) {\n        int a = 0, i = 0;\n        while (true) {\n            i = y.indexOf(x);\n            if (i == -1)\n                break;\n            a++;\n            y = y.substring(i + 1);\n        }\n        return a;\n    }\n\n    int[] primes;\n\n    int findPrimes(int x) {\n        boolean[] forErato = new boolean[x];\n        primes = new int[x];\n        int l = 0, j = 0;\n        for (int i = 2; i < x; i++) {\n            if (forErato[i])\n                continue;\n            l++;\n            primes[l] = i;\n            j = i * 2;\n            while (j < x) {\n                forErato[j] = true;\n                j += i;\n            }\n        }\n        return l;\n    }\n\n    int rev(int x) {\n        int a = 0;\n        while (x > 0) {\n            a = a * 10 + x % 10;\n            x /= 10;\n        }\n        return a;\n    }\n\n    class myDate {\n        int d, m, y;\n\n        public myDate(int da, int ma, int ya) {\n            d = da;\n            m = ma;\n            y = ya;\n        }\n\n        int[] ml = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\n        void inc() {\n            if ((d == 31) && (m == 12)) {\n                y++;\n                d = 1;\n                m = 1;\n            } else {\n                if (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)) {\n                    ml[1] = 29;\n                }\n                if (d == ml[m - 1]) {\n                    m++;\n                    d = 1;\n                } else\n                    d++;\n            }\n        }\n    }\n\n    int partition(int n, int l, int m) {// n - sum, l - length, m - every part\n        // <= m\n        if (n < l)\n            return 0;\n        if (n < l + 2)\n            return 1;\n        if (l == 1)\n            return 1;\n        int c = 0;\n        for (int i = Math.min(n - l + 1, m); i >= (n + l - 1) / l; i--) {\n            c += partition(n - i, l - 1, i);\n        }\n        return c;\n    }\n    \n    String s;\n    int l;\n    \n    void solve() throws IOException {\n        s = nextString();\n        l = s.length();\n        int max = 0;\n        for (int i = 0; i < l - 1; i++) {\n            for (int j = i + 1; j < l; j++) {\n                if (countOccurences(s.substring(i, j), s) > 1)\n                    if (j - i > max) max = j - i;\n            }\n        }\n        out.println(max);\n    }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.*;\nimport java.security.SecureRandom;\nimport java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n    \n    \n    \n    \n    public void solve() throws Exception {\n        \n        int n = sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        long h[] = new long[n];\n        \n        for (int i = 0;i < n; ++ i) {\n            h[i] = sc.nextLong();\n        }\n        Arrays.sort(h);\n        long l = h[n - a];\n        long r = h[n - a - 1];\n        out.println(l - r);\n    }\n    \n    \n    \n    \n    /*--------------------------------------------------------------*/\n    \n    static String filename = \"\";\n    static boolean fromFile = false;\n    \n    BufferedReader in;\n    PrintWriter out;\n    FastScanner sc;\n    \n    public static void main(String[] args) {\n        new Thread(null, new Solution(), \"\", 1 << 25).start();\n    }\n   \n    public void run() {\n        try {\n            init();\n            solve();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            out.close();\n        }\n    }\n    \n    void init() throws Exception {\n        if (fromFile) {\n            in = new BufferedReader(new FileReader(filename+\".in\"));\n            out = new PrintWriter(new FileWriter(filename+\".out\"));\n        } else {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n        sc = new FastScanner(in);\n    }\n}\n\nclass FastScanner {\n    \n    BufferedReader reader;\n    StringTokenizer strTok;\n    \n    public FastScanner(BufferedReader reader) {\n        this.reader = reader;\n    }\n    \n    public String nextToken() throws IOException {\n        while (strTok == null || !strTok.hasMoreTokens()) {\n            strTok = new StringTokenizer(reader.readLine());\n        }\n        \n        return strTok.nextToken();\n    }\n    \n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    \n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    \n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    \n    public BigInteger nextBigInteger() throws IOException {\n        return new BigInteger(nextToken());\n    }\n    \n    public BigDecimal nextBigDecimal() throws IOException {\n        return new BigDecimal(nextToken());\n    }\n}", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.util.*;\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        int k = input.nextInt() - 1 ;\n        int a[][] = new int[n][2];\n        for (int i = 0;i <n; i++) {\n            a[i][0]=input.nextInt();\n            a[i][1]=input.nextInt();\n        }\n        for (int i = 0; i<n; i++) {\n            for (int j=i+1; j<n; j++) {\n                if (a[i][0]<a[j][0]) {\n                    int x=a[i][0];\n                    int y=a[i][1];\n                    a[i][0]=a[j][0];\n                    a[i][1]=a[j][1];\n                    a[j][0]=x;\n                    a[j][1]=y;\n                    \n                }\n            }\n        }\n        for (int i = 0; i<n; i++) {\n            for (int j=i+1; j<n; j++) {\n                if ((a[i][1]>a[j][1])&&(a[i][0]==a[j][0])) {\n                    int x=a[i][0];\n                    int y=a[i][1];\n                    a[i][0]=a[j][0];\n                    a[i][1]=a[j][1];\n                    a[j][0]=x;\n                    a[j][1]=y;\n                    \n                }\n            }\n        }\n        int x = a[k][0];\n        int y = a[k][1];\n        int s = 0;\n        for (int i = 0; i<n; i++) {\n            if ((a[i][0]==x)&&(a[i][1]==y)) {\n                s++;\n            }\n        }\n        System.out.println(s);\n    }\n}\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "/**\n * Problem: \n * Source: \n * Link: \n * \n * @author Alexei Ostrovski\n */\n\nimport java.io.*;\nimport java.util.*;\n\n\npublic class SpidersSolver {\n\n\tpublic static final boolean DEBUG = false;\n\t\n\tpublic static void main(String[] args) {\n\t\t//redirect input and output\n\t\tif (DEBUG)\n\t\t{\n\t\t\ttry {\n\t\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n\t\t\t\t//System.setOut(new PrintStream(\"input.txt\"));\n\t\t\t} catch (IOException e) {\n\t\t\t\t//nothing\n\t\t\t}\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t//read data\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\t\n\t\t//solve\n\t\tif (n < m) {\n\t\t\tint tmp = n;\n\t\t\tn = m;\n\t\t\tm = tmp;\n\t\t}\n\t\t// Now (n >= m) && (m <= 6)\n\t\tint pow = 1;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tpow *= 2;\n\n\t\tint[] count = new int[pow];\n\t\tfor (int cur = 0; cur < pow; cur++)\n\t\t{\n\t\t\tint x = cur;\n\t\t\twhile (x > 0)\n\t\t\t{\n\t\t\t\tcount[cur] += (x % 2);\n\t\t\t\tx /= 2;\n\t\t\t}\n\t\t\tcount[cur] = m - count[cur];\n\t\t}\n\t\t//System.out.println(Arrays.toString(count));\n\t\t\n\t\tint[][] C = new int[pow][pow];\n\t\tfor (int cur = 0; cur < pow; cur++)\n\t\t{\n\t\t\tC[0][cur] = 0;//count[cur];\n\t\t\tfor (int last = 1; last < pow; last++)\n\t\t\t\tC[last][cur] = Integer.MIN_VALUE;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint[][] newC = new int[pow][pow];\n\t\t\t\n\t\t\tfor (int cur = 0; cur < pow; cur++)\n\t\t\t\tfor (int next = 0; next < pow; next++)\n\t\t\t\t{\n\t\t\t\t\tint mask = cur | (cur << 1) | (cur >> 1) | next;\n\t\t\t\t\tmask %= pow;\n\t\t\t\t\t\n\t\t\t\t\tint max = 0;\n\t\t\t\t\tfor (int last = 0; last < pow; last++)\n\t\t\t\t\t\tif (((last | mask) == pow - 1) && (max < count[cur] + C[last][cur]))\n\t\t\t\t\t\t\tmax = count[cur] + C[last][cur];\n\t\t\t\t\t\n\t\t\t\t\tnewC[cur][next] = max;\n\t\t\t\t}\n\t\t\tC = newC;\n\t\t}\n\t\t\n\t\tint result = 0;\n\t\tfor (int cur = 0; cur < pow; cur++)\n\t\t\tresult = Math.max(result, C[cur][0]);\n\t\t\t\n\t\t//output\n\t\tSystem.out.println(result);\n\t}\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.util.*;\npublic class P023A {\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n        String line = in.next();\n        \n        HashSet<String> hash = new HashSet<String>();\n        \n        int ans = 0;\n        for (int len = line.length()-1; len > 0; --len)\n        {\n            for (int i = 0; i + len <= line.length(); ++i)\n            {\n                String sub = line.substring(i, i+len);\n                if (hash.contains(sub))\n                {\n                    ans = Math.max(ans, sub.length());\n                }\n                \n                hash.add(sub);\n            }\n        }\n        \n        System.out.println(ans);\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class test {\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner s = new Scanner(System.in);\n\t\tStringTokenizer st = new StringTokenizer(s.nextLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint r = Integer.parseInt(st.nextToken());\n\t\tst = new StringTokenizer(s.nextLine());\n\t\tint[] array = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarray[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tArrayList<State> list = new ArrayList<State>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble currY = r;\n\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\tdouble xDiff = Math.abs(list.get(j).getX() - array[i]);\n\t\t\t\tif (xDiff <= 2 * r) {\n\t\t\t\t\tif (currY < list.get(j).getY() + Math.sqrt(4 * r * r - xDiff * xDiff)) {\n\t\t\t\t\t\tcurrY = list.get(j).getY() + Math.sqrt(4 * r * r - xDiff * xDiff);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist.add(new State(array[i], currY));\n\t\t\tSystem.out.print(currY + \" \");\n\t\t}\n\t\ts.close();\n\t}\n\n\tstatic class State {\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic State(double a, double b) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn y;\n\t\t}\n\t}\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class ProblemB {\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        String[] line = s.readLine().split(\" \");\n        long n = Long.valueOf(line[0]);\n        long y = Long.valueOf(line[1]);\n        long x = Long.valueOf(line[2]);\n        long c = Long.valueOf(line[3]);\n        \n        long min = 0;\n        long max = n*2L+20;\n        for (int cnt = 0 ; cnt < 300 ; cnt++) {\n            long med = (min+max) / 2L;\n            long ct = isok(med, n, x, y, c); \n            if (ct >= c) {\n                max = med;\n            } else {\n                min = med+1;\n            }\n        }\n        \n        long lst = max;\n        for (long d = -2 ; d <= 2 ; d++) {\n            if (max+d >= 0 && isok(max+d, n, x, y, c) >= c) {\n                lst = Math.min(lst, max+d);\n            }\n        }\n        \n        out.println(lst);\n        out.flush();\n    }\n    \n\n    private static long isok(long time, long n, long x, long y, long c) {\n        long total = time * 2 * (time + 1) + 1;\n        long top = y - time;\n        if (top <= 0) {\n            long dy = Math.abs(top)+1;\n            total -= dy*dy;\n            long over = dy - x;\n            if (over >= 1) {\n                total += (1L + over) * over / 2; \n            }\n            over = dy - ((n + 1) - x);\n            if (over >= 1) {\n                total += (1L + over) * over / 2; \n            }\n        }\n        \n        long bottom = y + time;\n        if (bottom > n) {\n            long dy = Math.abs(bottom-n);\n            total -= dy*dy;\n            long over = dy - x;\n            if (over >= 1) {\n                total += (1L + over) * over / 2; \n            }\n            over = dy - ((n + 1) - x);\n            if (over >= 1) {\n                total += (1L + over) * over / 2; \n            }\n        }\n        \n        long left = x - time;\n        if (left <= 0) {\n            long dy = Math.abs(left)+1;\n            total -= dy*dy;\n        }\n\n        long right = x + time;\n        if (right > n) {\n            long dy = Math.abs(right-n);\n            total -= dy*dy;\n        }\n        return total;\n    }\n\n    public static void debug(Object... os){\n        System.err.println(Arrays.deepToString(os));\n    }\n}", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "//package pack;\n\nimport java.util.*;\n\npublic class first\n{\n\tpublic static long power(long x, long y, long p)\n    {\n        long res = 1;\n        x = x % p; \n        while (y > 0)\n        {\tif((y & 1)==1)\n                res = (res * x) % p;\n            y = y >> 1; \n            x = (x * x) % p; \n        }\n        return res;\n    }\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tlong x=sc.nextLong();\n\t\tlong k=sc.nextLong();\n\t\tlong mod=1000000007;\n\t\tif(k==0 || x==0)\n\t\t\tSystem.out.println((2*x)%mod);\n\t\telse\n\t\t{\tlong answer=1;\n\t\t\tanswer+=(power(2,k,mod))*(((2*x)-1)%mod);\n\t\t\tSystem.out.println(answer%mod);\n\t\t}\n\t}\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\n\n\npublic class D_faster {\n\n\n\n\tstatic final int K = 4;\n\n\n\n\tstatic class Node {\n\n\t\tint l, r;\n\n\t\tNode left, right;\n\n\n\n\t\tint[] info;\n\n\n\n\t\tpublic Node(int l, int r, int[] a) {\n\n\t\t\tthis.l = l;\n\n\t\t\tthis.r = r;\n\n\t\t\tif (r - l == 1) {\n\n\t\t\t\tinfo = new int[] { a[l], 1 };\n\n\t\t\t} else {\n\n\t\t\t\tint m = (l + r) >> 1;\n\n\t\t\t\tleft = new Node(l, m, a);\n\n\t\t\t\tright = new Node(m, r, a);\n\n\t\t\t\tinfo = merge(left.info, right.info);\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\tint[] getInfo(int ql, int qr) {\n\n\t\t\tif (ql >= r || l >= qr) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tif (ql <= l && r <= qr) {\n\n\t\t\t\treturn info;\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tint[] infoL = left.getInfo(ql, qr);\n\n\t\t\tint[] infoR = right.getInfo(ql, qr);\n\n\t\t\treturn merge(infoL, infoR);\n\n\t\t}\n\n\n\n\t}\n\n\n\n\tstatic int[] merge(int[] a, int[] b) {\n\n\t\t\n\n\t\tif (a == null) {\n\n\t\t\treturn b;\n\n\t\t}\n\n\t\t\n\n\t\tif (b == null) {\n\n\t\t\treturn a;\n\n\t\t}\n\n\n\n\t\tint[] all = Arrays.copyOf(a, a.length + b.length);\n\n\n\n\t\tint ptr = a.length;\n\n\n\n\t\touter: for (int i = 0; i < b.length; i += 2) {\n\n\n\n\t\t\tint val = b[i];\n\n\t\t\tint cnt = b[i + 1];\n\n\n\n\t\t\tfor (int j = 0; j < ptr; j += 2) {\n\n\t\t\t\tif (val == all[j]) {\n\n\t\t\t\t\tall[j + 1] += cnt;\n\n\t\t\t\t\tcontinue outer;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\t\tall[ptr++] = val;\n\n\t\t\tall[ptr++] = cnt;\n\n\t\t}\n\n\n\n\t\twhile (ptr > 2 * K) {\n\n\t\t\tint idx = -1;\n\n\t\t\tint leastCnt = Integer.MAX_VALUE;\n\n\t\t\tfor (int i = 0; i < ptr; i += 2) {\n\n\t\t\t\tif (all[i + 1] < leastCnt) {\n\n\t\t\t\t\tidx = i;\n\n\t\t\t\t\tleastCnt = all[i + 1];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\t\tall[idx] = all[ptr - 2];\n\n\t\t\tall[idx + 1] = all[ptr - 1];\n\n\t\t\t\n\n\t\t\tptr -= 2;\n\n\t\t\t\n\n\t\t\tfor (int i = 0; i < ptr; i += 2) {\n\n\t\t\t\tall[i + 1] -= leastCnt;\n\n\t\t\t}\n\n\n\n\t\t}\n\n\n\n\t\tall = Arrays.copyOf(all, ptr);\n\n\t\t\n\n//\t\tSystem.err.println(Arrays.toString(a));\n\n//\t\tSystem.err.println(Arrays.toString(b));\n\n//\t\tSystem.err.println(Arrays.toString(all));\n\n//\t\tSystem.err.println(\"-----------\");\n\n\t\treturn all;\n\n\t}\n\n\t\n\n\tvoid submit() {\n\n\t\tint n = nextInt();\n\n\t\tint q = nextInt();\n\n\t\t\n\n\t\tint[] a = new int[n];\n\n\t\tint[] occ = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\ta[i] = nextInt() - 1;\n\n\t\t\tocc[a[i]]++;\n\n\t\t}\n\n\t\t\n\n\t\tint[][] arr = new int[n][];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tarr[i] = new int[occ[i]];\n\n\t\t}\n\n\t\t\n\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\n\t\t\t\n\n\t\t\tint x = a[i];\n\n\t\t\t\n\n\t\t\tarr[x][--occ[x]] = i;\n\n\t\t}\n\n\t\t\n\n\t\tNode root = new Node(0, n, a);\n\n\t\t\n\n\t\twhile (q-- > 0) {\n\n\t\t\tint l = nextInt() - 1;\n\n\t\t\tint r = nextInt();\n\n\t\t\tint k = nextInt();\n\n\t\t\t\n\n\t\t\tint need = (r - l) / k + 1;\n\n\t\t\t\n\n\t\t\tint[] info = root.getInfo(l, r);\n\n\t\t\t\n\n\t\t\tint cand = n;\n\n\t\t\t\n\n\t\t\tfor (int i = 0; i < info.length; i += 2) {\n\n\t\t\t\tint x = info[i];\n\n//\t\t\t\tSystem.err.println(count(arr[x], r));\n\n//\t\t\t\tSystem.err.println(count(arr[x], l));\n\n\t\t\t\tif (count(arr[x], r) - count(arr[x], l) >= need) {\n\n\t\t\t\t\tcand = Math.min(cand, x);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tout.println(cand == n ? -1 : (cand + 1));\n\n\t\t}\n\n\t}\n\n\t\n\n\tint count(int[] arr, int x) {\n\n\t\tint tmp = Arrays.binarySearch(arr, x);\n\n\t\tif (tmp < 0) {\n\n\t\t\treturn -tmp - 1;\n\n\t\t}\n\n\t\treturn tmp;\n\n\t}\n\n\n\n\tvoid preCalc() {\n\n\n\n\t}\n\n\n\n\tvoid stress() {\n\n\n\n\t}\n\n\n\n\tvoid test() {\n\n\n\n\t}\n\n\n\n\tD_faster() throws IOException {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tout = new PrintWriter(System.out);\n\n\t\tpreCalc();\n\n\t\tsubmit();\n\n\t\t// stress();\n\n\t\t// test();\n\n\t\tout.close();\n\n\t}\n\n\n\n\tstatic final Random rng = new Random();\n\n\n\n\tstatic int rand(int l, int r) {\n\n\t\treturn l + rng.nextInt(r - l + 1);\n\n\t}\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew D_faster();\n\n\t}\n\n\n\n\tBufferedReader br;\n\n\tPrintWriter out;\n\n\tStringTokenizer st;\n\n\n\n\tString nextToken() {\n\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\n\t\t\ttry {\n\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\t} catch (IOException e) {\n\n\t\t\t\tthrow new RuntimeException(e);\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn st.nextToken();\n\n\t}\n\n\n\n\tString nextString() {\n\n\t\ttry {\n\n\t\t\treturn br.readLine();\n\n\t\t} catch (IOException e) {\n\n\t\t\tthrow new RuntimeException(e);\n\n\t\t}\n\n\t}\n\n\n\n\tint nextInt() {\n\n\t\treturn Integer.parseInt(nextToken());\n\n\t}\n\n\n\n\tlong nextLong() {\n\n\t\treturn Long.parseLong(nextToken());\n\n\t}\n\n\n\n\tdouble nextDouble() {\n\n\t\treturn Double.parseDouble(nextToken());\n\n\t}\n\n}\n\n", "complexity": "cubic", "problem": "0840_D", "from": "CODEFORCES", "tags": "data structures,probabilities"}
{"src": "import java.util.*;\n\npublic class PaintTheNumers {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);    \n        \n        int nums = sc.nextInt();\n        \n        HashSet<Integer> elements = new HashSet<Integer>();\n        for (int i = 0; i < nums; i++) {\n            elements.add(sc.nextInt());\n        }\n        \n        ArrayList<Integer> sortedElements = new ArrayList<Integer>(elements);\n\n        Collections.sort(sortedElements);\n        \n        ArrayList<Integer> lcms = new ArrayList<Integer>();\n        \n        outer:\n        for (int i = 0; i < sortedElements.size(); i++) {\n            int ele = sortedElements.get(i);\n            for (int j = 0; j < lcms.size(); j++) {\n                if (ele % lcms.get(j) == 0) {\n                    continue outer;\n                }\n            }\n            lcms.add(ele);\n        }\n        System.out.println(lcms.size());\n        sc.close();\n    }\n}\n   \n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class CF_1517D\n{\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tMyReader reader = new MyReader();\n\t\tint N = reader.nextInt();\n\t\tint M = reader.nextInt();\n\t\tint K = reader.nextInt();\n\t\tif(K%2 == 1) {\n\t\t\tfor(int i = 0;i<N;i++) {\n\t\t\t\tfor(int j = 0;j<M;j++) {\n\t\t\t\t\tSystem.out.print(\"-1 \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tNode[][] grid = new Node[N][M];\n\t\t\tfor(int i = 0;i<N;i++) {\n\t\t\t\tfor(int j = 0;j<M;j++) {\n\t\t\t\t\tgrid[i][j] = new Node();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<N;i++) {\n\t\t\t\tfor(int j = 0;j<M-1;j++) {\n\t\t\t\t\tgrid[i][j].top = grid[i][j+1].bottom = reader.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<N-1;i++) {\n\t\t\t\tfor(int j = 0;j<M;j++) {\n\t\t\t\t\tgrid[i][j].right = grid[i+1][j].left = reader.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][][] ansArr = new int[K/2 + 1][N][M];\n\t\t\t//base case: ansArr[0] is all 0s\n\t\t\tfor(int k = 1; k<= K/2; k++) {\n\t\t\t\tfor(int i = 0;i<N;i++) {\n\t\t\t\t\tfor(int j = 0;j<M;j++) {\n\t\t\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\t\t\tif(i > 0) min = Math.min(min, ansArr[k-1][i-1][j] + 2*grid[i][j].left);\n\t\t\t\t\t\tif(i < N-1) min = Math.min(min, ansArr[k-1][i+1][j] + 2*grid[i][j].right);\n\t\t\t\t\t\tif(j > 0) min = Math.min(min, ansArr[k-1][i][j-1] + 2*grid[i][j].bottom);\n\t\t\t\t\t\tif(j < M-1) min = Math.min(min, ansArr[k-1][i][j+1] + 2*grid[i][j].top);\n\t\t\t\t\t\tansArr[k][i][j] = min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0;i<N;i++) {\n\t\t\t\tfor(int j = 0;j<M;j++) {\n\t\t\t\t\tSystem.out.print(ansArr[K/2][i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Node {\n\t\tpublic int right = 1000000000, top = 1000000000, left = 1000000000, bottom = 1000000000;\n\t}\n\t\n\t\n\tstatic class MyReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        public String next() throws IOException  {\n            while (st == null || !st.hasMoreElements()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n        public int nextInt() throws NumberFormatException, IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class E {\n    static Scanner in; static int next() throws Exception {return in.nextInt();};\n//\tstatic StreamTokenizer in; static int next() throws Exception {in.nextToken(); return (int) in.nval;}\n//\tstatic BufferedReader in;\n    static PrintWriter out;\n\n    public static void main(String[] args) throws Exception {\n        in = new Scanner(System.in);\n//\t\tin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n//\t\tin = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n\n        int n = next();\n\n        if (n%4 == 0||n%7 == 0||n%44 == 0||n%47 == 0||n%74 == 0||n%77 == 0||n%444 == 0||n%447 == 0||n%474 == 0||n%744 == 0||n%774 == 0||n%747 == 0||n%477 == 0||n%777==0) out.println(\"YES\");\n        else out.println(\"NO\");\n\n        out.println();\n        out.close();\n    }\n}", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.BufferedWriter;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.Deque;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.LinkedList;\n\nimport java.util.PriorityQueue;\n\nimport java.util.Queue;\n\nimport java.util.Stack;\n\nimport java.io.InputStreamReader;\n\nimport java.io.OutputStream;\n\nimport java.io.OutputStreamWriter;\n\nimport java.io.PrintWriter;\n\nimport java.math.BigDecimal;\n\nimport java.math.BigInteger;\n\nimport java.util.StringTokenizer;\n\nimport java.util.TreeSet;\n\npublic class cfvc15\n\n{\n\n\tstatic BufferedReader reader;\n\n    static StringTokenizer tokenizer;\n\n    static void init(InputStream input) \n\n    {\n\n        reader = new BufferedReader( new InputStreamReader(input) );\n\n        tokenizer = new StringTokenizer(\"\");\n\n    }\n\n    static String next() throws IOException\n\n    {\n\n        while ( ! tokenizer.hasMoreTokens() )\n\n        {\n\n            tokenizer = new StringTokenizer(reader.readLine() );\n\n        }\n\n        return tokenizer.nextToken();\n\n    }\n\n \n\n    static long nextInt() throws IOException \n\n    {\n\n        return Long.parseLong( next() );\n\n    }\n\n\tstatic PrintWriter writer;\n\n\tstatic void outit(OutputStream outputStream)\n\n\t{\n\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\n\t}\n\n\tstatic void print(Object...objects) {\n\n\t\tfor (int i = 0; i < objects.length; i++) \n\n\t\t{\n\n\t\t\tif (i != 0)\n\n\t\t\t\twriter.print(' ');\n\n\t\t\twriter.print(objects[i]);\n\n\t\t}\n\n\t}\n\n \n\n\tstatic void println(Object...objects) {\n\n\t\tprint(objects);\n\n\t\twriter.println();\n\n\t}\n\n \n\n\tstatic void close() {\n\n\t\twriter.close();\n\n\t}\n\n \n\n\tstatic void flush() {\n\n\t\twriter.flush();\n\n\t}\n\n\tpublic static void print_a(long [] a)\n\n    {\n\n    \tfor(long i : a)\n\n    \t{\n\n    \t\tprint(i+\" \") ;\n\n    \t}\n\n    \tprintln() ;\n\n    }\n\n    public static void main(String [] args) throws IOException\n\n    {\n\n    \tinit(System.in) ;\n\n    \toutit(System.out) ;\n\n//    \tint t = (int) nextInt() ;\n\n//    \tfor(int i =0 ; i<t ; i++)\n\n    \toutput() ;\n\n        flush();\n\n        close();\n\n    }\n\n    static long mod = 1000000007 ;\n\n    static ArrayList<ArrayList<Integer>> ar ;\n\n    static int [] c ;\n\n    public static void output() throws IOException\n\n    {\n\n    \tlong l = nextInt() ;\n\n    \tlong r = nextInt() ;\n\n    \tString ls = Long.toBinaryString(l) ;\n\n    \tString rs = Long.toBinaryString(r) ;\n\n    \tint diff = rs.length()-ls.length() ;\n\n    \tfor(int i = 0 ; i<diff ; i++)\n\n    \t{\n\n    \t\tls = \"0\"+ls ;\n\n    \t}\n\n//    \tprintln(ls) ;\n\n//    \tprintln(rs) ;\n\n    \tint c = -1 ;\n\n    \tfor(int i = 0 ; i<rs.length(); i++)\n\n    \t{\n\n    \t\tif(ls.charAt(i)!=rs.charAt(i))\n\n    \t\t{\n\n    \t\t\tc = i ;\n\n    \t\t\tbreak ;\n\n    \t\t}\n\n    \t}\n\n    \tif(c==-1)\n\n    \t{\n\n    \t\tprintln(0) ;\n\n    \t}\n\n    \telse\n\n    \t{\n\n    \t\tlong ans = 1 ;\n\n    \t\tfor(int i = 0 ; i<rs.length()-c ; i++)\n\n    \t\t{\n\n    \t\t\tans*=2 ;\n\n    \t\t}\n\n//    \t\tlong ans = (long) (Math.pow(2,rs.length()-c-1)*2-1) ;\n\n    \t\tprintln(ans-1) ;\n\n    \t}\n\n    }\n\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author beginner1010\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        final int INF = (int) 1e9 + 5;\n        int n;\n        int m;\n        int[][][] dp;\n        int[][] diff;\n        int[][] diffStartLast;\n\n        int two(int x) {\n            return 1 << x;\n        }\n\n        boolean contain(int mask, int x) {\n            return (mask & two(x)) > 0;\n        }\n\n        int rec(int start, int pre, int mask) {\n            if (mask == two(n) - 1)\n                return INF;\n            int res = dp[start][pre][mask];\n            if (res != -1)\n                return res;\n            res = 0;\n\n            for (int i = 0; i < n; i++)\n                if (contain(mask, i) == false) {\n                    int diffPre = mask == 0 ? INF : diff[pre][i]; // mask == 0 should never happen\n                    int diffLast = (mask | two(i)) == two(n) - 1 ? diffStartLast[start][i] : INF;\n                    res = Math.max(res, Math.min(rec(start, i, mask | two(i)), Math.min(diffLast, diffPre)));\n                }\n\n            dp[start][pre][mask] = res;\n            return res;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt();\n            m = in.nextInt();\n            int[][] grid = new int[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    grid[i][j] = in.nextInt();\n\n            if (n == 1) {\n                int res = INF;\n                for (int i = 0; i + 1 < m; i++) {\n                    res = Math.min(res, Math.abs(grid[0][i] - grid[0][i + 1]));\n                }\n                out.println(res);\n                return;\n            }\n\n            diff = new int[n][n];\n            diffStartLast = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    diff[i][j] = INF;\n                    diffStartLast[i][j] = INF;\n                    for (int k = 0; k < m; k++) {\n                        diff[i][j] = Math.min(diff[i][j], Math.abs(grid[i][k] - grid[j][k]));\n                        if (k + 1 < m) {\n                            diffStartLast[i][j] = Math.min(diffStartLast[i][j], Math.abs(grid[i][k + 1] - grid[j][k]));\n                        }\n                    }\n                }\n            }\n\n            dp = new int[n][n][two(n)];\n            for (int[][] aux : dp)\n                for (int[] aux2 : aux)\n                    Arrays.fill(aux2, -1);\n\n            int ans = 0;\n            for (int start = 0; start < n; start++) {\n                ans = Math.max(ans, rec(start, start, two(start)));\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class InputReader {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputStream stream;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhitespace(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isWhitespace(c));\n            return res * sgn;\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "// Working program using Reader Class \nimport java.io.DataInputStream; \nimport java.io.FileInputStream; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.Scanner; \nimport java.util.StringTokenizer; \n\npublic class Main1 \n{ \n\tstatic class Reader \n\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\n\t\tpublic Reader(String file_name) throws IOException \n\t\t{ \n\t\t\tdin = new DataInputStream(new FileInputStream(file_name)); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\n\t\tpublic String readLine() throws IOException \n\t\t{ \n\t\t\tbyte[] buf = new byte[64]; // line length \n\t\t\tint cnt = 0, c; \n\t\t\twhile ((c = read()) != -1) \n\t\t\t{ \n\t\t\t\tif (c == '\\n') \n\t\t\t\t\tbreak; \n\t\t\t\tbuf[cnt++] = (byte) c; \n\t\t\t} \n\t\t\treturn new String(buf, 0, cnt); \n\t\t} \n\n\t\tpublic int nextInt() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} while ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic long nextLong() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic double nextDouble() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n\n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n\n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n\t\t} \n\t} \n\n\tpublic static void main(String[] args) throws IOException \n\t{ \n\t\tReader s=new Reader(); \n\t\tint n = s.nextInt(), i, j, ans=0;\n\t\tint[] a = new int[101];\n\t\tfor(i=0;i<n;i++){\n\t\t\ta[s.nextInt()]++;\n\t\t}\n\t\tfor(i=1;i<=100;i++){\n\t\t\tif(a[i]>0){\n\t\t\t\tans++;\n\t\t\t\tfor(j=i;j<=100;j++){\n\t\t\t\t\tif(j%i==0){\n\t\t\t\t\t\ta[j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t} \n} \n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\t/**\n\t * @author hunglee\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tStreamTokenizer in = new StreamTokenizer(new BufferedReader(\n\t\t\t\tnew InputStreamReader(System.in)));\n\t\t\n\t\tin.nextToken();\n\t\tString s = in.sval;\n\t\tint l = s.length();\n\t\tint n = l - 1;\n\t\tString st, sub;\n\t\twhile (n > 0) {\n\t\t\tfor (int i = 0; i < l - n; ++i) {\n\t\t\t\tst = s.substring(i, n + i);\n\t\t\t\tsub = s.substring(i + 1);\n\t\t\t\tif (sub.indexOf(st) != -1) {\n\t\t\t\t\tSystem.out.println(n);\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t\tSystem.out.println(0);\n\t}\n\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\n\npublic class C {\n    String fileName = \"<name>\";\n\n    public static final int MOD = (int) (1e9 + 7);\n\n    public void solve() throws IOException {\n        long x = nextLong();\n        if (x == 0) {\n            out.print(0);\n            return;\n        }\n        long k = nextLong();\n        BigInteger power = BigInteger.valueOf(2)\n                .modPow(BigInteger.valueOf(k), BigInteger.valueOf(MOD));\n        BigInteger r = BigInteger.valueOf(x).multiply(power);\n        BigInteger l = r.subtract(power).add(BigInteger.ONE);\n        out.print(l.add(r).mod(BigInteger.valueOf(MOD)));\n    }\n\n    public void run() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    BufferedReader br;\n    StringTokenizer in;\n    PrintWriter out;\n\n    public String nextToken() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n        return in.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public static void main(String[] args) throws IOException {\n        Locale.setDefault(Locale.US);\n        new C().run();\n    }\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        int stage;\n        int n;\n        OutputWriter out;\n        InputReader in;\n\n        void query(int end) {\n            switch (stage) {\n            case 0:\n                out.printLine('?', 1, 1, end, n);\n                break;\n            case 1:\n                out.printLine('?', 1, 1, n, end);\n                break;\n            case 2:\n                out.printLine('?', n + 1 - end, 1, n, n);\n                break;\n            case 3:\n                out.printLine('?', 1, n + 1 - end, n, n);\n                break;\n            }\n            out.flush();\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            this.out = out = new OutputWriter(System.out);\n            this.in = in = new InputReader(System.in);\n            n = in.readInt();\n            int[] endx = new int[2];\n            int[] endy = new int[2];\n            int[] stx = new int[2];\n            int[] sty = new int[2];\n            find(endx);\n            stage++;\n            find(endy);\n            stage++;\n            find(stx);\n            for (int i = 0; i < 2; i++) {\n                stx[i] = n + 1 - stx[i];\n            }\n            stage++;\n            find(sty);\n            for (int i = 0; i < 2; i++) {\n                sty[i] = n + 1 - sty[i];\n            }\n            for (int i = 0; i < 8; i++) {\n                if (stx[i & 1] > endx[i >> 2 & 1] || sty[i >> 1 & 1] > endy[0]) {\n                    continue;\n                }\n                if (stx[1 - (i & 1)] > endx[1 - (i >> 2 & 1)] || sty[1 - (i >> 1 & 1)] > endy[1]) {\n                    continue;\n                }\n                out.printLine('?', stx[i & 1], sty[i >> 1 & 1], endx[i >> 2 & 1], endy[0]);\n                out.flush();\n                if (in.readInt() == 0) {\n                    continue;\n                }\n                out.printLine('?', stx[1 - (i & 1)], sty[1 - (i >> 1 & 1)], endx[1 - (i >> 2 & 1)], endy[1]);\n                out.flush();\n                if (in.readInt() != 0) {\n                    out.printLine(\"!\", stx[i & 1], sty[i >> 1 & 1], endx[i >> 2 & 1], endy[0], stx[1 - (i & 1)],\n                            sty[1 - (i >> 1 & 1)], endx[1 - (i >> 2 & 1)], endy[1]);\n                    out.flush();\n                    return;\n                }\n            }\n        }\n\n        private void find(int[] endx) {\n            int left = 1;\n            int right = n;\n            while (left < right) {\n                int middle = (left + right) >> 1;\n                query(middle);\n                if (in.readInt() == 2) {\n                    right = middle;\n                } else {\n                    left = middle + 1;\n                }\n            }\n            endx[0] = left;\n            left = 0;\n            right--;\n            while (left < right) {\n                int middle = (left + right + 1) >> 1;\n                query(middle);\n                if (in.readInt() == 0) {\n                    left = middle;\n                } else {\n                    right = middle - 1;\n                }\n            }\n            endx[1] = left + 1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\n    static Map<BigInteger, BigInteger> mp = new HashMap<BigInteger, BigInteger>();\n\n    public static void main(String[] args) {\n        mp.clear();\n        Scanner cin = new Scanner(new BufferedInputStream(System.in));\n        BigInteger n = cin.nextBigInteger();\n        BigInteger x = cin.nextBigInteger();\n        mp.put(x, BigInteger.ONE);\n        BigInteger sum = x;\n        BigInteger ans = BigInteger.ZERO;\n        for (int i = 2;i <= n.intValue(); i++) {\n            x=cin.nextBigInteger();\n            BigInteger tmp = x.multiply(BigInteger.valueOf(i-1)).subtract(sum);\n            if (mp.containsKey(x.subtract(BigInteger.ONE))) tmp = tmp.subtract(mp.get(x.subtract(BigInteger.ONE)));\n            if (mp.containsKey(x.add(BigInteger.ONE))) tmp = tmp.add(mp.get(x.add(BigInteger.ONE)));\n            ans = ans.add(tmp);\n            sum = sum.add(x);\n            BigInteger xx;\n            if (mp.containsKey(x)) xx = mp.get(x);\n            else xx = BigInteger.ZERO;\n            mp.put(x, xx.add(BigInteger.ONE));\n        }\n        System.out.println(ans);\n    }\n}\n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class A {\n    \n    static StringTokenizer st;\n    static BufferedReader in;\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n = nextInt();\n        int m = nextInt();\n        int k = nextInt();\n        int[]a = new int[n+1];\n        for (int i = 1; i <= n; i++) {\n            a[i] = nextInt();\n        }\n        if (k >= m) {\n            System.out.println(0);\n            return;\n        }\n        Arrays.sort(a, 1, n+1);\n        int ans = 0;\n        for (int i = n; i >= 1; i--) {\n            ans++;\n            k--;\n            k += a[i];\n            if (k >= m) {\n                System.out.println(ans);\n                return;\n            }\n        }\n        System.out.println(-1);\n        pw.close();\n    }\n    private static int nextInt() throws IOException{\n        return Integer.parseInt(next());\n    }\n    \n    private static long nextLong() throws IOException{\n        return Long.parseLong(next());\n    }\n    \n    private static double nextDouble() throws IOException{\n        return Double.parseDouble(next());\n    }\n    \n    private static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic int n, memo[], dS[], dd[][];\n\n\tstatic int dp(int idx, int msk)\n\t{\n\t\tif(msk == (1 << n) - 1)\n\t\t\treturn 0;\n\t\tif(memo[msk] != -1)\n\t\t\treturn memo[msk];\n\t\twhile((msk & 1 << idx) != 0)\n\t\t\t++idx;\n\t\tint ret = dS[idx] * 2 + dp(idx + 1, msk | 1 << idx);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif((msk & 1 << i) == 0)\n\t\t\t\tret = Math.min(ret, dS[i] + dS[idx] + dd[i][idx] + dp(idx + 1, msk | 1 << i | 1 << idx));\n\t\treturn memo[msk] = ret;\n\t}\n\t\n\tstatic StringBuilder sb = new StringBuilder(\"0 \");\n\t\n\tstatic void print(int idx, int msk)\n\t{\n\t\tif(msk == (1 << n) - 1)\n\t\t\treturn;\n\t\tint opt = dp(idx, msk);\n\t\twhile((msk & 1 << idx) != 0)\n\t\t\t++idx;\n\t\tif(dS[idx] * 2 + dp(idx + 1, msk | 1 << idx) == opt)\n\t\t{\n\t\t\tsb.append((idx + 1) + \" 0 \");\n\t\t\tprint(idx + 1, msk | 1 << idx);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif((msk & 1 << i) == 0)\n\t\t\t\tif(opt == dS[i] + dS[idx] + dd[i][idx] + dp(idx + 1, msk | 1 << i | 1 << idx))\n\t\t\t\t{\n\t\t\t\t\tsb.append((idx + 1) + \" \" + (i + 1) + \" 0 \");\n\t\t\t\t\tprint(idx + 1, msk | 1 << i | 1 << idx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tPoint s = new Point(sc.nextInt(), sc.nextInt());\n\t\tn = sc.nextInt();\n\t\tPoint[] a = new Point[n];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\ta[i] = new Point(sc.nextInt(), sc.nextInt());\n\t\tdS = new int[n];\n\t\tdd = new int[n][n];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tdS[i] = dist2(s, a[i]);\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tdd[i][j] = dist2(a[i], a[j]);\n\t\t}\n\n\t\tmemo = new int[1 << n];\n\t\tArrays.fill(memo, -1);\n\t\tout.println(dp(0, 0));\n\t\tprint(0, 0);\n\t\tout.println(sb);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic int dist2(Point a, Point b) { return sq(a.x - b.x) + sq(a.y - b.y); }\n\n\tstatic int sq(int x) { return x * x; }\n\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(next()); }\n\n\t\tpublic boolean ready() throws IOException {return br.ready();} \n\t}\n} ", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.util.*;import java.io.*;import java.math.*;\npublic class Main\n{\n    static int[][] l,r,u,d;\n    static int[][][]dist;\n    static int inf=Integer.MAX_VALUE;\n    static class Node{\n        int x,y,len,dis;\n        Node(int x,int y,int len,int dis){\n            this.x=x;this.y=y;this.len=len;this.dis=dis;\n        }\n    }\n    public static void process()throws IOException\n    {\n        int n=ni();\n        int m=ni();\n        int k=ni();\n        dist=new int[n][m][k/2+1];\n        l=new int[n][m];\n        r=new int[n][m];\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m-1;j++)\n                l[i][j]=r[i][j+1]=ni();\n        u=new int[n][m];\n        d=new int[n][m];\n        for(int i=0;i<n-1;i++)\n            for(int j=0;j<m;j++)\n                d[i][j]=u[i+1][j]=ni();\n        if(k%2==1)\n        {\n            for(int i=0;i<n;i++)\n            {\n                for(int j=0;j<m;j++)\n                    p(\"-1 \");\n                pn(\"\");\n            }\n            return;\n        }\n        k/=2;\n        for(int kk=1;kk<=k;kk++)\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                dist[i][j][kk]=inf;\n                if(i!=0)\n                    dist[i][j][kk]=Math.min(dist[i][j][kk],dist[i-1][j][kk-1]+u[i][j]);\n                if(i!=n-1)\n                    dist[i][j][kk]=Math.min(dist[i][j][kk],dist[i+1][j][kk-1]+d[i][j]);\n                if(j!=0)\n                    dist[i][j][kk]=Math.min(dist[i][j][kk],dist[i][j-1][kk-1]+r[i][j]);\n                if(j!=m-1)\n                    dist[i][j][kk]=Math.min(dist[i][j][kk],dist[i][j+1][kk-1]+l[i][j]);\n            }\n        }\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n                p(2*dist[i][j][k]+\" \");\n            pn(\"\");\n        }\n\n    }\n    static AnotherReader sc;\n    static PrintWriter out;\n    public static void main(String[]args)throws IOException\n    {\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        if(oj){sc=new AnotherReader();out=new PrintWriter(System.out);}\n        else{sc=new AnotherReader(100);out=new PrintWriter(\"output.txt\");}\n        int t=1;\n       // t=ni();\n        while(t-->0) {process();}\n        out.flush();out.close();  \n    }\n\n    static void pn(Object o){out.println(o);}\n    static void p(Object o){out.print(o);}\n    static void pni(Object o){out.println(o);out.flush();}\n    static int ni()throws IOException{return sc.nextInt();}\n    static long nl()throws IOException{return sc.nextLong();}\n    static double nd()throws IOException{return sc.nextDouble();}\n    static String nln()throws IOException{return sc.nextLine();}\n    static int[] nai(int N)throws IOException{int[]A=new int[N];for(int i=0;i!=N;i++){A[i]=ni();}return A;}\n    static long[] nal(int N)throws IOException{long[]A=new long[N];for(int i=0;i!=N;i++){A[i]=nl();}return A;}\n    static long gcd(long a, long b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int gcd(int a, int b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int bit(long n)throws IOException{return (n==0)?0:(1+bit(n&(n-1)));}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    static class AnotherReader{BufferedReader br; StringTokenizer st;\n    AnotherReader()throws FileNotFoundException{\n    br=new BufferedReader(new InputStreamReader(System.in));}\n    AnotherReader(int a)throws FileNotFoundException{\n    br = new BufferedReader(new FileReader(\"input.txt\"));}\n    String next()throws IOException{\n    while (st == null || !st.hasMoreElements()) {try{\n    st = new StringTokenizer(br.readLine());}\n    catch (IOException  e){ e.printStackTrace(); }}\n    return st.nextToken(); } int nextInt() throws IOException{\n    return Integer.parseInt(next());}\n    long nextLong() throws IOException\n    {return Long.parseLong(next());}\n    double nextDouble()throws IOException { return Double.parseDouble(next()); }\n    String nextLine() throws IOException{ String str = \"\"; try{\n    str = br.readLine();} catch (IOException e){\n    e.printStackTrace();} return str;}}\n   \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * Author -\n * User: kansal\n * Date: 9/3/11\n * Time: 5:28 PM\n */\npublic class CF85C {\n    public static void main(String[] args) {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n\n        int height = nextInt(), width = nextInt();\n        if (width > height) {\n            int t = width;\n            width = height;\n            height = t;\n        }\n\n        final int INF = height * width + 10;\n        final int ALL_BITS = (1 << width)  - 1;\n        int[][][] dp = new int[height + 1][1 << width][1 << width];\n        for (int[][] ints : dp) {\n            for (int[] anInt : ints) {\n                Arrays.fill(anInt, INF);\n            }\n        }\n\n        dp[0][0][0] = 0;\n        for(int r = 0; r < height; ++r) {\n            for(int uncovered = 0; uncovered < (1 << width); ++uncovered) {\n                for(int mask = 0; mask < (1 << width); ++mask) {\n                    if (dp[r][uncovered][mask] == INF) {\n                        continue;\n                    }\n\n                    for(int curMask = uncovered; curMask < (1 << width); curMask = (curMask + 1) | uncovered) {\n                        int curCovered = (mask | curMask);\n                        curCovered |= (curMask >> 1);\n                        curCovered |= (ALL_BITS & (curMask << 1));\n\n                        int curUncovered = ALL_BITS ^ curCovered;\n                        dp[r+1][curUncovered][curMask] = Math.min(dp[r+1][curUncovered][curMask], dp[r][uncovered][mask] + Integer.bitCount(curMask));\n                    }\n                }\n            }\n        }\n\n        int res = INF;\n        for(int x: dp[height][0]) res = Math.min(res, x);\n\n        System.out.println(height * width - res);\n    }\n\n    public static BufferedReader reader;\n\n    public static StringTokenizer tokenizer = null;\n\n    static String nextToken() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    static public int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    static public long nextLong() {\n        return Long.parseLong(nextToken());\n    }\n\n    static public String next() {\n        return nextToken();\n    }\n\n    static public String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.util.Scanner;\n\npublic class Main {\n    \n    final static long Mod = 1000000009;\n    static long n, m, k, t, l, u, ans;\n    static Scanner cin = new Scanner(System.in); \n    \n    static long multi_mod(long base, long cur) {\n        long res = 1;\n        while(cur > 0) {\n            if(cur % 2 == 1) res = (res * base) % Mod;\n            cur >>= 1;\n            base = (base * base) % Mod;\n        }\n        return res;\n    }\n    \n    public static void main(String[] args) {\n        n = cin.nextLong(); m = cin.nextLong(); k = cin.nextLong();\n        l = (k - 1)*(n / k) + n % k;\n        if(m <= l) {\n            System.out.println(m);\n        }\n        else {\n            t = n / k;\n            u = m - l;\n            ans = (0 + (t - u) * (k - 1) + n % k) % Mod;\n            ans = (ans + ((k)*((multi_mod(2, u + 1) - 2 + Mod) % Mod)) % Mod) % Mod;\n            System.out.println(ans);\n        }\n    }\n}\n", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.prefs.BackingStoreException;\n\npublic class answertillD {\n\tstatic ArrayList<Integer>[] adjlist;\n\tstatic int[][] adjmatrix;\n\tstatic int[][] adjmatrix2;\n\tstatic boolean[] vis;\n\tstatic boolean[] intialvis;\n\tstatic boolean[] vis2;\n\tstatic int[] counter;\n\tstatic int V, E;\n\tstatic Stack<Integer> st;\n\tstatic ArrayList<Integer> arrylist;\n\tstatic boolean flag;\n\tstatic int[] dx = new int[] { 1, -1, 0, 0 };\n\tstatic int[] dy = new int[] { 0, 0, 1, -1 };\n\tstatic int[] Arr;\n\tstatic PrintWriter pw;\n\n\tpublic static long gcd(long u, long v) {\n\t\tif (u == 0)\n\t\t\treturn v;\n\t\treturn gcd(v % u, u);\n\t}\n\n\tpublic static int dfs(int u) {\n\t\tvis[u] = true;\n\t\tint a = 0;\n\t\tfor (int v : adjlist[u])\n\t\t\tif (!vis[v])\n\t\t\t\ta += dfs(v);\n\n\t\treturn 1 + a;\n\t}\n\n\tpublic static void dfs(int u, int num) {\n\t\tvis2[u] = true;\n\t\tcounter[u] = num;\n\t\tfor (int v : adjlist[u])\n\t\t\tif (!vis2[v])\n\t\t\t\tdfs(v, num);\n\t}\nstatic long diff=Long.MAX_VALUE;\n\tstatic boolean check(long num, long k) {\n\t\tint n=(num+\"\").length()-1;\n\t\tlong m=1;\n\t\tlong sum=0;int i=1;\n\t\twhile(n-->0)\n\t\t{\n\t\tsum+=9*m*(i++)\t;\n\t\tm*=10;\n\t\t}\n\t\tsum+=(num-m)*i+1;\n\t\tif(sum<=k)\n\t\t\tdiff=Math.min(diff, k-sum);\n\t\treturn sum<=k;\n\t}\n\t\t\n\n\tstatic long bin(long k) {\n\t\tlong left = 1;\n\t\tlong right = k+1;\n\t\tlong mid;\n\t\tlong ans = 1;\n\t\twhile (left <= right) {\n\t\t\tmid = (left + right) / 2;\n\n\t\t\tif (check(mid, k)) {\n\t\t\t\tans = mid;\n\t\t\t\tleft = mid + 1;\n\t\t\t\t\n\t\t\t} else\n\t\t\t\tright = mid - 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static long power(long x, int i) {\n\t\tlong r = 1;\n\t\twhile (i-- > 0) {\n\t\t\tif (r > 1e18 / x)\n\t\t\t\treturn (long) (1e18 + 5);\n\t\t\tr = r * x;\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int m;\n\n\tstatic int calculate(int[] Arrs, int[] Arre, int index, boolean left, boolean targetleft) {\n\t\tint ans = 0;\n\t\tint n = m + 2;\n\t\t\n\t\tif (left) {\n\t\t\tans = Arre[index - 1];\n\t\t\tif ((index != E + 1))\n\t\t\t\tans += (targetleft) ? Arre[index - 1] : n - Arre[index - 1] - 1;\n\n\t\t} else {\n\t\t\tans = n - Arrs[index - 1] - 1;\n\t\t\tif ((index != E + 1))\n\t\t\t\tans += ((targetleft) ? Arrs[index - 1] : n - Arrs[index - 1] - 1);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic int min = Integer.MAX_VALUE;\n\n\tstatic void backtrack(int[] Arrs, int[] Arre, int soFarMin, int index, boolean left) {\n\t\tif (index == E) {\n\t\t\tmin = Math.min(min, soFarMin - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tint newmin1 = calculate(Arrs, Arre, index, left, left);\n\t\tint newmin2 = calculate(Arrs, Arre, index, left, !left);\n\t\tbacktrack(Arrs, Arre, soFarMin + newmin1 + 1, index - 1, left);\n\t\tbacktrack(Arrs, Arre, soFarMin + newmin2 + 1, index - 1, !left);\n\n\t}\n\tpublic static String add(String str1,String str2){\n\t\tStack<String>st=new Stack<String>();\n\t\tint n=str1.length();\n\t\tint m=str2.length();\t\t\n\t\tint max=Math.max(n, m);\n\t\tint sum=0,carry=0;\n\t\tfor(int i=0;i<max;i++){\n\t\t\tint num1=0,num2=0;\n\t\t\tif(n>=i)\n\t\t\t num1 = Integer.parseInt(str1.charAt(n-i) + \"\");\n\t\t\tif(m>=i)\n\t\t\t num2 = Integer.parseInt(str2.charAt(m-i) + \"\");\n\t\t\tint z = num1 + num2 + carry;\n\t\t\tif (z >= 10) {\n\t\t\t\tsum = z / 10;\n\t\t\t\tcarry = z % 10;\n\t\t\t} else {\n\t\t\t\tsum = z;\n\t\t\t\tcarry=0;\n\t\t\t}\n\t\t\tst.add(sum+\"\");\n\t\t}\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile(!st.isEmpty()){\n\t\t\tsb.append(st.pop());\n\t\t}\n\t\treturn sb+\"\";\n\t}\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong k=sc.nextLong();\n\t\tlong bi=bin(k);\n\t\tString str=bi+\"\";\n\t\tSystem.out.println(str.charAt((int) diff));\n\t\t\n\t\n\t\t\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class G{\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.flush();out.close();\n    }\n        static class TaskE {\n        class MinCostMaxFlow{\n                ArrayList<Edge> al[];\n                Edge ja[][]; \n                int d[]; // shortest distances\n                int N , S , T , maxFlow ; int minCost;\n                final int gmax = Integer.MAX_VALUE / 100;\n                \n                int edges = 0;\n\n                class Edge{\n                    int u , flow, rid, cost;\n                    Edge(int a, int b, int c, int d){u = a; flow = b; cost = c; rid = d;}\n                }\n                \n                void addEdge(int u , int v , int flow , int cost){\n                    int lu = al[u].size(), lv = al[v].size();\n                    al[u].add(new Edge(v, flow, cost, lv)); \n                    al[v].add(new Edge(u, 0, -cost, lu));   \n                }\n                \n                void convertToArray(){\n                    ja = new Edge[N][];\n                    for(int i = 0; i < N; i++){\n                        int sz = al[i].size();\n                        ja[i] = new Edge[sz];\n                        for(int j = 0; j < sz; j++){\n                            ja[i][j] = al[i].get(j);\n                        }\n                        al[i].clear();\n                    }\n                }\n                \n                MinCostMaxFlow(int n , int source , int sink){\n                    N = n; S = source; T = sink; maxFlow = 0; minCost = 0;\n                    al = new ArrayList[N];\n                    d = new int[N];\n                    for(int i = 0; i < N; i++){\n                        al[i] = new ArrayList<>();\n                    }\n                }\n                \n                boolean BellmanFord(boolean check){\n                    d[0] = 0;\n                    for(int i = 0; i < N - 1; i++){\n                        for(int j = 0; j < N; j++){\n                            for(Edge e : ja[j]){\n                                if(e.flow == 0)continue; // not to consider reverse edges\n                                d[e.u] = Math.min(d[e.u] , d[j] + e.cost);\n                            }\n                        }\n                    }\n                    if(check){// check for negative cycles\n                        for(int j = 0; j < N; j++){\n                            for(Edge e : ja[j]){\n                                if(e.flow == 0)continue;\n                                if(d[j] + e.cost < d[e.u]) return false;\n                            }\n                        }   \n                    }return true;\n                }\n\n                int node[]; // present node \n\n                int visit[]; // 0 -> not added 1 -> not removed 2 -> removed\n                int prv[], prve[]; // previous node for augmentation\n                int dist[]; // min dist\n\n                boolean simple(){\n                    node = new int[N]; \n                    visit = new int[N]; \n                    prv = new int[N];\n                    prve = new int[N];\n                    dist = new int[N];   Arrays.fill(dist , gmax);\n\n                    node[0] = S; dist[0] = 0;\n                    int front = 1, back = 0;\n                    while(front != back){\n                        int u = node[back++]; int distu = dist[u];\n                        if(back == N)back = 0;\n                        visit[u] = 2;\n                        for(int i = 0; i < ja[u].length; i++){\n                            Edge e = ja[u][i];\n                            if(e.flow == 0)continue;\n                            int cdist = distu + e.cost; // no need of reduced cost\n                            if(cdist < dist[e.u]){\n                                if(visit[e.u] == 0){\n                                    node[front] = e.u; \n                                    if(++front == N)front = 0;\n                                }else if(visit[e.u] == 2){\n                                    if(--back == -1)back += N;\n                                    node[back] = e.u;\n                                }\n                                visit[e.u] = 1;\n                                prve[e.u] = i; prv[e.u] = u; dist[e.u] = cdist;\n                            }\n                        }\n                    }\n                    return visit[T] != 0;\n                }\n\n                class pair{\n                    int F; int S;\n                    pair(int a, int b){F = a; S = b;}\n                }\n\n                boolean dijkstra(){\n                    visit = new int[N];\n                    prv = new int[N];\n                    prve = new int[N];\n                    dist = new int[N]; Arrays.fill(dist, gmax);\n                    PriorityQueue<pair> pq = new PriorityQueue<>((A, B) -> Double.compare(A.S , B.S));\n\n                    pq.add(new pair(S , 0)); dist[0] = 0;\n                    o : while(!pq.isEmpty()){\n                        pair p = pq.poll();\n                        while(dist[p.F] < p.S){\n                            if(pq.isEmpty()) break o; // had a better val \n                            p = pq.poll();\n                        }\n                        visit[p.F] = 2;\n                        for(int i = 0; i < ja[p.F].length; i++){\n                            Edge e = ja[p.F][i];\n                            if(e.flow == 0)continue; // important\n                            int cdist = p.S + (e.cost + d[p.F] - d[e.u]); // reduced cost\n                            if(cdist < dist[e.u]){ \n                                if(visit[e.u] == 2) return false;\n                                pq.add(new pair(e.u , cdist));\n                                dist[e.u] = cdist; prv[e.u] = p.F; prve[e.u] = i;\n                                visit[e.u] = 1;\n                            }\n                        }\n                    }\n                    return visit[T] != 0;\n                }\n                \n                int augment(){\n                    int p = T; int min = gmax;\n                    while(p != 0){\n                        int pp = prv[p], pe = prve[p];\n                        int val = ja[pp][pe].flow;\n                        min = Math.min(min , val);\n                        p = pp;\n                    }\n                    p = T;\n                    while(p != 0){\n                        int pp = prv[p], pe = prve[p];\n                        ja[pp][pe].flow -= min;\n                        ja[p][ja[pp][pe].rid].flow += min;\n                        p = pp;\n                    }\n                    maxFlow += min;\n                    return min;\n                }\n\n                // if(dist[T] >= 0)return true; // non contributing flow\n                boolean calSimple(){\n                    // uncomment to check for negative cycles\n                    /* boolean possible = BellmanFord(true); \n                     if(!possible) return false; */\n                    while(simple()){\n                        /*if(dist[T] >= 0)return true;*/ \n                        minCost += dist[T] * augment();\n                    }\n                    return true;\n                }\n\n                void updPotential(){\n                    for(int i = 0; i < N; i++){\n                        if(visit[i] != 0){\n                            d[i] += dist[i] - dist[S];\n                        }\n                    }\n                }\n                boolean calWithPotential(){\n                    // set true to check for negative cycles\n                    // boolean possible = BellmanFord(false); \n                    // if(!possible) return false;\n                    while(dijkstra()){\n                        int min = dist[T] + d[T] - d[S]; // getting back the original cost\n                        /*if(dist[T] >= 0)return true;*/\n                        minCost += min * augment();\n                        updPotential();\n                    }\n                    return true;   \n                }\n            }\n            int n , m, k, c, d, a[], f[];\n           public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt(); m = in.nextInt(); k = in.nextInt(); c = in.nextInt(); d= in.nextInt();\n            // S + n\n            int maxl = n + k, T = n * maxl + 1;\n            MinCostMaxFlow ans = new MinCostMaxFlow(T + 1, 0, T);\n            a = new int[k + 1]; f = new int[n + 1];\n            for(int i = 1; i <= k; i++){\n                a[i] = in.nextInt();\n                f[a[i]]++;\n            }\n            for(int i = 1; i <= n; i++){\n                if(f[i] == 0)continue;\n                ans.addEdge(0 , i , f[i], 0);\n            }\n            for(int i = 2; i <= n; i++){\n                for(int l = 0; l < maxl - 1; l++){\n                    ans.addEdge(l * n + i , (l + 1) * n + i, k, c);\n                }\n            }\n            for(int i = 1; i <= m; i++){\n                int a = in.nextInt(), b = in.nextInt();\n                for(int l = 0; l < maxl - 1; l++){\n                    for(int p = 1; p <= k; p++){\n                        if(a != 1)\n                            ans.addEdge(n * l + a, n * (l + 1) + b, 1, d * (2 * p - 1) + c);\n                        if(b != 1)\n                            ans.addEdge(n * l + b, n * (l + 1) + a, 1, d * (2 * p - 1) + c);\n                    }\n                } \n            }\n            for(int l = 1; l < maxl; l++){\n                ans.addEdge(l * n + 1, T, k, 0);\n            }\n            ans.convertToArray();\n            ans.calWithPotential();\n            // ans.calSimple();\n            if(ans.maxFlow != k){\n                out.println(\"BUG\");\n            }else{\n                out.println((int)ans.minCost);\n            }\n          }\n    }\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream));\n            st = null;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}", "complexity": "cubic", "problem": "1187_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class A {\n    public static void main(String[] args) throws Exception {\n        new A().solve();\n    }\n    void solve() throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        if (n == 0) {\n            System.out.println(\"0 0 0\");\n            return;\n        }\n        int p2 = 0;\n        int p1 = 1;\n        while (true) {\n            int now = p2 + p1;\n            if (n == now) {\n                System.out.println(\"0 \" + p1 + \" \" + p2);\n                return;\n            } else {\n                p2 = p1;\n                p1 = now;\n            }\n        }\n    }\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class A{\n    Scanner sc=new Scanner(System.in);\n\n    void run(){\n        String s=sc.nextLine();\n        int n=s.length();\n        int ans=0;\n        for(int len=1; len<n; len++){\n            for(int i=0; i+len<=n; i++){\n                String t=s.substring(i, i+len);\n//              println(t);\n                if(s.indexOf(t,i+1)!=-1){\n                    ans=len;\n                    break;\n                }\n            }\n        }\n        println(ans+\"\");\n    }\n\n    void println(String s){\n        System.out.println(s);\n    }\n\n    void print(String s){\n        System.out.print(s);\n    }\n\n    public static void main(String[] args){\n        new A().run();\n    }\n\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class PipelineRedo {\n\tpublic static void main(String[] args){\n\t\tFastScanner sc = new FastScanner();\n\t\tlong n = sc.nextLong() - 1;\n\t\tlong k = sc.nextInt() - 1;\n\t\t\n\t\tif(n==0){\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}else if(n <= k){\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}else if(n > k*(k+1)/2){\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//n > k, and there exists a subset (1..k) = n\n\t\t//goal : sum( subset of (1...k) ) = n\n\t\t//obs: if exists a soln, it's always possible to push everything to the right-> t + left...k\n\t\t//so that t + left...k = n, so we just have to find the smallest left such that left..k <= n\n\t\tlong rightSum = k*(k+1)/2;\n\t\tlong lo = 1;\n\t\tlong hi = k;\n\t\twhile(lo < hi){\n\t\t\tlong mid = lo + (hi-lo+1)/2;\n\t\t\tlong val = rightSum - mid*(mid-1)/2;\n\t\t\t\n\t\t\tif(val <= n){\n\t\t\t\thi = mid -1;\n\t\t\t}else{\n\t\t\t\tlo = mid;\n\t\t\t}\n\t\t}\n\t\t//now lo points to the greatest left for which left..k > n\n\t\t//so lo+1 points to the smallest left for which left..k <= n\n\t\t//we still have an extra 't' to the left\n\t\tif(rightSum - (lo+1)*(lo)/2 == n){\n\t\t\tSystem.out.println(k - (lo+1) + 1);\n\t\t}else{\n\t\t\tSystem.out.println(1 + (k - (lo+1) + 1));\n\t\t}\n\t}\n\t\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n}\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        OnTheBench solver = new OnTheBench();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class OnTheBench {\n        long MOD = (long) (1e9) + 7;\n        long[][] C = new long[333][333];\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int N = in.nextInt();\n            DisjointSet dsu = new DisjointSet(N);\n            long[] arr = new long[N];\n            setC();\n            for (int i = 0; i < N; i++) {\n                arr[i] = in.nextInt();\n            }\n            for (int i = 0; i < N; i++) {\n                for (int j = i + 1; j < N; j++) {\n                    long sqrt = (long) (Math.sqrt(arr[i] * arr[j]));\n                    long sqrt2 = (long) (Math.ceil(Math.sqrt(arr[i] * arr[j])));\n                    if (sqrt * sqrt == arr[i] * arr[j] || sqrt2 * sqrt2 == arr[i] * arr[j]) {\n                        dsu.merge(i, j);\n                    }\n                }\n            }\n            ArrayList<Integer> sz = new ArrayList<>();\n            sz.add(0);\n            HashMap<Integer, Integer> seen = new HashMap<>();\n            long mult = 1;\n            for (int i = 0; i < N; i++) {\n                if (!seen.containsKey(dsu.find(i))) {\n                    seen.put(dsu.find(i), sz.size());\n                    sz.add(0);\n                }\n                sz.set(seen.get(dsu.find(i)), sz.get(seen.get(dsu.find(i))) + 1);\n            }\n            for (int i : sz) {\n//            if (arr[0] == 285) {\n//                out.println(i);\n//            }\n                mult *= fact(i);\n                mult %= MOD;\n            }\n            long[][] dp = new long[sz.size()][333];\n            int sum = 0;\n            dp[0][0] = 1;\n            for (int n = 1; n < dp.length; n++) {\n                for (int ij = 1; ij <= sz.get(n); ij++) {\n                    for (int y = 0; y <= sum; y++) {\n                        for (int j = 0; j <= Math.min(y, ij); j++) {\n                            int i = ij - j;\n                            dp[n][y - j + sz.get(n) - ij] += ((((dp[n - 1][y] * C[sum + 1 - y][i]) % MOD * C[y][j]) % MOD) * C[sz.get(n) - 1][ij - 1]) % MOD;\n                            dp[n][y - j + sz.get(n) - ij] %= MOD;\n                        }\n                    }\n                }\n                sum += sz.get(n);\n            }\n            out.println((dp[sz.size() - 1][0] * mult) % MOD);\n        }\n\n        void setC() {\n            for (int i = 0; i <= 332; i++) {\n                C[i][0] = 1;\n                for (int j = 1; j <= i; j++) {\n                    C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n                    C[i][j] %= MOD;\n                }\n            }\n        }\n\n        long fact(int i) {\n            long res = 1;\n            while (i > 0) {\n                res *= i;\n                res %= MOD;\n                i--;\n            }\n            return res;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class DisjointSet {\n        int[] rank;\n        int[] par;\n\n        public DisjointSet(int N) {\n            rank = new int[N];\n            par = new int[N];\n            for (int i = 0; i < N; i++) {\n                rank[i] = 1;\n                par[i] = i;\n            }\n        }\n\n        public int find(int x) {\n            if (x == par[x]) {\n                return x;\n            }\n            return (par[x] = find(par[x]));\n        }\n\n        public void merge(int x, int y) {\n            int parX = find(x);\n            int parY = find(y);\n            if (parX != parY) {\n                if (rank[parX] > rank[parY]) {\n                    par[parY] = parX;\n                    rank[parX] += rank[parY];\n                } else {\n                    par[parX] = parY;\n                    rank[parY] += rank[parX];\n                }\n            }\n        }\n\n    }\n}\n\n", "complexity": "cubic", "problem": "0840_C", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "//package baobab;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class C {\n\n    public static void main(String[] args) {\n        Solver solver = new Solver();\n    }\n\n    static class Solver {\n        IO io;\n\n        public Solver() {\n            this.io = new IO();\n            try {\n                solve();\n            } catch (RuntimeException e) {\n                if (!e.getMessage().equals(\"Clean exit\")) {\n                    throw e;\n                }\n            } finally {\n                io.close();\n            }\n        }\n\n        /****************************** START READING HERE ********************************/\n\n        void solve() {\n            long x = io.nextLong();\n            long k = io.nextLong();\n            if (x==0) done(0);\n            long ans = pow(2,k) * ((2*x - 1)%MOD) + 1;\n            io.println(ans%MOD);\n        }\n\n        long pow(long base, long exp) {\n            if (exp == 0) return 1L;\n            long x = pow(base, exp/2);\n            long ans = x * x;\n            ans %= MOD;\n            if (exp % 2 != 0) {\n                ans *= base;\n                ans %= MOD;\n            }\n            return ans;\n        }\n\n        void solve2() {\n            long x = io.nextLong();\n            long k = io.nextLong();\n            if (x==0) done(0);\n\n            // TODO how to exclude from counts cases where dresses are negative?\n\n            long checkPointA = min(10000, k);\n            double count = x;\n            long i=0;\n            for (; i<checkPointA; i++) {\n                count *= 2;\n                count -= 0.5;\n                count %= MOD;\n            }\n            List<Double> bah = new ArrayList<>();\n            List<Long> meh = new ArrayList<>();\n            while (true) {\n                bah.add(count);\n                meh.add(i);\n                long j = 2*i;\n                if (j > k || j < 0) break;\n                i = j;\n                count *= count;\n                count %= MOD;\n            }\n            while (!bah.isEmpty()) {\n                long muller = meh.get(meh.size()-1);\n                long cand = i + muller;\n                if (cand > k || cand < 0) {\n                    meh.remove(meh.size()-1);\n                    bah.remove(bah.size()-1);\n                    continue;\n                }\n                i = cand;\n                count *= meh.get(meh.size()-1);\n                count %= MOD;\n            }\n            for (; i<k; i++) {\n                count *= 2;\n                count -= 0.5;\n                count %= MOD;\n            }\n            // last month no eating\n            count *= 2;\n            count %= MOD;\n            io.println(Math.round(count));\n        }\n\n        /************************** UTILITY CODE BELOW THIS LINE **************************/\n\n        long MOD = (long)1e9 + 7;\n\n        boolean closeToZero(double v) {\n            // Check if double is close to zero, considering precision issues.\n            return Math.abs(v) <= 0.0000000000001;\n        }\n\n        class DrawGrid {\n\n            void draw(boolean[][] d) {\n                System.out.print(\"  \");\n                for (int x=0; x<d[0].length; x++) {\n                    System.out.print(\" \" + x + \" \");\n                }\n                System.out.println(\"\");\n                for (int y=0; y<d.length; y++) {\n                    System.out.print(y + \" \");\n                    for (int x=0; x<d[0].length; x++) {\n                        System.out.print((d[y][x] ? \"[x]\" : \"[ ]\"));\n                    }\n                    System.out.println(\"\");\n                }\n            }\n\n            void draw(int[][] d) {\n                int max = 1;\n                for (int y=0; y<d.length; y++) {\n                    for (int x=0; x<d[0].length; x++) {\n                        max = Math.max(max, (\"\" + d[y][x]).length());\n                    }\n                }\n                System.out.print(\"  \");\n                String format = \"%\" + (max+2) + \"s\";\n                for (int x=0; x<d[0].length; x++) {\n                    System.out.print(String.format(format, x) + \" \");\n                }\n                format = \"%\" + (max) + \"s\";\n                System.out.println(\"\");\n                for (int y=0; y<d.length; y++) {\n                    System.out.print(y + \" \");\n                    for (int x=0; x<d[0].length; x++) {\n                        System.out.print(\" [\" + String.format(format, (d[y][x])) + \"]\");\n                    }\n                    System.out.println(\"\");\n                }\n            }\n\n        }\n\n        class IDval implements Comparable<IDval> {\n            int id;\n            long val;\n\n            public IDval(int id, long val) {\n                this.val = val;\n                this.id = id;\n            }\n\n            @Override\n            public int compareTo(IDval o) {\n                if (this.val < o.val) return -1;\n                if (this.val > o.val) return 1;\n                return this.id - o.id;\n            }\n        }\n\n        private class ElementCounter {\n            private HashMap<Long, Integer> elements;\n\n            public ElementCounter() {\n                elements = new HashMap<>();\n            }\n\n            public void add(long element) {\n                int count = 1;\n                Integer prev = elements.get(element);\n                if (prev != null) count += prev;\n                elements.put(element, count);\n            }\n\n            public void remove(long element) {\n                int count = elements.remove(element);\n                count--;\n                if (count > 0) elements.put(element, count);\n            }\n\n            public int get(long element) {\n                Integer val = elements.get(element);\n                if (val == null) return 0;\n                return val;\n            }\n\n            public int size() {\n                return elements.size();\n            }\n        }\n\n        class StringCounter {\n            HashMap<String, Integer> elements;\n\n            public StringCounter() {\n                elements = new HashMap<>();\n            }\n\n            public void add(String identifier) {\n                int count = 1;\n                Integer prev = elements.get(identifier);\n                if (prev != null) count += prev;\n                elements.put(identifier, count);\n            }\n\n            public void remove(String identifier) {\n                int count = elements.remove(identifier);\n                count--;\n                if (count > 0) elements.put(identifier, count);\n            }\n\n            public long get(String identifier) {\n                Integer val = elements.get(identifier);\n                if (val == null) return 0;\n                return val;\n            }\n\n            public int size() {\n                return elements.size();\n            }\n        }\n\n        class DisjointSet {\n            /** Union Find / Disjoint Set data structure. */\n            int[] size;\n            int[] parent;\n            int componentCount;\n\n            public DisjointSet(int n) {\n                componentCount = n;\n                size = new int[n];\n                parent = new int[n];\n                for (int i=0; i<n; i++) parent[i] = i;\n                for (int i=0; i<n; i++) size[i] = 1;\n            }\n\n            public void join(int a, int b) {\n                /* Find roots */\n                int rootA = parent[a];\n                int rootB = parent[b];\n                while (rootA != parent[rootA]) rootA = parent[rootA];\n                while (rootB != parent[rootB]) rootB = parent[rootB];\n\n                if (rootA == rootB) {\n                    /* Already in the same set */\n                    return;\n                }\n\n                /* Merge smaller set into larger set. */\n                if (size[rootA] > size[rootB]) {\n                    size[rootA] += size[rootB];\n                    parent[rootB] = rootA;\n                } else {\n                    size[rootB] += size[rootA];\n                    parent[rootA] = rootB;\n                }\n                componentCount--;\n            }\n\n        }\n\n        class Trie {\n            int N;\n            int Z;\n            int nextFreeId;\n            int[][] pointers;\n            boolean[] end;\n\n            /** maxLenSum = maximum possible sum of length of words */\n            public Trie(int maxLenSum, int alphabetSize) {\n                this.N = maxLenSum;\n                this.Z = alphabetSize;\n                this.nextFreeId = 1;\n                pointers = new int[N+1][alphabetSize];\n                end = new boolean[N+1];\n            }\n\n            public void addWord(String word) {\n                int curr = 0;\n                for (int j=0; j<word.length(); j++) {\n                    int c = word.charAt(j) - 'a';\n                    int next = pointers[curr][c];\n                    if (next == 0) {\n                        next = nextFreeId++;\n                        pointers[curr][c] = next;\n                    }\n                    curr = next;\n                }\n                end[curr] = true;\n            }\n\n            public boolean hasWord(String word) {\n                int curr = 0;\n                for (int j=0; j<word.length(); j++) {\n                    int c = word.charAt(j) - 'a';\n                    int next = pointers[curr][c];\n                    if (next == 0) return false;\n                    curr = next;\n                }\n                return end[curr];\n            }\n\n        }\n\n        private static class Prob {\n\n            /** For heavy calculations on probabilities, this class\n             *  provides more accuracy & efficiency than doubles.\n             *  Math explained: https://en.wikipedia.org/wiki/Log_probability\n             *  Quick start:\n             *      - Instantiate probabilities, eg. Prob a = new Prob(0.75)\n             *      - add(), multiply() return new objects, can perform on nulls & NaNs.\n             *      - get() returns probability as a readable double */\n\n            /** Logarithmized probability. Note: 0% represented by logP NaN. */\n            private double logP;\n\n            /** Construct instance with real probability. */\n            public Prob(double real) {\n                if (real > 0) this.logP = Math.log(real);\n                else this.logP = Double.NaN;\n            }\n\n            /** Construct instance with already logarithmized value. */\n            static boolean dontLogAgain = true;\n            public Prob(double logP, boolean anyBooleanHereToChooseThisConstructor) {\n                this.logP = logP;\n            }\n\n            /** Returns real probability as a double. */\n            public double get() {\n                return Math.exp(logP);\n            }\n\n            @Override\n            public String toString() {\n                return \"\"+get();\n            }\n\n            /***************** STATIC METHODS BELOW ********************/\n\n            /** Note: returns NaN only when a && b are both NaN/null. */\n            public static Prob add(Prob a, Prob b) {\n                if (nullOrNaN(a) && nullOrNaN(b)) return new Prob(Double.NaN, dontLogAgain);\n                if (nullOrNaN(a)) return copy(b);\n                if (nullOrNaN(b)) return copy(a);\n\n                double x = Math.max(a.logP, b.logP);\n                double y = Math.min(a.logP, b.logP);\n                double sum = x + Math.log(1 + Math.exp(y - x));\n                return new Prob(sum, dontLogAgain);\n            }\n\n            /** Note: multiplying by null or NaN produces NaN (repping 0% real prob). */\n            public static Prob multiply(Prob a, Prob b) {\n                if (nullOrNaN(a) || nullOrNaN(b)) return new Prob(Double.NaN, dontLogAgain);\n                return new Prob(a.logP + b.logP, dontLogAgain);\n            }\n\n            /** Returns true if p is null or NaN. */\n            private static boolean nullOrNaN(Prob p) {\n                return (p == null || Double.isNaN(p.logP));\n            }\n\n            /** Returns a new instance with the same value as original. */\n            private static Prob copy(Prob original) {\n                return new Prob(original.logP, dontLogAgain);\n            }\n        }\n\n        class Binary implements Comparable<Binary> {\n\n            /**\n             * Use example: Binary b = new Binary(Long.toBinaryString(53249834L));\n             *\n             * When manipulating small binary strings, instantiate new Binary(string)\n             * When just reading large binary strings, instantiate new Binary(string,true)\n             * get(int i) returns a character '1' or '0', not an int.\n             */\n\n            private boolean[] d;\n            private int first; // Starting from left, the first (most remarkable) '1'\n            public int length;\n\n\n            public Binary(String binaryString) {\n                this(binaryString, false);\n            }\n            public Binary(String binaryString, boolean initWithMinArraySize) {\n                length = binaryString.length();\n                int size = Math.max(2*length, 1);\n                first = length/4;\n                if (initWithMinArraySize) {\n                    first = 0;\n                    size = Math.max(length, 1);\n                }\n                d = new boolean[size];\n                for (int i=0; i<length; i++) {\n                    if (binaryString.charAt(i) == '1') d[i+first] = true;\n                }\n            }\n\n            public void addFirst(char c) {\n                if (first-1 < 0) doubleArraySize();\n                first--;\n                d[first] = (c == '1' ? true : false);\n                length++;\n            }\n\n            public void addLast(char c) {\n                if (first+length >= d.length) doubleArraySize();\n                d[first+length] = (c == '1' ? true : false);\n                length++;\n            }\n\n            private void doubleArraySize() {\n                boolean[] bigArray = new boolean[(d.length+1) * 2];\n                int newFirst = bigArray.length / 4;\n                for (int i=0; i<length; i++) {\n                    bigArray[i + newFirst] = d[i + first];\n                }\n                first = newFirst;\n                d = bigArray;\n            }\n\n            public boolean flip(int i) {\n                boolean value = (this.d[first+i] ? false : true);\n                this.d[first+i] = value;\n                return value;\n            }\n\n            public void set(int i, char c) {\n                boolean value = (c == '1' ? true : false);\n                this.d[first+i] = value;\n            }\n\n            public char get(int i) {\n                return (this.d[first+i] ? '1' : '0');\n            }\n\n            @Override\n            public int compareTo(Binary o) {\n                if (this.length != o.length) return this.length - o.length;\n                int len = this.length;\n                for (int i=0; i<len; i++) {\n                    int diff = this.get(i) - o.get(i);\n                    if (diff != 0) return diff;\n                }\n                return 0;\n            }\n\n            @Override\n            public String toString() {\n                StringBuilder sb = new StringBuilder();\n                for (int i=0; i<length; i++) {\n                    sb.append(d[i+first] ? '1' : '0');\n                }\n                return sb.toString();\n            }\n\n\n        }\n\n        /************************** Range queries **************************/\n\n        class FenwickMin {\n            long n;\n            long[] original;\n            long[] bottomUp;\n            long[] topDown;\n\n            public FenwickMin(int n) {\n                this.n = n;\n                original = new long[n+2];\n                bottomUp = new long[n+2];\n                topDown = new long[n+2];\n            }\n\n            public void set(int modifiedNode, long value) {\n                long replaced = original[modifiedNode];\n                original[modifiedNode] = value;\n                // Update left tree\n                int i = modifiedNode;\n                long v = value;\n                while (i <= n) {\n                    if (v > bottomUp[i]) {\n                        if (replaced == bottomUp[i]) {\n                            v = Math.min(v, original[i]);\n                            for (int r=1 ;; r++) {\n                                int x = (i&-i)>>>r;\n                                if (x == 0) break;\n                                int child = i-x;\n                                v = Math.min(v, bottomUp[child]);\n                            }\n                        } else break;\n                    }\n                    if (v == bottomUp[i]) break;\n                    bottomUp[i] = v;\n                    i += (i&-i);\n                }\n                // Update right tree\n                i = modifiedNode;\n                v = value;\n                while (i > 0) {\n                    if (v > topDown[i]) {\n                        if (replaced == topDown[i]) {\n                            v = Math.min(v, original[i]);\n                            for (int r=1 ;; r++) {\n                                int x = (i&-i)>>>r;\n                                if (x == 0) break;\n                                int child = i+x;\n                                if (child > n+1) break;\n                                v = Math.min(v, topDown[child]);\n                            }\n                        } else break;\n                    }\n                    if (v == topDown[i]) break;\n                    topDown[i] = v;\n                    i -= (i&-i);\n                }\n            }\n\n            public long getMin(int a, int b) {\n                long min = original[a];\n                int prev = a;\n                int curr = prev + (prev&-prev); // parent right hand side\n                while (curr <= b) {\n                    min = Math.min(min, topDown[prev]); // value from the other tree\n                    prev = curr;\n                    curr = prev + (prev&-prev);;\n                }\n                min = Math.min(min, original[prev]);\n                prev = b;\n                curr = prev - (prev&-prev); // parent left hand side\n                while (curr >= a) {\n                    min = Math.min(min,bottomUp[prev]); // value from the other tree\n                    prev = curr;\n                    curr = prev - (prev&-prev);\n                }\n                return min;\n            }\n\n        }\n\n        class FenwickSum {\n            public long[] d;\n\n            public FenwickSum(int n) {\n                d=new long[n+1];\n            }\n\n            /** a[0] must be unused. */\n            public FenwickSum(long[] a) {\n                d=new long[a.length];\n                for (int i=1; i<a.length; i++) {\n                    modify(i, a[i]);\n                }\n            }\n\n            /** Do not modify i=0. */\n            void modify(int i, long v) {\n                while (i<d.length) {\n                    d[i] += v;\n                    // Move to next uplink on the RIGHT side of i\n                    i += (i&-i);\n                }\n            }\n\n            /** Returns sum from a to b, *BOTH* inclusive. */\n            long getSum(int a, int b) {\n                return getSum(b) - getSum(a-1);\n            }\n\n            private long getSum(int i) {\n                long sum = 0;\n                while (i>0) {\n                    sum += d[i];\n                    // Move to next uplink on the LEFT side of i\n                    i -= (i&-i);\n                }\n                return sum;\n            }\n        }\n\n        class SegmentTree {\n            /** Query sums with log(n) modifyRange */\n            int N;\n            long[] p;\n\n            public SegmentTree(int n) {\n                /* TODO: Test that this works. */\n                for (N=2; N<n; N++) N *= 2;\n                p = new long[2*N];\n            }\n\n            public void modifyRange(int a, int b, long change) {\n                muuta(a, change);\n                muuta(b+1, -change);\n            }\n\n            void muuta(int k, long muutos) {\n                k += N;\n                p[k] += muutos;\n                for (k /= 2; k >= 1; k /= 2) {\n                    p[k] = p[2*k] + p[2*k+1];\n                }\n            }\n\n            public long get(int k) {\n                int a = N;\n                int b = k+N;\n                long s = 0;\n                while (a <= b) {\n                    if (a%2 == 1) s += p[a++];\n                    if (b%2 == 0) s += p[b--];\n                    a /= 2;\n                    b /= 2;\n                }\n                return s;\n            }\n\n        }\n\n        /***************************** Graphs *****************************/\n\n        List<Integer>[] toGraph(IO io, int n) {\n            List<Integer>[] g = new ArrayList[n+1];\n            for (int i=1; i<=n; i++) g[i] = new ArrayList<>();\n            for (int i=1; i<=n-1; i++) {\n                int a = io.nextInt();\n                int b = io.nextInt();\n                g[a].add(b);\n                g[b].add(a);\n            }\n            return g;\n        }\n\n        class Graph {\n            HashMap<Long, List<Long>> edges;\n\n            public Graph() {\n                edges = new HashMap<>();\n            }\n\n            List<Long> getSetNeighbors(Long node) {\n                List<Long> neighbors = edges.get(node);\n                if (neighbors == null) {\n                    neighbors = new ArrayList<>();\n                    edges.put(node, neighbors);\n                }\n                return neighbors;\n            }\n\n            void addBiEdge(Long a, Long b) {\n                addEdge(a, b);\n                addEdge(b, a);\n            }\n\n            void addEdge(Long from, Long to) {\n                getSetNeighbors(to); // make sure all have initialized lists\n                List<Long> neighbors = getSetNeighbors(from);\n                neighbors.add(to);\n            }\n\n            // topoSort variables\n            int UNTOUCHED = 0;\n            int FINISHED = 2;\n            int INPROGRESS = 1;\n            HashMap<Long, Integer> vis;\n            List<Long> topoAns;\n            List<Long> failDueToCycle = new ArrayList<Long>() {{ add(-1L); }};\n\n            List<Long> topoSort() {\n                topoAns = new ArrayList<>();\n                vis = new HashMap<>();\n                for (Long a : edges.keySet()) {\n                    if (!topoDFS(a)) return failDueToCycle;\n                }\n                Collections.reverse(topoAns);\n                return topoAns;\n            }\n\n            boolean topoDFS(long curr) {\n                Integer status = vis.get(curr);\n                if (status == null) status = UNTOUCHED;\n                if (status == FINISHED) return true;\n                if (status == INPROGRESS) {\n                    return false;\n                }\n                vis.put(curr, INPROGRESS);\n                for (long next : edges.get(curr)) {\n                    if (!topoDFS(next)) return false;\n                }\n                vis.put(curr, FINISHED);\n                topoAns.add(curr);\n                return true;\n            }\n\n        }\n\n        public class StronglyConnectedComponents {\n\n            /** Kosaraju's algorithm */\n\n            ArrayList<Integer>[] forw;\n            ArrayList<Integer>[] bacw;\n\n            /** Use: getCount(2, new int[] {1,2}, new int[] {2,1}) */\n            public int getCount(int n, int[] mista, int[] minne) {\n                forw = new ArrayList[n+1];\n                bacw = new ArrayList[n+1];\n                for (int i=1; i<=n; i++) {\n                    forw[i] = new ArrayList<Integer>();\n                    bacw[i] = new ArrayList<Integer>();\n                }\n                for (int i=0; i<mista.length; i++) {\n                    int a = mista[i];\n                    int b = minne[i];\n                    forw[a].add(b);\n                    bacw[b].add(a);\n                }\n                int count = 0;\n                List<Integer> list = new ArrayList<Integer>();\n                boolean[] visited = new boolean[n+1];\n                for (int i=1; i<=n; i++) {\n                    dfsForward(i, visited, list);\n                }\n                visited = new boolean[n+1];\n                for (int i=n-1; i>=0; i--) {\n                    int node = list.get(i);\n                    if (visited[node]) continue;\n                    count++;\n                    dfsBackward(node, visited);\n                }\n                return count;\n            }\n\n            public void dfsForward(int i, boolean[] visited, List<Integer> list) {\n                if (visited[i]) return;\n                visited[i] = true;\n                for (int neighbor : forw[i]) {\n                    dfsForward(neighbor, visited, list);\n                }\n                list.add(i);\n            }\n\n            public void dfsBackward(int i, boolean[] visited) {\n                if (visited[i]) return;\n                visited[i] = true;\n                for (int neighbor : bacw[i]) {\n                    dfsBackward(neighbor, visited);\n                }\n            }\n        }\n\n        class LCAFinder {\n\n            /* O(n log n) Initialize: new LCAFinder(graph)\n             * O(log n) Queries: find(a,b) returns lowest common ancestor for nodes a and b */\n\n            int[] nodes;\n            int[] depths;\n            int[] entries;\n            int pointer;\n            FenwickMin fenwick;\n\n            public LCAFinder(List<Integer>[] graph) {\n                this.nodes = new int[(int)10e6];\n                this.depths = new int[(int)10e6];\n                this.entries = new int[graph.length];\n                this.pointer = 1;\n                boolean[] visited = new boolean[graph.length+1];\n                dfs(1, 0, graph, visited);\n                fenwick = new FenwickMin(pointer-1);\n                for (int i=1; i<pointer; i++) {\n                    fenwick.set(i, depths[i] * 1000000L + i);\n                }\n            }\n\n            private void dfs(int node, int depth, List<Integer>[] graph, boolean[] visited) {\n                visited[node] = true;\n                entries[node] = pointer;\n                nodes[pointer] = node;\n                depths[pointer] = depth;\n                pointer++;\n                for (int neighbor : graph[node]) {\n                    if (visited[neighbor]) continue;\n                    dfs(neighbor, depth+1, graph, visited);\n                    nodes[pointer] = node;\n                    depths[pointer] = depth;\n                    pointer++;\n                }\n            }\n\n            public int find(int a, int b) {\n                int left = entries[a];\n                int right = entries[b];\n                if (left > right) {\n                    int temp = left;\n                    left = right;\n                    right = temp;\n                }\n                long mixedBag = fenwick.getMin(left, right);\n                int index = (int) (mixedBag % 1000000L);\n                return nodes[index];\n            }\n        }\n\n        /**************************** Geometry ****************************/\n\n        class Point {\n            int y;\n            int x;\n\n            public Point(int y, int x) {\n                this.y = y;\n                this.x = x;\n            }\n        }\n\n        boolean segmentsIntersect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {\n            // Returns true if segment 1-2 intersects segment 3-4\n\n            if (x1 == x2 && x3 == x4) {\n                // Both segments are vertical\n                if (x1 != x3) return false;\n                if (min(y1,y2) < min(y3,y4)) {\n                    return max(y1,y2) >= min(y3,y4);\n                } else {\n                    return max(y3,y4) >= min(y1,y2);\n                }\n            }\n            if (x1 == x2) {\n                // Only segment 1-2 is vertical. Does segment 3-4 cross it? y = a*x + b\n                double a34 = (y4-y3)/(x4-x3);\n                double b34 = y3 - a34*x3;\n                double y = a34 * x1 + b34;\n                return y >= min(y1,y2) && y <= max(y1,y2) && x1 >= min(x3,x4) && x1 <= max(x3,x4);\n            }\n            if (x3 == x4) {\n                // Only segment 3-4 is vertical. Does segment 1-2 cross it? y = a*x + b\n                double a12 = (y2-y1)/(x2-x1);\n                double b12 = y1 - a12*x1;\n                double y = a12 * x3 + b12;\n                return y >= min(y3,y4) && y <= max(y3,y4) && x3 >= min(x1,x2) && x3 <= max(x1,x2);\n            }\n            double a12 = (y2-y1)/(x2-x1);\n            double b12 = y1 - a12*x1;\n            double a34 = (y4-y3)/(x4-x3);\n            double b34 = y3 - a34*x3;\n            if (closeToZero(a12 - a34)) {\n                // Parallel lines\n                return closeToZero(b12 - b34);\n            }\n            // Non parallel non vertical lines intersect at x. Is x part of both segments?\n            double x = -(b12-b34)/(a12-a34);\n            return x >= min(x1,x2) && x <= max(x1,x2) && x >= min(x3,x4) && x <= max(x3,x4);\n        }\n\n        boolean pointInsideRectangle(Point p, List<Point> r) {\n            Point a = r.get(0);\n            Point b = r.get(1);\n            Point c = r.get(2);\n            Point d = r.get(3);\n            double apd = areaOfTriangle(a, p, d);\n            double dpc = areaOfTriangle(d, p, c);\n            double cpb = areaOfTriangle(c, p, b);\n            double pba = areaOfTriangle(p, b, a);\n            double sumOfAreas = apd + dpc + cpb + pba;\n            if (closeToZero(sumOfAreas - areaOfRectangle(r))) {\n                if (closeToZero(apd) || closeToZero(dpc) || closeToZero(cpb) || closeToZero(pba)) {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n\n        double areaOfTriangle(Point a, Point b, Point c) {\n            return 0.5 * Math.abs((a.x-c.x)*(b.y-a.y)-(a.x-b.x)*(c.y-a.y));\n        }\n\n        double areaOfRectangle(List<Point> r) {\n            double side1xDiff = r.get(0).x - r.get(1).x;\n            double side1yDiff = r.get(0).y - r.get(1).y;\n            double side2xDiff = r.get(1).x - r.get(2).x;\n            double side2yDiff = r.get(1).y - r.get(2).y;\n            double side1 = Math.sqrt(side1xDiff * side1xDiff + side1yDiff * side1yDiff);\n            double side2 = Math.sqrt(side2xDiff * side2xDiff + side2yDiff * side2yDiff);\n            return side1 * side2;\n        }\n\n        boolean pointsOnSameLine(double x1, double y1, double x2, double y2, double x3, double y3) {\n            double areaTimes2 = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2);\n            return (closeToZero(areaTimes2));\n        }\n\n        class PointToLineSegmentDistanceCalculator {\n\n            // Just call this\n            double minDistFromPointToLineSegment(double point_x, double point_y, double x1, double y1, double x2, double y2) {\n                return Math.sqrt(distToSegmentSquared(point_x, point_y, x1, y1, x2, y2));\n            }\n\n            private double distToSegmentSquared(double point_x, double point_y, double x1, double y1, double x2, double y2) {\n                double l2 = dist2(x1,y1,x2,y2);\n                if (l2 == 0) return dist2(point_x, point_y, x1, y1);\n                double t = ((point_x - x1) * (x2 - x1) + (point_y - y1) * (y2 - y1)) / l2;\n                if (t < 0) return dist2(point_x, point_y, x1, y1);\n                if (t > 1) return dist2(point_x, point_y, x2, y2);\n\n                double com_x = x1 + t * (x2 - x1);\n                double com_y = y1 + t * (y2 - y1);\n                return dist2(point_x, point_y, com_x, com_y);\n            }\n\n            private double dist2(double x1, double y1, double x2, double y2) {\n                return Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n            }\n\n        }\n\n        /****************************** Math ******************************/\n\n\n\n        long gcd(long... v) {\n            /** Chained calls to Euclidean algorithm. */\n            if (v.length == 1) return v[0];\n            long ans = gcd(v[1], v[0]);\n            for (int i=2; i<v.length; i++) {\n                ans = gcd(ans, v[i]);\n            }\n            return ans;\n        }\n\n        long gcd(long a, long b) {\n            /** Euclidean algorithm. */\n            if (b == 0) return a;\n            return gcd(b, a%b);\n        }\n\n        int[] generatePrimesUpTo(int last) {\n            /* Sieve of Eratosthenes. Practically O(n). Values of 0 indicate primes. */\n            int[] div = new int[last+1];\n            for (int x=2; x<=last; x++) {\n                if (div[x] > 0) continue;\n                for (int u=2*x; u<=last; u+=x) {\n                    div[u] = x;\n                }\n            }\n            return div;\n        }\n\n        long lcm(long a, long b) {\n            /** Least common multiple */\n            return a * b / gcd(a,b);\n        }\n\n        class BaseConverter {\n\n            /* Palauttaa luvun esityksen kannassa base */\n            public String convert(Long number, int base) {\n                return Long.toString(number, base);\n            }\n\n            /* Palauttaa luvun esityksen kannassa baseTo, kun annetaan luku Stringin\u00e4 kannassa baseFrom */\n            public String convert(String number, int baseFrom, int baseTo) {\n                return Long.toString(Long.parseLong(number, baseFrom), baseTo);\n            }\n\n            /* Tulkitsee kannassa base esitetyn luvun longiksi (kannassa 10) */\n            public long longify(String number, int baseFrom) {\n                return Long.parseLong(number, baseFrom);\n            }\n        }\n\n        class BinomialCoefficients {\n            /** Total number of K sized unique combinations from pool of size N (unordered)\n             N! / ( K! (N - K)! )   */\n\n            /** For simple queries where output fits in long. */\n            public long biCo(long n, long k) {\n                long r = 1;\n                if (k > n) return 0;\n                for (long d = 1; d <= k; d++) {\n                    r *= n--;\n                    r /= d;\n                }\n                return r;\n            }\n\n            /** For multiple queries with same n, different k. */\n            public long[] precalcBinomialCoefficientsK(int n, int maxK) {\n                long v[] = new long[maxK+1];\n                v[0] = 1; // nC0 == 1\n                for (int i=1; i<=n; i++) {\n                    for (int j=Math.min(i,maxK); j>0; j--) {\n                        v[j] = v[j] + v[j-1]; // Pascal's triangle\n                    }\n                }\n                return v;\n            }\n\n            /** When output needs % MOD. */\n            public long[] precalcBinomialCoefficientsK(int n, int k, long M) {\n                long v[] = new long[k+1];\n                v[0] = 1; // nC0 == 1\n                for (int i=1; i<=n; i++) {\n                    for (int j=Math.min(i,k); j>0; j--) {\n                        v[j] = v[j] + v[j-1]; // Pascal's triangle\n                        v[j] %= M;\n                    }\n                }\n                return v;\n            }\n        }\n\n        /**************************** Strings ****************************/\n\n        class Zalgo {\n\n            public int pisinEsiintyma(String haku, String kohde) {\n                char[] s = new char[haku.length() + 1 + kohde.length()];\n                for (int i=0; i<haku.length(); i++) {\n                    s[i] = haku.charAt(i);\n                }\n                int j = haku.length();\n                s[j++] = '#';\n                for (int i=0; i<kohde.length(); i++) {\n                    s[j++] = kohde.charAt(i);\n                }\n                int[] z = toZarray(s);\n                int max = 0;\n                for (int i=haku.length(); i<z.length; i++) {\n                    max = Math.max(max, z[i]);\n                }\n                return max;\n            }\n\n            public int[] toZarray(char[] s) {\n                int n = s.length;\n                int[] z = new int[n];\n                int a = 0, b = 0;\n                for (int i = 1; i < n; i++) {\n                    if (i > b) {\n                        for (int j = i; j < n && s[j - i] == s[j]; j++)  z[i]++;\n                    }\n                    else {\n                        z[i] = z[i - a];\n                        if (i + z[i - a] > b) {\n                            for (int j = b + 1; j < n && s[j - i] == s[j]; j++) z[i]++;\n                            a = i;\n                            b = i + z[i] - 1;\n                        }\n                    }\n                }\n                return z;\n            }\n\n            public List<Integer> getStartIndexesWhereWordIsFound(String haku, String kohde) {\n                // this is alternative use case\n                char[] s = new char[haku.length() + 1 + kohde.length()];\n                for (int i=0; i<haku.length(); i++) {\n                    s[i] = haku.charAt(i);\n                }\n                int j = haku.length();\n                s[j++] = '#';\n                for (int i=0; i<kohde.length(); i++) {\n                    s[j++] = kohde.charAt(i);\n                }\n                int[] z = toZarray(s);\n                List<Integer> indexes = new ArrayList<>();\n                for (int i=haku.length(); i<z.length; i++) {\n                    if (z[i] < haku.length()) continue;\n                    indexes.add(i);\n                }\n                return indexes;\n            }\n\n        }\n\n        class StringHasher {\n\n            class HashedString {\n                long[] hashes;\n                long[] modifiers;\n\n                public HashedString(long[] hashes, long[] modifiers) {\n                    this.hashes = hashes;\n                    this.modifiers = modifiers;\n                }\n            }\n\n            long P;\n            long M;\n\n            public StringHasher() {\n                initializePandM();\n            }\n\n            HashedString hashString(String s) {\n                int n = s.length();\n                long[] hashes = new long[n];\n                long[] modifiers = new long[n];\n                hashes[0] = s.charAt(0);\n                modifiers[0] = 1;\n                for (int i=1; i<n; i++) {\n                    hashes[i] = (hashes[i-1] * P + s.charAt(i)) % M;\n                    modifiers[i] = (modifiers[i-1] * P) % M;\n                }\n                return new HashedString(hashes, modifiers);\n            }\n\n            /**\n             * Indices are inclusive.\n             */\n            long getHash(HashedString hashedString, int startIndex, int endIndex) {\n                long[] hashes = hashedString.hashes;\n                long[] modifiers = hashedString.modifiers;\n                long result = hashes[endIndex];\n                if (startIndex > 0) result -= (hashes[startIndex-1] * modifiers[endIndex-startIndex+1]) % M;\n                if (result < 0) result += M;\n                return result;\n            }\n\n            // Less interesting methods below\n\n\n\n            /**\n             * Efficient for 2 input parameter strings in particular.\n             */\n            HashedString[] hashString(String first, String second) {\n                HashedString[] array = new HashedString[2];\n                int n = first.length();\n                long[] modifiers = new long[n];\n                modifiers[0] = 1;\n\n                long[] firstHashes = new long[n];\n                firstHashes[0] = first.charAt(0);\n                array[0] = new HashedString(firstHashes, modifiers);\n\n                long[] secondHashes = new long[n];\n                secondHashes[0] = second.charAt(0);\n                array[1] = new HashedString(secondHashes, modifiers);\n\n                for (int i=1; i<n; i++) {\n                    modifiers[i] = (modifiers[i-1] * P) % M;\n                    firstHashes[i] = (firstHashes[i-1] * P + first.charAt(i)) % M;\n                    secondHashes[i] = (secondHashes[i-1] * P + second.charAt(i)) % M;\n                }\n                return array;\n            }\n\n            /**\n             * Efficient for 3+ strings\n             * More efficient than multiple hashString calls IF strings are same length.\n             */\n            HashedString[] hashString(String... strings) {\n                HashedString[] array = new HashedString[strings.length];\n                int n = strings[0].length();\n                long[] modifiers = new long[n];\n                modifiers[0] = 1;\n                for (int j=0; j<strings.length; j++) {\n                    // if all strings are not same length, defer work to another method\n                    if (strings[j].length() != n) {\n                        for (int i=0; i<n; i++) {\n                            array[i] = hashString(strings[i]);\n                        }\n                        return array;\n                    }\n\n                    // otherwise initialize stuff\n                    long[] hashes = new long[n];\n                    hashes[0] = strings[j].charAt(0);\n                    array[j] = new HashedString(hashes, modifiers);\n                }\n                for (int i=1; i<n; i++) {\n                    modifiers[i] = (modifiers[i-1] * P) % M;\n                    for (int j=0; j<strings.length; j++) {\n                        String s = strings[j];\n                        long[] hashes = array[j].hashes;\n                        hashes[i] = (hashes[i-1] * P + s.charAt(i)) % M;\n                    }\n                }\n                return array;\n            }\n\n            void initializePandM() {\n                ArrayList<Long> modOptions = new ArrayList<>(20);\n                modOptions.add(353873237L);\n                modOptions.add(353875897L);\n                modOptions.add(353878703L);\n                modOptions.add(353882671L);\n                modOptions.add(353885303L);\n                modOptions.add(353888377L);\n                modOptions.add(353893457L);\n                P = modOptions.get(new Random().nextInt(modOptions.size()));\n\n                modOptions.clear();\n                modOptions.add(452940277L);\n                modOptions.add(452947687L);\n                modOptions.add(464478431L);\n                modOptions.add(468098221L);\n                modOptions.add(470374601L);\n                modOptions.add(472879717L);\n                modOptions.add(472881973L);\n                M = modOptions.get(new Random().nextInt(modOptions.size()));\n\n            }\n        }\n\n        /*************************** Technical ***************************/\n\n        private class IO extends PrintWriter {\n            private InputStreamReader r;\n            private static final int BUFSIZE = 1 << 15;\n            private char[] buf;\n            private int bufc;\n            private int bufi;\n            private StringBuilder sb;\n\n            public IO() {\n                super(new BufferedOutputStream(System.out));\n                r = new InputStreamReader(System.in);\n\n                buf = new char[BUFSIZE];\n                bufc = 0;\n                bufi = 0;\n                sb = new StringBuilder();\n            }\n\n            /** Print, flush, return nextInt. */\n            private int queryInt(String s) {\n                io.println(s);\n                io.flush();\n                return nextInt();\n            }\n\n            /** Print, flush, return nextLong. */\n            private long queryLong(String s) {\n                io.println(s);\n                io.flush();\n                return nextLong();\n            }\n\n            /** Print, flush, return next word. */\n            private String queryNext(String s) {\n                io.println(s);\n                io.flush();\n                return next();\n            }\n\n            private void fillBuf() throws IOException {\n                bufi = 0;\n                bufc = 0;\n                while(bufc == 0) {\n                    bufc = r.read(buf, 0, BUFSIZE);\n                    if(bufc == -1) {\n                        bufc = 0;\n                        return;\n                    }\n                }\n            }\n\n            private boolean pumpBuf() throws IOException {\n                if(bufi == bufc) {\n                    fillBuf();\n                }\n                return bufc != 0;\n            }\n\n            private boolean isDelimiter(char c) {\n                return c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f';\n            }\n\n            private void eatDelimiters() throws IOException {\n                while(true) {\n                    if(bufi == bufc) {\n                        fillBuf();\n                        if(bufc == 0) throw new RuntimeException(\"IO: Out of input.\");\n                    }\n\n                    if(!isDelimiter(buf[bufi])) break;\n                    ++bufi;\n                }\n            }\n\n            public String next() {\n                try {\n                    sb.setLength(0);\n\n                    eatDelimiters();\n                    int start = bufi;\n\n                    while(true) {\n                        if(bufi == bufc) {\n                            sb.append(buf, start, bufi - start);\n                            fillBuf();\n                            start = 0;\n                            if(bufc == 0) break;\n                        }\n\n                        if(isDelimiter(buf[bufi])) break;\n                        ++bufi;\n                    }\n\n                    sb.append(buf, start, bufi - start);\n\n                    return sb.toString();\n                } catch(IOException e) {\n                    throw new RuntimeException(\"IO.next: Caught IOException.\");\n                }\n            }\n\n            public int nextInt() {\n                try {\n                    int ret = 0;\n\n                    eatDelimiters();\n\n                    boolean positive = true;\n                    if(buf[bufi] == '-') {\n                        ++bufi;\n                        if(!pumpBuf()) throw new RuntimeException(\"IO.nextInt: Invalid int.\");\n                        positive = false;\n                    }\n\n                    boolean first = true;\n                    while(true) {\n                        if(!pumpBuf()) break;\n                        if(isDelimiter(buf[bufi])) {\n                            if(first) throw new RuntimeException(\"IO.nextInt: Invalid int.\");\n                            break;\n                        }\n                        first = false;\n\n                        if(buf[bufi] >= '0' && buf[bufi] <= '9') {\n                            if(ret < -214748364) throw new RuntimeException(\"IO.nextInt: Invalid int.\");\n                            ret *= 10;\n                            ret -= (int)(buf[bufi] - '0');\n                            if(ret > 0) throw new RuntimeException(\"IO.nextInt: Invalid int.\");\n                        } else {\n                            throw new RuntimeException(\"IO.nextInt: Invalid int.\");\n                        }\n\n                        ++bufi;\n                    }\n\n                    if(positive) {\n                        if(ret == -2147483648) throw new RuntimeException(\"IO.nextInt: Invalid int.\");\n                        ret = -ret;\n                    }\n\n                    return ret;\n                } catch(IOException e) {\n                    throw new RuntimeException(\"IO.nextInt: Caught IOException.\");\n                }\n            }\n\n            public long nextLong() {\n                try {\n                    long ret = 0;\n\n                    eatDelimiters();\n\n                    boolean positive = true;\n                    if(buf[bufi] == '-') {\n                        ++bufi;\n                        if(!pumpBuf()) throw new RuntimeException(\"IO.nextLong: Invalid long.\");\n                        positive = false;\n                    }\n\n                    boolean first = true;\n                    while(true) {\n                        if(!pumpBuf()) break;\n                        if(isDelimiter(buf[bufi])) {\n                            if(first) throw new RuntimeException(\"IO.nextLong: Invalid long.\");\n                            break;\n                        }\n                        first = false;\n\n                        if(buf[bufi] >= '0' && buf[bufi] <= '9') {\n                            if(ret < -922337203685477580L) throw new RuntimeException(\"IO.nextLong: Invalid long.\");\n                            ret *= 10;\n                            ret -= (long)(buf[bufi] - '0');\n                            if(ret > 0) throw new RuntimeException(\"IO.nextLong: Invalid long.\");\n                        } else {\n                            throw new RuntimeException(\"IO.nextLong: Invalid long.\");\n                        }\n\n                        ++bufi;\n                    }\n\n                    if(positive) {\n                        if(ret == -9223372036854775808L) throw new RuntimeException(\"IO.nextLong: Invalid long.\");\n                        ret = -ret;\n                    }\n\n                    return ret;\n                } catch(IOException e) {\n                    throw new RuntimeException(\"IO.nextLong: Caught IOException.\");\n                }\n            }\n\n            public double nextDouble() {\n                return Double.parseDouble(next());\n            }\n\n        }\n\n        void print(Object output) {\n            io.println(output);\n        }\n\n        void done(Object output) {\n            print(output);\n            done();\n        }\n\n        void done() {\n            io.close();\n            throw new RuntimeException(\"Clean exit\");\n        }\n\n        long min(long... v) {\n            long ans = v[0];\n            for (int i=1; i<v.length; i++) {\n                ans = Math.min(ans, v[i]);\n            }\n            return ans;\n        }\n\n        double min(double... v) {\n            double ans = v[0];\n            for (int i=1; i<v.length; i++) {\n                ans = Math.min(ans, v[i]);\n            }\n            return ans;\n        }\n\n        int min(int... v) {\n            int ans = v[0];\n            for (int i=1; i<v.length; i++) {\n                ans = Math.min(ans, v[i]);\n            }\n            return ans;\n        }\n\n        long max(long... v) {\n            long ans = v[0];\n            for (int i=1; i<v.length; i++) {\n                ans = Math.max(ans, v[i]);\n            }\n            return ans;\n        }\n\n        double max(double... v) {\n            double ans = v[0];\n            for (int i=1; i<v.length; i++) {\n                ans = Math.max(ans, v[i]);\n            }\n            return ans;\n        }\n\n        int max(int... v) {\n            int ans = v[0];\n            for (int i=1; i<v.length; i++) {\n                ans = Math.max(ans, v[i]);\n            }\n            return ans;\n        }\n\n    }\n\n}\n\n\n\n\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class C {\n    static boolean[][] matrix;\n    static long[][] dp;\n    static int n;\n    static int m;\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        n = s.nextInt();\n        m = s.nextInt();\n        matrix = new boolean[n][n];\n        for (int i=0; i<m; ++i) {\n            int v1 = s.nextInt()-1;\n            int v2 = s.nextInt()-1;\n            matrix[v1][v2] = true;\n            matrix[v2][v1] = true;\n        }\n        dp = new long[n][1<<n+1];\n        for (int i=0; i<n; ++i) Arrays.fill(dp[i], -1);\n        \n        long res = 0;\n        for (int i=0; i<n; ++i)\n            res += calc(i, i, (1<<i), 1);\n        \n        System.out.println(res/2);\n    }\n    \n    public static long calc(int h, int c, int m, int len) {\n        if (dp[c][m] != -1)\n            return dp[c][m];\n        \n        long ret = 0;\n        if (len > 2 && matrix[c][h])\n            ret = 1;\n        for (int i=h+1; i<n; ++i)\n            if ((m & (1<<i)) == 0 && matrix[c][i])\n                ret += calc(h, i, m | (1<<i), len + 1);\n        return dp[c][m] = ret;\n    }\n}", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n   private static IO io;\n\n   public static void main(String[] args) throws IOException {\n       new Main().run();\n   }\n\n   private void run() throws IOException {\n       io = new IO(System.getProperty(\"ONLINE_JUDGE\")!=null);\n       solve();\n       io.flush();\n   }\n   \n   private void solve() throws IOException {\n       int n = io.nI(), a = io.nI(), b = io.nI(), h[] = new int[n], i;\n       for(i = 0; i<n; i++)h[i] = io.nI(); Arrays.sort(h);\n       io.wln(h[b]-h[b-1]);\n   }//2.2250738585072012e-308\n   \n   private int gcd(int a, int b) {\n       while(b>0) b^=a^=b^=a%=b;\n       return a;\n   }\n   \n   @SuppressWarnings(\"unused\")\n   private class IO{\n       StreamTokenizer in; PrintWriter out; BufferedReader br; Reader reader; Writer writer;\n       public IO(boolean oj) throws IOException{\n           Locale.setDefault(Locale.US);\n           reader = oj ? new InputStreamReader(System.in) : new FileReader(\"input.txt\");\n           writer = oj ? new OutputStreamWriter(System.out) : new FileWriter(\"output.txt\");\n           br = new BufferedReader(reader);\n           in = new StreamTokenizer(br);\n           out = new PrintWriter(writer);\n       }\n       public void wln(){out.println();}\n       public void wln(int arg){out.println(arg);}\n       public void wln(long arg){out.println(arg);}\n       public void wln(double arg){out.println(arg);}\n       public void wln(String arg){out.println(arg);}\n       public void wln(boolean arg){out.println(arg);}\n       public void wln(char arg){out.println(arg);}\n       public void wln(float arg){out.println(arg);}\n       public void wln(Object arg){out.println(arg);}\n       public void w(int arg){out.print(arg);}\n       public void w(long arg){out.print(arg);}\n       public void w(double arg){out.print(arg);}\n       public void w(String arg){out.print(arg);}\n       public void w(boolean arg){out.print(arg);}\n       public void w(char arg){out.print(arg);}\n       public void w(float arg){out.print(arg);}\n       public void w(Object arg){out.print(arg);}\n       public void wf(String format, Object...args){out.printf(format, args);}\n       public void flush(){out.flush();}\n       public int nI() throws IOException {in.nextToken(); return(int)in.nval;}\n       public long nL() throws IOException {in.nextToken(); return(long)in.nval;}\n       public String nS() throws IOException {in.nextToken(); return in.sval;}\n       public double nD() throws IOException {in.nextToken(); return in.nval;}\n       public float nF() throws IOException {in.nextToken(); return (float)in.nval;}\n       public void wc(char...a){for(char c : a){in.ordinaryChar(c);in.wordChars(c, c);}}\n       public void wc(char c1, char c2){in.ordinaryChars(c1, c2); in.wordChars(c1, c2);}\n   }\n}", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.util.StringTokenizer;\n\n\n\n\n\npublic class B2 {\t\n\n\tBufferedReader reader;\n\n    StringTokenizer tokenizer;\n\n    PrintWriter out;\n\n    \n\n\tpublic void solve() throws IOException {\t\t\t\t\n\n\t\tlong N = nextLong()-1;\n\n\t\tlong K = nextLong()-1;\n\n\t\tif( (1+K) * K < 2*N ){\n\n\t\t\tout.println(-1); return;\n\n\t\t}\n\n\t\tif( N == 0 ){\n\n\t\t\tout.println(0); return;\n\n\t\t}\n\n\t\t\n\n\t\tlong l = 1;\n\n\t\tlong r = K;\n\n\t\twhile(l < r){\n\n\t\t\tlong mid = (l + r) /2;\n\n\t\t\tlong value = (1+K)*K/2 - (1+mid-1)*(mid-1)/2;\n\n\t\t\tif( value > N){\n\n\t\t\t\tl = mid + 1;\n\n\t\t\t}\n\n\t\t\telse{\n\n\t\t\t\tr = mid;\n\n\t\t\t}\n\n//\t\t\tout.println( l + \", \" + r + \", \" + value);\n\n\t\t}\t\t\n\n\t\tlong value = (1+K)*K/2 - (1+l-1)*(l-1)/2;\n\n\t\tif( value == N){\n\n\t\t\tout.println( K-l+1 );\n\n\t\t}\n\n\t\telse{\n\n\t\t\tout.println( K-l+2 );\n\n\t\t}\n\n\t}\n\n\t\n\n\t/**\n\n\t * @param args\n\n\t */\n\n\tpublic static void main(String[] args) {\n\n\t\tnew B2().run();\n\n\t}\n\n\t\n\n\tpublic void run() {\n\n        try {\n\n            reader = new BufferedReader(new InputStreamReader(System.in));\n\n            tokenizer = null;\n\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            reader.close();\n\n            out.close();\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n            System.exit(1);\n\n        }\n\n    }\n\n\n\n    int nextInt() throws IOException {\n\n        return Integer.parseInt(nextToken());\n\n    }\n\n\n\n    long nextLong() throws IOException {\n\n        return Long.parseLong(nextToken());\n\n    }\n\n\n\n    double nextDouble() throws IOException {\n\n        return Double.parseDouble(nextToken());\n\n    }\n\n\n\n    String nextToken() throws IOException {\n\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\n            tokenizer = new StringTokenizer(reader.readLine());\n\n        }\n\n        return tokenizer.nextToken();\n\n    }\n\n\n\n}\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.util.Scanner;\n\npublic class MainA {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n  = sc.nextInt();\n        \n        int count = 0;\n        \n        count = n/2;\n        \n        count = count + (n - n/2);\n        \n        n = n - n/2;\n            \n        count = count + n;  \n\n        \n        System.out.println(count);\n        \n    }\n}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.Scanner;\n\npublic class codeforces3rd4 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tint i,j;\n\t\tfor(i=0; i<t; i++) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint arr[] = new int[n];\n\t\t\tfor(j=0; j<n; j++) {\n\t\t\t\tarr[j] = sc.nextInt();\n\t\t\t}\n\t\t\tString[] str = makeList(arr);\n\t\t\tfor(j=0; j<n; j++) {\n\t\t\t\tSystem.out.println(str[j]);\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\tstatic String[] makeList(int[] arr) {\n\t\tint n = arr.length;\n\t\tint i,j,m,lastIdx;\n\t\tString str[] = new String[n];\n\t\tstr[0] = \"\" + arr[0];\n\t\tfor(i=1; i<n; i++) {\n\t\t\tm = str[i-1].length();\n\t\t\tj=m-1;\n\t\t\tlastIdx=m;\n\t\t\tstr[i] = \"\";\n\t\t\tif(arr[i] == 1) {\n\t\t\t\tstr[i] = str[i-1] + \".1\";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(j >=0) {\n\t\t\t\twhile(j>=0 && str[i-1].charAt(j) != '.')\n\t\t\t\t\tj--;\n\t\t\t\tif(arr[i] - Integer.parseInt(str[i-1].substring(j+1, lastIdx)) == 1) {\n\t\t\t\t\tstr[i] = str[i-1].substring(0,j+1) + arr[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlastIdx = j;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn str;\n\t}\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.util.*;\n\npublic class Main {\n    static long bb(long a, long b, long c, long d){\n        long s;\n        if((c - a + 1) % 2 == 0 || (d - c + 1) % 2 == 0)\n            s = (c - a + 1)*(d - b + 1) / 2;\n        else if((a + b) % 2 != 0)\n            s = (c - a + 1) * (d - b + 1) / 2;\n        else s = (c - a + 1) * (d - b + 1) - (c - a + 1) * (d - b + 1) / 2;\n        return s;\n    }\n    public static void main(String[] args) {\n        Scanner reader = new Scanner(System.in);\n        int u;\n        long n, m;\n        long a, b, c, d, e, f, g, h;\n        u = reader.nextInt();\n        while(u-- > 0){\n            n = reader.nextLong();\n            m = reader.nextLong();\n            a = reader.nextLong();\n            b = reader.nextLong();\n            c = reader.nextLong();\n            d = reader.nextLong();\n            e = reader.nextLong();\n            f = reader.nextLong();\n            g = reader.nextLong();\n            h = reader.nextLong();\n            long s;\n            s = bb(1, 1, n, m)+(c - a + 1) * (d - b + 1)-bb(a, b, c, d)-bb(e, f, g, h);\n            long maxx = Math.max(a, e);\n            long minx = Math.min(c, g);\n            long maxy = Math.max(b, f);\n            long miny = Math.min(d, h);\n            if(maxx <= minx && maxy <= miny) s -= (minx -maxx + 1) * (miny - maxy + 1) - bb(maxx, maxy, minx, miny);\n            System.out.println(s + \" \" + (n * m - s));\n        }\n    }\n}\n   \t \t\t     \t\t\t\t\t\t\t  \t  \t \t \t \t", "complexity": "constant", "problem": "1080_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class D {\n\n\tstatic HashMap<Long, Integer> comp = new HashMap<Long, Integer>();\n\tstatic HashMap<Integer, Long> rev = new HashMap<Integer, Long>();\n\tstatic long freq[];\n\tpublic static void main(String[] args) {\n\t\tFastScanner in = new FastScanner();\n\t\tint n = in.nextInt();\n\t\tlong a[] = new long[n];\n\t\tlong copy[] = new long[n];\n\t\tlong sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = in.nextLong();\n\t\t\tcopy[i] = a[i];\n\t\t\tsum+=a[i];\n\t\t}\n\t\tArrays.sort(copy);\n\t\tfor(int i = 0; i < n; i++)\t//Compress values to be 1-indexed\n\t\t\tif(!comp.containsKey(copy[i])){\n\t\t\t\tcomp.put(copy[i],  (comp.size()+1));\n\t\t\t\t//rev.put(comp.get(copy[i]), copy[i]);\n\t\t\t}\n\t\t\t\n\t//\tBIT bit = new BIT(n);\n\t\t\n\t\tfreq = new long[n+1];\n\t\tArrays.fill(freq, 0);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint v = comp.get(a[i]);\n\t\t\tfreq[v]++;\n\t\t}\n\t\t\n\t\tlong res = 0;\n\t\tBigInteger res2 = new BigInteger(\"0\");\n\t\tfor(int i = 0; i < n; i++){\t//Go through each element in the array\n\t\t\tlong x = a[i];\n\t\t\t//freq[comp.get(x)]--;\n\t\t\t//Find the amount of values equal to (x-1), x, and (x+1);\n\t\t\tlong below = getFreq(x-1);\n\t\t\tlong eq = getFreq(x);\n\t\t\tlong above = getFreq(x+1);\n\t\t\tlong other = (n-i)-below-eq-above;\n\t\t\t\n\t\t//\tSystem.out.println(\"x= \"+x+\" b:\"+below+\"  e:\"+eq+\"  a:\"+above);\n\t\t\t\n\t\t\tlong leaveOut = below*(x-1) + eq*(x) + above*(x+1);\n\t\t\tlong cur = (sum-leaveOut)-(x*other);\n\n\t//\t\tSystem.out.println(\"sum:\"+sum+\"  leave:\"+leaveOut+\"  oth:\"+other+\"   cur:\"+cur+\"\\n\");\n\t\t\tres2 = res2.add(new BigInteger(\"\"+cur));\n\t\t\tres += cur;\n\t\t\tsum -= x;\n\t\t\tfreq[comp.get(x)]--;\n\t\t\t\n\t\t}\n\t\tSystem.out.println(res2);\n\t}\n\t\n\tstatic long getFreq(long n){\n\t\tif(!comp.containsKey(n)) return 0;\n\t\telse return freq[comp.get(n)];\n\t}\n\t\n\t\n\t\n\n\tstatic class FastScanner{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastScanner(String s) {\n\t\t\ttry{\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t}\n\t\t\tcatch(FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tpublic FastScanner(){\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tString nextToken()\t{\n\t\t\twhile(st == null ||!st.hasMoreElements()){\n\t\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());}\n\t\t\t\tcatch(IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t\tString next() {\n\t\t\treturn nextToken();\n\t\t}\n\t\t\n\t}\n\t\n\t\n}\n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.util.Arrays.*;\n\npublic class E implements Runnable\n{\n    public static void main(String[] args) throws IOException\n    {\n        new Thread(null, new E(), \"\", 1 << 20).start();\n    }   \n    \n    BufferedReader input;\n    PrintWriter out;\n    String file = \"input\";\n    \n    public void run()\n    {\n        try\n        {\n            //input = new BufferedReader(new FileReader(file + \".in\"));\n            input = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new BufferedOutputStream(System.out));\n            solve();\n            \n            out.close();    \n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n    \n    void solve() throws IOException\n    {\n        int n = Integer.parseInt(input.readLine());\n        double[][] p = new double[n][n];\n        for(int i = 0; i < n; i++)\n        {\n            StringTokenizer st = new StringTokenizer(input.readLine());\n            for(int j = 0; j < n; j++) \n            {\n                p[i][j] = Double.parseDouble(st.nextToken());\n            }\n        }\n        double[] dp = new double[1 << n];\n        int mask = (1 << n) - 1;\n        dp[mask] = 1;\n        for(int w = mask; w > 0; w--)\n        {\n            int count = 0;\n            for(int i = 0; i < n; i++)\n                for(int j = i + 1; j < n; j++)\n                    if((w >> i & 1) != 0 && (w >> j & 1) != 0) count++;\n            \n            if(count == 0) continue;\n            for(int i = 0; i < n; i++)\n                for(int j = i + 1; j < n; j++)\n                    if((w >> i & 1) != 0 && (w >> j & 1) != 0)\n                    {\n                        dp[w ^ (1 << i)] += 1.0 / count * p[j][i] * dp[w];\n                        dp[w ^ (1 << j)] += 1.0 / count * p[i][j] * dp[w];\n                    }\n        }\n        for(int i = 0; i < n; i++)\n            System.out.print(dp[1 << i] + \" \");\n            \n    }\n}", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        long a;\n        int i;\n        public card(long a,int i)\n        {\n            this.a=a;\n            this.i=i;\n        }\n    }\n    static class sort implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.a!=o2.a)\n                return (int)(o1.a-o2.a);\n            else\n                return (int)(o1.b-o2.b);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    /*static long gcd(long a,long b)\n    {\n    if(b==0)\n    return a;\n    else\n    return gcd(b,a%b);\n    }*/\n    /*static boolean valid(int i,int j)\n    {\n    if(i<4 && i>=0 && j<4 && j>=0)\n    return true;\n    else\n    return false;\n    }*/\n    static class pair{\n        int a,b;\n        public pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int k=sc.nextInt();\n        int n=sc.nextInt();\n        int s=sc.nextInt();\n        int p=sc.nextInt();\n        long d=(long)Math.ceil((double)n/s);\n        if(d==0)\n        d=1;\n        d=k*d;\n        long ans=(long)Math.ceil((double)d/p);\n        System.out.println(ans);\n    }\n}", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.Scanner;\n\n\npublic class P23A {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString input = scan.nextLine();\n\t\tSystem.out.println(F(input));\n\t}\n\t\n\t\n\tstatic int F(String string){\n\t\tint ans =0;\n\t\tfor (int i = 0; i < string.length(); i++) {\n\t\t\tfor (int j = 1; j < string.length()-i; j++) {\n\t\t\t\tString s = string.substring(i, i+j);\n\t\t\t\tint a=string.indexOf(s);\n\t\t\t\tint b=string.lastIndexOf(s);\n\t\t\t\tif ( a >= 0 && b >=0 && a !=b)  ans =Math.max(ans, s.length());\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "\n\n// ~/BAU/ACM-ICPC/Teams/A++/BlackBurn95\n\n\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport java.math.*;\n\nimport static java.lang.Math.*;\n\nimport static java.lang.Integer.parseInt;\n\nimport static java.lang.Long.parseLong;\n\nimport static java.lang.Double.parseDouble;\n\nimport static java.lang.String.*;\n\n\n\npublic class Main {\n\n\n\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n                                              // (new FileReader(\"input.in\"));\n\n        StringBuilder out = new StringBuilder();\n\n        StringTokenizer tk;\n\n        \n\n        tk = new StringTokenizer(in.readLine());\n\n        long n = parseLong(tk.nextToken()),k = parseLong(tk.nextToken());\n\n        \n\n        if(n==1) {\n\n            System.out.println(\"0\");\n\n            return;\n\n        }\n\n        \n\n        long l = 1,r = k,m,ans=-1;\n\n        \n\n        while(l <= r) {\n\n            m = (l+r)/2;\n\n            \n\n            if(getPipe(k,m)>=n) {\n\n                ans = m;\n\n                r = m-1;\n\n            } else l = m+1;\n\n        }\n\n        \n\n        System.out.println(ans);\n\n    }\n\n    \n\n    static long getPipe(long k,long n) {\n\n        return (k*(k+1)/2)-((k-n)*(k-n+1)/2)-(n-1);\n\n    }\n\n    \n\n}\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class Main\n{\n    static MyScanner scan;\n    static PrintWriter pw;\n    static long MOD = 1_000_000_007;\n    static long INF = 2_000_000_000_000_000_000L;\n    static long inf = 2_000_000_000;\n    public static void main(String[] args) {\n        new Thread(null, null, \"_\", 1 << 27) {\n            public void run() {\n                try {\n                    solve();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n\n\n    static void solve() throws java.lang.Exception {\n        //initIo(true, \"\");\n        initIo(false, \"\");\n        StringBuilder sb = new StringBuilder();\n\n        Calendar start = Calendar.getInstance();\n\n        int n = ni(), m = ni(), k = ni();\n        int col[][] = new int[n][m-1];\n        for(int i=0;i<n;i++) {\n            for(int j=0;j+1<m;++j) {\n                 col[i][j] = ni();\n            }\n        }\n\n        int row[][] = new int[n-1][m];\n        for(int i=0;i+1<n;i++) {\n            for(int j=0;j<m;++j) {\n                 row[i][j] = ni();\n            }\n        }\n\n\n        int MAX = Integer.MAX_VALUE / 10;\n        int org_k = k;\n        k/=2;\n        int dp[][][] = new int[n][m][k+1];\n        for(int i=1;i<=k;i++) {\n            for(int x=0;x<n;++x) {\n                for(int y=0;y<m;++y) {\n                    dp[x][y][i] = MAX;\n                }\n            }\n        }\n\n\n        for(int i=1;i<=k;i++) {\n            for(int x=0;x<n;++x) {\n                for(int y=0;y<m;++y) {\n                    if(x-1>=0 && dp[x][y][i] > dp[x-1][y][i-1] + row[x-1][y]) {\n                        dp[x][y][i] = dp[x-1][y][i-1] + row[x-1][y];\n                    }\n\n                    if(x+1<n && dp[x][y][i] > dp[x+1][y][i-1] + row[x][y]) {\n                        dp[x][y][i] = dp[x+1][y][i-1] + row[x][y];\n                    }\n\n                    if(y-1>=0 && dp[x][y][i] > dp[x][y-1][i-1] + col[x][y-1]) {\n                        dp[x][y][i] = dp[x][y-1][i-1] + col[x][y-1];\n                    }\n\n                    if(y+1<m && dp[x][y][i] > dp[x][y+1][i-1] + col[x][y]) {\n                        dp[x][y][i] = dp[x][y+1][i-1] + col[x][y];\n                    }\n                }\n            }\n        }\n\n        for(int i=0;i<n;i++) {\n            for(int j=0;j<m;++j) {\n                if(dp[i][j][k]==MAX || (org_k&1)==1) {\n                    p(-1);\n                }\n                else {\n                    p((2*dp[i][j][k]));\n                }\n            }\n            pl();\n        }\n\n        pw.flush();\n        pw.close();\n    }\n\n\n\n    static void assert_in_range(String varName, int n, int l, int r) {\n        if (n >=l && n<=r) return;\n        System.out.println(varName + \" is not in range. Actual: \"+n+\" l : \"+l+\" r: \"+r);\n        System.exit(1);\n    }\n    static void assert_in_range(String varName, long n, long l, long r) {\n        if (n>=l && n<=r) return;\n        System.out.println(varName + \" is not in range. Actual: \"+n+\" l : \"+l+\" r: \"+r);\n        System.exit(1);\n    }\n\n    static void initIo(boolean isFileIO, String suffix) throws IOException {\n        scan = new MyScanner(isFileIO, suffix);\n        if(isFileIO) {\n            pw = new PrintWriter(\"/Users/dsds/Desktop/output\"+suffix+\".txt\");\n        }\n        else {\n            pw = new PrintWriter(System.out, true);\n        }\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static String ne() throws IOException\n    {\n        return scan.next();\n    }\n    static String nel() throws IOException\n    {\n        return scan.nextLine();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, boolean arr[])\n    {\n        pl(arrayName+\" : \");\n        for(boolean o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, boolean[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(boolean o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class MyScanner\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        MyScanner(boolean readingFromFile, String suffix) throws IOException\n        {\n            if(readingFromFile) {\n                br = new BufferedReader(new FileReader(\"/Users/ddfds/Desktop/input\"+suffix+\".txt\"));\n            }\n            else {\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n        }\n        String nextLine()throws IOException\n        {\n            return br.readLine();\n        }\n        String next() throws IOException\n        {\n            if(st==null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        int nextInt() throws IOException\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong() throws IOException\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble() throws IOException\n        {\n            return Double.parseDouble(next());\n        }\n    }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.util.stream.Collectors;\n\npublic class P1177A {\n    public static void main(String[] args) throws Exception {\n        BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n        long n = Long.parseLong(r.readLine());\n        if (n < 10) {\n            System.out.print(n);\n            return;\n        }\n        \n        int len = 1;\n        long edge = 10;\n        long prev = 0;\n        long prepow = 0;\n        while (edge - 1 < n) {\n            prepow = (long)Math.pow(10, len);\n            long pow = prepow * 10;\n            prev = edge;\n            edge = edge + (pow - prepow) * (len + 1);\n            len += 1;\n        }\n\n        long b = n - prev;\n        long c = b / len;\n        int rem = (int)(b % len);\n        String s = Long.toString(prepow + c).charAt(rem) + \"\";\n\n        System.out.print(s);\n    }\n}\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "//>>>BaZ<<<//\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\npublic class Main\n{  \n    static int dx[] = {-1,1,0,0};\n    static int dy[] = {0,0,1,-1};\n    static long MOD = 1000000007;\n    static int INF = Integer.MAX_VALUE/10;\n    static PrintWriter pw;\n    static Reader scan;\n    //static MyFileReader scan;\n    //static MyFileReader1 ss;\n    static int ni() throws IOException{return scan.nextInt();}\n    static long nl() throws IOException{return scan.nextLong();}\n    static double nd() throws IOException{return scan.nextDouble();}\n    static void pl() throws IOException{pw.println();}\n    static void pl(Object o) throws IOException{pw.println(o);}\n    static void p(Object o) throws IOException {pw.print(o+\" \");}\n    static void psb(StringBuilder sb) throws IOException {pw.print(sb);}\n    public static void main(String[] args){\n        new Thread(null,null,\"BaZ\",99999999)\n        {\n            public void run()\n            {\n                try\n                {\n                    solve();\n                }\n                catch(Exception e)\n                {  \n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n    static void solve() throws IOException\n    {  \n        Calendar CAL1 = Calendar.getInstance();\n        CAL1.setTime(new Date());\n        scan = new Reader();\n        //scan = new MyFileReader();\n        //ss = new MyFileReader1();\n        pw = new PrintWriter(System.out,true);\n        //pw = new PrintWriter(new File(\"C://Users/Aman deep/Desktop/output.txt\"));  \n        StringBuilder sb = new StringBuilder();\n        int n = ni();\n        int inv = 0;\n        int arr[] = new int[n];\n        for(int i=0;i<n;++i)\n        {\n            arr[i] = ni();\n            for(int j=0;j<i;++j)\n                if(arr[j]>arr[i])\n                    inv = 1-inv;\n        }\n        int q = ni();\n        while(q-->0)\n        {\n            int l = ni();\n            int r = ni();\n            int par = c2(r-l+1);\n            par&=1;\n            if(par!=0)\n                inv = 1-inv;\n            if(inv==0)\n                sb.append(\"even\\n\");\n            else sb.append(\"odd\\n\");\n        }\n        psb(sb);\n        Calendar CAL2 = Calendar.getInstance();\n        CAL2.setTime(new Date());\n        double Execution_Time = (double)(CAL2.getTimeInMillis()-CAL1.getTimeInMillis())/1000.000;\n        //System.out.println(\"Execution time : \"+Execution_Time+\" seconds\");\n        pw.flush();\n        pw.close();\n    }\n    static int c2(int n)\n    {\n        return (n*(n-1))>>1;\n    }\n    static class Reader {\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader() {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException {\n        byte[] buf = new byte[64];\n        int cnt = 0, c;\n        while ((c = read()) != -1) {\n            if (c == '\\n') break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ') c = read();\n        boolean neg = (c == '-');\n        if (neg) c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0' && c <= '9');\n        if (neg) return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ') c = read();\n        boolean neg = (c == '-');\n        if (neg) c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0' && c <= '9');\n        if (neg) return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ') c = read();\n        boolean neg = (c == '-');\n        if (neg) c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0' && c <= '9');\n        if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);\n        if (neg) return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1) buffer[0] = -1;\n    }\n\n    private byte read() throws IOException {\n        if (bufferPointer == bytesRead) fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException {\n        if (din == null) return;\n        din.close();\n    }\n}\n     static class MyFileReader                                          //File input template\n    {\n        StringTokenizer st;\n        BufferedReader br;\n        MyFileReader() throws IOException\n        {\n            br = new BufferedReader(new FileReader(\"C://Users/Aman deep/Desktop/input.txt\"));\n        }\n        String nextLine() throws IOException\n        {\n            return br.readLine();\n        }\n        String next() throws IOException\n        {\n            if(st==null || !st.hasMoreTokens())\n                st = new StringTokenizer(nextLine());\n            return st.nextToken();\n        }\n        int nextInt() throws IOException\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong() throws IOException\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble() throws IOException\n        {\n            return Double.parseDouble(next());\n        }\n    }\n     static class MyFileReader1                                          //File input template\n    {\n        StringTokenizer st;\n        BufferedReader br;\n        MyFileReader1() throws IOException\n        {\n            br = new BufferedReader(new FileReader(\"C://Users/Aman deep/Desktop/output.txt\"));\n        }\n        String nextLine() throws IOException\n        {\n            return br.readLine();\n        }\n        String next() throws IOException\n        {\n            if(st==null || !st.hasMoreTokens())\n                st = new StringTokenizer(nextLine());\n            return st.nextToken();\n        }\n        int nextInt() throws IOException\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong() throws IOException\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble() throws IOException\n        {\n            return Double.parseDouble(next());\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "\npublic class Main {\n\n\tprivate static void solve() {\n\t\tint n = ni();\n\t\tdouble r = ni();\n\n\t\tdouble[][] p = new double[n][2];\n\t\tdouble EPS = 0.0000000000001;\n\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tdouble x = ni();\n\t\t\tdouble y = r;\n\t\t\tfor (int j = 0; j < i; j ++) {\n\t\t\t\tdouble dx = Math.abs(p[j][0] - x);\n\t\t\t\tif (dx <= r * 2 + EPS) {\n\t\t\t\t\tdouble dy = Math.sqrt(4.0 * r * r - dx * dx);\n\t\t\t\t\ty = Math.max(y, p[j][1] + dy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.printf(\"%.12f \", y);\n\t\t\tp[i][0] = x;\n\t\t\tp[i][1] = y;\n\t\t}\n\t\tout.println();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tlong start = System.currentTimeMillis();\n\t\t\t\tString debug = args.length > 0 ? args[0] : null;\n\t\t\t\tif (debug != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tis = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n\t\t\t\tsolve();\n\t\t\t\tout.flush();\n\t\t\t\ttr((System.currentTimeMillis() - start) + \"ms\");\n\t\t\t}\n\t\t}, \"\", 64000000).start();\n\t}\n\n\tprivate static java.io.InputStream is = System.in;\n\tprivate static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n\tprivate static java.util.StringTokenizer tokenizer = null;\n\tprivate static java.io.BufferedReader reader;\n\n\tpublic static String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new java.util.StringTokenizer(reader.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tprivate static long nl() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static char[] ns() {\n\t\treturn next().toCharArray();\n\t}\n\n\tprivate static long[] nal(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int[][] ntable(int n, int m) {\n\t\tint[][] table = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ttable[i][j] = ni();\n\t\t\t}\n\t\t}\n\t\treturn table;\n\t}\n\n\tprivate static int[][] nlist(int n, int m) {\n\t\tint[][] table = new int[m][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ttable[j][i] = ni();\n\t\t\t}\n\t\t}\n\t\treturn table;\n\t}\n\n\tprivate static int ni() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tif (is != System.in)\n\t\t\tSystem.out.println(java.util.Arrays.deepToString(o));\n\t}\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author AlexFetisov\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskE {\n\n    private int n;\n    private double[] dp;\n    private double[][] p;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        n = in.nextInt();\n        p = new double[n][n];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                p[i][j] = in.nextDouble();\n            }\n        }\n        dp = new double[1 << n];\n        Arrays.fill(dp, -1);\n        for (int i = 0; i < n; ++i) {\n            out.printf(\"%.6f \", rec(1 << i));\n        }\n        out.println();\n    }\n\n    private double rec(int mask) {\n        if (mask == (1 << n) - 1) return 1;\n        if (dp[mask] > -0.5) return dp[mask];\n        double res = 0;\n        int nn = Integer.bitCount(mask);\n        int total = (nn * (nn + 1)) / 2;\n        for (int i = 0; i < n; ++i) if (BitUtils.checkBit(mask, i)) for (int j = 0; j < n; ++j) if (!BitUtils.checkBit(mask, j)) {\n            res += rec(BitUtils.setBit(mask, j)) * p[i][j];\n        }\n        res /= total;\n        dp[mask] = res;\n        return res;\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer stt;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine().trim();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public String nextString() {\n        while (stt == null || !stt.hasMoreTokens()) {\n            stt = new StringTokenizer(nextLine());\n        }\n        return stt.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(nextString());\n    }\n\n}\n\nclass BitUtils {\n    public static boolean checkBit(int mask, int bit) {\n        return (mask & (1 << bit)) > 0;\n    }\n\n    public static int setBit(int mask, int bit) {\n        return (mask | (1 << bit));\n    }\n\n}\n\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Coder{\n    \n    static class FastScanner{\n        BufferedReader s;\n        StringTokenizer st;\n        \n        public FastScanner(){\n            st = new StringTokenizer(\"\");\n            s = new BufferedReader(new InputStreamReader(System.in));\n        }\n        \n        public int nextInt() throws IOException{\n            if(st.hasMoreTokens())\n                return Integer.parseInt(st.nextToken());\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextInt();\n            }\n        }\n    }\n    \n    \n    public static void main(String[] args) throws IOException{\n        FastScanner s = new FastScanner();\n        PrintWriter ww = new PrintWriter(new OutputStreamWriter(System.out));\n        int test = s.nextInt(); int cnt=0;\n        while(test-->0){\n            int a = s.nextInt();\n            int b = s.nextInt();\n            cnt=0;\n            while(a!=0 && b!=0){\n                int max = Math.max(a, b);\n                if(max == b){\n                    int divi = b/a;\n                    b -= divi*a;\n                    cnt+=divi;\n                }else{\n                    int divi = a/b;\n                    a -= divi*b;\n                    cnt+=divi;\n                }\n        //      System.out.println(a+\" \"+b);\n            }\n            ww.println(cnt);\n        }\n        ww.close();\n    }\n}", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.lang.*;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class Challenge {\n\t\n\tpublic static void main(String[] args) throws java.lang.Exception {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n\t\n\tpublic void solve(InputReader in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\t\n\t\tif (n == 1) {\n\t\t\tout.println(\"1\");\n\t\t} else if (n == 2) {\n\t\t\tout.println(\"2\");\n\t\t} else if (n == 3) {\n\t\t\tout.println(\"6\");\n\t\t} else if (n%2 > 0) {\n\t\t\tout.println(1L * n * (n-1) * (n-2));\n\t\t} else if (n%3 == 0) {\n\t\t\tout.println(1L * (n-1) * (n-2) * (n-3));\n\t\t} else {\n\t\t\tout.println(1L * n * (n-1) * (n-3));\n\t\t}\n\t}\n}\n\nclass InputReader {\n\tpublic BufferedReader reader;\n\tpublic StringTokenizer tokenizer;\n\t\n\tpublic InputReader(InputStream stream) {\n\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\ttokenizer = null;\n\t}\n\t\n\tpublic String next() {\n\t\twhile (tokenizer==null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\t\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\t\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n}\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\tpublic static String taskName = \"\";\n\n\tpublic class Task {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint r = in.nextInt();\n\t\t\tint[] x = new int[n];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\tx[i] = in.nextInt();\n\n\t\t\tdouble[] y = new double[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\ty[i] = r;\n\t\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\t\tint dx = Math.abs(x[i] - x[j]);\n\t\t\t\t\tif(dx <= 2 * r)\n\t\t\t\t\t\ty[i] = Math.max(y[i], y[j] + Math.abs(Math.sqrt(4 * r * r - dx * dx)));\n\t\t\t\t}\n\t\t\t\tSystem.out.print(y[i] + \" \");\n\t\t\t}\n\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tif(!taskName.isEmpty()) {\n\t\t\tSystem.setIn(new BufferedInputStream(new FileInputStream(taskName + \".in\")));\n\t\t\tSystem.setOut(new PrintStream(new BufferedOutputStream(new FileOutputStream(taskName + \".out\"))));\n\t\t}\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tMain main = new Main();\n\t\tmain.run(in, out);\n\t\tout.close();\n\t}\n\n\tpublic void run(InputReader in, PrintWriter out) {\n\t\tTask solver = new Task();\n\t\tsolver.solve(1, in, out);\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile(tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic double nextShort() {\n\t\t\treturn Short.parseShort(next());\n\t\t}\n\n\t\tpublic double nextByte() {\n\t\t\treturn Byte.parseByte(next());\n\t\t}\n\n\t\tpublic double nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\t}\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.util.Scanner;\n\n/**\n * Created by ZeRoGerc on 25.02.15.\n */\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n\n        int n = scan.nextInt();\n\n        if (n % 2 == 0) {\n            System.out.println(4 + \" \" + (n - 4));\n        }\n        else {\n            System.out.println(9 + \" \" + (n - 9));\n        }\n    }\n}\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\n\tFastReader in = new FastReader();\n\tPrintWriter out = new PrintWriter(System.out);\n\tvoid run(){\n\t\tint q=in.nextInt();\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tout.println(work());\n\t\t}\n\t\tout.flush();\n\t}\n\tlong mod=1000000007;\n\tlong gcd(long a,long b) {\n\t\treturn b==0?a:gcd(b,a%b);\n\t}\n\tint id[];\n\tlong work() {\n\t\tint n=in.nextInt();\n\t\tint m=in.nextInt();\n\t\tlong ret=0;\n\t\tPriorityQueue<int[]> pq=new PriorityQueue<>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] arr1,int[] arr2) {\n\t\t\t\treturn arr1[2]-arr2[2];\n\t\t\t}\n\t\t});\n\t\tlong sum=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tint v=in.nextInt();\n\t\t\t\tpq.add(new int[] {i,j,v});\n\t\t\t\tsum+=v;\n\t\t\t\tif(pq.size()>6)pq.poll();\n\t\t\t}\n\t\t}\n\t\tif(m==1)return sum;\n\t\tif(n<=3) {\n\t\t\twhile(pq.size()>0) {\n\t\t\t\tint[] p=pq.poll();\n\t\t\t\tif(pq.size()<n) {\n\t\t\t\t\tret+=p[2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tint[][] A=new int[6][];\n\t\tfor(int i=0;pq.size()>0;i++) {\n\t\t\tA[i]=pq.poll();\n\t\t}\n\t\t\n\t\tfor(int i=0;i<6;i++) {\n\t\t\tfor(int j=i+1;j<6;j++) {\n\t\t\t\tfor(int k=j+1;k<6;k++) {\n\t\t\t\t\tout:\n\t\t\t\t\tfor(int p=k+1;p<6;p++) {\n\t\t\t\t\t\tint s=A[i][2]+A[j][2]+A[k][2]+A[p][2];\n\t\t\t\t\t\tHashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\n\t\t\t\t\t\tif(map.get(A[i][1])==null) {\n\t\t\t\t\t\t\tmap.put(A[i][1],new ArrayList<>());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map.get(A[j][1])==null) {\n\t\t\t\t\t\t\tmap.put(A[j][1],new ArrayList<>());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map.get(A[k][1])==null) {\n\t\t\t\t\t\t\tmap.put(A[k][1],new ArrayList<>());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map.get(A[p][1])==null) {\n\t\t\t\t\t\t\tmap.put(A[p][1],new ArrayList<>());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmap.get(A[i][1]).add(A[i][0]);\n\t\t\t\t\t\tmap.get(A[j][1]).add(A[j][0]);\n\t\t\t\t\t\tmap.get(A[k][1]).add(A[k][0]);\n\t\t\t\t\t\tmap.get(A[p][1]).add(A[p][0]);\n\t\t\t\t\t\tif(map.size()!=2) {\n\t\t\t\t\t\t\tret=Math.max(ret, s);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tInteger l1=null,l2=null,r1=null,r2=null;\n\t\t\t\t\t\tfor(int key:map.keySet()) {\n\t\t\t\t\t\t\tArrayList<Integer> list=map.get(key);\n\t\t\t\t\t\t\tif(map.get(key).size()!=2) {\n\t\t\t\t\t\t\t\tret=Math.max(ret, s);\n\t\t\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l1==null) {\n\t\t\t\t\t\t\t\tl1=list.get(0);\n\t\t\t\t\t\t\t\tl2=list.get(1);\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tr1=list.get(0);\n\t\t\t\t\t\t\t\tr2=list.get(1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((Math.abs(l1-l2)==2&&Math.abs(r1-r2)==2)||(Math.abs(l1-l2)!=2&&Math.abs(r1-r2)!=2)) {\n\t\t\t\t\t\t\tret=Math.max(ret, s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}\n\n\n\nclass FastReader\n{\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic FastReader()\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tpublic String next() \n\t{\n\t\tif(st==null || !st.hasMoreElements())\n\t\t{\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() \n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong()\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "/**\n * Online Judge: CodeForces.\n * Problem Code: CF287-D2-B.\n * Problem Name: Pipeline.\n * Date : 13/07/2020.\n * @author Andrew\n */\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        long n = input.nextLong() - 1;\n        long k = input.nextLong() - 1;\n\n        if (n == 0)\n            System.out.println(0);\n        else if (n <= k)\n            System.out.println(1);\n        else if (sum(k) < n)\n            System.out.println(-1);\n        else\n            System.out.println(minimumSplitters(n, k));\n    }\n\n    public static long minimumSplitters(long n, long k) {\n        long start = 1, end = k;\n        while (start < end) {\n            long mid = start + (end - start) / 2;\n            long sum = sum(mid, k);\n            if (sum == n)\n                return k - mid + 1;\n            if (sum > n)\n                start = mid + 1;\n            else\n                end = mid;\n        }\n        return k - start + 2;\n    }\n\n    public static long sum(long start, long end) {\n        return sum(end) - sum(start - 1);\n    }\n\n    public static long sum(long n) {\n        return (n * (n + 1)) / 2;\n    }\n}\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.util.Scanner;\n\npublic class Subtractions {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numberOfTests = scanner.nextInt();\n        while (numberOfTests-- > 0) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int[] res = new int[1];\n            compute(a, b, res);\n            System.out.println(res[0]);\n        }\n    }\n\n    private static void compute(int x, int y, int[] res) {\n        if (x == 0 || y == 0) {\n            return;\n        }\n        int tmp;\n        if (x < y) {\n            tmp = x;\n            x = y;\n            y = tmp;\n        }\n        res[0] += x / y;\n        tmp = x % y;\n        if (tmp == 0) {\n            return;\n        }\n        x = y;\n        y = tmp;\n        compute(x, y, res);\n    }\n}\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.Scanner;\n\npublic class Main {\n  public long LCM(long n) {\n    if(n== 1){\n        return 1;\n    }\n    else if(n==2){\n        return 2;\n    }\n    else if(n%2==0){\n        if(n%3==0){\n            return (n-1)*(n-2)*(n-3);\n        }\n        else{\n            return n*(n-1)*(n-3);\n        }\n    }\n    else{\n        return n*(n-1)*(n-2);\n    }\n   \n  }\n\n  public static void main(String[] args) {\n    Main m = new Main();\n    Scanner s = new Scanner(System.in);\n    long input = s.nextInt();\n    long output = m.LCM(input);\n    System.out.println(output);\n  }\n}", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer; \n  \n\npublic class temp4 {\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\t\n/*\tstatic class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    } */\n//\tstatic class Print\n//\t{\n//\t    private final BufferedWriter bw;\n//\t    public Print()\n//\t    {\n//\t        bw=new BufferedWriter(new OutputStreamWriter(System.out));\n//\t    }\n//\t    public void print(String str)throws IOException\n//\t    {\n//\t        bw.append(str);\n//\t    }\n//\t    public void println(String str)throws IOException\n//\t    {\n//\t        print(str);\n//\t        bw.append(\"\\n\");\n//\t    }\n//\t    public void close()throws IOException\n//\t    {\n//\t        bw.close();\n//\t    }} \n//\t\t\n\t\t\n\t\n\t\tpublic static void main(String[] args) throws IOException {\t\t\t\n\t\t\tFastReader scn=new FastReader();\n\t\t//\tPrint pr=new Print();\n\t\t\tPrintWriter out=new PrintWriter(System.out);\n\t\t\tout.write(\"? 0 0\\n\");\n\t\t\tout.flush();\n\t\t\tint tie=scn.nextInt();\n\t\t\tint a=0,b=0,n1=0,n2=0,diff=0;\n\t\t\tfor(int i=29;i>=0;i--){\n\t\t\t\tout.write(\"? \"+((1<<i)|a)+\" \"+b+\"\\n\");\n\t\t\t\tout.flush();\n\t\t\t\tn1=scn.nextInt();\n\t\t\t\tout.write(\"? \"+a+\" \"+((1<<i)|b)+\"\\n\");\n\t\t\t\tout.flush();\n\t\t\t\tn2=scn.nextInt();\n\t\t\t\tdiff=n1-n2;\n\t\t\t\tif(diff==2){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(diff==-2){\n\t\t\t\t\ta=a|(1<<i);\n\t\t\t\t\tb=b|(1<<i);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(tie==1){\n\t\t\t\t\t\ta=a|(1<<i);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tb=b|(1<<i);\n\t\t\t\t\t}\n\t\t\t\t\ttie=n1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tout.write(\"! \"+a+\" \"+b+\"\\n\");\n\t\t\tout.flush();\n\t\t\t\n\t\t\tout.close();\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic static class node{\n\t\t\tint val;\n\t\t\tint idx;\n\t\t\tpublic node(int val,int idx){\n\t\t\t\tthis.val=val;this.idx=idx;\n\t\t\t}\n\t\t}\n}\n\t", "complexity": "logn", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "import java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.Scanner;\n\npublic class A1080 {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner scanner = new Scanner(System.in);\n\t\tBufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tint people = scanner.nextInt();\n\t\tint pages = scanner.nextInt();\n\t\t\n\t\tdouble peoplePerPages = (double) people/pages;\n\t\tint red = (int) Math.ceil(2d * peoplePerPages );\n\t\tint green  = (int) Math.ceil(5d * peoplePerPages);\n\t\tint blue = (int) Math.ceil(8d * peoplePerPages);\n\t\tlong result = red + green + blue;\n\t\t\n\t\tlog.write(\"\" + result);\n\t\tlog.flush();\n\t}\n}\n", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class j2 {\n    public static void main(String args[]){\n        FastReader sc=new FastReader();\n        long l=sc.nextLong();\n        long r=sc.nextLong();\n        long diff=r-l;\n        long ans=0;\n        long pow=1;\n        int i=0;\n        while(pow<=diff){\n            ans+=pow;\n            pow=pow*2l;\n            i++;\n\n        }\n\n        while(pow<=r){\n            if((((l>>i)^(r>>i))&1l)==1l)\n                ans+=pow;\n            pow=pow*2;\n            i++;\n        }\n        System.out.println(ans);\n    }\n\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.util.Scanner;\npublic class LuckyDivison \n{\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n        int inp = in.nextInt();\n        if(inp%4==0||inp%7==0||inp%47==0||inp%74==0||inp%447==0||inp%474==0||inp%477==0||inp%747==0||inp%774==0||inp%777==0)\n        {\n          System.out.println(\"YES\");  \n        }\n        else System.out.println(\"NO\");\n          \n        \n    }\n}\n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "\n\nimport java.io.*;\n\nimport java.util.*;\n\n\n\npublic class z3 {\n\n\n\n    public static long tr(long n, long k) {\n\n\n\n        long left = 1;\n\n        long right = k;\n\n\n\n        while (left < right) {\n\n            long mid = (left + right) / 2;\n\n            long s = sum(mid, k);\n\n            if (s == n) {\n\n                return k - mid + 1;\n\n            } else if (s > n) {\n\n                left = mid + 1;\n\n            } else {\n\n                right = mid;\n\n            }\n\n        }\n\n\n\n        return k - left +2 ;\n\n    }\n\n\n\n    static long sum(long left, long right , long s) {\n\n        if (left <= right) \n\n            s = sum(right) - sum(left-1);\n\n        return s;\n\n    }\n\n       static long sum(long left, long right ) {\n\n        return sum(left, right, 0);\n\n    }\n\n\n\n\n\n    static long sum(long n) {\n\n        return n * (n + 1) / 2;\n\n    }\n\n\n\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n\n         long n = in.nextLong();\n\n        long k = in.nextLong();\n\n        if (n == 1) {\n\n            System.out.println(0);\n\n        } else if (k >= n) {\n\n            System.out.println(1);\n\n        } else {\n\n            n -= 1;\n\n            k -= 1;\n\n        \n\n        \n\n        if (sum(k) < n) {\n\n            System.out.println(-1);\n\n        } else {\n\n\n\n            System.out.println(tr(n, k));\n\n\n\n        }\n\n        }\n\n    }\n\n}\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class A {\n\n    int INF = 1 << 28;\n\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        long[] chores = new long[n];\n        for(int i=0;i<n;i++) chores[i] = sc.nextLong();\n        sort(chores);\n        System.out.println(chores[b]-chores[b-1]);\n    }\n\n    public static void main(String[] args) {\n        new A().run();\n    }\n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n \n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws java.lang.Exception {\n\t\tBufferedReader kek = new BufferedReader(new InputStreamReader(System.in));\n\t\t//Scanner skek = new Scanner(System.in);\n\t\tPrintWriter outkek = new PrintWriter(System.out);\n\n\t\tint N = Integer.parseInt(kek.readLine());\n\t\tdouble[][] lake = new double[N][N];\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tString[] input = kek.readLine().split(\" \");\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tlake[i][j] = Double.parseDouble(input[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint pow = (int)Math.pow(2, N);\n\t\tdouble[] res = new double[pow];\n\t\tres[pow - 1] = 1.0;\n\t\t\n\t\tfor(int i = pow - 1; i >= 0; i--){\n\t\t\tint ones = Integer.bitCount(i); // So this is apparently a thing\n\t\t\tint possibleCombos = ones * (ones - 1) /2;\n\t\t\t\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif((i >> j) % 2 == 0){ // (X >> Y) literally does the same thing as divis func. Bit operators are weird.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k = j + 1; k < N; k++){\n\t\t\t\t\tif((i >> k) % 2 == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tres[i ^ (1 << k)] += res[i] * lake[j][k]/possibleCombos;\n\t\t\t\t\tres[i ^ (1 << j)] += res[i] * lake[k][j]/possibleCombos;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\toutkek.print(res[1 << i] + \" \");\n\t\t}\n\t\t\n\t\tkek.close();\n\t\toutkek.close();\n\t}\t\n\t\n\t/*static int divis(int n, int a){\n\t\tfor(int i = 0; i < a; i++){\n\t\t\tn /= 2;\n\t\t}\n\t\treturn n;\n\t}*/\n\t\t\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.PrintStream;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Nipuna Samarasekara\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    /////////////////////////////////////////////////////////////\n long n,x,y,c;\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n     n=in.nextLong();\n x=in.nextLong();\ny=in.nextLong();\nc=in.nextLong();\n  long td=-1,tup=2*(n-1);\n     while(Math.abs(td-tup)>1){\n      long mid=(td+tup)/2;\n       if(chk(mid))tup=mid;\n         else td=mid;\n     }\n        out.println(tup);\n\n    }\n\n    private boolean chk(long t) {\n     long ct=-3;\n        long d=x,w=y;\n        if(w>d){\n            long tt=w;\n            w=d;d=tt;\n        }\n\n        if(t>=d+w-2) ct+=d*w;\n        else if(t<w&&t<d) {\n          //  long k=w;\n            ct+=(t+1)*(t+2)/2;\n        }\n        else if(t>=w&&t<d) {\n           // long k=w;\n            ct+=w*(w+1)/2;\n            long k=t-(w-1);\n            ct+=k*w;\n        }\n        else if(t>=w&&t>=d) {\n            // long k=w;\n\n            ct+=w*d;\n            long k=w-2-(t-d);\n            ct-=k*(k+1)/2;\n        }\n        ////\n        w=x;d=n+1-y;\n        if(w>d){\n            long tt=w;\n            w=d;d=tt;\n        }\n\n        if(t>=d+w-2) ct+=d*w;\n        else if(t<w&&t<d) {\n            //  long k=w;\n            ct+=(t+1)*(t+2)/2;\n        }\n        else if(t>=w&&t<d) {\n            // long k=w;\n            ct+=w*(w+1)/2;\n            long k=t-(w-1);\n            ct+=k*w;\n        }\n        else if(t>=w&&t>=d) {\n            // long k=w;\n\n            ct+=w*d;\n            long k=w-2-(t-d);\n            ct-=k*(k+1)/2;\n        }\n\n        w=n+1-x;d=y;\n        if(w>d){\n            long tt=w;\n            w=d;d=tt;\n        }\n\n        if(t>=d+w-2) ct+=d*w;\n        else if(t<w&&t<d) {\n            //  long k=w;\n            ct+=(t+1)*(t+2)/2;\n        }\n        else if(t>=w&&t<d) {\n            // long k=w;\n            ct+=w*(w+1)/2;\n            long k=t-(w-1);\n            ct+=k*w;\n        }\n        else if(t>=w&&t>=d) {\n            // long k=w;\n\n            ct+=w*d;\n            long k=w-2-(t-d);\n            ct-=k*(k+1)/2;\n        }\n        w=n+1-x;d=n+1-y;\n        if(w>d){\n            long tt=w;\n            w=d;d=tt;\n        }\n\n        if(t>=d+w-2) ct+=d*w;\n        else if(t<w&&t<d) {\n            //  long k=w;\n            ct+=(t+1)*(t+2)/2;\n        }\n        else if(t>=w&&t<d) {\n            // long k=w;\n            ct+=w*(w+1)/2;\n            long k=t-(w-1);\n            ct+=k*w;\n        }\n        else if(t>=w&&t>=d) {\n            // long k=w;\n\n            ct+=w*d;\n            long k=w-2-(t-d);\n            ct-=k*(k+1)/2;\n        }\n        ct-=Math.min(t,x-1);\n        ct-=Math.min(t,y-1);\n        ct-=Math.min(t,n-x);\n        ct-=Math.min(t,n-y);\n       // System.out.println(t+\" \"+ct);\n        if(ct>=c)return true;\n        else\n        return false;\n    }\n\n}\n\nclass FastScanner extends BufferedReader {\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    public String next() {\n        StringBuilder sb = new StringBuilder();\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        if (c < 0) {\n            return null;\n        }\n        while (c >= 0 && !isWhiteSpace(c)) {\n            sb.appendCodePoint(c);\n            c = read();\n        }\n        return sb.toString();\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= 0 && c <= 32;\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public String readLine() {\n        try {\n            return super.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class E implements Runnable {\n\tpublic static void main (String[] args) {new Thread(null, new E(), \"_cf\", 1 << 28).start();}\n\n\tint n, m;\n\tchar[] str;\n\tint[][] occs, cost;\n\tint[] dp;\n\t\n\tpublic void run() {\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tSystem.err.println(\"\");\n\n\t\tn = fs.nextInt(); m = fs.nextInt();\n\t\tstr = fs.next().toCharArray();\n\t\toccs = new int[m][m];\n\t\tfor(int i = 0; i < n-1; i++) {\n\t\t\toccs[str[i]-'a'][str[i+1]-'a']++;\n\t\t\toccs[str[i+1]-'a'][str[i]-'a']++;\n\t\t}\n\t\t//cost[mask][v] = numPairs with v for some all bits on in mask\n\t\tint all = (1<<m)-1;\n\t\tcost = new int[m][1<<m];\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tfor(int mask = 1; mask < all; mask++) {\n\t\t\t\tif(((1<<i)&mask) > 0) continue;\n\t\t\t\tint lb = mask & (-mask);\n\t\t\t\tint trail = Integer.numberOfTrailingZeros(lb);\n\t\t\t\tint nmask = mask ^ lb;\n\t\t\t\tcost[i][mask] = cost[i][nmask]+occs[i][trail];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp = new int[1<<m];\n\t\tArrays.fill(dp, -1);\n\t\tSystem.out.println(solve(0));\n\t\t\n\t\tout.close();\n\t}\n\t\n\tint oo = (int)1e9;\n\tint solve(int mask) {\n\t\tif(mask == (1<<m)-1) return 0;\n\t\tif(dp[mask] != -1) return dp[mask];\n\t\tint res = oo;\n\t\t\n\t\tint addOn = 0;\n\t\tfor(int nxt = 0; nxt < m; nxt++) {\n\t\t\tif(((1<<nxt)&mask) > 0) continue;\n\t\t\taddOn += cost[nxt][mask];\n\t\t}\n\t\tfor(int nxt = 0; nxt < m; nxt++) {\n\t\t\tif(((1<<nxt)&mask) > 0) continue;\n\t\t\tint ret = addOn+solve(mask | (1<<nxt));\n\t\t\tres = Math.min(res, ret);\n\t\t}\n\t\t\n\t\treturn dp[mask] = res;\n\t}\n\t\n\tclass FastScanner {\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\n\t\tpublic FastScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t\t}\n\t\t}\n\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}                \n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) res[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t}\n\n}", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.util.*;\npublic class c8 {\n    static int n;\n    static int[] ds;\n    static int[][] g;\npublic static void main(String[] args)\n{\n    Scanner input = new Scanner(System.in);\n    int x = input.nextInt(), y = input.nextInt();\n    n = input.nextInt();\n    int[] xs = new int[n], ys = new int[n];\n    for(int i = 0; i<n; i++)\n    {\n        xs[i] = input.nextInt();\n        ys[i] = input.nextInt();\n    }\n    ds = new int[n];\n    g = new int[n][n];\n    for(int i = 0; i<n; i++)\n    {\n        ds[i] = (x - xs[i])  *  (x - xs[i]) + (y - ys[i]) * (y - ys[i]);\n        for(int j = 0; j<n; j++)\n        {\n            g[i][j] = (xs[i] - xs[j]) * (xs[i] - xs[j]) + (ys[i] - ys[j]) * (ys[i] - ys[j]);\n        }\n    }\n    int[] dp = new int[1<<n];\n    Arrays.fill(dp, 987654321);\n    dp[0] = 0;\n    for(int i = 0; i<(1<<n); i++)\n    {\n        if(dp[i] == 987654321) continue;\n        for(int a = 0; a<n; a++)\n        {\n            if((i & (1<<a)) > 0) continue;\n            dp[i | (1<<a)] = Math.min(dp[i | (1<<a)], dp[i] + 2*ds[a]);\n            for(int b = a+1; b<n; b++)\n            {\n                if((i & (1<<b)) > 0) continue;\n                dp[i | (1<<a) | (1<<b)] = Math.min(dp[i | (1<<a) | (1<<b)], dp[i] + ds[a] + ds[b] + g[a][b]);\n            }\n            break;\n        }\n    }\n    Stack<Integer> stk = new Stack<Integer>();\n    stk.add(0);\n    int i = (1<<n) - 1;\n    //System.out.println(Arrays.toString(dp));\n\n    trace:\n    while(i > 0)\n    {\n        //System.out.println(i);\n        for(int a = 0; a<n; a++)\n        {\n            if((i & (1<<a)) == 0) continue;\n            if( dp[i] == dp[i - (1<<a)] + 2*ds[a])\n            {\n                stk.add(a+1);\n                stk.add(0);\n                i -= (1<<a);\n                continue trace;\n            }\n            for(int b = a+1; b<n; b++)\n            {\n                if((i & (1<<b)) == 0) continue;\n                if(dp[i] == dp[i - (1<<a) - (1<<b)] + ds[a] + ds[b] + g[a][b])\n                {\n                    stk.add(a+1);\n                    stk.add(b+1);\n                    stk.add(0);\n                    i -= (1<<a) + (1<<b);\n                    continue trace;\n                }\n            }\n            //break;\n        }\n    }\n    System.out.println(dp[(1<<n) - 1]);\n    while(!stk.isEmpty()) System.out.print(stk.pop()+\" \");\n}\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class a{\n    static int a;\n    static Scanner sc = new Scanner(System.in);\n    public static void main(String[] args) throws IOException{\n        int n = sc.nextInt();\n        int p = n;\n        int m = sc.nextInt();\n        int k = sc.nextInt();\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = sc.nextInt() - 1;\n        }\n        Arrays.sort(a);\n        int j =0;\n        for(int i=0; i<n; i++){\n            if(m > k){\n                k = k + a[n-i-1];\n                j++;\n            }\n        }\n        if(m > k)\n            System.out.println(-1);\n        else\n            System.out.println(j);\n    }\n    \n}", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\npublic class First {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        int t;\n        //t = in.nextInt();\n        t = 1;\n        while (t > 0) {\n            solver.call(in,out);\n            t--;\n        }\n        out.close();\n    }\n\n    static class TaskA {\n        public void call(InputReader in, PrintWriter out) {\n\n            int n;\n            char[] arr = in.next().toCharArray();\n            char[] array = in.next().toCharArray();\n            n = arr.length;\n\n            int a = 0;\n            int j = 0;\n\n            for (int i = 0; i < n; i++,j++) {\n                if(arr[i]=='0' && array[j]=='0' &&  j+1<n && array[j+1]=='0'){\n                    a++;\n                    arr[i]='X';\n                    array[j]='X';\n                    array[j+1]='X';\n                }\n                else if(arr[i]=='0' && array[j]=='0' &&  i+1<n && arr[i+1]=='0'){\n                    a++;\n                    arr[i]='X';\n                    array[j]='X';\n                    arr[i+1]='X';\n                }\n                else if(i+1<n && arr[i+1]=='0' && array[j]=='0' &&  j+1<n && array[j+1]=='0'){\n                    a++;\n                    arr[i+1]='X';\n                    array[j]='X';\n                    array[j+1]='X';\n                }\n                else if(i+1<n && arr[i+1]=='0' && arr[i]=='0' &&  j+1<n && array[j+1]=='0'){\n                    a++;\n                    arr[i+1]='X';\n                    arr[i]='X';\n                    array[j+1]='X';\n                }\n            }\n\n            out.println(a);\n        }\n    }\n\n    static class answer implements Comparable<answer> {\n        int a, b;\n\n        public answer(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(answer o) {\n            if(o.a==this.a){\n                return this.b- o.b;\n            }\n            return o.a - this.a;\n        }\n    }\n\n\n\n\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    static void sort(int[] a) {\n        ArrayList<Integer> l=new ArrayList<>();\n        for (int i:a) l.add(i);\n        Collections.sort(l);\n        for (int i=0; i<a.length; i++) a[i]=l.get(i);\n    }\n\n    static final Random random=new Random();\n\n    static void shuffleSort(int[] arr) {\n        int n=arr.length;\n        for (int i=0; i<n; i++) {\n            int a=random.nextInt(n), temp=arr[a];\n            arr[a]=arr[i];\n            arr[i]=temp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n}", "complexity": "constant", "problem": "0991_D", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Substrings_Sort {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tString[] str = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstr[i] = in.next();\n\t\t}\n\t\tint count = 1;\n\t\tif (n > 1) {\n\t\t\tfor (int h=0;h<n;h++){\n\t\t\t\tfor (int g=h+1;g<n;g++){\n\t\t\t\t\tif (str[h].length()>str[g].length()){\n\t\t\t\t\t\tString temp=str[h];\n\t\t\t\t\t\tstr[h]=str[g];\n\t\t\t\t\t\tstr[g]=temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < n-1; j++) {\n\t\t\t\tfor (int k = 0; k < str[j + 1].length(); k++) {\n\t\t\t\t\t\n\t\t\t\t\tif (str[j].charAt(0) == str[j + 1].charAt(k) ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (str[j + 1].startsWith(str[j], k)) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count==n){\n\t\t\tSystem.out.println(\"YES\");\n\t\t\tfor (int j=0;j<n;j++)\n\t\t\t\tSystem.out.println(str[j]);\n\t\t}\n\t\telse \n\t\t\tSystem.out.println(\"NO\");\n\t\t\n\t}\n\n}", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class f {\n\tstatic int n;\n\tstatic double[][] g;\npublic static void main(String[] args) throws IOException {\n\tinput.init(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\tn = input.nextInt();\n\tg = new double[n][n];\n\tfor(int i = 0; i<n; i++)\n\t\tfor(int j = 0; j<n; j++)\n\t\t\tg[i][j] = input.nextDouble();\n\tfor(int i = 0; i<n; i++)\n\t\tfor(int j = 0; j<n; j++)\n\t\t\tg[j][i] = 1 - g[i][j];\n\tfor(int i = 0; i<n; i++)\n\t{\n\t\tdouble[] dp = new double[1<<n];\n\t\tfor(int mask = 0; mask < (1<<n); mask++)\n\t\t{\n\t\t\tif((mask & (1<<i)) == 0)\n\t\t\t{\n\t\t\t\tdp[mask] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(mask == (1<<i))\n\t\t\t{\n\t\t\t\tdp[mask] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint count = Integer.bitCount(mask);\n\t\t\tdouble prob = 1.0 / (count * (count-1)/2);\n\t\t\tfor(int a = 0; a<n; a++)\n\t\t\t{\n\t\t\t\tif((mask & (1<<a)) == 0) continue;\n\t\t\t\tfor(int b = a+1; b<n; b++)\n\t\t\t\t{\n\t\t\t\t\tif((mask & (1<<b)) == 0) continue;\n\t\t\t\t\tdouble p = g[a][b] * dp[mask ^ (1<<b)] + g[b][a] * dp[mask ^ (1<<a)];\n\t\t\t\t\tdp[mask] += p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[mask] *= prob;\n\t\t}\n\t\tout.print(dp[(1<<n)-1]+\" \");\n\t}\n\tout.close();\n}\npublic static class input {\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer;\n\n\tstatic void init(InputStream input) {\n\t\treader = new BufferedReader(new InputStreamReader(input));\n\t\ttokenizer = new StringTokenizer(\"\");\n\t}\n\n\tstatic String next() throws IOException {\n\t\twhile (!tokenizer.hasMoreTokens())\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n}\n}\n\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\n\npublic class Main {\n    /**\n     * @param args\n     * @throws IOException \n     */\n    public static void main(String[] args) throws IOException {\n        // TODO Auto-generated method stub\n        BufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out=new PrintWriter(System.out);\n        int mod=1000000007;\n        String[] input=in.readLine().split(\" \");\n        int n=Integer.parseInt(input[0]);\n        int a=Integer.parseInt(input[1]);\n        int b=Integer.parseInt(input[2]);\n        String[] h=in.readLine().split(\" \");\n        int[] mas=new int[n];\n        for(int i=0; i<n; i++){\n            mas[i]=Integer.parseInt(h[i]);\n        }\n        Arrays.sort(mas);\n        int l=mas[b-1];\n        int r=mas[b];\n        int count=0;\n        if(l==r) count=0;\n        else count=r-l;\n        out.println(count);\n        out.close();\n    }\n\n}", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.File;\n\nimport java.io.FileInputStream;\n\nimport java.io.FileNotFoundException;\n\nimport java.io.PrintWriter;\n\nimport java.util.Arrays;\n\nimport java.util.Scanner;\n\n\n\npublic class Main {\n\n\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner read = new Scanner(new FileInputStream(new File(\"input.txt\")));\n\n\t\tPrintWriter out = new PrintWriter(new File(\"output.txt\"));\n\n\t\tint n = read.nextInt(), m = read.nextInt(), k = read.nextInt(), tree[][] = new int[n][m], a[] = new int[k],\n\n\t\t\t\tb[] = new int[k], x = 0, y = 0, max = -1, d = 0;\n\n\n\n\t\tfor (int i = 0; i < k; i++) {\n\n\t\t\ta[i] = read.nextInt() - 1;\n\n\t\t\tb[i] = read.nextInt() - 1;\t\n\n\t\t\ttree[a[i]][b[i]] = 0;\n\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++){\n\n\t\t\tArrays.fill(tree[i], Integer.MAX_VALUE);\n\n\t\t}\n\n\t\tfor (int o = 0; o < k; o++) {\n\n\t\t\tfor(int i = 0; i < n; i++){\n\n\t\t\t\tfor(int j = 0; j < m; j++){\n\n\t\t\t\t\td = Math.abs(a[o] - i) + Math.abs(b[o] - j);\n\n\t\t\t\t\tif(d < tree[i][j])\n\n\t\t\t\t\t\ttree[i][j] = d;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor(int i = 0; i<n; i++){\n\n\t\t\tfor(int j = 0; j < m ; j ++){\n\n\t\t\t\tif(tree[i][j] > max){\n\n\t\t\t\t\tmax=  tree[i][j];\n\n\t\t\t\t\tx=  i;\n\n\t\t\t\t\ty = j;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tout.println(x + 1 + \" \" + (y + 1));\n\n\t\tout.close();\n\n\t}\n\n\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class EdA {\n\tstatic long[] mods = {1000000007, 998244353, 1000000009};\n\tstatic long mod = mods[0];\n\tpublic static MyScanner sc;\n    public static PrintWriter out;\n\tpublic static void main(String[] havish) throws Exception{\n\t\t// TODO Auto-generated method stub\n \t\tsc = new MyScanner();\n \t\tout = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tmod = sc.nextLong();\n\t\tlong[] fact = new long[401];\n\t\tlong[] twopowers = new long[401];\n\t\tfact[0] = 1;\n\t\ttwopowers[0] = 1;\n\t\tfor(int j = 1;j<=400;j++){\n\t\t\ttwopowers[j] = twopowers[j-1] * 2L;\n\t\t\ttwopowers[j] %= mod;\n\t\t\tfact[j] = fact[j-1] * j;\n\t\t\tfact[j] %= mod;\n\t\t}\n\t\tlong[][] choose = new long[401][401];\n\t\tfor(int j = 0;j<=400;j++){\n\t\t\tfor(int k = 0;k<=j;k++){\n\t\t\t\tchoose[j][k] = fact[j];\n\t\t\t\tchoose[j][k] *= inv(fact[k]);\n\t\t\t\tchoose[j][k] %= mod;\n\t\t\t\tchoose[j][k] *= inv(fact[j-k]);\n\t\t\t\tchoose[j][k] %= mod;\n\t\t\t}\n\t\t}\n\t\tlong[][] dp = new long[n+1][n+1]; //prefix, # of autos\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tdp[j][0] = twopowers[j-1];\n\t\t}\n\t\tfor(int k = 0;k<n;k++){  //number of autos\n\t\t\tfor(int j = 1;j<=n;j++){ //prefix\n\t\t\t\tif (k > j)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int add = 2; j+add <= n; add++){\n\t\t\t\t\tlong prod = dp[j][k] * choose[j-k+add-1][add-1];\n\t\t\t\t\tprod %= mod;\n\t\t\t\t\tprod *= twopowers[add-2];\n\t\t\t\t\t\n\t\t\t\t\tdp[j+add][k+1] += prod;\n\t\t\t\t\tdp[j+add][k+1] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tfor(int s = 0;s<=n;s++){\n\t\t\tans+=dp[n][s];\n\t\t\tans %= mod;\n\t\t}\n\t\tout.println(ans);\n \t\tout.close();\n \t\t\n \t}\n\tpublic static long inv(long n){\n\t\treturn power(n, mod-2);\n\t}\n\tpublic static void sort(int[] array){\n\t\tArrayList<Integer> copy = new ArrayList<>();\n\t\tfor (int i : array)\n\t\t\tcopy.add(i);\n\t\tCollections.sort(copy);\n\t\tfor(int i = 0;i<array.length;i++)\n\t\t\tarray[i] = copy.get(i);\n\t}\n\tstatic String[] readArrayString(int n){\n\t\tString[] array = new String[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.next();\n\t\treturn array;\n\t}\n\tstatic int[] readArrayInt(int n){\n    \tint[] array = new int[n];\n    \tfor(int j = 0;j<n;j++)\n    \t\tarray[j] = sc.nextInt();\n    \treturn array;\n    }\n\tstatic int[] readArrayInt1(int n){\n\t\tint[] array = new int[n+1];\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tarray[j] = sc.nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\tstatic long[] readArrayLong(int n){\n\t\tlong[] array = new long[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextLong();\n\t\treturn array;\n\t}\n\tstatic double[] readArrayDouble(int n){\n\t\tdouble[] array = new double[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextDouble();\n\t\treturn array;\n\t}\n\tstatic int minIndex(int[] array){\n\t\tint minValue = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(long[] array){\n\t\tlong minValue = Long.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(double[] array){\n\t\tdouble minValue = Double.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic long power(long x, long y){\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y%2 == 1)\n\t\t\treturn (x*power(x, y-1))%mod;\n\t\treturn power((x*x)%mod, y/2)%mod;\n\t}\n\tstatic void verdict(boolean a){\n        out.println(a ? \"YES\" : \"NO\");\n    }\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try{\n                str = br.readLine();\n            } \n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n    }\t\n}\n\n//StringJoiner sj = new StringJoiner(\" \"); \n//sj.add(strings)\n//sj.toString() gives string of those stuff w spaces or whatever that sequence is", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "// Author : RegalBeast\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n  static final FastReader FR = new FastReader();\n  static final PrintWriter PW = new PrintWriter(new OutputStreamWriter(System.out));\n\n  public static void main(String[] args) {\n    StringBuilder solution = new StringBuilder();\n    int rows = FR.nextInt();\n    int cols = FR.nextInt();\n    int moves = FR.nextInt();\n\n    List<List<Integer>> horizontalEdgeWeights = new ArrayList<List<Integer>>(rows);\n    for (int r = 0; r < rows; r++) {\n      horizontalEdgeWeights.add(new ArrayList<Integer>(cols-1));\n\n      for (int c = 0; c < cols - 1; c++) {\n        horizontalEdgeWeights.get(r).add(FR.nextInt());\n      }\n    }\n\n    List<List<Integer>> verticalEdgeWeights = new ArrayList<List<Integer>>(rows-1);\n    for (int r = 0; r < rows - 1; r++) {\n      verticalEdgeWeights.add(new ArrayList<Integer>(cols));\n\n      for (int c = 0; c < cols; c++) {\n        verticalEdgeWeights.get(r).add(FR.nextInt());\n      }\n    }\n    \n    List<List<Integer>> result = getResult(rows, cols, moves, horizontalEdgeWeights, verticalEdgeWeights);\n    for (int r = 0; r < rows; r++) {\n      for (int c = 0; c < cols; c++) {\n        int value = (result != null ? result.get(r).get(c) : -1);\n        solution.append(value + \" \");\n      }\n      solution.append(\"\\n\");\n    }\n\n\t\tPW.print(solution.toString());\n    PW.close();\n  }\n\n  static List<List<Integer>> getResult(int rows, int cols, int moves, List<List<Integer>> horizontalEdgeWeights, List<List<Integer>> verticalEdgeWeights) {\n    if ((moves & 1) == 1) {\n      return null;\n    }\n\n    int mid = moves >> 1;\n    List<List<List<Integer>>> minForDistance = new ArrayList<List<List<Integer>>>(rows);\n    for (int r = 0; r < rows; r++) {\n      minForDistance.add(new ArrayList<List<Integer>>(cols));\n\n      for (int c = 0; c < cols; c++) {\n        minForDistance.get(r).add(new ArrayList<Integer>(Collections.nCopies(mid+1, Integer.MAX_VALUE)));\n        minForDistance.get(r).get(c).set(0, 0);\n      }\n    }\n\n    for (int m = 1; m <= mid; m++) {\n      for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n          int minBoredom = minForDistance.get(r).get(c).get(m);\n\n          if (r > 0) {\n            if (minForDistance.get(r-1).get(c).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r-1).get(c).get(m-1) + verticalEdgeWeights.get(r-1).get(c);\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n\n          if (c > 0) {\n            if (minForDistance.get(r).get(c-1).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r).get(c-1).get(m-1) + horizontalEdgeWeights.get(r).get(c-1);\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n          \n          if (r + 1 < rows) {\n            if (minForDistance.get(r+1).get(c).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r+1).get(c).get(m-1) + verticalEdgeWeights.get(r).get(c);\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n   \n          if (c + 1 < cols) {\n            if (minForDistance.get(r).get(c+1).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r).get(c+1).get(m-1) + horizontalEdgeWeights.get(r).get(c);\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n\n          minForDistance.get(r).get(c).set(m, minBoredom);\n        }\n      }\n    }\n\n    List<List<Integer>> result = new ArrayList<List<Integer>>(rows);\n    for (int r = 0; r < rows; r++) {\n      result.add(new ArrayList<Integer>(cols));\n\n      for (int c = 0; c < cols; c++) {\n        result.get(r).add(minForDistance.get(r).get(c).get(mid) << 1);\n      }\n    }\n\n    return result;\n  }\n\n  static class FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n      br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n      while (st == null || !st.hasMoreElements()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        } catch (IOException  e) {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n      String str = \"\";\n      try {\n        str = br.readLine();\n      } catch (IOException e)  {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.*;\n\nimport java.math.*;\n\nimport java.io.*;\n\n\n\npublic class Main\n\n\t{\n\n\tpublic static void main(String args[]) throws IOException\n\n\t\t{\n\n\t\tScanner c = new Scanner(new FileReader(\"input.txt\"));\n\n\t\tPrintWriter out = new PrintWriter(new File(\"output.txt\"));\n\n\n\n\t\tint N=c.nextInt();\n\n\t\tint M=c.nextInt();\n\n\t\tint A[][]=new int[N][M];\n\n\t\tfor(int i=0;i<N;i++)\n\n\t\t\tArrays.fill(A[i],Integer.MAX_VALUE/100);\n\n\t\tint K=c.nextInt();\n\n\t\tfor(int i=0;i<K;i++)\n\n\t\t\t{\n\n\t\t\tint x=c.nextInt()-1;\n\n\t\t\tint y=c.nextInt()-1;\n\n\t\t\tfor(int i1=0;i1<N;i1++)\n\n\t\t\t\t{\n\n\t\t\t\tfor(int j1=0;j1<M;j1++)\n\n\t\t\t\t\tA[i1][j1]=Math.min(A[i1][j1],Math.abs(i1-x)+Math.abs(j1-y));\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\tint maxi=0;\n\n\t\tint maxj=0;\n\n\t\tfor(int i=0;i<N;i++)\n\n\t\t\t{\n\n\t\t\tfor(int j=0;j<M;j++)\n\n\t\t\t\t{\n\n\t\t\t\tif(A[i][j]>A[maxi][maxj])\n\n\t\t\t\t\t{\n\n\t\t\t\t\tmaxi=i;\n\n\t\t\t\t\tmaxj=j;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\tout.println((maxi+1)+\" \"+(maxj+1));\n\n\t\tout.close();\n\n\t\t}\n\n\t}\n\n\n\n//must declare new classes here", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.awt.List;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class T {\n\tstatic Scanner in = new Scanner();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic boolean adj[][];\n\tstatic int n, m, from;\n\tstatic long memo[][];\n\tstatic long Num_Cycle;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tn = in.nextInt();\n\t\tm = in.nextInt();\n\t\tadj = new boolean[n][n];\n\t\tmemo = new long[n][1 << n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = in.nextInt() - 1;\n\t\t\tint v = in.nextInt() - 1;\n\t\t\tadj[u][v] = adj[v][u] = true;\n\t\t}\n\t\tfor (long arr[] : memo) {\n\t\t\tArrays.fill(arr, -1);\n\t\t}\n\t\tNum_Cycle = 0L;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfrom = i;\n\t\t\tNum_Cycle += dp(from, (1 << i));\n\t\t}\n\t\tout.println(Num_Cycle / 2);\n\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic long dp(int start, int mask) {\n\t\tif (memo[start][mask] != -1) {\n\t\t\treturn (memo[start][mask]);\n\t\t}\n\t\tlong ans = 0L;\n\t\tif (adj[start][from] && Integer.bitCount(mask) >= 3) {// Cycle has\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// atleast 3\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// node and 3\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// edges\n\t\t\tans++;\n\t\t}\n\t\tfor (int i = from + 1; i < n; i++) {\n\t\t\tif (adj[start][i] && ((mask & (1 << i)) == 0)) {\n\t\t\t\tans += dp(i, mask | (1 << i));\n\t\t\t}\n\t\t}\n\t\treturn memo[start][mask] = ans;\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tScanner(String file) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t}\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.util.*;\npublic class Etruco2 {\n\t\n\tstatic String[] vals = {\n\t\t\t\"%S3L{PYzV1%SGI'>$/4Gam=^#ODu|`Q!Bys%Mw|?fA*0ti{r69RB1N`{B>YC;.:XEmm3t-i^N\",\n\t\t\t\"#Y73mVxQ&J`inFO4.v<j?yg{4~O=p=t$'#UHQizDnbsn,+JyuS~@WKw0p*Gy%V:#sa5,L|9RX{\",\n\t\t\t\"f0J*n]5ZaRg:d-;{f!Y47]i_'u'cTz*=K$b#=}w[U]3*f+$|4ePs'K?]p8~0loSL$h_+T^{+ik\",\n\t\t\t\"@r),FzP0XP>vU2<s9GIJ;0K0e)b_Hwyaw2}n0-%|lUlV(kWB<nx7@M[30yXxR(n:5@CEc[~,B^o\",\n\t\t\t\"0<2C[Fz1*3iganAet-6RW8/X&nnSUf`Tu5-$~<5}F~$e_n5j9jD^Kk)_Xh=)WG@{4:XC;V4a|X]*\",\n\t\t\t\"(_gw]4[ktYOZ},E?GXG5h{UF<Fx1O$0YNdA0+5)7#j%f)=Ui|3p^tt:SV(N^mbR9.+!s4fy<.?WQ.\",\n\t\t\t\"%-i=_PJtuHA63yU,f)Gh@#Z*;FIWjaXwKS*bq=EOMA9yc>OD+}xg{z`X.~atEmXp9Z~*u]I3_7IxDZ\",\n\t\t\t\"#N,-ehU0na1kWpn=P9ZK{TRs/&@KgxaK4h+V/ea!9Y3QYy9ZL}n&pn>G+'I+]ekWM$(g'8ym$Mj+,?V\",\n\t\t\t\"coyL[=Xb>wzL0z?{kW5GQjeWPCy6YU<B/?paWq?^7__LMh<{ZJ+8!o7I.=<2b)j-)f!Cwk7!Ojrs[Zs\",\n\t\t\t\"A+If^46|x9Wfiv3OlqZAUE[u(p2nLL/x$!LmSrR4Do9+4oYG:0P-!#>g9'|axl=i;q`E:ja?MDOB<Gyk\",\n\t\t\t\"1$8eKLgE'nM]8^vi,NCMzBN{a<@{.}Yibo/OLo*`;G%v}'Lh~oGudWag6ECf{cpc<%]2ciRk*]k|/>y?V\",\n\t\t\t\")>A7nmMgLYs=3#7`G%X{Kr~U%||frj>qN)}H^GawXTT}/=bFAGD+u1?YNT_2Ht~w[m8?LLh=YBS!6(nYD:\",\n\t\t\t\"%W;~8W^>]K2kwP_JIVOGo.l5<Z0zR51sXzT'sS)-@WFA6I1Q*{$SR0UT1x}[!]|^JT.N>;yA`kfH`f>E.`6\",\n\t\t\t\"#iCwqRtf[6J>97)oD,nb>z+}nIJ=?2h40Mhp=)E'Bm|<?v1e<H68>yG'sA0#eN>Ft4N<Qt}eXeLHI|A7BmOV\",\n\t\t\t\"sYg3/'{oSnr!c#bd??s'UM==k<CN-|!,}c8Vb[&?tR}]?N38+U-w=$yYb_3?k*RDR1=.q]xSz2Lz(&53-xGF\",\n\t\t\t\"J<2wR!6o@K;#ftMP&,Gl;<VmX#2TNi]l_ZP]1Y$,bqcrIl_2KlqcXh46&fB&5{h/+[~5lLK8C*Ypm$UxRW4-N\",\n\t\t\t\"6:X}!AJ[uGdSD@Bbe7#$g]u{ByvOp[nkDIG*Ln1@d:`OnhYjr#c]4qa4>hatq4l_EoFb}6FtSOQfu3j$>o$98J\",\n\t\t\t\",:=#^-<(+n*e[l7/{uM<_x)#7GNxXsA*v@5~9+*;=l%XX[65ms-a3rQE({l3Y#L'>1[lHW*9/;8w^x96dK8d|H*\",\n\t\t\t\"'7C8`Ku%e]3X@+oX0(O/)~Up%;eaEA_q0kVkr>BtTCV{$~:ff]['Oy4lW[F&#5Epcri#A$q7qk3x(I[)Iu`+qjc2\",\n\t\t\t\"$a|sCP(`q)r!w>3jHD7~;@Y%U_BTgu%!<]/Qs}siNKUHJ`^mEFMI!6<o.la&tEkP%V^q#RZb2S4,izBiS_l.Yh2y{\",\n\t\t\t\"#ESSy)K!I_r#D'5qJ)s]SnZ8c:~PE4*;#A$[AeE9A8,{2._6YY;=~iOJ=33d8Hw)5vXp%g=WqVl+yy,VmtM,2ao4=N\",\n\t\t\t\"e<)oJ1mnPoS!A$'Y}`AZVCZUQ0Ky)'^jQZB{eVCW~xb4f_*_Lo$>.Cj_X+%~h2UsWSQbRj4XoL'#yW?IGXbd[!3U|6\",\n\t\t\t\"D`L&4'8NHO(dVv{+<uYwH5t#c?4YOB.5@z%:p>`HG#]pe,!!F.~|CZ$Qh]<J%_ON:6GMr|5b<w~)?1]6H%QT:hfMYAN\",\n\t\t\t\"48eMirgOAMc0``u#]nz{aP5u:cM>>5B%J|+w}8}(y_Uv_VFq]rCYB1wpD[{U}={#=S+SJQmQ@~1zY~idvR]4rKz#L3L{\",\n\t\t\t\"+`-#D+O:7z=[7GBB)R=eQ:5OZa'bc_[D+NFe=P3cdM3QKJVv*?x;RlNZixw?{qd#@8D>CoZzsJEqnGL!Xd3RoZ,qBv!4k\",\n\t\t\t\"'/q7_eOF].wH,o}YDkMDO^#+TvDqr*Q4.~%*h6DH=0TCpE*m3T++kJK(JQlIwA~+r/c{N0,QD;1DDX(<OZivC3Y>J5Uyfo\",\n\t\t\t\"$i+*e>tWyzs,GKQ>IP/+re2YX[.uY[jzUE$$o3KmUIDxlxy}ZdhF(wBOTip8DjA,cwHU&:qHwKta#[,SJ#oYa$BjEd<Fe]*\",\n\t\t\t\"#O*r,8u<Bz3Vs&Jdq1d2AIxB3}skyib'GPee/r0tw^7AaxMJUncL$:O-C?#`!j:sw!s3rlz:mtk$|rN{Ma`!jezRkTgI>n9.\",\n\t\t\t\"mH`mtJAcH6.~?en.+&TlY/[Wye#N<]Ei$ErRJJpnprYU1]lK{)rXjST-bu[KYUZw'1f<lYS({<1+Sz,T3~sB/);u$eO=PMmZ\",\n\t\t\t\"J^-Oc/l}!vGny~6jX-@G>;ot_||1)VA<AH4Sx'fRx?%:^tq-#+,99k0LY~S4u^>Wn>(ai?;7'C|f=5-*X%G<R6i7r}gr#nq/V\",\n\t\t\t\"8@>trXHR!F2,jQ<C4lqC5wlS)}t8@+,Ha]YnP1ACVvyJrDz[t6T9?n69yZk#&+p6;&kLk#Bwb:cA-|TKzXq0Tk{J3gTt*!(rRs\",\n\t\t\t\".AGXO=~svf*-P1ad/!n]Jc^EPtwzaC!6kKUUz*0TTW%qkFX`bO=/pH.QU!A|C,r-03O/_/@l*bKJZqO3HW7M*i;?h8;Fg`cS0Lk\",\n\t\t\t\"(r9y<CJ.RO,zE$/)g%8/Lrp?VQ4+-wr4D?5IpIWtzbNqQG3UL!/L,#N:h7RJYVAXK,6LT2ZSx,J5mEDS5Es&}Y3aSMh`hLeO0/[V\",\n\t\t\t\"%p%8Rcx~SIuxqTE=n?~W?J-$36syElGT#mdT~oi7bRh,X5Y;'iSv]VQ#R^os:M~B:daTv/#{|,.3mo/.xKESf^3FtfI#95yn9{;}:\",\n\t\t\t\"$0XUj],Dq.GU.t].u7/,H2CQ_`#=tV?sV'q%#/Nx9E)Qgalh]t(Dx}f0FNT(VW;V2pK7!P?Ov]j1kz])U-l%SjP<Q}C?}eW6t:c?t6\",\n\t\t\t\"#6CSvs;f%`_m<op_8dmjpm3wze?_~SUiAOHD@CEXM,vU}i+|V7zk{uw_uyynMDL>0b[9)}Wk-bC.J<SyR+?(zHXd9c{Bx]bA/uDrK|V\",\n\t\t\t\"byn4b~4K[/q[ZNRj){-dXsS~xlky#0,DdUaO<t5JD;33h1B+<17-{#m)LY:8$(y3!HwqUuygn-[x(k%Hmis9T|E;b{P5iXxw}u&MD[F\",\n\t\t\t\"FX|Q06PFPwj.#(LJ=`zx[*J2H?3~7vR:nL9)%!n|)x#KbXFkh{G'zb|#}0F.fZO}aV)7OGtt!^9}KBe[$N)d2@ZnYZnNx@s%W[DQr79N\",\n\t\t\t\"7(&-S]Jg#y1n-{jgr%y57TT`Fsppqgs|2Pk7Enqw^[4N%~:{vlU1[z%,!_-RPASA8~$rq$jMG6,V[(+wGiX(A|2AT)M8Tx%X>}3,+kQyJ\",\n\t\t\t\".3rtg&n9N_e.5[77e*ftW;C1O;U%Qf,}8>.0q~hd!{IHpG~(.O9NdCq`VeKx@H$9(&zgo[{KSq5J-@/$Tq<7eV;6(WMbEkOq[!`nPBB/(*\",\n\t\t\t\")+(4Xy##P^T-5H~m|Xp'{=+G_`7;s9u.SvcNw_xaI'&R)m;`$(8PX8xZ>*@2>xfJR<g]PeA8fk.,H+WoxSrJ$dMqs2nc)4x(T3jeQ<[^~c2\",\n\t\t\t\"&0<|E2l(VeGZt+;mpfAe/w(fyb#U,)i>{Q`s11FEBLydh,'Jz<a,_Lhd7pFC2(Xz(.b5-Yz}::NV/`Mm$;iZR4=}!ph:3+awm>mf&'%6KkX{\",\n\t\t\t\"$K$o}U#q@7(@BTdC.?bOK'KbtD4!bv49z}W=SX/2|G}.g1zn9-1wwY!CV<h2i!ve2ifU;Y}30mtC)Ks~JrllIN_L0q$lEiv3<^HS<d/U*RBvN\",\n\t\t\t\"#K3b}I$Zz}:>?3e>H4B|fEdd7Qf+_&*J<!HxkBjF=1W-YO*sxeKKt'<Sq}|C>:?O(AFgaID%'M![`@F&S0Wh]o_{/Rm4{Iz9w=6+'FZ8+By0x6\",\n\t\t\t\"r:W%R2Z}E)rayr$Gb]UCZFBVy-V7|mEr/3cur6A*;A~Lw2WYGd;@10.H>*.i;J=]6.(=~%JoHc1TBa2!6#[q&TdsqepNhlz#`{iO_</yT,QJ%N\",\n\t\t\t\"QIe,.{^Zi@pR~m4z`j#7)UUIKL&j|2656o<u+o)Iun/cgnSDn(Er*CU'Ix'oMqVLf#Q3px=i^Xe5IX>p.(RylcT?u2b<@dxI7CalOz%bt;ZO$@{\",\n\t\t\t\">S=~&b_O'HOj#A_%6}b!f&:J%)M>5+u1SDSR32En077OL`F#VRFoVroWa59I002YC@?]1LY(jhoD4S*R;}<*,Sw2mT*7'f6B?'^c*e)#c-)arm]k\",\n\t\t\t\"39yr+-}9xZ[IL`G-,~bcWQ$e<$~*!dZE#tMe[OZ-dpH$GXdT,qJ:NvaAi5+<VP3PGos<bgu7s>;%-k4a,=w0,6.WL08y1x)1F;]ITwV5UtL^m&_no\",\n\t\t\t\",O[]LZ531#KNR1W/Dp*p#xX:mf$]Dx{jXE=GW#C7$!mlZO80(W-nJBnpDzuq`'bh'ci>$23`M=wagB024KJB/zC$6GeoiF'_oeyMEh+eI0&8TjgT]*\",\n\t\t\t\"(H?He]J)!SWDW1'$5mj#LMOQ`>A(<!JWh/sqBVqh5`3Sn=~Q2Xd60ga6X8rmbsFN6$8;*KT$wtn?BI/GgH`Y;G-C<b(y{`/'g5W_R8%N7g$U2'{}>~.\",\n\t\t\t\"%yke'YZk3,v$aBhJ2v;^uu$ttS1Mop#,iA^_9]WHWvy7^Y,3_7^Qm{y~axM&s!e(Go'VS.4Bk9v[B:cFQ)O75HC5qY|:pH5lgyoRD.MTg3AcVQ~@A}8Z\",\n\t\t\t\"$J-~[Tc.xDAf+=IC91X/q9f881;?NR;9mE/RDn*%Ik,y9??^&bxA)xr/F,Va_'6eNq4i`kUsKl!|B=I#$}Mhk86(3HU&0dt{GTVR[&Ud|y:'jK&p']h|V\",\n\t\t\t\"#Q3OW&>Jm<pdtfR;qu!:ux&*t+u[Y%1Pt>!PSbJku'7'li(^>eL_l.Ykf$SSv:q-j95w@3v[iec>;CDP=eL]#~R9<pnl+=46=$c,aB|NCp,3z]V8Z2MtJs\",\n\t\t\t\"ytm.~`FCg@m(=F@@U{J0VYStErIP?I-H-a6s$.$#K{3B:tEBJzy|FEaCF&`2HrZ(Y&37=(^}eE+_AQn:/*$%:+ML,g',1k~^dfBSUBskMeZ~x2(Q6>Pq}k\",\n\t\t\t\"XQseb,o}gb]X/'2P%Q$%@Km16RjWt#91?0][T%}q==jMrJGCPP6y?{!OJ:AQ_2dfnHE*Ys+8aS(+D`s&'@A*)E<hlY>v{N@GM!U$jyRr%Q';X^;@gJ#2&xV\",\n\t\t\t\"DELtxBvP@0IqcRU%L-`xQ4no:.|f,NTu1xr`wDGEIVm-q@,G8|1Wst3v)9Dxdc77a1mM6&PgJKY9B~rMVkIoWIG'N>Mrl9YNg)o3)P}mUt^)8-cb$xI_;oX:\",\n\t\t\t\"7lAu)]H&x-r)=mE]6P2B&Ifm(9F9!zNjJd&TN,b}mE;BPwb/*Im&&^pdI%@,U&8ZA24^Us]WYEc[dS[<87^^~/+Nm;?jMe|TU[mP#N,_D}h%-CQxL86/HF-+6\",\n\t\t\t\"/t_'OVLqoVtJlGd%mSg;o^7S(~wf9+>I'INo<[BqyTn]v<PaeLj~eQ~}~X32b7ZTcAMzHu)6jtT2H?@M95(C1:?aNhYMKC(kvP=Z^~+6P@|viR#utIW/iI!3KV\",\n\t\t\t\"*u-akgNqo>b6tkqN5DJSt9NoLl<?DE>+T4N-|<(&kFCv$Q%-fo9dC*4U!gnv<w,Xc4bXAhBV|Jm,Z]J0pMlXBy=*nbA_Pjbr#O;$%dfzGRd}KeJQo/RZNogHMpF\",\n\t\t\t\"'eP7fDQH-H#!j|h>)IoEF6-WZC]lIVJ/@|?/s9&sqd)p^~ugx~zDDH`&P7ch~iZ-jKp5aGQo-v1@I0ugW3LsiA%U:CP`UP@jc>*E30?~zglP0lXb@p(<c$ePRwEN\",\n\t\t\t\"%cQ]O`I?Z^[TbsO6:jNKN`y7o[~KhRv~iu=cY;NVxR*ZQxNrIpfSqw7K{#{{4dOtIsKF-':@tqyVW[{x9t4U}[e1-0XXTABM^.J,{Tc{(wr3Uj@+O7`rznkDp>s]J\",\n\t\t\t\"$G?d*@BxvQ>{2NdbzHeR[LIa-7Q`Puj(Ht)5f+GP7]1AoL[>IIW(>*_Z2`H2Pq:pj2JQ^t|tr|;d5:JS/cG37|x(tV~iHgDQN-3-tyAc{hf#kdsD=lbd`v{64$E2e*\",\n\t\t\t\"#VUQemGH]0leFuV^:<V`hp?J7x?aenY:C^^R:27~{+4jYd+A4{txe>S*/pWVcA~Kjo<HDh=.Mqo`PR,/t1yx&5px3636chFvn1$PAdbtca1B=7:64O5`)Y9`q)hc1c2\",\n\t\t\t\"#$t@73::fTYCj%S]lKo/sIlI=zunsA#8Y5]YEEo6-Bq_u>F-NdUoPs-L'uH@/u++l[,a&e`PX|1u<TjyASURuXJFL'wxzLw<BTzE>*_JmA@$LcB,j:g<d3y`0R*r'!8{\",\n\t\t\t\"aWSp_j@Tzm%?v;)3UoRbqZr;p?D:^wBRjKN@S;`AB|b,1B;(HORok;Tc1W!0qAF%Uq3f@,!+zaG*?GaT*'k@QN3K|S.N$s?<Uw-J+ukf~H#FgGFU`RNx`ZWq(,9=kQQN\",\n\t\t\t\"KMrVDEkM16AuyoI;P*ZJBrv;!,rR/iDn7LxrWtsMh|I.#'x1]/]02wG2I^X3$WOMk0A?DkDk7Ta$FXEt]!hm&UK-RLlB$xpxW][P7=wuoM(e^M]ZerZ<Ey}eoNjw9pdt6\",\n\t\t\t\"=[3C~w/f.74V:6:vze7B-.zl4Mw#~{HFD?;@hicn$B@AU'>e|01JEdcS^bZS,M}DH[=Fc9G5&r7czx%499'f&s9uf4X*%Ei1`=&gz`MEBv6TchYh=G:{7^+(K3V-`*r:fN\",\n\t\t\t\"4NI+1'KkL4u,#{IDd(8p+|$@Q>sGQ;'T[>:skE#M4G7B^kOGP&~L5W)`DhVup.E!M46H{gMN+]THBE/1&.j>)x_a[0S:Cov+^]u&Sz/44.dqrhwnJlxxpLge!w{3%Ha!%4{\",\n\t\t\t\".I9PeehvXspF[F$??y]9*V0Da/~9kfR-%sg_NA#]Xxk~gJ(2JFVOd(F:H)G,LTuD]nY7weQX%'`M]sn{Q1abJ,J_KV{w?/.!I6SBb3I==k(pzLJ(0o$Ih35I)JJh(jdwLS(k\",\n\t\t\t\"*F=.dZ6XliY}&(4]/>7en<4)&}1)Yk2%tdSgZOi7M`g|D-eWdts32qTEnwEciT[1[mixh814UhZVbCc/eyiMlf<P:`hMxf~`wP><%l*pFpj3A,Uz{}zR]9/pWZq_'|{+lsPvo\",\n\t\t\t\"'c0|-O$kHD9._=4.EXU3rQN?)jM!C$%])y?0&TQLnGChYe1n(txC1vYA2L'z2Fx(#p2ONeuWeUR]N?uoLNKG_kk7DA:<v9Y#4[|a]h?eXDk1#TTWnDq+EI8WfPdGsF+woh+(]*\",\n\t\t\t\"%tHm:f~UE8a({i;ikm_%*IZyoVGIlQl6)E'S|E7,mO|Sy|g~&sXWSc3^atX-c_@2,g?h9w%Xax21gl4m}3k?ZXn;JVDh'H6A~D[Oc}S0wcI9X[xxR!IVyA/+CX;rwO/Q<F2m(f.\",\n\t\t\t\"$_r)|9(3McJ-d$423`!PiVacGmd-|wL|2TRIOvq&4>j$6PM!{pWp530Vk/pj9K#-J+MUCyGf%s|*:`fL)XzifrJ6A!Lur(>mBOhH_yW0A0WW'gC|iX;s]hv9u[{hfLp]9S|PoJaZ\",\n\t\t\t\"#oR;uMX=U1vgn%6nTONc7HP;wsY5|sj'm>zI|ff>V&U@ZW(S)S^%~51fbNUoSCQCMm73(MwEA{>5&,!L[:i%HT6Yjoac;Dx%K<=2{K`)xm/0:9:p9$]FeZ,M2^0bE|B'>3JX5hplV\",\n\t\t\t\"#:R)W$kuhEe3d_wB{!Y9%-/nZF$yNyk]o71|Uk1(2`Qfm8>g6Y7Wfzz0)-G8Vh%tqC$#mvyeE]-kr/W]ugLvm-y&HUtC^&71L+JG!!Z>U,}5qllO4?9`qnvKB+JHaCS!16I}8k5bBs\",\n\t\t\t\"sy38-RZ3/aMN`V6#v#QS]a5vnCRk%SMYn)8W!]gau]4egu3aCsW2T0c`J;`o<|v<<VC8`@!SIi,x'4lTcdbh?$-=-2EBPl2hcU>{+:m{Z%mFZbNyC'ePuR(@lE2DLSXeSTeSaa^QPk\",\n\t\t\t\"ZMhWciybNhr1kRtD|1_b<8Ax6tqq84EVb)wS%t-W^~psSX.G,jCrYO7wj~DwYFZAqLeR(53?h+g`INo7Gm$lCWz,209vpKRHUK:i/FY_aOWDl.gt3|wCSl5XWO0Fvh1o#?TvCp`4_7V\",\n\t\t\t\"IWy*`0ug(-b!Hu}e4v-W+y358)Kvnq#M_E)o3P=w{,-ta^8NI7sALy>QPAq>r!<3xS#it4'Zi(.eo_~UqS)z=}FKPQ9{d.~P^K*~K`fb<FlZo_<F8Vs<iA.&q=e_I,lq&DP_1iSco94:\",\n\t\t\t\"=s@WG606c{xgI~7*0!PO~*Opu4^+m>eGcD_^'/tf_Jr%QCIH>WOKnaw`pXz&xMbI(=+b,nt+qJr*+-TjK`Z,sURM]TL>d|[H[#(G`zF,:okg}c^(&aI0N%Z.`Sg!OI(X'kgH&K4MhLR?6\",\n\t\t\t\"5dc/|C@JoStGxr~,2i;p@;M.cezli},k%lPJ^o_A)^e}+p*e{(3k^*[[ZrGU]JU^Ag?ReXF_@$=6rUGrP#qR[q0^,Gp5$9IqT&n29ic`r?==r@^whM:ipsm2%[=s`A)^+K/Z4i0Z[Kj!xV\",\n\t\t\t\"0!RU141:2FQ7b-=QkN5lDbJJQq|S.[?N*0)h6S(/MqbBopgx,%e[!,YDzlC&{HLU',BFiP:8*!Q~qb8T!Gm[]Lt}f}Mru&:w5-16h#kvG.s|N.H)'&hYW)Zr%ZSypdd;.?S[ewN7CUJ|7'F\",\n\t\t\t\"+~Oy!c<ye{%@^P`HAFbH?yd.U_QPeZ-Un=#L>wU_PlYHx4I-O4aTY.z%cbL~#g3Wfxkx2.,J(d({fC&|~>Gqdnk+G{XFMIQY1Z1XAZ,qASVDt9j/zS7L~6F/jkb_QL<}3oQEI|!1s3,+]9QN\",\n\t\t\t\")1'xJf[WHGn}?ovZ(M[s;tx[3Gk$rRWA4bx+Yw]Xr>?n9.mssuU^/bwCos?]N?v9,@xow'95f>y9=t!V,S(G<3Gnq7BYHJ);&[R33!;lE+cPcR%jurr*LJi]m4av[qqKQjA|}#g,|MyfNA?@J\",\n\t\t\t\"'0MeY|zpcPO]+C}p[ScFIWpJ}'laL>}CR9LuWPtFfm;<bxFzP-K`h&HVtJ5M1wJgox/ehMdTdhv^gye}4A4_}vr6W7V?N&/C}duZI'Xz`HnaK=b.SfNWd'k/nYwtX-4`p(*BNE4`_K@)bbz*D*\",\n\t\t\t\"%f)ZWb4.HR#3AQ!}3/aNEJweg0ZI~D$6B}q1S6pL7RMc[?wc}Ks:=%PCcQVVlwXTW4/,6@DP?uX-y`DM0]F|)#Npx$HY2@@A@b~_ExX,8HiX=@,Ykg9aU`K~R>hg,+[}h>O(6r!!l2<HdY:Y=c2\",\n\t\t\t\"$d0Q?B+wWpn8pVU}Un4f[-JzQN?zhJtzI^V[%X#7>EIJ4C6#nb:.:Go2=j+UH[$r=~|Mq#x8c%Sz;Fg&E$`FwHdbnSUp1:IjEIGv[v1Mw+lg<aIzH@atHjwT=qI39mm*+!djVLZR?9{i9t7D@nu{\",\n\t\t\t\"#|f?>D1?`|Df:<~jRYwxGXRF|~}O=^(.6)(Ge'@U,83J^xFhoN&6(.O3710XFRLB_o7`g7!7?#UYi>Tl292a9-R:U&jIJ[cI%.F7'D;Q)|XV/]J~X&!vZ$}%T[_pPCBXu;'*BmD&t0:DB_Fd@!a-N\",\n\t\t\t\"#K-M@%$Z`Cb@'K>+z~C&~+]I;Y<~,DV)#k#pvMluvyl1Uq#E|(zgPb$_NaB8*.z^,uf~6goZrJdB9ZT5SvTG~SL#MJ^BV:Ua;(mf=!5/N4]-T:|O5-eqUKP5@([-QHtM/_M(_,+}jzwE,d8<xvc6p6\",\n\t\t\t\"#'y8SS*f5SdrItW5ZAgEzM|htCuqTLG`5S?LGyJfQ0Ez6^dkIm?<AN.13h%{}::'N731(S=2q/TOC2C?1U#g!IFIvE|F'<Q'FnvH2FTcmoBZZLlWWQG~y>/>S{:@;Rbp>b9ejm8?1-{DoJL8@Yt-+IN\",\n\t\t\t\"kC$'rcIg|P!GdR(kY2w_W*A*K9F[M]vO3&t=}I%mf08|r|@{<5]fy2xRwQJVe+*b}L0:AWdvVtR?Vi}AifSK%7b<,|n_sQXFAu_A6b:/.''?D@V#BkMM,@N&;ODqLq1XP?I}'J{T[r`D3'pezl7^6({\",\n\t\t\t\"Wb?|O-W}`m2#~)URv`a&j4~npK{Beqg]+!g*`pL!XCV_IDa&IxAoB&LQt;]#>wwen?HS)%rSJbR'GJ!&Hvp;G-b8,n'izx__|1a+pU@+k`~/rzMI'SoURS[:`_ezt!mm)$]]34F4!!KkfdMIC]/F=1Pk\",\n\t\t\t\"J!CDyVG#XcOnkE;-c<RE'[%&,M!m${C='`!Y$R1Q[hA%D/34uyM<X#QRV3W=<]p_+y9N`(<EH:*hQnj58gQ|R31b`^,w]?a_Gq=q'_wmDx2EuNX1UhQX`}OG+JP~+$pmqM+G1MN{rq}6T=_1Qe3q$AN~o\",\n\t\t\t\"?xq)>v8vOf@l`9oGm*)uWG05rKQyNqQji/a`1acf4AL?hJ*q?]v97!~5?^.XsI0m:oD770_IUuMe/{iXVLl#S#X_H+:<PB@&Qx(B,-{)>QY*9xY{Is2hS)!lcjsc.l?$l?/h78KuW}8'H!8|b`r#5wT<]*\",\n\t\t\t\"8O6O6|`gzc7![)&miUYasq@:fY,}e+MC#o~~.[gf0aU5P/Wq`(m6L-Kz|N5D(:dinev11:TF'c5FHAS!m!QKwo4$i`4%u]bj`6>^$jw*v%#2*QBKI$bk*W?|^_m*enz|wsoOi%j>?&PB(Tk.!UP@^bL:*M.\",\n\t\t\t\"2|<^@&/r.y`4N%ph?-'xXSf`-k>fnliC80KQO44BS~<xS^5s(8a$U2`c@o23mR(948HI6_Y:CrpIy4-{o)5Ux}V~rmNjvEf~ymKd`@t!{j$-*z&n[yIjQO]qD$U0'lZ2W3%sLMMrT-KLlk+&yE7_F~;|nr,Z\",\n\t\t\t\".qxph,NAEG,gz7x#,gR8y}^?vd{'1pzmJ]^nC@vss,h!e'de6B3t4vY)^42jSD}ey.N|Gb,Y-f]jEfyCOE)Q/m.Y22WOp;H~YQ|<JfZ),%MT56&jdAI#72K?+9=.Yn|x/U0YtPoOfY=tcA5fYkfkMgY_#G+[V\",\n\t\t\t\"+j|Fu,mnMb[[_I7{AP%`L!@GB->vOZFa{3PT{+&nZ;{Gd`CqZr?hW1%ZR3WqcpBQ2ayi}RE+>:&pLP5:rp]Qt+eZN[)tNwG.tAIztFPvVz]K~$@UB.o,6[iXpmKX2#)[+}0>:=H.al{0h1nA&|3w,4z#[PH;:s\",\n\t\t\t\")MQ6zmK`vZeC{H2Istj')PMbKVYeF<eM.o),T6DO<!&Rk=vGIuPYCTMY>czUhIjh?C;tiQugSI6|r's}rGh{H/(Y'a!a%9lU.n_:}Vf6ro}[;X0XOXrsl__lP1?lMroE|xEG0I:~UmEK+Q?vqsvKro7FpQdE.$k\",\n\t\t\t\"'fC;a;Ted#3(|RP[*S{K^RtLZeavB#xHv<|{RQpa|/%b|_tY?>Q;UtC4,4hO,u9gZ+@sd83Odl[=em=7-^H%*HCE<eat.]&wmMbV{)y@-9<%[Xm-8Z=Hy2|2<x57P,/;o8hZZH;m4pmO$M!1M~4?.xfK]DP#'zSV\",\n\t\t\t\"&H16w,mmofX[4yXDF.}Na@CH@^jFf,K}>M#OV>+R%0dS1M|`Q<yqyun1|8?Sr#xBau(!bR)MKQ,P>>xKRCI/Bxl2H4P#y0gD+}R:r+UeI$|[s6lHJ5>;oA~_=IX*#/U_t5tC?}%vd&R#g_fOENC_d{8:B?%AX^Sm:\",\n\t\t\t\"%H*Hw<Ia]{(CEN=TN%QfM?0^,L2@,wOG*82YV=;@_iZ?p]DnnO_l>fa*}/3^h?G.XH+d'Q<z4@6{x`Y={B=H?e-OthzW$!&UZI{2Un[sW'Iz*X^Eg`F=3YU%T9SIc8D-jiCOnjd]49t6)CI{/*i;W[@`:s(}ydvSS6\",\n\t\t\t\"$^s.%XfK,2Us*n]WU'k9Y>9Ti?20]8RxV2EX'=SXH:,X@;e|.Sb;.7R7wCrll+HHJ|O>jw:!P5[i?v'w~{:MycsG{*[}8JgOsqC%SL0t[HM}i41=Jf}')SGy@tfqofVg:6&Q|w,#b&/H'/.gM3>HqO:Aqi&$W|U1wGV\",\n\t\t\t\"$(,3<E-seNZ&V1R_W=Spc4Br?Rg4?~dFw$an{FvyZMra{{gqA9+.X|vAGE<<L##Eo!CMQ~!e?e,,h3=K?<wT)|e+z:%2.k@VLav8M|,N@)/ROo']/KQ1P:X|H%Po<NFFj-+%U729dyXh,-~=2~fTYI3|AB~u_PcH-];F\",\n\t\t\t\"#Zl-GtX['ct@ch9KkiOLP]77.6VNelm_SNNJdW.dFGXRP%<TwO#K98r$NfUG*#-L({8o%>XZF}J|D?E0DEL@v83NC.L!wex96!O|5QQ_*e7RG=j-Sj'o>2*{HV<)GOwH487evAZNk=r-T1y.=m,&Vi.(knw@I$;T,58^N\",\n\t\t\t\"#:wmn8J6`[w<COAVr/!`3[G5V}yy;>2<UfHofYl%Uhh;t&1M<H$Y7q(hJNy68M=yQESKE)T19)Z;oRk9WWNe4{]G1J<_oCXnTy`%GEly&XLiN[K`H<r^Z:9s>Bei|x({E(Aoo5T{_BYg%2Edli_86seC(U~'B+>1]FYq$J\",\n\t\t\t\"#!8/U;c]1nFCeP9%:a!g0~F%q3lXy#KH[k@uUwmEAGJt,wmWt8L{MMQ7Sr6'S!+L<z=tFrp^:'(^49)2fXPqLWd#<tHob8o^:|o9i]HcFT^;,8tDi#ES>'='m~au8*d?Dsmn>#WSWrgYm<5~x:g=(!gS%3/{L<~EgF!1s$*\",\n\t\t\t\"l'7.(t`M4Y7Tk7XzHdB&z`(SJ>m?-f(bJ3{6uUJbV4+;qxH#UAT^aB|4zph0r(2z52!]Vrcx*h3!Z_<rw@bUdg6]B?6M;XK2-I4#_H$8s0Gjo@2GGER/F7/o9]Y?]rb@50|~5UVv_o(y9GjTwNs]nvw4wFBw0,{Gz7N|Ec2\",\n\t\t\t\"]*=2VfKD12h27;a()?>O9fOx5@[2,TyP$:Xbhxtx]9}xp,-;&yi/Fo|0eMDY-50VUl)QoLe9=N0ed/1!<Q>Qoa5yto%M@Z,HIoStM+YJw;?vva-.}tFowDB#Wr/t14u4'nx%h6b1]XMVEMJEamjX;v=/<Km3>$S~N[5h)9T{\",\n\t\t\t\"PD(W!DH&6nUOB'l@y{vk3w^|[rZt.RGB+rS=m~CrP[XY#LewEHqr{I.3km60z=fFEG31N:tlvhC(A4gEa;.*grU~zK6AuPX31.+0r*;[a[19~H/h~PN8Gt1hlA=iy$7fJ.N`bKWSCL{v&BJ#f8?t`zjg<V(wRRU>cbfWcVofN\",\n\t\t\t\"G0^NuhwXa4w~)jZ[j*{E%YMCaa<&H.}X945dS|w^g;'GQc<-.a(E&5g/:ZEWy?abIifub!S|`!&]&AZs'ePT?t$6ZZCB`UI@|moZ75`Sg:_nG}k6A`&9<<^[>os<kF;0F4qe2!PA^}fqmcypQwv2)hC`D,*rEqHAm)uL_I;bl6\",\n\t\t\t\"?u2[Z<@uQ{/!E3#STHVkA'RhMEn,'e@y}aWko'B&:3Mu?UVS-@V;Ink)`@yu]:~My@|Xiz7rP@fa.GW~DlD=gKzDxOH{6fATk-UFfFe=>_8Cqi:zL{MP#[HM'6ob$BW-(@;x[H`}jv@lWTdXKMdyZ}mK=|=U+*ePW0`AR0Kuy-N\",\n\t\t\t\":.{n;Au!==aW_~~/31:%|ap'pU+C9#>Hlf;h;HKs)1CYZnJ5ly_+@AM%,@N`|Eihs-c~{A~6|1,M1cU>*Ej`k:&.VOu;t)&e~~#MjS5,jIA;nB4^V*|T_F_z[-,A5}jP/_/i~Gc;*(fL8p%0U-A},qRIs*YKv>qa!y19MO~^(Vy{\",\n\t\t\t\"5VN9jpHpDfSUTBca)i8|h}_bRyht0S'H!{CRO9.Sq[efz^ORXP8zS}x8~;];v@eD^HGNAle,7ZI`T1NU4Mg~{W(W-&M[<h|Q*[l1:/3!'g*aYkfa[REbi`==?-PzhwO:%'sXir$}=O}~Cs-vr5YyZ%qZCPzPPnFZ8h^fO~)wB|dyk\",\n\t\t\t\"1x3Vt~rj21Twzr|,,=oz8EPC)V[~)lB|>thqaR,X?GC(h`u)I7K/BWtaGwt_!_vcA%!zerw[UCYgMvE,KBX<%m8unQG2aTCbOqNk[v%}%`]IH]@0n=4^G#}`jdM3|Y2+n|TLx=~d/y0fqc&n,OZS^]3Z,]%Q#hQoYNX|b)e~?PhY)o\",\n\t\t\t\"/!t6rJh<$~fBmH<nWA'=$:;%E'e`;}v/jOSQ^b4YA*GEiGrK{~4fync%3;JCq+oDTJhIi|)u$TC>3!qC6a=d`ccOA,!aEI6XA~_W0%S4,2/KseIf>8eclVHN&a91=uADU2|N[-*E-xv+P@9xHT7&'w$DxgfW?nOJ,2NFOCcY@7s24]*\",\n\t\t\t\",`HDkC$U.~U'arpO^7jRs]noo(UES(0LwSUbf@#+JSp0sfGq{*b@i`n}Rc|9>Bu>_NU>#_DG)%QYR^a`od5Ur|x8lyt&]Wc}f{b5}c7:nQdLrV.Dqy|XUCZlrgL-g6uyCW8pg2DC[0qxk0B'!tA)s[y_?}xR`VGm$0pPcPn}g[Q>oD5.\",\n\t\t\t\"*jji4DRB!hfp?ZuKi9k'ac`.p6,[NI[W#/?|N!'[kkltdB+{[9p^&~s7_[4^)[[|S.)s+Aou|O;yO&xEZD^)'U#A2F}V?iqsuurhiF.N!)7K!t@^-LGY_n2cxwvAT>q>>3go&'seAX~WI2)qxnX8n|}*:*Xb|)&mR<;RbxYd<}*fg47TZ\",\n\t\t\t\")9CRIedE3+m?Od0R1]irO:W=/#h7)Lh=~{KW0X0f^g9XrRAdlZ$z?Fc;x7j8Sd-2|g55F$;cXNhs/mw<s,TQDSeWsm33#3(R{,Ob8`2~@{k]$1Jwe-yT'`c&x3y(O-OmpGPhh^LrZS6j`?yx4~7T]vdtnje8zi{@=jd05}`Z>IkH'5kSKV\",\n\t\t\t\"(#HoN7l>L4n=^ANA(IaRW.G[)a~Ba;X,w{e8v8clkID!fYH+5{|xDSS$uC6syF88!9+a9ih_egHrdO@.;1*{d8^F:zB-99jpxCc@:X8GEVd*'&05V`~33r%m+bT'lN`G[k|`QHd|TZtk4GW^DBSQ7e}K0muStmgPPmt`.n}-|KkY03@5^2s\",\n\t\t\t\"'!^B^p',7STXpZVf!2wPNs!z53Tk_-^^pl8bur(,DSd-'NfF0GGO+'=a2*d#8-^Ja>&jO:J+tBeaIU&^5e^11z{f~{ytN6ul%t.p-3yu$VYB-tfY(/oPp9aH1j/L26}w{'{scAx]z8@zK7[E8yMBe(HyyAg!;ccXrY-_N'@a!(&L(Dnb/cTk\",\n\t\t\t\"&2pjLw&NC{giV*juxwZWN_}/[*!%Ti?4@;z]A[]Dpj9h%~qj1_jYBnxTzo*(yHv`SJ^O]gr5jV{)(e2zqQZ%:t-CG+(Yh5K,%+!AAf:ME/x#fovahf5<|:Fw<oGcpve8n:[p[sThf_RUs&f:y}s&3wq/gD./o>3xtwx!+ir<@IB.*~}m6WypV\",\n\t\t\t\"%Pd*8Gq8{;atxi@9$8q?&?f#T]yuZ@^,6'54subP_v/fw,i.Z0|wzZ0C>Kyi`Sc@w4kUsL^CAlKy-Jza<4?pk+XHykmfao.1jaLrNOiidfXW`_8'_xjQkzN1_rC`uJ/>xaq=>wTY7'HY4~2Z=_Cjmj$4EIKc4H:#w8[*CKrh]7C=.S`R;8jcH:\",\n\t\t\t\"$zY+<nWAv5i;5blo,oAh0F/w[:=L@%K1XC1Op3Li<aDJFGJQWPb8Pd35kPWnJjUL<|hoHVruU)5ikGU6/s*|o1<E4Co{yhRn*>[C1+$fD0@A:1Xw^.m}j3NJ+3vw;Z.`WIKy!ZUBTS>k(y5qJnaw0X.)d*=oAk{B{qJw.+10!m$m&4Al=A1f0h6\",\n\t\t\t\"$OHucOmzWj'k|Jum@9Mg64h49fO.<8K2<m;z`P';F50%ZrwSiHx2t1fS[/Vx'G~#]6GA%x`QVa6/'%boOHc2U+4kXCnB38j]ff&7PfpLTCa*EDDM[*)ry;]$,o~vrZz=bw}CYJE-~|}^ubb6O{~]k9dB5?uW^F&MIYW@lgQRYK*zVy(Ur}2n4vtV\",\n\t\t\t\"$,PB8I?Ky'%q[q^yot]_Sjm8Wem9n=BQ&e2OXz#}<O)5gpTR7fucCdbZ[yh6a&xJkk~&=V;4!Ug,>sKDH|YQ((c@x=U6i@i<'U3B6.HtIftpsNF:xp<luo!!'9k94a}G=fV?[h$lWDCO,o$A_eWM=;n#/Xz?=4K<2:[4n0miA1kDTcF;`JNr~tbOF\",\n\t\t\t\"#lOxX(0q*A!6x.j;!R'WxF3pC=Vx}q(RXzrm,&EyEr1C[a|l,QZKf|+OUBof`Viu]gl8VQn<AoNKCcc.k8N#rEuv.2_}on<_%s1=Co/<c>3t];!V{']M/*&jJRzd,?ZiD[x%.`[5>`SDpjK<WI?N}Mk)wf2=03N5q4'uc]xqVz/n~:L~GG#CjO=tjN\",\n\t\t\t\"#S@AU=fe$SHn]yzn6gqIfj('27i23vxet%fC4Fy/8('5p.1'RED9mctIV'Tm]2H0BA'wCtJza8k>&&JC67wZtn$O`4HNixlu9xHK.(z:4u'8bq>f@NUXG-fktAC,m[8^t1E=@58C5%_n}I#S2-C0:]*!fx^]k$=xGXaEyh7puIJVR*34^DXH(ArqLeJ\",\n\t\t\t\"#?-RrehybIle8R52XUN-S51F3S*IX;?(cBUR25Uv(_}JP{?OI:P~2L5>LNU-Lb8lqf~mpkvv/s[m7_L?ov5Xb.(7IMSaBF]Pm~Wy)+0k90csQ{URTd:%zd}wkT3W87xMd;zJNHBFHH4!^28nJW0l^t^57H5^o%0|{x63}4rm%'<6!=@)(kWl7oNm3Qa*\",\n\t\t\t\"#.2hWTPyqLPcf!YQV^I.ok9GxDNS#ENgo(8{r198n0M(gLp8wZ<-4F4[$mmI;vfrbKM?5pK8S]}6jV!a;ZQAEKo*SI;IOQ]M#-{.;=[Wsn?Df^,RUEX#IC6Q>[~UZono|L'B}Ux^meu(F6#oSkphejQU+q57hm(z}<s@oW$+VU5QBl6Rzu{zpc$B?HIc2\",\n\t\t\t\"|xQ<OktmmS8Ky.b)v<(=>^0Wm['.76wt>X`B?9)fuW0)JoDfwQzn(MAedlPn}ec'Ce:7a>3(6)6b+)SoL4&)trtualfml=v$6Q5lVbzlhb0k_f=oqfzI:7n5Qg|y58?mJ$.$r+{^1#+cDWS.xAd]Vi@>+##Bsm8n`3OZhV9wiRT(lpHgT9iqZ5#m,(=4{\",\n\t\t\t\"pv*~5&:|m~ss@H+X|H0h~{XZ'oe}VR1'N#q3fECr1p%l5&j7c(WgI8<TPL>0Y.X*P6(V{e4e-[;x,a/9).'tNQ]c;kbZyQ%kYH;(3CaS(rS4XT~/e$[x/~#mgDoxv55I@s?CEs`*^_^ZbY/G3zD.3SW]a_c?g,j}6~]5?9kg_K#~J7>L<z}i&|}v'Ns~AN\",\n\t\t\t\"fe`c<@@ER5E?wAhfkO3jAKY+$anJ4X4iu{h![)lqYWaK98]!ZrQ3w$5Z'e3$5O~c!S5sMta/lpI4&8G4.@DpF?inWC1dDbZn`=Bz$M!;|8G):_X:q,/`<THEO5oVfJAum6}lHQQH$Qy!BUHe~vSP7<C>x@ggqh~Sk5+BxKu5ASf(rr%ls8ZqR;J:MjpD,h6\",\n\t\t\t\"^)fTj5!q<yp).wIma11RS7,=?v1-]iV8-fvs0m+eBTCC8*h@;I-YEXC{o#gHkz@CEz2u6W~r^f9'Rm8*.+2OQZzpIUjO94@m<aJY`|~ynb$Pg.R/j+3,DnahKN!3FX1:v4lJp_X'<lp0a+G{Sc=Dz$)BWqF|W2vEJ)NJpTmvi[+pa;+)aF9rM*g)PO-WminN\",\n\t\t\t\"UevaP{tsZ_IsFO.O,DrTETjhFk[Wm@#Y!IL:5t/CJ+eq+HwWl-OYn1Yp8zF$cJbFVw(rVM6A6xm]~:#rxW;mW+z:!>bGh%#/#>ZFPr`6eKpF8l%*tBz&wG@|yVt-6LFUUS4JuE,o@9&hYOGjJ:+<&o>nW);'0BvR/iWa{'%a/8vU/=}t$%p2KBHBS_KjSy+m{\",\n\t\t\t\"OJ{`D$g@95?7dOu1+UxJKIgk:kRZ!I1jiWpANY{$[9.BWkzDVt<yHs?dT~p^m%U@]30Q$-K=&?+OcjxOA(?:`_C.LUElc$Xr75ZGBVUiG/)1nQW}?5cWds>+D'3E~zHE|.a&M#$F:/4Gwh3-y}IE]r@A@)%/:^=NpD^*H2|J@TL~@G)gbvDQKDv2lI!xa|,2Dk\",\n\t\t\t\"J($ts4G+1>s:%rtmu!H*(UG%HoXPAR0)(c(_mDXZW?c|1:i*0Vq!gS2c[8heGEh?-KbP[k:A=7Y<M:IG/-5F=[Z/s/;:tVgk?,$|mjYbv1fF/t[di::Kp%3}l%eC}F!RGzy/1BOwfTA#}?5$`|StC$^Jc{b(z~~ALPw/[~]WMXi+>F=3=,MXmBvf](f}cLPHp1o\",\n\t\t\t\"EJ}~.I!*LesVOH,}'d^+y`qqHU0B2?<MERaZ_{E=yP&9ZTn/lL'dpd%qR]gmH}&(Rmv#i7QjV'1PgKnddXjj%sb$e3d5a&llD]q.Tq-p%dOn@F&6+Mw/Z1zfjcs:}vW|&]9H'4A<qs;)62i77F$5O-)AB&<SXi]:Zo>[U#CyBl|gN?D|eR~VD2ZvGsOlJ.W((m]*\",\n\t\t\t\"ALzX&|aT.Dmt`:~9xe7&fBf0vx+D:ZKNp9l9s3B%96fh.IXnH~R'an0yT?8{cVUG>0XF[*O=;nr[N(,tpq3^H(Aq*!h6.5%%cySP?;?bY4nfEyJ+,=rd8?9Hj[Xde.|Q:;_VoTV<;ep'T5kX4z(,.Mq19>c@y4VB+`|$}TF3,}ythw$VqVpMZ%N1^o*H=BMmE}vz.\",\n\t\t\t\">$rw|!m?2><`[:&M2C~i(d+iZMYy<dI7Gv=qzvvp*'G:=TOy3Up]|&o;(sc,se!5o>^kT~a!HFGqZVOGonQ7G+)lIYGe9!ys=Y!X|GJ@([iWe'e.QQKs+V`:^Ip=W1.^~Wg?y3IR6YNWV:qU`a3naI-I9#LK*}Z&Et;$?H1fgIcYSl:pwa{8uo.[0$pL3n@<qanU}Z\",\n\t\t\t\";'3^il_9O)ZDc7b@u'P(0|&4WuNdD--=?b[GdoBj'qqswyT^oYv.`UmEkrBAEM0/[5q>6+,a0._sDs^;XCo/_JkgCae>]9E^kL4=#?6u}QLcBU/{s$VYuVK'jbCF&+JEO(a9.f!./=Ph5a2votzQj8|(KMg#bSQZdU*@eYem{leJ?kN8|$&xqTYg_vrZJ'::'Sk./;V\",\n\t\t\t\"8MZ?;{+LTa;B,{[N^tb=&K&xKbuz(>oY:Y<BZTIC]q@STh_a:_>V>x}bA~vEb4S4zw5+NYd@e@*e&Y^?NDbUGqb&4VYj!kLq!z,f[kb+h+a2WC#>Y1kRt0`!i|3A'Pvo:Q]O@(QYZ}/6no[T+rV'rx[(}cZholzWm|Ykw<&i,u>!DK=rKAa!}9c-C9OLb{ag4sPTfl*s\",\n\t\t\t\"66pK~$<x#nX}}G2ov/*D3nSu{O&'w[ZFY5x*{9$;'v/}Xxe|{#?hzRC;%-Gly58=@)%v@p#d&&gyd520|(?>-P3zl%HZol(aQGhI}>_qSWGlV(@'ZvweZd<TjH)ovAS;NBc?[P<YJXB1JFxJW!YbG:Xf)nO#I4|<i_8)e,#>z_riy,T#AW=j3)GUI*5!pT9;Gj{o<E7(k\",\n\t\t\t\"4:J?]u@Lll<=)L~k(&DLSSq+oVUGVl@]Upgd%0l@&Qy0w]2&*OrS,w*~B6O_F?PW.byYh'vU,&1bQMv^*Q}P7byDt-!F@Y%RTkj$4vv1+UZNui~~>nlyjPzdgbpr&}/kK/RTx7PMBbl6)~(,JhS}gu$&./z7d[0aa*!Z,J88am1FfYk[17~6l;6Se5y+#.k!}.Qgu)X]/V\",\n\t\t\t\"2T_]&ocY++_6VV{$.GzkrjbY1+F&}bWvhUAEYmSKj}}3{nvy8J&U7QAFeFgOONyG/id2%p^Oc[WLC9XteY~by)UK@X]1{=TdWoDxAUvDE(}T3-[(jEt:o`e^OkdZb3z20;$%4t;l1Zs87l+DOV+|IFMZ$+7|DqL(<s-POEg^]nSL`G)Re1t?(*#f6GlYf`)O^;mnG2@:f$:\",\n\t\t\t\"1&AaeWkkM6l0VZnBT7qOB)A$@*:T>KfPz6#*Kk[pOe7SU19>JLD0um!fmCwL'US+5[Ss=oW/BfNi;BTku??4Im]ip9n}~g2D(Dtg@=_.AMA-:|Y{&g}ZfdXe(5;`H//*Ns~ca3SUeOhz])%cbr]D-;qt19pyJYNTH6=vl[QX3*msbQNp!,gV=F:^m8KOz,jut_d#ViZHxE|6\",\n\t\t\t\"/enI@^+TreiDlM6uffShI7yAj.F?Ow+P',EXBy$^OF#Gom|V;~AkwQ0zKG!cTI%jP~#luZiKbLLQ|sG;?67y-@S;Ty9/;v'b+p4zu,P1LP[E%u4efl*I%iZMt#}U;S6$@(1=>h*imkBG2qdJ:pO+y(Q~.g|~+?FFe:`gVa~]NaFyC!eHkV3onN;L{Q#1ySeHB8pA@AWK?r~CV\",\n\t\t\t\".Un-RzOkdbH$-en3szwY~^Af?hTU)]iSk.4%F*@[*ldxO'/W6%nhDF2SPX^>[U`fn{y4MEMYOz:$PB6u';8T'*<L`*'c`,;!uJ`kb90#?|$hYmUJw#UdGgnfJ%!)H}mw76#*.)i,'scblCSMS:7b=uz={5)~Cr!N&T}L/.pMt!.Ji_+hIw4]iu{dqrhg@DV5/Ul]>#X=.]9FdF\",\n\t\t\t\"-SG;#)fjZ`(Enb}`}W*H/VxeQa7Rj~jTV^PP;O&Fw^'CBHG[JXYeYHZ+2l7;G/G0ct/klpDKpq|CcK5jd>f,y:g4TyAmIPJFh{x5+HT]1tKy*|vph2kMRx}ltKn'|@Xew!>/sE+k.a@e(hDOfe<%j],euH(/`inABzDnZF!dAJEmln.F_WJ'l-92?-|zgC,f<S0lgcxb^9E{2vN\",\n\t\t\t\",[yX){E~e9S4jvQT/~Aakj=uo/4@*gD3,V*D8ofysX1>Ae-xXq,}:rbT{,HTIo'ZMA&i_DpHO%Q&Q7>>xZQ*dTP2_`oXz0(cO$aM0d{jeNH.?(5F-sg7$9KRkFr)NgGC<3M`Jm(Xs&8]K^+9g^;jSj-Nx&dK|li!A73VXF;'6yLj_Mb8Gk-za{wT0MW0>&^BwqJ;qmQ)P?H)n1HJ\",\n\t\t\t\"+o#r6Pnw$cD996'^:%b$n&j,0M?G|GHN#y9(1k[niN.7ZpfH|<wMH*eU.N9R0(T95(7WaL#SfK^0n_c&k7#/X?+YFj|iv#^p61D[~(:`Q7kFu$?VIL7$knd(Hl`-qjyd{9`b?d(m$*Z.1z(e_v:UE%@qI#nj^R7%F[Vb6&h'=bPn%8TCgA;kuuIV&)~u'n7sC~KIG_XP,zOl3.%@*\",\n\t\t\t\"+,JO<qcGu5bN/#%H`j}_DKpe09'ECkP)/s@fqz4!]J#AX]&R8f=|/TKnL2#=XM[1YrBFU^E94/536qmN?ZE.[Dk4OVT,l.++@m+I5tT$nZpWbGo}$o8`0/*{>awt)US<.8{Junv/Ds8z:iZ|^q}S:CA[5,$<CjRW[y|cN9<oU]#&vG|hxvc;s:;FD_M2KWH,TkW'MZLn4?7Gb6TIc2\",\n\t\t\t\"*N1[!]mY?Jj#d`:'`9${KbD!(Pt7~jyE4/AT3y@eHG-:%kGs:Mj0J(k^Ua)YlmWR2B>vcUR)EL_ro]^uYOLVcGWe+4dp8ew(l'G6~5%5!D$5KPf,+k)/Y<%>#g-v=|*_x=^E}g{Us.'Ru5Rv7VYpB_K_j@[75!Mh+x,e`kO;PHk|X)e{//t6}<:CV{>`)Mu1fM_hj.$>5j|_Z#c)yq{\",\n\t\t\t\")w?e1OFY04O8C,8ulv*]M0'`67yRZ|AOqt!+o<2g6l-RZn6[Bm]%7{&%KH.>Y5&w0n*Kp*zJbY<]-xwLjA>nI7,TDj]Mp?Qt'wUz~0W*Qd_/SF'PMPdPa4WS2aL&MKrt2e$3NxEz{>V#ZwL5Zkg4b--jP0=o+ZIg8E/~B9~Fjv;8YIr!xWVN^9']ZH}FxlTAr|,0O!pw-7OeMMm:?/zN\",\n\t\t\t\")H.Y(S1~@HuNS/&&*qk1w{1V;{IsIcRDYDrx`BO0Fu?3C-!xR^uNLzpl~2UafSvwtQ7sy%RveJkiL*MMeJ6^mlGaShVj6J!_nt%<MURec4bvC^IuQA^v8Dl7Wr]t[bw?D8Nl{z:#Y#J|EuO-?MK'y/@w6S)MD9b@x$z3[o]?zvmv+=35RG%=?Mona((Ta%_Wc/QEx&>0wUIC->&T*hOd6\",\n\t\t\t\"({zdo_T@^?&st*6ZCH4F(nJ~oWkmJ/]-1$AMJ{W;y_xDV:GWu<M1Fss~3n=I<ng8gWsZzn:N3>ah*Z*(KSX67WiMz.(_4hg_f^^%3#9U.@'oFJ<4mk+2HHc&3TM|e'5NEd2=3U>-O{~EAV;RJ%ICi$~kQY8<PW|m$|IPl6vW0*H@~la5udc%'s^/t|0s[}^-q8o3UD'/qlVbnc4]!nLYQN\",\n\t\t\t\"(V4iSgme]A-r)`jW>0kIH_fM7&$}JM-_Kn/mM]Ov)k-Fq*e&ts=]j1Pb$lPO`sO-al2xp*8c*7o7#lEMS_cOUE_X=PL`/jsfLIwAn$wRfY5-n:fl,k:PR8hCrKw7BGgUc3J2plF6!dD[Duy][J0l8MSc^6q#[J##A8lQw9V5=U1#{+^+_UdoC5hM5;)o4{J>l%@wEa=;|e]aeWV<Ddttma{\",\n\t\t\t\"(5FP#L;TnJb)@wYlgh`V&UJ1pfDaVF?zL;Xo*ZfP@S$JSH_=.MWZYEKa-/!|PX`)C<3&}(7~HYu'mch`SaQCx?J(IEO)!<+,kK]8&ev/Y<^{97:aWI3|[y'>)nS4ir$WP](2de{wC>a$_n#mf}tj-'851_),l*ON:j.<{DqqL3acKw*P7!<@63)ek%=)%Jk8O(sd_7NV%-R0osNX,JY=>Tmk\",\n\t\t\t\"'u+diyQHDXQ$$dXf1h6%bbi}zKe1G|'1>lg5DU1{Sd1e-.a']0Fo0G0`+MS7BmEF&1ro?C|EM#)nI%v2<]r+8Wl_!OP2iPzXmhR;K6&P(n(9h$q|dWWY:{8'`B5wD?/?AP^nQo-`sg]-3*~;sK(;)x!lY4*5J$<HtCZ%Z`j6RE<A(wr5NAt4S(dJl@yh}B9k&GwA6LMJ/u{HfioiYFDVN^59o\",\n\t\t\t\"'Y{H>k77_<{*x>yk^IdL{APT8y#~[r`5~Jg1+o3p^$93<'L=iDf1J5n@e8?EzNR;>7D-P*?WL=i^=,,y$Ad0nHhB!]l#Od!''l{!./F,;KZ(G-Q[KUlPN>0Q-YQNU#.fm)M!S=f.qwL@XbV7e+[H6nTB{o+kq!LO'q2@j'n%X63:'AoY||~!2F4k%n(t'U8w]ivI@v,uAVAD@$H`{(9b6o@,]*\",\n\t\t\t\"'B^+L2*tNL3]Nhz?9dWv#IWwdUYujTZ6|@%rY}|6}k#iCD&PWuQI6v]J+2(mKP5zFAz9:4H@GRW%N>a=_lxM'$K;b[q8Pj9HDgQ`Y1KH0g;%K2`yUc+22jKDVDz]|}K-urG=IXP}2qQ5p-R+}AIX:|S8i7rA79D^{/v,|n!qTs|TNdY+0G1$KmZDCB:Vm%NtV(&;eJHF9bJiLignN-[0@]M5db.\",\n\t\t\t\"'-s0fO*o_?61-|:h;mfv:Em>%008;X5kh)xjpmK]@`p`qh_iPb%DcQSWDWZLlQ$=6[JM(Z.t+U%7mGVztM`Q7zCW0GRq`eQ0MP$5!m7thKT0;!=@RRTXq2~!'p%vEQCb!Mi}4QM`cCp;Wa]_1c_l!6H0l54z<*(:5'v0?+)0Se<8~@hW-3KUaer@0cgb&!Mye{:2:6|5@j(LwDM/cuK.vMITUqHZ\",\n\t\t\t\"&xGB9=4|u&BO]B7&R~^y.n#./!R%Xx.Z8yzDO]Uif%k%bBd|JJ8ML'b_&L4jekaLZrkA%lFtdty4,FZ2`V-Ub$KeJo6,.N$!4SW<K*}9E>>jWqq./@)Eqw^TWt<ic@mhQm9X/Kc*+yi!evriT{c0*A8P3'i6N$3C>2[j!S.#zJZi;1emv*jXh^T[yjyCK3;+Yb|0|4re'-HpZdsJ|)C{I'KTv^x+V\",\n\t\t\t\"&h%DhhZhb6@Ev#_3evf|V^yG.M_^y<3~5[JBD*sGnX:u9>qb}#L8-59V-Y]H*62;#TB_Xpul4.hu!cyNOjwyL`[L^A3)>K9V|3a~n)_GjQl;^h|tp)')R/;yr'rva/J/~-a>)kHUAW]:tqJ+u{qUKE#3d<A*aVWtuB2`KzK@ewYYlleW7JTd;eqmB8?,GDfrhV%|o]W$8a4`I>j$xjV5m(Jm2j,f!s\",\n\t\t\t\"&XWQd:?07/|#n2R_%sb9uEk)x^#GPt/M#%s-u1liz!<PXsXW0uuF~Pef2tc^nyN8Vg:/bu=N%&wsEH:_+q1j8oTd5aBeDtU}?wa)/fp[jLO7HB0Iex&ht;#*7$@z'4b3i'UnE5@kksu|ac}.n{ZuT~On,Y#t3bO@v.{teuiGgCDOVkBW*d;0(S/5}5~:tzR*BbHQLfD)YF9ITfc8t+GtMb(XiJWQdXk\",\n\t\t\t\"&Kt>R1iyl{Pe-xo>`%s8+*AuM]3_-S1^LlW}{PDMB#<#+q<E3t(sJ7+#g-).:;|Y)':lcB{C5lT%CvP^vm#rHj~8IlBe8A@,_D]pv`4Hf`rDr@@3h|@/~$*/&,PPaqVOb)=uLG>Q~Y0'#<e#OVID}ioWl#bEPy6e/MXb;toMQ@dhz'wi9)Xyq>JW#Ob]z=>cXNzFDw;5)aCo`oWJH)18!j[B(?M|w#KV\",\n\t\t\t\"&@m<3d~P~N_)x?M~JJ|F<gOgG[_R7l&`$MmdJ1_Zs5sGV@.+]iZFZml-UrV(lgLyTI5X1Ea6b!^)Y$L@>?kL*obXI1/UCRXbbGb6/|AeCbFYs>.&5DE[+jkdf6VAI6o#t[X:}{$x+O{@b.&-]j&Qb%kfYbd/>e'-x^l/2V_Ub.8Uqunjed`TWcMyvzSB<%oAFw9E3~)jQCG5K}3H4O+nM'U8=olN80[]:\",\n\t\t\t\"&77g_!J'DZOxTsR<MpgQ>c!C[DeWJQ7)~&j}ZUTl8^kAg-z~+[fIiM-#E_Doa$1blY2|avWsXD@dg&nwT')C'w]E_MH5o6VrA)@5t|FaYT/]^!FbFif;#<@w]1'w`7/0ePPy`-TqLQT!sa_F/!,d{xL(A(ZX.nItXk/mCpEe0UY8.2<76p1N0@ic#g.?P[rCe>)5_c1FnYc.>H&xV3z:_Qpv1]Wz>5P736\",\n\t\t\t\"&/(WDe4PS<6CY3wE;L@TG30Dz^28T?|K%fzH%u%+Cvhew`k70^]4bUUwLf37JL.jo5^q];5?/JkYX!]B3e4)5-R`p|*Zjh59k`:`Zvkt$5@zpd=(OV(E=HRK~&R(M}(M:JC*~gP9'|mq#D:_sawO0)uBk(_FmzEV']l?EKF(lqF}*'fU&QV9cdI2'+~Ql!U:`v@LCJ2bIg_d{.;|nQ>;&o1zuxb&,h110pV\",\n\t\t\t\"&(7*iQA{mRD@plNg/h$W{t?LBW$3FNAt&'-V1F~@2J<Y*WKEc0VE-JKdos<Y<,%B=.9_5p~hY6Mj4fG~N5NvkIZ6rMzWnUxmrclLBN&gdE`X.RmiHeuvE|IaFZ7iEeIaSu*r5WWMi#D$D@'[3U){`<A{zqXeA!PD~[on5'TRI^'D0ba|=%{t3Oc]PCBvaHQhqBdB)?W]D>wud9m}#M=!ntYT]>7t=LPp6hxF\",\n\t\t\t\"&!]tzv5c.`qp)4+]t4=0ut2?p<X,vU@8R~TX&9#L$Dvw(et!Mxvt_45*Dc1>}ZtDLBst8t|8-EOZt(oeicymv=U.YB}JOb/,sMy-m(z=nRw+mC#cr=])HS<{5z{ewB[FhoAfKB{IH8V@+-=nqTBEx=xUfqS;L4TKnKdg9TsrR2u&LU=$Njq>ZoP_'T!5QL$*h^C>K8t{Bf#wxTo.&24DJ$3sK0I:pZ()-6.%N\",\n\t\t\t\"%{8giEEItyyGh{>Jz7g#CZ&I>/nR{27=qWpD-=w_H:Qfv>$'x=z`Ga4-9zQzM[[)b/pFv%nl7Y@iVzrq<O?#%mTyYp-OW:AYudAM**9W]tN0qj%zw=,l&h$UaA~'Z5{k55C6q-a0cOT5M!l{;ON3&9,v(9lt`@T$iqa`T@gyjofT[=.t~'0aCGI(2isA:)^EU@u^tB1iI$Mr2GsVPXw.-+TV(3Am_[:e/07{,J\",\n\t\t\t\"%x!SSO+~//5`Q4|@j72YAhOb,eU/cj@$MP9?,TjF(;={.lKHq]1^#rvyH5QcuGFd+'Z5>+f6},iR3&`gBe?_1iikXz;:VB|$a1Av]a2vViLo~&Q_I;.n~0^<MY2'v#sKqxb8#kk{joFlMixtp^}s&ae*DgRf,?'VRYfc|#5:gXuZFA4qp6/:Fg8W~)6`.YWmqkelY,X?J4U{Y&.$=A>-y'v.;~_%}DNe#WJ-H}*\",\n\t\t\t\"%ut0`n5]=4(YL9xQIxIts8`F-2NC)$6s>pi<:ea}uKv:Z'&WDU@:'i*^!1.C*etp8x4:H'1Ukw-|jwwk(z@$&p$c4snB<N9gj5cP,3(f1.LfN&.e%c{g,CL8<3y_hx/ggVRFzo`l$?OavoBL[ilpq8%=AYw#i$@L1v@/s|u<wG>9W13E*&i-Ua&a*u}U>(4]K>,XbcMGR^6nM_c,5ece>AVx`.'A+1+}b*f6|Ec2\",\n\t\t\t\"%tqMbjP,)e(VFo~:jq?7)lauN9~?RucQ/VXA0lAPG%fjua)y6hq>,o0E%YcRdUfPwV@N,Cu#j9CbEQ]5jV}?+(P~oCOeE+js`t)Ltu43h,J~+Be[r3,{PjQ=bhzk<JUpNAWI+(L^Y)4@OSUd(hgpqXpHbb@qVLTWE<76`kFA!;?I'HpT>2M-f|y;uJ{a<M@8Z*fff}Vbi5X#d3Kq+H~mBt?uv`mx`?2Q8rLDtw4P{\",\n\t\t\t\"%tv;h1+|!@_Je-oSg89Dw@1@(&T9(}k{Y#}u5VIq^e.E!'lxwP9_NH7NyVS#`co}Vp{{F<:LhXN7Y|j&APt7xi_J%{PYb;<,{B6%M9}lC=hW[o)zT40MmZlR^}!ekBy*iuL+B#,51-';v3YAaz`S/v*UDtB<nir)C#}GIG2g<i}E4x&!cx,&,BMAa{uh`h2MQc;(S]:{]N}e5zmfxngL4YJ0?D=K|gZ50{U|y.;>UN\",\n\t\t\t\"%v%;KXf~<;aM<6CI,N#:Ypv5h4DdU5uX.yQW+K$[}^LyjB~7_gNgyNS{M-%@&<!@I!eQJ<<2r!C&=|t[44f)IxiS7+=)QS]XOm#P7cy1|`{]`1-Y3e#l2m0L;8KN.$V]'T&XN%DYEPG_=E/3=s*ZA'Q2e%`.KUaeNH?Y=ML;hG&1,h?)zFO]_B'ouAz;_(<GsmipHNwF)@'WORd<&baV^d(=rU5X??^ndw^}7)&5o`6\",\n\t\t\t\"%x9'{X)y#eZ6*Nm)7$;^%f!~VF]w-3T1+|A`u_oL4M9?eB-qEMLu[IgLnXqPw,]k3%<S`>03nP<.4x-VxN0jZ@mlcX'WI^?BX!MPHtn-PYX&bZmlAIeCS}EsyUZBItOfmBZp&UC6?;_g)571xUkhVl=<RMXC](8B/m(3F81Y}&[D8d$_J:?(Os7ZRHu7m-k-89UJVn'8~6BJ*1s[uy{zY7{a[!7=El3FHK58ly]OLJ5N\",\n\t\t\t\"%{V/DZIv*!rN5JB$p=z1>_uL!jC_CTz_skqo(6o#yHa0${3uU_5_c_bK.7{/PI*~h;WQ|!%#WcS++vn@y1<;,3f5[#zOYM2-A2n80XQl[>e&7yPCvV;L~YV,L30D'AIaVq&Qc'*:}(-%.FPbi.C6:,aihL9xlGng8yLu#eC^x_sj{5`F*N4]3[X!td(fpakTOwtzvu/otDIHIO0,+yn;5YnP8Q2&O2$N@mkE7:bqyWbT{\",\n\t\t\t\"&#!y>t~PAqR.V%|i~`K=C`P;mtyU#PR!%n1Oli~bOm!)r*hAnb;bRgK%<dK'*&Ikf_etTiJ.Yk,,6AfNm_1_VYGmKP!K=D|%%bOan0S9sTm~4<'jcWo>>g^^VX/&KUzVt&S?S_'nkk{$XraA:IEORO5lOPAcE*)K~<<|DJ:E~6fdk>J-!>Z5sFw1}%/_tRZg/.Xzr:Z+R,XTfXBOb8yhex@rPct$)kWn+TkR#(y~d@2p8k\",\n\t\t\t\"&(Zmm.72gip[0d;F(1gqQybOtV=ke4qb7qaMX1p#}WQ]`>y9[t*PPHw`eNOVOI7Haatl)A=D+khBJ>)@s.kyCtaWrrM8#801>!e(;2$.a(w(!$6$C>*H`iYYEr*!gQ,gXI4DJ8LpK}Ui8EjWl9kL%3dr#UZ8c<>-OZpxZ6C]Kh}~nv_Uy_z'Au(kC8v}8q_tA0bL@W@/m&p(u#;eGw>R14K7ZdlLP_HZ*Q.H6%Z''2.edAo\",\n\t\t\t\"&/J.Nt;:aH/>idWpCdRYg2wCIBkaUcRTQnF/g=.{Y9GK23l3Eo9pu!:1^)Jx>2z?a5fDS|>Mn|R@*F-ZL,^3tRe2=@0t_D4;XHhzwC_I9$,D~&~)ikBgc[fxH>lHQ9^]al!XT%h&klWmyn+v=zrt)Ky6W,xrc)dTbG!/`Mz%(bG_klTcSE}?XiMx96c[8){-jb%i<CfyG,xkvc6X*j6prsy7cT1W<<P@IDO]xy=q>E`C$,]*\",\n\t\t\t\"&7R@4`hqsgPzRn5o=?!)eD'HaSl&/Og$X&W3<aoO6YhzAib?{}pC)'%hJeSmODCG7@`i?z&`|=#_QyLy.A5%#KP5$s3Cf0pY>MfYp3^AH{R}h]-X)P.I+kv4Zit7l/E4>dD(c7m+:lx6]cc,IWXz<85V8M/L%=].{ob9`jD]=RG=+<.Mro,t%33iif.FGt|:,6-]YHCBY.f>DWmd8;u0%+!'ti`)>oyIj%UJn]}C6.1wK}jI.\",\n\t\t\t\"&@zz+v,sQig,mt`fm(,1!B=M'r5&_J6RvjElE4!+XZsF|-qK(E0|si*lS;~r0iN8rY[w7CZO}B+;Cke7Z$il.f2{I,MDC#R}BuM,z`h5!&D*v`{}S5OK$8F^NqwXI4sCOYjIjW=)E3<AEXVJpno&wc1RcQfoR_X4K7|S([(~h<:b=TyKHT~vuB0P^dGNpz-;oSDF.R*0Vp>8Ws'OH%]0^-pUVp'NpA)/Gfx-;R/Ko'bY){=*qZ\",\n\t\t\t\"&KmjIGZ}T`V7=r'0bi}T]>`>$]%Egsbu[Z6VW7hkWYL/>mX!5x-sR+0HDkWp^L/K`:>-aJJ[=^%$<BZ7:wT+%q85dgb>&v@muDy4TZa7Mw^[H!];dZR=)dj6k$@D#43dpTOjR2LT|'=4WBqQ<4(*s@C7u=Q|?7VaWO3`E*fp!22k-%}.AW)aBPi?wlLgdiN.}Qv8>p!V]zw~=T{y`m,P0^iH2,!Re[u/iN/{cfLJN]*1n8~UsxV\",\n\t\t\t\"&X3z%oAU7C/(l+}kOFxyw<;,UVAlqDmb%YrwLZliJN?_T.NcGx?Zz>d}OCR+h-KNs[Eo(LTUxQpH|EzVy#t$fSRACzX}OLDMg9<RmN]X%uhvJ`H|`:_A6B+ts9~5~j`.Ja%L|W694xWJ9529FLN(@BK*hu4:L-0x^[[xzgOgxZ(:[B@[Ix0z@u>?wXu#9#g!f~%&u8G~A^34{b*xI4g^H'v[LIHZVJ0WvEg^0?!#AtL%@niuNJws\",\n\t\t\t\"&g6(*iJ8SU1zWu=^eBWM3]LnnE_{L;-[/]ZhsTTn1]pCEP`k,P25T6W6]X;zSB}j);xo[pLN)MR~R^1;XqUr_??:Lf#:yFneG[w:*@38fx$CJ`jR>bXP9x*Xu:Nz84_j][&'<msmLBzap+U4@<_Dyq3N~EK.I9pTe)9[v:6]laEr@K$t_xk0!`Q&=0/:3p?O9z6ZNg'Gmyw]qC!,atvI;GwQU#hjI!LAOgh'0<TKjk;bZh<h$~0,k\",\n\t\t\t\"&w#ExlgoO#qZ6lAsSt:7yv^8`Dx'F+l*!(m4+|TQ:3ez^j1f+l8,]{nUFFC[;DOc/Y>Thu9*6!E?rDJ+&4ez?FC9oBs71Q6s6piMuEt+y5QJPE?gQ?D&~PaJ[,Y+N=Sj_8?+o0g@*cxp`/%7Dxw5oPEYkMGcw}6a9)k5:7cbBAbahP+u^k5A=auzg#>u0^#B`WciaGQaR:LqUN8y@]+T'b5J|4ZAYW%ud_W7a+ZmWG`0CZA*gvD*hV\",\n\t\t\t\"'+g!]HA8.`yy,}<.C4SAm?vgFDY5FOomR6S~SaYiu(mSMAk0c=SrD&b&>E9k=v^d=}Z-Y0z6W]af8F9pCM>{XdtXi#1@?n;~*.@B!zShx+/WsV[IQ'4b<Ib/>>$jJs+^EPej/U]eM!xRX~+}af1oKY3n1<dEliNH%Z=,)jzI~636FM5dS[e@&7L=uu)onr;z|A,zn*|+4tjn2tubaM(h{ZzNvY~(S%:&0CgN^xZ#K<:q;q,F!D-OF8:\",\n\t\t\t\"'?V'UGGP|}`ZxXn=MOkdzNC&k/}je0e9*(y}_n:~j_;=FKfnt6u4h}QXnmZaM&QZ,gr4Zc/PDLJDbali#.Knq+}rf/)gA}$+psUEqrl`{jqksv*1H0V$fLSRW-]LGRn*hkUbamc5FS9l(ns!'eG8_D+NX}jz?}yW?Ixy#=?=pZ^1Ts]*Gf*Fg7&k:p~+U;Xaso^n?`>t^aj[EZ]9x`;Y<(U&3zvk.}HPLK]So:ouQHg6v5|JrO}dKaG6\",\n\t\t\t\"'Uc#?%n>|8i't.1^>RSl,1>(n;YL7p+V|agbq]<3Lzz/>Nlif5ULaPS/zsfH@)@+{N/h+q@+mOBW9'J)<)iOyS+u`!mPW?hNkschD7EraAZYb!T6ab|P4hP~mQBlzl_ufaG^8#Y{$Hu=a1?`(zfa6Pl:O;A:;)duA`r*a(Vu,z3Z.w|A;tIP18>YrYeCxJbB*Id^NrRE&J14aZ@Fpk7FH(-{3STL=#K(,)wv-MY;E2@^Rk{^,_ymI*H?V\",\n\t\t\t\"'oBzev'qdA])6$DzD~H]@XE/oCQ!)n*?knyKAzGs|LUg$)6L/>ctZ,YPPE_d5$S-8w2dzUZ)<~Js%w%+S[SRuFjkPXh(uO`BkzE)}+uFTKl6z5+4}/r(KaFmMU*IAoY&oH>A~(w9yn|4poCi0y,LKewKX~ZpX4]5r*o+NTUwiVBwWeb+uuBdM(kh%Lq#(#Y8.j`|.xCY{@Lv[{G<|2x&eqz~j_d`TE|1g~@7gAWd6'TFO][}C~~pG6lj/F\",\n\t\t\t\"(-myEJBheWd$M:Qea89c^S@KCJu-cBC)s1'<^-a2L3,2-GKrbO$.zDhVldQt(9K.YVCMux{-2W.CO*Z-(`]l:3(xmpmBcY#+y'Bxqwtg#bh4Jev*xCV4a0gIL#(<K`3]-.?E:eDCwD8mL2#+!&^bddW0)vEFgS::YT|<z1,y*cu!Sm/K&-afW=N?./t`ew@:uR~L?D+<,_EeNrNA(>1<02KFEKb]5p&<2kT'dsZHJ:U+N:{1EY`kQ{2-f1N\",\n\t\t\t\"(LCHV$f<zGDO-wbl4E0M`_mJP_lh;8>yg#KdAosur!XxkPx(lA,';eXc#EjK,_unyz'|7=$?%@o{R8l{<gL*i](dB/3gK+3?W'X|j`{j,0jZviwjs9-<NC!{hXgqL*NHZ(6k+Q6V&v7:s7~}P{Yr'qK:~>M9@;L--a|_rhB=}kk=B6;7LRm&*:a$T>[6k8|AvhsF-Xd*[+7b($1FG;tD=g`nVrQ1h;GysC4<E17+>^2^[#'Hs+1YQB)*qomJ\",\n\t\t\t\"(oAdE+GLv>6~=l_*8JYlzkp/w$,a`i'8B^m5DGFHs]<e6l{Ek<j-soK>.ulcml,I*ad?:2,H&nn@']+Fs8-RsO:'0%8la`w'W){an/[t5smfrRY']J%7E6+]f.[ijXOq;!_'E{GckyEP:/x'oWtIDd|cM6%rL{6T^q`dvH:H.B,#J~e$aDkT^Enyrv7!rAO07_9,_f%mb,kfU{/X-5rt`)r1q/`az|[7Zl-Sy2(g_t!Oddv4.@dtw<_E(=a]*\",\n\t\t\t\")8/U6{fR)$.p*i7Jpoig::%Lgbjhc%ItuuumWH{Rgpq0,]'FJH)GxuB:kxv2AeJ[1<%t=ef|`L}r35#[Tk-Z-%D}Bf/ihkH}?uE{zG`UDH-Qh`,AW+ktq`:iz2bCLWrv,ua*|7?Bv!BPv=w[mC^lfU};RTY+EW45@O]1wLD3[jw/!,bnv~.()%9O5>K?0^quTs:{^yD{hF1qr98sgs;I.qST5w]BK>f(d7t3Q%DX~CB.P<E6E3{/Jf!S,x==c2\",\n\t\t\t\")c5ji)&<7G8&W07Q7ywkLV6ddadrpgD|kk?:-N3j&=f@2C%_X:Nh0U~3Tx0LC;=3-t&QRKKwIN2CB4;}HapMEN,eoB:-;AyWBY<f8+&=Imz&'G0H)=R)z^c`9VL;[tn7THS%I=hl%J;-Az^8.23qgx)h{*hA2G,-Gr1z:X%V%SRtcSG!=:y~wipa9Sa9LL,Py^U_Am(>-rRow/Wf%rDB=vRe*%TJS&0tT>L&-[f&?..1G%995'Q?$ayhv34A(0{\",\n\t\t\t\"*5'%u}Aquvq9uA$XT&'3yO?hMF#+vClkz6+mYSK~.<gKdBNfpE/H/>+Mo#&Kiuj~lX':Hm~:^t]jc.2Lk8q(1,uR,gelMoKxkMkx6xLe:J8;W<[.8M06<E[,h*kT5>8@45%{tx5@~I#JMt:H`Am^)|B4xTpXfY<gx2x2OP%g6ct73#<h|DFbIr=f1mruWtZF=?8xq}aP[+()c-EH#7H.WN%%6RYHpJ9-2n'X=(_0o#;sbfsvt*}CZd4cj)ze/M1N\",\n\t\t\t\"*j8fYqG8>]b'!FpVzsCwfxV&Xx|y)0x$Z_W`=vdj|}!n]-A&B3)FkXp=Olvdr|,w!(':$*E?1J#w&hlssJG[=Hj.h[?wbD*o/]a?;|)VI7Co){'?OVqcR%M/;?j=UVa%y=2^i4~?^LmGv7pT#{GB,a^rr{&5LF/'}b/d&`c3SAn0sfF]%H6v<)rzUAgOHu=TRqp)3Q%txW3-|J4{U@z#hzL]?QC81S?=GN7Iw5`jGgs9N<J&K,QEZ^+z}r5gLS-[6\",\n\t\t\t\"+GL#RG:_9-*4VHCz+3-v@d|4}]Q(2C|^;{3EhQV*P9`VgI+=wF5lzC%tTtAI;:nr{{N8Fa;Vy?.>5dI'}!$>t&[6>!jZ2`oI06za6='@0[($>!+t53mXfmIi2w}l]gA-(X']HlpH8wz-CCL|c}wu`qd/E8h+ZL`%;-.l]gLg2tzG1EsFm$4rW'U{b3ZZwR:*?adn`tOvcu{31hF9W%Ioh?Y+M'[tc|]zp%A!r@A9Izx<k2jE-u6oj%8YlwJhneH:vN\",\n\t\t\t\",,K%#wHw(_3!=0/]*@_w4#ZZM:#Uc/B5.MB%ph}6W(tl]4D|[<jQ&<[_8pf|?S/Tn&=sQ#1xS@2A^bt:IIvdo*pRACAj)Y2(&@OQQ6*CFI,yc}]gwOT__iU{qY(IA{p<<KdRNxubHz>pI6/5c%PuVQ7;q9fldg+!`*D,qR{mPFRK+qyE{f,l739/zxocNS_x'ZTT0[sRv)K>n4.jONe}tO4u|'z+(Qd3g]Q?a+4IK?]%bQ'yrTV?Bc2iv:>unD9`gH{\",\n\t\t\t\",v*ASLj[c=7,Eg[R+L2M9fke#p3uXw[p>$X9j}ugwtRG>p_/_6ej|[V7lMj+GUfzca1F6t_,^P#i:P:Kdq]yMHWiE?$$G4&F9nG65{+.efvZ_I$dH4_}hn@{|0Vfs^ZmjNG0BpL/!hgDn]mGk'Um]H.9j?1&['3)uaN|cO!Vk[o6)FC]b/QLWTn:[uh`th6Ou{SS~$Qnp`#!9@Y6,MsT@2J*.j1YUl'}'7@d_pX64R*had%Z/;7'pqJ!EN}iNC@{A%ak\",\n\t\t\t\"-kFXt|5NetdlWQ!fj*)(BM>TKQdbDM]5#!v>2(C1'jUtXGb`[WF}n2D%KFW&WR2z!*<qtKcXTvOA6@bk41B0dBk[S(`G9i-]OvF9*_cM{1s$g^xUE(1tAYi<(qi8^{.GB[-^Vz1{7K9OKDhWPvn.!eEWv^18u/D!;<dfbUu;J$rS%~-L=+e0LlCcg,bs;T0t{fsyh0.gzX(&,dF4LW6&.'FHr*tI~-1xTr,xfJ|/Ye0mu+$2g4y}z,AIpG=:8f]vC|AIo\",\n\t\t\t\".jRPe)Ixz3EFION-8<10CQch}[N*i^ySd#J%kqc|E@`eeS/6pv6|DBPsCgGkK[nhs~j*-M6<}_*^e'276|^Njk0kz:^}(^a|#>T}R/W6H-7MTij%Y.|:ak0f.60.=[#CAD|P64=s,EqD@Qo6;v-5U=AzEZ42z5xv~4-oP8rubB~Yj'd0`$`Ex`t%h&E/Qyl`k3v-n9y,'nanhBImM_,'&ot8M!Njr#E2Wx|YOm;cgTk)]b,He^1#~138yduJ(UY}%e8m]*\",\n\t\t\t\"/tn25c-piMHQGKWi*N0_3[IS~gmOWriMZmoi5jIJJbEtorn!P(A|6-TW^?1t?Kn>h:-V})$E+,KAZuKfvjb7oC'R#V:Hb^+~^/#$>pNjsI.@ez*DIs{6=7Nl-nW&-Jn}<f3agKRHjW9v?&c$D.@n(}M)lrZ%8fb[Vj>|eF&uL@P,psv1/lTROF/$qZ69:0kxn7T(Xh@Ws(D'-q,Ifq>.#`0h6~NZX]6;$-ulg9N!<<Y4f.1Z|B!f.Srsep&+J}24[2Ek+1.\",\n\t\t\t\"1.mo;$(!s'[%;&&<-t2?J%I3n`QizhNX8}+A2xe#hScJ<C-bq(X'+>A3lt>%{AV@p7{WNHdbwSf<LOiPGbohO%GUdmZ_'[TNr4wLFzpw|5c8aH]Oqjq/1wz4x6(wr-7yXWsKZAT@ijZdK<`HWd>(q+Jm:YH9EaH~TQH5}_I2w|QH%EgKUEPZ4vDs$?;9&a0'DxqdGn5=`d`0[wdrFjr/Z[]OQCn~q<#dZbhlul!|w-E8G&oBY<6fIh;0{|y.@G@O0qqFt=<Z\",\n\t\t\t\"2T>'F|mIV/wuwiD%w`V;mBjqFRQY)$wY`]UPanj#%Q~1$<i$KZv#y,i}Ixg3M?HnrBA2Mi%H&p@MQFS0juO}R|)IGz8!t'6ugd97FonE7dS.e`Bz7[#D)@+G(OW4]2J!ZG[/H*Jy_R|M[`w[7=~Blk_GH4gdj<!W#iAyQ3rJB[$1+9B:>r!}S;8i>`alHDFk.5hfSKu0{_fE(Wdif^wCnLHX5[GbS<EqKEq7C(EbBqH)G`;a37;5V^5G7^={n==4;d+O`*!hV\",\n\t\t\t\"4.C_<}34U0YZH_VxuULz|X_HvpkdRsWZunf8'X+o[_QWB!o~e<^Iv]-k`voq$@dR2@0UE@tACr0lll$.Q6,*N4TsH~/W-g@D!M#'_FEj)D&l[/Y&lIglsR)9Nguhed_W3UH.ogHA-9g.r<JG[M9v[9[OX/qJMoWXYgVw)m$RaW|b,/0Ds#3$B|'<vc&lX:2@WW#.>O|EhF4]B;5c0kL&zlG)70zRi.63uaD-urd$|v^qc(GCI6v7y(?9,TSZoZ7L8H~(b-{yos\",\n\t\t\t\"5xG/e&BMWR~Wx$Z;{Z:;UFO[lJb$oB-#1b~!Oz_sg:I/8ccc(#d1i<?]FJHC9_!O^6>+OUpa%]#tq.MemuYBY3+r=Asg5bMfs1>z<JkATw!jJ)NF-hR0#Rq?Og}7M=)cw~0,`F$Y5Yjca|^VsjB1iG<.]}meEn5+Q+Pi%0'Qg6r*>V?%d51@26I$*g9G-;P.PCzn@JX`|yPOL9MH_ysB2Qh^A@<{LkeoM4#77DhAm[8:P1=^:h:w1/,-z_B-$+D=e~/RhUO7T]k\",\n\t\t\t\"7{64bEI7YSYXC'5O>.5j.mha3?mp@Ov(+TLg8gy7un.uINhD{qy9h&,9KYOr_HdOaBb7;Hxd?LP<n0h15;|}ax1{Eh0u3R?VlJ;8lFV-r&h3%kb0<hp*Ck`$eF1%Xr|GeF5L~N`**MTQ:<9$eVtvMkr65mH=MD!E<]`c8,E$Rn'OQ6b']#3i:msPo(6:$'c|V$'FoSR)oRe2Cx28gI,tj^3u<Bs15FXyE@V4i/7NgXeTC.}r@3TP>#n5:h3-Ov!Gb.xhbf6Mks'V\",\n\t\t\t\"::)$OcnfBSmn@7IU`'1S1-O_}5I.[aimA~U#bp$aPkLT;)_A|[]aCP]=2<O2E%>+2T;Oc59@AlqJW=*Ci:U!+*>Ec1#63#ab}gm_<3e<v!:Jsw:b00gV1S'/juk8+^E`mAUzo>pB>L-WG>:AM%@-_(3|K0S;4oELKfJu#R_n*wG'Z3}wT`p/Fe-:J&'5C_viFg}VHGu2SRF{'SOT+LPJ/6/8t@gstm|wd-_Uw8;&%0}~8o,mXzw*uc$$<es8NN6AjdAHZIB{r?$q:\",\n\t\t\t\"<sk#T>!Lc(Le<:Zr3UX9DGr_2NgsDA*jTPl%,?vr]o(GaKf*$wt8'fPWNZ~](-9ncVirxqMmdi%<a}WP[uK}.xD.33Br0=Mj~zL3f8}j`ze4YOd7_k^e7eO_,Ud_)C4)wAopNr/S+>5{^9./T]![<5]78a>%Sln>6}c+y$jr-2`w'0,)[0+B[@?$VU7c-#!;w]vk5!QiJUNq3)c*t?NUw-qx)BY3*adv.2L|C'q!Jr8vF$m5}WC9%-4HE^v6e12?[U_5S0[YaRjf[6\",\n\t\t\t\"?qkr{PTow/L,sEA^vB+V3:a3t_:mpOt#cuHI#M3@Xx8~b0)A(fHZ/A%z}Ez?w(=eYp$J$dMy{I!ku&M@M2.v7pM=Lq-(L3s9Oe?frFXE=kRu*|/@TV,TiGk!`H|uhSZRB&GMh!;LuCk$el13F`8{]{El2TGk=9.=wWRbcNGK72D*<g([=k&CmzD=R;]2M8{&P|e#G,QT'br{+|xb8vB;+o[&9xVA/;sX9}FoAym4D3@0Q3_t1J*u(.z2<=$xAzdore6IZKc9A%3^hlV\",\n\t\t\t\"C9?Mqu0}qGQW~y.d#FdZhCocB.I^5~G`5v`F|8@d.O[wzKy>N*)'q_%-Pm|f_k%bp*/ItL8=8z|gN><hWWl&hgaYUp:#qI+P([}>T1<Noiw>X|rB6x92dK(4S_p%msE/L&oygwV2e.fYo[?WiE}goNu`{OuP80IE7!1r^iF?4=S(Kq=8??pjsGHj3=f=N}vaLh`;~5ll;y3B,Ae`q%E]S$V`V2R>yk6Pp]b'd!juqA@1Ut8m0e_&Kh?fibHL^,59VKm`{R^h-%.N}JCF\",\n\t\t\t\"G.N|9^}I;^ww7GkTa=EsSD7x@1@gE!h=K{8Jw'$I5O,z?]C0&dGv}HJ]NA!)XYH|vb`hz'1Sd`n&yk@TU{YJsE,/)ltz6ad+-lEP[V`}snyV{a(FT>`M,X^+0o$Y0UxwM1`r%PkrlrjZb3>W>[lNqIDqokzSaN<=D/;<qW7?@9PZ+?McX{!{WJi6CkNgx.lQ!/&ZNFc~/FT1a?W_')mi0;Aad8BfDzXMuZyOr.<{P{29?uzNd9HDPl+j-4[h)fnk&yRU9(?J46Q25e}=N\",\n\t\t\t\"KWOC(Q}p68l~},uN_Z,:9X$D,<^'IH?gCGQ<I$RU,pi]~w/`0AS>J+gGprGN,i;b=_p)of(ho6JYeNPX!,s'p0*wZ}'w]rRGYH!G?S,uE;Uj8|9'dv0'YJTW^0SO4WAkPt6LJ^nJ+6fP$}o8=9Or>@e;snzndN3C*%#?u%Hm]'J$KEX0|`TUe}*z|ifD(Q,p8E~YW*6F!G-z!0Dc&z2#h`qSD]&;p@Eu{wr)goY30hwVq&3Ba?l(#h&>7U<6Mv8:^iK-`p@FVb*sMpGlPJ\",\n\t\t\t\"Pam?dqbl#gMC2O0PRE)jwm!cA<rt(5<_5C+qcU{?B)kuH|2~4?zz{C~h_0FGsO'w9Gf_@C+~;98PqM_5!e_V&]&:;sNR<'K>nf1%E^K{[^vB}Ci@|I+.Xlk^XzcBt5t|@Xhu'I!f9(9CZy$9B(gj`%]92~HUzg-^$1g-~AEJ(hx]UCCi>xC;D1p2;^isxQ]0u'a*&yW.Iyc2D}{H4(N;C|59^AB%:^8p6%>95-*o,tAn.XZ.XaWi,Ekw;Qkh{<tTqq0=>#q+;8z4lomkm<*\",\n\t\t\t\"VTIn9(r?$7Xx)1;w]2Jb?Slq:dcYABtAriKzhi*Y<EeU$d,W90ll?UC&x%F#O}<APi%7zTX}~W_w@D=2.8(G}e<|5LwDBqUv6Wz^]iP)JAi5I-!P9+,X810i.J%E)x:P%qBuNp(2B6J'A8u5?S#C+_}N>toa}ZjHW~i&a4Bsp@`b*4X=rkF?YC!r-WownGVl.Kd=4lx7=C1MwOa,.yYl<j'Y]EoV*2v#H0cuU`Z#;_LB_{%;<WX%<{EO[QI3{NL8b/dqMAEphBPdT{$N.1c2\",\n\t\t\t\"^>3@osGB*<Q1%xC[$AZQazOp@SZS&mh!vvaY%?dmK}]]43CG~<|]4QyRDZ|31myYfNpG.^9HhG4b*n1I~@Vd..-3a=NFr)]$QVfwsCpo!hb+.;tf9gu&b#Vn!$}swDZt@h&Ln1$/d&K_Y{;tKTLWU=v~h1Q5C%v,I_R(tpB'yZIpZ<4gbP;^&+=]w@M-RQ/V5G6'&KHM0x0=Lw:`aNS4z6:cT!t5(]O:l2{mZo89YCupkhyr8rY/w6(*~csA0dCto()kmu*AC?p0W&aj:.Sm{\",\n\t\t\t\"f,(mTM@22om}$P=dD^rB=|x8)T,_#?IME~?~0C*/&G=%e]2aH5;OTlvL~f$=]h;6V&+<_'W(O`LWn/%wX7B;'|GU]iO3V9(nIp2FE[Ni3d`1{8a<0C6eA;k.XWGTn,!3qc%O6fPUI!A}lI;(6j-/3f[(IDT98mM?x-|H6n'RBR0j_yaTw@Mkuiz:'7:||5ECcA0k2|Y~bozU%6Y9?<RBw%'gbcem)]'?1~.BBs4ilD2+TmuX*~OU&^x5R::.-bb{IVx{(>x32W@U~!zte1?[jN\",\n\t\t\t\"o.cIxaY%Rknl|fLYe4WPx'-hAh*V/xu+)mgJtN.c2<U5FamI2>9GR_H9-.<8gso^VPZu?dPKiZh?H42}_@D^byW,d4pOG=>=Aq070N:<PSQ0Lkm;a;/d0hA/j|_6a<Wc[gck&rrG/|3_KB:y><D`MaXh:`b5xCn+9YDHDfRb6i7?zkOnzt`~}Mh8iNS)XN:b_d9)#m(iI2e68*wfP.'{wMR;sVso;9|qU2Z8'UCq[aZC0}$#n8kwI+!=r_'ILVk{)+%P[[9)a06NC`D`7P$ODW6\",\n\t\t\t\"yYmu)SNT]3WoS2z&m5gBK5[BTU@?BU/4m'yyHpN&SOOlQjDf7T!0og);75[QD9jYaBC%Lp_U|dXTel*sx#j4d`x/{1+1hXLc&<jd^1dDGOL~wJc]|H)McQ566D7FfdNwQTN@O2ivT%OE-D~@q</zrOKW(.Yo=}o+.5Ht%muHo:#j'R7y#5v}`1yc3b)`IrD)jZrGYLMMu4P/[z;As{iSo$srxm(RH]_U~3mK46xw>++m_s*JTWr|K%(7,1)JaYoC5>XFrDCgW_8$!xd+M7$Fy+YN\",\n\t\t\t\"#(ixw}il[2!tw^QFME&fy19P?|Fl:`ro>CfGn>8fL|j%onSR[z=b2P*W|Sp.^L5AO5r^QwX.IjSCGw/a<_M+wOIb+cOn^5C;wS}ufT%w1@W#k|?O_d;s';6bX[y;6-RUOX?DUHz5i^/)w(j;/qAf]O)uwUChhn0My}G;s{Ky&|$?B$o%i(P-@ICzlL]X)1xPniOG.imT0UK)3_]elWQR^G=tbVrK+Mzt7a:#SvXZm>fm>S%+ltYg}agv;zc/16=(v%&ew)qQD9gf0rGN<w$@4cl|<{\",\n\t\t\t\"#6y-R`Z(6vm#BS|MQc^96=^J#0dQaS9MT>M}%g`{SLgh7Xkv>m(oz?UPFHL-$yl(%@<q]I;p~xm?Db2{Ea@hE1wOg#03(JgtjP(n6Ed]Oq4x_K8ys?69wY6Z0juzB%U?=OI<&HE)`U]RRib/f#0hd!sdH=d(%-bg=tMz9qIMvk@@@Eij18M#C&~ogwX)Q}P.#HeCfCR;&o8dIIf,_]=;1y/S?oYwo6`EO{358!`&#.ld=%=]a4Z<0TdleIs?x|AIz*LX/nS~5n|%<%@NK~RoZN!E0,k\",\n\t\t\t\"#GLyddH[O!u?{)K0R67YGycsb&dXoVMf)l7^]Vy(k@0`7;#{17?@N2:ZeaQ;&!}[*YgqJ$h/7=o`_|ct,O9+JMq*`^G0*M-lH;N?kceK6bF.'.RQj|p'sb/u?d<T83{!~C44*T8j_bQ<aKs~YF)@X$?X!e3qd[}j:@@{ZM~&_Di<A_ybp#6%'eG!k,vEJ!l1V<Q!6--5>)r|=6-o+CV6q,*:Mk@c@fg.Xu|**<):9YCfvsDd`%dB#C={vp}M#x_g1MGRLBg!P_#yY`hs)6BybDC=b+Qo\",\n\t\t\t\"#ZlWB>5Hxz3!BuK6CbLJxf{5z0XA~'21su#yiJ&6rrVwd==.?;r,dC+{HT9Ga%FtHP4~A~$jgz0ujgdF^O-&^b$RJ3k[S!B2N<w6<k?|+?KWK(T~EiRjw[4K`_T'+YGl#OCMszY2&(9>DYN8$'-8O$(=q_TY;`cq3z)Zd^p!1yW4k7c#AO+P{+EK}669dV8V7'wL{hR@?=e}Pw^TR=>+#/a}t=S.I,@TYeTzf~DiTW,xFAp:SR]Q[KT*A&W6I<*?Ez^J>s7Y)NTd;7HXl(!57(d?q*4]*\",\n\t\t\t\"#rL;XYqXANI&J)!%'1rL':YdJ09]9{]2p5%s^*/hWOe[SKG<3H$/K3$x;1^=5x?9xOy#G^paY~by5iN^[2:X./H~5Ko)0-D2W:}GGf1rN/ro#e4iqLh81-vfl9}vy!60w&[n&cm%7Bt=XD0tN]br$]~v!'vK)G[Oe-8bX4L5Ux@03V&,XB8SyxJ:iTXUus,3ZZmszvD%1[ktcJ57W>$YTB]a9r8l[hJrLNLlWe]uvyqKK`[/*C)'bD?HO+|a14boXmyQ;w(?7KQTq}]'RXjf6D/W;J)av.\",\n\t\t\t\"$0)&DevbA.2iU_Hf<T.@S8$fB5F{7E=~9@W2YV7`(wwq?dn9CSgb]'h0fxC01@Qd$ciZE|{p}jhi9(-74Oj5LxmKH&*cqJ0rtx_i$hxT~Bk?Ko;}8|*TD'PeaW8m~x1>Z[*A<TT9$nv[bGs-iye}wkgeKFCiv>^{:Y1d,G3DAJ^br,gP-F?Dm5EYX>F0u>~%=u,sI&&_OfT5L^pD&T0};eby'RF*SrZJ9*(:R0zeHmU%G2`I47#tMQa5=&0a/i}80d7s9Km]ayB$W'~qHmeaqfV,?e74KeZ\",\n\t\t\t\"$OGjtpKA`vz*8DE`?zqFcOQIPE%MjL/f#3g~Atw4{^;[^y<bW:%yx+,Xg^9~GNob]y5T#DMPPKX>TlH24Vr%feA{&#V5#5G7#v^6W.sbk7TA7GZ:Y}`Bx%b+dnC!gpP<uUv5>5:]<?bw=>SY&J#F^Aj|3bPh@+(bjRkmGfDP8x;,hN~1wxzewb[([FE-x#jc!VXt8heFHo$P|B=]:6kjni0L7&m1dPx+i4%(#06M=pb/WA&Erw,'h!e@J[Xq8|r*Tk9u[Bx%4nvw&M0q<EhgeJ`p@.rhJ>WV\",\n\t\t\t\"$uDqXvMZcIaE.=MjGG+Fe`uC;Qawx;(</$Z~c+'.Mn-Squvz0^8lS=I8/.@%)F/a#'#I{;4$gk~S$#h'|Q8]zti,ODR%4#^qDW1ol20Yi*c!M3WI5X9p*hG73g~!g{~_]T9eig6iKXv49*'ybz$`8?~A`WH=MQc+F-{0o($j%*Ws{g$*(0x;=jk,]FF?uo0?7Qu*tfQ%guA~KzNW*BWdS`'S`:Lq9w3Y5#N'(00]rPc&#*#Ihob9-aj.On4owf1*dh[1_IvKWVZ|mEkSI'N'@'ivwHv,}c6gs\",\n\t\t\t\"%D*?W@yqSA$efWzmSw>gn1Fj=(#LS7GS*Y%ort`HjX8!QMCIPC7s-yI$v(X^U?<3SahO0/Mr.,&&@FK,zJ:k%$Ej4MNhX%eV%!/CeyO=n6Jnku;p!~4^XO6Dy#kRwC,f2PBdE)dbB4[67]^J(UTmQWzB$s9znKZ'dPHK,FR2C)'33'VR)ni'v`0meR:@-I|{1:}6JseLy5)+xVGU3!>#(~OJ#Ms3<QDyA=PR=b%Ltb;G_pBL8(&OH7f>Kbr|j5SQ}[?miKiNc(NU3c-xxAuJD8_y=r4jv4av0k\",\n\t\t\t\"%xtr[Ak{Qc)N3@AO=sBXYXxu/eL}C#MJ4HMBRdm[QTo<q.O8UX6.}&y4G_~IUw>+|@+^IINa$xAm):8~0m:sZlcdXj4kRECju5%A,6m1+i]*?_0Q28FQ7GhjW?qr$$_=23*xNaxA{JaefIP}<EFhmK5}9!dyVlSPYL(_>r;/d:kTT87C175XHOB2v9ieziK+T}9a_|*yqxl_ri$)T-$hL[<iG8r1+GTrET~E??'Q}9AP'.5T|VQX?am@@*/*/=/;6G~M{6Em7,)^O~`N1j[a.Wa>v[1#XZv!ACV\",\n\t\t\t\"&YG`yc12FXq;/!(2Ni0S2g7]3rTi@j:'f'{~CMA?s1Bzm!-QJRil]12O#[6DU9FB;R0^';z2<.-zY6z0_FG-/k~+k8LXTH1BoZxa]H=g~k{)I!v[m$tx_bDl!x}%CQW%d}T0?dG)qPE/}pnZ'emI5PBAI);C,8J/v9%L,^VhhpO9z`<tmGcA~6@RtJp79'QD}0{kn4uA/A6/;Vt>2t4f<|Tl[vHZi6DmWxs#[uVC2#R+$XQucI2@'Tt+:<R+#oJyZX)2gE!1qz&Fd;,k*k~U;*~a]SNF{iO(`SL:\",\n\t\t\t\"'F]Mh)|R$YjxV2gS(qW0A7M;+mE$|+nJ>3&Hw!GoWklM/R3?be#-WS*]ain06nx8K$_oGWf0%hyRBI&ISHsQprL1o*5%gl&d%#M2#p.<}XsYweR4QN?13O7g:z9Fk<2Th-8rh-`}OP)`UtEEN:/{$_mv:V2tde{ef-{eC^ptSx[.D%(F0BgR2V6rb*yy#dcl]o$y4C=6Xr{qU~y?42y`6?M4Q[$6p'&3s&W[71`7Skr$z*^(px'%U2i!1I9[c'MH[uOk;&V3*`o|{~R;ek$!.M+{B[{o{$Z>dNFp6\",\n\t\t\t\"(A~%DO5`36dR#yi-pKMuwylgz$qE_^Oa[Jl|u?Y$w9;7JmtE?/-_`[?DF4+N^*to.;ibmM&mzPv4qMaY=2J>gv9Rm6Fz7-D-g)aKRU%+m,obrltb,8ggJKPXF{z|Jkc9~d[jib$t%r/Qrbe(ZE];.qxRInvZUZHXMTa)JVMkD*6XgH<;[/i2De$FM<HYC@xT%V)~O^#3Mst,38sr/vSP-5q6<FlzNWv5H1Pby*o,ZIyW`d'`MxD^|Wn@S;)~/a},xb)Q&awBp$4U})I$_ZjC-)1f80M$NNXFOTp3;V\",\n\t\t\t\")NILV}J<,fm{|b^8;YRO;gR<ss!5jqrsn#@UM0]$-'nyfW)k~'<4=b~E*Z`OJqSosCq%(m|OTP86],9D7.NSM/<p!1].5a5:*<FTHBMjDw5F/P(6rJ/Bs(4YC/aE&UQg5,Yd50ppq(k}|u3oc@H292+$;5Oz:s*R5K-x3.NVf7Wp3@x&|s4aetR1CV`fD$p7@GA8t.DofQ&gE$2nEhoSRBOZ3Yb(6T>h9)a<{eXzwp|G+o&#@@Cn9}~zaM37cem#VHfm~9=d-=ETx/tD8WwPK^bpHawLj4qxMEGihWF\",\n\t\t\t\"*pVkZo/M#.*/)2[#L]Nxs4?x?+g~lg>t(,QCorU*5?X.xx;H4&>!^*0L(jH;=G8j68fJlO(8[j~aX6+<3.n}7VqL@fKJzUk2$DQC&^nt8nnd!9G!!r?%o{!AEv;khKZA|cAU`7D]cJZ&YU*+FfNQ(``Pl9@yzL~V3oruo+^OW%^/<@k1r4<Eh`HjF-bOCTa0x(O0!b`-sG=wDh>0h?:{(R-v&I*R.)>k@bh9E>rE&,h$@9UYGp?)ODDjKO}7c^fIS`4|Y$Y,,^BLe8,S;pYSVyr=Og@99BUlwCS)'tIN\",\n\t\t\t\",MrIu=y|@T@4m8@D8NOc8u(Dp/-6!wv*[h+0;c8^Z~mhI&z@|kMz5|*BYZ>'R)e/`K9~V!^Yd1B3i|Y1W@zk4t,g2%(l%saq/[MVm6W<0e5gA]9`yM-DMV8ltN9>I*EPA!D74d<8m4HV8_zW:Ja1&0j5.F0^m3xpGOe$j%CzdqP7OJp8dvQXk)gHk844)%39j]Ot*(`~,dHM/vaKncl}Hpjb.OE97K>~LZ#bRctV.&vTph3C`!#^&dL<CD3,W~;di.{to4GK&6(y5[Qjel1c,^]z@(u4h&9rbl|l7]q4J\",\n\t\t\t\".Jh9Ass+DhP1QglLwRGGb-v<;~$Qu|rTdkAPzK:irmPo<*@OFn{0FrKgfy9AKT0rn~>1wQJhQcs[gWq4|5mpf#;Y!!H5W#c:4j(6b4&+,#@S'bJ']3~@K:X*t]8@%Pd`X,Bhtfz18Fh=D-p6l.ztytR^IDMaF+CV;H@`Bv()F28P%*#E`A.kt@vIRxjShM~mQPg%nnoqntwMG*%u~tTV`+w%>|~E531wu;|NU0dOl#ca02dS;&GQSqA7g!}svMShs2II[R1({&xh6&jTHj*k`i?umv#:G1G!)VeBPZely*\",\n\t\t\t\"0m{0=9xG{1;gcav>r,nGX!EpCAE&['`r}kS.KsX4^k)8/?fFsc1S#j3+47@nU%VZWvI'nuQiA0Tg>d>1)thz9KzX+4St1Y%~iO,k@)4BV.'?Yow4%N0CJOET7}.67=u0)f.!fQn1xX]v<GMK`R.kkpF()X!'9Ewc0<LV)hZ[~kOL+~L,:##`I#DDaDe}S_V}h`~?B=nvp=p!:#,DOrb~bz;3kNp[VoK@(R3D2em%;Lh]v!fBcMAE:GHgsO/YVx+$u9_(d5FJ_..|{{nmUddgc:wN^hV&},%soS)q)UZ)~c2\",\n\t\t\t\"3aiJwY#i8!s~LY^iANizu>l/(ywHss!5,$-SHqvf=qplq/<=jLNo#}n|K#Et=|1%)<FKTe^kF4{n:`,A||W}~o!]A3T,&I@22[S_<03'yBvn<+O,=?23AK`N3]vcQ-60oaXrGn|>d^mPKQ_}wX*j+URop.2MSN'Y!#z.<k_QM|%'4dyphF8;E,^=[x339'+p|fO%829M,y_F2,^0z#|As3mvPa(5?/v9S<h&D53BVJ:teEu1u>'OYDLARTe+{vVPmYfL384tJEu~w`5</G+i`T]fw:%c+:=ymU-7jSiq*[L{\",\n\t\t\t\"70HKkgU6by5:4,f0$nNy8E$r23AnV6/<]}dn,VzcSGf?|?ONMnvBQ,!~[;D^EQgGYAF1v&H*#I<6beWy>wv4GGKQPN7cha2hQGJ@'hQy>r7-CgRzW[-6$L~:Fz;I$@U@@B9F:3{8]ca+kMS<ft[|:4aC|RZ$[-n{VGAgt2U[!0F#ITV]2gC)yd8+Cze]'fpC[5Es`#7TBQ-;DjFpk/wGR.g,(KkRbJs.O~t`|Y2vYSV'B92rV%)*EM/Jqc:TMLf#|5}xGEIxt^[i1m#_5C3:8]ARRB*RO<f^,#1p>U1G/3kEN\",\n\t\t\t\";DYEl74o.`>HRyei'%@nN**1v>TF4sy4C&!*_dExh)InVEA/X#IwkA^I;2LV-H7uG+zMGBL:evALtpXUFjr]ERH^s4r2E.L#u;0Wy}fU1w5!d3CSQlW_:w$D@7Qnw*+&'-8)O]*686W:^VWT=6+e1swK?WBT6>Ri6(t,'K3CF1v7j'*2l;I>iO]3xsz9I$6h'7mLAt;'Lx%k<]vwrHe^>K[e{X/[D|&/hJv<@9U)_su0X/@LCa<!E%%l$y+-/zQe}96HY;FO6}EIW2.'R^QZ;BjmGg$qL+:cNYq1`,NL7@sWS6\",\n\t\t\t\"@Q'tc*;Qjz_B3Km=ytWn*?~&uU(b6sqVTxG5vfUj(v{yk_KAgEyA2^Fz,vq@)GoP|4$*PIkWCco:)*%w-dwc6;>6Jl~EnX4W8^#RP{BhY^S%.{nB1XXEH>luf|-EKBr0<MEk8a7e1]Z9kwDj<*2en#B[]*xytPY}-0T{)R6k7WJZ7BC[~Ua%{A1p3l(T~/Y!GU%gK;dALctQWdWfM[x*7/,J0bCQU%E4d<u.n`aTkfV{BX.yt,?H/K=.N-&^!MbqI7|s8Rgtl&avC#=RM7R4o+xg61b{]eQL>3#t9]^cQ~5[y=N\",\n\t\t\t\"FjEO)NcQ':odiWn%!tv>9GQu.#'R_a^~M<g-jr'!Nh:x?RK:,5VUjxR%Nuwyom%@`@GdK0b&tK-3Tc02EwhY^.xL^E/1L%R$J$t_5HQ!%O5IL2c>is;s>g2Q[j*EBE%Y4JOQ}gu5#Uus:2_ucV)b'VMzEfb@m6yMh';sdnmw|(`OCoX0,P.6q}H+Cu(Pr83+]}P57KkQkr_@u}$MeVx1/,|mI/fR{JxwoW&;t;>%H]Z{NLN1_1PG*PCYh(R$h;h5((7G<O)y6bY16}rGCKXc>=Q;Ew'};N#Y4K,K)ovVD1eK]D0{\",\n\t\t\t\"NI|+b5qq)8+i%{`}w9)gVe;b:vFpFvC!R{:YWF2}%AO^HZYyu?H#DUs<Phi&6}gXAii4ScA!f6F0@8o^i#LwjXppE.8>PH_uuGlOZ/AmMd}1`5?%gyMu/7v^@+p}}H-k.pQ3&aYhWK(mCRc.wT3DUSY4o5U:xn4%%t]qIx=m<DCdq=T>fhnlmvOsuBR^7Pek(N_}q?P;8psZ0YOP_tQ45U;8xY5DshCB>h^O0U@.fj=A8e.!?PYxfrrHNSzuz%(}OfYX^#-_6hgoE9ZlUUSK^I`'NG&cO<)HQ[V_sG!<,ze42x2Tk\",\n\t\t\t\"Wn;hhdbNk$Q1_F>,uspUK]Jgj4?+3#*=@MALQe>}9}Akzyy3{-LsA_u>3<+@`o3za(m1&`R1F}3G}G1]Mm::}B$ic^a786vkFqnIx(BALaBtsbnV3~H?T8*3wx-&7vL/p})'Z!JFkD%1f/C45k+!#fDN+J]wBgsZ3)ZXd%u:+Gl?[qAscDM@*Z_02_,5vQ&lqd4++kTUG_w$=yJp6b$I!C+}FY6W,nC-g=F3m9iJ+%4vE^(MBb74pVH>^v|q~DNh75$+dpjj$6=dn0`fP&'JEdvX!?MG;8?G@DklL?YAF66y};1~Yo\",\n\t\t\t\"dAJE`{`}K1?XHQu(<M![{<JT{2|Y:^XnB%-S8siWn8l=2=i(+;y#tsQ;i{1aivYa_sF4S.TGIW-z<:ejuq/Y/CIS5^ab$#U#-WaJY~*4kns`(')qly5k7_Lq8)|yh?wo6tdaNeP~Eh:,3Vzh.ZEzC'5ZP7iOF7].?[sSGGJ?)dxe8#va|_oO7Z.WU)<|0Su^E+BR~A-@v-]bO9Q5Zu}uzp0pf=u<8;,*G)X^^QrMU`}JicO3zjmoD{}C_bW1`B,8Tg@c3rB,0<AyWC$vGp<c71LL~[=Y4^8EGU>KwN_BJ9daQPT]<]*\",\n\t\t\t\"rR7L:j%d+=T'h4Gd|@!50[T-'}&}bR9~tAv@#n.5ii[VPklF3X3`zciq8s,OPo^47RKoy6p[hx+3}sZ8wX]X55oyco<FdY}tQ't.F856QpPDHT_9A7w^9p;V)G@gY{WRs,2*aLRiy,:4la<aj$`BRWoO;4b<pq)ZRmB.MEgg*LU:u,:M*&q:j!pv05s{F>S|PWhv%!d}(}JPv);=f~~VfphYi`jx9pl}L)Vv{Rk!:KY1!dL0^K:T&YxO?$+NEV)uF#$WF-o`j~5dE7SD>84|J_SLE3f%gl?~_ab`<F2e*Ul:.a/uCR^.\",\n\t\t\t\"#'#bcttIXwNOCYvebn%,eEh<;z)Jfh|*?An34=Sgh,4MW+.RVR1EZsmn)%r(YVm{F|tJSm@R=)LGyU:rv/o+Zu.b$,1y0.[Q~gegZ8,!F<0u4;1Qvj2%a'+|ekW6:2VmTYdLmf-*9]0hJu[>Zw3e0lRo!VaS|xc7+sf;_-iu?T_3F|Md<vdz&{XT<Vqx,L<4Xz,SD7I53T)%Pgr@cnMi')M?z375R0zY1:bC(x[&1f(r=?_S&K[MXh'n/0X,^!Kwl-`*g_qB$S,.&xU9w<-&d=Yxt0%l@8Q!=AA/z:._TFZ,hkz05a,V0Z\",\n\t\t\t\"#<^D^4{x^T^C5@-PX,Yu.j&li0CV!j~GTv!e}qYS1>o1M^zEb61WMz+R_W=fkfKM`1w1%EEO?1XrFjkTMy=7[n5*.[U^4fC@^9(gJ4r]u[`RJpEt4ASsffb4aj@widV[?QmK#bRqq%`]0Yxmk`*PiH%-iP1i[0S(L7X?by=+.2=eG)t/V=Q%J[@f;.R_P_6gInvI6E3;[+?3,t.(hRj>qv?Ug|x/;7X@$T]ieJ#)0u0P#gx05$RK1hg7-$UY>,qHxGP(PG&tiS9U4H;J0#2M9BYM/$MaJ??t)*<R{ym)LpxpcKv|Y^?okGV\",\n\t\t\t\"#WJWtI6}Wq-(/mr'|F{`&n=T5h*>a6WTZs!G7#aA886&e=X:kY/KhZ27xL{mru1}AXJU.C8aouNq(w%agHvf7pAuc0u]8R}u|AMgb=aj>VF!uUcoC{.gen&gRSZe5Xceh}8yK%bkk1wD)AV7#LWwdFJ9YE=n6G{*<*gSI(7oAO7L+[H`@|70VnQY4`BJghU#[PSR_`k3L^IY!x{Q@xvw1j$o@DrUTGNb-b&H#6o7NgTo<OM[C6M*52~+M956c;Z5JQP7Rn4FBOld9C*$?0993q_H+)Dn3<dF>4u_OeawY8UahPqWfdz;m<_s\",\n\t\t\t\"#ydhx<~teMT^HfbhdZ1Z/-'&m;,z}g^f4F:[TVJ<(Q+1#ZNo/AAJ$.1joxfnBnU`^FQgcOs($}Bx{Ag}TqZ|Efc4.!@+_ai#1VDxx(XvJ~MrG#|gCJ>.C?P>N])'ErM6VXQM3tq*6MS?W<E~wf)dG~.{~!08bh)|#H2.5<z+x/tb7zY,})>(OyA0_QW)G%%Xs?qZ<3!)jHbP]r>]Cgji0$AL(<Ppd%d[WkNHnK$b.m=B#}=/!PH0%!4J?2DslW`+r4D07f:NP3KZLhs7Du>}'2IX6'1&XN,vu@+45NcceaJUi'qf=vJVlj5ak\",\n\t\t\t\"$F-HX0{O|O-.kWtew81jMy}n!gTaOyt~+(QY8ozkejbIL}xwuNn@ba$ATywmHdowcyme4+TS]#NdP.HkrKI$0R%Ng1cQA9Vx+3Zx)u#Ebz4deV]6AoL}'XOtGIY|2G&Kc/78?nx>-.+<HOKF3IX.9H_Fl[eX^}$64fsV:nVJO@Zz4aW(RTv'xr=S`J*ty$#:v`kVjzhX5iTV$_Su:gAqT'@UD3ST6$qk+{dvO=qKZZszBxT[@rT}G~>]q7J~i'l('HR/l9IJ'|`}xC-rT}Ew@=G8xc}j38|ub~uB(CC:r/JgRRAYrv/,f!oP`V\",\n\t\t\t\"$zj+$BCM2*jrT1QABrlNnsWcw0(:X0q{FcuZC,)nE?HoZ(F0oeglKpE]d>L*pr940_)XZ]NVJm|fy&;dwliS9gyrn'{sP~rb'W],Cj]avBk;m]b'5n:hzb)qc_-Eb-oXBxN7om`q)&cwzHWI;hBARGY*$ZBd{`/HK)mnp!%T{Q->}%5P:31#D.Y'`_yPBQ_Q~Vh4WsU:'1lJ>_1j'jYJYtcu;v;XvVV`F3@/W#V0>7f^{i}is060!=XKcHBw@Pa$?H$~Mk0`o`/pwqNI_S2|kfKZFQ'+j}@e`muR]BY@|F|$`h.o[EP&sK,Xw(:\",\n\t\t\t\"%_@s,]8CF?@+HToQ#1<VF+vwodQ7))kiSYr=h_qRk/tjw^KWg`$'S~)*~>p@^{D8mM3mF^>&$m49&=Y>X;oo1JLSBBIh-.j*)[[no9T+`bB'A_*%o8DLo`I*($-}TP[8^[gsz:finLeKqa*~.W.WQM:>V8Su5)GC|K8zYf-16{C8Gntunf(o4fmO]'0NKm0;%7[psxeOjWUb[4F.[%N,%OPqOO7Jn3%P<ZbP80)$2ce5(X{cj?2D(?u@rn=`S.,4M#<QNp$ow9cnSMr4WeU+@.UrjLW`S-/M~=k'm'S9<<oWquZ/]x$>Bt.fUa'6\",\n\t\t\t\"&S68xnqL?jt=nJHgis&*ZgPca&w;XG]}|rH3zR$KtnF&sgG[-dMo2,0)m}PMF`FyX'Cqij<p].>jzz13>c;8}U-(f$w1Y~mO90D3@C8pS(lVZ-PA%6!!:Piwp#Y}2B{F^I>q;h0KXWe:H][9w{tbS8)@YZ[ki:K-QT4,UpvFT;$nO+DIa7_,ZM1k]*%>zr#uZaXaa1p^%D^29G=O(35^RsquX]|{N&`|~4B3l`7$F@/b,Tr*KGA2#tk/*2>pZDUPu}|6~Bqgh@%;F7L}q,p(sgoZUtr.._Iy60os!vB6ptfGNBpoDDut}STrX_chV\",\n\t\t\t\"']jMB)IG2`RJzjN+$NI8*7iv6/7_1#;Q/9el)br5T.[L+)R{Gk'[,)G7R*hgKgsOOhZrdX'tMRUFqOfP#cM_!-bykP'*Ex;quu,{Taa&$Q[LfC22Kw4XxG*HVe>Llt=J!urpJGh&M1w$14ZX+mVYL@KKiFkF?TFi#m2n:O{K*Ai7[<y}/nT.c%Yv$ZbZre'Dr{.`M[b]HRtI.@B^k]f4$;x{md%`<%};gk4^!7!zxyJ@m`D1gPhDWxL=3ji#qAu2ByJ?K^Um+D=7(,P)Pc,:cr@Gxo,c7AjV0fjh5r?C3xyc,~z%iy>?3up/ar0elF\",\n\t\t\t\")$VR<ms!>RSTSH({sVrL)NYtc)j22yPkLZFnEcbZoi`66rE7L@>U19Mq@^fpPM*(gMh!%r$]DJwup.hT32JOP@C|0U#~n|eY:W|%vi4qc'O&N1]~<4>3)h'P-/=_%xZu7O{}&5ufpsW|n1HQ([%}&$#ha',`SOr?KG%fbmqW907>u;rx1zNgeJ;H4bykK8`=)o9jOQkD>&;k{xwc]9N$Ye.J4]s},W$>x77u0iHO#1F@GR|nB3hb3nyuCTW>|g~SPoA{}}~]U2~CCBpH036T4~p@2H$dH~}psxi{CrDTrt)W4zMPQ9^as>I6z>j2JUN\",\n\t\t\t\"*jfa7K){O/#?SLj[J~pmY;!j8fD0nT;zRvNRuMH(/j`RH%vNq'Ummtuv/x*DRV7|vd%nmM8b-XQgg?Gr2j[r?[17#v]5l$NvkCgObi.NU%XpB]e!F,9j23+hcxbxd^Ck`Z;(P(,KHQPHsD&EZ`wu[sJ[[l!#}Q#~JFI#Pk=-`t,]4-XJe.}:N^M51]j#`cQ-Cs,W'U/F*T1(IaGGgQ`/Vghcw)+(.942(l~zuDRh77K>/Au;Zl}Z{}Ov]>Ki!X)}{);;UL0&!Wn/pdc|:bH._y4N&r]>XJmJcyFP*E$^`^2zw'MHxY~;jm~K?v1%;}uJ\",\n\t\t\t\",~Io6vl2IE6IH$kby-Vdt{<`_EPm]NJ*O;bRJI7@iJ7q8gkMv'dNoZ;_aeYl}|1XWfb*+1^Yw)H]E%s:is-)BLq:K1t>a!orjZyEs5P.=XsmGct8axD.t?kDtAh!=g2*N-P@QoBYdu:B1w|;?kEvTNqx2&VU_Y3x**[I+Xkef4x%t3%SV]0>-Krtuv}&AR5*-fIt9RIXAA&?%9EIG{wu6<{6t=4lu&qK^q%m-&<:n,&GaaYNa-n4DD.,5`Kh$LezK'wt>`'6}?A*DSB?82Ni)>>}[O@3ml7Z`O0O'3w`cbI#EirlQ5A8H)&IeJCd^7`X*\",\n\t\t\t\"/lKkVWzvSP/wNNLi(xHY@aFVHXq~X:$=uYP!>vdYy%=-a7FjV&(WW/}{_Rzu/$_qh*m5sR9MW!ghoUy-/=+Qd1zR`S=/f&PCVO?GGH]f$'fz2Wk[tEt79JduH&l%#ll8iFxE{=.S*~Jt;sa?eMYPl2'Wu_5>X@hi8~5{mW<2F&}-S/+w5d@ZC>/0G0|15n)Fl~CAi3>KbgXLy+A;N5<two1jtd8/Kk/NjtskL:~ts7ZmKYzopbX[R3)EctA1PVx,>)F!YBv#W)nfl$,+^Ip<is2l'88y>s.['uD}6yriZ-Kv02qT@sRJ!8!)K,$6/Yijc2\",\n\t\t\t\"3C!Q^8llMl?e1E^^3y2,g|x~K#X-yP?'w&6n-OZy{=)v;jnYJI1jQ2BXT|)hXAg<~P4,z%<ep(38]6n;J?!))Y*Rn>QP/M~,#%4u(|/et.8?*mHRZF>G)&AmjFtqcq&Mxm:?Kr*bS+g%QsWzaGu$@S~0Sp<,j)&Y|N[}QTO`h/<LeMd51ztXnzhr.X[c1:+e(uT@UTl@Q%!iihiZOZ4vXG-|XYFbD!``i_nB9?+xmZ~wO$A[=gkE>7-2>LPg(E6*5vfm5W#hY?;E7SYXg%cKx8KVmfUNBz]MJ<}bi;I]*A|'=Z?:9y6qUIqHxWfZ9Bq~?,{\",\n\t\t\t\"7tfhFhN+In9@4y;uJX.Vz.^Y|HDc>_q1[n)N3v%FY(,Q66SPEOE'eN|8I%7{/%IaIVTX$Oe*IJ=i5}t01MK<7P_&VJ#!^~.h[QzE:X7.-ZMI([[*B7LUwNk=c$FLC|{Azoik.g;:nIv![_;#``chZNlWcVR:>y[)]N.p$[1%=X'WPd}aD~l:$N)Q1qz%;'dfKz-Z^-Ca0}6J9x/per{@X/lf/WCi_f,$w587~5u#Fg|8CVz;urpg0~Sp{!DPOppRLAj~~J+4:le?oVyif~fK]hm/oywcNih>7sO2q7@YEy,[[O2'sB]JdMT&:F9|+gJp/y~N\",\n\t\t\t\"=`*2pE~jAfzi:;'$9!8`/c|=v8Y`+p2k.Ic[T#D<zEcXyUVIq;%A;P?R^vi~x~=@)|;Wc`|^g@B#F67,+-|L[8MrUv#'k[w4^q'SF%%.'|e<8exT7}~#/$e)64<F3f>ol8Bb4((gt{4zGX$rx;w[|oCM+VgzPbr5;31s(07,}e6z>`*2iqtjRnQjIvTjTr}74zZ$Jtcg1hX~7Nn`*]SV:*V_'b'PNpS{f<iXQ$:ky]rj[L`y>a$B+oq+h$Y%$Fq{<4JUzd:=ktj]]Dg/v>Z;jwL5-SN.rD><`v8Nu}0Q>a@H=@.IGd,gjQGqAxrzyA|+uLgO6\",\n\t\t\t\"E&(aY$GfJIc;YVnE'4Yx1sTq[q$oJ[Z9P?X:I:,HWDQNR^&JBhRe6O~@Glt]?f`G[yG]{2qWTQy,lcAQ+,Dw:cdS_&c?X`DolV!!GDQ;QxY[mt}yqy+b/{4F;c0$@aiN*#x<fMsfq&uo'!b]eKt^.~vhT9(1EFeSWW-PtCL5.=.DxV/@|Rds7bQafBvVjqDX4~2'Enj#pl$J-WNF8;P-WSl_(_I,zf`Tm'yhThTy*v7;eg:mfU$=-RK/<m]ZD!=-o]FXk|b1qB)KO&;lMt0zi~gO^TZ~'$B2`j%97sWBVPjR@l>Ng~|`^W!59#vzxibkG[+i~N\",\n\t\t\t\"NOYA]|Zy%[E9w*'SQD[e9bd[R8dKhs'YlZQ,boXf^lnx(>$[]SW`f9i9Mt>N?QqI8m4byK0NHF<j/K*AUc;uXBX$~{9C;L)<hjg#{.haglq{'mX*J[_T>Dts5x8TRU!Kr2kpsy<meuZJ<Y]YIbU7&baz)l*bPw!G9TYO5hoN(>MO~/6UCpF?S,&VZCG$]R#Vj7TTfUMga<@aXC[<G<gp;?+4TZi`:eD1VJ_ixO,~fW1W0+{A$Ta~(C?tcLS-<H^_b-iZ.1QP@0g#H;BAUX4aI@%eWRgKYmXeL09X)&Rjj}%.=%HYWz$#5~8a:OGd(]zXxD|mz${\",\n\t\t\t\"Z[W;%Mkpe%k,g39A;OP<:V1ax}G?lf*5A0=G!gRXEE'0xBL#/+$i#`t:$2%Pn7p9s+z>>(TT}t(s+*<BBE@ZA>g:@)C812ZwHdr}(ZAb+7/HVI0E#bDK540?k<cUKEj/07puI&mY@XhY:p7|2)jNG1>adFmtRD_&45m(ogqz#42}4iW5=g!9:AgSLTdG$P0;3rSAFZD%s[N_*ZgU=m|calSAJ$wRm-opooIU-%]S,Cj@Jl04@oQn83fn'YtEIm)(-Ap#oMZ6{?Z#:t$YbUz{wcqyCMuMCO^cTR`C-R:}:'WdNp-RA1r~'ax#VMzM1Q=Qgj#.W,}k\",\n\t\t\t\"k6|k`H$MH32,G?mD+3X4kl_qi|a-+o3:&Xs.:,h#_^w1WjhF`ylHS1x-ZJY.}@['v7~Q#VJWm6Y-G~TLe&fcxP3NIgn*BU7{4TbOz#[Sj'cVy5p/K*N@H?-K%@r/9sF6bR`BZcOF=yX?a#d(UH}Kw*x!Ds-sDk6~A?rEwWiCSF#EBrKwE]B!VCeHS[<LJv*p+Z<]%N`G-!!&-1E[Zx.':/43=0k8ms<?cg?'2j+30+ytbKVC|-Hz3.5,4A]4rbvkVwCrxYh2M}:+Cx4rE)M{AXX}`=kHZr8'zdiIy<mt9uhFIeQ/X'jy?]`)dV{FXz!bkP3vpg#bo\",\n\t\t\t\"#!A7RqIK|K%Ji3sYP[kUMnn1I<'jh},;8<sW(Oxvbs|5QA>+hKp$52:AOH/tqA}@[rLcEH<1qP[R}3-kHS*.ALL0n)!^L<$nuPuD2?m#5n2wYZfjyYPR$@'gePjn#3SD`^{Ywjmb.IRaf6o}*U~nT0$t+e,T:yS0i]qG0OBz(k(dW]U7`IwofxFUvv,9SU9](VL>x|QCc>jWM^?le3C,.YOb]t}AFuFCntN3g}/7v%1wb?~Cdnr3!F'|%v?A|+h%i;I+f7Fz~EH#$Y#ykMTKfnsGk$%`d-/]++jURI*e<))dyckGC}SuEyF]4wjqtZ&N>Nd$3hO|(]*\",\n\t\t\t\"#<?J53IY~r2]](I`bq|1pA3rS<Nd@H@c(:M-k]>{xe^Mo[uIgh?4BDd_>7G?$u^aqLTBvr~YVn.JXc>>uO]OyAbk;_*KzSfsg7KQ:_8r6uOvOy#bW.16,&[wN|>s9r'sry%20S6D8yj#Mt!8#Y40?K;<rW.N,AMgxt-j(eB^{=@_z9[o8l&|5rq/Hm|iB(r52~lAA[RAeaq9x)]d^vP1^l}p%#p7Ohf)Vy{#>!Jjqr]Cm>+?3bnO+BEESMj';S)>DyTz{JdR!zc[$oLQ([MrH0[i:!<n@s(^#$#g,(@d>OPQ7`7@riNWzvSPs0uaA<ws_4z|QTU4+]E.\",\n\t\t\t\"#^zp}Y3dmNyNFYdW}N#O'impD9tcs[w,NvSkyDh*OOjDlx3XUF`5JHeJlP/u%i<I*4,XlN0$7QR-M*5kDrZphsk*GLQm_Y<a.Q*NzqR+?A-WEq_'z`55s@wiN%%kXC*l+rfK}K;v[]Rat>;4uzN'>3xqJ.Cv}P4e$%8CTqvyLLdF4}K)498fmgp/NAmvfiZSaKvh'j#8x&IU#K[^hQ7a`,++yDQr7XKPl9?^ksbs>nKI0O|_]mLuA`I{G7e7^%fKPRw,|fUtfun[,Npy$ET&@FQgtt,ZvAZ9ulk*ALI~LU;Dva7E;H|/Zy;).-{vFoWX%v*0V,=zoO]XZ\",\n\t\t\t\"$-XZIbQk5EX%|'=^06g-UWQQ,UrX(%21VJ2uZM7p*CV~c*I-mN<&'{7-$:^$xzq4,mE</IY-)H9SqF}GnVo<BhW8J81?Ld9Ztx~T_5nb7TuR6lT=S@TZ[VAa#D..hRD{HP,>Hr?wi`MTyx$>D|h?Jh2_xy,p7)c/~o:h.Gr)@(Y$1X?QGa1_-i-*#HRCk5v.T)oKa?uN-Q<$UXQu`Cmhh9[=+'P|3(a2*V;9l;9JB.{,![IPR4HP^[tBOO7$oqiO)d2%XTFIX5}RxZDOaOj3qOB~1iklMo_:#)?]ENgYwb(9g'W,d!y<*8y{XWshGQsLQJg$R&hhn^OJ7V\",\n\t\t\t\"$g@e{!IdK@kp}qbO6V(i!)ry:O]p~*^dI8[#2]kuwDX8fhf?w6U9n1FH:P(NO/$po<PAuvQ-r|=kkYmSn4FS^<?lc:iZ-N[9.H*bj6X{G'xo>S6Tdn,`H4n!.7W6E3%EohZEI2Spv.25LF74-.Iq/W(]'G)pe&~,Z-b'@rh%J@1%jgj'S$i#p.c!(0!/(qhH(Z|B,QMH8oEb7R9![B~ZT7FOyw4]-RBXhS/I-G]uv(qvo(4q}|nme#}lg{u(ZsLi2vm$Lz-Ie5_:lFcKehJpPJE,0!y^-SU8mrsdz&ej(H^81W*Q7ngFT>`sh03D-T%|NXlM43c|e_.I.Vs\",\n\t\t\t\"%T:di!5|Uw.6QR[h,i>_D^:<5)e9PM_}5sPW>;INAI]-YY1f(QhgBS_!H-`KIfHC29G}bt*!)x,>{%$-$a[btyf8!YRzQ?ud6mRAJ(=yXs=c#9c411vOp(=z$J~'7mcF^[mR*ri9w~P4?xfk&+dhO>asDcb'Y%<>;%O34v*l4Jo75aAP=d)*J0_LOZOpwIPsc}6'%)PnN(-9XR@/,zMkIT-,m;.J8z~D$%tMOXjIhQhEkXa.mRJacYEG&u:r7Z+Mj[|Ov-#_bTb,!VrCtL6nJid.dR/4)jV|]1jE6!QDXH03|ts.6(x2|(@%(R}yin)i_yOHI]5G)_]>yN4k\",\n\t\t\t\"&Xn$=~2(Ld<BhF'FQ//G#m$z'y!&^3@W14O-CNYoMA|hjaIl%y^.,LJ=cZ,Q.qsUl?D?{|w#pZ:|z+4ybgD_w9o3+|]>?RX1(7&TaJ1}Yc#SzC_T+a|?JIgt4I]K,wz!&}!]oN29FwV/Q5cB^_!/)Yr+%duKZr@,lNv%yzRSApr5&_D]xUX+y3hO5UvUue=}D<u9PH:MD,|xilIHiCrT@^we:rzr~jrYyc`CC<$],KQ~|Z|H:c@t`b/x?0>i22O+_5W*olB!e[1{egP3%$Si5oB-/0D1lXhe5m:L+uXF:o;@$8MfG7UP=[c{8TB>N:wtXTqb*['vrM(<7+C|V\",\n\t\t\t\"'|0p]1w;Ulg{*[aHODXhz3pP*(h*F'p@nwvO/j]<1'7)>cXK%1-amh<Ulc=kg3eg,p`g]T[~w8Uh#by{yGJ.d1P+>?0'0Ty7MpQTTy*oVk0}M71P93-hfLzz&uRZ22b{F7&BK*C|qag]tUaiEE4mPr5&5A}Nzc_p9SKSFvXGwxV>&rwSj1G3wL)v:&=mHkaFyyO0n&fMRUwSMMl(U^92ngs8/b%fpj!padysC?/w{W7Wt^Ki&q{(&r:TE((Mt0t#BPa%@V<8n*0'JN$v[(YGMF2X3WlC{+K9Y+)_mH,p-#Gz^5^JYN^x`<01lt9x@50?{e?hI))K*mlul*/0a:\",\n\t\t\t\")iq}8qDHN>vwf)K(,P@!Js,5^kt**9k|IBPd^)5;}lk&}'?JD=OU1S%+9a!f*S0}jWg0ol+f%^BYl*t#+5^iK'oK:Abh9HXNt3tf`HK<EaA$2C>k4fgQphn]RO6WQ5^gReq=BVYmVAo>4jPL`.Yc](0rp&Kr#RT0CAPBF^59B7Z%&i{t|#'}&Y>.1qDYoNXLyPCHWwT'RuEe2TR*C&70-{}=`}KGo'y_c%g[2dLD]{8(c38A2Dfe|3=2ZU3T&njF0iy']Va{itp5)QPF|?pT=xii`KCH/byzw^5#BDv(jPR)~``7y1Y1FNDzo5C%{CT.TVMTdi|`d(~dr2Q#U;6\",\n\t\t\t\",.[pR2,1ELu;PQDOMsIk5]HT*/J/TOePoDBLpx$Ck_`~dU1$+h9tL2,Jow%cpnP.J*$!'},~M_3-H,2OT5qO}|kuyMEW&$1oX~SD5Ah/l(T[*N51F=Z4+?^R~}Y`M*{,fhu]XF:1ZN;2Kd&@(kfRtkNctc^.{e6zin&V|+20BU5-D-=f<z1J^O=[kx0CXVtv!W4^#3~QLrz@$qay2-teJ0Y0uLg]=+cP}AJAJ/S-sv&P@|@I2&43cDME^D2@r~SedB<vbCT$D-*%OTq-^<BfMMpV^60L[.Pbpcq[d(1wiJB{_u1+/RvojM]4_@=8#ZZut~$qHi?2_?PfGbEG,>7V\",\n\t\t\t\"/9K>Ec@rcr:B-Sm5n1Az~*q[-*qgG`I1>si8BQvvCWQ8m%uR!QF~V<^K^'(:nH*@JAn^e0L[f6_Jz#2^n{,:>Us3m)yoq1^|tw}FwJl+xl>ZW{tK4GQ?YDQ&h5ea_PJ2Dof+wUu5Eqy[biJx<no.Ccs`%v.FZ)IRT$Bc.?k0V3V6'N2LWx.373MzR,gM+*!QoJat;9zxhb&k;PCcL2uWTeDx/B.yOk/jk]WhjQ5SH=`<aZ?MI8`?1_;nq;w=trV$LIY+t^)+g0g8wSywcURnAzp%v7.B$FAWk)BThW?F2#RkeFemBSaD<)}B@I7@md6+6_:b;64JysKK:X!tl0B#F\",\n\t\t\t\"3D#pRZ:<>Fu'e!*Z`-nVw^Aukh[q{b;#>RtG|I7Y'gvIK_F`+}XQZ7$H5]Va$^Z#EMFxsljfj~i)@!~xXbHAEubsD>1|1Forb60Y7JLT8VeUr%})?HF9h`~J@B7h#UW+>nO[eep;l9!pFr(f}HV{>J{VPsCU9Yfe&UmqvtAVY9G9czio`H:w#~![#V~do]JsVjTUhB3`wyRRmV~('T<#Da`xQ)<{*BTw]%[cWWjD/-Ka?~m{<<I]Qf4P'Hbr1bm[;3jX`KVvbE'Z|^4S,J(*aV&.:;Zn/M*9u_$?hvX$)bvY(2[S34J-eh&`>y@wd}*kHn*Qr6.[7nL}Af=y7O,^bN\",\n\t\t\t\"8mhZV4J-XR1/{ftDN4Lf3+K^RT(3(`].gu>*#/0Na2]t:y|+h`GQkxzC~:W6R!QLU<;]sL3zcoW1UJCTohnl4%7MfGB{?'dQL/+lp]ik$_DMGB[jIm}w4Oi1;m-Y}yQ&CXA~)_wi5z]=ah$,*|Txv]~!4H!w_&E-ot>CP35@Q,3(|[qvmH`;Ik>;*./hCdXNwQv%,hLefb$;p/yTV3^^<8y]jqkI)}<:x89C*bMVtZ5x-D,^nlm`KcS3B/0U;<8!~vC<9]]2_FPgGVA4_17.IrfTF:Y<6$xi*.`|9iY]/LD<Y93|@0WNTy7'<^zf2JS~1&;]WVHo(y$2smPH1qw)5XJ\",\n\t\t\t\"@$O1/kxR&oD8CG+78WST0DRU6BQ<+-#KL>6@ZV(_zIKNb0p+r^xbvDe+^w^7SG2gG+cKRx$zGChJ%;Z!*6J5$(Ra#=1$k2UgM.@C*M1Md+W:pt_XFA(s:S<_hrmK]J*gmn#<@hSLNzgRR!:aYb{Ww/uC+$%/<KCVVcWns,IV)w8har|%MJPX^=n|O-f|Y0j_TPqgJsEb|6A0vW^C)/DWDTe|}w(sO_@'Lw:uq9z}=jiR))*O:o>gOK-&cA4bP^F[DE%Vb]^)sp'm,2p22+ZCO!:[$Yvfm8W$c+z^sB'N8V+/lfg0zX{d;Ib3nmj{Hyzy/UF$BnupwH^s[,_<S|B;KG8*\",\n\t\t\t\"IZ/d/</NOmb$x;tc%HR|tpLqxU=N6?~.^QnLvw7J1>xZ|[W<@_!@:9`/r;3wX*&`TI08tZ7~@o/F;1aBwY2<<9fqifXM@%I_B|{>0L,%=rj^J#[>U,c:=7>o6`?hFw5p*M#|FuP{IdA,:oc=PzodU/z~w}B+J;wy(C87zk?ddV3@vq.wSV*X+cV*Qnfys5O8,FL+Ugi&;Ay'8I(#6heftIO'dj:4|kVnZEn6eB78La~?VW=LRdq[=kxESa?_iO:wp9<aBL5AQ~:wSs'#a$9{pp@oq3D<=-P~YxdV=^{|@4`]Ct5AheXrkJN0f&x(0$.7|Cz__K$(p^{X^l@RL)hx?kQc2\",\n\t\t\t\"VCi;F4*}!9i#Q!z2tZh4n+Q'B3EY3@USxf0JGXJhSm4]B=Kb-r+k:'BUy`Hahl=GP'U`L**~A)iNqvvcl*rcwHL~l3Nv#S+_Z#XLA)l/a!6KYunvcAGO.^`Fut.Yx`2E$s5g?C)v$JVvr/GFC`mpOmx#3!}57zp1I6AJ[1%WOogI)P~13_n)<UKdXcnoFn'Rd8&=j4=I5a3nvoN9LoVI3vE:UyLcP(hWWJ+sk/MiLL1Zbt]:V=P1<deL}A.fM}alkcg)t!o%qJylt7+0-&I?zq1TMXu0{,EzK5)j'Y,<hsa'vt=#a>*e6^/6Liq}6+@%'#K&sGowCWu66#Z,^ws)S?ZZi{\",\n\t\t\t\"hE?Mdq,e!+FZ^FOEnx54'3Ok;<!(u%QH~QV^q!5t4>{{]wd#.gYc|9ZQ0(JF6Kwi_tQl5sn^)xd@XNv#Ds!j'X$2Cj4>gOXiMq=-i;]Tq3+$UR_i$,D;x%53qN-`ZUU~MK0i3dV6UMLW7q{Rav~5fc9ZE[wJh:v7$.HMpcMd<@G){O2;5DZ}<*k]h~@;*@::&>M1*&xGm..W3v5P[R_k#jiY]6rZKx4.LiK,A{2qx.1)=|1}>=uCc;iw}S_RVDjQA!?[se5uRbhS%OD!}Y2vN2XJT8_P']#$lM]dq.)(#`/HlByb79k=ZL^-vH2}u*i~|egVZ2ipL4YE1xIn9)q=qO{X+YN\",\n\t\t\t\"#!.-0p(g8}z|kNr'x.pP}OQb9r:oVoAwY$(te'mG#0cl}O/;KRg^Ei$4TR+v:RxIfEnB<$*.iac8]_aKxI+['kMtb3#BK+4OrV]lrZb*3cdop@7e=}+9d#B)s5dLx#_>Er~t$8_D.~8cY+36;eA0;q9/g=ZxrqrqjwWHsmImu_mV3(|*11Z6iYi_Yg&E$r$?^ep1#Gt+$RgIq3U;z^i{6lX.oNHs%0bik~'?tJ%[[{[-jESg=:;k=9Gm4bpQ$z=fQ8YF:'ZKP*.xMK`G1$8+3~`5tv#kNE$VPuFNdJ->t701Y!!$6#I}3t^P^,j&8(24c{:5WRtW+D9!DjX+WM,l,rgx.%rK6\",\n\t\t\t\"#@Y[_pgp>8hl!_8&I^Hr1c61`oYZyfltUCE!,W|OtCk(xIB+UPXiFx`y!~bPiIK^aLH3qs]/=Bzd#|R([_?A&o4sw4/q%B,:1LN!A;bf^TT>ZBefH6:-onGa{M,;sXEkQ+POR1({9H.7LRLBL|(wad6ioG^B/oY.,ZIilztb+RL7@y4K!uKTr>y>F36'b<pPcJ_7]8D=AeLbD<%1|a!+Z`c?i3zI[LV?Or_o$kW*(OB~*_U?}[;L*Z.r5eY_WFAJc[JuJ1?;cAB:qUQb.g-=-i{*V+hOP-Y@JF%ZYw<kg~Y=+#3$z@#[_~wn0ya}lK:k_q{5mA'3tNW6fj97_ngEUn8pUr|YbN\",\n\t\t\t\"#jQ*,]7ea17g{W5f&9W6conksw7+I_u~Yr8~yDyJ9jA32Pf(6.6fx]E;@Q56(Fbf:F8rk+h6eV-.8{Xf^krkQWQGaq>ho'+3Q$ArW63v?6Nt%`+o_vz)'iy=4ZE~MogN(yT'zG2x?BJU?^wwJx,2tbadr|w@B^Fukj/?5DL-5XbToa`D0{nfw!_dcfI'6G<6WZ9Km?+RW4VgsVT]{p.:#m}!~j(KVjQbz!<D-5VDs2/+K#`o;Lwn%U!%hNe?q+rnze.D)U+e/u>u,:^-m/~?~@&YG+>0)bc-x(sLiCohQr?F7sWQ$aozJO;AZL5U=Y#W&R.tXx<lr>Z)P_~<$m*T77dV,C&~bu{\",\n\t\t\t\"$DSmthwzpd;|Y!0N@EwR|<'Gk|:s-kG9K<@p;d^px7&9TXm<N<Jt`Vata=2hbOm=T1?){6xp8[DXvfW^_l+cAb(rt>2-nYrGwjuXy07.+iY?%eC-5x~[aMd0{]VAXl4Bt(y;ntAzr4o6R<xxTIL.,jR9NocyO%xsMR6a>$VI)Nul:cf%<BGZQ0/#Ut}nWyr;QVZ'&@]L5=Y|t!cJXHBCX0`_w&u$`5Iii6.g3%}fWWAp@4R&EVN&ksXYM]s3#P'~g2|AH/F-W.=DzIK1q0Xm$wO6S<>[Z59PNPzB6<cSBpt),4t>kqZk`(7._xvQFQp)ryD&vPW$U^,CDFk4n|;E):Us$s<Gy|Hk\",\n\t\t\t\"%2e[;,B|/Eu/ZE4lNtcjC.R6.fe@z5%2PN<,:D:K)O5vAa,YxM#q{S}A:<DOs/uLs8DB&D^Sx>vxNSM-l.fH,S[lS):qrPY3lb!,g`l'A~Syu|(|0?pjXEY[wZXIOM$;zs??,~g]v0gR~Do3]>6d.4{c($[<Qv^Wiv![/,xru^c=lBuvpq:lbN:0(Or4[|i=pxfT&V:-N<YbgC)M4d*gNI3,!.:IIaA.E=WOUqxwXC,kboWnpgZLN_e9!&g-IP6K)Es3w]Z`V@Y,;>:j>?/d1huGG(aI|?Jc.o6Y#/<tl0zy>_+aJoxiU8%qIPkwPSTmjWt.ngDEk4U8GjT1~Z5hmHX8>wHskb1jo\"};\n\t\n\tstatic String chars = \"!#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~\";\n\tstatic int N = 400;\n\tstatic long mod;\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong b = chars.length();\n\t\tint n = sc.nextInt();\n\t\tmod = sc.nextLong();\n\t\tif(n > 110) {\n\t\t\tchar[] s = vals[n-111].toCharArray();\n\t\t\tlong res = 0;\n\t\t\tfor(char c: s) {\n\t\t\t\tres *= b;\n\t\t\t\tres += chars.indexOf(c);\n\t\t\t\tres %= mod;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\telse {\n\t\t\tc = new long[N+1][N+1];\n\t\t\tc[0][0] = 1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tc[i][0] = 1;\n\t\t\t\tfor(int j = 1; j <= i; j++){\n\t\t\t\t\tc[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdpcl = new long[N+1][N+1];\n\t\t\tdpop = new long[N+1][N+1];\n\t\t\tfor(int i = 0; i <= N; i++){\n\t\t\t\tfor(int j = 0; j <= N; j++){\n\t\t\t\t\tdpcl[i][j] = -1;\n\t\t\t\t\tdpop[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j <= n-1; j++){\n\t\t\t\t\tfor(int a = 0; a <= j; a++) {\n\t\t\t\t\t\tlong leftv = dpop(i, a);\n\t\t\t\t\t\tlong rightv = dpop(n-i-1, j-a);\n\t\t\t\t\t\tlong curr = leftv * rightv % mod;\n\t\t\t\t\t\tlong fac = c[j][a];\n\t\t\t\t\t\tlong v = curr * fac % mod;\n\t\t\t\t\t\tres = (res + v) % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tstatic long[][] c, dpcl, dpop;\n\tstatic long dpcl(int n, int k) {\n\t\tif(dpcl[n][k] >= 0) return dpcl[n][k];\n\t\tif(n == 0 || n == 1) {\n\t\t\tif(k == 0) {\n\t\t\t\treturn dpcl[n][k] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn dpcl[n][k] = 0;\n\t\t\t}\n\t\t}\n\t\tif(k == 0) { // n > 1\n\t\t\treturn dpcl[n][k] = 0;\n\t\t}\n\t\tlong res = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int a = 0; a <= k-1; a++) {\n\t\t\t\tlong leftv = dpcl(i, a);\n\t\t\t\tlong rightv = dpcl(n-i-1, k-1-a);\n\t\t\t\tlong curr = leftv * rightv % mod;\n\t\t\t\tlong fac = c[k-1][a];\n\t\t\t\tlong v = curr * fac % mod;\n\t\t\t\tres = (res + v) % mod;\n\t\t\t}\n\t\t}\n\t\treturn dpcl[n][k] = res;\n\t}\n\tstatic long dpop(int n, int k) {\n\t\tif(dpop[n][k] >= 0) return dpop[n][k];\n\t\tif(n == 0) {\n\t\t\tif(k == 0) {\n\t\t\t\treturn dpop[n][k] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn dpop[n][k] = 0;\n\t\t\t}\n\t\t}\n\t\tif(k == 0) { // n > 0\n\t\t\treturn dpop[n][k] = 0;\n\t\t}\n\t\tlong res = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int a = 0; a <= k-1; a++) {\n\t\t\t\tlong leftv = dpcl(i, a);\n\t\t\t\tlong rightv = dpop(n-i-1, k-1-a);\n\t\t\t\tlong curr = leftv * rightv % mod;\n\t\t\t\tlong fac = c[k-1][a];\n\t\t\t\tlong v = curr * fac % mod;\n\t\t\t\tres = (res + v) % mod;\n\t\t\t}\n\t\t}\n\t\treturn dpop[n][k] = res;\n\t}\n\n}\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1187G extends PrintWriter {\n\tCF1187G() { super(System.out); }\n\tstatic class Scanner {\n\t\tScanner(InputStream in) { this.in = in; } InputStream in;\n\t\tint k, l; byte[] bb = new byte[1 << 15];\n\t\tbyte getc() {\n\t\t\tif (k >= l) {\n\t\t\t\tk = 0;\n\t\t\t\ttry { l = in.read(bb); } catch (IOException e) { l = 0; }\n\t\t\t\tif (l <= 0) return -1;\n\t\t\t}\n\t\t\treturn bb[k++];\n\t\t}\n\t\tint nextInt() {\n\t\t\tbyte c = 0; while (c <= 32) c = getc();\n\t\t\tint a = 0;\n\t\t\twhile (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n\t\t\treturn a;\n\t\t}\n\t}\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1187G o = new CF1187G(); o.main(); o.flush();\n\t}\n\n\tstatic final int INF = 0x3f3f3f3f;\n\tArrayList[] aa_;\n\tint n_, m_;\n\tint[] pi, bb;\n\tint[] uu, vv, uv, cost;\n\tint[] cc;\n\tvoid init() {\n\t\taa_ = new ArrayList[n_];\n\t\tfor (int u = 0; u < n_; u++)\n\t\t\taa_[u] = new ArrayList<Integer>();\n\t\tpi = new int[n_];\n\t\tbb = new int[n_];\n\t\tqq = new int[nq];\n\t\tiq = new boolean[n_];\n\t\tuu = new int[m_];\n\t\tvv = new int[m_];\n\t\tuv = new int[m_];\n\t\tcost = new int[m_];\n\t\tcc = new int[m_ * 2];\n\t\tm_ = 0;\n\t}\n\tvoid link(int u, int v, int cap, int cos) {\n\t\tint h = m_++;\n\t\tuu[h] = u;\n\t\tvv[h] = v;\n\t\tuv[h] = u ^ v;\n\t\tcost[h] = cos;\n\t\tcc[h << 1 ^ 0] = cap;\n\t\taa_[u].add(h << 1 ^ 0);\n\t\taa_[v].add(h << 1 ^ 1);\n\t}\n\tint[] qq;\n\tint nq = 1 << 20, head, cnt;\n\tboolean[] iq;\n\tvoid enqueue(int v) {\n\t\tif (iq[v])\n\t\t\treturn;\n\t\tif (head + cnt == nq) {\n\t\t\tif (cnt * 2 <= nq)\n\t\t\t\tSystem.arraycopy(qq, head, qq, 0, cnt);\n\t\t\telse {\n\t\t\t\tint[] qq_ = new int[nq *= 2];\n\t\t\t\tSystem.arraycopy(qq, head, qq_, 0, cnt);\n\t\t\t\tqq = qq_;\n\t\t\t}\n\t\t\thead = 0;\n\t\t}\n\t\tqq[head + cnt++] = v; iq[v] = true;\n\t}\n\tint dequeue() {\n\t\tint u = qq[head++]; cnt--; iq[u] = false;\n\t\treturn u;\n\t}\n\tboolean spfa(int s, int t) {\n\t\tArrays.fill(pi, INF);\n\t\tpi[s] = 0;\n\t\thead = cnt = 0;\n\t\tenqueue(s);\n\t\twhile (cnt > 0) {\n\t\t\tint u = dequeue();\n\t\t\tArrayList<Integer> adj = aa_[u];\n\t\t\tfor (int h_ : adj)\n\t\t\t\tif (cc[h_] > 0) {\n\t\t\t\t\tint h = h_ >> 1;\n\t\t\t\t\tint p = pi[u] + ((h_ & 1) == 0 ? cost[h] : -cost[h]);\n\t\t\t\t\tint v = u ^ uv[h];\n\t\t\t\t\tif (pi[v] > p) {\n\t\t\t\t\t\tpi[v] = p;\n\t\t\t\t\t\tbb[v] = h_;\n\t\t\t\t\t\tenqueue(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn pi[t] != INF;\n\t}\n\tvoid push(int s, int t) {\n\t\tint c = INF;\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tc = Math.min(c, cc[h_]);\n\t\t}\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_] -= c; cc[h_ ^ 1] += c;\n\t\t}\n\t}\n\tvoid push1(int s, int t) {\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_]--; cc[h_ ^ 1]++;\n\t\t}\n\t}\n\tint edmonds_karp(int s, int t) {\n\t\twhile (spfa(s, t))\n\t\t\tpush1(s, t);\n\t\tint c = 0;\n\t\tfor (int h = 0; h < m_; h++)\n\t\t\tc += cost[h] * cc[h << 1 ^ 1];\n\t\treturn c;\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tint[] ii = new int[k];\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tii[h] = sc.nextInt() - 1;\n\t\tArrayList[] aa = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = new ArrayList<Integer>();\n\t\tfor (int h = 0; h < m; h++) {\n\t\t\tint i = sc.nextInt() - 1;\n\t\t\tint j = sc.nextInt() - 1;\n\t\t\taa[i].add(j);\n\t\t\taa[j].add(i);\n\t\t}\n\t\tint t = n + k + 1;\n\t\tn_ = n * t + 1;\n\t\tm_ = k + (m * 2 * k + n) * (t - 1);\n\t\tinit();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrayList<Integer> adj = aa[i];\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s;\n\t\t\t\tfor (int j : adj) {\n\t\t\t\t\tint v = j * t + s + 1;\n\t\t\t\t\tfor (int x = 1; x <= k; x++)\n\t\t\t\t\t\tlink(u, v, 1, c + (x * 2 - 1) * d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s, v = u + 1;\n\t\t\t\tlink(u, v, k, i == 0 ? 0 : c);\n\t\t\t}\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tlink(n_ - 1, ii[h] * t + 0, 1, 0);\n\t\tprintln(edmonds_karp(n_ - 1, 0 * t + t - 1));\n\t}\n}\n", "complexity": "cubic", "problem": "1187_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class G1 {\n    static int n, T, duration[], type[];\n    static long dp[][][], mod = (long) 1e9 + 7;\n\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Runnable() {\n            public void run() {\n                try {\n                    solveIt();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }, \"Main\", 1 << 28).start();\n    }\n\n    public static void solveIt() throws Exception {\n        Scanner in = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        n = in.nextInt();\n        T = in.nextInt();\n        dp = new long[3][T + 1][1 << n];\n        duration = new int[n];\n        type = new int[n];\n        for (int i = 0; i < n; i++) {\n            duration[i] = in.nextInt();\n            type[i] = in.nextInt() - 1;\n        }\n        for (long a[][] : dp) for (long b[] : a) Arrays.fill(b, -1);\n        pw.println(solve(0, T, 0));\n\n        pw.close();\n    }\n\n    static long solve(int lastType, int rem, int mask) {\n        if (rem == 0) return 1;\n        if (rem < 0) return 0;\n        if (dp[lastType][rem][mask] != -1) return dp[lastType][rem][mask];\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            if (!check(mask, i) && (lastType != type[i] || mask == 0) && rem - duration[i] >= 0) {\n                res += solve(type[i], rem - duration[i], set(mask, i));\n                if (res >= mod) res -= mod;\n            }\n        }\n        return dp[lastType][rem][mask] = res;\n    }\n\n    static boolean check(int N, int pos) {\n        return (N & (1 << pos)) != 0;\n    }\n\n    static int set(int N, int pos) {\n        return N = N | (1 << pos);\n    }\n\n    static int reset(int N, int pos) {\n        return N = N & ~(1 << pos);\n    }\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n}", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class D\n{\n\n\tstatic FastIO f;\n\tstatic long ve[][], he[][];\n\n\tpublic static void main(String args[]) throws IOException\n\t{\n\t\tf = new FastIO();\n\n\t\tint n = f.ni(), m = f.ni(), k = f.ni(), i, j;\n\t\tve = new long[n-1][];\n\t\the = new long[n][];\n\n\t\tlong[][] ans = new long[n][m], pans = new long[n][m], temp;\n\n\t\tfor(i = 0; i < n; i++)\n\t\t\the[i] = f.nla(m-1);\n\n\t\tfor(i = 0; i < n-1; i++)\n\t\t\tve[i] = f.nla(m);\n\n\t\tif(k%2 == 1)\n\t\t{\n\t\t\tfor(i = 0; i < n; i++)\n\t\t\t\tArrays.fill(ans[i], -1L);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk /= 2;\n\n\t\t\twhile(k-->0)\n\t\t\t{\n\t\t\t\tfor(i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(j = 0; j < m; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i][j] = Integer.MAX_VALUE;\n\n\t\t\t\t\t\tif(i != 0)\n\t\t\t\t\t\t\tans[i][j] = Math.min(ans[i][j], pans[i-1][j] + 2*edge(i, j, i-1, j));\n\n\t\t\t\t\t\tif(i != n-1)\n\t\t\t\t\t\t\tans[i][j] = Math.min(ans[i][j], pans[i+1][j] + 2*edge(i, j, i+1, j));\n\n\t\t\t\t\t\tif(j != 0)\n\t\t\t\t\t\t\tans[i][j] = Math.min(ans[i][j], pans[i][j-1] + 2*edge(i, j, i, j-1));\n\n\t\t\t\t\t\tif(j != m-1)\n\t\t\t\t\t\t\tans[i][j] = Math.min(ans[i][j], pans[i][j+1] + 2*edge(i, j, i, j+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// f.err(k + \"\\n\");\n\t\t\t\t// errorprint(ans, n, m);\n\n\t\t\t\ttemp = pans;\n\t\t\t\tpans = ans;\n\t\t\t\tans = temp;\n\t\t\t}\n\n\t\t\ttemp = pans;\n\t\t\tpans = ans;\n\t\t\tans = temp;\n\t\t}\n\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tf.out(ans[i][j] + \" \");\n\t\t\t}\n\n\t\t\tf.out(\"\\n\");\n\t\t}\n\n\t\tf.flush();\n\t}\n\n\tpublic static void errorprint(long[][] p, int n, int m) throws IOException\n\t{\n\t\tint i, j;\n\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tf.err(p[i][j] + \" \");\n\t\t\t}\n\n\t\t\tf.err(\"\\n\");\n\t\t}\n\t\t\n\t\tf.err(\"\\n\");\n\t}\n\n\tpublic static long edge(int i, int j, int x, int y)\n\t{\n\t\tif(i == x)\n\t\t\treturn he[i][Math.min(j, y)];\n\t\telse\n\t\t\treturn ve[Math.min(i, x)][j];\n\t}\n\n\tpublic static class FastIO\n\t{\n\t\tBufferedReader br;\n\t\tBufferedWriter bw, be;\n\t\tStringTokenizer st;\n\n\t\tpublic FastIO()\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t\tbe = new BufferedWriter(new OutputStreamWriter(System.err));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\n\t\tprivate void read() throws IOException\n\t\t{\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t}\n\n\t\tpublic String ns() throws IOException\n\t\t{\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t\tread();\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int ni() throws IOException\n\t\t{\n\t\t\treturn Integer.parseInt(ns());\n\t\t}\n\n\t\tpublic long nl() throws IOException\n\t\t{\n\t\t\treturn Long.parseLong(ns());\n\t\t}\n\n\t\tpublic float nf() throws IOException\n\t\t{\n\t\t\treturn Float.parseFloat(ns());\n\t\t}\n\n\t\tpublic double nd() throws IOException\n\t\t{\n\t\t\treturn Double.parseDouble(ns());\n\t\t}\n\n\t\tpublic char nc() throws IOException\n\t\t{\n\t\t\treturn ns().charAt(0);\n\t\t}\n\n\t\tpublic int[] nia(int n) throws IOException\n\t\t{\n\t\t\tint[] a = new int[n];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\ta[i] = ni();\n\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nla(int n) throws IOException\n\t\t{\n\t\t\tlong[] a = new long[n];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\ta[i] = nl();\n\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[] nca() throws IOException\n\t\t{\n\t\t\treturn ns().toCharArray();\n\t\t}\n\n\t\tpublic void out(String s) throws IOException\n\t\t{\n\t\t\tbw.write(s);\n\t\t}\n\n\t\tpublic void flush() throws IOException\n\t\t{\n\t\t\tbw.flush();\n\t\t\tbe.flush();\n\t\t}\n\n\t\tpublic void err(String s) throws IOException\n\t\t{\n\t\t\tbe.write(s);\n\t\t}\n\t}\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n\npublic class D {\n\n    private static void run() throws IOException {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int p = in.nextInt();\n\n        int[] dx = {1, -1, 0, 0};\n        int[] dy = {0, 0, 1, -1};\n        int[][][] map = new int[n][m][4];\n\n        ArrayList<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m - 1; j++) {\n                int len = in.nextInt();\n                edges.add(new Edge(new Point[]{new Point(i, j), new Point(i, j + 1)}, len));\n                map[i][j][2] = map[i][j + 1][3] = len;\n            }\n        }\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < m; j++) {\n                int len = in.nextInt();\n                edges.add(new Edge(new Point[]{new Point(i, j), new Point(i + 1, j)}, len));\n                map[i][j][0] = map[i + 1][j][1] = len;\n            }\n        }\n        if (p % 2 != 0) {\n            int[] ans = new int[m];\n            for (int i = 0; i < m; i++) {\n                ans[i] = -1;\n            }\n            for (int i = 0; i < n; i++) {\n                print_array(ans);\n            }\n            return;\n        }\n\n        edges.sort(Comparator.comparingInt(o -> o.len));\n\n        int[][][] dp = new int[2][n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int min = Integer.MAX_VALUE;\n                for (int k = 0; k < 4; k++) {\n                    if (map[i][j][k] == 0) continue;\n                    min = Math.min(min, map[i][j][k]);\n                }\n                dp[1][i][j] = min * 2;\n            }\n        }\n\n        for (int k = 2; k <= p / 2; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    dp[k & 1][i][j] = Integer.MAX_VALUE;\n                    for (int d = 0; d < 4; d++) {\n                        int nx = i + dx[d];\n                        int ny = j + dy[d];\n                        if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n\n                        dp[k & 1][i][j] = Math.min(dp[(k - 1) & 1][nx][ny] + map[i][j][d] * 2, dp[k&1][i][j]);\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            print_array(dp[(p / 2) & 1][i]);\n        }\n    }\n\n    static class Edge {\n        Point[] points;\n        int len;\n\n        public Edge(Point[] points, int len) {\n            this.points = points;\n            this.len = len;\n        }\n    }\n\n    static class Point {\n        final int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new Reader();\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n\n//        int t = in.nextInt();\n//        for (int i = 0; i < t; i++) {\n//        }\n        run();\n\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    private static int gcd(int a, int b) {\n        if (a == 0 || b == 0)\n            return 0;\n        while (b != 0) {\n            int tmp;\n            tmp = a % b;\n            a = b;\n            b = tmp;\n        }\n        return a;\n    }\n\n    static final long mod = 1000000007;\n\n    static long pow_mod(long a, long b) {\n        long result = 1;\n        while (b != 0) {\n            if ((b & 1) != 0) result = (result * a) % mod;\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return result;\n    }\n\n    private static long multiplied_mod(long... longs) {\n        long ans = 1;\n        for (long now : longs) {\n            ans = (ans * now) % mod;\n        }\n        return ans;\n    }\n\n    @SuppressWarnings(\"FieldCanBeLocal\")\n    private static Reader in;\n    private static PrintWriter out;\n\n    private static void print_array(int[] array) {\n        for (int now : array) {\n            out.print(now);\n            out.print(' ');\n        }\n        out.println();\n    }\n\n    private static void print_array(long[] array) {\n        for (long now : array) {\n            out.print(now);\n            out.print(' ');\n        }\n        out.println();\n    }\n\n    static class Reader {\n        private static final int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            final byte[] buf = new byte[1024]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    break;\n                }\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextSign() throws IOException {\n            byte c = read();\n            while ('+' != c && '-' != c) {\n                c = read();\n            }\n            return '+' == c ? 0 : 1;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        public int skip() throws IOException {\n            int b;\n            // noinspection ALL\n            while ((b = read()) != -1 && isSpaceChar(b)) {\n                ;\n            }\n            return b;\n        }\n\n        public char nc() throws IOException {\n            return (char) skip();\n        }\n\n        public String next() throws IOException {\n            int b = skip();\n            final StringBuilder sb = new StringBuilder();\n            while (!isSpaceChar(b)) { // when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) {\n                buffer[0] = -1;\n            }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) {\n                fillBuffer();\n            }\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            din.close();\n        }\n\n    }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.fill;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class E {\n\n\tstatic void solve() throws Exception {\n\t\tint tests = scanInt();\n//\t\tint tests = 40;\n\t\tfor (int test = 0; test < tests; test++) {\n\t\t\tint n = scanInt(), m = scanInt(), a[][] = new int[n][m];\n//\t\t\tint n = 12, m = 2000, a[][] = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\ta[i][j] = scanInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bestCols[] = new int[min(m, n)];\n\t\t\tfor (int i = 0; i < bestCols.length; i++) {\n\t\t\t\tbestCols[i] = i;\n\t\t\t}\n\t\t\tif (m > n) {\n\t\t\t\tint bestColMax[] = new int[n];\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint cmax = 0;\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tcmax = max(cmax, a[j][i]);\n\t\t\t\t\t}\n\t\t\t\t\tbestColMax[i] = cmax;\n\t\t\t\t}\n\t\t\t\tfor (int i = n; i < m; i++) {\n\t\t\t\t\tint cmax = 0;\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tcmax = max(cmax, a[j][i]);\n\t\t\t\t\t}\n\t\t\t\t\tint minBC = 0, minBCM = Integer.MAX_VALUE;\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (bestColMax[j] < minBCM) {\n\t\t\t\t\t\t\tminBC = j;\n\t\t\t\t\t\t\tminBCM = bestColMax[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cmax > minBCM) {\n\t\t\t\t\t\tbestCols[minBC] = i;\n\t\t\t\t\t\tbestColMax[minBC] = cmax;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint dyn[] = new int[1 << n], dynNext[] = new int[1 << n], sums[] = new int[1 << n], csums[] = new int[1 << n];\n\t\t\tfor (int i: bestCols) {\n\t\t\t\tfill(dynNext, 0);\n\t\t\t\tfill(sums, 0);\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 1, bit = 0; k < 1 << n; k++) {\n\t\t\t\t\t\tif (k == 1 << (bit + 1)) {\n\t\t\t\t\t\t\t++bit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsums[k] = max(sums[k], csums[k] = csums[k ^ (1 << bit)] + a[(bit + j) % n][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int mask1 = 0; mask1 < 1 << n; mask1++) {\n\t\t\t\t\tint cdyn = dynNext[mask1];\n\t\t\t\t\tfor (int mask2 = mask1;; mask2 = (mask2 - 1) & mask1) {\n\t\t\t\t\t\tcdyn = max(cdyn, dyn[mask2] + sums[mask1 ^ mask2]);\n\t\t\t\t\t\tif (mask2 == 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdynNext[mask1] = cdyn;\n\t\t\t\t}\n\t\t\t\tint t[] = dyn;\n\t\t\t\tdyn = dynNext;\n\t\t\t\tdynNext = t;\n\t\t\t}\n\t\t\tout.println(dyn[(1 << n) - 1]);\n\t\t}\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeSet;\n\npublic class r568p8{\n\n    private static InputReader sc;\n    private static PrintWriter pw;\n    private static long mod;\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n\n        InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        long nextLong() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        String readString() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        String nextLine() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void main(String args[]) {\n        sc = new InputReader(System.in);\n        pw = new PrintWriter(System.out);\n\n        int t = 1;\n        while(t-->0)\n            solve();\n\n        pw.flush();\n        pw.close();\n    }\n\n    private static void fill_matrix(long dp[][][][], int a, int b, int c, int end){\n\n        if((a == 0 && b == 0 && c == 0) || (a == 0 && end == 0) || (b == 0 && end == 1) || (c == 0 && end == 2)){\n            dp[a][b][c][end] = 0;\n            return;\n        }\n\n        if(a > 1 && b == 0 && c == 0){\n            dp[a][b][c][end] = 0;\n            return;\n        }\n\n        if(b > 1 && a == 0 && c == 0){\n            dp[a][b][c][end] = 0;\n            return;\n        }\n\n        if(c > 1 && a == 0 && b == 0){\n            dp[a][b][c][end] = 0;\n            return;\n        }\n\n        if(a == 1 && end == 0 && b == 0 && c == 0){\n            dp[a][b][c][end] = 1;\n            return;\n        }\n        if(b == 1 && end == 1 && a == 0 && c == 0){\n            dp[a][b][c][end] = 1;\n            return;\n        }\n        if(c == 1 && end == 2 && b == 0 && a == 0){\n            dp[a][b][c][end] = 1;\n            return;\n        }\n\n        if(end == 0){\n            fill_matrix(dp, a-1, b, c, 1);\n            fill_matrix(dp, a-1, b, c, 2);\n\n            dp[a][b][c][0] = (dp[a-1][b][c][1]%mod + dp[a-1][b][c][2]%mod)%mod;\n        }\n        else if(end == 1){\n            fill_matrix(dp, a, b-1, c, 0);\n            fill_matrix(dp, a, b-1, c, 2);\n\n            dp[a][b][c][1] = (dp[a][b-1][c][0]%mod + dp[a][b-1][c][2]%mod)%mod;\n        }\n        else{\n            fill_matrix(dp, a, b, c-1, 0);\n            fill_matrix(dp, a, b, c-1, 1);\n\n            dp[a][b][c][2] = (dp[a][b][c-1][0]%mod + dp[a][b][c-1][1]%mod)%mod;\n        }\n    }\n\n    private static long cal(int count[]){\n        int a = count[0], b = count[1], c = count[2];\n        long dp[][][][] = new long[a+1][b+1][c+1][3];\n\n        long factorial[] = new long[20];\n\n        factorial[0] = 1;\n        factorial[1] = 1;\n\n        for(int i=2; i<20; i++)\n            factorial[i] = (factorial[i-1]%mod*i%mod)%mod;\n\n        fill_matrix(dp, a, b, c, 0);\n        fill_matrix(dp, a, b, c, 1);\n        fill_matrix(dp, a, b, c, 2);\n\n         long p = (dp[a][b][c][0]%mod + dp[a][b][c][1]%mod + dp[a][b][c][2]%mod)%mod;\n\n         long ans = (((p%mod * factorial[a]%mod)%mod * factorial[b]%mod)%mod * factorial[c]%mod)%mod;\n\n         return ans;\n    }\n\n    private static void solve(){\n        int n = sc.nextInt(), T = sc.nextInt();\n\n        int len[] = new int[n], genre[] = new int[n];\n\n        for(int i=0; i<n; i++){\n            len[i] = sc.nextInt();\n            genre[i] = sc.nextInt();\n        }\n\n        int sum[] = new int[(1<<n)];\n\n        mod = (long)1e9 + 7;\n        long ans = 0;\n\n        for(int i=1; i<(1<<n); i++){\n            for(int j=0; j<15; j++){\n                if((i&(1<<j)) != 0){\n                    sum[i] = sum[i^(1<<j)] + len[j];\n                    break;\n                }\n            }\n\n            if(sum[i] == T) {\n                int count[] = {0, 0, 0};\n\n                for (int j = 0; j < 15; j++) {\n                    if ((i & (1 << j)) != 0)\n                        count[genre[j] - 1]++;\n                }\n\n                ans = (ans % mod + cal(count) % mod) % mod;\n            }\n        }\n\n        pw.println(+ans);\n    }\n}", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.util.*;\nimport java.math.*;\n\npublic\tclass task\n{\n\tpublic static void\tmain(String args[])\n\t{\n\t\tScanner a = new Scanner(System.in);\n\t\t\n\t\twhile(a.hasNext())\n\t\t{\n\t\t\tint n = a.nextInt();\n\t\t\tint m = a.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t    \n\t\t\tboolean[][] adj = new boolean[n][n];\n\t\t\tlong res = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tint x = a.nextInt();\n\t\t\t\tint y = a.nextInt();\n\t\t\t\tadj[x - 1][y - 1] = true;\n\t\t\t\tadj[y - 1][x - 1] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; ++i) \n\t\t\t\tfor (int j = i + 1; j < n; ++j) \n\t\t\t\t\tif (adj[i][j]) \n\t\t\t\t\t\t--res;\n\t\t\t\t\t\t\n\t\t\tfor (int i = 0; i < n; ++i) \n\t\t\t{\n\t\t\t\tlong[][] dp = new long[n - i][1 << (n - i)];\n\t\t\t\tdp[0][0] = 1;\n\t\t\t\tfor (int mask = 0; mask < (1 << (n - i)); ++mask) \n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < n - i; ++j) \n\t\t\t\t\t{\n\t\t\t\t\t\tif (dp[j][mask] != 0) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int k = 0; k < n - i; ++k) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (((mask >> k) & 1) == 0 && adj[j + i][k + i]) \n\t\t\t\t\t\t\t\t\tdp[k][mask | (1 << k)] += dp[j][mask];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (((mask >> 0) & 1) != 0) {\n\t\t\t\t\t\tres += dp[0][mask];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res/2);\n\t\t}\n\t}\n}\n\t", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.IOException;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class ProblemE {\n    public static int w, h;\n    \n    public static int MAX = 9999999;\n    \n    public static Set<Integer> result = new HashSet<Integer>();\n    \n    public static void dfs(int n, int m, int mask) {\n        if (n >= w) {\n            result.add(mask);\n            return;\n        }\n        if (m >= 1) {\n            dfs(n+1, m, mask|(1<<n));\n        }\n        if (m <= h - 2) {\n            dfs(n+1, m, mask|(1<<(n+w*2)));\n        }\n        if (n >= 1) {\n            dfs(n+1, m, mask|(1<<((n-1)+w)));\n        }\n        if (n <= w - 2) {\n            dfs(n+1, m, mask|(1<<((n+1)+w)));\n        }\n        dfs(n+1, m, mask|(1<<(n+w)));\n    }\n    \n    public static void main(String[] args) throws IOException {\n        Scanner s = new Scanner(System.in);\n        String[] line = s.nextLine().split(\" \");\n        w = Integer.valueOf(line[0]);\n        h = Integer.valueOf(line[1]);\n        if (w == 6 && h == 6) {\n            System.out.println(26);\n            return;\n        }\n        if (w == 5 && h == 8) {\n            System.out.println(29);\n            return;\n        }\n        if (w == 5 && h == 7) {\n            System.out.println(26);\n            return;\n        }\n        if (w == 5 && h == 6) {\n            System.out.println(22);\n            return;\n        }\n        if (w == 5 && h == 5) {\n            System.out.println(18);\n            return;\n        }\n        if (w > h) {\n            int tmp = w;\n            w = h;\n            h = tmp;\n        }\n    \n        int[][] dp = new int[h+1][1<<(w*3)];\n        for (int i = 0 ; i <= h ; i++) {\n            for (int j = 0 ; j < 1<<(w*3) ; j++) {\n                dp[i][j] = MAX;\n            }\n        }\n        dp[0][0] = 0;\n        \n        \n        for (int i = 0 ; i < h ; i++) {\n            result.clear();\n            dfs(0, i, 0);\n            for (int j = 0 ; j < 1<<(w*2) ; j++) {\n                if (dp[i][j] != MAX) {\n                    for (int res : result) {\n                        int next = (res | j);\n                        int nextn = next >> w;\n                        int add = Integer.bitCount(next & ((1<<w) - 1));\n                        dp[i+1][nextn] = Math.min(dp[i+1][nextn], dp[i][j] + add);\n                    }\n                }\n            }\n        }\n        \n\n        int answer = MAX;\n        for (int j = 0 ; j < 1<<(w*2) ; j++) {\n            answer = Math.min(answer, dp[h][j] + Integer.bitCount(j));\n        }\n        System.out.println(h * w - answer);\n    }\n}", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class C {\n\n\tstatic int[] nm;\n\tstatic int ans = 0;\n\tstatic int rows, cols;\n\tstatic boolean[][] cae;\n\tstatic int[][] ca;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnm = readIntArray();\n\t\trows = Math.max(nm[0], nm[1]);\n\t\tcols = Math.min(nm[0], nm[1]);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tcae = new boolean[1000][50];\n\t\tca = new int[1000][50];\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < cols; i++) {\n\t\t\tsb.append('1');\n\t\t}\n\t\tint startingState = Integer.parseInt(sb.toString(), 3);\n\t\tans = solve(startingState, 0);\n\n\t\tSystem.out.println(nm[0]*nm[1] - ans);\n//\t\tSystem.out.println(System.currentTimeMillis() - s );\n\t}\n\n\tstatic int solve(int state, int row) {\n\t\tif (row == rows) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (cae[state][row]) {\n\t\t\treturn ca[state][row];\n\t\t}\n\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < Math.pow(3, cols); i++) {\n\t\t\tboolean isCover = covers(i, state);\n\t\t\tif (isCover && (row < rows - 1 || coversTotally(i, state))) {\n\t\t\t\tint p = placed(i);\n\t\t\t\tint s = solve(i, row + 1);\n\t\t\t\tans = Math.min(ans, s + p);\n\t\t\t}\n\t\t}\n\n\t\tcae[state][row] = true;\n\t\tca[state][row] = ans;\n\n\t\treturn ans;\n\t}\n\n\tprivate static boolean coversTotally(int i, int state) {\n\t\t\t\n\t\tString bottom = decode(i);\n\t\tfor (int j = 0; j < bottom.length(); j++) {\n\t\t\tif (bottom.charAt(j) == '0') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static boolean covers(int i, int state) {\n\t\tString top = decode(state);\n\t\tString bottom = decode(i);\n\n\t\tfor (int j = 0; j < top.length(); j++) {\n\t\t\tif (top.charAt(j) == '0' && bottom.charAt(j) != '2') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (top.charAt(j) == '2' && bottom.charAt(j) == '0') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < top.length(); j++) {\n\t\t\tif (bottom.charAt(j) == '1' && (top.charAt(j) != '2' && !(j > 0 && bottom.charAt(j-1) == '2') && !(j < top.length() - 1 && bottom.charAt(j+1) == '2'))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static int placed(int i) {\n\t\tString s = decode(i);\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < s.length(); j++) {\n\t\t\tif (s.charAt(j) == '2') {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\treturn cnt;\n\t}\n\n\tprivate static String decode(int state) {\t\t\n\t\tString tmp = Integer.toString(state, 3);\n\t\tif (tmp.length() < cols) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < cols - tmp.length(); i++) {\n\t\t\t\tsb.append('0');\n\t\t\t}\t\t\n\t\t\tsb.append(tmp);\n\t\t\treturn sb.toString();\n\t\t} else {\n\t\t\treturn tmp;\n\t\t}\t\t\n\t}\n\n\tstatic int countDispositionDivisors(int[] d) {\n\t\tHashSet<Integer> div = new HashSet<Integer>();\n\t\tfor (int i = 1; i <= d.length; i++) {\n\t\t\tfor (int j = 0; j < d.length; j++) {\n\t\t\t\tif ((j + 1) % i == 0 && d[j] % i == 0) {\n\t\t\t\t\tdiv.add(j + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn div.size();\n\t}\n\n\tstatic InputStreamReader isr = new InputStreamReader(System.in);\n\tstatic BufferedReader br = new BufferedReader(isr);\n\n\tstatic int[] readIntArray() throws IOException {\n\t\tString[] v = br.readLine().split(\" \");\n\t\tint[] ans = new int[v.length];\n\n\t\tfor (int i = 0; i < ans.length; i++) {\n\t\t\tans[i] = Integer.valueOf(v[i]);\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tstatic long[] readLongArray() throws IOException {\n\t\tString[] v = br.readLine().split(\" \");\n\t\tlong[] ans = new long[v.length];\n\n\t\tfor (int i = 0; i < ans.length; i++) {\n\t\t\tans[i] = Long.valueOf(v[i]);\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tstatic <T> void print(List<T> v) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\tif (sb.length() > 0) {\n\t\t\t\tsb.append(' ');\n\t\t\t}\n\n\t\t\tsb.append(v.get(i));\n\t\t}\n\n\t\tSystem.out.println(sb);\n\t}\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
