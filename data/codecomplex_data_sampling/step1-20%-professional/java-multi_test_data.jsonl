{"src": "//Codeforces\n// package codeNcode.binarySearch;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n//    public static int n, s;\n\n    public static Long F(long x){\n        return x-sumOfDigits(x);\n    }\n\n    private static long sumOfDigits(long x) {\n        long sum = 0;\n        while(x!=0){\n            long rem = x%10;\n            sum+=rem;\n            x/=10;\n        }\n        return sum;\n    }\n\n    public static long bSearch(long x,long s){\n        long l=10,h=x;\n        long ans = -1;\n        while(l<=h){\n            long mid=(l+h)/2;\n            long a = F(mid);\n            long b = F(mid-1);\n            if(a>=s && b<s){\n                ans = mid;\n                break;\n            }\n            else if (a<s)\n                l = mid+1;\n            else\n                h = mid - 1;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] in = br.readLine().split(\" \");\n        long n = Long.parseLong(in[0]);\n        long s = Long.parseLong(in[1]);\n        if(n<10)\n            System.out.println(0);\n        else\n        {\n            if(F(n)<s){\n                System.out.println(0);\n            }\n            else {\n                long y = bSearch(n,s);\n                System.out.println(n-y+1);\n            }\n        }\n    }\n}\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\n/**\n __                  __\n ( _)                ( _)\n / / \\\\              / /\\_\\_\n / /   \\\\            / / | \\ \\\n / /     \\\\          / /  |\\ \\ \\\n /  /   ,  \\ ,       / /   /|  \\ \\\n /  /    |\\_ /|      / /   / \\   \\_\\\n /  /  |\\/ _ '_| \\   / /   /   \\    \\\\\n |  /   |/  0 \\0\\    / |    |    \\    \\\\\n |    |\\|      \\_\\_ /  /    |     \\    \\\\\n |  | |/    \\.\\ o\\o)  /      \\     |    \\\\\n \\    |     /\\\\`v-v  /        |    |     \\\\\n | \\/    /_| \\\\_|  /         |    | \\    \\\\\n | |    /__/_ `-` /   _____  |    |  \\    \\\\\n \\|    [__]  \\_/  |_________  \\   |   \\    ()\n /    [___] (    \\         \\  |\\ |   |   //\n |    [___]                  |\\| \\|   /  |/\n /|    [____]                  \\  |/\\ / / ||\n (  \\   [____ /     ) _\\      \\  \\    \\| | ||\n \\  \\  [_____|    / /     __/    \\   / / //\n |   \\ [_____/   / /        \\    |   \\/ //\n |   /  '----|   /=\\____   _/    |   / //\n __ /  /        |  /   ___/  _/\\    \\  | ||\n (/-(/-\\)       /   \\  (/\\/\\)/  |    /  | /\n (/\\/\\)           /   /   //\n _________/   /    /\n \\____________/    (\n\n\n @author NTUDragons-Reborn\n */\n\npublic class C{\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(in, out);\n        out.close();\n    }\n    // main solver\n    static class Task{\n\n        double eps= 0.00000001;\n        static final int MAXN = 10000001;\n\n        // stores smallest prime factor for every number\n        static int spf[] = new int[MAXN];\n\n        Map<Integer,Set<Integer>> dp= new HashMap<>();\n\n        // Calculating SPF (Smallest Prime Factor) for every\n        // number till MAXN.\n        // Time Complexity : O(nloglogn)\n        public void sieve()\n        {\n            spf[1] = 1;\n            for (int i=2; i<MAXN; i++)\n\n                // marking smallest prime factor for every\n                // number to be itself.\n                spf[i] = i;\n\n            // separately marking spf for every even\n            // number as 2\n            for (int i=4; i<MAXN; i+=2)\n                spf[i] = 2;\n\n            for (int i=3; i*i<MAXN; i++)\n            {\n                // checking if i is prime\n                if (spf[i] == i)\n                {\n                    // marking SPF for all numbers divisible by i\n                    for (int j=i*i; j<MAXN; j+=i)\n\n                        // marking spf[j] if it is not\n                        // previously marked\n                        if (spf[j]==j)\n                            spf[j] = i;\n                }\n            }\n        }\n\n        // A O(log n) function returning primefactorization\n        // by dividing by smallest prime factor at every step\n        public Set<Integer> getFactorization(int x)\n        {\n            if(dp.containsKey(x)) return dp.get(x);\n            Set<Integer> ret = new HashSet<>();\n            while (x != 1)\n            {\n                if(spf[x]!=2) ret.add(spf[x]);\n                x = x / spf[x];\n            }\n            dp.put(x,ret);\n            return ret;\n        }\n        // function to find first index >= x\n        public int lowerIndex(List<Integer> arr, int n, int x)\n        {\n            int l = 0, h = n - 1;\n            while (l <= h)\n            {\n                int mid = (l + h) / 2;\n                if (arr.get(mid) >= x)\n                    h = mid - 1;\n                else\n                    l = mid + 1;\n            }\n            return l;\n        }\n\n        // function to find last index <= y\n        public int upperIndex(List<Integer> arr, int n, int y)\n        {\n            int l = 0, h = n - 1;\n            while (l <= h)\n            {\n                int mid = (l + h) / 2;\n                if (arr.get(mid) <= y)\n                    l = mid + 1;\n                else\n                    h = mid - 1;\n            }\n            return h;\n        }\n\n        // function to count elements within given range\n        public int countInRange(List<Integer> arr, int n, int x, int y)\n        {\n            // initialize result\n            int count = 0;\n            count = upperIndex(arr, n, y) -\n                    lowerIndex(arr, n, x) + 1;\n            return count;\n        }\n        InputReader in;\n        PrintWriter out;\n        public void solve(InputReader in, PrintWriter out) {\n            this.in=in;\n            this.out=out;\n            int t=in.nextInt();\n            while(t-->0){\n                int n= in.nextInt();\n                int[] arr= new int[n];\n                for(int i=0;i<n;i++) arr[i]= in.nextInt();\n                int[] cur= new int[n];\n                int idx=0;\n                for(int num: arr){\n                    if(idx<n && num==cur[idx]+1){\n                        cur[idx]=num;\n                        printRes(cur, idx);\n                        idx++;\n                    }\n                    else{\n                        for(int i=idx;i>=0;i--){\n                            if(i<n && num!=cur[i]+1) cur[i]=0;\n                            else{\n                                cur[i]=num;\n                                printRes(cur,i);\n                                i++;\n                                idx=i;\n                                break;\n                            }\n                        }\n                    }\n\n                }\n            }\n        }\n\n        public void printRes(int[] cur, int idx){\n            for(int i=0;i<idx;i++) out.print(cur[i]+\".\");\n            out.println(cur[idx]);\n        }\n\n        public boolean ok(char[] s){\n            boolean allEqual = true;\n            boolean Alternate = true;\n            for (int i = 0; i < s.length - 1; i++){\n                if (s[i]!=s[i+1]){\n                    allEqual = false;\n                }\n                else{\n                    Alternate = false;\n                }\n            }\n            if (s[0] == '0' || s[s.length-1] == '0'){\n                return false;\n            }\n            return allEqual || Alternate;\n        }\n\n        // private int cal()\n        public static boolean nextPermutation(char[] array){\n            boolean hasNext = false;\n            int i;\n            for(i = array.length-2; i >= 0; i--){\n                if(array[i] < array[i+1]){\n                    hasNext = true;\n                    break;\n                }\n            }\n             \n            if(!hasNext){// If all elements are arranged from largest to smallest, it means the largest string\n                return false;\n            }\n             \n            // Find backward from the subscript of i + 1 (must be monotonically decreasing), find a smallest element in the set larger than array [i]\n            int j;\n            for(j = i+1; j < array.length; j++){\n                if(array[j] <= array[i]){\n                    break;\n                }\n            }\n            j--;\n             \n            // Swap these two elements, and then reverse all the elements in i + 1 and later (i + 1, array.length)\n            swap(array, i, j);\n            reverse(array, i+1, array.length);\n       \n            return true;\n        }\n        public static void swap(char[] array, int i, int j) {\n            char temp =array[i];\n            array[i] = array[j];\n            array[j] =temp;\t\n        }\n        public static void reverse(char[] array, int start, int end){\n            for(int i = start, j = end-1; i < j; i++, j--) {\n                swap(array, i, j);\n            }\n        }\n\n        public static class compareL implements Comparator<Tuple>{\n            @Override\n            public int compare(Tuple t1, Tuple t2) {\n                return t2.l - t1.l;\n            }\n        }\n        public static class compareR implements Comparator<Tuple>{\n            @Override\n            public int compare(Tuple t1, Tuple t2) {\n                return t1.r - t2.r;\n            }\n        }\n        public static class Tuple{\n            public int l, r, w;\n            public Tuple(int l, int r,int w){\n                this.l = l; this.r= r;\n                this.w =w;\n            }\n        }\n        public static class Range implements Comparable<Range>{\n            public int l, r;\n            List<Integer> data;\n            int weight;\n            public Range(int l, int r, List<Integer> data){\n                this.data = data;\n                this.l = l; this.r =r;\n                this.weight = (int)1e9;\n            }\n\n            @Override\n            public int compareTo(Range o) {\n                return this.l - o.l;\n            }\n        }\n        public int _gcd(int a,  int  b)\n        {\n\n            if(b == 0) {\n                return a;\n            }\n            else {\n                return _gcd(b, a % b);\n            }\n        }\n\n    }\n\n    static class Tuple implements Comparable<Tuple>{\n        int x, y, z;\n        public Tuple(int x, int y, int z){\n            this.x= x;\n            this.y= y;\n            this.z=z;\n        }\n        @Override\n        public int compareTo(Tuple o){\n            return this.x-o.x;\n        }\n    }\n\n    static class Pair implements Comparable<Pair>{\n        public int x;\n        public int y;\n        public Pair(int x, int y){\n            this.x= x;\n            this.y= y;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            return this.x-o.x;\n        }\n    }\n    // fast input reader class;\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (line == null) {\n                    return null;\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(nextToken());\n        }\n        public long nextLong(){\n            return Long.parseLong(nextToken());\n        }\n    }\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.util.Scanner;\n\npublic class C {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int len = s.nextInt();\n        s.nextLine();\n        String l = s.nextLine();\n        char[] ca = l.toCharArray();\n        int h = 0;\n        for (char c : ca)\n            h += A(c);\n        int cur = h;\n        int i;\n        for (i = 0; i < h; i++)\n            cur -= A(ca[i]);\n        int best = cur;\n        while (i != h + len) {\n            cur -= A(ca[i % len]);\n            cur += A(ca[(i - h) % len]);\n            best = best > cur ? cur : best;\n            i++;\n        }\n        System.out.println(best);\n    }\n\n    public static int A(char x) {\n        return x == 'H' ? 1 : 0;\n    }\n}\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class cf {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        pw.println(n/2+1);\n        pw.close();\n    }\n}", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.Scanner;\n\npublic class A {\n    public static void main(String args[]){\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        String str=sc.next();\n        boolean b=false;\n        int ind=-1;\n        for(int i=1;i<n;i++){\n            if(str.substring(i).equals(str.substring(0,n-i))){\n                b=true;\n                ind=i;\n                break;\n            }\n        }\n        if(ind==-1)\n        {\n            String ss=str;\n            for(int i=1;i<k;i++){\n                str+=ss;\n            }\n        }else{\n            String ss=str.substring(n-ind);\n            for(int i=1;i<k;i++){\n                str+=ss;\n            }\n        }\n        System.out.println(str);\n    }\n}\n", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] ar = new int[n];\n            for (int i = 0; i < n; i++)\n                ar[i] = in.nextInt();\n            Arrays.sort(ar);\n            boolean[] u = new boolean[n];\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (!u[i]) {\n                    u[i] = true;\n                    ans++;\n                    for (int j = 0; j < n; j++) {\n                        if (!u[j] && ar[j] % ar[i] == 0) {\n                            u[j] = true;\n                        }\n                    }\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n\npublic class a{ \n     static int[] count,count1,count2;\n     static Node[] nodes;\n     static long[] arr;\n     static int[] dp,arrInt,darrInt;\n     static char[] ch,ch1;\n     static long[] darr,farr;\n     static char[][] mat,mat1;\n     static int[][] space;\n     static boolean[][] vis;\n     static long x,h;\n     static long maxl;\n     static double dec;\n     static long mx = (long)1e10;\n     static String s,s1,s2,s3,s4;\n     static long minl;\n     static int start_row;\n     static int start_col;     \n     static int end_row;     \n     static int end_col;     \n     static long mod = 998244353;\n     // static int minl = -1;\n     // static long n;\n     static int n,n1,n2,q,r1,c1,r2,c2;\n     static long a;\n     static long b;\n     static long c;\n     static long d;\n     static long y,z;\n     static int m;\n     static long k;\n     static FastScanner sc;\n     static String[] str,str1;\n     static Set<Long> set,set1,set2;\n     static SortedSet<Long> ss;\n     static List<Long> list,list1,list2,list3;\n     static PriorityQueue<Integer> pq,pq1;\n     static LinkedList<Node> ll;\n     static Map<Integer,List<Integer>> map1;\n     static Map<Long,Integer> map;\n     static StringBuilder sb,sb1,sb2;\n     static int index;\n     static long[] sum;\n     static int[] dx = {0,-1,0,1,-1,1,-1,1};\n     static int[] dy = {-1,0,1,0,-1,-1,1,1};\n\n     // public static void solve(){\n\n     //    FastScanner sc = new FastScanner();\n     //    // int t = sc.nextInt();\n     //    int t = 1;\n     //    for(int tt = 0 ; tt < t ; tt++){\n\n     //        // s = sc.next();\n     //        // s1 = sc.next();\n\n     //        n = sc.nextInt();\n     //        // m = sc.nextInt();\n     //        sb = new StringBuilder();\n     //        // map = new HashMap<>();\n     //        // q = sc.nextInt();\n     //        // k = sc.nextLong();\n     //        // ch = sc.next().toCharArray();\n     //        // boolean ans = false;\n     //        // int charge = n;\n     //        // int prev = 0;\n\n     //        count = new int[7];\n           \n     //        // m = sc.nextInt();\n     //        // long ans = 0;\n     //        // long added = 0;\n     //        for(int j = 0 ; j < n ; j++){\n\n\n     //        }\n\n     //    }\n        \n     // }\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n\n     public static void solve(){\n\n        int zeros = 0;\n        int pos = -1;\n        for(int i = 0 ; i < n ; i++){\n            if(ch[i] == '0'){\n                zeros += 1;\n            }\n            else if(pos == -1){\n                pos = i;\n            }\n        }\n\n        if(pos == -1){\n            System.out.println(\"0\");\n            return;\n        }\n\n        sb = new StringBuilder();\n        sb.append(\"1\");\n\n        for(int i = pos+1 ; i <= pos+zeros ; i++){\n            sb.append(\"0\");\n        }\n        System.out.println(sb);\n\n     }\n        \n     public static void main(String[] args) {\n\n            sc = new FastScanner();\n            // Scanner sc = new Scanner(System.in);\n            // int t = sc.nextInt();\n            int t = 1;\n            // int l = 1;\n            while(t > 0){\n                \n                // n = sc.nextInt();\n                // n = sc.nextLong();\n                // k = sc.nextLong();\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // z = sc.nextLong();\n\n                // a = sc.nextLong();\n                // b = sc.nextLong();\n                // c = sc.nextLong();\n                // d = sc.nextLong();\n\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // z = sc.nextLong();\n                // d = sc.nextLong();\n                // n = sc.nextLong();\n\n                n = sc.nextInt();\n\n                // n = 3;\n                // n1 = sc.nextInt();\n\n                // m = sc.nextInt();\n                // q = sc.nextInt();\n\n                // k = sc.nextLong();\n                // d = sc.nextLong();\n                // s = sc.next();\n\n                ch = sc.next().toCharArray();\n                // ch1 = sc.next().toCharArray();\n\n                // n = 3;\n                // arr = new long[n];\n                // for(int i = 0 ; i < n ; i++){\n                //     arr[i] = sc.nextLong();\n                // }\n\n                // arrInt = new int[n];\n                // for(int i = 0 ; i < n ; i++){\n                //     arrInt[i] = sc.nextInt();\n                // }\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // ch = sc.next().toCharArray();\n                // m = n;\n                // darr = new long[m];\n                // for(int i = 0 ; i < m ; i++){\n                //     darr[i] = sc.nextLong();\n                // }\n\n                // m = n;\n                // darrInt = new int[m];\n                // for(int i = 0 ; i < m ; i++){\n                //     darrInt[i] = sc.nextInt();\n                // }\n\n                // farr = new int[n];\n                // for(int i = 0; i < n ; i++){\n                //     farr[i] = sc.nextInt();\n                // }\n\n                // mat = new long[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat[i][j] = sc.nextLong();\n                //     }\n                // }\n\n                // m = n;\n                // mat = new char[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     String s = sc.next();\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat[i][j] = s.charAt(j);\n                //     }\n                // }\n\n                // m = n;\n                // mat1 = new char[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     String s = sc.next();\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat1[i][j] = s.charAt(j);\n                //     }\n                // }\n\n                // n= 5 ;\n                // str = new String[n];\n                // for(int i = 0 ; i < n ; i++)\n                //     str[i] = sc.next();\n\n                // nodes = new Node[n];\n                // for(int i = 0 ; i < n ;i++)\n                //     nodes[i] = new Node(sc.nextInt(),(i+1));\n\n                // m = sc.nextInt();\n\n                // System.out.println(solve()?\"YES\":\"NO\");\n                 solve();       \n                 // System.out.println(solve());\n                 t -= 1;\n            }\n\n     }\n\n     // public static dfs(int i){\n\n     //    if(count[i] == 1)\n     //        return;\n     //    list = map.get(i);\n     //    for(Integer j : list){\n     //        if(j == i)\n     //            continue;\n     //        dfs(j);\n     //    }\n     // }\n\n    public static int log(long n,long base){\n\n         if(n == 0 || n == 1)\n             return 0;\n\n         if(n == base)\n             return 1;\n\n         double num = Math.log(n);\n         double den = Math.log(base);\n\n         if(den == 0)\n             return 0;\n\n         return (int)(num/den);\n     }\n\n    public static boolean isPrime(long n) { \n    // Corner cases \n        if (n <= 1)  \n            return false; \n\n        if (n <= 3)  \n            return true; \n      \n        // This is checked so that we can skip  \n        // middle five numbers in below loop \n        if (n%2 == 0 || n%3 == 0) \n            return false; \n      \n        for (int i=5; i*i<=n; i=i+6) \n            if (n%i == 0 || n%(i+2) == 0) \n               return false; \n      \n        return true; \n    } \n\n    public static long gcd(long a, long b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b); \n    }\n\n     public static long mod_inverse(long a,long mod){\n        long x1=1,x2=0;\n        long p=mod,q,t;\n        while(a%p!=0){\n          q = a/p;\n          t = x1-q*x2;\n          x1=x2; x2=t;\n          t=a%p;\n          a=p; p=t;\n        }\n        return x2<0 ? x2+mod : x2;\n    }\n\n     public static void swap(int i,int j){\n         long temp = arr[j];\n         arr[j] = arr[i];\n         arr[i] = temp;\n     } \n\n    static final Random random=new Random();\n\n    static void ruffleSortLong(long[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            long temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSortInt(int[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            int temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n    \n    static void ruffleSortChar(char[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            char temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class Node{\n        Integer first;\n        Integer second;\n        Node(Integer f,Integer s){\n            this.first = f;\n            this.second = s;\n        }\n    }\n\n     static class FastScanner {\n\n                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n                StringTokenizer st=new StringTokenizer(\"\");\n                String next() {\n                        while (!st.hasMoreTokens())\n                                try {\n                                        st=new StringTokenizer(br.readLine());\n                                } catch (IOException e) {\n                                        e.printStackTrace();\n                                }\n                        return st.nextToken();\n                }\n                \n                int nextInt() {\n                        return Integer.parseInt(next());\n                }\n                int[] readArray(int n) {\n                        int[] a=new int[n];\n                        for (int i=0; i<n; i++) a[i]=nextInt();\n                        return a;\n                }\n                long nextLong() {\n                        return Long.parseLong(next());\n                }\n        }\n\n}", "complexity": "linear", "problem": "0976_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "//package codeforces;\n\n\n\nimport java.io.BufferedReader;\n\nimport java.io.Closeable;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.Comparator;\n\nimport java.util.HashMap;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.StringTokenizer;\n\nimport java.util.TreeMap;\n\nimport java.util.TreeSet;\n\n\n\npublic class B implements Closeable {\n\n    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n    PrintWriter writer = new PrintWriter(System.out);\n\n    StringTokenizer stringTokenizer;\n\n\n\n    B() throws IOException {\n\n//        reader = new BufferedReader(new FileReader(\"cycle2.in\"));\n\n//        writer = new PrintWriter(new FileWriter(\"cycle2.out\"));\n\n    }\n\n\n\n    String next() throws IOException {\n\n        while (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n\n            stringTokenizer = new StringTokenizer(reader.readLine());\n\n        }\n\n        return stringTokenizer.nextToken();\n\n    }\n\n\n\n    int nextInt() throws IOException {\n\n        return Integer.parseInt(next());\n\n    }\n\n\n\n    long nextLong() throws IOException {\n\n        return Long.parseLong(next());\n\n    }\n\n\n\n    double nextDouble() throws IOException {\n\n        return Double.parseDouble(next());\n\n    }\n\n\n\n    final int MOD = 1000 * 1000 * 1000 + 9;\n\n\n\n    int sum(int a, int b) {\n\n        a += b;\n\n        return a >= MOD ? a - MOD : a;\n\n    }\n\n\n\n    int product(int a, int b) {\n\n        return (int) (1l * a * b % MOD);\n\n    }\n\n\n\n    @SuppressWarnings(\"unchecked\")\n\n    void solve() throws IOException {\n\n        nextInt();\n\n        char[] s = next().toCharArray();\n\n        char[] t = next().toCharArray();\n\n        int[][] p = new int[26][26];\n\n        int d = 0;\n\n        for(int i = 0; i < s.length; i++) {\n\n            if(s[i] != t[i]) {\n\n                d++;\n\n                p[s[i] - 'a'][t[i] - 'a'] = i + 1;\n\n            }\n\n        }\n\n        for(int i = 0; i < 26; i++) {\n\n            for(int j = i + 1; j < 26; j++) {\n\n                if(p[i][j] > 0 && p[j][i] > 0) {\n\n                    writer.println(d - 2);\n\n                    writer.println(p[i][j] + \" \" + p[j][i]);\n\n                    return;\n\n                }\n\n            }\n\n        }\n\n        for(int i = 0; i < 26; i++) {\n\n            int to = 0;\n\n            int from = 0;\n\n            for(int j = 0; j < 26; j++) {\n\n                if(p[i][j] > 0) {\n\n                    to = p[i][j];\n\n                }\n\n                if(p[j][i] > 0) {\n\n                    from = p[j][i];\n\n                }\n\n            }\n\n            if(from > 0 && to > 0) {\n\n                writer.println(d - 1);\n\n                writer.println(from + \" \" + to);\n\n                return;\n\n            }\n\n        }\n\n        writer.println(d);\n\n        writer.println(\"-1 -1\");\n\n    }\n\n\n\n    public static void main(String[] args) throws IOException {\n\n        try(B b = new B()) {\n\n            b.solve();\n\n        }\n\n    }\n\n\n\n    @Override\n\n    public void close() throws IOException {\n\n        reader.close();\n\n        writer.close();\n\n    }\n\n}\n\n", "complexity": "linear", "problem": "0527_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class A {\n\n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void solve() throws IOException {\n\t\tfinal int mod = 1000*1000*1000+9;\n\t\tlong n = readInt();\n\t\tlong m = readInt();\n\t\tlong k = readInt();\n\t\tlong fail = n-m;\n\t\tlong posl = n / k ;\n\t\tif(n % k != 0) {\n\t\t\tposl++;\n\t\t}\n\t\tif(posl <= fail) {\n\t\t\tout.println(m);\n\t\t} else {\n\t\t\tlong d = fail - posl;\n\t\t\tlong res = (k-1) * fail;\n\t\t\tm -= (k-1) * fail;\n\t\t\tlong z = m / k;\n\t\t\tres += m % k;\n\t\t\tres %= mod;\n\t\t\tlong x = binpow(2, z+1, mod);\n\t\t\tx -= 2;\n\t\t\tx += mod;\n\t\t\tx %= mod;\n\t\t\tx *= k;\n\t\t\tres += x;\n\t\t\tres %= mod;\n\t\t\tout.println(res);\n\t\t}\n    }\n\n\tlong binpow (long a, long n, long mod) {\n\t\tlong res = 1;\n\t\twhile (n != 0)\n\t\t\tif ((n & 1) != 0) {\n\t\t\t\tres *= a;\n\t\t\t\tres = res % mod;\n\t\t\t\t--n;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta *= a;\n\t\t\t\ta = a % mod;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\treturn res;\n\t}\n\n    void init() throws FileNotFoundException {\n        if (ONLINE_JUDGE) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    int[] readArr(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = readInt();\n        }\n        return res;\n    }\n\n    long[] readArrL(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = readLong();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        new A().run();\n    }\n\n    public void run() {\n        try {\n            long t1 = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \" + (t2 - t1));\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n}", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;\nimport java.io.IOException;import java.io.PrintStream;import java.io.PrintWriter;\nimport java.security.AccessControlException;import java.util.Arrays;import java.util.Collection;\nimport java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Objects;\nimport java.util.Scanner;import java.util.TreeMap;import java.util.function.Function;\nimport java.util.stream.Collectors;import java.util.stream.IntStream;import java.util.stream.LongStream;\nimport java.util.stream.Stream;public class _p000084A {static public void main(final String[] args) \nthrows IOException{p000084A._main(args);}\nstatic private class p000084A extends Solver{public p000084A(){nameIn=\"in/900/p000084A.in\";\nsingleTest=true;}@Override public void solve()throws IOException{int n=sc.nextInt();\nif(sc.hasNextLine()){sc.nextLine();}pw.println(n/2*3);}static public void _main(String[]\nargs)throws IOException{new p000084A().run();}}static private class Pair<K,V>{private \nK k;private V v;public Pair(final K t,final V u){this.k=t;this.v=u;}public K getKey()\n{return k;}public V getValue(){return v;}}static private abstract class Solver{protected \nString nameIn=null;protected String nameOut=null;protected boolean singleTest=false;\nprotected boolean preprocessDebug=false;protected boolean doNotPreprocess=false;\nprotected PrintStream debugPrintStream=null;protected Scanner sc=null;protected \nPrintWriter pw=null;final static String SPACE=\" \";final static String SPACES=\"\\\\s+\";\nprivate void process()throws IOException{if(!singleTest){int t=lineToIntArray()[0];\nwhile(t-->0){solve();}}else{solve();}}abstract protected void solve()throws IOException;\nprotected String[]lineToArray()throws IOException{return sc.nextLine().trim().split(SPACES);\n}protected int[]lineToIntArray()throws IOException{return Arrays.stream(lineToArray()).mapToInt(Integer::valueOf).toArray();\n}protected long[]lineToLongArray()throws IOException{return Arrays.stream(lineToArray()).mapToLong(Long::valueOf).toArray();\n}protected void run()throws IOException{boolean done=false;try{if(nameIn!=null && \nnew File(nameIn).exists()){try(FileInputStream fis=new FileInputStream(nameIn);PrintWriter \npw0=select_output();){done=true;sc=new Scanner(fis);pw=pw0;process();}}}catch(IOException \nex){}catch(AccessControlException ex){}if(!done){try(PrintWriter pw0=select_output();\n){sc=new Scanner(System.in);pw=pw0;process();}}}private PrintWriter select_output()\nthrows FileNotFoundException{if(nameOut!=null){return new PrintWriter(nameOut);}\nreturn new PrintWriter(System.out);}public static Map<Integer,List<Integer>>mapi(final \nint[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<Integer,List<Integer>>(),\n(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static Map<Long,List<Integer>>\nmapi(final long[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<Long,\nList<Integer>>(),(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final T[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<T,List<Integer>>(),\n(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final T[]a,Comparator<T>cmp){return IntStream.range(0,a.length).collect(()->\nnew TreeMap<T,List<Integer>>(cmp),(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],\nStream.of(i).collect(Collectors.toList()));}else{res.get(a[i]).add(i);}},Map::putAll\n);}public static Map<Integer,List<Integer>>mapi(final IntStream a){int[]i=new int[]{0};\nreturn a.collect(()->new TreeMap<Integer,List<Integer>>(),(res,v)->{if(!res.containsKey(v))\n{res.put(v,Stream.of(i[0]).collect(Collectors.toList()));}else{res.get(v).add(i[0]);\n}i[0]++;},Map::putAll);}public static Map<Long,List<Integer>>mapi(final LongStream \na){int[]i=new int[]{0};return a.collect(()->new TreeMap<Long,List<Integer>>(),(res,\nv)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}i[0]++;},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final Stream<T>a,Comparator<T>cmp){int[]i=new int[]{0};return a.collect(()->\nnew TreeMap<T,List<Integer>>(cmp),(res,v)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final Stream<T>a){int[]i=new int[]{0};return a.collect(()->new TreeMap<T,List<Integer>>(),\n(res,v)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}},Map::putAll);}public static List<int[]>listi(final \nint[]a){return IntStream.range(0,a.length).mapToObj(i->new int[]{a[i],i}).collect(Collectors.toList());\n}public static List<long[]>listi(final long[]a){return IntStream.range(0,a.length).mapToObj(i\n->new long[]{a[i],i}).collect(Collectors.toList());}public static<T>List<Pair<T,\nInteger>>listi(final T[]a){return IntStream.range(0,a.length).mapToObj(i->new Pair<T,\nInteger>(a[i],i)).collect(Collectors.toList());}public static List<int[]>listi(final \nIntStream a){int[]i=new int[]{0};return a.mapToObj(v->new int[]{v,i[0]++}).collect(Collectors.toList());\n}public static List<long[]>listi(final LongStream a){int[]i=new int[]{0};return \na.mapToObj(v->new long[]{v,i[0]++}).collect(Collectors.toList());}public static<T>\nList<Pair<T,Integer>>listi(final Stream<T>a){int[]i=new int[]{0};return a.map(v->\nnew Pair<T,Integer>(v,i[0]++)).collect(Collectors.toList());}public static String \njoin(final int[]a){return Arrays.stream(a).mapToObj(Integer::toString).collect(Collectors.joining(SPACE));\n}public static String join(final long[]a){return Arrays.stream(a).mapToObj(Long::toString).collect(Collectors.joining(SPACE));\n}public static<T>String join(final T[]a){return Arrays.stream(a).map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final T[]a,final Function<T,String>toString){return \nArrays.stream(a).map(v->toString.apply(v)).collect(Collectors.joining(SPACE));}public \nstatic<T>String join(final Collection<T>a){return a.stream().map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Collection<T>a,final Function<T,String>toString)\n{return a.stream().map(v->toString.apply(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Stream<T>a){return a.map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Stream<T>a,final Function<T,String>toString){\nreturn a.map(v->toString.apply(v)).collect(Collectors.joining(SPACE));}public static\n<T>String join(final IntStream a){return a.mapToObj(Integer::toString).collect(Collectors.joining(SPACE));\n}public static<T>String join(final LongStream a){return a.mapToObj(Long::toString).collect(Collectors.joining(SPACE));\n}public static List<Integer>list(final int[]a){return Arrays.stream(a).mapToObj(Integer::valueOf).collect(Collectors.toList());\n}public static List<Integer>list(final IntStream a){return a.mapToObj(Integer::valueOf).collect(Collectors.toList());\n}public static List<Long>list(final long[]a){return Arrays.stream(a).mapToObj(Long::valueOf).collect(Collectors.toList());\n}public static List<Long>list(final LongStream a){return a.mapToObj(Long::valueOf).collect(Collectors.toList());\n}public static<T>List<T>list(final Stream<T>a){return a.collect(Collectors.toList());\n}public static<T>List<T>list(final T[]a){return Arrays.stream(a).collect(Collectors.toList());\n}}}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\n \npublic class Solution_1 {\n\tpublic static void main(String[] args) {\n//\t\tsolution start :-)\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s1 = sc.next();\n\t\tString s2 = sc.next();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(s1.charAt(0));\n\t\tfor(int i=1;i<s1.length();i++){\n\t\t    if(s1.charAt(i)<s2.charAt(0)){\n\t\t        sb.append(s1.charAt(i));\n\t\t    }\n\t\t    else break;\n\t\t}\n\t\tsb.append(s2.charAt(0));\n\t\tSystem.out.println(sb.toString());\n//\t\tsolution end \\(^-^)/\n//\t\t                |\n//\t\t               / \\\n\t\t}\n\t}", "complexity": "linear", "problem": "0909_A", "from": "CODEFORCES", "tags": "brute force,greedy,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class main {\n\tInputStream is;\n\tPrintWriter out;\n\tstatic long mod=pow(10,9)+7;\n\tint dx[]= {0,0,1,-1},dy[]={+1,-1,0,0};\n\tvoid solve()\n\t{\n\t\tlong x=nl();\n\t\tlong k=nl();\n\t\tif(x==0)\n\t\t{\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tlong term=(pow(2,k,mod))%mod;\n\t\tlong last=((x%mod)*pow(2,k+1,mod))%mod;\n\t\tlong sumdom=((2*last)%mod+(((term-1+mod)%mod)*((-2+mod)%mod))%mod)%mod;\n\t\tsumdom=(sumdom*term)%mod;\n\t\tsumdom=(sumdom*pow(2,mod-2,mod))%mod;\n\t\tsumdom=(sumdom*pow(term,mod-2,mod))%mod;\n\t\tout.println(sumdom);\n\t\t\t\t\n\t}\n\tint bsdown(ArrayList<Integer> al,int l) {\n\t\tint low=0,high=al.size()-1,ans=-1;\n\t\twhile(low<=high) {\n\t\t\tint mid=low+(high-low)/2;\n\t\t\tif(al.get(mid)<=l) {\n\t\t\t\tlow=mid+1;\n\t\t\t\tans=mid;\n\t\t\t}else\n\t\t\t\thigh=mid-1;\t\t\t\n\t\t}\n\t\treturn ans;\n\t}\n\tArrayList<Integer>al [];\n\tvoid take(int n,int m)\n\t{\n\t\tal=new ArrayList[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tal[i]=new ArrayList<Integer>();\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint x=ni()-1;\n\t\t\tint y=ni()-1;\n\t\t\tal[x].add(y);\n\t\t\tal[y].add(x);\n\t\t\t\n\t\t}\n\t}\n\tint arr[][];\n\tint small[];\n\tvoid pre(int n)\n\t{\n\t\tsmall=new int[n+1];\n\t\tfor(int i=2;i*i<=n;i++)\n\t\t{\n\t\t\tfor(int j=i;j*i<=n;j++)\n\t\t\t{\n\t\t\t\tif(small[i*j]==0)\n\t\t\t\t\tsmall[i*j]=i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tif(small[i]==0)\n\t\t\t\tsmall[i]=i;\n\t\t}\n\t}\n\tpublic static int count(long x)\n\t{\n\t\tint num=0;\n\t\twhile(x!=0)\n\t\t{\n\t\t\tx=x&(x-1);\n\t\t\tnum++;\n\t\t}\n\t\treturn num;\n\t}\n\tstatic long d, x, y;\n\tvoid extendedEuclid(long A, long B) {\n\t    if(B == 0) {\n\t        d = A;\n\t        x = 1;\n\t        y = 0;\n\t    }\n\t    else {\n\t        extendedEuclid(B, A%B);\n\t        long temp = x;\n\t        x = y;\n\t        y = temp - (A/B)*y;\n\t    }\n\t}\n\tlong modInverse(long A,long M) //A and M are coprime\n\t{\n\t    extendedEuclid(A,M);\n\t    return (x%M+M)%M;    //x may be negative\n\t}\n\tpublic static void mergeSort(int[] arr, int l ,int r){\n\t\tif((r-l)>=1){\n\t\t\tint mid = (l+r)/2;\n\t\t\tmergeSort(arr,l,mid);\n\t\t\tmergeSort(arr,mid+1,r);\n\t\t\tmerge(arr,l,r,mid);\n\t\t}\n\t}\n\tpublic static void merge(int arr[], int l, int r, int mid){\n\t\tint n1 = (mid-l+1), n2 = (r-mid);\n\t\tint left[] = new int[n1];\n\t\tint right[] = new int[n2];\n\t\tfor(int i =0 ;i<n1;i++) left[i] = arr[l+i];\n\t\tfor(int i =0 ;i<n2;i++) right[i] = arr[mid+1+i];\n\t\tint i =0, j =0, k = l;\n\t\twhile(i<n1 && j<n2){\n\t\t\tif(left[i]>right[j]){\n\t\t\t\tarr[k++] = right[j++];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarr[k++] = left[i++];\n\t\t\t}\n\t\t}\n\t\twhile(i<n1) arr[k++] = left[i++];\n\t\twhile(j<n2) arr[k++] = right[j++];\n\t}\n\tpublic static void mergeSort(long[] arr, int l ,int r){\n\t\tif((r-l)>=1){\n\t\t\tint mid = (l+r)/2;\n\t\t\tmergeSort(arr,l,mid);\n\t\t\tmergeSort(arr,mid+1,r);\n\t\t\tmerge(arr,l,r,mid);\n\t\t}\n\t}\n\tpublic static void merge(long arr[], int l, int r, int mid){\n\t\tint n1 = (mid-l+1), n2 = (r-mid);\n\t\tlong left[] = new long[n1];\n\t\tlong right[] = new long[n2];\n\t\tfor(int i =0 ;i<n1;i++) left[i] = arr[l+i];\n\t\tfor(int i =0 ;i<n2;i++) right[i] = arr[mid+1+i];\n\t\tint i =0, j =0, k = l;\n\t\twhile(i<n1 && j<n2){\n\t\t\tif(left[i]>right[j]){\n\t\t\t\tarr[k++] = right[j++];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarr[k++] = left[i++];\n\t\t\t}\n\t\t}\n\t\twhile(i<n1) arr[k++] = left[i++];\n\t\twhile(j<n2) arr[k++] = right[j++];\n\t}\n\t static class Pair implements Comparable<Pair>{\n\t\t \n\t      long x;\n\t      long y,k;\n\t      int i,h;\n\t      String s;\n\t\tPair (long x,long y,int i){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.i=i;\n\t\t}\n\t        \n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(this.x!=o.x)\n\t\t\t\treturn Long.compare(this.x,o.x);\n\t\t\treturn Long.compare(this.y,o.y);\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Pair) {\n\t\t\t\tPair p = (Pair)o;\n\t\t\t\treturn p.x == x && p.y == y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic int hashCode() {\n\t\t\treturn new Long(x).hashCode()*31 + new Long(y).hashCode() ;\n\t\t}\n\t           \n\t \n\t        @Override\n\t        public String toString() {\n\t            return  \"(\"+x + \" \" + y +\" \"+k+\" \"+i+\" )\";\n\t        }\n\t    \n\t    } \n\t    \n\t    public static boolean isPal(String s){\n\t        for(int i=0, j=s.length()-1;i<=j;i++,j--){\n\t                if(s.charAt(i)!=s.charAt(j)) return false;\n\t        }\n\t        return true;\n\t    }\n\t    public static String rev(String s){\n\t\t\tStringBuilder sb=new StringBuilder(s);\n\t\t\tsb.reverse();\n\t\t\treturn sb.toString();\n\t    }\n\t    \n\t    public static long gcd(long x,long y){\n\t\tif(x%y==0)\n\t\t\treturn y;\n\t\telse\n\t\t\treturn gcd(y,x%y);\n\t    }\n\t    \n\t    public static int gcd(int x,int y){\n\t    \tif(y==0) \n\t    \t\treturn x; \n\t    \treturn gcd(y,x%y);\n\t    }\n\t    \n\t    public static long gcdExtended(long a,long b,long[] x){\n\t        \n\t        if(a==0){\n\t            x[0]=0;\n\t            x[1]=1;\n\t            return b;\n\t        }\n\t        long[] y=new long[2];\n\t        long gcd=gcdExtended(b%a, a, y);\n\t        \n\t        x[0]=y[1]-(b/a)*y[0];\n\t        x[1]=y[0];\n\t        \n\t        return gcd;\n\t    }\n\t    \n\t    public static int abs(int a,int b){\n\t\treturn (int)Math.abs(a-b);\n\t    }\n\t \n\t    public static long abs(long a,long b){\n\t\treturn (long)Math.abs(a-b);\n\t    }\n\t    \n\t    public static int max(int a,int b){\n\t\tif(a>b)\n\t\t\treturn a;\n\t\telse\n\t\t\treturn b;\n\t    }\n\t \n\t    public static int min(int a,int b){\n\t\tif(a>b)\n\t\t\treturn b;\n\t\telse \n\t\t\treturn a;\n\t    }\n\t    \n\t    public static long max(long a,long b){\n\t\tif(a>b)\n\t\t\treturn a;\n\t\telse\n\t\t\treturn b;\n\t    }\n\t \n\t    public static long min(long a,long b){\n\t\tif(a>b)\n\t\t\treturn b;\n\t\telse \n\t\t\treturn a;\n\t    }\n\t \n\t    public static long pow(long n,long p,long m){\n\t\t long  result = 1;\n\t\t  if(p==0)\n\t\t    return 1;\n\t\tif (p==1)\n\t\t    return n;\n\t\twhile(p!=0)\n\t\t{\n\t\t    if(p%2==1)\n\t\t        result *= n;\n\t\t    if(result>=m)\n\t\t    result%=m;\n\t\t    p >>=1;\n\t\t    n*=n;\n\t\t    if(n>=m)\n\t\t    n%=m;\n\t\t}\n\t\treturn result;\n\t    }\n\t    \n\t    public static long pow(long n,long p){\n\t\tlong  result = 1;\n\t\t  if(p==0)\n\t\t    return 1;\n\t\tif (p==1)\n\t\t    return n;\n\t\twhile(p!=0)\n\t\t{\n\t\t    if(p%2==1)\n\t\t        result *= n;\t    \n\t\t    p >>=1;\n\t\t    n*=n;\t    \n\t\t}\n\t\treturn result;\n\t    }\n\t    public static void debug(Object... o) {\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t\t}\n\t    void run() throws Exception {\n\t\t\tis = System.in;\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t   \n\t    public static void main(String[] args) throws Exception {\n\t\t\tnew Thread(null, new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnew main().run();\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, \"1\", 1 << 26).start();\n\n\t\t}\n\t    private byte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\t \n\t\tprivate int readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\t \n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\t \n\t\tprivate int skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b));\n\t\t\treturn b;\n\t\t}\n\t \n\t\tprivate double nd() {\n\t\t\treturn Double.parseDouble(ns());\n\t\t}\n\t \n\t\tprivate char nc() {\n\t\t\treturn (char) skip();\n\t\t}\n\t \n\t\tprivate String ns() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t \n\t\tprivate char[] ns(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\t \n\t\tprivate char[][] nm(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = ns(m);\n\t\t\treturn map;\n\t\t}\n\t \n\t\tprivate int[] na(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = ni();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tprivate long[] nl(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nl();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tprivate int ni() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t \n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t \n\t\tprivate long nl() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t \n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t \n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class World_Cup {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next(){\n            while(st==null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt(){\n            return Integer.parseInt(next());\n        }\n        long nextLong(){\n            return Long.parseLong(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }catch (IOException e){\n                e.printStackTrace();\n            }\n            return str;\n        }\n        double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader in = new FastReader();\n        int n = in.nextInt();\n        int arr[] = new int[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = in.nextInt();\n        }\n        int brr[] = new int [n];\n        for(int i = 0; i < n; i++){\n            brr[i] += arr[i]/n;\n            if(i >= (arr[i] % n)){\n                brr[i]+=1;\n            }else{\n                brr[i]+=2;\n            }\n        }\n        int ans = brr[0];\n        int ind = 0;\n        for(int i = 1; i < n; i++){\n            if(ans > brr[i] ){\n                ans = brr[i];\n                ind = i;\n            }\n        }\n        ind++;\n        System.out.println(ind);\n    }\n}\n", "complexity": "linear", "problem": "0996_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class E {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tArrayList<Integer>[][] nexts = new ArrayList[13][];\t\t\n\t\tArrayList<Integer>[] bs = new ArrayList[13];\n\t\tint[][] index = new int[13][];\n\t\tint[][] eqcl = new int[13][];\n\t\tfor(int n = 1; n <= 12; n++) {\n\t\t\teqcl[n] = new int[(1 << n)];\n\t\t\tbs[n] = new ArrayList<Integer>();\n\t\t\tindex[n] = new int[(1 << n)];\n\t\t\tint ind = 0;\n\t\t\tfor(int mask = 0; mask < (1 << n); mask++) {\n\t\t\t\tboolean add = true;\n\t\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\t\tif(rot(mask, k, n) < mask) add = false;\n\t\t\t\t}\n\t\t\t\tif(add) {\n\t\t\t\t\tbs[n].add(mask);\n\t\t\t\t\tindex[n][mask] = ind; ind++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnexts[n] = new ArrayList[bs[n].size()];\n\t\t\tfor(int i = 0; i < bs[n].size(); i++) {\n\t\t\t\tint mask = bs[n].get(i);\n\t\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\t\teqcl[n][rot(mask, k, n)] = mask;\n\t\t\t\t}\n\t\t\t\tnexts[n][i] = new ArrayList<>();\n\t\t\t\tfor(int y = 0; y < (1 << n); y++) {\n\t\t\t\t\tif((mask & y) == 0) {\n\t\t\t\t\t\tnexts[n][i].add(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint T = Integer.parseInt(br.readLine());\n\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tfor(int test = 0; test < T; test++) {\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\tint n = Integer.parseInt(st.nextToken());\n\t\t\tint m = Integer.parseInt(st.nextToken());\n\t\t\tint[][] arrt = new int[m][n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\t\tarrt[j][i] = Integer.parseInt(st.nextToken());\n\t\t\t\t}\n\t\t\t}\n\t\t\tColumn[] cols = new Column[m];\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tcols[j] = new Column(arrt[j]);\n\t\t\t}\n\t\t\tArrays.sort(cols, Collections.reverseOrder());\n\t\t\tm = Integer.min(n, m);\n\t\t\tint[][] arr = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\t\tarr[i][j] = cols[j].arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] max = new int[m][bs[n].size()];\n\t\t\tfor(int c = 0; c < m; c++) {\n\t\t\t\tfor(int mask = 0; mask < (1 << n); mask++) {\n\t\t\t\t\tint curr = 0;\n\t\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\t\tif((mask & (1 << i)) > 0) curr += arr[i][c];\n\t\t\t\t\t}\n\t\t\t\t\tint cl = eqcl[n][mask];\n\t\t\t\t\tmax[c][index[n][cl]] = Integer.max(max[c][index[n][cl]], curr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[m+1][bs[n].size()];\n\t\t\tfor(int c = 0; c < m; c++) {\n\t\t\t\tfor(int i = 0; i < bs[n].size(); i++) {\n\t\t\t\t\tint mask = bs[n].get(i);\n\t\t\t\t\tfor(int next: nexts[n][i]) {\n\t\t\t\t\t\tint cl = eqcl[n][next];\n\t\t\t\t\t\tint dl = eqcl[n][mask | next];\n\t\t\t\t\t\tif(dp[c][i] + max[c][index[n][cl]] > dp[c+1][index[n][dl]]) {\n\t\t\t\t\t\t\tdp[c+1][index[n][dl]] = dp[c][i] + max[c][index[n][cl]]; \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbw.write(dp[m][bs[n].size() - 1]+\"\\n\");\n\t\t}\n\t\tbw.flush();\n\t}\n\tstatic int rot(int x, int k, int n) {\n\t\tint a = x << k;\n\t\tint b = x >> (n - k);\n\t\treturn (a + b) & ((1 << n) - 1);\n\t}\n\tstatic class Column implements Comparable<Column>{\n\t\tint[] arr;\n\t\tint max;\n\t\tpublic Column(int[] arr) {\n\t\t\tthis.arr = arr;\n\t\t\tmax = 0;\n\t\t\tfor(int k: arr) {\n\t\t\t\tmax = Integer.max(max, k);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Column col) {\n\t\t\treturn max - col.max;\n\t\t}\n\t}\n}\n", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        int kisu = 0;\n        int gusu = 0;\n        for(int i = 0 ; i < n ; i++){\n            nums[i] = sc.nextInt();\n            if(nums[i] % 2 == 0)gusu++;\n            if(nums[i] % 2 == 1)kisu++;\n        }\n        int ans = -1;\n        if(gusu == 1){\n            for(int i = 0 ; i < n ; i++){\n                if(nums[i]%2 == 0){\n                    ans = i+1;\n                    break;\n                }\n            }\n        }\n        else{\n            for(int i = 0 ; i < n ; i++){\n                if(nums[i]%2 == 1){\n                    ans = i+1;\n                    break;\n                }\n            }\n            \n        }\n        System.out.println(ans);\n    }\n\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n    thread.start();\n    thread.join();\n  }\n\n  static class TaskAdapter implements Runnable {\n    @Override\n      public void run() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastInput in = new FastInput(inputStream);\n        FastOutput out = new FastOutput(outputStream);\n        FElongatedMatrix solver = new FElongatedMatrix();\n        solver.solve(1, in, out);\n        out.close();\n      }\n  }\n\n  static class FElongatedMatrix {\n    public void solve(int testNumber, FastInput in, FastOutput out) {\n      int n = in.readInt();\n      int m = in.readInt();\n      int[][] mat = new int[n][m];\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n          mat[i][j] = in.readInt();\n        }\n      }\n\n      int[][] minDist = new int[n][n];\n      SequenceUtils.deepFill(minDist, (int) 1e9);\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          for (int k = 0; k < m; k++) {\n            minDist[i][j] = Math.min(minDist[i][j], Math.abs(mat[i][k] - mat[j][k]));\n          }\n        }\n      }\n      int[][] minDistBetweenHeadAndTail = new int[n][n];\n      SequenceUtils.deepFill(minDistBetweenHeadAndTail, (int) 1e9);\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          for (int k = 1; k < m; k++) {\n            minDistBetweenHeadAndTail[i][j] = Math.min(minDistBetweenHeadAndTail[i][j], Math.abs(mat[i][k] - mat[j][k - 1]));\n          }\n        }\n      }\n\n      Log2 log2 = new Log2();\n      BitOperator bo = new BitOperator();\n      int[][][] dp = new int[1 << n][n][n];\n      for (int i = 1; i < (1 << n); i++) {\n        if (i == Integer.lowestOneBit(i)) {\n          dp[i][log2.floorLog(i)][log2.floorLog(i)] = (int) 1e9;\n          continue;\n        }\n        for (int j = 0; j < n; j++) {\n          for (int k = 0; k < n; k++) {\n            if (bo.bitAt(i, j) == 0) {\n              continue;\n            }\n            for (int t = 0; t < n; t++) {\n              dp[i][j][k] = Math.max(dp[i][j][k],\n                  Math.min(dp[bo.setBit(i, j, false)][t][k],\n                    minDist[j][t]));\n            }\n          }\n        }\n      }\n\n      int ans = 0;\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          ans = Math.max(ans, Math.min(dp[(1 << n) - 1][i][j], minDistBetweenHeadAndTail[j][i]));\n        }\n      }\n      out.println(ans);\n    }\n\n  }\n\n  static class SequenceUtils {\n    public static void deepFill(Object array, int val) {\n      if (!array.getClass().isArray()) {\n        throw new IllegalArgumentException();\n      }\n      if (array instanceof int[]) {\n        int[] intArray = (int[]) array;\n        Arrays.fill(intArray, val);\n      } else {\n        Object[] objArray = (Object[]) array;\n        for (Object obj : objArray) {\n          deepFill(obj, val);\n        }\n      }\n    }\n\n  }\n\n  static class Log2 {\n    public int floorLog(int x) {\n      return 31 - Integer.numberOfLeadingZeros(x);\n    }\n\n  }\n\n  static class FastInput {\n    private final InputStream is;\n    private byte[] buf = new byte[1 << 13];\n    private int bufLen;\n    private int bufOffset;\n    private int next;\n\n    public FastInput(InputStream is) {\n      this.is = is;\n    }\n\n    private int read() {\n      while (bufLen == bufOffset) {\n        bufOffset = 0;\n        try {\n          bufLen = is.read(buf);\n        } catch (IOException e) {\n          bufLen = -1;\n        }\n        if (bufLen == -1) {\n          return -1;\n        }\n      }\n      return buf[bufOffset++];\n    }\n\n    public void skipBlank() {\n      while (next >= 0 && next <= 32) {\n        next = read();\n      }\n    }\n\n    public int readInt() {\n      int sign = 1;\n\n      skipBlank();\n      if (next == '+' || next == '-') {\n        sign = next == '+' ? 1 : -1;\n        next = read();\n      }\n\n      int val = 0;\n      if (sign == 1) {\n        while (next >= '0' && next <= '9') {\n          val = val * 10 + next - '0';\n          next = read();\n        }\n      } else {\n        while (next >= '0' && next <= '9') {\n          val = val * 10 - next + '0';\n          next = read();\n        }\n      }\n\n      return val;\n    }\n\n  }\n\n  static class BitOperator {\n    public int bitAt(int x, int i) {\n      return (x >> i) & 1;\n    }\n\n    public int setBit(int x, int i, boolean v) {\n      if (v) {\n        x |= 1 << i;\n      } else {\n        x &= ~(1 << i);\n      }\n      return x;\n    }\n\n  }\n\n  static class FastOutput implements AutoCloseable, Closeable {\n    private StringBuilder cache = new StringBuilder(10 << 20);\n    private final Writer os;\n\n    public FastOutput(Writer os) {\n      this.os = os;\n    }\n\n    public FastOutput(OutputStream os) {\n      this(new OutputStreamWriter(os));\n    }\n\n    public FastOutput println(int c) {\n      cache.append(c).append('\\n');\n      return this;\n    }\n\n    public FastOutput flush() {\n      try {\n        os.append(cache);\n        os.flush();\n        cache.setLength(0);\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n      return this;\n    }\n\n    public void close() {\n      flush();\n      try {\n        os.close();\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n    }\n\n    public String toString() {\n      return cache.toString();\n    }\n\n  }\n}\n", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\n\npublic class Solution implements Runnable {\n\t\n\tpublic static void main(String[] args) {\n\t\t(new Thread(new Solution())).start();\n\t}\n\t\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st;\n\t\n\tString nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) st = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\t\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\t\n\tvoid solve() throws Exception {\n\t\tboolean[] r = new boolean[1010];\n\t\tArrays.fill(r, true);\n\t\tr[0] = r[1] = false;\n\t\tfor (int i = 2; i < 1010; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tfor (int j = i + i; j < 1010; j += i) {\n\t\t\t\t\tr[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] pr = new int[1010];\n\t\tint l = 0;\n\t\tfor (int i = 2; i < 1010; i++) if (r[i]) pr[l++] = i;\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tint ans = 0;\n\t\tint j = 0;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tif (r[i]) {\n\t\t\tfor (; j < l - 1; j++) {\n\t\t\t\tif (i == pr[j] + pr[j + 1] + 1) {\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i < pr[j] + pr[j + 1] + 1) break;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans >= k) out.println(\"YES\"); else out.println(\"NO\");\n\t}\n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tout.flush();\n\t}\n\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.util.Scanner;\n\n\n\npublic class CodeforcesC {\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner ob = new Scanner(System.in);\n\n\t\tlong n = ob.nextLong();\n\n\t\tlong s = ob.nextLong();\n\n\t\tlong l = 1;\n\n\t\tlong r = n;\n\n\t\twhile(l<=r){\n\n\t\t\tlong mid = (l + r)/2;\n\n\t\t\tif(reallybignumber(mid,s)){\n\n\t\t\t\tr = mid-1;\n\n\t\t\t}else{\n\n\t\t\t\tl = mid +1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t/******long l1 = l;\n\n\t\t***while(l1<=n) {\n\n\t\t\tSystem.out.print(l1 + \" \");\n\n\t\t\tl1++;\n\n\t\t}*/////////\n\n\t\tSystem.out.println(n-l+1);\n\n\n\n\t}\n\n\n\n\tprivate static boolean reallybignumber(long n,long s) {\n\n\t\tlong m = n;\n\n\t\tlong sum=0;\n\n\t\tint d=1;\n\n\t\twhile(m>0){\n\n\t\t\tlong rem = m % 10;\n\n\t\t\tsum =   rem * d + sum;\n\n\t\t\tm = m / 10;\n\n\t\t}\n\n\t\tif(n-sum >= s) return true;\n\n\t\telse return false;\n\n\t}\n\n\n\n}", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            out.printLine(25);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "    import java.util.Scanner;\n     \n    public class ABC {\n        public static void main(String[] args){\n     \n            Scanner sc=new Scanner(System.in);\n            long k,c,n,d;\n            c=1;\n            d=9;\n            n=1;\n            k= sc.nextLong();\n            while(k>(c*d)) {\n                k-=(c*d);\n                n*=10;\n                d*=10;\n                c++;\n            }\n            n+=(k-1)/c;\n            char[] num = String.valueOf(n).toCharArray();\n            System.out.println(num[(int)((k-1)%c)]);\n        }\n     \n    }\n\n\n\t\t\t\t \t     \t\t \t \t\t\t   \t \t  \t  \t", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long MOD = MathExtentions.DEFAULT_MOD;\n            long x = in.NextLong();\n            long k = in.NextLong();\n            if (x == 0) {\n                out.println(0);\n                return;\n            }\n            x %= MOD;\n            long res = x * MathExtentions.powerMod(2, k + 1, MOD);\n            res %= MOD;\n            res -= MathExtentions.powerMod(2, k, MOD) - 1;\n            res %= MOD;\n            while (res < 0) res += MOD;\n            while (res >= MOD) res -= MOD;\n            out.println(res);\n\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long NextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n\n    static class MathExtentions {\n        public static final long DEFAULT_MOD = 1_000_000_007;\n\n        public static long powerMod(final long x, final long y, final long m) {\n            if (y == 0)\n                return 1;\n\n            long p = powerMod(x, y / 2, m) % m;\n            p = (p * p) % m;\n\n            if (y % 2 == 0)\n                return p;\n            else\n                return (x * p) % m;\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        final int MOD = (int) (1e9 + 7);\n        long[][] C;\n        long[] fact;\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            precalc(n);\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n                a[i] = removeSquares(a[i]);\n            }\n            int[] g = getGroupSizes(a);\n            long ans = solve(g);\n            for (int x : g) {\n                ans = ans * fact[x] % MOD;\n            }\n            out.println(ans);\n        }\n\n        private long solve(int[] a) {\n            // For a description, see http://petr-mitrichev.blogspot.com/2017/07/a-week7.html\n            long[] d = new long[1];\n            d[0] = 1;\n            int totalPositions = 1;\n            for (int x : a) {\n                long[] nd = new long[d.length + x + 1];\n                for (int s = 0; s < d.length; s++) {\n                    if (d[s] == 0) {\n                        continue;\n                    }\n                    for (int m = 1; m <= x; m++) {\n                        for (int p = 0; p <= s && p <= m; p++) {\n                            long cur = d[s];\n                            cur = cur * C[s][p] % MOD;\n                            cur = cur * C[totalPositions - s][m - p] % MOD;\n                            cur = cur * f(x, m) % MOD;\n                            int ns = s + x - m - p;\n                            if (ns >= 0 && ns < nd.length) {\n                                nd[ns] += cur;\n                                if (nd[ns] >= MOD) {\n                                    nd[ns] -= MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (totalPositions == 1) {\n                    totalPositions = x + 1;\n                } else {\n                    totalPositions += x;\n                }\n                d = nd;\n            }\n            return d[0];\n        }\n\n        private long f(int n, int k) {\n            if (n < k) {\n                return 0;\n            }\n            n -= k;\n            return C[n + k - 1][k - 1];\n        }\n\n        private void precalc(int n) {\n            fact = new long[n + 1];\n            fact[0] = 1;\n            for (int i = 1; i < fact.length; i++) {\n                fact[i] = i * fact[i - 1] % MOD;\n            }\n\n            C = new long[1000][1000];\n            C[0][0] = 1;\n            for (int i = 1; i < C.length; i++) {\n                C[i][0] = 1;\n                for (int j = 1; j < C.length; j++) {\n                    C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n                    if (C[i][j] >= MOD) {\n                        C[i][j] -= MOD;\n                    }\n                }\n            }\n        }\n\n        private int[] getGroupSizes(int[] a) {\n            Arrays.sort(a);\n            List<Integer> res = new ArrayList<>();\n            for (int i = 0; i < a.length; ) {\n                int j = i;\n                while (j < a.length && a[i] == a[j]) {\n                    ++j;\n                }\n                res.add(j - i);\n                i = j;\n            }\n            int[] r = new int[res.size()];\n            for (int i = 0; i < r.length; i++) {\n                r[i] = res.get(i);\n            }\n            return r;\n        }\n\n        private int removeSquares(int n) {\n            int res = 1;\n            for (int d = 2; d * d <= n; d++) {\n                if (n % d == 0) {\n                    int cur = 0;\n                    while (n % d == 0) {\n                        n /= d;\n                        ++cur;\n                    }\n                    if (cur % 2 == 1) {\n                        res *= d;\n                    }\n                }\n            }\n            if (n > 1) {\n                res *= n;\n            }\n            return res;\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "cubic", "problem": "0840_C", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Problem_A {\n\t\n\tpublic static void main(String[] args) {\n\t\tMyScanner scan = new MyScanner();\n\t\tint n = scan.nextInt();\n\t\tint[] elements = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\telements[i] = scan.nextInt();\n\t\t\n\t\tint x = 0;\n\t\t\n\t\tArrays.sort(elements);\n\t\twhile(n > 0) {\n\t\t\tx++;\n\t\t\tint[] temp = new int[n];\n\t\t\tint j = 0;\n\t\t\tint size = n;\n\t\t\tint min = elements[0];\n\t\t\tn--;\n\t\t\tfor (int i = 1; i < size; i++) {\n\t\t\t\tif (elements[i]%min == 0) {\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttemp[j++] = elements[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\telements = temp;\n\t\t}\n\t\t\n\t\tout.println(x);\n\t\tout.close();\n\t}\n\n\tpublic static PrintWriter out  = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static class MyScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements())\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\t\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\n\nimport java.io.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\n\tlong mod1 = (long) 1e9 + 7;\n\tint mod2 = 998244353;\n\n\tpublic void solve() throws Exception {\n\t\tint n=sc.nextInt();\n\t\tint arr[]=new int[n+1];\n\t\tfor(int i=1;i<=n;i++) arr[i]=sc.nextInt();\n\t\tint indices[]=new int[n+1];\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tindices[arr[i]]=i;\n\t\t}\n\t\tint winorlose[]=new int[n+1];\n\t\twinorlose[n] = -1;\n\t\tfor(int i=n-1;i>=1;i--) {\n\t\t\tint index=indices[i];\n\t\t\twinorlose[i]=-1;\n\t\t\t\n\t\t\tfor(int j=index;j<=n;j+=i) {\n\t\t\t\t\n\t\t\t\tif(arr[j]>i && winorlose[arr[j]]!=0) {\n\t\t\t\t\tif(winorlose[arr[j]]==-1) {\n\t\t\t\t\t\twinorlose[i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=index;j>=1;j-=i) {\n//\t\t\t\tif(i==2) {\n//\t\t\t\t\tout.println(j+\" \"+arr[j]);\n//\t\t\t\t}\n\t\t\t\tif(arr[j]>i && winorlose[arr[j]]!=0) {\n\t\t\t\t\tif(winorlose[arr[j]]==-1) {\n\t\t\t\t\t\twinorlose[i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++) \n\t\t{\n\t\t\tif(winorlose[arr[i]]==1) {\n\t\t\t\tout.print(\"A\");\n\t\t\t}\n\t\t\telse out.print(\"B\");\n\t\t}\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic long ncr(int n, int r, long p) {\n\t\tif (r > n)\n\t\t\treturn 0l;\n\t\tif (r > n - r)\n\t\t\tr = n - r;\n\n\t\tlong C[] = new long[r + 1];\n\n\t\tC[0] = 1;\n\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\tfor (int j = Math.min(i, r); j > 0; j--)\n\t\t\t\tC[j] = (C[j] + C[j - 1]) % p;\n\t\t}\n\t\treturn C[r] % p;\n\t}\n\n\tpublic long power(long x, long y, long p) {\n\t\tlong res = 1;\n\t\t// out.println(x+\" \"+y);\n\t\tx = x % p;\n\t\tif (x == 0)\n\t\t\treturn 0;\n\n\t\twhile (y > 0) {\n\t\t\tif ((y & 1) == 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\ty = y >> 1;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic Throwable uncaught;\n\n\tBufferedReader in;\n\tFastScanner sc;\n\tPrintWriter out;\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsc = new FastScanner(in);\n\t\t\tsolve();\n\t\t} catch (Throwable uncaught) {\n\t\t\tSolution.uncaught = uncaught;\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Throwable {\n\t\tThread thread = new Thread(null, new Solution(), \"\", (1 << 26));\n\t\tthread.start();\n\t\tthread.join();\n\t\tif (Solution.uncaught != null) {\n\t\t\tthrow Solution.uncaught;\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\n\tpublic FastScanner(BufferedReader in) {\n\t\tthis.in = in;\n\t}\n\n\tpublic String nextToken() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic int[] readArray(int n) throws Exception {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n}", "complexity": "nlogn", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class a2oj implements Runnable {\n\n    static FastReader sc;\n    static PrintWriter out;\n    static int mod = 1000000007;\n\n    public static void main(String[] args) {\n        new Thread(null, new a2oj(), \"coderrohan14\", 1 << 26).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            ioSetup();\n        } catch (IOException e) {\n            return;\n        }\n    }\n\n    public static void ioSetup() throws IOException {\n        if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n            File f1 = new File(\"input.txt\");\n            File f2 = new File(\"output.txt\");\n            Reader r = new FileReader(f1);\n            sc = new FastReader(r);\n            out = new PrintWriter(f2);\n            double prev = System.currentTimeMillis();\n            solve();\n            out.println(\"\\n\\nExecuted in : \" + ((System.currentTimeMillis() - prev) / 1e3) + \" sec\");\n        } else {\n            sc = new FastReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n            solve();\n        }\n        out.flush();\n        out.close();\n    }\n\n    static void solve() {\n        int t = sc.nextInt();\n        StringBuilder ans = new StringBuilder(\"\");\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            int[] arr = sc.readArrayI(n);\n            Stack<Integer> st = new Stack<>();\n            for (int i = 0; i < n; i++) {\n                if (st.isEmpty()) {\n                    st.push(arr[i]);\n                } else {\n                    if (arr[i] == 1) {\n                        st.push(arr[i]);\n                    } else {\n                        while (!st.isEmpty()) {\n                            if (st.peek() == arr[i] - 1) {\n                                st.pop();\n                                st.push(arr[i]);\n                                break;\n                            }\n                            st.pop();\n                        }\n                    }\n                }\n                Object[] ars = st.toArray();\n                for (int j = 0; j < ars.length; j++) {\n                    if (j == ars.length - 1) {\n                        ans.append(ars[j]);\n                    } else {\n                        ans.append(ars[j] + \".\");\n                    }\n                }\n                ans.append(\"\\n\");\n            }\n        }\n        out.println(ans);\n    }\n\n    /****************************************************************************************************************************************************************************************/\n\n    static long modInverse(long a, int mod) {\n        long g = gcd(a, mod);\n        if (g != 1)\n            return -1;\n        else {\n            return modPower(a, mod - 2L, mod);\n        }\n    }\n\n    static long modPower(long x, long y, int mod) {\n        long res = 1;\n        x = x % mod;\n        if (x == 0)\n            return 0;\n        while (y > 0) {\n            if ((y & 1) != 0)\n                res = (res * x) % mod;\n            y = y >> 1;\n            x = (x * x) % mod;\n        }\n        return res;\n    }\n\n    static int gcd(int a, int b) {\n        int tmp = 0;\n        while (b != 0) {\n            tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n        return a;\n    }\n\n    static long gcd(long a, long b) {\n        long tmp = 0;\n        while (b != 0) {\n            tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n        return a;\n    }\n\n    static boolean isPrime(long n) {\n        if (n == 2 || n == 3)\n            return true;\n        if (n % 2 == 0)\n            return false;\n        for (long i = 3; i * i <= n; i += 2) {\n            if (n % i == 0)\n                return false;\n        }\n        return n != 1;\n    }\n\n    static boolean isPerfectSquare(long x) {\n        long sqrt = (long) Math.sqrt(x);\n        return (sqrt * sqrt) == x;\n    }\n\n    static int digitsCount(long x) {\n        return (int) Math.floor(Math.log10(x)) + 1;\n    }\n\n    static boolean isPowerTwo(long n) {\n        return (n & n - 1) == 0;\n    }\n\n    static void sieve(boolean[] prime, int n) { // Sieve Of Eratosthenes\n        for (int i = 1; i <= n; i++) {\n            prime[i] = true;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (prime[i]) {\n                for (int j = 2; i * j <= n; j++) {\n                    prime[i * j] = false;\n                }\n            }\n        }\n    }\n\n    static long nCr(long n, long r) { // Combinations\n        if (n < r)\n            return 0;\n        if (r > n - r) { // because nCr(n, r) == nCr(n, n - r)\n            r = n - r;\n        }\n        long ans = 1L;\n        for (long i = 0; i < r; i++) {\n            ans *= (n - i);\n            ans /= (i + 1);\n        }\n        return ans;\n    }\n\n    static int floor(int[] a, int v) {\n        int l = 0, h = a.length - 1;\n        while (l < h) {\n            int mid = (l + h) / 2;\n            if (a[mid] == v)\n                return mid;\n            if (v < a[mid])\n                h = mid;\n            else {\n                if (mid + 1 < h && a[mid + 1] < v)\n                    l = mid + 1;\n                else\n                    return mid;\n            }\n        }\n        return a[l] <= v ? l : -1;\n    }\n\n    static int floor(long[] a, long v) {\n        int l = 0, h = a.length - 1;\n        while (l < h) {\n            int mid = (l + h) / 2;\n            if (a[mid] == v)\n                return mid;\n            if (v < a[mid])\n                h = mid;\n            else {\n                if (mid + 1 < h && a[mid + 1] < v)\n                    l = mid + 1;\n                else\n                    return mid;\n            }\n        }\n        return a[l] <= v ? l : -1;\n    }\n\n    static int ceil(int[] a, int v) {\n        int l = 0, h = a.length - 1;\n        while (l < h) {\n            int mid = (l + h) / 2;\n            if (a[mid] == v)\n                return mid;\n            if (a[mid] < v)\n                l = mid + 1;\n            else\n                h = mid;\n        }\n        return a[h] >= v ? h : -1;\n    }\n\n    static int ceil(long[] a, long v) {\n        int l = 0, h = a.length - 1;\n        while (l < h) {\n            int mid = (l + h) / 2;\n            if (a[mid] == v)\n                return mid;\n            if (a[mid] < v)\n                l = mid + 1;\n            else\n                h = mid;\n        }\n        return a[h] >= v ? h : -1;\n    }\n\n    static long catalan(int n) { // n-th Catalan Number\n        long c = nCr(2 * n, n);\n        return c / (n + 1);\n    }\n\n    static class Pair implements Comparable<Pair> { // Pair Class\n        int x;\n        int y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (!(o instanceof Pair)) {\n                return false;\n            }\n\n            Pair pair = (Pair) o;\n\n            if (x != pair.x) {\n                return false;\n            }\n            if (y != pair.y) {\n                return false;\n            }\n\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            long result = x;\n            result = 31 * result + y;\n            return (int) result;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            return (int) (this.x - o.x);\n        }\n    }\n\n    static class Trip { // Triplet Class\n        long x;\n        long y;\n        long z;\n\n        Trip(long x, long y, long z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (!(o instanceof Trip)) {\n                return false;\n            }\n\n            Trip trip = (Trip) o;\n\n            if (x != trip.x) {\n                return false;\n            }\n            if (y != trip.y) {\n                return false;\n            }\n            if (z != trip.z) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            long result = 62 * x + 31 * y + z;\n            return (int) result;\n        }\n    }\n\n    /**************************************************************************************************************************************************************************************/\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader(Reader r) {\n            br = new BufferedReader(r);\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int[] readArrayI(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = sc.nextInt();\n            }\n            return arr;\n        }\n\n        long[] readArrayL(int n) {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = sc.nextLong();\n            }\n            return arr;\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    /*\n     * ASCII Range--->(A-Z)--->[65,90]<<::>>(a-z)--->[97,122]\n     */\n    /******************************************************************************************************************/\n\n    static void printArray(int[] arr) {\n        out.print(\"[\");\n        for (int i = 0; i < arr.length; i++) {\n            if (i < arr.length - 1)\n                out.print(arr[i] + \",\");\n            else\n                out.print(arr[i]);\n        }\n        out.print(\"]\");\n        out.println();\n    }\n\n    static void printArray(long[] arr) {\n        out.print(\"[\");\n        for (int i = 0; i < arr.length; i++) {\n            if (i < arr.length - 1)\n                out.print(arr[i] + \",\");\n            else\n                out.print(arr[i]);\n        }\n        out.print(\"]\");\n        out.println();\n    }\n\n    static void printArray(double[] arr) {\n        out.print(\"[\");\n        for (int i = 0; i < arr.length; i++) {\n            if (i < arr.length - 1)\n                out.print(arr[i] + \",\");\n            else\n                out.print(arr[i]);\n        }\n        out.print(\"]\");\n        out.println();\n    }\n    /**********************************************************************************************************************/\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class E\n{\n    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok;\n\n    public void go() throws IOException\n    {\n        StringTokenizer tok = new StringTokenizer(in.readLine());\n        int zzz = Integer.parseInt(tok.nextToken());\n        for (int zz = 0; zz < zzz; zz++)\n        {\n            ntok();\n            int n = ipar();\n            int m = ipar();\n            int[][] mat = new int[n][m];\n            for (int i = 0; i < n; i++)\n            {\n                ntok();\n                mat[i] = iapar(m);\n            }\n            long[][] dp = new long[1 << n][m+1];\n            for (int i = 0; i < 1 << n; i++)\n            {\n                dp[i][m] = -1000000000;\n            }\n            dp[(1 << n) - 1][m] = 0;\n            for (int i = m-1; i >= 0; i--)\n            {\n                for (int e = 0; e < 1 << n; e++)\n                {\n                    dp[e][i] = dp[e][i+1];\n                    for (int w = 0; w < 1 << n; w++)\n                    {\n                        if ((e & w) == 0)\n                        {\n                            dp[e][i] = Math.max(dp[e][i], best(w, mat, i) + dp[e|w][i+1]);\n                        }\n                    }\n                }\n            }\n            // for (long[] arr : dp)\n            // {\n            //     out.println(Arrays.toString(arr));\n            // }\n            out.println(dp[0][0]);\n        }\n\n        out.flush();\n        in.close();\n    }\n\n    public long best(int mask, int[][] mat, int col)\n    {\n        long max = 0;\n        for (int t = 0; t < mat.length; t++)\n        {\n            long sum = 0;\n            int mk = mask;\n            for (int i = 0; i < mat.length; i++)\n            {\n                if (mk % 2 == 1)\n                {\n                    sum += mat[i][col];\n                }\n                mk /= 2;\n            }\n            max = Math.max(max, sum);\n            cycle(mat, col);\n        }\n        return max;\n    }\n\n    public void cycle(int[][] mat, int col)\n    {\n        int temp = mat[0][col];\n        for (int i = 0; i < mat.length-1; i++)\n        {\n            mat[i][col] = mat[i+1][col];\n        }\n        mat[mat.length-1][col] = temp;\n    }\n\n    public void ntok() throws IOException\n    {\n        tok = new StringTokenizer(in.readLine());\n    }\n\n    public int ipar()\n    {\n        return Integer.parseInt(tok.nextToken());\n    }\n\n    public int[] iapar(int n)\n    {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            arr[i] = ipar();\n        }\n        return arr;\n    }\n\n    public long lpar()\n    {\n        return Long.parseLong(tok.nextToken());\n    }\n\n    public long[] lapar(int n)\n    {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++)\n        {\n            arr[i] = lpar();\n        }\n        return arr;\n    }\n\n    public double dpar()\n    {\n        return Double.parseDouble(tok.nextToken());\n    }\n\n    public String spar()\n    {\n        return tok.nextToken();\n    }\n\n    public static void main(String[] args) throws IOException\n    {\n        new E().go();\n    }\n}\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        int n;\n        long neededSum;\n        long[] sums;\n        Map<Long, Integer> where;\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            n = in.nextInt();\n            int[][] a = new int[n][];\n            neededSum = 0;\n            sums = new long[n];\n            for (int i = 0; i < n; i++) {\n                int k = in.nextInt();\n                a[i] = new int[k];\n                for (int j = 0; j < k; j++) {\n                    a[i][j] = in.nextInt();\n                    neededSum += a[i][j];\n                    sums[i] += a[i][j];\n                }\n            }\n\n            if (neededSum % n != 0) {\n                out.println(\"No\");\n                return;\n            }\n            neededSum /= n;\n\n            where = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < a[i].length; j++) {\n                    where.put((long) a[i][j], i);\n                }\n            }\n\n            Entry[][] cycleSol = new Entry[1 << n][];\n            List<Entry> sol = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                for (int x : a[i]) {\n                    search(i, i, x, x, 0, 0, sol, cycleSol);\n                }\n            }\n\n            boolean[] can = new boolean[1 << n];\n            int[] via = new int[1 << n];\n            can[0] = true;\n            for (int mask = 0; mask < 1 << n; mask++) {\n                for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n                    if (cycleSol[submask] != null && can[mask ^ submask]) {\n                        can[mask] = true;\n                        via[mask] = submask;\n                    }\n                }\n            }\n\n            if (!can[(1 << n) - 1]) {\n                out.println(\"No\");\n                return;\n            }\n\n            int[][] ans = new int[n][2];\n            for (int mask = (1 << n) - 1; mask > 0; ) {\n                int sm = via[mask];\n                mask ^= sm;\n\n                for (Entry e : cycleSol[sm]) {\n                    ans[e.from][0] = e.what;\n                    ans[e.from][1] = e.to + 1;\n                }\n            }\n\n            out.println(\"Yes\");\n            for (int i = 0; i < n; i++) {\n                out.println(ans[i][0] + \" \" + ans[i][1]);\n            }\n        }\n\n        private void search(int start, int cur, long fromStart, long fromCur, int hasIn, int hasOut, List<Entry> sol, Entry[][] cycleSol) {\n            for (int i = start; i < n; i++) {\n                if ((hasIn & (1 << i)) > 0) {\n                    continue;\n                }\n                if ((hasOut & (1 << cur)) > 0) {\n                    continue;\n                }\n                long fromI = sums[i] + fromCur - neededSum;\n                Integer w = where.get(fromI);\n                if (w == null || w != i) {\n                    continue;\n                }\n                sol.add(new Entry(cur, i, (int) fromCur));\n                int nHasIn = hasIn | (1 << i);\n                int nHasOut = hasOut | (1 << cur);\n                if (i == start && fromI == fromStart) {\n                    cycleSol[nHasOut] = sol.toArray(new Entry[0]);\n                }\n                search(start, i, fromStart, fromI, nHasIn, nHasOut, sol, cycleSol);\n                sol.remove(sol.size() - 1);\n            }\n        }\n\n        class Entry {\n            int from;\n            int to;\n            int what;\n\n            Entry(int from, int to, int what) {\n                this.from = from;\n                this.to = to;\n                this.what = what;\n            }\n\n            public String toString() {\n                return from + \" \" + to + \" \" + what;\n            }\n\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "//package com.codeforces;\n\nimport java.util.Scanner;\n\npublic class Solution1080 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int red = n * 2;\n        int green = n * 5;\n        int blue = n * 8;\n        int sum =  numberUp(red, k) +  numberUp(green, k) + numberUp(blue, k);\n        System.out.println(sum);\n    }\n\n    private static int numberUp(int d, int t) {\n        int num = (int) Math.ceil(d/t);\n        if (d % t != 0) {\n            num++;\n        }\n        return num;\n    }\n}\n", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main\n{\n\tstatic final boolean _DEBUG = false;\n\n\tprivate static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic MyScanner(BufferedReader _br) {\n\t\t\tbr = _br;\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t}\n\n\tstatic MyScanner   scan;\n\tstatic PrintWriter out;\n\n\tstatic int debugCount = 0;\n\tstatic void debug(String msg) {\n\t\tif (_DEBUG && debugCount < 200) {\n\t\t\tout.println(msg);\n\t\t\tout.flush();\n\t\t\tdebugCount++;\n\t\t}\n\t}\n\t\n    public static void main (String args[]) throws IOException {\n//    \tscan = new MyScanner(new BufferedReader(new FileReader(\"test.in\")));\n    \tscan = new MyScanner(new BufferedReader(new InputStreamReader(System.in)));\n    \tout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        Main inst = new Main();\n        inst.execute();\n        out.close();\n    }\n    \n    int N, M, pow;\n    int[] counts;\n    int[][][] dp;\n    \n    void execute() {\n    \tN = scan.nextInt();\n    \tM = scan.nextInt();\n    \tif (N < M) {\n    \t\tint temp = N;\n    \t\tN = M;\n    \t\tM = temp;\n    \t}\n    \tpow = 1<<M;\n    \tcounts = new int[pow];\n    \tdp = new int[N][pow][pow];\n    \tfor (int[][] i : dp) {\n    \t\tfor (int[] j : i) {\n    \t\t\tArrays.fill(j, -1);\n    \t\t}\n    \t}\n    \tfor (int i = 0; i < pow; i++) {\n    \t\tcounts[i] = Integer.bitCount(i);\n        \tdp[0][i][0] = counts[i];\n    \t}\n    \tint spiders = Integer.MAX_VALUE;\n    \tfor (int y = 0; y < N-1; y++) {\n    \t\tfor (int i = 0; i < pow; i++) {\n    \t\t\tfor (int j = 0; j < pow; j++) {\n    \t\t\t\tif (dp[y][i][j] == -1) {\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}\n    \t\t\t\tfor (int k = 0; k < pow; k++) {\n    \t\t\t\t\tif (((i|(i<<1)|(i>>1)|j|k)&(pow-1))==(pow-1)) {\n    \t\t\t\t\t\tint value = dp[y][i][j] + counts[k];\n    \t\t\t\t\t\tif (dp[y+1][k][i] == -1 || dp[y+1][k][i] > value) {\n    \t\t\t\t\t\t\tdp[y+1][k][i] = value;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n//    \tfor (int i = 0; i < N; i++) {\n//        \tSystem.out.println(Arrays.deepToString(dp[i]));\n//    \t}\n    \tfor (int i = 0; i < pow; i++) {\n    \t\tfor (int j = 0; j < pow; j++) {\n    \t\t\tif (dp[N-1][i][j] != -1 && ((i|(i<<1)|(i>>1)|j)&(pow-1))==(pow-1)) {\n    \t\t\t\tspiders = Math.min(spiders, dp[N-1][i][j]);\n//    \t\t\t\tSystem.out.println(spiders+\" \"+i+\" \"+j);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tout.println((N*M)-spiders);\n    }\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class code\n{\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n    \n    public static void main(String args[])throws IOException\n\t{\n        FastReader scn = new FastReader();\n\n        long a_ = scn.nextLong();\n        long b_ = scn.nextLong();\n\n        String a_str = Long.toBinaryString(a_);\n        String b_str = Long.toBinaryString(b_);\n\n        int a_str_length = a_str.length();\n        int b_str_length = b_str.length();\n\n        StringBuilder a = new StringBuilder();\n        StringBuilder b = new StringBuilder();\n        StringBuilder max_xor = new StringBuilder();\n\n        while(a_str_length++ < 64)\n            a.append(0);\n        while(b_str_length++ < 64)\n            b.append(0);\n        a.append(a_str);\n        b.append(b_str);\n\n\n        boolean equality = true;\n        boolean max_gave_up = false;\n        boolean min_gave_up = false;\n\n        for(int i = 0; i < 64; i++)\n        {\n\n            if((a.charAt(i) == b.charAt(i)) && equality)\n            {\n                max_xor.append('0');\n                continue;\n            }   \n\n            if(equality)\n                equality = false;\n\n            max_xor.append('1');\n        }\n        //System.out.println(max_xor.toString());\n        System.out.println(Long.parseLong(max_xor.toString(), 2));\n\t}\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n    public static void main(String[] args) throws Exception {\n\t// TODO Auto-generated method stub\n\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\tPrintWriter out = new PrintWriter(System.out);\n\tString s = bf.readLine();\n\tout.println(25);\n\t\n\tout.flush();\n\tout.close();\n\n    }\n}\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        long a;\n        int i;\n        public card(long a,int i)\n        {\n            this.a=a;\n            this.i=i;\n        }\n    }\n    static class sort implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.a!=o2.a)\n                return (int)(o1.a-o2.a);\n            else\n                return (int)(o1.b-o2.b);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    /*static long gcd(long a,long b)\n    {\n    if(b==0)\n    return a;\n    else\n    return gcd(b,a%b);\n    }*/\n    /*static boolean valid(int i,int j)\n    {\n    if(i<4 && i>=0 && j<4 && j>=0)\n    return true;\n    else\n    return false;\n    }*/\n    static class pair{\n        int a,b;\n        public pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int k=sc.nextInt();\n        int n=sc.nextInt();\n        int s=sc.nextInt();\n        int p=sc.nextInt();\n        long d=(long)Math.ceil((double)n/s);\n        if(d==0)\n        d=1;\n        d=k*d;\n        long ans=(long)Math.ceil((double)d/p);\n        System.out.println(ans);\n    }\n}", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.List;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author RiaD\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tReader in = new Reader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    private static final long MOD = 1000000009;\n\n    public void solve(int testNumber, Reader in, OutputWriter out) {\n        long answer = 0;\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int k = in.nextInt();\n\n        long l = -1;\n        long r = n + 1;\n\n        while (l + 1 < r) {\n            long c = (l + r) / 2;\n            if(n < c * k || canAchieve(n - c * k, k) >= m - c * k) {\n                r = c;\n            }\n            else\n                l = c;\n        }\n\n        //out.println(r);\n\n        long c = r;\n\n        answer = ((IntegerUtils.power(2, c + 1, MOD) - 2 + MOD) % MOD) * k % MOD;\n\n        n -= k * c;\n        m -= k * c;\n        answer += m;\n        answer %= MOD;\n\n        out.println(answer);\n    }\n\n    private long canAchieve(long n, long k) {\n        return n - n / k;\n    }\n}\n\nclass Reader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public Reader(BufferedReader reader) {\n        this.reader = reader;\n    }\n\n    public Reader(InputStream stream) {\n        this(new BufferedReader(new InputStreamReader(stream)));\n    }\n\n    public String nextString() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n    private String readLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\nclass OutputWriter extends PrintWriter {\n\n\tpublic OutputWriter(OutputStream out) {\n\t\tsuper(out);\n\t}\n\n\tpublic OutputWriter(java.io.Writer writer){\n\t\tsuper(writer);\n\t}\n\n\t}\n\nclass IntegerUtils {\n\n\tpublic static long power(long base, long power, long mod) {\n\t\tlong result = 1 % mod;\n\t\tbase %= mod;\n\t\twhile (power > 0) {\n\t\t\tif (power % 2 == 1) {\n\t\t\t\tresult *= base;\n\t\t\t\tresult %= mod;\n\t\t\t}\n\t\t\tbase *= base;\n\t\t\tbase %= mod;\n\t\t\tpower >>= 1;\n\t\t}\n\t\treturn result;\n\t}\n\n\t}\n", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.util.*;\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a[] = new int[100004];\n        int b[] = new int[100004];\n        int n, m, ans = 0, dau, cuoi=-1;\n        n = sc.nextInt();\n        m = sc.nextInt();\n        for(int i=0;i<100004;i++) a[i] = 0;\n        for(int i=0;i<n;i++){\n            b[i] = sc.nextInt();\n            if(a[b[i]]==0){\n                a[b[i]] = 1;\n                ans++;\n                if(ans==m){\n                    cuoi = i+1;\n                    break;\n                }\n            }\n        }\n        for(int i=cuoi-1;i>=00;i--){\n            if(a[b[i]]==1){\n                a[b[i]] = 0;\n                ans--;\n                if(ans==0){\n                    System.out.println((i+1)+\" \"+cuoi);\n                    System.exit(0);\n                }\n            }\n        }\n        System.out.println(\"-1 -1\");\n    }\n\n}\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    public static void main(String[] args) {\n        \n        var sc = new Scanner(System.in);\n        var pw = new PrintWriter(System.out);\n        \n        int T = Integer.parseInt(sc.next());\n        for(int t = 0; t < T; t++){\n            int n = Integer.parseInt(sc.next());\n            boolean ok = false;\n            if(n%2 == 0){\n                int a = n/2;\n                int b = (int) Math.sqrt(a);\n                if(b*b == a){\n                    ok = true;\n                }\n            }\n            if(n%4 == 0){\n                int a = n/4;\n                int b = (int) Math.sqrt(a);\n                if(b*b == a){\n                    ok = true;\n                }\n            }\n            if(ok){\n                pw.println(\"YES\");\n            }else{\n                pw.println(\"NO\");\n            }\n        }\n        pw.flush();\n    }\n}", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "\n\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\nimport java.lang.*;\n\n\npublic class P11D{\n\tstatic long mod=1000000007;\n\t\n    public static void main(String[] args) throws Exception{           \t\n    \tInputReader in = new InputReader(System.in);       \n    \tPrintWriter pw=new PrintWriter(System.out);   \n    \t\n    \t\n    \t//int t=in.readInt();\n        //while(t-->0)\n        //{\n    \t\n        int n=in.readInt();\n        int m=in.readInt();\n        boolean v[][]=new boolean[n][n];\n        for(int i=0;i<m;i++)\n        {\n        \tint x=in.readInt()-1;\n        \tint y=in.readInt()-1;\n        \tv[x][y]=true;\n        \tv[y][x]=true;\n        }\n    \t\n       long dp[][]=new long[1<<n][n];\n       for(int i=0;i<n;i++)\n       {\n    \t   dp[1<<i][i]=1;\n       }\n       long ans=0;\n    \tfor(int mask=1;mask<(1<<n);mask++)\n    \t{\n    \t\tint s=-1;\n    \t\tfor(int i=0;i<n;i++)\n    \t\t{\n    \t\t\tif((mask&(1<<i))!=0)\n    \t\t\t{\n    \t\t\t\ts=i;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\tfor(int i=0;i<n;i++)\n    \t\t{\n    \t\t\tif(i!=s&&((1<<i)&mask)!=0)\n    \t\t\t{\n    \t\t\t\tfor(int j=0;j<n;j++)\n    \t\t\t\t{\n    \t\t\t\t\tif((1<<j)!=0&&i!=j&&v[i][j])\n    \t\t\t\t\t{\n    \t\t\t\t\t\tint rem=(1<<i)^mask;\n    \t\t\t\t\t\tdp[mask][i]+=dp[rem][j];\n    \t\t\t\t\t}\n    \t\t\t\t}    \t\t\t\n    \t\t\n    \t\t\t\tint c=Integer.bitCount(mask);\n    \t\t\t\tif(c>=3&&v[i][s])\n    \t\t\t\t{\n    \t\t\t\t\tans+=dp[mask][i];\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tans/=2;\n\t\tpw.println(ans);\t     \t\n    \t\n    \t//}\n    \t\n    \tpw.close();\n    }\n    \n\n\t\npublic static long gcd(long x,long y)\n{\n\tif(x%y==0)\n\t\treturn y;\n\telse\n\t\treturn gcd(y,x%y);\n}\npublic static int gcd(int x,int y)\n{\n\tif(x%y==0)\n\t\treturn y;\n\telse \n\t\treturn gcd(y,x%y);\n}\npublic static int abs(int a,int b)\n{\n\treturn (int)Math.abs(a-b);\n}\npublic static long abs(long a,long b)\n{\n\treturn (long)Math.abs(a-b);\n}\npublic static int max(int a,int b)\n{\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\npublic static int min(int a,int b)\n{\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n}\npublic static long max(long a,long b)\n{\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\npublic static long min(long a,long b)\n{\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n}\n\n\npublic static long pow(long n,long p,long m)\n{\n\t long  result = 1;\n\t  if(p==0)\n\t    return 1;\n\tif (p==1)\n\t    return n;\n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\n\t    if(result>=m)\n\t    result%=m;\n\t    p >>=1;\n\t    n*=n;\n\t    if(n>=m)\n\t    n%=m;\n\t}\n\treturn result;\n}\npublic static long pow(long n,long p)\n{\n\tlong  result = 1;\n\t  if(p==0)\n\t    return 1;\n\tif (p==1)\n\t    return n;\n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\t    \n\t    p >>=1;\n\t    n*=n;\t    \n\t}\n\treturn result;\n\n}\nstatic class Pair implements Comparable<Pair>\n{\n\tint a,b;\n\tPair (int a,int b)\n\t{\n\t\tthis.a=a;\n\t\tthis.b=b;\n\t}\n\n\tpublic int compareTo(Pair o) {\n\t\t// TODO Auto-generated method stub\n\t\tif(this.a!=o.a)\n\t\treturn Integer.compare(this.a,o.a);\n\t\telse\n\t\t\treturn Integer.compare(this.b, o.b);\n\t\t//return 0;\n\t}\n\tpublic boolean equals(Object o) {\n        if (o instanceof Pair) {\n            Pair p = (Pair)o;\n            return p.a == a && p.b == b;\n        }\n        return false;\n    }\n    public int hashCode() {\n        return new Integer(a).hashCode() * 31 + new Integer(b).hashCode();\n    }\n    \n} \n    \nstatic long sort(int a[])\n{  int n=a.length;\n\tint b[]=new int[n];\t\n\treturn mergeSort(a,b,0,n-1);}\nstatic long mergeSort(int a[],int b[],long left,long right)\n{ long c=0;if(left<right)\n {   long mid=left+(right-left)/2;\n\t c= mergeSort(a,b,left,mid);\n\t c+=mergeSort(a,b,mid+1,right);\n\t c+=merge(a,b,left,mid+1,right); }\t\n\treturn c;\t }\nstatic long merge(int a[],int  b[],long left,long mid,long right)\n{long c=0;int i=(int)left;int j=(int)mid; int k=(int)left;\nwhile(i<=(int)mid-1&&j<=(int)right)\n{ if(a[i]<=a[j]) {b[k++]=a[i++]; }\nelse\t{ b[k++]=a[j++];c+=mid-i;}}\nwhile (i <= (int)mid - 1)   b[k++] = a[i++]; \nwhile (j <= (int)right) b[k++] = a[j++];\nfor (i=(int)left; i <= (int)right; i++) \n\ta[i] = b[i];  return c;  }\n    \npublic static int[] radixSort(int[] f)\n{\n\tint[] to = new int[f.length];\n\t{\n\t\tint[] b = new int[65537];\n\t\tfor(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\tfor(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n\t\tint[] d = f; f = to;to = d;\n\t}\n\t{\n\t\tint[] b = new int[65537];\n\t\tfor(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\tfor(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n\t\tint[] d = f; f = to;to = d;\n\t}\n\treturn f;\n}    \nstatic  class InputReader\n{\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream)\n    {\n        this.stream = stream;\n    }\n\n    public int read()\n    {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars)\n        {\n            curChar = 0;\n            try\n            {\n                numChars = stream.read(buf);\n            } catch (IOException e)\n            {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt()\n    {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-')\n        {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do\n        {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public String readString()\n    {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do\n        {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n    public String readLine() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    }\n    \n\n    public double readDouble() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        double res = 0;\n        while (!isSpaceChar(c) && c != '.') {\n            if (c == 'e' || c == 'E')\n                return res * Math.pow(10, readInt());\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        }\n        if (c == '.') {\n            c = read();\n            double m = 1;\n            while (!isSpaceChar(c)) {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, readInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                m /= 10;\n                res += (c - '0') * m;\n                c = read();\n            }\n        }\n        return res * sgn;\n    }\n    public long readLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n    public boolean isSpaceChar(int c)\n    {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public String next()\n    {\n        return readString();\n    }\n\n    public interface SpaceCharFilter\n    {\n        public boolean isSpaceChar(int ch);\n    }\n    public boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n}\n\n  \n//BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t//StringBuilder sb=new StringBuilder(\"\");\n\t //InputReader in = new InputReader(System.in);\n\t//PrintWriter pw=new PrintWriter(System.out);\n\t//String line=br.readLine().trim();\n\t       \t\n\t//int t=Integer.parseInt(br.readLine());\n  //\twhile(t-->0)\n  \t//{\n  \t//int n=Integer.parseInt(br.readLine());\n\t//long n=Long.parseLong(br.readLine());\n\t//String l[]=br.readLine().split(\" \");\n  //int m=Integer.parseInt(l[0]);\n\t//int k=Integer.parseInt(l[1]);\n\t//String l[]=br.readLine().split(\" \");\n\t//l=br.readLine().split(\" \");\n\t/*int a[]=new int[n];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta[i]=Integer.parseInt(l[i]);\n\t}*/\n\t   //System.out.println(\" \");\t     \t\n\t\n\t//}\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class D911{\n\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = ia(n);\n\t\tint Q = ni();\n\t\tString[] ans = {\"even\", \"odd\"};\n\t\tint cur = merge(a, 0, n - 1) % 2;\n\t\twhile(Q-->0)\n\t\t{\n\t\t\tint l = ni(), r = ni();\n\t\t\tcur ^= (r - l + 1) / 2 % 2;\n\t\t\tout.println(ans[cur]);\n\t\t}\n\t\t\n\t}\n\t\n\tint merge(int[] a, int l, int r)\n\t{\n\t\tif(l >= r)\n\t\t\treturn 0;\n\t\tint mid = l + r >> 1;\n\t\tint v1 = merge(a, l, mid);\n\t\tint v2 = merge(a, mid + 1, r);\n\t\t\n\t\tint[] rep = new int[r-l+1];\n\t\tint ptr0 = 0, ptr1 = l, ptr2 = mid + 1;\n\t\t\n\t\tlong len = mid-l+1;\n\t\tint ret = 0;\n\t\twhile(ptr1<=mid && ptr2<=r)\n\t\t{\n\t\t\tif(a[ptr1] <= a[ptr2])\n\t\t\t{\n\t\t\t\tlen--;\n\t\t\t\trep[ptr0++] = a[ptr1++];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret += len;\n\t\t\t\trep[ptr0++] = a[ptr2++]; \n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(ptr1 <= mid)\n\t\t\trep[ptr0++] = a[ptr1++];\n\t\twhile(ptr2 <= r)\n\t\t\trep[ptr0++] = a[ptr2++];\n\t\t\n\t\tfor(int i=0;i<ptr0;i++)\n\t\t\ta[l+i] = rep[i];\n\t\t\n\t\treturn v1 + v2 + ret;\n\t}\n\t\n\tpublic static void main(String[] args){new D911().run();}\n\t\n\tprivate byte[] bufferArray = new byte[1024];\n\tprivate int bufLength = 0;\n\tprivate int bufCurrent = 0;\n\tInputStream inputStream;\n\tPrintWriter out;\n\t\n\tpublic void run()\n\t{\n\t\tinputStream = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\t\n\tint nextByte()\n\t{\n\t\tif(bufLength == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif(bufCurrent >= bufLength)\n\t\t{\n\t\t\tbufCurrent = 0;\n\t\t\ttry\n\t\t\t{bufLength = inputStream.read(bufferArray);}\n\t\t\tcatch(IOException e)\n\t\t\t{ throw new InputMismatchException();}\n\t\t\tif(bufLength <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn bufferArray[bufCurrent++];\n\t}\n\t\n\tboolean isSpaceChar(int x)\t{return (x < 33 || x > 126);}\n\t\n\tboolean isDigit(int x)\t{return (x >= '0' && x <= '9');}\n\t\n\tint nextNonSpace()\n\t{\n\t\tint x;\n\t\twhile((x=nextByte()) != -1 && isSpaceChar(x));\n\t\treturn x;\n\t}\n\t\n\tint ni()\n\t{\n\t\tlong ans = nl();\n\t\tif (ans >= Integer.MIN_VALUE && ans <= Integer.MAX_VALUE)\n\t\t\treturn (int)ans;\n\t\tthrow new InputMismatchException();\n\t}\n\t\n\tlong nl()\n\t{\n\t\tlong ans = 0;\n\t\tboolean neg = false;\n\t\tint x = nextNonSpace();\n\t\tif(x == '-') \n\t\t{\n\t\t\tneg = true;\n\t\t\tx = nextByte();\n\t\t}\n\t\twhile(!isSpaceChar(x))\n\t\t{\n\t\t\tif(isDigit(x))\n\t\t\t{\n\t\t\t\tans = ans * 10 + x -'0';\n\t\t\t\tx = nextByte();\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\treturn neg ? -ans : ans;\n\t}\n\t\n\tString ns()\n\t{\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint x = nextNonSpace();\n\t\twhile(!isSpaceChar(x))\n\t\t{\n\t\t\tsb.append((char)x);\n\t\t\tx = nextByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tchar nc()\t{ return (char)nextNonSpace();}\n\t\n\tdouble nd()\t{ return (double)Double.parseDouble(ns()); }\n\t\n\tchar[] ca()\t{ return ns().toCharArray();}\n\t\n\tchar[][] ca(int n)\n\t{\n\t\tchar[][] ans = new char[n][];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tans[i] = ca();\n\t\treturn ans;\n\t}\n\t\n\tint[] ia(int n)\n\t{\n\t\tint[] ans = new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tans[i] = ni();\n\t\treturn ans;\n\t}\n\t\n\tvoid db(Object... o) {System.out.println(Arrays.deepToString(o));}\n\t\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class E3 {\n\tInputStream is;\n\tFastWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tfor(int T = ni();T > 0;T--)go();\n\t}\n\n\tint[] lpf = enumLowestPrimeFactors(10000000);\n\n\tvoid go()\n\t{\n\t\tint n = ni(), K = ni();\n\t\tint[] a = na(n);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\ta[i] = factorFast(a[i], lpf);\n\t\t}\n\t\ta = shrink(a);\n\n\t\tint[][] dp = new int[K+1][n+1];\n\t\tfor(int i = 0;i <= K;i++){\n\t\t\tArrays.fill(dp[i], 999999999);\n\t\t}\n\t\tfor(int i = 0;i <= K;i++)dp[i][0] = 0;\n\n\t\tint[] prev = makePrev(a, n+1);\n\n\t\tint[] imos = new int[n+5];\n\t\tint[] pp = new int[K+1];\n\t\tint[] vs = new int[K+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint p = prev[i];\n\t\t\timos[p+1]--;\n\n\t\t\tfor(int j = 0;j <= K;j++){\n\t\t\t\tvs[j]++;\n\t\t\t\tif(pp[j] >= p+1){\n\t\t\t\t\tvs[j]--;\n\t\t\t\t}\n\t\t\t\twhile(vs[j] > j){\n\t\t\t\t\tpp[j]++;\n\t\t\t\t\tvs[j] += imos[pp[j]];\n\t\t\t\t}\n\t\t\t\tfor(int k = 0;k+j <= K;k++){\n\t\t\t\t\tdp[k+j][i+1] = Math.min(dp[k+j][i+1], dp[k][pp[j]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(dp[K][n]);\n\t}\n\n\tpublic static int[] shrink(int[] a) {\n\t\tint n = a.length;\n\t\tlong[] b = new long[n];\n\t\tfor (int i = 0; i < n; i++) b[i] = (long) a[i] << 32 | i;\n\t\tArrays.sort(b);\n\t\tint[] ret = new int[n];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0) p++;\n\t\t\tret[(int) b[i]] = p;\n\t\t}\n\t\treturn ret;\n\t}\n\n\n\tpublic static int[] makePrev(int[] a, int sup)\n\t{\n\t\tint n = a.length;\n\t\tint[] mnext = new int[sup];\n\t\tArrays.fill(mnext, -1);\n\t\tint[] next = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tnext[i] = mnext[a[i]];\n\t\t\tmnext[a[i]] = i;\n\t\t}\n\t\treturn next;\n\t}\n\n\tpublic static int factorFast(int n, int[] lpf)\n\t{\n\t\tint ret = 1;\n\t\tint e = 0;\n\t\tint last = -1;\n\t\twhile(lpf[n] > 0) {\n\t\t\tint p = lpf[n];\n\t\t\tif (last != p) {\n\t\t\t\tif (last > 0 && e % 2 == 1) {\n\t\t\t\t\tret = ret * last;\n\t\t\t\t}\n\n\t\t\t\tlast = p;\n\t\t\t\te = 1;\n\t\t\t} else {\n\t\t\t\te++;\n\t\t\t}\n\t\t\tn /= p;\n\t\t}\n\n\t\tif(last > 0 && e % 2 == 1){\n\t\t\tret *= last;\n\t\t}\n\t\treturn ret;\n\t}\n\n\n\tpublic static int[] enumLowestPrimeFactors(int n)\n\t{\n\t\tint tot = 0;\n\t\tint[] lpf = new int[n+1];\n\t\tint u = n+32;\n\t\tdouble lu = Math.log(u);\n\t\tint[] primes = new int[(int)(u/lu+u/lu/lu*1.5)];\n\t\tfor(int i = 2;i <= n;i++)lpf[i] = i;\n\t\tfor(int p = 2;p <= n;p++){\n\t\t\tif(lpf[p] == p)primes[tot++] = p;\n\t\t\tint tmp;\n\t\t\tfor(int i = 0;i < tot && primes[i] <= lpf[p] && (tmp = primes[i]*p) <= n;i++){\n\t\t\t\tlpf[tmp] = primes[i];\n\t\t\t}\n\t\t}\n\t\treturn lpf;\n\t}\n\n\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new FastWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new E3().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic static class FastWriter\n\t{\n\t\tprivate static final int BUF_SIZE = 1<<13;\n\t\tprivate final byte[] buf = new byte[BUF_SIZE];\n\t\tprivate final OutputStream out;\n\t\tprivate int ptr = 0;\n\n\t\tprivate FastWriter(){out = null;}\n\n\t\tpublic FastWriter(OutputStream os)\n\t\t{\n\t\t\tthis.out = os;\n\t\t}\n\n\t\tpublic FastWriter(String path)\n\t\t{\n\t\t\ttry {\n\t\t\t\tthis.out = new FileOutputStream(path);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"FastWriter\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter write(byte b)\n\t\t{\n\t\t\tbuf[ptr++] = b;\n\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(char c)\n\t\t{\n\t\t\treturn write((byte)c);\n\t\t}\n\n\t\tpublic FastWriter write(char[] s)\n\t\t{\n\t\t\tfor(char c : s){\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(String s)\n\t\t{\n\t\t\ts.chars().forEach(c -> {\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(int l) {\n\t\t\tif (l >= 1000000000) return 10;\n\t\t\tif (l >= 100000000) return 9;\n\t\t\tif (l >= 10000000) return 8;\n\t\t\tif (l >= 1000000) return 7;\n\t\t\tif (l >= 100000) return 6;\n\t\t\tif (l >= 10000) return 5;\n\t\t\tif (l >= 1000) return 4;\n\t\t\tif (l >= 100) return 3;\n\t\t\tif (l >= 10) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(int x)\n\t\t{\n\t\t\tif(x == Integer.MIN_VALUE){\n\t\t\t\treturn write((long)x);\n\t\t\t}\n\t\t\tif(ptr + 12 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(long l) {\n\t\t\tif (l >= 1000000000000000000L) return 19;\n\t\t\tif (l >= 100000000000000000L) return 18;\n\t\t\tif (l >= 10000000000000000L) return 17;\n\t\t\tif (l >= 1000000000000000L) return 16;\n\t\t\tif (l >= 100000000000000L) return 15;\n\t\t\tif (l >= 10000000000000L) return 14;\n\t\t\tif (l >= 1000000000000L) return 13;\n\t\t\tif (l >= 100000000000L) return 12;\n\t\t\tif (l >= 10000000000L) return 11;\n\t\t\tif (l >= 1000000000L) return 10;\n\t\t\tif (l >= 100000000L) return 9;\n\t\t\tif (l >= 10000000L) return 8;\n\t\t\tif (l >= 1000000L) return 7;\n\t\t\tif (l >= 100000L) return 6;\n\t\t\tif (l >= 10000L) return 5;\n\t\t\tif (l >= 1000L) return 4;\n\t\t\tif (l >= 100L) return 3;\n\t\t\tif (l >= 10L) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(long x)\n\t\t{\n\t\t\tif(x == Long.MIN_VALUE){\n\t\t\t\treturn write(\"\" + x);\n\t\t\t}\n\t\t\tif(ptr + 21 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(double x, int precision)\n\t\t{\n\t\t\tif(x < 0){\n\t\t\t\twrite('-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tx += Math.pow(10, -precision)/2;\n\t\t\t//\t\tif(x < 0){ x = 0; }\n\t\t\twrite((long)x).write(\".\");\n\t\t\tx -= (long)x;\n\t\t\tfor(int i = 0;i < precision;i++){\n\t\t\t\tx *= 10;\n\t\t\t\twrite((char)('0'+(int)x));\n\t\t\t\tx -= (int)x;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(char c){\n\t\t\treturn write(c).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(int x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(double x, int precision){\n\t\t\treturn write(x, precision).writeln();\n\t\t}\n\n\t\tpublic FastWriter write(int... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(int x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(long... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(long x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln()\n\t\t{\n\t\t\treturn write((byte)'\\n');\n\t\t}\n\n\t\tpublic FastWriter writeln(int... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[] line)\n\t\t{\n\t\t\treturn write(line).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[]... map)\n\t\t{\n\t\t\tfor(char[] line : map)write(line).writeln();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(String s)\n\t\t{\n\t\t\treturn write(s).writeln();\n\t\t}\n\n\t\tprivate void innerflush()\n\t\t{\n\t\t\ttry {\n\t\t\t\tout.write(buf, 0, ptr);\n\t\t\t\tptr = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"innerflush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic void flush()\n\t\t{\n\t\t\tinnerflush();\n\t\t\ttry {\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"flush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter print(byte b) { return write(b); }\n\t\tpublic FastWriter print(char c) { return write(c); }\n\t\tpublic FastWriter print(char[] s) { return write(s); }\n\t\tpublic FastWriter print(String s) { return write(s); }\n\t\tpublic FastWriter print(int x) { return write(x); }\n\t\tpublic FastWriter print(long x) { return write(x); }\n\t\tpublic FastWriter print(double x, int precision) { return write(x, precision); }\n\t\tpublic FastWriter println(char c){ return writeln(c); }\n\t\tpublic FastWriter println(int x){ return writeln(x); }\n\t\tpublic FastWriter println(long x){ return writeln(x); }\n\t\tpublic FastWriter println(double x, int precision){ return writeln(x, precision); }\n\t\tpublic FastWriter print(int... xs) { return write(xs); }\n\t\tpublic FastWriter print(long... xs) { return write(xs); }\n\t\tpublic FastWriter println(int... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(long... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(char[] line) { return writeln(line); }\n\t\tpublic FastWriter println(char[]... map) { return writeln(map); }\n\t\tpublic FastWriter println(String s) { return writeln(s); }\n\t\tpublic FastWriter println() { return writeln(); }\n\t}\n\n\tpublic void trnz(int... o)\n\t{\n\t\tfor(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+\":\"+o[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n\t// print ids which are 1\n\tpublic void trt(long... o)\n\t{\n\t\tQueue<Integer> stands = new ArrayDeque<>();\n\t\tfor(int i = 0;i < o.length;i++){\n\t\t\tfor(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n\t\t}\n\t\tSystem.out.println(stands);\n\t}\n\n\tpublic void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(long[]... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long[] r : b) {\n\t\t\t\tfor (long x : r) {\n\t\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic void tf(long... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long x : b) {\n\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import java.io.*;\nimport java.util.*;\n/*\n * Heart beats fast\n * \t\tColors and promises\n * \t\t\tHow to be brave\n * \t\t\t\tHow can I love when I am afraid...\n */\npublic class Main\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tlong x=nl(),k=nl();\n\t\tif(x==0)\n\t\t{\n\t\t\tpr(0);\n\t\t\texit();\n\t\t}\n\t\tx%=mod;\n\t\tpr((((x*powm(2,k+1,mod))%mod-powm(2,k,mod)+1)%mod+mod)%mod);\n\t\tSystem.out.print(output);\n\t}\n\t///////////////////////////////////////////\n\t///////////////////////////////////////////\n\t///template from here\n\tstatic class pair\n\t{\n\t\tlong a, b;\n\t\tpair(){}\n\t\tpair(long c,long d){a=c;b=d;}\n\t}\n\tstatic interface combiner\n\t{\n\t\tpublic long combine(long a, long b);\n\t}\n\tstatic final int mod=1000000007;\n\tstatic final double eps=1e-9;\n\tstatic final long inf=100000000000000000L;\n\tstatic Reader in=new Reader();\n\tstatic StringBuilder output=new StringBuilder();\n\tstatic Random rn=new Random();\n\tstatic void reverse(int[]a){for(int i=0; i<a.length/2; i++){a[i]^=a[a.length-i-1];a[a.length-i-1]^=a[i];a[i]^=a[a.length-i-1];}}\n\tstatic void sort(int[]a)\n\t{\n\t\tint te;\n\t\tfor(int i=0; i<a.length; i+=2)\n\t\t{\n\t\t\tte=rn.nextInt(a.length);\n\t\t\tif(i!=te)\n\t\t\t{\n\t\t\t\ta[i]^=a[te];\n\t\t\t\ta[te]^=a[i];\n\t\t\t\ta[i]^=a[te];\n\t\t\t}\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\tstatic void sort(long[]a)\n\t{\n\t\tint te;\n\t\tfor(int i=0; i<a.length; i+=2)\n\t\t{\n\t\t\tte=rn.nextInt(a.length);\n\t\t\tif(i!=te)\n\t\t\t{\n\t\t\ta[i]^=a[te];\n\t\t\ta[te]^=a[i];\n\t\t\ta[i]^=a[te];\n\t\t\t}\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\tstatic void sort(double[]a)\n\t{\n\t\tint te;\n\t\tdouble te1;\n\t\tfor(int i=0; i<a.length; i+=2)\n\t\t{\n\t\t\tte=rn.nextInt(a.length);\n\t\t\tif(i!=te)\n\t\t\t{\n\t\t\tte1=a[te];\n\t\t\ta[te]=a[i];\n\t\t\ta[i]=te1;\n\t\t\t}\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\tstatic void sort(int[][]a)\n\t{\n\t\tArrays.sort(a, new Comparator<int[]>()\n\t\t{\n\t\t\tpublic int compare(int[]a,int[]b)\n\t\t\t{\n\t\t\t\tif(a[0]>b[0])\n\t\t\t\t\treturn -1;\n\t\t\t\tif(b[0]>a[0])\n\t\t\t\t\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\t}\n\tstatic void sort(pair[]a)\n\t{\n\t\tArrays.sort(a,new Comparator<pair>()\n\t\t\t\t{\n\t\t\t@Override\n\t\t\tpublic int compare(pair a,pair b)\n\t\t\t{\n\t\t\t\tif(a.a>b.a)\n\t\t\t\t\treturn 1;\n\t\t\t\tif(b.a>a.a)\n\t\t\t\treturn -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\t});\n\t}\n\tstatic int log2n(long a)\n\t{\n\t\tint te=0;\n\t\twhile(a>0)\n\t\t{\n\t\t\ta>>=1;\n\t\t\t++te;\n\t\t}\n\t\treturn te;\n\t}\n\tstatic class vector implements Iterable<Integer>\n\t{\n\t\tint a[],size;\n\t\tvector(){a=new int[10];size=0;}\n\t\tvector(int n){a=new int[n];size=0;}\n\t\tpublic void add(int b){if(++size==a.length)a=Arrays.copyOf(a, 2*size);a[size-1]=b;}\n\t\tpublic void sort(){Arrays.sort(a, 0, size);}\n\t\tpublic void sort(int l, int r){Arrays.sort(a, l, r);}\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\tIterator<Integer> hola=new Iterator<Integer>()\n\t\t\t\t\t{\n\t\t\t\tint cur=0;\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\treturn cur<size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Integer next() {\n\t\t\t\t\t\t\treturn a[cur++];\n\t\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\t};\n\t\t\treturn hola;\n\t\t}\n\t}\n\t//output functions////////////////\n\tstatic void pr(Object a){output.append(a+\"\\n\");}\n\tstatic void pr(){output.append(\"\\n\");}\n\tstatic void p(Object a){output.append(a);}\n\tstatic void pra(int[]a){for(int i:a)output.append(i+\" \");output.append(\"\\n\");}\n\tstatic void pra(long[]a){for(long i:a)output.append(i+\" \");output.append(\"\\n\");}\n\tstatic void pra(String[]a){for(String i:a)output.append(i+\" \");output.append(\"\\n\");}\n\tstatic void pra(double[]a){for(double i:a)output.append(i+\" \");output.append(\"\\n\");}\n\tstatic void sop(Object a){System.out.println(a);}\n\tstatic void flush(){System.out.println(output);output=new StringBuilder();}\n\t//////////////////////////////////\n\t//input functions/////////////////\n\tstatic int ni(){return Integer.parseInt(in.next());}\n\tstatic long nl(){return Long.parseLong(in.next());}\n\tstatic String ns(){return in.next();}\n\tstatic double nd(){return Double.parseDouble(in.next());}\n\tstatic int[] nia(int n){int a[]=new int[n];for(int i=0; i<n; i++)a[i]=ni();return a;}\n\tstatic int[] pnia(int n){int a[]=new int[n+1];for(int i=1; i<=n; i++)a[i]=ni();return a;}\n\tstatic long[] nla(int n){long a[]=new long[n];for(int i=0; i<n; i++)a[i]=nl();return a;}\n\tstatic String[] nsa(int n){String a[]=new String[n];for(int i=0; i<n; i++)a[i]=ns();return a;}\n\tstatic double[] nda(int n){double a[]=new double[n];for(int i=0; i<n; i++)a[i]=nd();return a;}\n\t//////////////////////////////////\n\t//some utility functions\n\tstatic void exit(){System.out.print(output);System.exit(0);}\n\tstatic int min(int... a){int min=a[0];for(int i:a)min=Math.min(min, i);return min;}\n\tstatic int max(int... a){int max=a[0];for(int i:a)max=Math.max(max, i);return max;}\t\n\tstatic int gcd(int... a){int gcd=a[0];for(int i:a)gcd=gcd(gcd, i);return gcd;}\t\n\tstatic long min(long... a){long min=a[0];for(long i:a)min=Math.min(min, i);return min;}\n\tstatic long max(long... a){long max=a[0];for(long i:a)max=Math.max(max, i);return max;}\t\n\tstatic long gcd(long... a){long gcd=a[0];for(long i:a)gcd=gcd(gcd, i);return gcd;}\t\n\tstatic String pr(String a, long b){String c=\"\";while(b>0){if(b%2==1)c=c.concat(a);a=a.concat(a);b>>=1;}return c;}\n\tstatic long powm(long a, long b, long m)\n\t{long an=1;long c=a;while(b>0)\n\t{if(b%2==1)an=(an*c)%m;c=(c*c)%m;b>>=1;}return an;}\n\tstatic int gcd(int a, int b){if(b==0)return a;return gcd(b, a%b);}\n\tstatic long gcd(long a, long b){if(b==0)return a;return gcd(b, a%b);}\n\tstatic class Reader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public Reader() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n    }\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\npublic class G_PlaylistForPolycarp {\n\n\tstatic final int mod = 1000000007;\n\n\tstatic int dp[][];\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n\t\tString[] dat = br.readLine().split(\" \");\n\n\t\tint n = Integer.parseInt(dat[0]);\n\t\tint T = Integer.parseInt(dat[1]);\n\n\t\tint[] st = new int[n];\n\t\tbyte[] sg = new byte[n];\n\n\t\tdp = new int[1 << (n + 1)][4];\n\n\t\tfor (int j = 0; j < 1 << (n + 1); j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tdp[j][k] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdat = br.readLine().split(\" \");\n\t\t\tst[i] = Integer.parseInt(dat[0]);\n\t\t\tsg[i] = Byte.parseByte(dat[1]);\n\t\t}\n\n\t\tshort visited = 0;\n\n\t\tint count = recur(0, visited, st, sg, T, 0);\n\n\t\tbw.write(count + \"\\n\");\n\n\t\tbw.close();\n\n\t}\n\n\tprivate static int recur(int time, short visited, int[] st, byte[] sg, int T, int last) {\n\n\t\tint count = 0;\n\n\t\tif (dp[visited][last] != -1) {\n\t\t\treturn dp[visited][last];\n\t\t}\n\n\t\tfor (int i = 0; i < st.length; i++) {\n\n\t\t\tif ((visited & (1 << i)) == 0 && sg[i] != last) {\n\n\t\t\t\tif (time + st[i] == T) {\n\t\t\t\t\tcount += 1;\n\t\t\t\t} else if (time + st[i] < T) {\n\t\t\t\t\tshort visitedc = (short) (visited | (1 << i));\n\t\t\t\t\tcount += recur(time + st[i], visitedc, st, sg, T, sg[i]);\n\t\t\t\t\tif (count > mod) {\n\t\t\t\t\t\tcount = count % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn dp[visited][last] = count % mod;\n\t}\n\n}\n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.util.*;\npublic class G {\n    static int n,t;\n    static int[]a;\n    static int[]g;\n    static long[][][]dp;\n    static final long MOD=1000000007;\n    public static void main(String[]args){\n        Scanner sc=new Scanner(System.in);\n        n=sc.nextInt();\n        t=sc.nextInt();\n        a=new int[n];\n        g=new int[n];\n        for(int i=0;i<n;i++) {\n            a[i] = sc.nextInt();\n            g[i] = sc.nextInt();\n        }\n        dp=new long[4][1<<(n-1)+1][t+1];\n        for(int i=0;i<4;i++)\n            for(int j=0;j<1<<(n-1)+1;j++)\n                for(int k=0;k<=t;k++)\n                    dp[i][j][k]=-1;\n        System.out.println(dp(0,0,t));\n    }\n    private static long dp(int genre,int mask,int time){\n        if(time<0)\n            return 0;\n        if(dp[genre][mask][time]!=-1)\n            return dp[genre][mask][time];\n        if(time==0)\n            return 1;\n        dp[genre][mask][time]=0;\n        for(int i=0;i<n;i++) {\n            if (g[i] != genre && ((1 << i) & mask) == 0)\n                dp[genre][mask][time] = (dp[genre][mask][time]+dp(g[i], mask | (1 << i), time - a[i]))%MOD;\n        }\n        return dp[genre][mask][time];\n    }\n}", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.util.Scanner;\npublic class Solution {\n    public static void main(String [] args){\n        Scanner stdin = new Scanner(System.in);\n        long n = stdin.nextLong();\n        if(n<3)\tSystem.out.println(n);\n        else {\n            if(n%2==0){\n                long a=0,b=0;\n                if(n%3!=0)\ta = (n*(n-1)*(n-3));    \n                n--;\n                b = (n*(n-1)*(n-2));\n                System.out.println(Math.max(a, b));\n            }\n            else\tSystem.out.println(n*(n-1)*(n-2));\n        }\n    }\n}\n \t \t \t\t\t   \t \t\t \t \t \t \t \t\t", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\n/**\n * Created by IntelliJ IDEA.\n * User: aircube\n * Date: 11.01.11\n * Time: 4:14\n * To change this template use File | Settings | File Templates.\n */\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.concurrent.Exchanger;\n\n\npublic class Template {\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n\n    public static void main(String[] args) throws IOException {\n        new Template().run();\n    }\n\n    void run() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        st = null;\n        out = new PrintWriter(System.out);\n        solve();\n        br.close();\n        out.close();\n    }\n    double dm[];\n    double a[][];\n    boolean fil[];\n    int p[];\n    int n;\n    // x & (x - 1)\n    // 10\n    //\n    void solve() throws  IOException {\n        n = nextInt();\n        a = new double[n][n];\n        for(int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                a[i][j] = nextDouble();\n            }\n        dm = new double[1 << n];\n        dm[(1 << n) - 1] = 1;\n        for(int mask = (1 << n) - 1; mask >= 1; --mask) {\n            int c = Integer.bitCount(mask);\n            if (c == 1) continue ;\n            double p = 2.0 / (double)(c - 1) / (double) c;\n            for(int i = 0; i < n; ++i) {\n                for (int j =0 ; j < n; ++j) {\n                    if (i != j && (mask & (1 << i)) > 0 && (mask & (1 << j)) > 0) {\n                        dm[mask ^ (1 << j)] += a[i][j] * dm[mask] * p;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < n; ++i) {\n            out.print(dm[1 << i] + \" \");\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n}", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.util.Scanner;\n\n\n\npublic class code_1B {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint count = scan.nextInt();\n\n\t\tString[] strs = new String[count]; \n\n\t\tfor(int i=0;i<count;i++){\n\n\t\t\tstrs[i] = scan.next();\n\n\t\t}\n\n\t\tfor(int i=0;i<count;i++){\n\n\t\t\tStringBuffer sb = new StringBuffer();\n\n\t\t\tString str = strs[i];\n\n\t\t\tif(str.matches(\"R\\\\d+C\\\\d+\")){\n\n\t\t\t\tint col = Integer.valueOf(str.split(\"C\")[1]);\n\n\t\t\t\twhile(col>26){\n\n\t\t\t\t\tcol--;\n\n\t\t\t\t\tsb.append((char)(col%26+65));\n\n\t\t\t\t\tcol /=26;\n\n\t\t\t\t}\n\n\t\t\t\tsb.append((char)(col+64));\n\n\t\t\t\tsb.reverse();\n\n\t\t\t\tint rIndex = str.indexOf(\"R\");\n\n\t\t\t\tint cIndex = str.indexOf(\"C\");\n\n\t\t\t\tsb.append(str.substring(rIndex+1, cIndex));\n\n\t\t\t}else{\n\n\t\t\t\tString row = str.split(\"\\\\d\")[0];\n\n\t\t\t\tsb.append(\"R\");\n\n\t\t\t\tsb.append(str.split(row)[1]);\n\n\t\t\t\tsb.append(\"C\");\n\n\t\t\t\tint col = 0;\n\n\t\t\t\tfor(int j=0;j<row.length();j++){\n\n\t\t\t\t\tcol = col*26+(int)row.charAt(j)-64;\n\n\t\t\t\t}\n\n\t\t\t\tsb.append(col);\n\n\t\t\t}\n\n\t\t\tSystem.out.println(sb.toString());\n\n\t\t}\n\n\t}\n\n}\n\n", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.*;\n\npublic class LearnMath {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tscan.close();\n\t\t\n\t\tif ((N%2) == 0) {\n\t\t\tSystem.out.println(4 + \" \" + (N-4));\n\t\t}\n\t\telse {\n\t\t\tif (N > 18) {\n\t\t\t\tSystem.out.println(9 + \" \" + (N-9));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println((N-9) + \" \" + 9);\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Solution{\n\t\n\tstatic FastScanner fs = new FastScanner();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic int n, d;\n\t\n\t\n    public static void main(String[] args) throws IOException {\n    \t\n\t\t\n//    \tFastScanner fs = new FastScanner();\n//    \tPrintWriter out = new PrintWriter(System.out);\n    \t\t\n    \tint tt = 1;\n    \twhile(tt-->0) {\n    \t\t\n    \t\n    \t\tn = fs.nextInt();\n    \t\tint l = 1, r = 1 + n/2;\n    \t\t\n    \t\td = getB(l);\n    \t\tif(d%2!=0) {\n    \t\t\tout.println(\"! -1\");\n    \t\t\tout.flush();\n    \t\t\treturn;\n    \t\t}\n    \t\t\n    \t\tif(d==0) {\n    \t\t\tout.println(\"! 1\");\n    \t\t\tout.flush();\n    \t\t\treturn;\n    \t\t}\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\twhile(l<r) {\n    \t\t\tint mid = (l+r)/2;\n    \t\t\tif(check(mid)) {\n    \t\t\t\tl = mid + 1;\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tr = mid;\n    \t\t\t}\n    \t\t\tint f = 1;\n    \t\t}\n    \t\t\n    \t\t\n    \t\tout.println(\"! \"+l);\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t}\n    \t\n    \tout.close();\n    \t\t\n    }\n    \n    \n    static boolean check(int i) {\n    \tint k = getB(i);\n    \tif(sig(d)==sig(k)) {\n    \t\treturn true;\n    \t}\n    \treturn false;\n    }\n    \n    \n    static int getB(int i) {\n    \tout.println(\"? \"+i);\n    \tout.flush();\n    \tint x1 = fs.nextInt();\n    \tint j = i + n/2;\n    \tif(j>n) j -= n;\n    \tout.println(\"? \"+j);\n    \tout.flush();\n    \tint x2 = fs.nextInt();\n    \treturn x1 - x2;\n    }\n    \n    \n    static int sig(int x) {\n    \tif(x>0) return 1;\n    \telse if(x<0) return -1;\n    \treturn 0;\n    }\n    \n    \n    \n   \n    \n    \n    \n    \n    \n    static final Random random=new Random();\n    \n    static <T> void shuffle(T[] arr) {\n    \tint n = arr.length;\n    \tfor(int i=0;i<n;i++\t) {\n    \t\tint k = random.nextInt(n);\n    \t\tT temp = arr[k]; arr[k] = arr[i]; arr[i] = temp;\n    \t}\n    }\n    \n    \t\n    static void ruffleSort(int[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); int temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n    \n    static void ruffleSort(long[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); long temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n   \n  \n    \n    static void reverse(int[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tint temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    static void reverse(long[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tlong temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    \n    static <T> void reverse(T[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++) {\n    \t\tT temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \t\n    \t\n    static class FastScanner{\n    \tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \tStringTokenizer st = new StringTokenizer(\"\");\n     \n    \tpublic String next(){\n    \t\twhile(!st.hasMoreElements()){\n    \t\t\ttry{\n    \t\t\t\tst = new StringTokenizer(br.readLine());\n    \t\t\t} catch(IOException e){\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t\treturn st.nextToken();\n    \t}\n    \t\t\n    \tpublic String nextLine() throws IOException {\n    \t\treturn br.readLine();\n    \t}\n    \t\t\n    \tpublic int nextInt(){\n    \t\treturn Integer.parseInt(next());\n    \t}\n     \n    \tpublic int[] readArray(int n){\n    \t\tint[] a = new int[n];\n    \t\tfor(int i=0;i<n;i++)\n    \t\t\ta[i] = nextInt();\n    \t\treturn a;\n    \t}\n    \t\t\n    \tpublic long nextLong() {\n    \t\treturn Long.parseLong(next());\n    \t}\n    \t\t\n    \tpublic char nextChar() {\n    \t\treturn next().toCharArray()[0];\n    \t}\n    }\n   \t\n}\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[])\n    {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=1;\n        while(T-->0)\n        {\n            int n=input.nextInt();\n            TreeMap<Long,Integer> map=new TreeMap<>();\n            for(int i=0;i<n;i++)\n            {\n                long l=input.nextLong();\n                long r=input.nextLong();\n                if(map.containsKey(l))\n                {\n                    map.put(l,map.get(l)+1);\n                }\n                else\n                {\n                    map.put(l,1);\n                }\n                if(map.containsKey(r+1))\n                {\n                    map.put(r+1,map.get(r+1)-1);\n                }\n                else\n                {\n                    map.put(r+1,-1);\n                }\n            }\n            ArrayList<ArrayList<Long>> list=new ArrayList<>();\n            Iterator it=map.entrySet().iterator();\n            while(it.hasNext())\n            {\n                Map.Entry e=(Map.Entry)it.next();\n                long v=(long)e.getKey();\n                long r=(int)e.getValue();\n                ArrayList<Long> l=new ArrayList<>();\n                l.add(v);\n                l.add(r);\n                list.add(l);\n            }\n            for(int i=0;i<list.size();i++)\n            {\n                if(i!=0)\n                {\n                    list.get(i).set(1,list.get(i-1).get(1)+list.get(i).get(1));\n                }\n            }\n\n            long arr[]=new long[n+1];\n            for(int i=0;i<list.size()-1;i++)\n            {\n                long v=list.get(i+1).get(0)-1-list.get(i).get(0)+1;\n                long c=list.get(i).get(1);\n                arr[(int)c]+=v;\n            }\n            for(int i=1;i<=n;i++)\n            {\n                out.print(arr[i]+\" \");\n            }\n            out.println();\n        }\n        out.close();\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "nlogn", "problem": "1000_C", "from": "CODEFORCES", "tags": "data structures,implementation,sortings"}
{"src": "import java.util.Scanner;\n\npublic class Really_Big_Numbers {\n\tstatic long sum(long x) {\n\t\tString s=\"\"+x;\n\t\tlong r=0;\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tr+=Integer.parseInt(\"\"+s.charAt(i));\n\t\t}\n\t\treturn r;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tlong n=sc.nextLong();\n\t\tlong  s=sc.nextLong();\n\t\tlong r=0;\n//\t\t10<=x<=n     x-sum>=s\n\t\tlong st=Math.max(10, s);\n\t\tfor(long i=st;i<=n;i++) {\n\t\t\tif(i-sum(i)>=s) {\n\t\t\t\tr+=n-i+1;\n//\t\t\t\tSystem.out.println(i);\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti=((i/10)+1)*10-1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t}\n}\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tdouble f(int dist, double initSp, int a, int maxSp) {\n\t\tdouble distToReachMaxSpeed = 0.5 * (maxSp * maxSp - initSp * initSp)\n\t\t\t\t/ a;\n\n\t\tif (dist > distToReachMaxSpeed)\n\t\t\treturn 1d * (maxSp - initSp) / a + (dist - distToReachMaxSpeed)\n\t\t\t\t\t/ maxSp;\n\n\t\treturn (Math.sqrt(initSp * initSp + 2 * a * dist) - initSp) / a;\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint a = nextInt();\n\t\tint maxSp = nextInt();\n\t\tint len = nextInt();\n\t\tint signX = nextInt();\n\t\tint signSp = nextInt();\n\n\t\tif (maxSp <= signSp) {\n\t\t\tout.printf(\"%.9f\\n\", f(len, 0, a, maxSp));\n\t\t\treturn;\n\t\t}\n\n\t\tdouble distToReachSignSp = 0.5 * signSp * signSp / a;\n\t\tif (distToReachSignSp >= signX) {\n\t\t\tout.printf(\"%.9f\\n\", f(len, 0, a, maxSp));\n\t\t\treturn;\n\t\t}\n\n\t\tdouble distToReachMaxThenSign = 0.5\n\t\t\t\t* (maxSp * maxSp + maxSp * maxSp - signSp * signSp) / a;\n\t\tif (distToReachMaxThenSign <= signX) {\n\t\t\tdouble t = 1d * (2 * maxSp - signSp) / a\n\t\t\t\t\t+ (signX - distToReachMaxThenSign) / maxSp\n\t\t\t\t\t+ f(len - signX, signSp, a, maxSp);\n\t\t\tout.printf(\"%.9f\\n\", t);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdouble xSp = Math.sqrt(a * signX + signSp * signSp * 0.5);\n\t\tdouble xTime = (2 * xSp - signSp) / a;\n\t\tout.printf(\"%.9f\\n\", xTime + f(len - signX, signSp, a, maxSp));\n\t}\n\n\tvoid inp() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew D().inp();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class Test {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String s = in.readLine();\n        String[] p = in.readLine().split(\" \");\n        List<Integer> a = new ArrayList<Integer>();\n        for (String k : p) {\n            a.add(Integer.parseInt(k));\n        }\n        int n = a.size();\n        int c1 = 0;\n        int c2 = 0;\n        int c1p = 0;\n        int c2p = 0;\n        for (int i = 0; i < n; i++) {\n            if (a.get(i) % 2 == 0) {\n                c1++;\n                c1p = i;\n            } else {\n                c2++;\n                c2p = i;\n            }\n        }\n        if (c1 < c2) {\n            System.out.println(c1p + 1);\n        }  else {\n            System.out.println(c2p + 1);\n        }\n    }\n    \n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tlong f(int x, int y, int sz) {\n\t\tif (x > y) {\n\t\t\tint tmp = x;\n\t\t\tx = y;\n\t\t\ty = tmp;\n\t\t}\n\t\tif (sz <= x)\n\t\t\treturn (long) sz * (sz + 1) / 2;\n\t\tif (sz >= x + y - 1)\n\t\t\treturn (long) x * y;\n\t\tlong val = x * (x + 1) / 2;\n\t\tif (sz <= y)\n\t\t\treturn val + (long) (sz - x) * x;\n\n\t\tlong rest = x + y - 1 - sz;\n\t\treturn (long) x * y - (long) rest * (rest + 1) / 2;\n\t}\n\n\tlong count(int x, int y, int n, int time) {\n\t\tlong DL = f(x + 1, y + 1, time + 1);\n\t\tlong DR = f(n - x, y + 1, time + 1);\n\t\tlong UL = f(x + 1, n - y, time + 1);\n\t\tlong UR = f(n - x, n - y, time + 1);\n//\t\tif (time == 1)\n//\t\t\tSystem.err.println(DL + \" \" + DR + \" \" + UL + \" \" + UR);\n\t\tlong L = Math.min(x + 1, time + 1);\n\t\tlong R = Math.min(n - x, time + 1);\n\t\tlong U = Math.min(n - y, time + 1);\n\t\tlong D = Math.min(y + 1, time + 1);\n//\t\tif (time == 1)\n//\t\t\tSystem.err.println(L + \" \" + R + \" \" + U + \" \" + D);\n\t\treturn DL + DR + UL + UR - L - R - U - D + 1;\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint x = nextInt() - 1;\n\t\tint y = nextInt() - 1;\n\t\tlong need = nextLong();\n\n\t\tif (need == 1) {\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\n\t\tint low = 0;\n\t\tint high = Math.max(x, n - 1 - x) + Math.max(y, n - 1 - y);\n\t\t\n//\t\tfor (int i = 0; i <= 100; i++)\n//\t\t\tSystem.err.println(count(x, y, n, i));\n\n\t\twhile (low < high - 1) {\n\t\t\tint mid = (int) (((long) low + high) / 2);\n\t\t\tif (count(x, y, n, mid) >= need)\n\t\t\t\thigh = mid;\n\t\t\telse\n\t\t\t\tlow = mid;\n\t\t}\n\n\t\tout.println(high);\n\n\t}\n\n\tB() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew B();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n\npublic class A {\n    \n    static StringTokenizer st;\n    static BufferedReader in;\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n = nextInt();\n        int k = nextInt();\n        Integer[]a = new Integer[n+1];\n        for (int i = 1; i <= n; i++) {\n            a[i] = nextInt();\n        }\n        if (k==1) {\n            System.out.println(n);\n            return;\n        }\n        Arrays.sort(a, 1, n+1);\n        Set<Integer> set = new HashSet<Integer>();\n        int ans = 0;\n        int INF = (int) 1e9;\n        for (int i = 1; i <= n; i++) {\n            if (set.contains(a[i]))\n                continue;\n            int t = a[i];\n            int s = 1;\n            while ((long)t*k <= INF) {\n                t *= k;\n                if (Arrays.binarySearch(a, 1, n+1,  t) >= 0) {\n                    set.add(t);\n                    s++;\n                }\n                else\n                    break;\n            }\n            if (s % 2==0)\n                ans += s/2;\n            else\n                ans += s/2+1;\n        }\n        System.out.println(ans);\n        pw.close();\n    }\n    private static int nextInt() throws IOException{\n        return Integer.parseInt(next());\n    }\n    \n    private static long nextLong() throws IOException{\n        return Long.parseLong(next());\n    }\n    \n    private static double nextDouble() throws IOException{\n        return Double.parseDouble(next());\n    }\n    \n    private static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n}\n", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskE1 solver = new TaskE1();\n    int testCount = Integer.parseInt(in.next());\n    for (int i = 1; i <= testCount; i++) {\n      solver.solve(i, in, out);\n    }\n    out.close();\n  }\n\n  static class TaskE1 {\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      int m = in.nextInt();\n      // int n = 12;\n      // int m = 2000;\n      int[][] d = new int[2][1 << n];\n      int[] buf = new int[1 << n];\n      int[][] a = new int[m][n];\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n          a[j][i] = in.nextInt();\n          // a[j][i] = (int)((i * 12346L + j * 789L) % 100000);\n        }\n      }\n\n      ArrayList<Integer> inds = new ArrayList<>();\n      for (int i = 0; i < m; ++i) {\n        inds.add(i);\n      }\n      int[][] finalA = a;\n      Collections.sort(inds, new Comparator<Integer>() {\n\n        public int compare(Integer i1, Integer i2) {\n          int val1 = 0, val2 = 0;\n          for (int i = 0; i < n; ++i) {\n            if (finalA[i1][i] > val1) {\n              val1 = finalA[i1][i];\n            }\n          }\n          for (int i = 0; i < n; ++i) {\n            if (finalA[i2][i] > val2) {\n              val2 = finalA[i2][i];\n            }\n          }\n          return -Integer.compare(val1, val2);\n        }\n      });\n      int newM = Math.min(m, n + 1);\n      int[][] na = new int[newM][];\n      for (int i = 0; i < newM; ++i) {\n        int ind = inds.get(i);\n        na[i] = a[ind];\n      }\n      m = newM;\n      a = na;\n\n      for (int i = 0; i < m; ++i) {\n        int[] prev = d[i % 2], nx = d[(i + 1) % 2];\n        for (int shift = 0; shift < n; ++shift) {\n          int[] b = new int[n];\n          for (int j = 0; j < n; ++j) {\n            b[j] = a[i][(j + shift) % n];\n          }\n          System.arraycopy(prev, 0, buf, 0, prev.length);\n          for (int j = 0; j < n; ++j) {\n            int inc = b[j];\n            for (int mask = 0; mask < (1 << n); ++mask) {\n              if ((mask >> j) % 2 == 0) {\n                int val = buf[mask] + inc;\n                int nm = mask ^ (1 << j);\n                if (val > buf[nm]) {\n                  buf[nm] = val;\n                }\n              }\n            }\n          }\n          for (int mask = 0; mask < (1 << n); ++mask) {\n            if (nx[mask] < buf[mask]) {\n              nx[mask] = buf[mask];\n            }\n          }\n        }\n      }\n      out.printLine(d[m % 2][(1 << n) - 1]);\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public String nextToken() {\n      int c = readSkipSpace();\n      StringBuilder sb = new StringBuilder();\n      while (!isSpace(c)) {\n        sb.append((char) c);\n        c = read();\n      }\n      return sb.toString();\n    }\n\n    public String next() {\n      return nextToken();\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n}\n\n", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tn = sc.nextInt();\n\t\tif(n >1) {\n\t\t\tlong[] a = new long[n + 1];\n\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrays.sort(a, 1, n+1);\n\n\t\t\tw: for(int x = 1; x <= n; x++) {\n\t\t\t\tif(a[x] == a[x+1]) {\n\t\t\t\t\tif(x + 1 == n) {\n\t\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\t\tbreak w ;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(a[x + 1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}\n       \t \t\t \t\t \t     \t\t  \t\t \t", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author Trung Pham\n */\npublic class E {\n\n    public static double[] dp;\n    public static double[][] data;\n    public static int n;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n        n = in.nextInt();\n        data = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                data[i][j] = in.nextDouble();\n            }\n        }\n        dp = new double[1 << n];\n        Arrays.fill(dp, -1);\n        for (int i = 0; i < n; i++) {\n            int a = 1 << i;\n            out.print(cal(a) + \" \");\n        }\n        out.close();\n        //System.out.print(builder.toString());\n    }\n\n    public static double cal(int mask) {\n        if (mask == (1 << n) - 1) {\n            //  System.out.println(mask);\n            return 1;\n        }\n        if (dp[mask] != -1) {\n            return dp[mask];\n        }\n        double result = 0;\n        int c = 0;       \n        for (int i = 0; i < n; i++) {\n            int a = 1 << i;\n            if ((a & mask) != 0) {\n                c++;\n                for (int j = 0; j < n; j++) {\n                    int b = 1 << j;\n                    if ((b & mask) == 0) {\n                        result += (data[i][j] * cal(mask | b));\n                    }\n                }\n            }\n        }\n    \n        int nC2 = (c + 1) * c / 2;\n        dp[mask] = result / nC2;\n        return dp[mask];\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() {\n            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() {\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.util.*;\n\npublic class A {\n\tprivate static Scanner in;\n\n\tpublic void run() {\n\t\tlong a = in.nextLong();\n\t\tlong b = in.nextLong();\n\t\tlong ans = 0;\n\t\twhile (a > 0 && b > 0) {\n\t\t\tif (a >= b) {\n\t\t\t\tans += a / b;\n\t\t\t\ta %= b;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += b / a;\n\t\t\tb %= a;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tLocale.setDefault(Locale.US);\n\t\tin = new Scanner(System.in);\n\t\tnew A().run();\n\t\tin.close();\n\t}\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class lcm {\n\tstatic int n;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t//BufferedReader in = new BufferedReader(new FileReader(\"lcm.in\"));\n\t\tn = Integer.parseInt(in.readLine());\n\t\tSystem.out.println(lcm(n));\n\t\tin.close();\n\t}\n\t\n\tstatic long lcm(int n) {\n\t\tif (n == 1) return 1;\n\t\tif (n == 2) return 2;\n\t\t\n\t\tif(n%6==0) {\n\t\t\tlong ans = n-1;\n\t\t\tans *= n-2;\n\t\t\tans *= n-3;\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\tif (n%2==0) {\n\t\t\tlong ans = n;\n\t\t\tans *= n-1;\n\t\t\tans *= n-3;\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\tlong ans = n;\n\t\tans *= n-1;\n\t\tans *= n-2;\n\t\treturn ans;\n\t}\n}\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.*;\npublic class HeatIntense {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tdouble prefix[] = new double[n];\n\t\tint sum = 0;\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tint a = sc.nextInt();\n\t\t\tsum = sum + a;\n\t\t\tprefix[i] = sum ;\n\t\t\t\n\t\t}\n\t\t\n\t\tdouble ans = 0;\n\t\tfor(int i = 0; i<=n-k; i++)\n\t\t{\n\t\t\tfor(int j = i+k-1 ; j<n; j++)\n\t\t\t{\n\t\t\t\tdouble avg = 0;\n\t\t\t\tif(i > 0)\n\t\t\t\t{\n\t\t\t\t\tavg = (prefix[j] - prefix[i-1])/(j-i+1); \n\t\t\t\t\t//System.out.println(prefix[j]- prefix[i-1] + \" \" + avg);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tavg = prefix[j]/(j+1);\n\t\t\t\t//\tSystem.out.println(prefix[j] + \" \" + avg);\n\t\t\t\t}\n\t\t\t\tans = Math.max(avg, ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\n}\n", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Rishabhdeep Singh\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        int MOD = (int) 1e9 + 7;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            long x = in.nextLong(), k = in.nextLong();\n            long res = Utilities.mul(x, Utilities.power(2, k + 1, MOD), MOD) % MOD - Utilities.power(2, k, MOD) + 1;\n            while (res < 0) res += MOD;\n            out.println(x == 0 ? 0 : res);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class Utilities {\n        public static long mul(long x, long y, long mod) {\n            return (x % mod) * (y % mod) % mod;\n        }\n\n        public static long power(long a, long k, long m) {\n            long res = 1;\n            while (k > 0) {\n                if ((k & 1) != 0) {\n                    res = mul(res, a, m);\n                }\n                a = mul(a, a, m);\n                k >>= 1;\n            }\n            return res;\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.Collection;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.FileInputStream;\nimport java.io.InputStreamReader;\nimport java.util.Objects;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Nafiur Rahman Khadem Shafin \ud83d\ude42\n */\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader (inputStream);\n\t\tPrintWriter out = new PrintWriter (outputStream);\n\t\tProblemCFireAgain solver = new ProblemCFireAgain ();\n\t\tsolver.solve (1, in, out);\n\t\tout.close ();\n\t}\n\t\n\tstatic class ProblemCFireAgain {\n\t\tprivate static final byte[] dx = {-1, 0, 0, 1};\n\t\tprivate static final byte[] dy = {0, -1, 1, 0};\n\t\tprivate static int[][] lvl;\n\t\tprivate static int max;\n\t\tprivate static int n;\n\t\tprivate static int m;\n\t\tprivate static int k;\n\t\tprivate static ProblemCFireAgain.Pair[] bgn;\n\t\tprivate static ProblemCFireAgain.Pair res;\n\t\t\n\t\tprivate static void bfs2d () {\n\t\t\tQueue<ProblemCFireAgain.Pair> bfsq = new LinkedList<ProblemCFireAgain.Pair> ();\n\t\t\tfor (ProblemCFireAgain.Pair src : bgn) {\n\t\t\t\tlvl[src.a][src.b] = 0;\n\t\t\t\tbfsq.add (src);\n\t\t\t}\n\t\t\twhile (!bfsq.isEmpty ()) {\n\t\t\t\tProblemCFireAgain.Pair op = bfsq.poll ();\n\t\t\t\tint plvl = lvl[op.a][op.b];\n//\t\t\tSystem.out.println (\"ber hoise \"+op+\" \"+plvl);\n\t\t\t\tif (plvl>max) {\n\t\t\t\t\tres = op;\n\t\t\t\t\tmax = plvl;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i<4; i++) {\n\t\t\t\t\tint newX = op.a+dx[i];\n\t\t\t\t\tint newY = op.b+dy[i];\n//\t\t\t\tSystem.out.println (newX+\" \"+newY+\" \"+n+\" \"+m);\n\t\t\t\t\tif (newX>0 && newX<=n && newY>0 && newY<=m && lvl[newX][newY] == -1) {\n\t\t\t\t\t\tbfsq.add (new ProblemCFireAgain.Pair (newX, newY));\n\t\t\t\t\t\tlvl[newX][newY] = (plvl+1);\n//\t\t\t\t\tSystem.out.println (\"dhukse \"+newX+\" \"+newY);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void solve (int testNumber, InputReader _in, PrintWriter _out) {\n\t\t\t/*\n\t\t\t * file input-output \ud83d\ude2e. Multi source bfs. Same as snackdown problem.\n\t\t\t * */\n\t\t\ttry (InputReader in = new InputReader (new FileInputStream (\"input.txt\"));\n\t\t\t\t PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (\"output.txt\")))) {\n\t\t\t\tn = in.nextInt ();\n\t\t\t\tm = in.nextInt ();\n\t\t\t\tk = in.nextInt ();\n\t\t\t\tbgn = new ProblemCFireAgain.Pair[k];\n\t\t\t\tfor (int i = 0; i<k; i++) {\n\t\t\t\t\tbgn[i] = new ProblemCFireAgain.Pair (in.nextInt (), in.nextInt ());\n\t\t\t\t}\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tlvl = new int[n+5][m+5];\n\t\t\t\tfor (int i = 0; i<n+4; i++) {\n\t\t\t\t\tArrays.fill (lvl[i], -1);\n\t\t\t\t}\n\t\t\t\tbfs2d ();\n//\t\t\tSystem.out.println (max);\n\t\t\t\tout.println (res);\n\t\t\t} catch (Exception e) {\n//\t\t\te.printStackTrace ();\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate static class Pair {\n\t\t\tint a;\n\t\t\tint b;\n\t\t\t\n\t\t\tPair (int a, int b) {\n\t\t\t\tthis.a = a;\n\t\t\t\tthis.b = b;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tpublic String toString () {\n\t\t\t\treturn a+\" \"+b;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tpublic boolean equals (Object o) {\n\t\t\t\tif (this == o) return true;\n\t\t\t\tif (!(o instanceof ProblemCFireAgain.Pair)) return false;\n\t\t\t\tProblemCFireAgain.Pair pair = (ProblemCFireAgain.Pair) o;\n\t\t\t\treturn a == pair.a && b == pair.b;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tpublic int hashCode () {\n\t\t\t\treturn Objects.hash (a, b);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class InputReader implements AutoCloseable {\n\t\tprivate BufferedReader reader;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic InputReader (InputStream stream) {\n\t\t\treader = new BufferedReader (new InputStreamReader (stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\t\n\t\tpublic String next () {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens ()) {\n\t\t\t\ttry {\n\t\t\t\t\tString str;\n\t\t\t\t\tif ((str = reader.readLine ()) != null) tokenizer = new StringTokenizer (str);\n\t\t\t\t\telse return null;//to detect eof\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException (e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken ();\n\t\t}\n\t\t\n\t\tpublic int nextInt () {\n\t\t\treturn Integer.parseInt (next ());\n\t\t}\n\t\t\n\t\t\n\t\tpublic void close () throws Exception {\n\t\t\treader.close ();\n\t\t}\n\t\t\n\t}\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\n\n\n\n\n\n\n\npublic class B2 {\n\tString s = null;\n\n\tString[] ss = null;\n\tint[][] sn = null;\n\tint n = 0;\n\tdouble ans = 1;\n\tint A = 0;\n\tpublic void run() throws Exception{\n\n\t\tBufferedReader br = null;\n\t\tFile file = new File(\"input.txt\");\n\t\tif(file.exists()){\n\t\t\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t}\n\t\telse{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\n\t\ts = br.readLine();\n\t\tss = s.split(\" \");\n\t\t\n\t\t\n\t\t\n\t\tn = Integer.parseInt(ss[0]);\n\t\tint k = Integer.parseInt(ss[1]);\n\t\tA = Integer.parseInt(ss[2]);\n\t\tsn = new int[n][2];\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ts = br.readLine();\n\t\t\tss = s.split(\" \");\n\t\t\tsn[i][0] = Integer.parseInt(ss[0]);\n\t\t\tsn[i][1] = Integer.parseInt(ss[1]);\n\t\t}\n\n\t\tint num = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tnum += (100 - sn[i][1]) / 10;\n\t\t}\n\t\tif(k >= num){\n\t\t\tSystem.out.println(\"1.0\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tcheck(0, k, sn);\n\t\t\n\t\tans = 1 - ans;\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\t\n\tvoid check(int i, int k, int[][] sn){\n\t\tif(i == n && k == 0){\n\t\t\tcheck2(sn);\n\t\t\treturn;\n\t\t}\n\t\telse if(i == n && k > 0){\n\t\t\treturn;\n\t\t}\n\t\telse if(k == 0){\n\t\t\tcheck(i+1, k, sn);\n\t\t}\n\t\telse{\n\t\t\tfor(int j = 0; j <= k; j++){\n\t\t\t\tif(sn[i][1] + j * 10 <= 100){\n\t\t\t\t\tint[][] nsn = copy(sn);\n\t\t\t\t\tnsn[i][1] += j * 10;\n\t\t\t\t\tcheck(i+1, k - j, nsn);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid check2(int[][] sn){\n\t\tList<Integer> target = new ArrayList<Integer>();\n\t\tint h = 0;\n\t\tfor(int i = 0; i < sn.length; i++){\n\t\t\tif(sn[i][1] != 100){\n\t\t\t\ttarget.add(i);\n\t\t\t}\n\t\t\telse{\n\t\t\t\th++;\n\t\t\t}\n\t\t}\n\t\tif(h  > n / 2){\n\t\t\tSystem.out.println(\"1.0\");\n\t\t\tSystem.exit(0);\t\n\t\t}\n\t\tint makemax = n - h;\n\t\tint makemin = (n+1)/2;\n\t\tdouble ma = 0;\n\t\tfor(int i = makemax; i >= makemin; i--){\n\t\t\tCombination c = new Combination(makemax, i);\n\t\t\tIterator<int[]> ite = c.iterator();\n\t\t\t\n\t\t\twhile(ite.hasNext()){\n\t\t\t\tint[] ret = ite.next();\n\t\t\t\tSet<Integer> make = new HashSet<Integer>();\n\t\t\t\tfor(int j = 0; j < ret.length; j++){\n\t\t\t\t\tif(ret[j] > 0){\n\t\t\t\t\t\tmake.add(target.get(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdouble makeK = 1;\n\t\t\t\tint B = 0;\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tint perc = 0;\n\t\t\t\t\tif(make.contains(j)){\n\t\t\t\t\t\tperc = 100 - sn[j][1];\n\t\t\t\t\t\tB += sn[j][0];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tperc = sn[j][1];\n\t\t\t\t\t}\n\t\t\t\t\tmakeK *= ((double)perc / 100);\n\t\t\t\t}\n\t\t\t\tma += makeK * (1 - (double)A/(A+B));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tans = Math.min(ans, ma);\n\t}\n\t\n\tint[][] copy(int[][] sn){\n\t\tint[][] csn = new int[sn.length][2];\n\t\t\n\t\tfor(int i = 0; i < sn.length; i++){\n\t\t\tcsn[i][0] = sn[i][0];\n\t\t\tcsn[i][1] = sn[i][1];\n\t\t}\n\t\t\n\t\treturn csn;\n\t}\n\t\n\n\t\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws Exception{\n\t\tB2 t = new B2();\n\t\tt.run();\n\n\t}\n\n\t\n\tpublic class Combination implements Iterable<int[]> {\n\t\tprivate final int max;\n\t\tprivate final int select;\n\t\t\n\t\tpublic Combination(int max, int select) {\n\t\t\tif (max < 1 || 62 < max) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\tthis.max = max;\n\t\t\tthis.select = select;\n\t\t}\n\t\n\t\tpublic Iterator<int[]> iterator() {\n\t\t\treturn new CombinationIterator(max, select);\n\t\t}\n\t\t\n\t\tprivate class CombinationIterator implements Iterator<int[]> {\n\t\t\tprivate long value;\n\t\t\tprivate final long max;\n\t\t\tprivate final int size;\n\t\t\tprivate int[] ret = null;\n\t\t\tpublic CombinationIterator(int max, int select) {\n\t\t\t\tthis.value = (1L << select) - 1L;\n\t\t\t\tthis.size = max;\n\t\t\t\tthis.max = 1L << max;\n\t\t\t\tthis.ret = new int[size];\n\t\t\t}\n\n\t\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn value < max;\n\t\t\t}\n\n\n\t\t\tpublic int[] next() {\n\t\t\t\tlong stock = value;\n\t\t\t\tvalue = next(value);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tlong tmp = stock >> i;\n\t\t\t\t\ttmp = tmp & 1;\n\t\t\t\t\tret[i] = (int)tmp;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\tprivate long next(long source) {\n\t\t\t\tlong param1 = smallestBitOf(source);\n\t\t\t\tlong param2 = param1 + source;\n\t\t\t\tlong param3 = smallestBitOf(param2);\n\t\t\t\tlong param5 = (param3 / param1) >>> 1;\n\t\t\t\treturn param5 - 1 + param2;\n\t\t\t}\n\n\t\t\tprivate long smallestBitOf(long source) {\n\t\t\t\tlong result = 1L;\n\t\t\t\twhile (source % 2 == 0) {\n\t\t\t\t\tsource >>>= 1;\n\t\t\t\t\tresult <<= 1;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n\n/*\n * Author    : joney_000[jaswantsinghyada007@gmail.com]\n * Algorithm : N/A\n * Platform  : Codeforces\n * Ref       : \n */\n\npublic class A{ \n  \n  private InputStream inputStream ;\n  private OutputStream outputStream ;\n  private FastReader in ;\n  private PrintWriter out ;\n  \n  private final int BUFFER = 100005;\n  private final long mod = 1000000000+7;\n  private final int  INF  = Integer.MAX_VALUE;\n  private final long INF_L  = Long.MAX_VALUE / 10;\n\n  public A(){}\n  public A(boolean stdIO)throws FileNotFoundException{\n    // stdIO = false;\n    if(stdIO){\n      inputStream = System.in;\n      outputStream = System.out;\n    }else{\n      inputStream = new FileInputStream(\"input.txt\");\n      outputStream = new FileOutputStream(\"output.txt\");\n    }\n    in = new FastReader(inputStream);\n    out = new PrintWriter(outputStream);\n  }\n  \n  void run()throws Exception{\n    long x = l(); long k = l();\n    if(x == 0){\n      out.write(\"0\");\n      return;\n    }\n    x %= mod;\n    long a = (x * pow(2L, k, mod) + mod)%mod;\n    long b = (a - pow(2L, k, mod) + 1 + mod)%mod;\n    long res = (a + b + mod )%mod;\n    out.write(\"\"+res+\"\\n\");\n  }\n\n  long gcd(long a, long b){\n    if(b == 0)return a;\n    return gcd(b, a % b);\n  }\n\n  long lcm(long a, long b){\n    if(a == 0 || b == 0)return 0;\n    return (a * b)/gcd(a, b);\n  }\n\n  long mulMod(long a, long b, long mod){\n    if(a == 0 || b == 0)return 0;\n    if(b == 1)return a;\n    long ans = mulMod(a, b/2, mod);\n    ans = (ans * 2) % mod;\n    if(b % 2 == 1)ans = (a + ans)% mod;\n    return ans;\n  }\n\n  long pow(long a, long b, long mod){\n    if(b == 0)return 1;\n    if(b == 1)return a;\n    long ans = pow(a, b/2, mod);\n    ans = (ans * ans);\n    if(ans >= mod)ans %= mod;\n\n    if(b % 2 == 1)ans = (a * ans);\n    if(ans >= mod)ans %= mod;\n\n    return ans;\n  }\n\n  // 20*20   nCr Pascal Table\n  long[][] ncrTable(){\n    long ncr[][] = new long[21][21];\n\n    for(int i = 0; i <= 20; i++){\n      ncr[i][0] = ncr[i][i] = 1L;\n    }\n\n    for(int j = 0; j <= 20; j++){\n      for(int i = j + 1; i <= 20; i++){\n        ncr[i][j] = ncr[i-1][j] + ncr[i-1][j-1];\n      }\n    }\n\n    return ncr;\n  }\n\n  int i()throws Exception{\n    return in.nextInt();\n  }\n\n  long l()throws Exception{\n    return in.nextLong();\n  }\n\n  double d()throws Exception{\n    return in.nextDouble();\n  }\n\n  char c()throws Exception{\n    return in.nextCharacter();\n  }\n\n  String s()throws Exception{\n    return in.nextLine();\n  }\n\n  BigInteger bi()throws Exception{\n    return in.nextBigInteger();\n  }\n\n  private void closeResources(){\n    out.flush();\n    out.close();\n    return;\n  }\n\n//  IMP: roundoff upto 2 digits \n//  double roundOff = Math.round(a * 100.0) / 100.0;\n//                    or\n//  System.out.printf(\"%.2f\", val);\n\n//  print upto 2 digits after decimal\n//  val = ((long)(val * 100.0))/100.0;    \n\n  public static void main(String[] args) throws java.lang.Exception{\n  \n    A driver = new A(true);\n    driver.run();\n    driver.closeResources();\n  }\n}\n\nclass FastReader{\n\n  private boolean finished = false;\n\n  private InputStream stream;\n  private byte[] buf = new byte[4 * 1024];\n  private int curChar;\n  private int numChars;\n  private SpaceCharFilter filter;\n\n  public FastReader(InputStream stream){\n    this.stream = stream;\n  }\n\n  public int read(){\n    if (numChars == -1){\n      throw new InputMismatchException ();\n    }\n    if (curChar >= numChars){\n      curChar = 0;\n      try{\n        numChars = stream.read (buf);\n      } catch (IOException e){\n        throw new InputMismatchException ();\n      }\n      if (numChars <= 0){\n        return -1;\n      }\n    }\n    return buf[curChar++];\n  }\n\n  public int peek(){\n    if (numChars == -1){\n      return -1;\n    }\n    if (curChar >= numChars){\n      curChar = 0;\n      try{\n        numChars = stream.read (buf);\n      } catch (IOException e){\n        return -1;\n      }\n      if (numChars <= 0){\n        return -1;\n      }\n    }\n    return buf[curChar];\n  }\n\n  public int nextInt(){\n    int c = read ();\n    while (isSpaceChar (c))\n      c = read ();\n    int sgn = 1;\n    if (c == '-'){\n      sgn = -1;\n      c = read ();\n    }\n    int res = 0;\n    do{\n      if(c==','){\n        c = read();\n      }\n      if (c < '0' || c > '9'){\n        throw new InputMismatchException ();\n      }\n      res *= 10;\n      res += c - '0';\n      c = read ();\n    } while (!isSpaceChar (c));\n    return res * sgn;\n  }\n\n  public long nextLong(){\n    int c = read ();\n    while (isSpaceChar (c))\n      c = read ();\n    int sgn = 1;\n    if (c == '-'){\n      sgn = -1;\n      c = read ();\n    }\n    long res = 0;\n    do{\n      if (c < '0' || c > '9'){\n        throw new InputMismatchException ();\n      }\n      res *= 10;\n      res += c - '0';\n      c = read ();\n    } while (!isSpaceChar (c));\n    return res * sgn;\n  }\n\n  public String nextString(){\n    int c = read ();\n    while (isSpaceChar (c))\n      c = read ();\n    StringBuilder res = new StringBuilder ();\n    do{\n      res.appendCodePoint (c);\n      c = read ();\n    } while (!isSpaceChar (c));\n    return res.toString ();\n  }\n\n  public boolean isSpaceChar(int c){\n    if (filter != null){\n      return filter.isSpaceChar (c);\n    }\n    return isWhitespace (c);\n  }\n\n  public static boolean isWhitespace(int c){\n    return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n  }\n\n  private String readLine0(){\n    StringBuilder buf = new StringBuilder ();\n    int c = read ();\n    while (c != '\\n' && c != -1){\n      if (c != '\\r'){\n        buf.appendCodePoint (c);\n      }\n      c = read ();\n    }\n    return buf.toString ();\n  }\n\n  public String nextLine(){\n    String s = readLine0 ();\n    while (s.trim ().length () == 0)\n      s = readLine0 ();\n    return s;\n  }\n\n  public String nextLine(boolean ignoreEmptyLines){\n    if (ignoreEmptyLines){\n      return nextLine ();\n    }else{\n      return readLine0 ();\n    }\n  }\n\n  public BigInteger nextBigInteger(){\n    try{\n      return new BigInteger (nextString ());\n    } catch (NumberFormatException e){\n      throw new InputMismatchException ();\n    }\n  }\n\n  public char nextCharacter(){\n    int c = read ();\n    while (isSpaceChar (c))\n      c = read ();\n    return (char) c;\n  }\n\n  public double nextDouble(){\n    int c = read ();\n    while (isSpaceChar (c))\n      c = read ();\n    int sgn = 1;\n    if (c == '-'){\n      sgn = -1;\n      c = read ();\n    }\n    double res = 0;\n    while (!isSpaceChar (c) && c != '.'){\n      if (c == 'e' || c == 'E'){\n        return res * Math.pow (10, nextInt ());\n      }\n      if (c < '0' || c > '9'){\n        throw new InputMismatchException ();\n      }\n      res *= 10;\n      res += c - '0';\n      c = read ();\n    }\n    if (c == '.'){\n      c = read ();\n      double m = 1;\n      while (!isSpaceChar (c)){\n        if (c == 'e' || c == 'E'){\n          return res * Math.pow (10, nextInt ());\n        }\n        if (c < '0' || c > '9'){\n          throw new InputMismatchException ();\n        }\n        m /= 10;\n        res += (c - '0') * m;\n        c = read ();\n      }\n    }\n    return res * sgn;\n  }\n\n  public boolean isExhausted(){\n    int value;\n    while (isSpaceChar (value = peek ()) && value != -1)\n      read ();\n    return value == -1;\n  }\n\n  public String next(){\n    return nextString ();\n  }\n\n  public SpaceCharFilter getFilter(){\n    return filter;\n  }\n\n  public void setFilter(SpaceCharFilter filter){\n    this.filter = filter;\n  }\n\n  public interface SpaceCharFilter{\n    public boolean isSpaceChar(int ch);\n  }\n}\n\nclass Pair implements Comparable<Pair>{\n  public int a;\n  public int b;\n  public int c;\n\n  public Pair(){\n    this.a = 0;\n    this.b = 0;\n    this.c = 0;\n  }\n\n  public Pair(int a,int b, int c){\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n\n  public int compareTo(Pair p){\n   return this.c - p.c; \n  }\n\n  @Override\n  public String toString(){\n    return \"a = \" + this.a + \" b = \" + this.b + \" c = \"+this.c;\n  }\n} ", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class CFC {\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    private static final long MOD = 1000L * 1000L * 1000L + 7;\n    private static final int[] dx = {0, -1, 0, 1};\n    private static final int[] dy = {1, 0, -1, 0};\n    private static final String yes = \"Yes\";\n    private static final String no = \"No\";\n\n    void solve() throws IOException {\n        long x = nextLong();\n        long k = nextLong();\n        if (x == 0) {\n            outln(0);\n            return;\n        }\n        x %= MOD;\n        long two = powMod(2, k, MOD);\n        long res = two;\n        res *= 2;\n        res %= MOD;\n        res *= x;\n        res %= MOD;\n        res -= two - 1;\n        while (res < 0) {\n            res += MOD;\n        }\n        while (res >= MOD) {\n            res -= MOD;\n        }\n\n        outln(res);\n    }\n\n    public long powMod(long N, long M, long MOD){//N^M % MOD\n        if(M == 0L)\n            return 1L;\n        long[] hp = new long[64];\n        boolean[] bp = new boolean[64];\n        hp[0] = N;\n        for(int i = 1; i < hp.length; i++) {\n            hp[i] = (hp[i - 1] * hp[i - 1]) % MOD;\n        }\n        for(int j = 0; j < hp.length; j++) {\n            if((M & (1L << j)) != 0)\n                bp[j] = true;\n        }\n        long res = 1;\n        for(int i = 0;i < bp.length; i++){\n            if(bp[i]) {\n                res = (res * hp[i]) % MOD;\n            }\n        }\n        return res;\n    }\n\n    void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n    long gcd(long a, long b) {\n        while(a != 0 && b != 0) {\n            long c = b;\n            b = a % b;\n            a = c;\n        }\n        return a + b;\n    }\n    private void outln(Object o) {\n        out.println(o);\n    }\n    private void out(Object o) {\n        out.print(o);\n    }\n    public CFC() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFC();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class CF_111_A {\n\n    public static void main(String[] args){\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt(), sum = 0, sum2 = 0;\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++){\n            a[i] = in.nextInt();\n            sum += a[i];\n        }\n        \n        Arrays.sort(a);\n        \n        for (int i = n - 1; i >=0; i--){\n            sum2 +=a[i];\n            if (sum2 * 2 > sum){\n                System.out.println(n - 1 - i + 1);\n                System.exit(0);             \n            }\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n\n            Map<Integer, List<Range>> rgs = new HashMap<Integer, List<Range>>();\n            for (int i = 0; i < n; i++) {\n                int s = 0;\n                for (int j = i; j < n; j++) {\n                    s += a[j];\n\n                    if (rgs.get(s) == null) {\n                        rgs.put(s, new ArrayList<Range>());\n                    }\n\n                    rgs.get(s).add(new Range(i, j));\n                }\n            }\n\n            Iterator it = rgs.entrySet().iterator();\n\n            List<Range> ans = new ArrayList<Range>();\n\n            while (it.hasNext()) {\n                Map.Entry pair = (Map.Entry) it.next();\n                int sum = (int) pair.getKey();\n                Object[] intermediate = ((List<Object[]>) pair.getValue()).toArray();\n                Range[] ranges = new Range[intermediate.length];\n                for (int i = 0; i < intermediate.length; i++) {\n                    ranges[i] = (Range) intermediate[i];\n                }\n                Arrays.sort(ranges);\n\n                List<Range> cand = new ArrayList<Range>();\n\n                for (Range r : ranges) {\n                    if (cand.size() == 0) {\n                        cand.add(r);\n                        continue;\n                    }\n\n                    if (cand.get(cand.size() - 1).j < r.i) {\n                        cand.add(r);\n                    } else {\n                        if (cand.get(cand.size() - 1).j > r.j) {\n                            cand.remove(cand.size() - 1);\n                            cand.add(r);\n                        }\n                    }\n                }\n\n                if (cand.size() > ans.size()) {\n                    ans = cand;\n                }\n            }\n\n            out.println(ans.size());\n            for (Range r : ans) {\n                out.println((r.i + 1) + \" \" + (r.j + 1));\n            }\n        }\n\n        public class Range implements Comparable {\n            public int i;\n            public int j;\n\n            public Range(int i, int j) {\n                this.i = i;\n                this.j = j;\n            }\n\n            public int compareTo(Object o) {\n                Range t = (Range) o;\n                if (this.i == t.i) {\n                    if (this.j < t.j) return 1;\n                    else return 0;\n                }\n                if (this.i < t.i) return 1;\n                return 0;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Task2 {\n\n    public static void main(String[] args) throws IOException {\n\n        new Task2().solve();\n\n    }\n\n    //ArrayList<Integer>[] g;\n\n    int mod = 1000000007;\n\n    PrintWriter out;\n\n    int n;\n    int m;\n    //int[][] a = new int[1000][1000];\n\n\n    //int cnt = 0;\n\n    long base = (1L << 63);\n    long P = 31;\n\n    int[][] a;\n\n    void solve() throws IOException {\n\n        //Reader in = new Reader(\"in.txt\");\n        //out = new PrintWriter( new BufferedWriter(new FileWriter(\"output.txt\")) );\n        Reader in = new Reader();\n        PrintWriter out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );\n\n        //BufferedReader br = new BufferedReader( new FileReader(\"in.txt\") );\n        //BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );\n\n        int n = in.nextInt();\n\n        double[][] a = new double[n][n];\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                a[i][j] = in.nextDouble();\n\n        double[] dp = new double[1 << n];\n\n        dp[(1 << n) - 1] = 1;\n\n        for (int mask = (1 << n) -1; mask >= 0; mask--) {\n\n            int k = Integer.bitCount(mask);\n            double p = 1.0 / (k*(k-1)/2.0);\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    if ((mask & (1 << i)) != 0 && (mask & (1 << j)) != 0)\n                        dp[(mask & ~(1 << j))] += p*dp[mask]*a[i][j];\n\n        }\n\n        for (int i = 0; i < n; i++)\n            out.print(dp[1 << i]+\" \");\n\n        out.flush();\n        out.close();\n    }\n\n    long gcd(long a, long b) {\n\n        if (b == 0)\n            return a;\n\n        return gcd(b, a%b);\n\n    }\n\n    class Item {\n\n        int a;\n        int b;\n        int c;\n\n        Item(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n    }\n\n    class Pair implements Comparable<Pair>{\n\n        int a;\n        int b;\n\n        Pair(int a, int b) {\n\n            this.a = a;\n            this.b = b;\n        }\n\n        public int compareTo(Pair p) {\n\n            if (b < p.b)\n                return 1;\n\n            if (b > p.b)\n                return -1;\n\n            return 0;\n        }\n\n        //\t\t@Override\n        //\t\tpublic boolean equals(Object o) {\n        //\t\t\tPair p = (Pair) o;\n        //\t\t\treturn a == p.a && b == p.b;\n        //\t\t}\n        //\n        //\t\t@Override\n        //\t\tpublic int hashCode() {\n        //\t\t\treturn Integer.valueOf(a).hashCode() + Integer.valueOf(b).hashCode();\n        //\t\t}\n\n    }\n\n    class Reader {\n\n        BufferedReader  br;\n        StringTokenizer tok;\n\n        Reader(String file) throws IOException {\n            br = new BufferedReader( new FileReader(file) );\n        }\n\n        Reader() throws IOException {\n            br = new BufferedReader( new InputStreamReader(System.in) );\n        }\n\n        String next() throws IOException {\n\n            while (tok == null || !tok.hasMoreElements())\n                tok = new StringTokenizer(br.readLine());\n            return tok.nextToken();\n        }\n\n        int nextInt() throws NumberFormatException, IOException {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.valueOf(next());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n    }\n\n}", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.util.*;\npublic class algo93\n{\n    public static void main(String args[])\n    {\n        Scanner ex=new Scanner(System.in);\n        long x=ex.nextLong();\n        long k=ex.nextLong();\n        long mod=1000000007;\n        if(k==0)\n        System.out.println((2*x)%mod);\n        else if(x==0)\n        System.out.println(\"0\");\n        else\n        {\n            long pow=power(2,k);\n            long pow1=(2*pow)%mod;\n            long ans=(pow1*(x%mod))-pow+1;\n            if(ans<0)\n            ans=ans+mod;\n            ans=ans%mod;\n            System.out.println(ans);\n        }\n    }\n    public static long power(long x,long y)\n    {\n        if (y == 0)\n        return 1;\n        long mod=1000000007;\n        long pow=power(x,y/2);\n        pow=(pow*pow)%mod;\n        if(y%2==0)\n        return pow;\n        else\n        return ((x%mod)*pow)%mod;\n    }\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.Scanner;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n\tpublic void solve(int testNumber, Scanner in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint[] fs = IOUtils.readIntArray(in, n);\n\t\tArrays.sort(fs);\n\t\tint ptr = fs.length - 1;\n\t\tint res = 0;\n\t\twhile (ptr >= 0 && k < m) {\n\t\t\tk += fs[ptr--] - 1;\n\t\t\tres++;\n\t\t}\n\t\tif (k < m) out.println(-1);\n\t\telse out.println(res);\n\t}\n}\n\nclass IOUtils {\n    public static int[] readIntArray(Scanner in, int size) {\n        int[] array = new int[size];\n        for (int i = 0; i < size; i++)\n            array[i] = in.nextInt();\n        return array;\n    }\n\n    }\n\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.*;\nimport java.awt.image.BandedSampleModel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Array;\nimport java.util.Scanner;\npublic class D{\n\n    static void sort(int[] A){\n\n        int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i){\n            int tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n        Arrays.sort(A);\n    }\n\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        //int cases = sc.nextInt();\n\n        //for(int i=0;i<cases;i++)\n        {\n            int n = sc.nextInt();\n            int m=sc.nextInt();\n            int steps=sc.nextInt();\n            long arr[][][] = new long[n][m][5];\n            for(int j=0;j<n;j++)\n            {\n                for(int k=0;k<m-1;k++)\n                {\n                    long num=sc.nextLong();\n                    arr[j][k][1]=num;\n                    arr[j][k+1][3]=num;\n                }\n            }\n\n            for(int j=0;j<n-1;j++)\n            {\n                for(int k=0;k<m;k++)\n                {\n                    long num=sc.nextLong();\n                    arr[j][k][2]=num;\n                    arr[j+1][k][4]=num;\n                }\n            }\n\n            long temp[][]=new long[n][m];\n            long ans[][]=new long[n][m];\n            for(int i=0;i<steps/2;i++)\n            {\n                for(int j=0;j<n;j++)\n                {\n                    for(int k=0;k<m;k++)\n                    {\n                        long min=Long.MAX_VALUE;\n                        if(k>0)\n                        {\n                            long f=arr[j][k][3]+ans[j][k-1];\n                            min=Math.min(min,f);\n                        }\n\n                        if(k<m-1)\n                        {\n                            long f=arr[j][k][1]+ans[j][k+1];\n                            min=Math.min(min,f);\n                        }\n\n                        if(j>0)\n                        {\n                            long f=arr[j][k][4]+ans[j-1][k];\n                            min=Math.min(min,f);\n                        }\n\n                        if(j<n-1)\n                        {\n                            long f=arr[j][k][2]+ans[j+1][k];\n                            min=Math.min(min,f);\n                        }\n\n                        temp[j][k]=min;\n                    }\n                }\n\n                for(int j=0;j<n;j++)\n                {\n                    for(int k=0;k<m;k++)\n                    {\n                        ans[j][k]=temp[j][k];\n                    }\n                }\n            }\n\n\n            StringBuilder p=new StringBuilder();\n            for(int j=0;j<n;j++)\n            {\n                for(int k=0;k<m;k++)\n                {\n                    if(steps%2!=0)\n                    {\n                        p.append(-1+\" \");\n                    }\n                    else\n                    {\n                    p.append(2*ans[j][k]+\" \");}\n                }\n\n                p.append(\"\\n\");\n            }\n\n\n            System.out.println(p);\n        }\n\n    }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class G{\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.flush();out.close();\n    }\n        static class TaskE {\n        class MinCostMaxFlow{\n                ArrayList<Edge> al[];\n                Edge ja[][]; \n                int d[]; // shortest distances\n                int N , S , T , maxFlow ; int minCost;\n                final int gmax = Integer.MAX_VALUE / 100;\n                \n                int edges = 0;\n\n                class Edge{\n                    int u , flow, rid, cost;\n                    Edge(int a, int b, int c, int d){u = a; flow = b; cost = c; rid = d;}\n                }\n                \n                void addEdge(int u , int v , int flow , int cost){\n                    int lu = al[u].size(), lv = al[v].size();\n                    al[u].add(new Edge(v, flow, cost, lv)); \n                    al[v].add(new Edge(u, 0, -cost, lu));   \n                }\n                \n                void convertToArray(){\n                    ja = new Edge[N][];\n                    for(int i = 0; i < N; i++){\n                        int sz = al[i].size();\n                        ja[i] = new Edge[sz];\n                        for(int j = 0; j < sz; j++){\n                            ja[i][j] = al[i].get(j);\n                        }\n                        al[i].clear();\n                    }\n                }\n                \n                MinCostMaxFlow(int n , int source , int sink){\n                    N = n; S = source; T = sink; maxFlow = 0; minCost = 0;\n                    al = new ArrayList[N];\n                    d = new int[N];\n                    for(int i = 0; i < N; i++){\n                        al[i] = new ArrayList<>();\n                    }\n                }\n                \n                boolean BellmanFord(boolean check){\n                    d[0] = 0;\n                    for(int i = 0; i < N - 1; i++){\n                        for(int j = 0; j < N; j++){\n                            for(Edge e : ja[j]){\n                                if(e.flow == 0)continue; // not to consider reverse edges\n                                d[e.u] = Math.min(d[e.u] , d[j] + e.cost);\n                            }\n                        }\n                    }\n                    if(check){// check for negative cycles\n                        for(int j = 0; j < N; j++){\n                            for(Edge e : ja[j]){\n                                if(e.flow == 0)continue;\n                                if(d[j] + e.cost < d[e.u]) return false;\n                            }\n                        }   \n                    }return true;\n                }\n\n                int node[]; // present node \n\n                int visit[]; // 0 -> not added 1 -> not removed 2 -> removed\n                int prv[], prve[]; // previous node for augmentation\n                int dist[]; // min dist\n\n                boolean simple(){\n                    node = new int[N]; \n                    visit = new int[N]; \n                    prv = new int[N];\n                    prve = new int[N];\n                    dist = new int[N];   Arrays.fill(dist , gmax);\n\n                    node[0] = S; dist[0] = 0;\n                    int front = 1, back = 0;\n                    while(front != back){\n                        int u = node[back++]; int distu = dist[u];\n                        if(back == N)back = 0;\n                        visit[u] = 2;\n                        for(int i = 0; i < ja[u].length; i++){\n                            Edge e = ja[u][i];\n                            if(e.flow == 0)continue;\n                            int cdist = distu + e.cost; // no need of reduced cost\n                            if(cdist < dist[e.u]){\n                                if(visit[e.u] == 0){\n                                    node[front] = e.u; \n                                    if(++front == N)front = 0;\n                                }else if(visit[e.u] == 2){\n                                    if(--back == -1)back += N;\n                                    node[back] = e.u;\n                                }\n                                visit[e.u] = 1;\n                                prve[e.u] = i; prv[e.u] = u; dist[e.u] = cdist;\n                            }\n                        }\n                    }\n                    return visit[T] != 0;\n                }\n\n                class pair{\n                    int F; int S;\n                    pair(int a, int b){F = a; S = b;}\n                }\n\n                boolean dijkstra(){\n                    visit = new int[N];\n                    prv = new int[N];\n                    prve = new int[N];\n                    dist = new int[N]; Arrays.fill(dist, gmax);\n                    PriorityQueue<pair> pq = new PriorityQueue<>((A, B) -> Double.compare(A.S , B.S));\n\n                    pq.add(new pair(S , 0)); dist[0] = 0;\n                    o : while(!pq.isEmpty()){\n                        pair p = pq.poll();\n                        while(dist[p.F] < p.S){\n                            if(pq.isEmpty()) break o; // had a better val \n                            p = pq.poll();\n                        }\n                        visit[p.F] = 2;\n                        for(int i = 0; i < ja[p.F].length; i++){\n                            Edge e = ja[p.F][i];\n                            if(e.flow == 0)continue; // important\n                            int cdist = p.S + (e.cost + d[p.F] - d[e.u]); // reduced cost\n                            if(cdist < dist[e.u]){ \n                                if(visit[e.u] == 2) return false;\n                                pq.add(new pair(e.u , cdist));\n                                dist[e.u] = cdist; prv[e.u] = p.F; prve[e.u] = i;\n                                visit[e.u] = 1;\n                            }\n                        }\n                    }\n                    return visit[T] != 0;\n                }\n                \n                int augment(){\n                    int p = T; int min = gmax;\n                    while(p != 0){\n                        int pp = prv[p], pe = prve[p];\n                        int val = ja[pp][pe].flow;\n                        min = Math.min(min , val);\n                        p = pp;\n                    }\n                    p = T;\n                    while(p != 0){\n                        int pp = prv[p], pe = prve[p];\n                        ja[pp][pe].flow -= min;\n                        ja[p][ja[pp][pe].rid].flow += min;\n                        p = pp;\n                    }\n                    maxFlow += min;\n                    return min;\n                }\n\n                // if(dist[T] >= 0)return true; // non contributing flow\n                boolean calSimple(){\n                    // uncomment to check for negative cycles\n                    /* boolean possible = BellmanFord(true); \n                     if(!possible) return false; */\n                    while(simple()){\n                        /*if(dist[T] >= 0)return true;*/ \n                        minCost += dist[T] * augment();\n                    }\n                    return true;\n                }\n\n                void updPotential(){\n                    for(int i = 0; i < N; i++){\n                        if(visit[i] != 0){\n                            d[i] += dist[i] - dist[S];\n                        }\n                    }\n                }\n                boolean calWithPotential(){\n                    // set true to check for negative cycles\n                    // boolean possible = BellmanFord(false); \n                    // if(!possible) return false;\n                    while(dijkstra()){\n                        int min = dist[T] + d[T] - d[S]; // getting back the original cost\n                        /*if(dist[T] >= 0)return true;*/\n                        minCost += min * augment();\n                        updPotential();\n                    }\n                    return true;   \n                }\n            }\n            int n , m, k, c, d, a[], f[];\n           public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt(); m = in.nextInt(); k = in.nextInt(); c = in.nextInt(); d= in.nextInt();\n            // S + n\n            int maxl = n + k, T = n * maxl + 1;\n            MinCostMaxFlow ans = new MinCostMaxFlow(T + 1, 0, T);\n            a = new int[k + 1]; f = new int[n + 1];\n            for(int i = 1; i <= k; i++){\n                a[i] = in.nextInt();\n                f[a[i]]++;\n            }\n            for(int i = 1; i <= n; i++){\n                if(f[i] == 0)continue;\n                ans.addEdge(0 , i , f[i], 0);\n            }\n            for(int i = 2; i <= n; i++){\n                for(int l = 0; l < maxl - 1; l++){\n                    ans.addEdge(l * n + i , (l + 1) * n + i, k, c);\n                }\n            }\n            for(int i = 1; i <= m; i++){\n                int a = in.nextInt(), b = in.nextInt();\n                for(int l = 0; l < maxl - 1; l++){\n                    for(int p = 1; p <= k; p++){\n                        if(a != 1)\n                            ans.addEdge(n * l + a, n * (l + 1) + b, 1, d * (2 * p - 1) + c);\n                        if(b != 1)\n                            ans.addEdge(n * l + b, n * (l + 1) + a, 1, d * (2 * p - 1) + c);\n                    }\n                } \n            }\n            for(int l = 1; l < maxl; l++){\n                ans.addEdge(l * n + 1, T, k, 0);\n            }\n            ans.convertToArray();\n            ans.calWithPotential();\n            // ans.calSimple();\n            if(ans.maxFlow != k){\n                out.println(\"BUG\");\n            }else{\n                out.println((int)ans.minCost);\n            }\n          }\n    }\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream));\n            st = null;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}", "complexity": "cubic", "problem": "1187_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class SimpleTask {\n\n    public static void main(String[] args) throws Exception {\n        InputReader in = new InputReader(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] g = new int[n];\n        long[][] dp = new long[1 << n][n];\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt() - 1, b = in.nextInt() - 1;\n            g[a] |= (1 << b);\n            g[b] |= (1 << a);\n        }\n        int all = (1 << n) - 1;\n        for (int i = 0; i < n; i++) {\n            int l = (1 << i);\n            int left = all ^ (l - 1) ^ l;\n            for (int j = left; j > 0; j = (j - 1) & left)\n                if ((j & (j - 1)) != 0) {\n                    dp[j | l][i] = 1;\n                }\n        }\n        for (int i = (1 << n) - 1; i > 0; i--) {\n            int last = i & -i;\n            for (int j = 0; j < n; j++) {\n                if (((1 << j) == last && (i & (i - 1)) != 0)\n                        || ((1 << j) & i) == 0)\n                    continue;\n                for (int k = 0; k < n; k++) {\n                    if ((1 << k) >= last && ((1 << k) & g[j]) != 0\n                            && ((1 << k) == last || ((1 << k) & i) == 0)) {\n                        dp[i][j] += dp[i | (1 << k)][k];\n                    }\n\n                }\n            }\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++)\n            res += dp[(1 << i)][i];\n        System.out.println(res / 2);\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * Author -\n * User: kansal\n * Date: 9/3/11\n * Time: 5:28 PM\n */\npublic class CF85C {\n    public static void main(String[] args) {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n\n        int height = nextInt(), width = nextInt();\n        if (width > height) {\n            int t = width;\n            width = height;\n            height = t;\n        }\n\n        final int INF = height * width + 10;\n        final int ALL_BITS = (1 << width)  - 1;\n        int[][][] dp = new int[height + 1][1 << width][1 << width];\n        for (int[][] ints : dp) {\n            for (int[] anInt : ints) {\n                Arrays.fill(anInt, INF);\n            }\n        }\n\n        dp[0][0][0] = 0;\n        for(int r = 0; r < height; ++r) {\n            for(int uncovered = 0; uncovered < (1 << width); ++uncovered) {\n                for(int mask = 0; mask < (1 << width); ++mask) {\n                    if (dp[r][uncovered][mask] == INF) {\n                        continue;\n                    }\n                    for(int curMask = uncovered; curMask < (1 << width); curMask = (curMask + 1) | uncovered) {\n                        int curCovered = (mask | curMask);\n                        curCovered |= (curMask >> 1);\n                        curCovered |= (ALL_BITS & (curMask << 1));\n\n                        int curUncovered = ALL_BITS ^ curCovered;\n                        dp[r+1][curUncovered][curMask] = Math.min(dp[r+1][curUncovered][curMask], dp[r][uncovered][mask] + Integer.bitCount(curMask));\n                    }\n                }\n            }\n        }\n\n        int res = INF;\n        for(int x: dp[height][0]) res = Math.min(res, x);\n\n        System.out.println(height * width - res);\n    }\n\n    private static boolean hasBit(int mask, int bit) {\n        return (((mask >> bit) & 1) == 1);\n    }\n\n    public static BufferedReader reader;\n\n    public static StringTokenizer tokenizer = null;\n\n    static String nextToken() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    static public int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    static public long nextLong() {\n        return Long.parseLong(nextToken());\n    }\n\n    static public String next() {\n        return nextToken();\n    }\n\n    static public String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}\n", "complexity": "np", "problem": "0112_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.util.Scanner;\n\npublic class Hello {\n\t\tpublic static void main(String[] args){\t\t\t\n\t\t\tScanner scan = new Scanner(System.in);\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tboolean[][] graph = new boolean[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tint from = scan.nextInt() - 1;\n\t\t\t\tint to = scan.nextInt() - 1;\n\t\t\t\tgraph[from][to] = graph[to][from] = true;\n\t\t\t}\n\t\t\t\n\t\t\tint max = 1 << n;\n\t\t\tlong[][] dp = new long[max][n];\n\t\t\t\n\t\t\tfor(int mask = 1; mask < max; mask++) {\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tboolean existI = (mask & (1 << i)) > 0;\n\t\t\t\t\tif(Integer.bitCount(mask) == 1 && existI) {\n\t\t\t\t\t\tdp[mask][i] = 1;\n\t\t\t\t\t} else if(Integer.bitCount(mask) > 1 && existI && first(mask) != i) {\n\t\t\t\t\t\tlong sum = 0; \n\t\t\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tif(graph[i][j]) sum += dp[mask ^ (1 << i)][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[mask][i] = sum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong countCycles = 0;\n\t\t\tfor(int mask = 7; mask < max; mask++) {\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tif(Integer.bitCount(mask) >= 3 && graph[first(mask)][i]) {\n\t\t\t\t\t\tcountCycles += dp[mask][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(countCycles / 2);\n\t\t}\n\t\t\n\t\t\n\t\tpublic static int first(int mask) {\n\t\t\tint i = 0;\n\t\t\twhile((mask & (1 << i++)) == 0);\n\t\t\treturn i - 1; \n\t\t}\n}", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.*;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class _276D {\n\n\n\n    public static void main(String[] args) throws Exception {\n\n        Reader.init(System.in);\n\n        BufferedWriter cout = new BufferedWriter(new OutputStreamWriter(System.out));\n\n\n\n        long l = Long.parseLong(Reader.next());\n\n        long r = Long.parseLong(Reader.next());\n\n        long ans = 0;\n\n        for (int i = 62; i >= 0; i--) {\n\n            if (((1L << i) & l) != ((1L << i) & r)) {\n\n                for (int j = i; j >= 0; j--) ans = ans | (1L << j);\n\n                break;\n\n            }\n\n        }\n\n        System.out.println(ans);\n\n\n\n        cout.close();\n\n    }\n\n\n\n    static class Pair<U extends Comparable<U>, V extends Comparable<V>> implements Comparable<Pair<U, V>> {\n\n        final U _1;\n\n        final V _2;\n\n\n\n        private Pair(U key, V val) {\n\n            this._1 = key;\n\n            this._2 = val;\n\n        }\n\n\n\n        public static <U extends Comparable<U>, V extends Comparable<V>> Pair<U, V> instanceOf(U _1, V _2) {\n\n            return new Pair<U, V>(_1, _2);\n\n        }\n\n\n\n        @Override\n\n        public String toString() {\n\n            return _1 + \" \" + _2;\n\n        }\n\n\n\n        @Override\n\n        public int hashCode() {\n\n            int res = 17;\n\n            res = res * 31 + _1.hashCode();\n\n            res = res * 31 + _2.hashCode();\n\n            return res;\n\n        }\n\n\n\n        @Override\n\n        public int compareTo(Pair<U, V> that) {\n\n            int res = this._1.compareTo(that._1);\n\n            if (res < 0 || res > 0) return res;\n\n            else return this._2.compareTo(that._2);\n\n        }\n\n\n\n        @Override\n\n        public boolean equals(Object obj) {\n\n            if (this == obj) return true;\n\n            if (!(obj instanceof Pair)) return false;\n\n            Pair<?, ?> that = (Pair<?, ?>) obj;\n\n            return _1.equals(that._1) && _2.equals(that._2);\n\n        }\n\n    }\n\n\n\n    /**\n\n     * Class for buffered reading int and double values\n\n     */\n\n    static class Reader {\n\n        static BufferedReader reader;\n\n        static StringTokenizer tokenizer;\n\n\n\n        /**\n\n         * call this method to initialize reader for InputStream\n\n         */\n\n        static void init(InputStream input) {\n\n            reader = new BufferedReader(new InputStreamReader(input));\n\n            tokenizer = new StringTokenizer(\"\");\n\n        }\n\n\n\n        /**\n\n         * get next word\n\n         */\n\n        static String next() throws IOException {\n\n            while (!tokenizer.hasMoreTokens()) {\n\n                // TODO add check for eof if necessary\n\n                tokenizer = new StringTokenizer(reader.readLine());\n\n            }\n\n            return tokenizer.nextToken();\n\n        }\n\n\n\n        static int nextInt() throws IOException {\n\n            return Integer.parseInt(next());\n\n        }\n\n\n\n        static double nextDouble() throws IOException {\n\n            return Double.parseDouble(next());\n\n        }\n\n    }\n\n\n\n    static class ArrayUtil {\n\n        static void swap(int[] a, int i, int j) {\n\n            int tmp = a[i];\n\n            a[i] = a[j];\n\n            a[j] = tmp;\n\n        }\n\n\n\n        static void swap(long[] a, int i, int j) {\n\n            long tmp = a[i];\n\n            a[i] = a[j];\n\n            a[j] = tmp;\n\n        }\n\n\n\n        static void swap(double[] a, int i, int j) {\n\n            double tmp = a[i];\n\n            a[i] = a[j];\n\n            a[j] = tmp;\n\n        }\n\n\n\n        static void swap(char[] a, int i, int j) {\n\n            char tmp = a[i];\n\n            a[i] = a[j];\n\n            a[j] = tmp;\n\n        }\n\n\n\n        static void swap(boolean[] a, int i, int j) {\n\n            boolean tmp = a[i];\n\n            a[i] = a[j];\n\n            a[j] = tmp;\n\n        }\n\n\n\n        static void reverse(int[] a, int i, int j) {\n\n            for (; i < j; i++, j--)\n\n                swap(a, i, j);\n\n        }\n\n\n\n        static void reverse(long[] a, int i, int j) {\n\n            for (; i < j; i++, j--)\n\n                swap(a, i, j);\n\n        }\n\n\n\n        static void reverse(double[] a, int i, int j) {\n\n            for (; i < j; i++, j--)\n\n                swap(a, i, j);\n\n        }\n\n\n\n        static void reverse(char[] a, int i, int j) {\n\n            for (; i < j; i++, j--)\n\n                swap(a, i, j);\n\n        }\n\n\n\n        static void reverse(boolean[] a, int i, int j) {\n\n            for (; i < j; i++, j--)\n\n                swap(a, i, j);\n\n        }\n\n\n\n        static long sum(int[] a) {\n\n            int sum = 0;\n\n            for (int i : a)\n\n                sum += i;\n\n            return sum;\n\n        }\n\n\n\n        static long sum(long[] a) {\n\n            long sum = 0;\n\n            for (long i : a)\n\n                sum += i;\n\n            return sum;\n\n        }\n\n\n\n        static double sum(double[] a) {\n\n            double sum = 0;\n\n            for (double i : a)\n\n                sum += i;\n\n            return sum;\n\n        }\n\n\n\n        static int max(int[] a) {\n\n            int max = Integer.MIN_VALUE;\n\n            for (int i : a)\n\n                if (i > max) max = i;\n\n            return max;\n\n        }\n\n\n\n        static int min(int[] a) {\n\n            int min = Integer.MAX_VALUE;\n\n            for (int i : a)\n\n                if (i < min) min = i;\n\n            return min;\n\n        }\n\n\n\n        static long max(long[] a) {\n\n            long max = Long.MIN_VALUE;\n\n            for (long i : a)\n\n                if (i > max) max = i;\n\n            return max;\n\n        }\n\n\n\n        static long min(long[] a) {\n\n            long min = Long.MAX_VALUE;\n\n            for (long i : a)\n\n                if (i < min) min = i;\n\n            return min;\n\n        }\n\n    }\n\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1187G extends PrintWriter {\n\tCF1187G() { super(System.out); }\n\tstatic class Scanner {\n\t\tScanner(InputStream in) { this.in = in; } InputStream in;\n\t\tint k, l; byte[] bb = new byte[1 << 15];\n\t\tbyte getc() {\n\t\t\tif (k >= l) {\n\t\t\t\tk = 0;\n\t\t\t\ttry { l = in.read(bb); } catch (IOException e) { l = 0; }\n\t\t\t\tif (l <= 0) return -1;\n\t\t\t}\n\t\t\treturn bb[k++];\n\t\t}\n\t\tint nextInt() {\n\t\t\tbyte c = 0; while (c <= 32) c = getc();\n\t\t\tint a = 0;\n\t\t\twhile (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n\t\t\treturn a;\n\t\t}\n\t}\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1187G o = new CF1187G(); o.main(); o.flush();\n\t}\n\n\tstatic final int INF = 0x3f3f3f3f;\n\tArrayList[] aa_;\n\tint n_, m_;\n\tint[] pi, kk, bb;\n\tint[] uu, vv, uv, cost, cost_;\n\tint[] cc;\n\tvoid init() {\n\t\taa_ = new ArrayList[n_];\n\t\tfor (int u = 0; u < n_; u++)\n\t\t\taa_[u] = new ArrayList<Integer>();\n\t\tpi = new int[n_];\n\t\tkk = new int[n_];\n\t\tbb = new int[n_];\n\t\tuu = new int[m_];\n\t\tvv = new int[m_];\n\t\tuv = new int[m_];\n\t\tcost = new int[m_];\n\t\tcost_ = new int[m_];\n\t\tcc = new int[m_ * 2];\n\t\tm_ = 0;\n\t}\n\tvoid link(int u, int v, int cap, int cos) {\n\t\tint h = m_++;\n\t\tuu[h] = u;\n\t\tvv[h] = v;\n\t\tuv[h] = u ^ v;\n\t\tcost[h] = cos;\n\t\tcc[h << 1 ^ 0] = cap;\n\t\taa_[u].add(h << 1 ^ 0);\n\t\taa_[v].add(h << 1 ^ 1);\n\t}\n\tvoid dijkstra(int s) {\n\t\tArrays.fill(pi, INF);\n\t\tpi[s] = 0;\n\t\tTreeSet<Integer> pq = new TreeSet<>((u, v) -> pi[u] != pi[v] ? pi[u] - pi[v] : kk[u] != kk[v] ? kk[u] - kk[v] : u - v);\n\t\tpq.add(s);\n\t\tInteger first;\n\t\twhile ((first = pq.pollFirst()) != null) {\n\t\t\tint u = first;\n\t\t\tint k = kk[u] + 1;\n\t\t\tArrayList<Integer> adj = aa_[u];\n\t\t\tfor (int h_ : adj)\n\t\t\t\tif (cc[h_] > 0) {\n\t\t\t\t\tint h = h_ >> 1;\n\t\t\t\t\tint p = pi[u] + ((h_ & 1) == 0 ? cost_[h] : -cost_[h]);\n\t\t\t\t\tint v = u ^ uv[h];\n\t\t\t\t\tif (pi[v] > p || pi[v] == p && kk[v] > k) {\n\t\t\t\t\t\tif (pi[v] < INF)\n\t\t\t\t\t\t\tpq.remove(v);\n\t\t\t\t\t\tpi[v] = p;\n\t\t\t\t\t\tkk[v] = k;\n\t\t\t\t\t\tbb[v] = h_;\n\t\t\t\t\t\tpq.add(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\tvoid push(int s, int t) {\n\t\tint c = INF;\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tc = Math.min(c, cc[h_]);\n\t\t}\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_] -= c; cc[h_ ^ 1] += c;\n\t\t}\n\t}\n\tvoid push1(int s, int t) {\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_]--; cc[h_ ^ 1]++;\n\t\t}\n\t}\n\tint edmonds_karp(int s, int t) {\n\t\tSystem.arraycopy(cost, 0, cost_, 0, m_);\n\t\twhile (true) {\n\t\t\tdijkstra(s);\n\t\t\tif (pi[t] == INF)\n\t\t\t\tbreak;\n\t\t\tpush1(s, t);\n\t\t\tfor (int h = 0; h < m_; h++) {\n\t\t\t\tint u = uu[h], v = vv[h];\n\t\t\t\tif (pi[u] != INF && pi[v] != INF)\n\t\t\t\t\tcost_[h] += pi[u] - pi[v];\n\t\t\t}\n\t\t}\n\t\tint c = 0;\n\t\tfor (int h = 0; h < m_; h++)\n\t\t\tc += cost[h] * cc[h << 1 ^ 1];\n\t\treturn c;\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tint[] ii = new int[k];\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tii[h] = sc.nextInt() - 1;\n\t\tArrayList[] aa = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = new ArrayList<Integer>();\n\t\tfor (int h = 0; h < m; h++) {\n\t\t\tint i = sc.nextInt() - 1;\n\t\t\tint j = sc.nextInt() - 1;\n\t\t\taa[i].add(j);\n\t\t\taa[j].add(i);\n\t\t}\n\t\tint t = n + k + 1;\n\t\tn_ = n * t + 1;\n\t\tm_ = k + (m * 2 * k + n) * (t - 1);\n\t\tinit();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrayList<Integer> adj = aa[i];\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s;\n\t\t\t\tfor (int j : adj) {\n\t\t\t\t\tint v = j * t + s + 1;\n\t\t\t\t\tfor (int x = 1; x <= k; x++)\n\t\t\t\t\t\tlink(u, v, 1, c + (x * 2 - 1) * d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s, v = u + 1;\n\t\t\t\tlink(u, v, k, i == 0 ? 0 : c);\n\t\t\t}\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tlink(n_ - 1, ii[h] * t + 0, 1, 0);\n\t\tprintln(edmonds_karp(n_ - 1, 0 * t + t - 1));\n\t}\n}\n", "complexity": "cubic", "problem": "1187_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class E implements Runnable {\n\tpublic static void main (String[] args) {new Thread(null, new E(), \"_cf\", 1 << 28).start();}\n\n\tint n, m;\n\tchar[] str;\n\tint[][] occs, cost;\n\tint[] dp;\n\t\n\tpublic void run() {\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tSystem.err.println(\"\");\n\n\t\tn = fs.nextInt(); m = fs.nextInt();\n\t\tstr = fs.next().toCharArray();\n\t\toccs = new int[m][m];\n\t\tfor(int i = 0; i < n-1; i++) {\n\t\t\toccs[str[i]-'a'][str[i+1]-'a']++;\n\t\t\toccs[str[i+1]-'a'][str[i]-'a']++;\n\t\t}\n\t\t//cost[mask][v] = numPairs with v for some all bits on in mask\n\t\tint all = (1<<m)-1;\n\t\tcost = new int[m][1<<m];\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tfor(int mask = 1; mask < all; mask++) {\n\t\t\t\tif(((1<<i)&mask) > 0) continue;\n\t\t\t\tint lb = mask & (-mask);\n\t\t\t\tint trail = Integer.numberOfTrailingZeros(lb);\n\t\t\t\tint nmask = mask ^ lb;\n\t\t\t\tcost[i][mask] = cost[i][nmask]+occs[i][trail];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp = new int[1<<m];\n\t\tfor(int mask = dp.length-2; mask >= 0; mask--) {\n\t\t\tint addOn = 0;\n\t\t\tfor(int nxt = 0; nxt < m; nxt++) {\n\t\t\t\tif(((1<<nxt)&mask) > 0) continue;\n\t\t\t\taddOn += cost[nxt][mask];\n\t\t\t}\n\t\t\tint res = oo;\n\t\t\tfor(int nxt = 0; nxt < m; nxt++) {\n\t\t\t\tif(((1<<nxt)&mask) > 0) continue;\n\t\t\t\tint ret = addOn+dp[mask | (1<<nxt)];\n\t\t\t\tres = min(res, ret);\n\t\t\t}\n\t\t\tdp[mask] = res;\n\t\t}\n\t\t\n\t\tSystem.out.println(dp[0]);\n\t\t\n\t\tout.close();\n\t}\n\t\n\tint oo = (int)1e9;\n\tint min(int a, int b) {\n\t\tif(a < b) return a;\n\t\treturn b;\n\t}\n\t\n\tclass FastScanner {\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\n\t\tpublic FastScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t\t}\n\t\t}\n\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}                \n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) res[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t}\n\n}", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class B{\n\n\tstatic int a[];\n\tstatic long []sum;\n\t\n\tstatic long max;\n\tstatic ArrayList<Integer> []adj;\n\tstatic int dfs(int u,int p,int t)\n\t{\n\t\tint ans=0;\n\t\t\n\t\tsum[u]=a[u];\n\t\tfor(int v:adj[u])\n\t\t\tif(v!=p)\n\t\t\t{\n\t\t\t\tans+=dfs(v,u,t);\n\t\t\t\tif(sum[v]>0)\n\t\t\t\t\tsum[u]+=sum[v] ;\n\t\t\t}\n\t\tif(t==0)\n\t\t\tmax=Math.max(max, sum[u]);\n\t\telse if(sum[u]==max) {\n\t\t\tsum[u]=0;\n\t\t\t\n\t\t\tans++;\n\t\t}\n\t\treturn ans;\n\t\t\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc=new Scanner();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tint n=sc.nextInt();\n\t\t\n\t\tadj=new ArrayList[n];\n\t\tsum=new long[n];\n\t\ta=new int [n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i]=sc.nextInt();\n\t\t\t\n\t\t\tadj[i]=new ArrayList();\n\t\t}\n\t\tmax=-(int)1e9;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint u=sc.nextInt()-1,v=sc.nextInt()-1;\n\t\t\tadj[u].add(v);\n\t\t\tadj[v].add(u);\n\t\t}\n\t\t\n\t\tdfs(0,0,0);\n\t\t\n\t\tlong cnt=dfs(0,0,1);\n\t\tout.println(cnt*max+\" \"+cnt);\n\t\tout.close();\n\n\t}\n\tstatic class Scanner\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tScanner(){\n\t\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tScanner(String fileName) throws FileNotFoundException{\n\t\t\tbr=new BufferedReader(new FileReader(fileName));\n\t\t}\n\t\tString next() throws IOException {\n\t\t\twhile(st==null || !st.hasMoreTokens())\n\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t\tint nextInt() throws IOException{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong()  throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n", "complexity": "linear", "problem": "1088_E", "from": "CODEFORCES", "tags": "dp,greedy,math,trees"}
{"src": "\nimport java.util.*;\nimport java.io.*;\n\npublic class two {\n\n\tpublic static void main(String[] args) throws IOException, FileNotFoundException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t//BufferedReader in = new BufferedReader(new FileReader(\"two\"));\n\n\t\tHashSet<Integer> good = new HashSet<>();\n\t\tint i=1;\n\t\tfor (; i<= (int)(1e9);) {\n\t\t\ti <<= 1;\n\t\t\tgood.add(i);\n\t\t}\n\t\t\n\t\tfor (i=3; i*i*2 <= (int)(1e9); i++) {\n\t\t\tgood.add(i*i*2);\n\t\t}\n\t\t\n\t\tint beg = 4;\n\t\tfor (i=3; beg + i*4 <= (int)(1e9); i+=2) {\n\t\t\tgood.add(beg + i*4);\n\t\t\tbeg += i*4;\n\t\t}\n\t\t\n\t\tint t = Integer.parseInt(in.readLine());\n\t\twhile (t-- > 0) {\n\t\t\tint n = Integer.parseInt(in.readLine());\n\t\t\tif (good.contains(n)) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n}\n", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.File;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n \npublic class C {\n\tScanner in;\n\tPrintWriter out;\n//\tString INPUT = \"3 3 1 1 1\";\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint m = ni();\n\t\tint k = ni();\n\t    int[][] f=new int[k][2];\n        \t\t\n        \t\tfor(int i=0;i<k;i++) {\n        \t\t\tf[i][0]=ni()-1;\n        \t\t\tf[i][1]=ni()-1;\n        \t\t}\n        \t\tint mx=-1;\n        \t\tint resx=0;\n        \t\tint resy=0;        \t\t\n        \t\t\n        \t\tfor(int i=0;i<n;i++) {\n        \t\t\tfor(int j=0;j<m;j++) {\n        \t\t\t\tint min=Integer.MAX_VALUE;\n        \t\t\t\tfor(int l=0;l<k;l++) {\n        \t\t\t\t\tmin=Math.min(min, Math.abs(f[l][0]-i)+Math.abs(f[l][1]-j));\n        \t\t\t\t}\n        \t\t\t\tif(min>mx) {\n        \t\t\t\t\tmx=min;\n        \t\t\t\t\tresx=i;\n        \t\t\t\t\tresy=j;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\t\n        \t\t}\n        \t\tout.println((resx+1)+\" \"+(resy+1));\n        \t\t\n\t}\n\n\tvoid run() throws Exception\n\t{\n\t\tin = INPUT.isEmpty() ? new Scanner(new File(\"input.txt\")) : new Scanner(INPUT);\n\t\tout = INPUT.isEmpty() ? new PrintWriter(\"output.txt\") : new PrintWriter(System.out);\n \n\t\tsolve();\n\t\tout.flush();\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew C().run();\n\t}\n\t\n\tint ni() { return Integer.parseInt(in.next()); }\n\tvoid tr(Object... o) { if(INPUT.length() != 0)System.out.println(o.length > 1 || o[0].getClass().isArray() ? Arrays.deepToString(o) : o[0]); }\n\tstatic String join(int[] a, int d){StringBuilder sb = new StringBuilder();for(int v : a){sb.append(v + d + \" \");}return sb.toString();}\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class CF_35C {\n    public static void main(String[] args) throws IOException{\n        BufferedReader f = new BufferedReader(new FileReader(\"input.txt\"));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n\n        StringTokenizer st1 = new StringTokenizer(f.readLine());\n        int n = Integer.parseInt(st1.nextToken());\n        int m = Integer.parseInt(st1.nextToken());\n\n        boolean[][] visited = new boolean[n][m];\n\n        int k = Integer.parseInt(f.readLine());\n        LinkedList<state1> ll = new LinkedList<state1>();\n        StringTokenizer st = new StringTokenizer(f.readLine());\n        for(int i = 0; i < k; i++) {\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken());\n\n            ll.add(new state1(x - 1, y - 1));\n            visited[x - 1][y - 1] = true;\n        }\n\n        int lastx = 1;\n        int lasty = 1;\n        while(!ll.isEmpty()) {\n            state1 focus = ll.remove();\n            lastx = focus.x+1;\n            lasty = focus.y+1;\n\n            //System.out.println(lastx + \" \" + lasty);\n\n            visited[focus.x][focus.y] = true;\n            if(focus.x+1 < n && !visited[focus.x+1][focus.y]) {\n                ll.add(new state1(focus.x+1, focus.y));\n                visited[focus.x+1][focus.y] = true;\n            }\n            if(focus.x-1 >= 0 && !visited[focus.x-1][focus.y]) {\n                ll.add(new state1(focus.x-1, focus.y));\n                visited[focus.x-1][focus.y] = true;\n            }\n            if(focus.y+1 < m && !visited[focus.x][focus.y+1]) {\n                ll.add(new state1(focus.x, focus.y+1));\n                visited[focus.x][focus.y+1] = true;\n            }\n            if(focus.y-1 >= 0 && !visited[focus.x][focus.y-1]) {\n                ll.add(new state1(focus.x, focus.y-1));\n                visited[focus.x][focus.y-1] = true;\n            }\n        }\n        out.println(lastx + \" \" + lasty);\n        out.close();\n    }\n}\n\nclass state1 {\n    int x, y;\n    state1(int x, int y) {\n        this.x = x; this.y = y;\n    }\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class SameSumBlock {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt();\n\t\tint[] arr = new int[n];\n\t\tint[] pSum = new int[n];\n\t\tfor(int i = 0; i< n; i++) {\n\t\t\tarr[i] = nextInt();\n\t\t\tif(i != 0)\n\t\t\t\tpSum[i] += pSum[i - 1];\n\t\t\tpSum[i] += arr[i];\n\t\t}\n\t\tArrayList<Interval> sorted = new ArrayList<Interval>();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tsorted.add(new Interval(pSum[i],0, i));\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tfor(int j = i; j < n; j++) {\n\t\t\t\tsorted.add(new Interval(pSum[j] - pSum[i - 1], i, j));\n\t\t\t}\n\t\t}\n\t\tsorted.sort(null);\n\t\tint i = 0;\n\t\tint max = 0, idx = 0, end = 0;\n\t\twhile(i < sorted.size()) {\n\t\t\tint last = i;\n\t\t\tint curr = 1;\n\t\t\tint start = i;\n\t\t\tsorted.get(i).marked = true;\n\t\t\twhile(i < sorted.size() - 1 && sorted.get(i).val == sorted.get(i + 1).val) {\n\t\t\t\ti++;\n\t\t\t\tif(sorted.get(i).l > sorted.get(last).r) {\n\t\t\t\t\tsorted.get(i).marked = true;\n\t\t\t\t\tcurr++;\n\t\t\t\t\tlast = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(curr > max) {\n\t\t\t\tmax = curr;\n\t\t\t\tidx = start;\n\t\t\t\tend = i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(max);\n\t\tfor(int j = idx; j <= end; j++) {\n\t\t\tif(sorted.get(j).marked)\n\t\t\t\tSystem.out.println(sorted.get(j).l + 1 + \" \" + (sorted.get(j).r + 1));\n\t\t}\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n}\nclass Interval implements Comparable<Interval> {\n\tint val, l, r;\n\tboolean marked;\n\tpublic Interval(int val, int l, int r) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tthis.l = l;\n\t\tthis.r = r;\n\t}\n\n\t@Override\n\tpublic int compareTo(Interval o) {\n\t\tif(val != o.val)\n\t\t\treturn val - o.val;\n\t\treturn r - o.r;\n\t}\n\t\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tstatic BigInteger tow=new BigInteger(\"2\"),mod=new BigInteger(\"1000000007\");\n\tstatic BigInteger pow(BigInteger a,BigInteger b) {\n\t\tif(b.equals(BigInteger.ZERO))return BigInteger.ONE;\n\t\tBigInteger x=pow(a,b.divide(tow));\n\t\tif(b.mod(tow).equals(BigInteger.ZERO)) \n\t\t\treturn x.mod(mod).multiply(x.mod(mod)).mod(mod);\n\t\telse \n\t\t\treturn x.mod(mod).multiply(x.mod(mod)).mod(mod).multiply(a).mod(mod);\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBigInteger x=in.RB(),k=in.RB();\n\t\tif(k.equals(BigInteger.ZERO))System.out.println(x.multiply(tow).mod(mod));\n\t\telse if(x.equals(BigInteger.ZERO))System.out.println(0);\n\t\telse {\n\t\t\tBigInteger x1=tow.multiply(x).subtract(BigInteger.ONE);\n\t\t\tx1=x1.mod(mod);\n\t\t\tBigInteger x2=pow(tow,k);\n\t\t\tx2=x2.mod(mod);\n\t\t\tSystem.out.println(x1.multiply(x2).add(BigInteger.ONE).mod(mod));\n\t\t\t\n\t\t}\n\t}\n}\n\n\nclass in{\n\tstatic StringTokenizer st=new StringTokenizer(\"\");\n\tstatic BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\tstatic String next() throws IOException {\n\t\twhile(!st.hasMoreTokens())st=new StringTokenizer(bf.readLine());\n\t\treturn st.nextToken();\n\t}\n\tstatic int RI() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tstatic BigInteger RB() throws IOException {\n\t\treturn new BigInteger(next());\n\t}\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jaynil\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BSportMafia solver = new BSportMafia();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BSportMafia {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long n = in.nextLong();\n            long k = in.nextLong();\n            long b = 2 * n + 3;\n            long c = n * n - 2 * k + n;\n            long d = b * b - 4 * c;\n            long val = (b - (long) Math.sqrt(d)) / 2;\n\n            out.println(val);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\n\n\npublic class Solution {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n=in.nextInt();\n    \n        out.print(n/2+n);\n       \n        out.close();\n        in.close();\n    }\n\n}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class CF_1517D\n{\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tMyReader reader = new MyReader();\n\t\tint N = reader.nextInt();\n\t\tint M = reader.nextInt();\n\t\tint K = reader.nextInt();\n\t\tif(K%2 == 1) {\n\t\t\tfor(int i = 0;i<N;i++) {\n\t\t\t\tfor(int j = 0;j<M;j++) {\n\t\t\t\t\tSystem.out.print(\"-1 \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tNode[][] grid = new Node[N][M];\n\t\t\tfor(int i = 0;i<N;i++) {\n\t\t\t\tfor(int j = 0;j<M;j++) {\n\t\t\t\t\tgrid[i][j] = new Node();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<N;i++) {\n\t\t\t\tfor(int j = 0;j<M-1;j++) {\n\t\t\t\t\tgrid[i][j].top = grid[i][j+1].bottom = reader.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<N-1;i++) {\n\t\t\t\tfor(int j = 0;j<M;j++) {\n\t\t\t\t\tgrid[i][j].right = grid[i+1][j].left = reader.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][][] ansArr = new int[K/2 + 1][N][M];\n\t\t\t//base case: ansArr[0] is all 0s\n\t\t\tfor(int k = 1; k<= K/2; k++) {\n\t\t\t\tfor(int i = 0;i<N;i++) {\n\t\t\t\t\tfor(int j = 0;j<M;j++) {\n\t\t\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\t\t\tif(i > 0) min = Math.min(min, ansArr[k-1][i-1][j] + 2*grid[i][j].left);\n\t\t\t\t\t\tif(i < N-1) min = Math.min(min, ansArr[k-1][i+1][j] + 2*grid[i][j].right);\n\t\t\t\t\t\tif(j > 0) min = Math.min(min, ansArr[k-1][i][j-1] + 2*grid[i][j].bottom);\n\t\t\t\t\t\tif(j < M-1) min = Math.min(min, ansArr[k-1][i][j+1] + 2*grid[i][j].top);\n\t\t\t\t\t\tansArr[k][i][j] = min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0;i<N;i++) {\n\t\t\t\tfor(int j = 0;j<M;j++) {\n\t\t\t\t\tSystem.out.print(ansArr[K/2][i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Node {\n\t\tpublic int right = 1000000000, top = 1000000000, left = 1000000000, bottom = 1000000000;\n\t}\n\t\n\t\n\tstatic class MyReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        public String next() throws IOException  {\n            while (st == null || !st.hasMoreElements()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n        public int nextInt() throws NumberFormatException, IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int k = Integer.parseInt(tokenizer.nextToken());\n        System.out.println((int)(n-(-3.0+Math.sqrt(9.0+8.0*(n+k)))/2.0));\n    }\n}", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Solution implements Runnable {\n    FastScanner sc;\n    PrintWriter pw;\n    final class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n \n        public long nlo() {\n            return Long.parseLong(next());\n        }\n \n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return st.nextToken();\n        }\n \n        public int ni() {\n            return Integer.parseInt(next());\n        }\n \n        public String nli() {\n            String line = \"\";\n            if (st.hasMoreTokens()) line = st.nextToken();\n            else try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            while (st.hasMoreTokens()) line += \" \" + st.nextToken();\n            return line;\n        }\n \n        public double nd() {\n            return Double.parseDouble(next());\n        }\n    }\n    public static void main(String[] args) throws Exception\n    {\n        new Thread(null,new Solution(),\"codeforces\",1<<28).start();\n    }\n    public void run()\n    {\n        sc=new FastScanner();\n        pw=new PrintWriter(System.out);\n        try{\n        solve();}\n        catch(Exception e)\n        {\n            pw.println(e);\n        }\n        pw.flush();\n        pw.close();\n    }\n    public long gcd(long a,long b)\n    {\n        return b==0L?a:gcd(b,a%b);\n    }\n    public long ppow(long a,long b,long mod)\n    {\n        if(b==0L)\n        return 1L;\n        long tmp=1;\n        while(b>1L)\n        {\n            if((b&1L)==1)\n            tmp*=a;\n            a*=a;\n            a%=mod;\n            tmp%=mod;\n            b>>=1;\n        }\n        return (tmp*a)%mod;\n    }\n    public  int gcd(int x,int y)\n    {\n        return y==0?x:gcd(y,x%y);\n    }\n   \n    //////////////////////////////////\n    /////////////  LOGIC  ///////////\n    ////////////////////////////////\n    \n    int[] visit,prr;\n    ArrayList<Integer>[] adj;\n    int mx=0,mv=0;\n    boolean res=true;\n    public void solve() throws Exception{\n        int n=sc.ni();\n        int k=sc.ni();\n        visit=new int[n];\n        adj=new ArrayList[n];\n        for(int i=0;i<n;i++)\n        adj[i]=new ArrayList();\n        for(int i=0;i<n-1;i++)\n        {\n            int x=sc.ni()-1;\n            int y=sc.ni()-1;\n            adj[x].add(y);\n            adj[y].add(x);\n        }\n        dm(n);\n        res=((mx%2==0)&&(mx/2)==k);\n        if(res){\n            mx/=2;\n            dist(mv,mx);\n            visit=new int[n];\n            if(adj[mv].size()<3)\n            res=false;\n            else\n            check(mv,mx);\n        }\n        if(res)\n        pw.println(\"Yes\");\n        else\n        pw.println(\"No\");\n    }\n    public void dm(int n){\n        mx=0;\n        prr=new int[n];\n        dfs(0,0,0);\n        visit=new int[n];\n        mx=0;\n        prr=new int[n];\n        dfs(mv,0,mv);\n        visit=new int[n];\n\n    }\n    public void dfs(int x,int d,int p)\n    {\n        visit[x]=1;\n        prr[x]=p;\n        if(d>mx){\n            mx=d;\n            mv=x;\n        }\n        for(int v:adj[x])\n            if(visit[v]==0)\n                dfs(v,d+1,x);\n    }\n    public void dist(int x,int d)\n    {\n       for(int i=0;i<d;i++)\n           mv=prr[mv];\n    }\n    public void check(int x,int d){\n        visit[x]=1;\n        if(x!=mv){\n            if(adj[x].size()==1){\n                if(d!=0)\n                    res=false;\n                }\n            else if(adj[x].size()<4)\n                res=false;\n        }\n        for(int v:adj[x])\n            if(visit[v]==0)\n                check(v,d-1);\n    }\n}", "complexity": "linear", "problem": "1067_B", "from": "CODEFORCES", "tags": "dfs and similar,graphs,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class LuxuriousHouses {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tSystem.out.println(25);\n\t\t\n\n\t\t\n\t}\n\t\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n}\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/*\n public class _909C {\n\n }\n\n */\npublic class _909C {\n  int mod = (int) 1e9 + 7;\n\n  public void solve() throws FileNotFoundException {\n    InputStream inputStream = System.in;\n\n    InputHelper in = new InputHelper(inputStream);\n\n    // actual solution\n    int n = in.readInteger();\n\n    char[] a = new char[n];\n\n    for (int i = 0; i < n; i++) {\n      a[i] = in.read().charAt(0);\n    }\n\n    int[][][] dp = new int[2][n + 1][2];\n\n    dp[0][0][0] = dp[0][0][1] = 1;\n\n    for (int i = 1; i < n; i++) {\n      for (int j = n; j >= 0; j--) {\n        if (a[i - 1] == 's') {\n          dp[1][j][0] = dp[1][j][1] = dp[0][j][1];\n        } else {\n          if (j > 0)\n            dp[1][j][0] = dp[1][j][1] = dp[0][j - 1][0];\n        }\n      }\n\n      for (int j = 0; j <= n; j++) {\n        dp[0][j][0] = dp[1][j][0];\n        dp[0][j][1] = dp[1][j][1];\n        dp[1][j][0] = 0;\n        dp[1][j][1] = 0;\n      }\n      for (int j = n - 1; j >= 0; j--) {\n        dp[0][j][1] += dp[0][j + 1][1];\n        dp[0][j][1] %= mod;\n      }\n    }\n\n    System.out.println(dp[0][0][1]);\n    // end here\n  }\n\n  public static void main(String[] args) throws FileNotFoundException {\n    (new _909C()).solve();\n  }\n\n  class InputHelper {\n    StringTokenizer tokenizer = null;\n    private BufferedReader bufferedReader;\n\n    public InputHelper(InputStream inputStream) {\n      InputStreamReader inputStreamReader = new InputStreamReader(inputStream);\n      bufferedReader = new BufferedReader(inputStreamReader, 16384);\n    }\n\n    public String read() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          String line = bufferedReader.readLine();\n          if (line == null) {\n            return null;\n          }\n          tokenizer = new StringTokenizer(line);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n\n      return tokenizer.nextToken();\n    }\n\n    public Integer readInteger() {\n      return Integer.parseInt(read());\n    }\n\n    public Long readLong() {\n      return Long.parseLong(read());\n    }\n  }\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.FileNotFoundException;\n\nimport java.io.FileReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.HashSet;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\nimport java.util.Random;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class P {\n\n\n\n\tstatic int N, M, K;\n\n\tstatic int dx[] = { 0, 0, 1, -1, 1, 1, -1, -1 };\n\n\tstatic int dy[] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n\tstatic Pair[] b;\n\n\n\n\tstatic boolean isValid(int x, int y) {\n\n\t\treturn x >= 0 && y >= 0 && x < N && y < M;\n\n\t}\n\n\n\n\tstatic class Pair {\n\n\t\tint x, y;\n\n\n\n\t\tPair(int i, int j) {\n\n\t\t\tx = i;\n\n\t\t\ty = j;\n\n\t\t}\n\n\t}\n\n\n\n\tstatic Pair bfs() {\n\n\t\tQueue<Pair> q = new LinkedList<Pair>();\n\n\t\tint[][] dist = new int[N][M];\n\n\t\tfor (int i = 0; i < N; i++)\n\n\t\t\tfor (int j = 0; j < M; j++)\n\n\t\t\t\tdist[i][j] = -1;\n\n\t\tfor (int i = 0; i < K; i++) {\n\n\t\t\tdist[b[i].x][b[i].y] = 0;\n\n\t\t\tq.add(b[i]);\n\n\t\t}\n\n\n\n\t\twhile (!q.isEmpty()) {\n\n\t\t\tPair cur = q.remove();\n\n\t\t\tfor (int d = 0; d < 4; d++) {\n\n\t\t\t\tint X = cur.x + dx[d];\n\n\t\t\t\tint Y = cur.y + dy[d];\n\n\t\t\t\tif (isValid(X, Y) && dist[X][Y] == -1) {\n\n\t\t\t\t\tdist[X][Y] = dist[cur.x][cur.y] + 1;\n\n\t\t\t\t\tPair P = new Pair(X, Y);\n\n\t\t\t\t\tq.add(P);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tint max = -1;\n\n\t\tPair MX = null;\n\n\t\tfor (int i = 0; i < N; i++)\n\n\t\t\tfor (int j = 0; j < M; j++) {\n\n\t\t\t\tif (dist[i][j] > max) {\n\n\t\t\t\t\tmax = dist[i][j];\n\n\t\t\t\t\tMX = new Pair(i + 1, j + 1);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\treturn MX;\n\n\t}\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner sc = new Scanner(\"input.txt\");\n\n\t\tPrintWriter out = new PrintWriter(\"output.txt\");\n\n\t\t// Scanner sc = new Scanner(System.in);\n\n\t\t// PrintWriter out = new PrintWriter(System.out);\n\n\t\tN = sc.nextInt();\n\n\t\tM = sc.nextInt();\n\n\t\tK = sc.nextInt();\n\n\t\tb = new Pair[K];\n\n\t\tfor (int i = 0; i < K; i++)\n\n\t\t\tb[i] = new Pair(sc.nextInt() - 1, sc.nextInt() - 1);\n\n\n\n\t\tPair last = bfs();\n\n\t\tout.println((last.x) + \" \" + (last.y));\n\n\t\tout.flush();\n\n\t\tout.close();\n\n\t}\n\n\n\n\tstatic class Scanner {\n\n\t\tStringTokenizer st;\n\n\t\tBufferedReader br;\n\n\n\n\t\tpublic Scanner(InputStream s) {\n\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\n\t\t}\n\n\n\n\t\tpublic Scanner(String f) throws FileNotFoundException {\n\n\t\t\tbr = new BufferedReader(new FileReader(f));\n\n\t\t}\n\n\n\n\t\tpublic String next() throws IOException {\n\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\n\t\t}\n\n\n\n\t\tpublic int nextInt() throws IOException {\n\n\t\t\treturn Integer.parseInt(next());\n\n\t\t}\n\n\n\n\t\tpublic long nextLong() throws IOException {\n\n\t\t\treturn Long.parseLong(next());\n\n\t\t}\n\n\n\n\t\tpublic String nextLine() throws IOException {\n\n\t\t\treturn br.readLine();\n\n\t\t}\n\n\n\n\t\tpublic double nextDouble() throws IOException {\n\n\t\t\treturn Double.parseDouble(next());\n\n\t\t}\n\n\n\n\t\tpublic boolean ready() throws IOException {\n\n\t\t\treturn br.ready();\n\n\t\t}\n\n\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\n\t\t\tint[] a = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++)\n\n\t\t\t\ta[i] = nextInt();\n\n\t\t\treturn a;\n\n\t\t}\n\n\n\n\t\tpublic int[] nextIntArray1(int n) throws IOException {\n\n\t\t\tint[] a = new int[n + 1];\n\n\t\t\tfor (int i = 1; i <= n; i++)\n\n\t\t\t\ta[i] = nextInt();\n\n\t\t\treturn a;\n\n\t\t}\n\n\n\n\t\tpublic int[] nextIntArraySorted(int n) throws IOException {\n\n\t\t\tint[] a = nextIntArray(n);\n\n\t\t\tRandom r = new Random();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\t\tint j = i + r.nextInt(n - i);\n\n\t\t\t\tint t = a[i];\n\n\t\t\t\ta[i] = a[j];\n\n\t\t\t\ta[j] = t;\n\n\t\t\t}\n\n\t\t\tArrays.sort(a);\n\n\t\t\treturn a;\n\n\t\t}\n\n\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\n\t\t\tlong[] a = new long[n];\n\n\t\t\tfor (int i = 0; i < n; i++)\n\n\t\t\t\ta[i] = nextLong();\n\n\t\t\treturn a;\n\n\t\t}\n\n\n\n\t\tpublic long[] nextLongArray1(int n) throws IOException {\n\n\t\t\tlong[] a = new long[n + 1];\n\n\t\t\tfor (int i = 1; i <= n; i++)\n\n\t\t\t\ta[i] = nextLong();\n\n\t\t\treturn a;\n\n\t\t}\n\n\n\n\t\tpublic long[] nextLongArraySorted(int n) throws IOException {\n\n\t\t\tlong[] a = nextLongArray(n);\n\n\t\t\tRandom r = new Random();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\t\tint j = i + r.nextInt(n - i);\n\n\t\t\t\tlong t = a[i];\n\n\t\t\t\ta[i] = a[j];\n\n\t\t\t\ta[j] = t;\n\n\t\t\t}\n\n\t\t\tArrays.sort(a);\n\n\t\t\treturn a;\n\n\t\t}\n\n\t}\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Anirudh Rayabharam (anirudhrb@yandex.com)\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        if (n % 2 == 0) {\n            out.println(\"4 \" + (n - 4));\n        } else {\n            out.println(\"9 \" + (n - 9));\n        }\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    private int tokenCount, nextTokenIndex;\n    private String[] tokens;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenCount = nextTokenIndex = 0;\n    }\n\n    public String next() {\n        String nextLine;\n        if (nextTokenIndex == tokenCount) {\n            try {\n                nextLine = reader.readLine();\n                nextTokenIndex = 0;\n                tokens = nextLine.split(\"\\\\s\");\n                tokenCount = tokens.length;\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return tokens[nextTokenIndex++];\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class A {\n\n    public static void main(String[] args) {\n        FastReader scan = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        Task solver = new Task();\n        int t = 1;\n        for(int tt = 1; tt <= t; tt++) solver.solve(tt, scan, out);\n        out.close();\n    }\n\n    static class Task {\n\n        public void solve(int testNumber, FastReader scan, PrintWriter out) {\n            int n = scan.nextInt();\n            int parity = 0;\n            int[] a = new int[n];\n\n            for(int i = 0; i < n; i++) a[i] = scan.nextInt();\n            for(int i = 0; i < n; i++) {\n                for(int j = i + 1; j < n; j++) {\n                    if(a[i] > a[j]) parity++;\n                }\n            }\n            parity %= 2;\n            int q = scan.nextInt();\n            String[] get = {\"even\", \"odd\"};\n            for(int i = 0; i < q; i++) {\n                int l = scan.nextInt(), r = scan.nextInt();\n                parity ^= (r - l + 1) / 2 % 2;\n                out.println(get[parity]);\n            }\n        }\n    }\n\n    static void ruffleSort(int[] a) {\n        Random get = new Random();\n        for (int i = 0; i < a.length; i++) {\n            int r = get.nextInt(a.length);\n            int temp = a[i];\n            a[i] = a[r];\n            a[r] = temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSort(long[] a) {\n        Random get = new Random();\n        for (int i = 0; i < a.length; i++) {\n            int r = get.nextInt(a.length);\n            long temp = a[i];\n            a[i] = a[r];\n            a[r] = temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws FileNotFoundException {\n            br = new BufferedReader(new FileReader(new File(s)));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass TaskA {\n    int n;\n    int m;\n    String answer = \"I'm too stupid to solve this problem\";\n    public void solve(InputReader in, PrintWriter out) {\n        n = in.nextInt();\n        out.println(\"0 0 \" + n);        \n    }\n    \n        \n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n}   ", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class E implements Runnable {\n\tFastReader scn;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tvoid solve() {\n\t\tint t = scn.nextInt();\n\t\twhile(t-- > 0) {\n\t\t\tint n = scn.nextInt(), m = scn.nextInt();\n\t\t\tint[][] arr = scn.next2DInt(n, m);\n\t\t\t\n\t\t\tint[][] col = new int[m][2];\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tint max = 0;\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tmax = Math.max(max, arr[i][j]);\n\t\t\t\t}\n\t\t\t\tcol[j][0] = max;\n\t\t\t\tcol[j][1] = j;\n\t\t\t}\n\t\t\tArrays.parallelSort(col, (o1, o2) -> o2[0] - o1[0]);\n\t\t\t\n\t\t\tm = Math.min(n, m);\n\t\t\t\n\t\t\tint[][] lol = new int[n][m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tlol[i][j] = arr[i][col[j][1]];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] row = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\trow[i] = lol[i][0];\n\t\t\t}\n\t\t\t\n\t\t\tans = 0;\n\t\t\tfunc(lol, 1, row);\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tint ans;\n\t\n\tvoid func(int[][] arr, int col, int[] rowM) {\n\t\tint n = arr.length, m = arr[0].length;\n\t\tif(col >= m) {\n\t\t\tint rv = 0;\n\t\t\tfor(int a : rowM) {\n\t\t\t\trv += a;\n\t\t\t}\n\t\t\tans = Math.max(ans, rv);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint max = 0, ind = -1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(arr[i][col] > max) {\n\t\t\t\tmax = arr[i][col];\n\t\t\t\tind = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean in = false;\n\t\tfor(int r = 0; r < n; r++) {\n\t\t\tif(max <= rowM[r]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint rot = (ind - r + n) % n;\n\t\t\tint[] need = new int[n], copy = Arrays.copyOf(rowM, n);\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tneed[i] = arr[(i + rot) % n][col];\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tarr[i][col] = need[i];\n\t\t\t\tcopy[i] = Math.max(rowM[i], arr[i][col]);\n\t\t\t}\n\t\t\t\n\t\t\tind = r;\n\t\t\tin = true;\n\t\t\tfunc(arr, col + 1, copy);\n\t\t}\n\t\t\n\t\tif(!in) {\n\t\t\tfunc(arr, col + 2, rowM);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\tout = new PrintWriter(System.out);\n\t\tscn = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new E(), \"Main\", 1 << 26).start();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tint c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] shuffle(long[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tlong c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] uniq(int[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tint[] rv = new int[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tlong[] uniq(long[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tlong[] rv = new long[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tint[] reverse(int[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] reverse(long[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] compress(int[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tint[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] compress(long[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tlong[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import sun.reflect.generics.tree.Tree;\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.net.Inet4Address;\nimport java.util.*;\n\npublic class l {\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMMMM      MMMMMM      OOO      OOO        SSSS   SSS     EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEE           MMMM MMM  MMM MMMM    OOO          OOO    SSSS       SSS   EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM  MMMMMM  MMMM   OOO            OOO   SSSS             EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM  OOO              OOO   SSSSSSS         EEEEE          /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO      SSSSSS       EEEEEEEEEEE    /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO         SSSSSSS   EEEEEEEEEEE    /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM   OOO            OOO              SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM    OOO          OOO     SSS       SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM      OOO      OOO        SSS    SSSS    EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    static long mod = (int) (1e9 + 7);\n    static int n;\n    static StringBuilder sol;\n\n    static class pair implements Comparable<pair> {\n        int L,R;\n        public pair( int x,int y) {\n            L=x;R=y;\n        }\n\n\n        public int compareTo(pair o) {\n            if (L!=o.L)return L-o.L;\n            return o.R-R;\n        }\n        public String toString(){\n            return L+\" \"+R;\n        }\n    }\n\n    static boolean is;\n    static int [][][]memo;\n    static int[]val,gen;\n    static int dp(int last,int rem,int msk){\n        if (rem==0)return 1;\n        if (memo[last][rem][msk]!=-1)return memo[last][rem][msk];\n        int ans =0;\n        for (int i =0;i<n;i++){\n            if ((msk&1<<i)==0){\n                if (gen[i]!=last&&val[i]<=rem){\n                    ans+=dp(gen[i],rem-val[i],msk|1<<i);\n                    ans%=mod;\n                }\n            }\n        }\n        return memo[last][rem][msk]=ans;\n    }\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        //FileWriter f = new FileWriter(\"C:\\\\Users\\\\Ibrahim\\\\out.txt\");\n        PrintWriter pw = new PrintWriter(System.out);\n         n = sc.nextInt();\n        int t = sc.nextInt();\n        gen= new int[n];\n        val= new int[n];\n        for (int i =0;i<n;i++){\n            val[i]=sc.nextInt();\n            gen[i]=sc.nextInt();\n        }\n        memo= new int[4][t+1][1<<n];\n        for (int[][]x:memo)for (int[]a:x)Arrays.fill(a,-1);\n        pw.println(dp(0,t,0));\n        pw.flush();\n    }\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n    }\n\n}", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.awt.Point;\n\nimport java.io.BufferedReader;\n\nimport java.io.FileInputStream;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.io.UnsupportedEncodingException;\n\nimport java.net.URISyntaxException;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class Main {\n\n    public static void main(String[] args)throws IOException, URISyntaxException {\n\n        Reader.init(new FileInputStream(\"input.txt\"));\n\n        StringBuilder s=new StringBuilder();\n\n        boolean[][]vis=new boolean[Reader.nextInt()][Reader.nextInt()];\n\n        int k=Reader.nextInt(),r,c;\n\n        Queue<Point>q=new LinkedList<Point>();\n\n        while(k-->0) {\n\n            r=Reader.nextInt()-1;\n\n            c=Reader.nextInt()-1;\n\n            vis[r][c]=true;\n\n            q.add(new Point(r,c));\n\n        }\n\n        Point end=null;\n\n        int[]x={0,0,1,-1},y={1,-1,0,0};\n\n        int a,b,i;\n\n        while(!q.isEmpty()) {\n\n            end=q.poll();\n\n            for(i=0;i<4;i++) {\n\n                a=end.x+x[i];\n\n                b=end.y+y[i];\n\n                if(a>=0&&b>=0&&a<vis.length&&b<vis[a].length&&!vis[a][b]) {\n\n                    vis[a][b]=true;\n\n                    q.add(new Point(a,b));\n\n                }\n\n            }\n\n        }\n\n        s.append(end.x+1).append(' ').append(end.y+1);\n\n        PrintWriter p=new PrintWriter(\"output.txt\");\n\n        p.println(s);\n\n        p.close();\n\n    }\n\n}\n\n\n\nclass Reader {\n\n    static BufferedReader reader;\n\n    static StringTokenizer tokenizer;\n\n\n\n    /** call this method to initialize reader for InputStream */\n\n    static void init(InputStream input) throws UnsupportedEncodingException {\n\n        reader = new BufferedReader(\n\n                     new InputStreamReader(input, \"UTF-8\") );\n\n        tokenizer = new StringTokenizer(\"\");\n\n    }\n\n\n\n    /** get next word */\n\n    static String next() throws IOException {\n\n        while ( ! tokenizer.hasMoreTokens() ) {\n\n            //TODO add check for eof if necessary\n\n            tokenizer = new StringTokenizer(\n\n                   reader.readLine() );\n\n        }\n\n        return tokenizer.nextToken();\n\n    }\n\n    \n\n    static String nextLine() throws IOException {\n\n        return reader.readLine();\n\n    }\n\n\n\n    static int nextInt() throws IOException {\n\n        return Integer.parseInt( next() );\n\n    }\n\n    \n\n    static double nextDouble() throws IOException {\n\n        return Double.parseDouble( next() );\n\n    }\n\n    \n\n    static long nextLong() throws IOException {\n\n        return Long.parseLong( next() );\n\n    }\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n\n\npublic class file{\n\n\n// *********************************************BEGINS*********************************************\npublic static void main(String[] args) throws IOException{\n\n\n// Working program using BufferedReader \n        //BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n       // StringTokenizer st = new StringTokenizer(br.readLine()); \n       // int n = Integer.parseInt(st.nextToken()); \n       // int k = Integer.parseInt(st.nextToken()); \n\nReader scn=new Reader();\nPrintWriter pt=new PrintWriter(System.out);\n\nint n=scn.nextInt();\nint k=scn.nextInt();\nint[] arr=new int[n];\nPriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\nfor(int i=0;i<n;i++){\n    arr[i]=scn.nextInt();\n    pq.add(arr[i]);\n}\n\nint sum=0;\nArrayList<Integer> list=new ArrayList<>();\nfor(int i=0;i<k;i++){\n    int data=pq.remove();\n    list.add(data);\n    sum+=data;\n}\npt.println(sum);\n\nint ind=-1;\nfor(int i=0;list.size()>1;i++){\n    if(list.contains(arr[i])){\n        pt.print(i-ind+\" \");\n        list.remove(new Integer(arr[i]));\n        ind=i;\n    }\n}\npt.println(n-1-ind);\npt.close();\n\n}\n// *********************************************ENDED*********************************************\nstatic boolean isPrime(int n)\n{\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n \n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n \n    return true;\n}\n\nstatic void merge(int arr[], int l, int m, int r)\n    {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n \n        /* Create temp arrays */\n        int L[] = new int [n1];\n        int R[] = new int [n2];\n \n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n \n \n        /* Merge the temp arrays */\n \n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n \n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2)\n        {\n            if (L[i] <= R[j])\n            {\n                arr[k] = L[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n \n        /* Copy remaining elements of L[] if any */\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n \n        /* Copy remaining elements of R[] if any */\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n \n    // Main function that sorts arr[l..r] using\n    // merge()\n    void sort(int arr[], int l, int r)\n    {\n        if (l < r)\n        {\n            // Find the middle point\n            int m = (l + r) / 2;\n \n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr , m + 1, r);\n \n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n\nstatic class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n\npublic Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        }\n\n\npublic Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        }  \n\npublic String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n\n\n public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n\n\n public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n\n\npublic double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n\nprivate void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n\nprivate byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n\n\npublic void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    }\n  \n}", "complexity": "nlogn", "problem": "1006_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class AA implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new AA()).run();\n\n\t}\n\n\tstatic class Utils {\n\n\t\tprivate Utils() {\n\t\t}\n\n\t\tpublic static void mergeSort(int[] a) {\n\t\t\tmergeSort(a, 0, a.length - 1);\n\t\t}\n\n\t\tprivate static void mergeSort(int[] a, int leftIndex, int rightIndex) {\n\t\t\tfinal int MAGIC_VALUE = 50;\n\t\t\tif (leftIndex < rightIndex) {\n\t\t\t\tif (rightIndex - leftIndex <= MAGIC_VALUE) {\n\t\t\t\t\tinsertionSort(a, leftIndex, rightIndex);\n\t\t\t\t} else {\n\t\t\t\t\tint middleIndex = (leftIndex + rightIndex) / 2;\n\t\t\t\t\tmergeSort(a, leftIndex, middleIndex);\n\t\t\t\t\tmergeSort(a, middleIndex + 1, rightIndex);\n\t\t\t\t\tmerge(a, leftIndex, middleIndex, rightIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void merge(int[] a, int leftIndex, int middleIndex,\n\t\t\t\tint rightIndex) {\n\t\t\tint length1 = middleIndex - leftIndex + 1;\n\t\t\tint length2 = rightIndex - middleIndex;\n\t\t\tint[] leftArray = new int[length1];\n\t\t\tint[] rightArray = new int[length2];\n\t\t\tSystem.arraycopy(a, leftIndex, leftArray, 0, length1);\n\t\t\tSystem.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n\t\t\tfor (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n\t\t\t\tif (i == length1) {\n\t\t\t\t\ta[k] = rightArray[j++];\n\t\t\t\t} else if (j == length2) {\n\t\t\t\t\ta[k] = leftArray[i++];\n\t\t\t\t} else {\n\t\t\t\t\ta[k] = leftArray[i] <= rightArray[j] ? leftArray[i++]\n\t\t\t\t\t\t\t: rightArray[j++];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void insertionSort(int[] a, int leftIndex, int rightIndex) {\n\t\t\tfor (int i = leftIndex + 1; i <= rightIndex; i++) {\n\t\t\t\tint current = a[i];\n\t\t\t\tint j = i - 1;\n\t\t\t\twhile (j >= leftIndex && a[j] > current) {\n\t\t\t\t\ta[j + 1] = a[j];\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\ta[j + 1] = current;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tBufferedReader br;\n\tStringTokenizer str = new StringTokenizer(\"\");\n\tPrintWriter pw;\n\n\tpublic Integer ni() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic Double nd() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic Long nl() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic boolean EOF() {\n\t\ttry {\n\t\t\tif (!br.ready() && !str.hasMoreTokens()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String nextToken() {\n\t\twhile (!str.hasMoreTokens())\n\t\t\ttry {\n\t\t\t\tstr = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\treturn str.nextToken();\n\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t// try {\n\t\t// br = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t// } catch (FileNotFoundException e) {\n\t\t// e.printStackTrace();\n\t\t// }\n\t\t// try {\n\t\t// pw = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t// } catch (IOException e) {\n\t\t// // TODO Auto-generated catch block\n\t\t// e.printStackTrace();\n\t\t// }\n\t\tsolve();\n\t\tpw.close();\n\t}\n\n\tpublic void solve() {\n\n\t\tint n = ni();\n\t\tint[] a = new int[n];\n\t\tint total = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = ni();\n\t\t\ttotal+=a[i];\n\t\t}\n\t\tArrays.sort(a);\n\t\tint c =0;\n\t\tint left=0;\n\t\tfor(int i=n-1; i>=0;i--){\n\t\t\tif (left<=total){\n\t\t\t\tc++;\n\t\t\t\tleft+=a[i];\n\t\t\t\ttotal-=a[i];\n\t\t\t}\n\t\t}\n\t\tpw.print(c);\n\t}\n}", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.System.out;\n\npublic class Main {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n    private List<Integer>[] gr = new ArrayList[1000_000+5];\n    private int dp[][] = new int[21][1000_000+5];\n    private boolean used[] = new boolean[1000_000+5];\n\n    void init(int v, int p) {\n        Stack<Integer> st = new Stack<>();\n        st.push(v);\n        st.push(p);\n        while (!st.isEmpty()) {\n            p = st.pop();\n            v = st.pop();\n            used[v] = true;\n\n            dp[0][v] =  p;\n            for (int i = 1; i <= 20; i++) {\n                if (dp[i - 1][v] != -1) {\n                    dp[i][v] = dp[i - 1][dp[i - 1][v]];\n                }\n            }\n\n            for (int next : gr[v]) {\n                if (!used[next]) {\n                    st.push(next);\n                    st.push(v);\n                }\n            }\n\n        }\n    }\n\n\n    private void solve() {\n        int n = scanner.nextInt(), k = scanner.nextInt();\n        boolean[] ans = new boolean[1000_000 + 5];\n\n        for (int i = 0; i < n; i++) {\n            gr[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < n - 1; i ++) {\n            int u = scanner.nextInt() - 1, v = scanner.nextInt() - 1;\n            gr[u].add(v);\n            gr[v].add(u);\n        }\n\n        k = n - k - 1;\n        ans[n - 1] = true;\n\n        init(n - 1 , n - 1);\n\n        int t, d, next;\n        for (int i = n - 2; i >= 0; i--) {\n            t = i;\n            d = 1;\n            if (ans[i]) {\n                continue;\n            }\n            for (int j = 20; j >= 0; j--){\n                next = dp[j][t];\n                if (next != -1 && !ans[next]) {\n                    t = next;\n                    d +=  1 << j;\n                }\n            }\n\n            if (d <= k) {\n                k -=d;\n                t = i;\n\n                while (!ans[t]) {\n                    ans[t] = true;\n                    t = dp[0][t];\n                }\n            }\n            if (k == 0) {\n                break;\n            }\n        }\n        StringBuilder sb = new StringBuilder(\"\");\n        for (int i = 0; i < n; i++) {\n            if (!ans[i]) {\n                sb.append(i + 1).append(\" \");\n            }\n        }\n        System.out.println(sb.toString());\n    }\n\n    class FastScanner {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "complexity": "nlogn", "problem": "0980_E", "from": "CODEFORCES", "tags": "data structures,greedy,trees"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class TaskA {\n\tvoid Run() throws IOException {\n\t\tint n=ReadInt();\n\t\tint[] arr=new int[n];\n\t\tfor(int i=0;i<n;++i)\n\t\t\tarr[i]=ReadInt();\n\t\tArrays.sort(arr);\n\t\tboolean one=true;\n\t\tfor(int x : arr)\n\t\t\tif(x!=1) {\n\t\t\t\tone=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(one) {\n\t\t\tfor(int i=1;i<n;++i)\n\t\t\t\toutput.print(\"1 \");\n\t\t\toutput.print(\"2\");\n\t\t\treturn;\n\t\t}\n\t\tint prev=1;\n\t\tfor(int x : arr)\n\t\t\tif(x==prev) {\n\t\t\t\toutput.print(prev);\n\t\t\t\toutput.print(\" \");\n\t\t\t} else {\n\t\t\t\toutput.print(prev);\n\t\t\t\toutput.print(\" \");\n\t\t\t\tprev=x;\n\t\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\tReader reader;\n\t\treader=oj ? new InputStreamReader(System.in) : new FileReader(\"input.txt\");\n\t\tinput=new BufferedReader(reader);\n\t\tWriter writer=new OutputStreamWriter(System.out);\n\t\twriter=new BufferedWriter(writer);\n\t\toutput=new PrintWriter(writer);\n\t\tnew TaskA().Run();\n\t\toutput.close();\n\t}\n\t\n\tstatic int ReadInt() throws IOException {\n\t\treturn Integer.parseInt(ReadString());\n\t}\n\t\n\tstatic long ReadLong() throws IOException {\n\t\treturn Long.parseLong(ReadString());\n\t}\n\t\n\tstatic String ReadString() throws IOException {\n\t\twhile(tokenizer==null || !tokenizer.hasMoreTokens())\n\t\t\ttokenizer=new StringTokenizer(input.readLine());\n\t\treturn tokenizer.nextToken();\n\t}\n\t\n\tstatic StringTokenizer tokenizer;\n\tstatic BufferedReader input;\n\tstatic PrintWriter output;\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Main\n\t{\n\tpublic static void main(String args[])\tthrows IOException\n\t\t{\n\t\tScanner c=new Scanner(System.in);\n\t\tint n=c.nextInt();\n\t\tint a=c.nextInt();\t\t//higher\n\t\tint b=c.nextInt();\t\t//lower\n\t\tint C[]=new int[n];\n\t\tfor(int i=0;i<n;i++) \n\t\t\tC[i]=c.nextInt();\n\t\tArrays.sort(C);\n\t\t//System.out.println(Arrays.toString(C));\n\t\tint petya=C[n-a];\n\t\tSystem.out.println((C[n-a]-C[n-a-1]));\n\t\t}\n\t}\n\n//must declare new classes here", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.util.*;\npublic class c8 {\n    static int n;\n    static int[] ds;\n    static int[][] g;\npublic static void main(String[] args)\n{\n    Scanner input = new Scanner(System.in);\n    int x = input.nextInt(), y = input.nextInt();\n    int n = input.nextInt();\n    int[] xs = new int[n], ys = new int[n];\n    for(int i = 0; i<n; i++)\n    {\n        xs[i] = input.nextInt();\n        ys[i] = input.nextInt();\n    }\n    ds = new int[n];\n    g = new int[n][n];\n    for(int i = 0; i<n; i++)\n    {\n        ds[i] = (x - xs[i])  *  (x - xs[i]) + (y - ys[i]) * (y - ys[i]);\n        for(int j = 0; j<n; j++)\n        {\n            g[i][j] = (xs[i] - xs[j]) * (xs[i] - xs[j]) + (ys[i] - ys[j]) * (ys[i] - ys[j]);\n        }\n    }\n    int[] dp = new int[1<<n];\n    Arrays.fill(dp, 987654321);\n    dp[0] = 0;\n    for(int i = 0; i<(1<<n); i++)\n    {\n        if(dp[i] == 987654321) continue;\n        for(int a = 0; a<n; a++)\n        {\n            if((i & (1<<a)) > 0) continue;\n            dp[i | (1<<a)] = Math.min(dp[i | (1<<a)], dp[i] + 2*ds[a]);\n            for(int b = a+1; b<n; b++)\n            {\n                if((i & (1<<b)) > 0) continue;\n                dp[i | (1<<a) | (1<<b)] = Math.min(dp[i | (1<<a) | (1<<b)], dp[i] + ds[a] + ds[b] + g[a][b]);\n            }\n            break;\n        }\n    }\n    Stack<Integer> stk = new Stack<Integer>();\n    stk.add(0);\n    int i = (1<<n) - 1;\n    //System.out.println(Arrays.toString(dp));\n\n    trace:\n    while(i > 0)\n    {\n        //System.out.println(i);\n        for(int a = 0; a<n; a++)\n        {\n            if((i & (1<<a)) == 0) continue;\n            if( dp[i] == dp[i - (1<<a)] + 2*ds[a])\n            {\n                stk.add(a+1);\n                stk.add(0);\n                i -= (1<<a);\n                continue trace;\n            }\n            for(int b = a+1; b<n; b++)\n            {\n                if((i & (1<<b)) == 0) continue;\n                if(dp[i] == dp[i - (1<<a) - (1<<b)] + ds[a] + ds[b] + g[a][b])\n                {\n                    stk.add(a+1);\n                    stk.add(b+1);\n                    stk.add(0);\n                    i -= (1<<a) + (1<<b);\n                    continue trace;\n                }\n            }\n            //break;\n        }\n    }\n    System.out.println(dp[(1<<n) - 1]);\n    while(!stk.isEmpty()) System.out.print(stk.pop()+\" \");\n}\n}", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "//package arbuz;\n\nimport java.util.Scanner;\n\npublic class Arbuz {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        if (n % 4 == 0 || n % 7 == 0 || n % 47 == 0 || n % 74 == 0 || n % 444 == 0 || n % 447 == 0 || n % 474 == 0 || n % 477 == 0) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n}\n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\tint n, m, k;\n\tint[] a;\n\t\n\tvoid run()throws IOException{\n//\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\ta = new int[n];\n\t\tfor(int i=0;i<n; i++) a[i] = sc.nextInt();\n\t\tArrays.sort(a);\n\t\t\n\t\tif(m<=k){\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint cnt = k;\n\t\tint ind = a.length-1;\n\t\tint ret = 0;\n\t\twhile(cnt<m && ind>=0){\n\t\t\tcnt += a[ind]-1;\n\t\t\t--ind;\n\t\t\tret++;\n\t\t\t\n\t\t}\n\t\t\n\t\tif(cnt>=m) System.out.println(ret);\n\t\telse System.out.println(-1);\n\t}\n\n\tpublic static void main(String[] args)throws IOException {\n\t\tnew A().run();\n\t}\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class C {\n\tstatic final int M = 1000000007;\t\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(in.readLine());\n\t\t\n\t\tlong x = Long.parseLong(st.nextToken());\n\t\tif(x == 0){\n\t\t\tSystem.out.println(0);\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tfinal long k = Long.parseLong(st.nextToken());\t\n\t\tx = x%M;\n\t\t\n\t\tlong ans = (exp(2, k+1)*x - (exp(2, k) - 1))%M;\n\t\tif(ans < 0) ans += M;\n\t\tSystem.out.println(ans);\n\t\t/*\n\t\tfor(long i = 1234567890; i < 1234567999; i++){\n\t\t\tans = (exp(2, i+1)*x - (exp(2, i) - 1))%M;\n\t\t\tif(ans < 0) ans += M;\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t/*\n\t\tSystem.out.println((k-1)/2);\n\t\tSystem.out.println(x);\n\t\tSystem.out.println(exp(2, k));\n\t\tSystem.out.println(exp(2, k+1));\n\t\t*/\n\t}\n\t\n\tpublic static long exp(long a, long n){\n\t\tif(n == 0) return 1;\n\t\tif(n == 1) return a%M;\n\t\tif(n%2 == 0) return exp((a*a)%M, n/2);\n\t\telse return (a*exp((a*a)%M, (n-1)/2))%M;\n\t}\n}\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n\tstatic int n, m, a[][];\n\tstatic int[][] memo;\n\n\tstatic int[] getCol(int col, int shift) {\n\t\tint[] ans = new int[n];\n\t\tfor (int i = 0, j = shift; i < n; i++, j = (j + 1) % n) {\n\t\t\tans[i] = a[j][col];\n\t\t}\n\t\treturn ans;\n\n\t}\n\n\tstatic int dp(int col, int msk) {\n\t\tif (col == m)\n\t\t\treturn 0;\n\t\tif (memo[msk][col] != -1)\n\t\t\treturn memo[msk][col];\n\t\tint ans = 0;\n\t\tfor (int shift = 0; shift < n; shift++) {\n\t\t\tint[] currCol = getCol(col, shift);\n\t\t\tfor (int nxtMsk = 0; nxtMsk < 1 << n; nxtMsk++) {\n\t\t\t\tif ((nxtMsk & msk) != msk)\n\t\t\t\t\tcontinue;\n\t\t\t\tint curr = 0;\n\t\t\t\tint diff = msk ^ nxtMsk;\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif ((diff & 1 << i) != 0)\n\t\t\t\t\t\tcurr += currCol[i];\n\t\t\t\tans = Math.max(ans, dp(col + 1, nxtMsk) + curr);\n\t\t\t}\n\t\t}\n\t\treturn memo[msk][col] = ans;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint tc = sc.nextInt();\n\t\twhile (tc-- > 0) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tmemo = new int[1 << n][m];\n\t\t\tfor (int[] x : memo)\n\t\t\t\tArrays.fill(x, -1);\n\t\t\ta = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\tout.println(dp(0, 0));\n\t\t}\n\t\tout.close();\n\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tboolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tshuffle(a);\n\t\tArrays.sort(a);\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tRandom rand = new Random();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint tmpIdx = rand.nextInt(n);\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[tmpIdx];\n\t\t\ta[tmpIdx] = tmp;\n\t\t}\n\t}\n\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedInputStream;\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.io.FilterInputStream;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jenish\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        F2SameSumBlocksHard solver = new F2SameSumBlocksHard();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class F2SameSumBlocksHard {\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            int n = in.scanInt();\n            long arr[] = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = in.scanLong();\n            }\n\n\n            HashMap<Long, ArrayList<pair>> hm = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                long sum = 0;\n                for (int j = i; j < n; j++) {\n                    sum += arr[j];\n                    if (hm.containsKey(sum)) {\n                        hm.get(sum).add(new pair(i + 1, j + 1));\n                    } else {\n                        hm.put(sum, new ArrayList<>());\n                        hm.get(sum).add(new pair(i + 1, j + 1));\n                    }\n                }\n            }\n\n\n            long maxi_sum = -1;\n            long sum = 0;\n            for (Map.Entry<Long, ArrayList<pair>> k : hm.entrySet()) {\n                Collections.sort(k.getValue(), new Comparator<pair>() {\n\n                    public int compare(pair o1, pair o2) {\n                        return o1.r - o2.r;\n                    }\n                });\n\n                int count = k.getValue().size() > 0 ? 1 : 0;\n                int index = 0;\n                for (int i = 1; i < k.getValue().size(); i++) {\n                    if (k.getValue().get(i).l > k.getValue().get(index).r) {\n                        count++;\n                        index = i;\n                    }\n                }\n\n\n                if (count > maxi_sum) {\n                    maxi_sum = count;\n                    sum = k.getKey();\n                }\n            }\n\n            out.println(maxi_sum);\n            ArrayList<pair> tt = hm.get(sum);\n            Collections.sort(tt, new Comparator<pair>() {\n\n                public int compare(pair o1, pair o2) {\n                    return o1.r - o2.r;\n                }\n            });\n\n\n            out.println(tt.size() > 0 ? (tt.get(0).l + \" \" + tt.get(0).r) : (\" \"));\n            int index = 0;\n            for (int i = 1; i < tt.size(); i++) {\n                if (tt.get(i).l > tt.get(index).r) {\n                    out.println(tt.get(i).l + \" \" + tt.get(i).r);\n                    index = i;\n                }\n            }\n\n\n        }\n\n        class pair {\n            int l;\n            int r;\n\n            public pair(int l, int r) {\n                this.l = l;\n                this.r = r;\n            }\n\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int INDEX;\n        private BufferedInputStream in;\n        private int TOTAL;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (INDEX >= TOTAL) {\n                INDEX = 0;\n                try {\n                    TOTAL = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (TOTAL <= 0) return -1;\n            }\n            return buf[INDEX++];\n        }\n\n        public int scanInt() {\n            int I = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    I *= 10;\n                    I += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * I;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n        public long scanLong() {\n            long I = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    I *= 10;\n                    I += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * I;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class D {\n\t\n\tpublic static class BIT {\n\t\tint[] dat;\n\t\t\n\t\tpublic BIT(int n){\n\t\t\tdat = new int[n + 1];\n\t\t}\n\t\t\n\t\tpublic void add(int k, int a){ // k : 0-indexed\n\t\t\tfor(int i = k + 1; i < dat.length; i += i & -i){\n\t\t\t\tdat[i] += a;\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int sum(int s, int t){ // [s, t)\n\t\t\tif(s > 0) return sum(0, t) - sum(0, s);\n\t\t\t\n\t\t\tint ret = 0;\n\t\t\tfor(int i = t; i > 0; i -= i & -i) {\n\t\t\t\tret += dat[i];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry (final Scanner sc = new Scanner(System.in)) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tint[] array = new int[N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tarray[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\t\n\t\t\tlong inv = 0;\n\t\t\tBIT bit = new BIT(N);\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tinv += bit.sum(array[i], N);\n\t\t\t\tbit.add(array[i], 1);\n\t\t\t}\n\t\t\t//System.out.println(inv);\n\t\t\t\n\t\t\tint mod2 = (int)(inv % 2);\n\t\t\tfinal int M = sc.nextInt();\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\n\t\t\t\tfinal long size = (r - l) + 1;\n\t\t\t\tif(size > 1){\n\t\t\t\t\t//System.out.println(size + \" \" + ((size * (size - 1) / 2)));\n\t\t\t\t\tif((size * (size - 1) / 2) % 2 == 1){\n\t\t\t\t\t\tmod2 = 1 - mod2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((mod2 == 0) ? \"even\" : \"odd\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() {\n\t\t\ttry {\n\t\t\t\twhile (!hasNext()) {\n\t\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t} catch (IOException e) { /* ignore */\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) { /* ignore */\n\t\t\t}\n\t\t}\n\t}\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class n122A {\n    Scanner in;\n    PrintWriter out;\n\n    void solve() {\n        int n = in.nextInt();\n        boolean good = false;\n        if (n % 4 == 0) {\n            good = true;\n        }\n        if (n % 7 == 0) {\n            good = true;\n        }\n        if (n % 44 == 0) {\n            good = true;\n        }\n        if (n % 47 == 0) {\n            good = true;\n        }\n        if (n % 74 == 0) {\n            good = true;\n        }\n        if (n % 77 == 0) {\n            good = true;\n        }\n        if (n % 444 == 0) {\n            good = true;\n        }\n        if (n % 447 == 0) {\n            good = true;\n        }\n        if (n % 474 == 0) {\n            good = true;\n        }\n        if (n % 477 == 0) {\n            good = true;\n        }\n        if (n % 744 == 0) {\n            good = true;\n        }\n        if (n % 747 == 0) {\n            good = true;\n        }\n        if (n % 774 == 0) {\n            good = true;\n        }\n        if (n % 777 == 0) {\n            good = true;\n        }\n        if (good) {\n            out.println(\"YES\");\n        } else {\n            out.println(\"NO\");\n        }\n    }\n\n    void run() {\n        in = new Scanner(System.in);\n        out = new PrintWriter(System.out);\n        try {\n            solve();\n        } finally {\n            out.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        new n122A().run();\n\n    }\n\n}\n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n\npublic class Codeforces {\n            \n    public static void main(String[] args) throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        final double eps = 1e-7;\n        String toks[] = in.readLine().split(\" \");\n        int n = Integer.parseInt(toks[0]);\n        double r = Double.parseDouble(toks[1]);\n        double x[] = new double[n];\n        toks = in.readLine().split(\" \");\n        for (int i = 0; i < n; i++) {\n            x[i] = Double.parseDouble(toks[i]);\n        }\n        double lo, hi, mid;\n        double y[] = new double[n];\n        y[0] = r;\n        for (int i = 1; i < n; i++) {\n            y[i] = r;\n            for(int j=0; j<i; j++) {\n                lo = y[j]; hi = 2000*2000;\n                while( Math.abs(hi-lo) >= eps ) {\n                    mid = (hi+lo)/2;\n                    if( Math.sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[j]-mid)*(y[j]-mid) ) + eps > 2*r ) {\n                        hi = mid;\n                    } else {\n                        lo = mid;\n                    }\n                }\n                if(Math.sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[j]-lo)*(y[j]-lo) ) < 2*r + eps) {\n                    y[i] = Math.max(y[i], lo);\n                }\n            }\n        }\n        for (double z : y) {\n            System.out.printf(Locale.US, \"%.7f \", z);\n        }\n    }\n}\n\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.*;\n\npublic class CF8C {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s = br.readLine();\n\t\tint si = s.indexOf(' ', 0);\n\t\tint x = Integer.parseInt(s.substring(0, si));\n\t\tint y = Integer.parseInt(s.substring(si + 1));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint[] xx = new int[n + 1];\n\t\tint[] yy = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts = br.readLine();\n\t\t\tsi = s.indexOf(' ', 0);\n\t\t\txx[i] = Integer.parseInt(s.substring(0, si));\n\t\t\tyy[i] = Integer.parseInt(s.substring(si + 1));\n\t\t}\n\t\txx[n] = x;\n\t\tyy[n] = y;\n\t\tint[][] dd = new int[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\tint dx = xx[i] - xx[j];\n\t\t\t\tint dy = yy[i] - yy[j];\n\t\t\t\tdd[i][j] = dx * dx + dy * dy;\n\t\t\t}\n\t\tint[] aa = new int[1 << n];\n\t\tint[] bb = new int[1 << n];\n\t\tfor (int k = 1; k < 1 << n; k++) {\n\t\t\tint a = -1;\n\t\t\tfor (int b = 0; b < n; b++)\n\t\t\t\tif ((k & 1 << b) > 0) {\n\t\t\t\t\ta = b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tint l = k ^ 1 << a;\n\t\t\tint d = dd[a][n] + dd[a][n];\n\t\t\taa[k] = aa[l] + d;\n\t\t\tbb[k] = l;\n\t\t\tfor (int b = a + 1; b < n; b++)\n\t\t\t\tif ((k & 1 << b) > 0) {\n\t\t\t\t\tl = k ^ 1 << a ^ 1 << b;\n\t\t\t\t\td = dd[a][n] + dd[b][n] + dd[a][b];\n\t\t\t\t\tif (aa[l] + d < aa[k]) {\n\t\t\t\t\t\taa[k] = aa[l] + d;\n\t\t\t\t\t\tbb[k] = l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tint k = (1 << n) - 1;\n\t\tSystem.out.println(aa[k]);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(0);\n\t\twhile (k != 0) {\n\t\t\tint l = bb[k];\n\t\t\tint m = k ^ l;\n\t\t\tfor (int b = 0; b < n; b++)\n\t\t\t\tif ((m & 1 << b) > 0)\n\t\t\t\t\tsb.append(' ').append(b + 1);\n\t\t\tsb.append(' ').append(0);\n\t\t\tk = l;\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.lang.Math;\nimport java.io.*;    \nimport java.util.*;\n \npublic class Main {\n        \n        static BufferedReader in;\n        static PrintStream out;\n        static StringTokenizer tok;\n        \n        @SuppressWarnings(\"empty-statement\")\n\tpublic static void main(String[] args) throws NumberFormatException, IOException, Exception {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            //in = new BufferedReader(new FileReader(\"metro.txt\"));\n            out = System.out;\n            \n            long mod = (long)1e9 + 7;\n            int n = nextInt();\n            long[][] dp = new long[n+1][n+1];\n            Character[] line = new Character[n+1];\n            line[0] = 'a';\n            for (int i = 1; i <= n; i++) {\n                line[i] = nextToken().charAt(0);\n                if(line[i-1] == 'f')//for\n                {\n                    for (int j = 0; j < i; j++) {\n                        dp[i][j+1] = dp[i-1][j];\n                    }\n                }\n                else if(line[i-1] == 's')//simple\n                {\n                    long temp = 0;\n                    for(int j = i; j >=0; j--)\n                    {\n                        temp = (temp + dp[i-1][j]) % mod;\n                        dp[i][j] = temp;\n                    }\n                }\n                else dp[i][0] = 1;\n            }\n            long total = 0;\n            for(int j = 0; j <= n; j++)\n                total = (total + dp[n][j]) % mod;\n            out.println(total);\n        }\n        static String nextToken() throws IOException\n        {\n                String line = \"\";\n                while(tok == null || !tok.hasMoreTokens()) {\n                        if((line = in.readLine()) != null)\n                                tok = new StringTokenizer(line);\n                        else \n                                return null;\n                }\n                return tok.nextToken();\n        }\n        static int nextInt() throws NumberFormatException, IOException\n        {\n                return Integer.parseInt(nextToken());\n        }\n        static long nextLong() throws NumberFormatException, IOException\n        {\n                return Long.parseLong(nextToken());\n        }\n\n}", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Quiz {\n    public static int mod = 1000000009;\n    public static void main(String[] args) throws IOException {\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(f.readLine());\n        long n = Long.parseLong(st.nextToken());\n        long m = Long.parseLong(st.nextToken());\n        long k = Long.parseLong(st.nextToken());\n        long d = n-m;\n        n -= d*k;\n        if (n <= 0)\n        {\n            System.out.println(m);\n            return;\n        }\n        long sum = (n%k) + d*(k-1);\n        sum += 2*k*(pow(2,n/k)-1);\n        sum %= mod;\n        System.out.println(sum);\n    }\n    \n    public static long pow(long a, long n)\n    {\n        if (n == 0)\n            return 1;\n        long pow = pow(a,n/2);\n        pow = pow*pow % mod;\n        if (n % 2 == 1)\n            pow = pow*a % mod;\n        return pow;\n    }\n}", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.util.*;\nimport static java.util.Arrays.deepToString;\n\npublic class A {\n\n\tprivate static int[] prime = new int[] {\n\t\t    2,     3,     5,     7,    11,    13,    17,    19,    23,    29,    31,    37,    41,    43,\n\t\t   47,    53,    59,    61,    67,    71,    73,    79,    83,    89,    97,   101,   103,   107,\n\t\t  109,   113,   127,   131,   137,   139,   149,   151,   157,   163,   167,   173,   179,   181,\n\t\t  191,   193,   197,   199,   211,   223,   227,   229,   233,   239,   241,   251,   257,   263,\n\t\t  269,   271,   277,   281,   283,   293,   307,   311,   313,   317,   331,   337,   347,   349,\n\t\t  353,   359,   367,   373,   379,   383,   389,   397,   401,   409,   419,   421,   431,   433,\n\t\t  439,   443,   449,   457,   461,   463,   467,   479,   487,   491,   499,   503,   509,   521,\n\t\t  523,   541,   547,   557,   563,   569,   571,   577,   587,   593,   599,   601,   607,   613,\n\t\t  617,   619,   631,   641,   643,   647,   653,   659,   661,   673,   677,   683,   691,   701,\n\t\t  709,   719,   727,   733,   739,   743,   751,   757,   761,   769,   773,   787,   797,   809,\n\t\t  811,   821,   823,   827,   829,   839,   853,   857,   859,   863,   877,   881,   883,   887,\n\t\t  907,   911,   919,   929,   937,   941,   947,   953,   967,   971,   977,   983,   991,   997\t\t\t\t\n\t};\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\t\n\t\tfor (int i=0;i<prime.length-1;i++) {\n\t\t\tif ((prime[i]+prime[i+1]+1) > n || k == 0)\n\t\t\t\tbreak;\n\t\t\tif (isPrime(prime[i]+prime[i+1]+1))\n\t\t\t\tk--;\n\t\t}\n\t\t\n\t\tif (k == 0)\n\t\t\toutnl(\"YES\");\n\t\telse\n\t\t\toutnl(\"NO\");\n\t}\n\t\n\tpublic static boolean isPrime(int x) {\n\t\tint i=0;\n\t\twhile (i<prime.length)\n\t\t\tif (prime[i++] == x)\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\t\n\tprivate static void debug(Object... os) { System.out.println(deepToString(os)); }\n\tprivate static void outnl(String out) { System.out.println(out); } \n\n}", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.util.*;\npublic class A {\n\n\tpublic static void main(String[] args) {\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tlong l = sc.nextLong();\n\t\tlong h = sc.nextLong();\n\t\t\n\t\tsc.close();\n\t\t\n\t\tif(h-l<2) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tif(h-l==2 && l%2==1) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tif(l%2==1) {\n\t\t\t++l;\n\t\t}\n\t\t\n\t\tSystem.out.printf(\"%d %d %d\\n\",l,l+1L,l+2L);\n\t}\n\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.Collection;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.FileInputStream;\nimport java.io.InputStreamReader;\nimport java.util.Objects;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Nafiur Rahman Khadem Shafin \ud83d\ude42\n */\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader (inputStream);\n\t\tPrintWriter out = new PrintWriter (outputStream);\n\t\tProblemCFireAgain solver = new ProblemCFireAgain ();\n\t\tsolver.solve (1, in, out);\n\t\tout.close ();\n\t}\n\t\n\tstatic class ProblemCFireAgain {\n\t\tprivate static final byte[] dx = {-1, 0, 0, 1};\n\t\tprivate static final byte[] dy = {0, -1, 1, 0};\n\t\tprivate static int[][] lvl;\n\t\tprivate static int max;\n\t\tprivate static int n;\n\t\tprivate static int m;\n\t\tprivate static int k;\n\t\tprivate static ProblemCFireAgain.Pair[] bgn;\n\t\tprivate static ProblemCFireAgain.Pair res;\n\t\t\n\t\tprivate static void bfs2d () {\n\t\t\tQueue<ProblemCFireAgain.Pair> bfsq = new LinkedList<ProblemCFireAgain.Pair> ();\n\t\t\tfor (ProblemCFireAgain.Pair src : bgn) {\n\t\t\t\tlvl[src.a][src.b] = 0;\n\t\t\t\tbfsq.add (src);\n\t\t\t}\n\t\t\twhile (!bfsq.isEmpty ()) {\n\t\t\t\tProblemCFireAgain.Pair op = bfsq.poll ();\n\t\t\t\tint plvl = lvl[op.a][op.b];\n//\t\t\tSystem.out.println (\"ber hoise \"+op+\" \"+plvl);\n\t\t\t\tif (plvl>max) {\n\t\t\t\t\tres = op;\n\t\t\t\t\tmax = plvl;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i<4; i++) {\n\t\t\t\t\tint newX = op.a+dx[i];\n\t\t\t\t\tint newY = op.b+dy[i];\n//\t\t\t\tSystem.out.println (newX+\" \"+newY+\" \"+n+\" \"+m);\n\t\t\t\t\tif (newX>0 && newX<=n && newY>0 && newY<=m && lvl[newX][newY] == -1) {\n\t\t\t\t\t\tbfsq.add (new ProblemCFireAgain.Pair (newX, newY));\n\t\t\t\t\t\tlvl[newX][newY] = (plvl+1);\n//\t\t\t\t\tSystem.out.println (\"dhukse \"+newX+\" \"+newY);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void solve (int testNumber, InputReader _in, PrintWriter _out) {\n\t\t\t/*\n\t\t\t * file input-output \ud83d\ude2e. Multi source bfs. Same as snackdown problem.\n\t\t\t * */\n\t\t\ttry (InputReader in = new InputReader (new FileInputStream (\"input.txt\"));\n\t\t\t\t PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (\"output.txt\")))) {\n\t\t\t\tn = in.nextInt ();\n\t\t\t\tm = in.nextInt ();\n\t\t\t\tk = in.nextInt ();\n\t\t\t\tbgn = new ProblemCFireAgain.Pair[k];\n\t\t\t\tfor (int i = 0; i<k; i++) {\n\t\t\t\t\tbgn[i] = new ProblemCFireAgain.Pair (in.nextInt (), in.nextInt ());\n\t\t\t\t}\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tlvl = new int[n+5][m+5];\n\t\t\t\tfor (int i = 0; i<n+4; i++) {\n\t\t\t\t\tArrays.fill (lvl[i], -1);\n\t\t\t\t}\n\t\t\t\tbfs2d ();\n//\t\t\tSystem.out.println (max);\n\t\t\t\tout.println (res);\n\t\t\t} catch (Exception e) {\n//\t\t\te.printStackTrace ();\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate static class Pair {\n\t\t\tint a;\n\t\t\tint b;\n\t\t\t\n\t\t\tPair (int a, int b) {\n\t\t\t\tthis.a = a;\n\t\t\t\tthis.b = b;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tpublic String toString () {\n\t\t\t\treturn a+\" \"+b;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tpublic boolean equals (Object o) {\n\t\t\t\tif (this == o) return true;\n\t\t\t\tif (!(o instanceof ProblemCFireAgain.Pair)) return false;\n\t\t\t\tProblemCFireAgain.Pair pair = (ProblemCFireAgain.Pair) o;\n\t\t\t\treturn a == pair.a && b == pair.b;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tpublic int hashCode () {\n\t\t\t\treturn Objects.hash (a, b);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class InputReader implements AutoCloseable {\n\t\tprivate BufferedReader reader;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic InputReader (InputStream stream) {\n\t\t\treader = new BufferedReader (new InputStreamReader (stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\t\n\t\tpublic String next () {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens ()) {\n\t\t\t\ttry {\n\t\t\t\t\tString str;\n\t\t\t\t\tif ((str = reader.readLine ()) != null) tokenizer = new StringTokenizer (str);\n\t\t\t\t\telse return null;//to detect eof\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException (e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken ();\n\t\t}\n\t\t\n\t\tpublic int nextInt () {\n\t\t\treturn Integer.parseInt (next ());\n\t\t}\n\t\t\n\t\t\n\t\tpublic void close () throws Exception {\n\t\t\treader.close ();\n\t\t}\n\t\t\n\t}\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class A {\n\n  static int countColors(List<Integer> colors) {\n    Collections.sort(colors);\n    int k = 0;\n    while (!colors.isEmpty()) {\n      Integer c = colors.get(0);\n      colors.remove(0);\n      k++;\n\n      List<Integer> toRemove = new ArrayList<>();\n      for (int i = 0; i < colors.size(); i++) {\n        if (colors.get(i) % c == 0) toRemove.add(i);\n      }\n\n      Collections.reverse(toRemove);\n      for (Integer integer : toRemove) {\n        colors.remove(integer.intValue());\n      }\n    }\n    return k;\n  }\n\n  public static void main(String[] args) {\n    try (Scanner scanner = new Scanner(System.in)) {\n      int n = scanner.nextInt();\n      scanner.nextLine();\n      List<Integer> integers = Arrays.stream(scanner.nextLine().split(\" \")).map(Integer::parseInt).collect(Collectors.toList());\n      System.out.println(countColors(integers));\n    }\n  }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Train_A {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int [] h = new int[n]; \n        for (int i = 0; i < n; i++) {\n            h[i]  = sc.nextInt(); \n        }\n        Arrays.sort(h);\n        System.out.println(h[n-a] - h[b-1]);\n    }\n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Codechef\n{\n \n        public static void main(String[] args) {\n            Scanner s = new Scanner(System.in);\n            int n=s.nextInt();\n            int a[]=new int[n];\n            for(int i=0;i<n;i++)\n            a[i]=s.nextInt();\n            Arrays.sort(a);\n            ArrayList<Integer>al=new ArrayList();\n            int k=a[0];\n            int count=0;\n            for(int j=0;j<n;j++)\n            {k=a[j];\n                if(Collections.frequency(al,a[j])==0)\n                {for(int i=0;i<n;i++)\n            {if(a[i]%k==0)\n            {al.add(a[i]);}}\n            count++;}}\n            System.out.println(count);}}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author anand.oza\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        APaintTheNumbers solver = new APaintTheNumbers();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class APaintTheNumbers {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n\n            int[] a = in.readIntArray(n);\n\n            Arrays.sort(a);\n\n            int answer = 0;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == 0)\n                    continue;\n\n                answer++;\n                for (int j = 0; j < n; j++) {\n                    if (j == i)\n                        continue;\n                    if (a[j] % a[i] == 0) {\n                        a[j] = 0;\n                    }\n                }\n\n                a[i] = 0;\n            }\n\n            out.println(answer);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] readIntArray(int n) {\n            int[] x = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextInt();\n            }\n            return x;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    long n;\n    long maxlcm;\n    \n    void run(){\n    \tn = cin.nextInt();\n    \tif(n == 1 || n ==2)\n    \t\tmaxlcm = n;\n    \telse if(n >= 3){\n            \tif(n % 2 != 0){\n    \t           \tmaxlcm = n * (n-1) * (n - 2);\n    \t        }\n            \telse if(n%3 != 0)\n            \t\tmaxlcm = n * (n-1) * (n - 3);\n            \telse maxlcm = (n - 1) * (n - 2) * (n - 3);\n    \t}  \n    \tSystem.out.println(maxlcm);\n    }\n\n\tpublic static void main(String[] args) {\n\t\t new Main().run();\n\t}\n\tScanner cin = new Scanner(new BufferedInputStream(System.in));\n}\n  \t\t \t   \t\t \t\t \t\t\t \t \t\t", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "    import java.util.*;\n    import java.io.*;\n    //import java.lang.*;\n\n    public class ranjan{\n\n        public static Read cin;\n        //public static InputReader cin;\n        public static PrintWriter cout;\n        public static int[] visited;\n        public static final long bil = (long)1e9+7;\n        public static int fileread = 0; \n        \n        public static void main(String ...arg) throws IOException\n        {\n            /*console writer*/\n            cout = new PrintWriter(new BufferedOutputStream(System.out));\n            /*Debug Reader*/\n            //Scan cin =new Scan();clear\n            \n            if(fileread == 1)\n            {\n                try\n                {\n                cin = new Read(new FileInputStream(new File(\"in3.txt\")));\n                //cin = new InputReader(new FileInputStream(new File(\"in1.txt\")));\n                }\n                catch (IOException error){}\n            }\n            else{\n                cin = new Read(System.in);\n                //cin = new InputReader(System.in);\n            }\n\n            //input\n            int n = cin.nextInt();\n            HashSet<Long> ls = new HashSet<>();\n            long[] q1 = new long[n];\n            long[] q2 = new long[n];\n\n            for(int i=0;i<n;i++){\n                q1[i] = cin.nextLong();\n                q2[i] = cin.nextLong()+1;\n                ls.add(q1[i]);\n                ls.add(q2[i]);\n            }\n            long[] compress = new long[ls.size()];\n            int index = 0;\n            for(Long x:ls)\n                compress[index++] = x;\n            Arrays.sort(compress);\n\n            //process\n            int[] prefix = new int[compress.length];\n            for(int i=0;i<n;i++){\n                prefix[Arrays.binarySearch(compress, q1[i])]++;\n                prefix[Arrays.binarySearch(compress, q2[i])]--;\n            }\n\n            for(int i=1;i<compress.length;i++)\n                prefix[i] += prefix[i-1];\n\n            long[] ans = new long[n];\n            for(int i=0;i<compress.length-1;i++){\n                if(prefix[i] != 0)\n                    ans[prefix[i]-1] +=  compress[i+1]-compress[i];\n            }\n\n            //output\n            for(long x:ans)\n                cout.print(x+\" \");\n\n\n            cout.print(\"\\n\");\n            cout.close();\n        }\n\n\n        private static class Pair{\n            public int a,b;\n            public Pair(int a,int b)\n            {\n                this.a = a;\n                this.b = b;\n            }\t\n        }\n\n\n        /*public static void seive(int size)\n        {\n            prime[0] = prime[1] = false;\n            int p = 2;\n            while(p*p<= size)\n            {\n                if(prime[p])\n                {\n                    for(int i=p*p;i<size;i += p)\n\n                        prime[i] = false;\n                }\n                p++;\n            }\n        }*/\n\n\n        public static <K, V> V getOrDefault(HashMap<K,V> map, K key, V defaultValue) {\n            return map.containsKey(key) ? map.get(key) : defaultValue;\n        }\n        \n        static void reverseArray(int intArray[], int size) \n        { \n            int i, temp; \n            for (i = 0; i < size / 2; i++) { \n                temp = intArray[i]; \n                intArray[i] = intArray[size - i - 1]; \n                intArray[size - i - 1] = temp; \n            }  \n        } \n\n        public static long mod_pow(long x,long n,long mod) {\n            long res=1;\n            while(n>0) {\n                if((n&1)==1)res=res*x%mod;\n                x=x*x%mod;\n                n>>=1;\n            }\n            return res;\n        }\n        public static int gcd(int n1, int n2) \n        {\n            int r;\n            while (n2 != 0) \n            {\n                r = n1 % n2;\n                n1 = n2;\n                n2 = r;\n            }\n            return n1;\n        }\n    \n        /*public static int lcm(int n1, int n2) \n        {\n            int answer = (n1 * n2) / (gcd(n1, n2));\n            return answer;\n        }*/\n\n\n        static class InputReader {\n            final InputStream is;\n            final byte[] buf = new byte[1024];\n            int pos;\n            int size;\n    \n            public InputReader(InputStream is) {\n                this.is = is;\n            }\n    \n            public int nextInt() {\n                int c = read();\n                while (isWhitespace(c))\n                    c = read();\n                int sign = 1;\n                if (c == '-') {\n                    sign = -1;\n                    c = read();\n                }\n                int res = 0;\n                do {\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    res = res * 10 + c - '0';\n                    c = read();\n                } while (!isWhitespace(c));\n                return res * sign;\n            }\n    \n            int read() {\n                if (size == -1)\n                    throw new InputMismatchException();\n                if (pos >= size) {\n                    pos = 0;\n                    try {\n                        size = is.read(buf);\n                    } catch (IOException e) {\n                        throw new InputMismatchException();\n                    }\n                    if (size <= 0)\n                        return -1;\n                }\n                return buf[pos++] & 255;\n            }\n    \n            static boolean isWhitespace(int c) {\n                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n            }\n    \n        }\n\n}\n\n\n    \nclass Read\n{\n    private BufferedReader br;\n    private StringTokenizer st;\n\n    public Read(InputStream is)\n    { br = new BufferedReader(new InputStreamReader(is)); }\n\n    String next()\n    {\n        while (st == null || !st.hasMoreElements())\n        {\n            try {st = new StringTokenizer(br.readLine());}\n            catch(IOException e)\n                {e.printStackTrace();}\n        }\n        return st.nextToken();\n    }\n\n    int nextInt()\n    { return Integer.parseInt(next()); }\n\n    long nextLong()\n    { return Long.parseLong(next()); }\n\n    double nextDouble()\n    { return Double.parseDouble(next()); }\n\n    String nextLine()\n    {\n        String str = \"\";\n        try {str = br.readLine();}\n        catch(IOException e)\n            {e.printStackTrace();}\n        return str;\n    }\n}\n\n", "complexity": "nlogn", "problem": "1000_C", "from": "CODEFORCES", "tags": "data structures,implementation,sortings"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\n\npublic class Main {\n\tBufferedReader in;\n\tPrintWriter out;\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tnew Main().run();\n\t}\n\tpublic void run() throws IOException\n\t{\n\t\t//in=new BufferedReader(new FileReader(\"input.txt\"));\n\t\t//out=new PrintWriter(new FileWriter(\"output.txt\"));\n\t\tin=new BufferedReader(new InputStreamReader(System.in));\n\t\tout=new PrintWriter(new OutputStreamWriter(System.out));\n\t\tsolve();\n\t\t\n\t\tout.flush();\n\t}\n\n\tpublic void solve() throws IOException\n\t{\n\t\tString now=in.readLine();\n\t\tint l=now.length();\n\t\tint answ=0;\n\t\tfor(int i=0;i!=l;i++)\n\t\t\tfor(int j=i+1;j<l;j++)\n\t\t\t{\n\t\t\t\tString a=now.substring(i, j);\n\t\t\t\tfor(int k=i+1;k<l-j+i+1;k++)\n\t\t\t\t\tif(a.compareTo(now.substring(k, k+j-i))==0)\n\t\t\t\t\t\tansw=Math.max(answ, a.length());\n\t\t\t}\n\t\tout.print(answ);\n\t\t\n\t\t\n\t}\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.Scanner;\npublic class Main{\n  public static void main(String[] args){\n    Scanner scan = new Scanner(System.in);\n    int n = scan.nextInt();\n    if (n % 4 == 0 || n % 7 == 0 || n % 47 == 0 || n % 77 == 0 || n % 74 == 0 || n % 447 == 0 || n % 474 == 0 || n % 477 == 0 || n % 747 == 0 || n % 774 == 0 || n % 777 == 0)\n      System.out.println(\"YES\");\n    else\n      System.out.println(\"NO\");\n  }\n}", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class C2 {\n\n    public static void main(String args[]) {\n        InputScanner is = new InputScanner();\n        try {\n            int n = is.nextInt();\n            String input = is.next();\n            char[] tab = input.toCharArray();\n            int start = 0, end = 0, dist = 0, hCount = 0, min = Integer.MAX_VALUE;\n            for (int i = 0; i < n; i++) if (tab[i] == 'H') dist++;\n            for (int i = 0; i < dist; i++) if (tab[i] == 'H') hCount++;\n            end = dist;\n            for (int i = 0; i < n; i++) {\n                min = Math.min(min, dist - hCount);\n                if (tab[i] == 'H') hCount--;\n                if (tab[end] == 'H') hCount++;\n                end++;\n                end %= n;\n            }\n            System.out.println(min);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class InputScanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public InputScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreTokens()) {\n                String line = br.readLine();\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            String next = next();\n            return Integer.parseInt(next);\n        }\n\n        public long nextLong() throws IOException {\n            String next = next();\n            return Long.parseLong(next);\n        }\n    }\n}", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic Scanner cin = new Scanner(System.in);\n\tstatic int n, x, y;\n\tstatic long c;\n\t\n\tprivate static long f(int mid) {\n\t\tlong block = 1 + 4 * (long)(mid + 1) * mid / 2;\n\t\tint l = y - mid;\n\t\tint r = y + mid;\n\t\tint u = x - mid;\n\t\tint d = x + mid;\n\t\tif(l <= 0)\n\t\t\tblock -= (long)(1 - l) * (1 - l);\n\t\tif(r > n)\n\t\t\tblock -= (long)(r - n) * (r - n);\n\t\tif(u <= 0)\n\t\t\tblock -= (long)(1 - u) * (1 - u);\n\t\tif(d > n)\n\t\t\tblock -= (long)(d - n) * (d - n);\n\t\tif(u <= 0 && 1 - u > n - y + 1) {\n\t\t\tint t = (1 - u) - (n - y + 1);\n\t\t\tblock += (long)t * (1 + t) / 2;\n\t\t}\n\t\tif(u <= 0 && (1 - u) > y) {\n\t\t\tint t = (1 - u) - y;\n\t\t\tblock += (long)t * (1 + t) / 2;\n\t\t}\n\t\tif(d > n && d - n > n - y + 1) {\n\t\t\tint t = (d - n) - (n - y + 1);\n\t\t\tblock += (long)t * (1 + t) / 2;\n\t\t}\n\t\tif(d > n && d - n > y) {\n\t\t\tint t = (d - n) - y;\n\t\t\tblock += (long)t * (1 + t) / 2;\n\t\t}\n//\t\tSystem.out.println(block);\n\t\treturn block;\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\t\n\t\tn = cin.nextInt();\n\t\tx = cin.nextInt();\n\t\ty = cin.nextInt();\n\t\tc = cin.nextLong();\n\t\t\n\t\tint low = 0, high = 1000000000;\n\t\tint ans = -1;\n\t\twhile(low <= high) { \n\t\t\tint mid = (low + high) / 2;\n//\t\t\tSystem.out.println(mid + \" \" + f(mid));\n\t\t\tif(f(mid) >= c) {\n\t\t\t\tans = mid;\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "import java.io.*;\nimport java.util.List;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Problem {\n\t\n\tpublic static Pair solve(Forest f, List<Pair> queue){\n\t\tPair current = null, next = null;\n\t\tint index = 0;\n\t\twhile(queue.size() > 0){\n\t\t\tcurrent = queue.remove(0);\n\t\t\tindex = f.desk[current.x][current.y];\n\t\t\t\tif(current.x>0){\n\t\t\t\t\tnext = new Pair(current.x-1,current.y);\n\t\t\t\t\tif(f.desk[next.x][next.y]==0){\n\t\t\t\t\t\tf.desk[next.x][next.y] = index+1;\n\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(current.x<f.N-1){\n\t\t\t\t\tnext = new Pair(current.x+1,current.y);\n\t\t\t\t\tif(f.desk[next.x][next.y]==0){\n\t\t\t\t\t\tf.desk[next.x][next.y] = index+1;\n\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(current.y>0){\n\t\t\t\t\tnext = new Pair(current.x,current.y-1);\n\t\t\t\t\tif(f.desk[next.x][next.y]==0){\n\t\t\t\t\t\tf.desk[next.x][next.y] = index+1;\n\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(current.y<f.M-1){\n\t\t\t\t\tnext = new Pair(current.x,current.y+1);\n\t\t\t\t\tif(f.desk[next.x][next.y]==0){\n\t\t\t\t\t\tf.desk[next.x][next.y] = index+1;\n\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn f.findMax();\n\t}\n\n\tpublic static void main(String[] args){\n\t\tString buffer = null;\n\t\tStringTokenizer st = null;\n\t\tForest f = null;\n\t\tList<Pair> pairs = new LinkedList<Pair>();\n\t\tInteger N,M,K,x,y;\n\t\ttry {\n\t\t\tBufferedReader in = new BufferedReader(\n\t\t\t\t\t\t\tnew FileReader(\"input.txt\")\n\t\t\t\t\t\t\t);\n\t\t\tFileWriter out = new FileWriter(\"output.txt\");\n\t\t\tbuffer = in.readLine();\n\t\t\tst = new StringTokenizer(buffer);\n\t\t\tN = new Integer(st.nextToken());\n\t\t\tM = new Integer(st.nextToken());\n\t\t\tf = new Forest(N,M);\n\t\t\tbuffer = in.readLine();\n\t\t\tst = new StringTokenizer(buffer);\n\t\t\tK = new Integer(st.nextToken());\n\t\t\tbuffer = in.readLine();\n\t\t\tst = new StringTokenizer(buffer);\n\t\t\tfor(int i = 0; i<K; i++){\n\t\t\t\tx = new Integer(st.nextToken());\n\t\t\t\ty = new Integer(st.nextToken());\n\t\t\t\tf.desk[x-1][y-1] = 1;\n\t\t\t\tpairs.add(new Pair(x-1,y-1));\n\t\t\t}\n\t\t\tPair res = solve(f,pairs);\n\t\t\t\n\t\t\tout.write(res.toString());\n\t\t\tout.flush();\n\t\t} catch (Exception e) {\n\t\t}\n\t}\n}\n\nclass Pair {\n\tpublic Pair(int i, int j){\n\t\tx = i;\n\t\ty = j;\n\t}\n\tpublic String toString(){\n\t\treturn (x+1) + \" \" + (y+1);\n\t}\n\tpublic int x;\n\tpublic int y;\n}\n\nclass Forest {\n\tpublic Forest(int n, int m){\n\t\tN = n;\n\t\tM = m;\n\t\tdesk = new int[N][M];\n\t}\n\n\tpublic Pair findMax(){\n\t\tPair max = new Pair(0,0);\n\t\tfor(int i = 0; i<N; i++){\n\t\t\tfor(int j = 0; j<M; j++){\n\t\t\t\tif(desk[i][j]>desk[max.x][max.y]){\n\t\t\t\t\tmax.x = i;\n\t\t\t\t\tmax.y = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\t\n\n\tpublic int N;\n\tpublic int M;\n\tpublic int[][] desk;\n}\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n744444444747477777774\n44444447474747777777\n */\n\n/**\n *\n * @author Andy Phan\n */\npublic class b {\n    public static void main(String[] args) {\n        FS in = new FS(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int n = in.nextInt();\n        Integer[] arr = new Integer[n];\n        int numZ = 0;\n        for(int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n            if(arr[i] == 0) numZ++;\n        }\n        \n        Arrays.sort(arr);\n        \n        \n        if(numZ > 1) {\n            System.out.println(\"cslnb\");\n            return;\n        }\n        int numDup = 0;\n        int[] arr2 = new int[n];\n        for(int i = 0; i < n; i++) {\n            arr2[i] = arr[i];\n            if(i != 0) {\n                if(arr2[i] == arr2[i-1]) {\n                    arr2[i-1]--;\n                    numDup++;\n                }\n            }\n        }\n        \n        if(numDup > 1) {\n            System.out.println(\"cslnb\");\n            return;\n        }\n        \n        \n        for(int i = 0; i < n; i++) {\n            if(i != 0) {\n                if(arr2[i] == arr2[i-1]) {\n                    System.out.println(\"cslnb\");\n                    return;\n                }\n            }\n        }\n        long num = 0;\n        if(numDup == 1) num++;\n        for(int i = 0; i < n; i++) {\n            num += arr2[i]-i;\n        }\n        \n        if(num%2 == 0) {\n            System.out.println(\"cslnb\");\n        } else {\n            System.out.println(\"sjfnb\");\n        }\n        \n\n        out.close();\n    }\n    \n    static class FS {\n\n        BufferedReader in;\n        StringTokenizer token;\n        \n        public FS(InputStream str) {\n            in = new BufferedReader(new InputStreamReader(str));\n        }\n        \n        public String next() {\n            if (token == null || !token.hasMoreElements()) {\n                try {\n                    token = new StringTokenizer(in.readLine());\n                } catch (IOException ex) {\n                }\n                return next();\n            }\n            return token.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n", "complexity": "linear", "problem": "1191_D", "from": "CODEFORCES", "tags": "games"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.lang.*;\n\npublic class Main {\n    //public static int max = -1;\n\tpublic static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int a[] = sc.nextIntArray(3);\n        sort(a);\n        if(a[0]==1)\n        {\n            System.out.println(\"YES\");\n        }\n        else if(a[1]==2 && a[0]==2)\n        {\n            System.out.println(\"YES\");\n        }\n        else if(a[0]==3 && a[1]==3 && a[2]==3)\n        {\n            System.out.println(\"YES\");\n        }\n        else if(a[0]==2 && a[1]==4 && a[2]==4)\n        {\n            System.out.println(\"YES\");\n        }\n        else\n        {\n            System.out.println(\"NO\");\n        }\n    }\n    \n    \n    \n    public static int sum(int a[])\n    {\n        int sum=0;\n        for(int i: a) sum=sum+i;\n        return sum;\n    }\n    \n  \n    public static int getMax(int a[])\n    {\n        int m=Integer.MIN_VALUE;\n        for(int i: a) m=Math.max(i,m);\n        return m;\n    }\n    \n    static class Pair\n    {\n        int x;\n        int y;\n\n        //int i;\n        public Pair(int x, int  y)\n        {\n            this.x=x;\n            this.y=y;\n        }\n    }\n    static class Comp implements Comparator<Pair>\n    {\n        public int compare(Pair p1, Pair p2)\n        {\n            return p1.x-p2.x;\n        }\n    }\n    public static int bs(long num[], long x)\n    {\n        int low=0;\n        int high=num.length-1;\n        int ans=-1;\n        while(low<=high)\n        {\n            int mid = low + (high-low)/2;\n            if(num[mid]==x)\n            {\n                ans = mid;\n                high=mid-1;\n            }\n            else if(num[mid]<x)\n            {\n               // ans=mid;\n                low=mid+1;\n            }\n            else\n            {\n                ans=mid;\n                high=mid-1;\n            }\n        }\n        return ans;\n    }\n    \n    \n    public static int partition(int arr[], int low, int high) \n    { \n        int pivot = arr[high];  \n        int i = (low-1);\n        for (int j=low; j<high; j++) \n        { \n            if (arr[j] < pivot) \n            { \n                i++; \n                int temp = arr[i]; \n                arr[i] = arr[j]; \n                arr[j] = temp; \n            } \n        } \n        int temp = arr[i+1]; \n        arr[i+1] = arr[high]; \n        arr[high] = temp; \n  \n        return i+1; \n    } \n    public static void sort(int arr[], int low, int high) \n    { \n        if (low < high) \n        { \n            int pi = partition(arr, low, high); \n            sort(arr, low, pi-1); \n            sort(arr, pi+1, high); \n        } \n    } \n    \n    \n    \n    \n    \n    \n    static int gcd(int a,int b)\n    {\n        if(b==0) return a;\n        return gcd(b,a%b);\n    }\n    \n    \n    static void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n    static void sort(long[] a) {\n\t\tArrayList<Long> l=new ArrayList<>();\n\t\tfor (long i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n \n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n \n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (final IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (final IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tint[] nextIntArray(final int n) {\n\t\t\tfinal int a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = Integer.parseInt(next());\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t}\t\n}\n//private ArrayList<String[]> action = new ArrayList<String[]>();\n\n\n//Templates for Comparator and Classes - @jagrit_07\n/*\nArrays.sort(newEmployees, new Comparator<Employee>() {\n    @Override\n    public int compare(Employee emp1, Employee emp2) {\n        return emp1.getName().compareTo(emp2.getName());\n    }\n});\nclass Pair\n\t{\n\t\t\n\t\tlong i; //index;\n\t\tlong l; //left;\n\t\tlong c; //cost;\n\t\tpublic Pair(long x,long y,long z)\n\t\t{\n\t\t\tthis.i=x;\n\t\t\tthis.l=y;\n\t\t\tthis.c=z;\n\t\t}\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn this.i+\" \"+this.l+\" \"+this.c;\n\t\t}\n\t}\nclass Comp implements Comparator<Pair>\n\t{\n\t\tpublic int compare(Pair p1, Pair p2)\n\t\t{\n\t\t\tif(p1.c!=p2.c)\n\t\t\t{\n\t\t\t\treturn (int)(p1.c-p2.c); //sort acc to cost;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn (int)(p1.i-p2.i); //sort acc to index;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n*/\n\n/*\n  HashMap - Put template - d.put(a1,d.getOrDefault(a1,0)+1);\n  for (Map.Entry<String, Integer> entry : map.entrySet()) {\n        System.out.println(entry.getKey() + \":\" + entry.getValue());\n    }\n  Deque<String> deque \n            = new LinkedList<String>();  \n            \n  List<Integer> c[] = new ArrayList[3];          \n*/", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.*;\n\npublic class Main {\n\n    static int N;\n    static int [][] dp;\n    static int M = (int)(1e9 + 7);\n    static ArrayList<Integer> l;\n\n    static int f(int idx, int b) {\n        if(idx == l.size())\n            return 1;\n        if(dp[idx][b] != -1)\n            return dp[idx][b];\n        long ret = f(idx + 1, b + l.get(idx));\n        if(b > 0)\n            ret += f(idx, b - 1);\n        return dp[idx][b] = (int) (ret % M);\n    }\n\n    public static void main(String[] args) throws IOException{\n\t    Scanner sc = new Scanner();\n\t    N = sc.nextInt();\n        int [] val = new int[N];\n        for(int i = 0; i < N; ++i)\n            if(sc.next().charAt(0) == 's')\n                val[i] = 0;\n            else\n                val[i] = 1;\n        l = new ArrayList<Integer>();\n        l.add(val[0]);\n\n        for(int i = 1; i < N; ++i)\n            if(val[i] == val[i - 1] && val[i] == 1) {\n                int prev = l.get(l.size() - 1);\n                l.set(l.size() - 1, ++prev);\n            } else if(val[i - 1] == 0){\n                l.add(val[i]);\n            }\n\n//        System.out.println(l);\n        dp = new int[l.size() + 1][N + 1];\n        for(int i = 0; i <= l.size(); ++i)\n            Arrays.fill(dp[i], -1);\n        System.out.println(f(0, 0));\n\n    }\n\n\n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n    }\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "\nimport java.io.*;\nimport java.util.*;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    long b = 31;\n    String fileName = \"\";\n\n\n    //////////////////////    SOLUTION   SOLUTION  SOLUTION    //////////////////////////////\n    int INF = Integer.MAX_VALUE / 10;\n    long MODULO = 1000*1000*100;\n    int MAX_VALUE = 1000*1000;\n    void solve() throws IOException {\n        long l = readLong();\n        long r = readLong();\n        boolean flag = false;\n        long ans = 0;\n        int bit = 63;\n        while(checkBit(l, bit) == checkBit(r, bit)&&bit>=0) bit--;\n        if (bit==-1) out.println(0);\n        else out.println((1l<<(bit+1))-1);\n    }\n\n\n    class Number implements Comparable<Number>{\n        int x, cost;\n        Number(int x, int cost){\n            this.x = x;\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(Number o) {\n            return Integer.compare(this.cost, o.cost);\n        }\n    }\n    class Point{\n        int x, y;\n        Point(int x, int y){\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    class Vertex implements Comparable<Vertex>{\n        int num, depth, e, c;\n        Vertex(int num, int depth, int e, int c){\n            this.num = num;\n            this.e = e;\n            this.depth = depth;\n            this.c = c;\n        }\n\n        @Override\n        public int compareTo(Vertex o) {\n            return Integer.compare(this.e, o.e);\n        }\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////\n\n    class Edge{\n        int from, to, num;\n        Edge(int to, int num){\n            this.to = to;\n            this.num = num;\n        }\n    }\n\n    class SparseTable{\n        int[][] rmq;\n        int[] logTable;\n        int n;\n        SparseTable(int[] a){\n            n = a.length;\n            logTable = new int[n+1];\n            for(int i = 2; i <= n; ++i){\n                logTable[i] = logTable[i >> 1] + 1;\n            }\n            rmq = new int[logTable[n] + 1][n];\n            for(int i=0; i<n; ++i){\n                rmq[0][i] = a[i];\n            }\n\n            for(int k=1; (1 << k) < n; ++k){\n                for(int i=0; i + (1 << k) <= n; ++i){\n                    int max1 = rmq[k - 1][i];\n                    int max2 = rmq[k-1][i + (1 << (k-1))];\n                    rmq[k][i] = Math.max(max1, max2);\n                }\n            }\n        }\n\n        int max(int l, int r){\n            int k = logTable[r - l];\n            int max1 = rmq[k][l];\n            int max2 = rmq[k][r - (1 << k) + 1];\n            return Math.max(max1, max2);\n        }\n    }\n    long checkBit(long mask, int bit){\n        return (mask >> bit) & 1;\n    }\n    class Dsu{\n        int[] parent;\n        int countSets;\n        Dsu(int n){\n            countSets = n;\n            parent = new int[n];\n            for(int i=0; i<n; ++i){\n                parent[i] = i;\n            }\n        }\n        int findSet(int a){\n            if(parent[a] == a) return a;\n            parent[a] = findSet(parent[a]);\n            return parent[a];\n        }\n        void unionSets(int a, int b){\n            a = findSet(a);\n            b = findSet(b);\n            if(a!=b){\n                countSets--;\n                parent[a] = b;\n            }\n        }\n    }\n    static int checkBit(int mask, int bit) {\n        return (mask >> bit) & 1;\n    }\n    boolean isLower(char c){\n        return c >= 'a' && c <= 'z';\n    }\n\n    ////////////////////////////////////////////////////////////\n\n    class SegmentTree{\n        int[] t;\n        int n;\n        SegmentTree(int n){\n            t = new int[4*n];\n            build(new int[n+1], 1, 1, n);\n        }\n        void build (int a[], int v, int tl, int tr) {\n            if (tl == tr)\n                t[v] = a[tl];\n            else {\n                int tm = (tl + tr) / 2;\n                build (a, v*2, tl, tm);\n                build (a, v*2+1, tm+1, tr);\n            }\n        }\n\n        void update (int v, int tl, int tr, int l, int r, int add) {\n            if (l > r)\n                return;\n            if (l == tl && tr == r)\n                t[v] += add;\n            else {\n                int tm = (tl + tr) / 2;\n                update (v*2, tl, tm, l, Math.min(r,tm), add);\n                update (v*2+1, tm+1, tr, Math.max(l,tm+1), r, add);\n            }\n        }\n\n        int get (int v, int tl, int tr, int pos) {\n            if (tl == tr)\n                return t[v];\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                return t[v] + get (v*2, tl, tm, pos);\n            else\n                return t[v] + get (v*2+1, tm+1, tr, pos);\n        }\n    }\n    class Fenwik {\n        long[] t;\n        int length;\n\n        Fenwik(int[] a) {\n            length = a.length + 100;\n            t = new long[length];\n\n            for (int i = 0; i < a.length; ++i) {\n                inc(i, a[i]);\n            }\n        }\n\n        void inc(int ind, int delta) {\n            for (; ind < length; ind = ind | (ind + 1)) {\n                t[ind] = Math.max(delta, t[ind]);\n            }\n        }\n\n        long getMax(int r) {\n            long sum = 0;\n            for (; r >= 0; r = (r & (r + 1)) - 1) {\n                sum = Math.max(sum, t[r]);\n            }\n            return sum;\n        }\n    }\n    int gcd(int a, int b){\n        return b == 0 ? a : gcd(b, a%b);\n    }\n    long gcd(long a, long b){\n        return b == 0 ? a : gcd(b, a%b);\n    }\n    long binPow(long a, long b, long m) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b % 2 == 1) {\n            return ((a % m) * (binPow(a, b - 1, m) % m)) % m;\n        } else {\n            long c = binPow(a, b / 2, m);\n            return (c * c) % m;\n        }\n\n    }\n    int minInt(int... values) {\n        int min = Integer.MAX_VALUE;\n        for (int value : values) min = Math.min(min, value);\n        return min;\n    }\n\n    int maxInt(int... values) {\n        int max = Integer.MIN_VALUE;\n        for (int value : values) max = Math.max(max, value);\n        return max;\n    }\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        // TODO Auto-generated method stub\n        new Main().run();\n    }\n\n    void run() throws NumberFormatException, IOException {\n        solve();\n        out.close();\n    };\n\n    BufferedReader in;\n    PrintWriter out;\n\n    StringTokenizer tok;\n    String delim = \" \";\n    Random rnd = new Random();\n\n    Main() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } catch (Exception e) {\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new PrintWriter(fileName + \".out\");\n            }\n\n        }\n        tok = new StringTokenizer(\"\");\n    }\n\n    String readLine() throws IOException {\n        return in.readLine();\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            String nextLine = readLine();\n            if (null == nextLine) {\n                return null;\n            }\n\n            tok = new StringTokenizer(nextLine);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(readString());\n    }\n    byte readByte() throws NumberFormatException, IOException {\n        return Byte.parseByte(readString());\n    }\n    int[] readIntArray (int n) throws NumberFormatException, IOException {\n        int[] a = new int[n];\n        for(int i=0; i<n; ++i){\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    Integer[] readIntegerArray (int n) throws NumberFormatException, IOException {\n        Integer[] a = new Integer[n];\n        for(int i=0; i<n; ++i){\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    long readLong() throws NumberFormatException, IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(readString());\n    }\n}\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int MOD = in.nextInt();\n\n            int[][] C = new int[n + 1][n + 1];\n            C[0][0] = 1;\n            for (int i = 1; i < C.length; i++) {\n                C[i][0] = 1;\n                for (int j = 1; j < C.length; j++) {\n                    C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n                    if (C[i][j] >= MOD) {\n                        C[i][j] -= MOD;\n                    }\n                }\n            }\n\n            int[] p2 = new int[n + 1];\n            p2[0] = 1;\n            for (int i = 1; i < p2.length; i++) {\n                p2[i] = 2 * p2[i - 1] % MOD;\n            }\n\n            int[][] d = new int[n + 1][n + 1];\n            d[0][0] = 1;\n            // Total.\n            for (int i = 1; i <= n; i++) {\n                // Switched on manually.\n                for (int j = 1; j <= i; j++) {\n                    // Switched on manually in the first block.\n                    for (int t = 1; t <= j; t++) {\n                        if (t == i - 1) {\n                            continue;\n                        }\n                        d[i][j] = (int) ((d[i][j] + (long) C[j][t] * p2[t - 1] % MOD * d[i - t - (i == t ? 0 : 1)][j - t]) % MOD);\n                    }\n                }\n            }\n\n            int ans = 0;\n            for (int k = 1; k <= n; k++) {\n                ans += d[n][k];\n                if (ans >= MOD) {\n                    ans -= MOD;\n                }\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.io.BufferedReader;\n\n// import java.io.FileInputStream;\n\n// import java.io.FileOutputStream;\n\nimport java.io.InputStream;\n\nimport java.io.InputStreamReader;\n\nimport java.io.IOException;\n\nimport java.io.PrintWriter;\n\nimport java.util.Arrays;\n\nimport java.util.ArrayList;\n\nimport java.util.Collections;\n\nimport java.util.Random;\n\nimport java.util.StringTokenizer;\n\n\n\nimport static java.lang.Math.*;\n\nimport static java.util.Arrays.copyOf;\n\nimport static java.util.Arrays.fill;\n\nimport static java.util.Arrays.sort;\n\nimport static java.util.Collections.reverseOrder;\n\nimport static java.util.Collections.sort;\n\n\n\npublic class Main {\n\n    private FastScanner in;\n\n    private PrintWriter out;\n\n\n\n    private void solve() throws IOException {\n\n        solveC();\n\n    }\n\n\n\n    private void solveA() throws IOException {\n\n        int x1 = in.nextInt(), y1 = in.nextInt();\n\n        int x2 = in.nextInt(), y2 = in.nextInt();\n\n        int dx = abs(x1 - x2), dy = abs(y1 - y2);\n\n        int x = in.nextInt(), y = in.nextInt();\n\n        out.print((dx % (2 * x) == 0 && dy % (2 * y) == 0) ||\n\n                (dx % (2 * x) == x && dy % (2 * y) == y) ? \"YES\" : \"NO\");\n\n    }\n\n\n\n    private void solveB() throws IOException {\n\n        int n = in.nextInt();\n\n        int[] a = new int[n];\n\n        for (int i = 0; i < n; i++) {\n\n            a[i] = in.nextInt();\n\n        }\n\n\n\n        shuffle(a);\n\n        sort(a);\n\n\n\n        int have = 0;\n\n        for (int i = 0; i < n; i++) {\n\n            if (a[i] == a[2]) {\n\n                have++;\n\n            }\n\n        }\n\n\n\n        long ans = 1;\n\n        for (int i = 0; i < (a[1] == a[2] ? a[0] == a[2] ? 3 : 2 : 1); i++) {\n\n            ans = ans * (have - i) / (i + 1);\n\n        }\n\n        out.print(ans);\n\n    }\n\n\n\n    private void shuffle(int[] a) {\n\n        int b;\n\n        Random r = new Random();\n\n        for (int i = a.length - 1, j; i > 0; i--) {\n\n            j = r.nextInt(i + 1);\n\n            b = a[j];\n\n            a[j] = a[i];\n\n            a[i] = b;\n\n        }\n\n    }\n\n\n\n    private void solveC() throws IOException {\n\n        long n = in.nextLong(), s = in.nextLong();\n\n        long l = 0, mid, r = Long.MAX_VALUE / 2;\n\n        while (l + 1 < r) {\n\n            mid = (l + r) / 2;\n\n            if (mid - sum(mid) >= s)\n\n                r = mid;\n\n            else\n\n                l = mid;\n\n        }\n\n        out.print(max(0, n - r + 1));\n\n    }\n\n\n\n    private long sum(long n) {\n\n        long sum = 0;\n\n        for (char c : Long.toString(n).toCharArray())\n\n            sum += c - '0';\n\n        return sum;\n\n    }\n\n\n\n    private void solveD() throws IOException {\n\n\n\n    }\n\n\n\n    private void solveE() throws IOException {\n\n\n\n    }\n\n\n\n    private void solveF() throws IOException {\n\n\n\n    }\n\n\n\n    class FastScanner {\n\n        StringTokenizer st;\n\n        BufferedReader br;\n\n\n\n        FastScanner(InputStream s) {\n\n            br = new BufferedReader(new InputStreamReader(s));\n\n        }\n\n\n\n        String next() throws IOException {\n\n            while (st == null || !st.hasMoreTokens())\n\n                st = new StringTokenizer(br.readLine());\n\n            return st.nextToken();\n\n        }\n\n\n\n        boolean hasNext() throws IOException {\n\n            return br.ready() || (st != null && st.hasMoreTokens());\n\n        }\n\n\n\n        int nextInt() throws IOException {\n\n            return Integer.parseInt(next());\n\n        }\n\n\n\n        long nextLong() throws IOException {\n\n            return Long.parseLong(next());\n\n        }\n\n\n\n        double nextDouble() throws IOException {\n\n            return Double.parseDouble(next().replace(',', '.'));\n\n        }\n\n\n\n        String nextLine() throws IOException {\n\n            return br.readLine();\n\n        }\n\n\n\n        boolean hasNextLine() throws IOException {\n\n            return br.ready();\n\n        }\n\n    }\n\n\n\n    private void run() throws IOException {\n\n        in = new FastScanner(System.in); // new FastScanner(new FileInputStream(\".in\"));\n\n        out = new PrintWriter(System.out); // new PrintWriter(new FileOutputStream(\".out\"));\n\n\n\n        solve();\n\n\n\n        out.flush();\n\n        out.close();\n\n    }\n\n\n\n    public static void main(String[] args) throws IOException {\n\n        new Main().run();\n\n    }\n\n}\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.util.Scanner;\n\n\n\npublic class ProblemC {\n\n    public static int sumDigits(long number) {\n\n        int count = 0;\n\n\n\n        while (number > 0) {\n\n            count += number % 10;\n\n            number /= 10;\n\n        }\n\n\n\n        return count;\n\n    }\n\n\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n\n        long n = scanner.nextLong();\n\n        long s = scanner.nextLong();\n\n        long lowerBorder = 1;\n\n        long upperBorder = n;\n\n        long x = (lowerBorder + upperBorder) / 2;\n\n\n\n        while (lowerBorder <= upperBorder) {\n\n            long sumDigits = sumDigits(x);\n\n\n\n            if ((x - sumDigits) >= s) {\n\n                upperBorder = x - 1;\n\n            } else {\n\n                lowerBorder = x + 1;\n\n            }\n\n\n\n            x = (lowerBorder + upperBorder) / 2;\n\n        }\n\n\n\n        System.out.println(n - x);\n\n    }\n\n}", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.util.HashMap;\n\nimport java.util.Map;\n\nimport java.util.Scanner;\n\n\n\npublic class forces {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\n\n\t\tint n = sc.nextInt();\n\n\t\t\n\n\t\twhile (n-- > 0) {\n\n\t\t\tString coor = sc.next();\n\n\t\t\tString str = \"\";\n\n\t\t\tif (coor.matches(\"R[0-9]+C[0-9]+\")) {\n\n\t\t\t\tString temp[] = coor.replaceAll(\"R|C\", \" \").trim().split(\" \");\n\n\t\t\t\tint a = new Integer(temp[1]);\n\n\t\t\t\twhile (a > 0) {\n\n\t\t\t\t\ta--;\n\n\t\t\t\t\tstr = (char)(a%26 + 'A') + str;\n\n\t\t\t\t\ta /= 26;\n\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(str+temp[0]);\n\n\t\t\t} else {\n\n\t\t\t\tString temp1 = coor.replaceAll(\"[0-9]\", \"\");\n\n\t\t\t\tint num = 0;\n\n\t\t\t\tfor(int i = 0; i<temp1.length(); i++) {\n\n\t\t\t\t\tnum = num * 26 + temp1.charAt(i) - 'A' + 1;\n\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(\"R\" + coor.replaceAll(\"[A-Z]\", \"\") + \"C\" + num);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\n\npublic class B1177 {\n\n\tpublic static void main(String[] args) throws Exception {\n//\t\tBufferedReader br = new BufferedReader(new FileReader(\"F:/books/input.txt\"));\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tLong n = Long.parseLong(br.readLine());\n\t\tlong[] p = new long[15];\n\t\tint i;\n\t\tp[0]=1;\n\t\tfor(i=1;i<15;p[i]=p[i-1]*10,i++);\n\t\tfor(i=1;i*p[i-1]*9L<n;n-=i*p[i-1]*9L,i++);\n\t\tn--;\n\t\tint v = (int) (n%i);\n\t\tn/=i;\n\t\tn+=p[i-1];\n\t\tString s = n.toString();\n\t\tSystem.out.println(s.charAt(v));\n\t}\n\n}\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class C {\n\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer st = null;\n\tPrintWriter out;\n\n\tpublic void solution() throws IOException {\n\t\tint n = nextInt();\n\t\tint a[] = new int[n];\n\t\tint b[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(a);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\tif (ans == 2 || ans == 0) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t} else {\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\tif (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(bf.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic void print(int a[]) {\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tSystem.out.print(a[i] + \" \");\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tnew C().solution();\n\t}\n}", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "//      \u3053\u308c\u3092\u7ffb\u8a33\u3057\u3066\u3044\u308b\u9593\u3001\u3042\u306a\u305f\u306f\u3042\u306a\u305f\u306e\u4eba\u751f\u306e\u3044\u304f\u3064\u304b\u306e\u8cb4\u91cd\u306a\u77ac\u9593\u3092\u7121\u99c4\u306b\u3057\u307e\u3057\u305f\n\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Solution {\n    static PrintWriter fop = new PrintWriter(System.out);\n\n    static int counter(String s){\n        int cnt = 0 ;\n        for (int i = 0; i <s.length() ; i++) {\n            if (s.charAt(i) == '(')cnt++ ;\n            else  cnt-- ;\n            if (cnt < 0)return -1 ;\n        }\n        return cnt ;\n\n    }\n\n    static int counter2(String s){\n        int cnt = 0 ;\n     for(int i = s.length()-1 ; i>=0 ; i--){\n         if (s.charAt(i) == ')')cnt++ ;\n         else cnt-- ;\n         if (cnt < 0)return -1 ;\n     }\n     return cnt ;\n\n    }\n\n\n\n\n\n\n    public static void main(String[] args) {\n\n        FastScanner fsca = new FastScanner();\n        int n = fsca.nextInt() ;\n        String a[] = new String[n] ;\n        for (int i = 0; i <n ; i++) {\n            a[i] = fsca.next() ;\n        }\n\n        int dp[] = new int[400009] ;\n        for (int i = 0; i <n ; i++) {\n           int tt = counter(a[i]) ;\n           if (tt != -1)\n               dp[tt]++ ;\n        }\n        long cnt = 0 ;\n        for (int i = 0; i <n ; i++) {\n            int tt = counter2(a[i]) ;\n            if (tt != -1){\n                cnt += dp[tt] ;\n            }\n        }\n        System.out.println(cnt);\n\n\n\n\n\n\n\n\n\n\n\n        fop.flush();\n        fop.close();\n\n\n    }\n    /*-----------------------------------------------------------------------------------------------------------------------------------------------*/\n\n\n    static long gcd(long a, long b) {\n        return (b == 0) ? a : gcd(b, a % b);\n    }\n\n    static int gcd(int a, int b) {\n        return (b == 0) ? a : gcd(b, a % b);\n    }\n\n\n    static final Random random = new Random();\n\n    static void ruffleSort(int[] a) {\n        int n = a.length;//shuffle, then sort\n        for (int i = 0; i < n; i++) {\n            int oi = random.nextInt(n), temp = a[oi];\n            a[oi] = a[i];\n            a[i] = temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSort(long[] a) {\n        int n = a.length;//shuffle, then sort\n        for (int i = 0; i < n; i++) {\n            int oi = random.nextInt(n);\n            long temp = a[oi];\n            a[oi] = a[i];\n            a[i] = temp;\n        }\n        Arrays.sort(a);\n    }\n\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[][] readMat(int n, int m) {\n            int a[][] = new int[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    a[i][j] = nextInt();\n            return a;\n        }\n\n        char[][] readCharMat(int n, int m) {\n            char a[][] = new char[n][m];\n            for (int i = 0; i < n; i++) {\n                String s = next();\n                for (int j = 0; j < m; j++)\n                    a[i][j] = s.charAt(j);\n            }\n            return a;\n        }\n\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n    static void print(int a[], int n) {\n        for (int i = 0; i < n; i++)\n            fop.append((a[i]) + \" \");\n        // fop.append(\"\\n\") ;\n    }\n\n    static void print(long a[], int n) {\n        for (int i = 0; i < n; i++)\n            fop.append((a[i]) + \" \");\n        // fop.append(\"\\n\") ;\n    }\n}\n        ", "complexity": "linear", "problem": "0990_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.*;\n\n\n\n\n\n\n\n\n\n\n\npublic class JavaApplication1 {\n\n\n\n  \n\n    public static void main(String[] args) throws Exception {\n\n        Scanner input=new Scanner(System.in);\n\n      int n=input.nextInt();\n\n   int m=input.nextInt();\n\n       \n\n     double formula= m% Math.pow(2, n);\n\n        \n\n      \n\n      \n\n\n\n       \n\n          \n\n         \n\n        System.out.println((long)formula);\n\n        }\n\n}", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport static java.lang.System.out;\n\npublic class Flatville\n{\n    public static void main( String args[] )\n    {\n        class SquareHouse implements Comparable<SquareHouse>\n        {\n            public SquareHouse( double posLeft, double sideLen )\n            { \n                _posLeft = posLeft;\n                _sideLen = sideLen;\n            }\n\n            public double posLeft()\n            { return _posLeft; }\n\n            public double posRight()\n            { return _posLeft + _sideLen; }\n\n            public int compareTo( SquareHouse house )\n            {\n                double dist = _posLeft - house.posLeft();\n                if ( dist < 0 )\n                    return -1;\n                else if ( dist > 0 )\n                    return 1;\n                else return 0;\n            }\n\n            private double _posLeft;\n            private double _sideLen;\n        }\n\n        Scanner scanner = new Scanner( System.in );\n\n        // Read the header\n        final int nHouses    = scanner.nextInt();\n        final double sideLen = scanner.nextDouble();\n\n        ArrayList<SquareHouse> houses = new ArrayList<SquareHouse>();\n\n        // Read the houses\n        for ( int iHouse = 0; iHouse < nHouses; ++iHouse )\n        {\n            double pos  = scanner.nextDouble();\n            double size = scanner.nextDouble();\n            double posLeft = pos - size / 2.0;\n            houses.add( new SquareHouse( posLeft, size ) );\n        }\n\n        // Sort the houses\n        Collections.sort( houses );\n\n        int nPositions = 2;\n        for ( int iHouse = 0; iHouse < nHouses - 1; ++iHouse )\n        {\n            double space = houses.get( iHouse + 1 ).posLeft() - houses.get( iHouse ).posRight();\n            if ( sideLen < space )\n                nPositions += 2;\n            else if ( sideLen == space )\n                nPositions++;\n        }\n\n        out.println( nPositions );\n    }\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.math.BigDecimal;\nimport java.util.*;\nimport java.math.BigInteger;\npublic class Main {\n    static Long[] a = new Long[205000];\n    static Long[] postfix=new Long[205000];\n    static HashMap<Long,Long> check=new HashMap<Long,Long>();\n    public static void main(String args[]) {\n        Scanner cin = new Scanner(System.in);\n        long k, j, p,sum,equal,bigone,lessone,cnt;\n        BigInteger ans;\n        int i,n;\n        while (cin.hasNext()) {\n            n=cin.nextInt();\n            check.clear();\n            for(i=1;i<=n;i++)\n            {\n                a[i]=cin.nextLong();\n            }\n            postfix[n+1]=0L;\n            for(i=n;i>=1;i--) {\n                postfix[i] = postfix[i + 1] + a[i];\n                if (check.containsKey(a[i]) == true) {\n                    Long v = check.get(a[i]);\n                    v += 1;\n                    check.put(a[i], v);\n                }\n                else\n                    check.put(a[i],1L);\n            }\n            ans=BigInteger.ZERO;\n            for(i=1;i<n;i++){\n                Long v=check.get(a[i]);\n                v--;\n                check.put(a[i],v);\n                equal=check.get(a[i]);\n                bigone=0L;\n                lessone=0L;\n                if(check.containsKey(a[i]+1L)==true)\n                bigone=check.get(a[i]+1L);\n                if(check.containsKey(a[i]-1L)==true)\n                lessone=check.get(a[i]-1L);\n                sum=postfix[i]-bigone*(a[i]+1L)-lessone*(a[i]-1L)-equal*a[i]-a[i];\n                cnt=n-i-bigone-lessone-equal;\n                ans=ans.add(BigInteger.valueOf(a[i]*cnt).subtract(BigInteger.valueOf(sum)));\n            }\n            System.out.println(ans.multiply(BigInteger.valueOf(-1)));\n        }\n    }\n}", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.io.*;\npublic class Main {\n\tpublic static class node implements Comparable<node> {\n\t\tint l,r;\n\t\tnode(){}\n\t\tnode(int l,int r) {\n\t\t\tthis.l=l;\n\t\t\tthis.r=r;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(node rhs) {\n\t\t\treturn r-rhs.r;\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tStringTokenizer sa=new StringTokenizer(in.readLine());\n\t\tint n=Integer.parseInt(sa.nextToken());\n\t\tsa=new StringTokenizer(in.readLine());\n\t\tint[] a=new int[n];\n\t\tTreeMap<Integer,ArrayList<node>> mp=new TreeMap();\n\t\tfor (int i=0;i<n;++i) a[i]=Integer.parseInt(sa.nextToken());\n\t\tArrayList<node> ans=new ArrayList<node>();\n\t\tfor (int i=0;i<n;++i) {\n\t\t\tint tmp=0;\n\t\t\tfor (int j=i;j<n;++j) {\n\t\t\t\ttmp+=a[j];\n\t\t\t\tif (!mp.containsKey(tmp)) {\n\t\t\t\t\tArrayList<node> t=new ArrayList();\n\t\t\t\t\tt.add(new node(i,j));\n\t\t\t\t\tmp.put(tmp,t);\n\t\t\t\t} else {\n\t\t\t\t\tArrayList<node> t=mp.get(tmp);\n\t\t\t\t\tint left=0,right=t.size()-1,res=t.size();\n\t\t\t\t\twhile (left<=right) {\n\t\t\t\t\t\tint mid=(left+right)>>1;\n\t\t\t\t\t\tif (t.get(mid).r>=i) {\n\t\t\t\t\t\t\tres=mid;\n\t\t\t\t\t\t\tright=mid-1;\n\t\t\t\t\t\t} else left=mid+1;\n\t\t\t\t\t}\n\t\t\t\t\tif (res==t.size()) t.add(new node(i,j));\n\t\t\t\t\telse if (t.get(res).r>j) t.set(res,new node(i,j));\n\t\t\t\t}\n\t\t\t\tif (mp.get(tmp).size()>ans.size()) ans=mp.get(tmp);\n\t\t\t}\n\t\t}\n\t\tout.println(ans.size());\n\t\tfor (int i=0;i<ans.size();++i)\n\t\t\tout.printf(\"%d %d\\n\",ans.get(i).l+1,ans.get(i).r+1);\n\t\tout.flush();\n\t}\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\n\npublic class BankAccount {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString s = in.readLine();\n\t\tint n = Integer.parseInt(s);\n\n\t\tif (s.charAt(0) == '-')\n\t\t\tif (Integer.parseInt(s.substring(0, s.length()-1))>Integer.parseInt(s.substring(0, s.length()-2)+s.charAt(s.length()-1)))\n\t\t\t\ts=s.substring(0, s.length()-1);\n\t\t\telse\n\t\t\t\ts=s.substring(0, s.length()-2)+s.charAt(s.length()-1);\n\n\t\tSystem.out.println(Integer.parseInt(s));\n\t\tin.close();\n\t}\n\n}\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * 111118315581\n *\n * @author pttrung\n */\npublic class C {\n\n    static Point hand;\n    static int n;\n    static Point[] data;\n    static int[] next;\n    static int[] dp;\n    static int[][] pre;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n        // System.out.println(1 << 24);\n        hand = new Point(in.nextInt(), in.nextInt());\n        n = in.nextInt();\n        data = new Point[n];\n        for (int i = 0; i < n; i++) {\n            data[i] = new Point(in.nextInt(), in.nextInt());\n        }\n        pre = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                pre[i][j] = distance(data[i], data[j]);\n            }\n        }\n\n\n        next = new int[1 << n];\n        dp = new int[1 << n];\n        Arrays.fill(dp, -1);\n\n        out.println(cal(0));\n\n\n        int start = 0;\n\n        do {\n            int m = next[start];\n            int val = m - start;\n            out.print(0 + \" \");\n            for (int i = 0; i < n; i++) {\n                if (((1 << i) & val) != 0) {\n                    out.print((i + 1) + \" \");\n                }\n            }\n            // out.print(0 + \" \")  ;\n            start = m;\n        } while (start != (1 << n) - 1);\n        out.println(0);\n        out.close();\n    }\n\n    public static int cal(int mask) {\n        if ((1 << n) - 1 == mask) {\n            //  System.out.println(mask);\n            return 0;\n        }\n        if (dp[mask] != -1) {\n            return dp[mask];\n        }\n        int result = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            if (((1 << i) & mask) == 0) {\n                int dist = distance(hand, data[i]);\n              \n                for (int j = i + 1; j < n; j++) {\n                    if (((1 << j) & mask) == 0) {\n                        //System.out.println(i + \" \" + j);\n                        int temp = dist + distance(hand, data[j]) + pre[i][j] + cal(mask | (1 << i) | (1 << j));\n                        //System.out.println(temp);\n                        if (temp < result) {\n                            result = temp;\n                            next[mask] = (mask | (1 << i) | (1 << j));\n                        }\n                        \n                    }\n                }\n             \n                    int temp = 2 * dist + cal(mask | (1 << i));\n                    if (temp < result) {\n                        result = temp;\n                        next[mask] = (mask | (1 << i));\n                    }\n             \n                break;\n            }\n\n        }\n        dp[mask] = result;\n        return result;\n    }\n\n    static int distance(Point a, Point b) {\n        int total = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n        return total;\n    }\n\n    static class Point {\n\n        int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n\n        }\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() {\n            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() {\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\npublic class ElevatorOrStairs {\n\n\tprivate static final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final OutputStreamWriter writer = new OutputStreamWriter(System.out);\n\t\n\tpublic static void main(String...strings) throws Exception {\n\t\tString[] specs = reader.readLine().split(\" \");\n\t\t\n\t\tint x = Integer.parseInt(specs[0]);\n\t\tint y = Integer.parseInt(specs[1]);\n\t\tint z = Integer.parseInt(specs[2]);\n\t\tint t1 = Integer.parseInt(specs[3]);\n\t\tint t2 = Integer.parseInt(specs[4]);\n\t\tint t3 = Integer.parseInt(specs[5]);\n\t\t\n\t\treader.close();\n\t\tString ans = solve(x, y, z, t1, t2, t3);\n\t\twriter.append(ans);\n\t\twriter.flush();\n\t\twriter.close();\n\t}\n\t\n\tprivate static String solve(int x, int y, int z, int t1, int t2, int t3) {\n\t\tint time_using_stairs = Math.abs(x - y) * t1;\n\t\tint elevator_time_between_floor = Math.abs(x - z) * t2;\n\t\tint elevator_from_z_to_x = elevator_time_between_floor + 2*t3;\n\t\t\n \t\tint time_using_elevator = elevator_from_z_to_x + (Math.abs(x - y) * t2) + t3;\n \t\t\n \t\tif(time_using_elevator <= time_using_stairs) {\n \t\t\treturn \"YES\";\n \t\t}\n \t\treturn \"NO\";\n\t}\n}", "complexity": "constant", "problem": "1054_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int t = in.readInt();\n            while (t-- > 0) {\n                int[] a = new int[]{in.readInt(), in.readInt()};\n                Arrays.sort(a);\n                int ans = 0;\n                while (a[0] > 0) {\n                    int x = a[1] / a[0];\n                    ans += x;\n                    a[1] -= a[0] * x;\n                    Arrays.sort(a);\n                }\n                out.println(ans);\n\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;import java.io.*;import java.math.*;\npublic class Main\n{\n    static int[][] l,r,u,d;\n    static int[][][]dist;\n    static int inf=Integer.MAX_VALUE;\n    static class Node{\n        int x,y,len,dis;\n        Node(int x,int y,int len,int dis){\n            this.x=x;this.y=y;this.len=len;this.dis=dis;\n        }\n    }\n    public static void process()throws IOException\n    {\n        int n=ni();\n        int m=ni();\n        int k=ni();\n        dist=new int[n][m][k/2+1];\n        l=new int[n][m];\n        r=new int[n][m];\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m-1;j++)\n                l[i][j]=r[i][j+1]=ni();\n        u=new int[n][m];\n        d=new int[n][m];\n        for(int i=0;i<n-1;i++)\n            for(int j=0;j<m;j++)\n                d[i][j]=u[i+1][j]=ni();\n        if(k%2==1)\n        {\n            for(int i=0;i<n;i++)\n            {\n                for(int j=0;j<m;j++)\n                    p(\"-1 \");\n                pn(\"\");\n            }\n            return;\n        }\n        k/=2;\n        for(int kk=1;kk<=k;kk++)\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                dist[i][j][kk]=inf;\n                if(i!=0)\n                    dist[i][j][kk]=Math.min(dist[i][j][kk],dist[i-1][j][kk-1]+u[i][j]);\n                if(i!=n-1)\n                    dist[i][j][kk]=Math.min(dist[i][j][kk],dist[i+1][j][kk-1]+d[i][j]);\n                if(j!=0)\n                    dist[i][j][kk]=Math.min(dist[i][j][kk],dist[i][j-1][kk-1]+r[i][j]);\n                if(j!=m-1)\n                    dist[i][j][kk]=Math.min(dist[i][j][kk],dist[i][j+1][kk-1]+l[i][j]);\n            }\n        }\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n                p(2*dist[i][j][k]+\" \");\n            pn(\"\");\n        }\n\n    }\n    static AnotherReader sc;\n    static PrintWriter out;\n    public static void main(String[]args)throws IOException\n    {\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        if(oj){sc=new AnotherReader();out=new PrintWriter(System.out);}\n        else{sc=new AnotherReader(100);out=new PrintWriter(\"output.txt\");}\n        int t=1;\n       // t=ni();\n        while(t-->0) {process();}\n        out.flush();out.close();  \n    }\n\n    static void pn(Object o){out.println(o);}\n    static void p(Object o){out.print(o);}\n    static void pni(Object o){out.println(o);out.flush();}\n    static int ni()throws IOException{return sc.nextInt();}\n    static long nl()throws IOException{return sc.nextLong();}\n    static double nd()throws IOException{return sc.nextDouble();}\n    static String nln()throws IOException{return sc.nextLine();}\n    static int[] nai(int N)throws IOException{int[]A=new int[N];for(int i=0;i!=N;i++){A[i]=ni();}return A;}\n    static long[] nal(int N)throws IOException{long[]A=new long[N];for(int i=0;i!=N;i++){A[i]=nl();}return A;}\n    static long gcd(long a, long b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int gcd(int a, int b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int bit(long n)throws IOException{return (n==0)?0:(1+bit(n&(n-1)));}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    static class AnotherReader{BufferedReader br; StringTokenizer st;\n    AnotherReader()throws FileNotFoundException{\n    br=new BufferedReader(new InputStreamReader(System.in));}\n    AnotherReader(int a)throws FileNotFoundException{\n    br = new BufferedReader(new FileReader(\"input.txt\"));}\n    String next()throws IOException{\n    while (st == null || !st.hasMoreElements()) {try{\n    st = new StringTokenizer(br.readLine());}\n    catch (IOException  e){ e.printStackTrace(); }}\n    return st.nextToken(); } int nextInt() throws IOException{\n    return Integer.parseInt(next());}\n    long nextLong() throws IOException\n    {return Long.parseLong(next());}\n    double nextDouble()throws IOException { return Double.parseDouble(next()); }\n    String nextLine() throws IOException{ String str = \"\"; try{\n    str = br.readLine();} catch (IOException e){\n    e.printStackTrace();} return str;}}\n   \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class A {\n\n    int INF = 1 << 28;\n\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        long[] chores = new long[n];\n        for(int i=0;i<n;i++) chores[i] = sc.nextLong();\n        sort(chores);\n        System.out.println(chores[b]-chores[b-1]);\n    }\n\n    public static void main(String[] args) {\n        new A().run();\n    }\n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class Test {\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n  static int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static String readLine() {\n    StringBuilder b = new StringBuilder();\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          b.append((char) c);\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return b.toString();\n  }\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  void start() {\n    int t = readInt();\n    while (t-- > 0) {\n      int n = readInt(), m = readInt();\n      int[][] a = new int[n][m];\n      for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n          a[i][j] = readInt();\n      int[] dp = new int[1<<n];\n      Arrays.fill(dp, -1);\n      dp[0] = 0;\n      for (int c = 0; c < m; c++) {\n        for (int i = (1 << n) - 1; i >= 0; i--) {\n          int u = (1 << n) - 1 - i;\n          int p = u;\n          if (dp[i] >= 0)\n            while (p > 0) {\n              for (int r = 0; r < n; r++) {\n                  int sum = 0;\n                  for (int j = 0; j < n; j++) if (((p >> j) & 1) != 0) sum += a[(j + r) % n][c];\n                  dp[i | p] = Math.max(dp[i | p], dp[i] + sum);\n                }\n              p = (p - 1) & u;\n            }\n        }\n      }\n      writer.println(dp[(1<<n) - 1]);\n    }\n  }\n}\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n@SuppressWarnings(\"unused\")\npublic class Solution{\n\t\n\tstatic long mod = -1;\n\tstatic long[] fact, invfact, pow;\n\tstatic long[][] C;\n\tstatic long[][] dp;\n\tstatic final int N = 405;\n\tstatic int n;\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner fs = new FastScanner();\n    \tPrintWriter out = new PrintWriter(System.out);\n    \t\n    \tint tt = 1;\n    \touter:\n    \twhile(tt-->0) {\n    \t\t\n    \t\tn = fs.nextInt();\n    \t\tmod = fs.nextLong();\n    \t\t\n    \t\tdp = new long[N][N];\n    \t\tprecompute();\n    \t\t\n    \t\tdp[0][0] = 1;\n    \t\t\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\tfor(int j=0;j<=i;j++) {\n    \t\t\t\tfor(int k=1;i+k<=n;k++) {\n    \t\t\t\t\tdp[i+k+1][j+k] += (((dp[i][j]*pow[k-1])%mod)*C[j+k][k])%mod;\n    \t\t\t\t\tdp[i+k+1][j+k] %= mod;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tlong ans = 0;\n    \t\tfor(int i=0;i<=n;i++) {\n    \t\t\tans = (ans + dp[n+1][i])%mod;\n    \t\t}\n    \t\t\n    \t\tout.println(ans);\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t}\n    \t\n    \tout.close();\n    }\n\t\n\t\n\tstatic void precompute() {\n\t\tfact = new long[N]; invfact = new long[N]; C = new long[N][N]; pow = new long[N];\n\t\tfact[0] = 1;\n\t\tfor(int i=1;i<=n;i++) fact[i] = (fact[i-1]*i)%mod;\n\t\tinvfact[n] = inv(fact[n]);\n\t\tfor(int i=n-1;i>=0;i--) invfact[i] = (invfact[i+1]*(i+1))%mod;\n\t\t\n\t\tpow[0] = 1;\n\t\tfor(int i=1;i<=n;i++) pow[i] = (pow[i-1]*2)%mod;\n\t\t\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tfor(int j=0;j<=i;j++) {\n\t\t\t\tif(j==0 || j==i) C[i][j] = 1;\n\t\t\t\telse C[i][j] = (C[i-1][j-1] + C[i-1][j])%mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\tstatic long exp(long a, long n) {\n\t\tlong res = 1;\n\t\twhile(n>0) {\n\t\t\tif((n&1)==1) res = (res*a)%mod;\n\t\t\ta = (a*a)%mod;\n\t\t\tn = n>>1;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic long inv(long n) {\n\t\treturn exp(n, mod-2);\n\t}\n\t\n\n\t\n    static final Random random=new Random();\n    \n    static <T> void shuffle(T[] arr) {\n    \tint n = arr.length;\n    \tfor(int i=0;i<n;i++\t) {\n    \t\tint k = random.nextInt(n);\n    \t\tT temp = arr[k]; arr[k] = arr[i]; arr[i] = temp;\n    \t}\n    }\n    \n    \t\n    static void ruffleSort(int[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); int temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n    \n    static void ruffleSort(long[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); long temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n   \n  \n    \n    static void reverse(int[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tint temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    static void reverse(long[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tlong temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    \n    static <T> void reverse(T[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++) {\n    \t\tT temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \t\n    \t\n    static class FastScanner{\n    \tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \tStringTokenizer st = new StringTokenizer(\"\");\n     \n    \tpublic String next(){\n    \t\twhile(!st.hasMoreElements()){\n    \t\t\ttry{\n    \t\t\t\tst = new StringTokenizer(br.readLine());\n    \t\t\t} catch(IOException e){\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t\treturn st.nextToken();\n    \t}\n    \t\t\n    \tpublic String nextLine() throws IOException {\n    \t\treturn br.readLine();\n    \t}\n    \t\t\n    \tpublic int nextInt(){\n    \t\treturn Integer.parseInt(next());\n    \t}\n     \n    \tpublic int[] readArray(int n){\n    \t\tint[] a = new int[n];\n    \t\tfor(int i=0;i<n;i++)\n    \t\t\ta[i] = nextInt();\n    \t\treturn a;\n    \t}\n    \t\t\n    \tpublic long nextLong() {\n    \t\treturn Long.parseLong(next());\n    \t}\n    \t\t\n    \tpublic char nextChar() {\n    \t\treturn next().toCharArray()[0];\n    \t}\n    }\n   \t\n}\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.util.Scanner;\n\n\n\npublic class ModularExponentiation_913 \n\n{\n\n\tpublic static void main(String[] args) \n\n\t{\n\n\t\tlong n, m;\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t\n\n\t\tn = sc.nextLong();\n\n\t\tm = sc.nextLong();\n\n\t\t\n\n\t\tn = (long) Math.pow(2, n);\n\n\t\tSystem.out.print(m%n);\n\n\t}\n\n}\n\n", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.awt.List;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\n\npublic class main {\n\t\n\tstatic long d,x,y;\n\tpublic static void main(String[] args) {\n\t\tFastScanner in = new FastScanner();\n\t    \n\t\tlong x = in.nextLong(), k = in.nextLong();\n\t\t\n\t\tlong mod = 1000000007;\n\t\t\n\t\tlong one = pow(2,k,mod);\n\t\t\n\t\tone %= mod;\n\t\t\n\t\tlong two = (2*x)%mod-1;\n\t\t\n\t\ttwo %= mod;\n\t\t\n\t\tlong ans = (one*two)%mod+1;\n\t\t\n\t\tans %= mod;\n\t\t\n\t\tif(ans<0)\n\t\t\tans += mod;\n\t\t\n\t\tif(x==0)\n\t\t\tSystem.out.println(\"0\");\n\t\telse\n\t\t\tSystem.out.println(ans);\n\t        \n\t}\n\tprivate static long pow(long a, long b, long mod) {\n\t\tif(b==0) return 1;\n\t\t\n\t\tif(b==1)\n\t\t\treturn a;\n\t\t\n\t\tif(b%2==0)\n\t\t\treturn pow((a*a)%mod,b/2,mod);\n\t\telse\n\t\t\treturn (a*pow((a*a)%mod,(b-1)/2,mod))%mod;\n\t\t\n\t}\n\t\n\t\n\n\t\n\n}\n\n\n\n\n\n\n\n\n\n\nclass FastScanner {\n\tBufferedReader br;\n\tStringTokenizer st;\n\t\n\tpublic FastScanner() {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\t\n\tString next() {\n\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\t\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n}\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tFastReader reader = new FastReader();\n\t\tint n = reader.nextInt();\n\t\tint s = reader.nextInt();\n\t\tint[][] mat = new int[n][2];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint j = 0;\n\t\t\tfor (String st : reader.nextLine().split(\"\\\\s+\"))\n\t\t\t\tmat[i][j++] = Integer.parseInt(st);\n\t\t}\n\t\treader.close();\n\t\tint time = s - mat[n - 1][0];\n\t\tif (time < mat[n - 1][1])\n\t\t\ttime += mat[n - 1][1] - time;\n\t\tfor (int i = n - 2; i >= 0; --i) {\n\t\t\ttime += mat[i + 1][0] - mat[i][0];\n\t\t\tif (time < mat[i][1])\n\t\t\t\ttime += mat[i][1] - time;\n\t\t}\n\t\tSystem.out.println(time + mat[0][0]);\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine().trim());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine().trim();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tint[] readArray(int size) {\n\t\t\tint[] ar = new int[size];\n\t\t\tint i = 0;\n\t\t\ttry {\n\t\t\t\tfor (String s : br.readLine().trim().split(\"\\\\s+\"))\n\t\t\t\t\tar[i++] = Integer.parseInt(s);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn ar;\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}", "complexity": "linear", "problem": "0608_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.FileReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.InputStreamReader;\n\nimport java.math.BigInteger;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class LittleGirlandMaximumXOR {\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t\n\n\t\tlong l = sc.nextLong(), r = sc.nextLong();\n\n\t\tchar c[] = Long.toBinaryString(r).toCharArray();\n\n\t\tint len = c.length;\n\n\t\tStringBuilder s = new StringBuilder();\n\n\t\tfor (int i = 0; i < len; i++) {\n\n\t\t\ts.append(c[i]);\n\n\t\t\tif (c[i] == '1') {\n\n\t\t\t\tStringBuilder sb = new StringBuilder(s.toString());\n\n\t\t\t\tsb.setCharAt(i, '0');\n\n\t\t\t\tfor (int j = i+1; j < len; j++)\n\n\t\t\t\t\tsb.append('1');\n\n\t\t\t\tBigInteger b = new BigInteger(sb.toString(), 2);\n\n\t\t\t\tif (b.compareTo(BigInteger.valueOf(l)) >= 0 && b.compareTo(BigInteger.valueOf(r)) <= 0) {\n\n\t\t\t\t\tsb.setCharAt(i, '1');\n\n\t\t\t\t\ti--;\n\n\t\t\t\t\tfor (; i >= 0; i--)\n\n\t\t\t\t\t\tsb.setCharAt(i, '0');\n\n\t\t\t\t\t\n\n\t\t\t\t\tb = new BigInteger(sb.toString(), 2);\n\n\t\t\t\t\tSystem.out.println(b);\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tSystem.out.println(0);\n\n\t}\n\n\t\n\n\tstatic class Scanner {\n\n\t\tBufferedReader br;\n\n\t\tStringTokenizer st;\n\n\n\n\t\tpublic Scanner(FileReader f) {\n\n\t\t\tbr = new BufferedReader(f);\n\n\t\t}\n\n\n\n\t\tpublic Scanner(InputStream in) {\n\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\n\t\t}\n\n\n\n\t\tpublic String next() throws IOException {\n\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\n\t\t}\n\n\n\n\t\tpublic String nextLine() throws IOException {\n\n\t\t\treturn br.readLine();\n\n\t\t}\n\n\n\n\t\tpublic int nextInt() throws IOException {\n\n\t\t\treturn Integer.parseInt(next());\n\n\t\t}\n\n\n\n\t\tpublic long nextLong() throws IOException {\n\n\t\t\treturn Long.parseLong(next());\n\n\t\t}\n\n\n\n\t\tpublic double nextDouble() throws IOException {\n\n\t\t\treturn Double.parseDouble(next());\n\n\t\t}\n\n\n\n\t\tpublic boolean Ready() throws IOException {\n\n\t\t\treturn br.ready();\n\n\t\t}\n\n\n\n\t\tpublic void waitForInput(long time) {\n\n\t\t\tlong ct = System.currentTimeMillis();\n\n\t\t\twhile(System.currentTimeMillis() - ct < time) {};\n\n\t\t}\n\n\n\n\t}\n\n\n\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeSet;\n\npublic class r568p8{\n\n    private static InputReader sc;\n    private static PrintWriter pw;\n    private static long mod;\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n\n        InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        long nextLong() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        String readString() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        String nextLine() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void main(String args[]) {\n        sc = new InputReader(System.in);\n        pw = new PrintWriter(System.out);\n\n        int t = 1;\n        while(t-->0)\n            solve();\n\n        pw.flush();\n        pw.close();\n    }\n\n    private static void fill_matrix(long dp[][][][], int a, int b, int c, int end){\n\n        if((a == 0 && b == 0 && c == 0) || (a == 0 && end == 0) || (b == 0 && end == 1) || (c == 0 && end == 2)){\n            dp[a][b][c][end] = 0;\n            return;\n        }\n\n        if(a > 1 && b == 0 && c == 0){\n            dp[a][b][c][end] = 0;\n            return;\n        }\n\n        if(b > 1 && a == 0 && c == 0){\n            dp[a][b][c][end] = 0;\n            return;\n        }\n\n        if(c > 1 && a == 0 && b == 0){\n            dp[a][b][c][end] = 0;\n            return;\n        }\n\n        if(a == 1 && end == 0 && b == 0 && c == 0){\n            dp[a][b][c][end] = 1;\n            return;\n        }\n        if(b == 1 && end == 1 && a == 0 && c == 0){\n            dp[a][b][c][end] = 1;\n            return;\n        }\n        if(c == 1 && end == 2 && b == 0 && a == 0){\n            dp[a][b][c][end] = 1;\n            return;\n        }\n\n        if(end == 0){\n            fill_matrix(dp, a-1, b, c, 1);\n            fill_matrix(dp, a-1, b, c, 2);\n\n            dp[a][b][c][0] = (dp[a-1][b][c][1]%mod + dp[a-1][b][c][2]%mod)%mod;\n        }\n        else if(end == 1){\n            fill_matrix(dp, a, b-1, c, 0);\n            fill_matrix(dp, a, b-1, c, 2);\n\n            dp[a][b][c][1] = (dp[a][b-1][c][0]%mod + dp[a][b-1][c][2]%mod)%mod;\n        }\n        else{\n            fill_matrix(dp, a, b, c-1, 0);\n            fill_matrix(dp, a, b, c-1, 1);\n\n            dp[a][b][c][2] = (dp[a][b][c-1][0]%mod + dp[a][b][c-1][1]%mod)%mod;\n        }\n    }\n\n    private static long cal(int count[]){\n        int a = count[0], b = count[1], c = count[2];\n        long dp[][][][] = new long[a+1][b+1][c+1][3];\n\n        long factorial[] = new long[20];\n\n        factorial[0] = 1;\n        factorial[1] = 1;\n\n        for(int i=2; i<20; i++)\n            factorial[i] = (factorial[i-1]%mod*i%mod)%mod;\n\n        fill_matrix(dp, a, b, c, 0);\n        fill_matrix(dp, a, b, c, 1);\n        fill_matrix(dp, a, b, c, 2);\n\n         long p = (dp[a][b][c][0]%mod + dp[a][b][c][1]%mod + dp[a][b][c][2]%mod)%mod;\n\n         long ans = (((p%mod * factorial[a]%mod)%mod * factorial[b]%mod)%mod * factorial[c]%mod)%mod;\n\n         return ans;\n    }\n\n    private static void solve(){\n        int n = sc.nextInt(), T = sc.nextInt();\n\n        int len[] = new int[n], genre[] = new int[n];\n\n        for(int i=0; i<n; i++){\n            len[i] = sc.nextInt();\n            genre[i] = sc.nextInt();\n        }\n\n        int sum[] = new int[(1<<n)];\n\n        mod = (long)1e9 + 7;\n        long ans = 0;\n\n        for(int i=1; i<(1<<n); i++){\n            for(int j=0; j<15; j++){\n                if((i&(1<<j)) != 0){\n                    sum[i] = sum[i^(1<<j)] + len[j];\n                    break;\n                }\n            }\n\n            if(sum[i] == T) {\n                int count[] = {0, 0, 0};\n\n                for (int j = 0; j < 15; j++) {\n                    if ((i & (1 << j)) != 0)\n                        count[genre[j] - 1]++;\n                }\n\n                ans = (ans % mod + cal(count) % mod) % mod;\n            }\n        }\n\n        pw.println(+ans);\n    }\n}", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\n\npublic class Solution implements Runnable {\n\t\n\tpublic static void main(String[] args) {\n\t\t(new Thread(new Solution())).start();\n\t}\n\t\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st;\n\t\n\tString nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) st = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\t\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\t\n\tclass Dom implements Comparable<Dom>{\n\t\tint x, a;\n\n\t\tpublic int compareTo(Dom o) {\n\t\t\treturn x - o.x;\n\t\t}\n\t}\n\t\n\tvoid solve() throws Exception {\n\t\tint n = nextInt();\n\t\tint t = nextInt() * 2;\n\t\tDom[] a = new Dom[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = new Dom();\n\t\t\ta[i].x = nextInt() * 2;\n\t\t\ta[i].a = nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tint ans = 2;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif (t < a[i + 1].x - a[i + 1].a - a[i].x - a[i].a) ans += 2;\n\t\t\tif (t == a[i + 1].x - a[i + 1].a - a[i].x - a[i].a) ans += 1;\n\t\t}\n\t\tout.print(ans);\n\t}\n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tout.flush();\n\t}\n\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\n    public void solve() throws IOException  {\n\n        int tt = readInt();\n        for (int t = 0; t < tt; t++) {\n            done = false;\n            n = readInt();\n            a = new int[n];\n            prefixes = new int[n][];\n            prefixes[0] = new int[0];\n            for (int i = 0; i < n; i++) {\n                a[i] = readInt();\n            }\n            int[] levels = new int[] {1};\n            find(levels, 1);\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < prefixes[i].length - 1; j++) {\n                    out.print(prefixes[i][j] + \".\");\n                }\n                out.println(a[i]);\n            }\n\n\n        }\n    }\n    int[] a;\n    int n;\n    boolean done;\n    int[][] prefixes;\n\n    void find(int[] levels, int position) {\n        if (position == n) {\n            done = true;\n            return;\n        }\n\n        int value = a[position];\n        if (value == 1) {\n            int[] newlevels = Arrays.copyOf(levels, levels.length + 1);\n            newlevels[levels.length] = 1;\n            prefixes[position] = newlevels;\n            find(newlevels, position + 1);\n        }\n        for (int i = levels.length - 1; i >= 0; i--) {\n            if (value == levels[i] + 1) {\n\n                int[] newlevels = Arrays.copyOf(levels, i + 1);\n                newlevels[i]++;\n                prefixes[position] = newlevels;\n                find(newlevels, position + 1);\n                if (done) {\n                    return;\n                }\n\n                prefixes[position] = null;\n            }\n        }\n    }\n\n\n    /////////////////////////////////////////\n\n\n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(\"input.txt\").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            solve();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n\n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    @SuppressWarnings(\"unused\")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private PrintWriter out;\n\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"\", 256 * (1L << 20)).start();\n    }\n\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        G1PlaylistForPolycarpEasyVersion solver = new G1PlaylistForPolycarpEasyVersion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class G1PlaylistForPolycarpEasyVersion {\n        public static final int GENRES_COUNT = 3;\n        private int songsCount;\n        private int totalDuration;\n        private Song[] songs;\n        private int[][][] mem;\n        static final int mod = 1000000007;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            songsCount = in.nextInt();\n            totalDuration = in.nextInt();\n\n            songs = new Song[songsCount];\n\n            for (int i = 0; i < songsCount; i++) {\n                songs[i] = new Song(in.nextInt(), in.nextInt() - 1);\n            }\n\n            long ret = 0;\n            int chosenSongs = 0;\n\n            mem = new int[GENRES_COUNT + 1][][];\n            for (int i = 0; i < GENRES_COUNT; i++) {\n                mem[i] = new int[totalDuration + 1][];\n\n                for (int j = 0; j <= totalDuration; j++) {\n                    mem[i][j] = new int[1 << songsCount];\n\n                    for (int k = 0; k < 1 << songsCount; k++) {\n                        mem[i][j][k] = -1;\n                    }\n                }\n            }\n\n            for (int i = 0; i < songsCount; i++) {\n                chosenSongs = 1 << i;\n                ret += search(totalDuration - songs[i].duration, songs[i].genre, chosenSongs);\n            }\n\n            out.println(ret % mod);\n        }\n\n        private long search(int timeLeft, int lastGenre, int chosen) {\n            if (timeLeft < 0) {\n                return 0;\n            }\n\n            if (timeLeft == 0) {\n                return 1;\n            }\n\n            if (mem[lastGenre][timeLeft][chosen] != -1) {\n                return mem[lastGenre][timeLeft][chosen];\n            }\n\n            long ret = 0;\n\n            for (int i = 0; i < songsCount; i++) {\n                if (((1 << i) & chosen) == 0 && songs[i].genre != lastGenre) {\n                    ret += search(timeLeft - songs[i].duration, songs[i].genre, chosen | 1 << i);\n                    if (ret > mod) {\n                        ret = ret % mod;\n                    }\n                }\n            }\n            mem[lastGenre][timeLeft][chosen] = (int) (ret % mod);\n\n            return mem[lastGenre][timeLeft][chosen];\n        }\n\n        class Song {\n            public int duration;\n            public int genre;\n\n            public Song(int duration, int genre) {\n                this.duration = duration;\n                this.genre = genre;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.FileReader;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class Fish extends Thread {\n\n    public Fish() {\n        this.input = new BufferedReader(new InputStreamReader(System.in));\n        this.output = new PrintWriter(System.out);\n        this.setPriority(Thread.MAX_PRIORITY);\n    }\n\n\n    private void solve() throws Throwable {\n        int n = nextInt();\n        double[][] a = new double[n][n];\n        double[] dp = new double[(1 << n)];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                a[i][j] = nextDouble();\n            }\n        }\n        int limit = (1 << n) - 1;\n        //dp[mask] = probability of current subset (mask) to remain in the end\n        dp[limit] = 1.0;\n        for (int mask = limit; mask > 0; --mask) {\n            int cardinality = Integer.bitCount(mask);\n            int probability = cardinality * (cardinality - 1) / 2;\n            for (int first = 0; first < n; ++first) {\n                if ((mask & powers[first]) != 0) {\n                    for (int second = first + 1; second < n; ++second) {\n                        if ((mask & powers[second]) != 0) {\n                            dp[mask - powers[first]] += dp[mask] * a[second][first] / probability;\n                            dp[mask - powers[second]] += dp[mask] * a[first][second] / probability;\n                        }\n\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            output.printf(\"%.10f \", dp[powers[i]]);\n        }\n    }\n\n    public void run() {\n        try {\n            solve();\n        } catch (Throwable e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace();\n            System.exit(666);\n        } finally {\n            output.flush();\n            output.close();\n        }\n    }\n\n\n    public static void main(String[] args) {\n        new Fish().start();\n    }\n\n    private String nextToken() throws IOException {\n        while (tokens == null || !tokens.hasMoreTokens()) {\n            tokens = new StringTokenizer(input.readLine());\n        }\n        return tokens.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    static int powers[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144};\n    private BufferedReader input;\n    private PrintWriter output;\n    private StringTokenizer tokens = null;\n}", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\npublic class file{\n\n     public static void main(String []args) {\n      Scanner sc=new Scanner(System.in);\n      int n=sc.nextInt();\n      while(n-->0)\n      {\n          int a=sc.nextInt();\n          int b=sc.nextInt();\n          int ans=f(a,b);\n          System.out.println(ans);\n      }\n     }\n     public static int f(int a,int b)\n     {\n         if(a==0||b==0)\n           return 0;\n         if(a>b)\n         {\n             return a/b + f(b,a%b);\n         }\n         else\n             return b/a + f(a,b%a);\n     }\n}", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n/**\n * User: alms\n * Date: 09.07.2010\n * Time: 18:57:44\n */\npublic class Solution {\n    public static void main(String[] args) throws Exception {\n        final String str;\n        final BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n        str = r.readLine();\n\n        int max = 0;\n\n        for (int x = 0; x  < str.length(); x++) {\n            for (int y = x + 1; y  < str.length(); y++) {\n                int c = 0;\n                for (;c + x < str.length() && y + c < str.length(); c++) {\n                    if (str.charAt(x + c) != str.charAt(y + c)) {\n                        break;\n                    }\n                }\n\n                if (c > max) {\n                    max = c;\n                }\n            }\n        }\n\n        System.out.println(max);\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] ar = new int[n];\n            for (int i = 0; i < n; i++) {\n                ar[i] = in.nextInt();\n            }\n            long ninv = 0;\n            for (int i = 0; i < n - 1; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (ar[i] > ar[j])\n                        ninv++;\n                }\n            }\n            int m = in.nextInt();\n            for (int i = 0; i < m; i++) {\n                int l = in.nextInt();\n                int r = in.nextInt();\n\n                int s = (r - l) * (r - l + 1) / 2;\n\n                ninv += s;\n\n                if (ninv % 2 == 0)\n                    out.println(\"even\");\n                else\n                    out.println(\"odd\");\n            }\n        }\n\n    }\n\n    static class InputReader {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public InputReader(InputStream is) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            this.br = br;\n        }\n\n        public String next() {\n            if (st == null || !st.hasMoreTokens()) {\n                String nextLine = null;\n                try {\n                    nextLine = br.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (nextLine == null)\n                    return null;\n                st = new StringTokenizer(nextLine);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;\nimport java.io.*;\n// import java.lang.*;\n// import java.math.*;\n\npublic class Codeforces {\n    static FastReader sc=new FastReader();\n\tstatic PrintWriter out=new PrintWriter(System.out);\n\tstatic long mod=1000000007;\n\t// static long mod=998244353;\n\tstatic int MAX=Integer.MAX_VALUE;\n\tstatic int MIN=Integer.MIN_VALUE;\n\tstatic long MAXL=Long.MAX_VALUE;\n\tstatic long MINL=Long.MIN_VALUE;\n\tstatic ArrayList<Integer> graph[];\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// code goes here\n\t\tint t=I();\n\t\twhile(t-->0)\n\t\t{\n\t\t\tint n=I();\n\t\t\tint a[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i]=I();\n\t\t\t}\n\t\t\tStack<Integer> st=new Stack<>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(a[i]==1){\n\t\t\t\t\tst.push(1);\n\t\t\t\t}else{\n\t\t\t\t\twhile(!st.isEmpty() && st.peek()+1!=a[i]){\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t}\n\t\t\t\t\tst.pop();\n\t\t\t\t\tst.push(a[i]);\n\t\t\t\t}\n\t\t\t\tStringBuffer sb=new StringBuffer();\n\t\t\t\tfor(int j:st){\n\t\t\t\t\tsb.append(j+\".\");\n\t\t\t\t}\n\t\t\t\tsb.delete(sb.length()-1,sb.length());\n\t\t\t\tout.println(sb.toString());\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\n\tpublic static class pair\n    {\n    \tlong a;\n    \tlong b;\n    \tpublic pair(long val,long index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n\tpublic static class myComp implements Comparator<pair>\n\t{\n\t\t//sort in ascending order.\n\t\tpublic int compare(pair p1,pair p2)\n\t\t{\n\t\t\tif(p1.a==p2.a)\n    \t    return 0;\n    \t    else if(p1.a<p2.a)\n    \t    return -1;\n    \t    else\n    \t    return 1;\n\t\t}\n\t\t//sort in descending order.\n\t\t// public int compare(pair p1,pair p2)\n    \t// {\n    \t//     if(p1.a==p2.a)\n    \t//     return 0;\n    \t//     else if(p1.a<p2.a)\n    \t//     return 1;\n    \t//     else\n    \t//     return -1;\n    \t// }\n\t}\n\tpublic static long kadane(long a[],int n)\n\t{\n\t\tlong max_sum=Long.MIN_VALUE,max_end=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tmax_end+=a[i];\n\t\t\tif(max_sum<max_end){max_sum=max_end;}\n\t\t\tif(max_end<0){max_end=0;}\n\t\t}\n\t\treturn max_sum;\n\t}\n\tpublic static void DFS(int s,boolean visited[])\n\t{\n\t\tvisited[s]=true;\n\t\tfor(int i:graph[s]){\n\t\t\tif(!visited[i]){\n\t\t\t\tDFS(i,visited);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void setGraph(int n,int m)\n\t{\n\t\tgraph=new ArrayList[n+1];\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tgraph[i]=new ArrayList<>();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u=I(),v=I();\n\t\t\tgraph[u].add(v);\n\t\t\tgraph[v].add(u);\n\t\t}\n\t}\n\tpublic static int BS(long a[],long x,int ii,int jj)\n\t{\n\t\t// int n=a.length;\n\t\tint mid=0;\n\t\tint i=ii,j=jj;\n\t\twhile(i<=j)\n\t\t{\n\t\t\tmid=(i+j)/2;\n\t\t\tif(a[mid]<x){\n\t\t\t\ti=mid+1;\n\t\t\t}else if(a[mid]>x){\n\t\t\t\tj=mid-1;\n\t\t\t}else{\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static int lower_bound(int arr[],int s, int N, int X)\n\t{\n\t\tif(arr[N]<X)return N;\n\t\tif(arr[0]>X)return -1;\n\t\tint left=s,right=N;\n\t\twhile(left<right){\n\t\t\tint mid=(left+right)/2;\n\t\t\tif(arr[mid]==X)\n\t\t\treturn mid;\n\t\t\telse if(arr[mid]>X){\n\t\t\t\tif(mid>0 && arr[mid]>X && arr[mid-1]<=X){\n\t\t\t\t\treturn mid-1;\n\t\t\t\t}else{\n\t\t\t\t\tright=mid-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(mid<N && arr[mid+1]>X && arr[mid]<=X){\n\t\t\t\t\treturn mid;\n\t\t\t\t}else{\n\t\t\t\t\tleft=mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\tpublic static ArrayList<Integer> primeSieve(int n)\n\t{\n\t    ArrayList<Integer> arr=new ArrayList<>();\n\t    boolean prime[] = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n        prime[i] = true;\n        for (int p = 2; p * p <= n; p++)\n        {\n            if (prime[p] == true)\n            {\n                for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n            }\n        }\n        for (int i = 2; i <= n; i++)\n        {\n            if (prime[i] == true)\n            arr.add(i);\n        }\n        return arr;\n\t}\n\n\t// Fenwick / BinaryIndexed  Tree  USE IT - FenwickTree ft1=new FenwickTree(n);\n\tpublic static class FenwickTree\n\t{\n\t\tint farr[];\n\t\tint n;\n\t\tpublic FenwickTree(int c)\n\t\t{\n\t\t\tn=c+1;\n\t\t\tfarr=new int[n];\n\t\t}\n\t\t// public void update_range(int l,int r,long p)\n\t\t// {\n\t\t// \tupdate(l,p);\n\t\t// \tupdate(r+1,(-1)*p);\n\t\t// }\n\t\tpublic void update(int x,int p)\n\t\t{\n\t\t\tfor(;x<=n;x+=x&(-x))\n\t\t\t{\n\t\t\t\tfarr[x]+=p;\n\t\t\t}\n\t\t}\n\t\tpublic long get(int x)\n\t\t{\n\t\t\tlong ans=0;\n\t\t\tfor(;x>0;x-=x&(-x))\n\t\t\t{\n\t\t\t\tans=ans+farr[x];\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\t//Disjoint Set Union\n\tpublic static class DSU\n\t{\n\t    int par[],rank[];\n\t    public DSU(int c)\n\t    {\n\t        par=new int[c+1];\n\t        rank=new int[c+1];\n\t        for(int i=0;i<=c;i++)\n\t        {\n\t            par[i]=i;\n\t            rank[i]=0;\n\t        }\n\t    }\n\t    public int find(int a)\n\t    {\n\t        if(a==par[a])\n\t        return a;\n\t        return par[a]=find(par[a]);\n\t    }\n\t    public void union(int a,int b)\n\t    {\n\t        int a_rep=find(a),b_rep=find(b);\n\t        if(a_rep==b_rep)\n\t        return;\n\t        if(rank[a_rep]<rank[b_rep])\n\t        par[a_rep]=b_rep;\n\t        else if(rank[a_rep]>rank[b_rep])\n\t        par[b_rep]=a_rep;\n\t        else\n\t        {\n\t            par[b_rep]=a_rep;\n\t            rank[a_rep]++;\n\t        }\n\t    }\n\t}\n\n\t//SEGMENT TREE CODE\n\n\t// public static void segmentUpdate(int si,int ss,int se,int qs,int qe,long x)\n\t// {\n\t// \tif(ss>qe || se<qs)return;\n\t// \tif(qs<=ss && qe>=se)\n\t// \t{\n\t// \t\tseg[si][0]+=1L;\n\t// \t\tseg[si][1]+=x*x;\n\t// \t\tseg[si][2]+=2*x;\n\t// \t\treturn;\n\t// \t}\n\t// \tint mid=(ss+se)/2;\n\t// \tsegmentUpdate(2*si+1,ss,mid,qs,qe,x);\n\t// \tsegmentUpdate(2*si+2,mid+1,se,qs,qe,x);\n\t// }\n\t// public static long segmentGet(int si,int ss,int se,int x,long f,long s,long t,long a[])\n\t// {\n\t// \tif(ss==se && ss==x)\n\t// \t{\n\t// \t\tf+=seg[si][0];\n\t// \t\ts+=seg[si][1];\n\t// \t\tt+=seg[si][2];\n\t// \t\tlong ans=a[x]+(f*((long)x+1L)*((long)x+1L))+s+(t*((long)x+1L));\n\t// \t\treturn ans;\n\t// \t}\n\t// \tint mid=(ss+se)/2;\n\t// \tif(x>mid){\n\t// \t\treturn segmentGet(2*si+2,mid+1,se,x,f+seg[si][0],s+seg[si][1],t+seg[si][2],a);\n\t// \t}else{\n\t// \t\treturn segmentGet(2*si+1,ss,mid,x,f+seg[si][0],s+seg[si][1],t+seg[si][2],a);\n\t// \t}\n\t// }\n\n\t\n    public static class myComp1 implements Comparator<pair1>\n    {\n\t\t//sort in ascending order.\n    \tpublic int compare(pair1 p1,pair1 p2)\n    \t{\n    \t    if(p1.a==p2.a)\n    \t    return 0;\n    \t    else if(p1.a<p2.a)\n    \t    return -1;\n    \t    else\n    \t    return 1;\n    \t}\n\t\t//sort in descending order.\n\t\t// public int compare(pair p1,pair p2)\n    \t// {\n    \t//     if(p1.a==p2.a)\n    \t//     return 0;\n    \t//     else if(p1.a<p2.a)\n    \t//     return 1;\n    \t//     else\n    \t//     return -1;\n    \t// }\n    }\n\tpublic static class pair1\n    {\n    \tlong a;\n    \tlong b;\n    \tpublic pair1(long val,long index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n    public static ArrayList<pair1> mergeIntervals(ArrayList<pair1> arr)\n\t{\n\t    //****************use this in main function-Collections.sort(arr,new myComp1());\n\t    ArrayList<pair1> a1=new ArrayList<>();\n\t    if(arr.size()<=1)\n\t    return arr;\n\t    a1.add(arr.get(0));\n\t    int i=1,j=0;\n\t    while(i<arr.size())\n\t    {\n\t        if(a1.get(j).b<arr.get(i).a)\n\t        {\n\t           a1.add(arr.get(i));\n\t           i++;\n\t           j++;\n\t        }\n\t        else if(a1.get(j).b>arr.get(i).a && a1.get(j).b>=arr.get(i).b)\n\t        {\n\t            i++;\n\t        }\n\t        else if(a1.get(j).b>=arr.get(i).a)\n\t        {\n\t            long a=a1.get(j).a;\n\t            long b=arr.get(i).b;\n\t            a1.remove(j);\n\t            a1.add(new pair1(a,b));\n\t            i++;\n\t        }\n\t    }\n\t    return a1;\n\t}\n\tpublic static boolean isPalindrome(String s,int n)\n\t{\n\t\tfor(int i=0;i<=n/2;i++){\n\t\t\tif(s.charAt(i)!=s.charAt(n-i-1)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static int gcd(int a,int b)\n\t{\n\t    if(b==0)\n\t    return a;\n\t    else\n\t    return gcd(b,a%b);\n\t}\n\tpublic static long gcd(long a,long b)\n\t{\n\t    if(b==0)\n\t    return a;\n\t    else\n\t    return gcd(b,a%b);\n\t}\n\tpublic static long fact(long n)\n\t{\n\t\tlong fact=1;\n\t\tfor(long i=2;i<=n;i++){\n\t\t\tfact=((fact%mod)*(i%mod))%mod;\n\t\t}\n\t\treturn fact;\n\t}\n\tpublic static long fact(int n)\n\t{\n\t\tlong fact=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tfact=((fact%mod)*(i%mod))%mod;\n\t\t}\n\t\treturn fact;\n\t} \n\tpublic static boolean isPrime(int n) \n\t{ \n\t    if (n <= 1) \n\t        return false; \n\t    if (n <= 3) \n\t        return true; \n\t    if (n % 2 == 0 || n % 3 == 0) \n\t        return false; \n\t    double sq=Math.sqrt(n);\n\t  \n\t    for (int i = 5; i <= sq; i = i + 6) \n\t        if (n % i == 0 || n % (i + 2) == 0) \n\t            return false; \n\t    return true; \n\t} \n    public static boolean isPrime(long n) \n\t{ \n\t    if (n <= 1) \n\t        return false; \n\t    if (n <= 3) \n\t        return true; \n\t    if (n % 2 == 0 || n % 3 == 0) \n\t        return false; \n\t    double sq=Math.sqrt(n);\n\t\n\t    for (int i = 5; i <= sq; i = i + 6) \n\t        if (n % i == 0 || n % (i + 2) == 0) \n\t            return false; \n\t    return true; \n\t}\n\tpublic static void printArray(long a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(int a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(pair a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i].a+\"->\"+a[i].b+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(char a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]);\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(String a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(boolean a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(int a[][])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tfor(int j=0;j<a[i].length;j++){\n\t\t\t\tout.print(a[i][j]+\" \");\n\t\t\t}out.println();\n\t\t}\n\t}\n\tpublic static void printArray(long a[][])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tfor(int j=0;j<a[i].length;j++){\n\t\t\t\tout.print(a[i][j]+\" \");\n\t\t\t}out.println();\n\t\t}\n\t}\n\tpublic static void printArray(char a[][])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tfor(int j=0;j<a[i].length;j++){\n\t\t\t\tout.print(a[i][j]+\" \");\n\t\t\t}out.println();\n\t\t}\n\t}\n\tpublic static void printArrayL(ArrayList<Long> arr)\n\t{\n\t\tfor(int i=0;i<arr.size();i++){\n\t\t\tout.print(arr.get(i)+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArrayI(ArrayList<Integer> arr)\n\t{\n\t\tfor(int i=0;i<arr.size();i++){\n\t\t\tout.print(arr.get(i)+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArrayS(ArrayList<String> arr)\n\t{\n\t\tfor(int i=0;i<arr.size();i++){\n\t\t\tout.print(arr.get(i)+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printMapInt(HashMap<Integer,Integer> hm){\n\t\tfor(Map.Entry<Integer,Integer> e:hm.entrySet()){\n\t\t\tout.println(e.getKey()+\"->\"+e.getValue());\n\t\t}out.println();\n\t}\n\tpublic static void printMapLong(HashMap<Long,Long> hm){\n\t\tfor(Map.Entry<Long,Long> e:hm.entrySet()){\n\t\t\tout.println(e.getKey()+\"->\"+e.getValue());\n\t\t}out.println();\n\t}\n\n\t//Modular Arithmetic\n\n\tpublic static long add(long a,long b)\n\t{\n\t\ta+=b;\n\t\tif(a>=mod)a-=mod;\n\t\treturn a;\n\t}\n\tpublic static long sub(long a,long b)\n\t{\n\t\ta-=b;\n\t\tif(a<0)a+=mod;\n\t\treturn a;\n\t}\n\tpublic static long mul(long a,long b)\n\t{\n\t\treturn ((a%mod)*(b%mod))%mod;\n\t}\n\tpublic static long divide(long a,long b,long m)\n\t{\n\t\ta=mul(a,modInverse(b,m));\n\t\treturn a;\n\t}\n\tpublic static long modInverse(long a,long m)\n\t{\n\t\tint x=0,y=0;\n\t\town p=new own(x,y);\n\t\tlong g=gcdExt(a,m,p);\n\t\tif(g!=1){\n\t\t\tout.println(\"inverse does not exists\");\n\t\t\treturn -1;\n\t\t}else{\n\t\t\tlong res=((p.a%m)+m)%m;\n\t\t\treturn res;\n\t\t}\n\t}\n\tpublic static long gcdExt(long a,long b,own p)\n\t{\n\t\tif(b==0){\n\t\t\tp.a=1;\n\t\t\tp.b=0;\n\t\t\treturn a;\n\t\t}\n\t\tint x1=0,y1=0;\n\t\town p1=new own(x1,y1);\n\t\tlong gcd=gcdExt(b,a%b,p1);\n\t\tp.b=p1.a - (a/b) * p1.b;\n\t\tp.a=p1.b;\n\t\treturn gcd;\n\t}\n\tpublic static long pwr(long m,long n)\n\t{\n\t\tlong res=1;\n\t\tm=m%mod;\n\t\tif(m==0)\n\t\treturn 0;\n\t\twhile(n>0)\n\t\t{\n\t\t\tif((n&1)!=0)\n\t\t\t{\n\t\t\t\tres=(res*m)%mod;\n\t\t\t}\n\t\t\tn=n>>1;\n\t\t\tm=(m*m)%mod;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static class own\n    {\n    \tlong a;\n    \tlong b;\n    \tpublic own(long val,long index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n\n\t//Modular Airthmetic\n\n\tpublic static void sort(int[] A)\n\t{\n        int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            int tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n        Arrays.sort(A);\n    }\n    public static void sort(long[] A)\n\t{\n\t    int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            long tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n\t    Arrays.sort(A);\n\t}\n\tpublic static int I(){return sc.I();}\n    public static long L(){return sc.L();}\n    public static String S(){return sc.S();}\n    public static double D(){return sc.D();}\n}\nclass FastReader {  \n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader(){\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    String next(){\n        while (st == null || !st.hasMoreElements()){\n            try {\n                st = new StringTokenizer(br.readLine());\n            }\n            catch (IOException e){\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    int I(){ \n        return Integer.parseInt(next());\n    }\n    long L(){ \n        return Long.parseLong(next());\n    }\n    double D(){\n         return Double.parseDouble(next());\n    }\n    String S(){\n        String str = \"\";\n        try \n        {\n            str = br.readLine();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class A implements Runnable {\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer st;\n\tstatic Random rnd;\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tlong k = nextLong();\n\n\t\tif (k == 1) {\n\t\t\tout.println(n);\n\t\t} else {\n\n\t\t\tTreeMap<Long, ArrayList<Integer>> numbers = new TreeMap<Long, ArrayList<Integer>>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong m = nextLong();\n\t\t\t\tint howMuch = 0;\n\n\t\t\t\twhile (m % k == 0) {\n\t\t\t\t\tm /= k;\n\t\t\t\t\t++howMuch;\n\t\t\t\t}\n\n\t\t\t\tif (!numbers.containsKey(m)) {\n\t\t\t\t\tnumbers.put(m, new ArrayList<Integer>());\n\t\t\t\t}\n\n\t\t\t\tnumbers.get(m).add(howMuch);\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tfor (ArrayList<Integer> oneGroup : numbers.values()) {\n\t\t\t\tres += parseOneGroup(oneGroup);\n\t\t\t}\n\n\t\t\tout.println(res);\n\t\t}\n\t}\n\n\tprivate int parseOneGroup(ArrayList<Integer> oneGroup) {\n\t\tCollections.sort(oneGroup);\n\n\t\tint res = 0, prevValue = Integer.MIN_VALUE;\n\n\t\tfor (int i = 0; i < oneGroup.size(); i++) {\n\t\t\tint curValue = oneGroup.get(i);\n\n\t\t\tif (prevValue + 1 != curValue) {\n\t\t\t\t++res;\n\t\t\t\tprevValue = curValue;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(42);\n\t\t}\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class d840 {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint N = in.nextInt(), Q = in.nextInt();\n\t\tint a[] = new int[N];\n\t\tfor(int n=0;n<N;n++) {\n\t\t\ta[n] = in.nextInt();\n\t\t}\n\t\tWT wt = new WT(a);\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int q=0;q<Q;q++) {\n\t\t\tint l = in.nextInt()-1;\n\t\t\tint r = in.nextInt()-1;\n\t\t\tint k = in.nextInt();\n\t\t\tint amount = (r-l+1)/k;\n//\t\t\tSystem.out.println(\"amount is \"+amount);\n\t\t\tsb.append(wt.hasMoreThanKOfOne(amount, l, r+1)).append('\\n');\n\t\t}\n\t\tSystem.out.print(sb);\n\t}\n\tstatic class WT{\n\t\tint s = Integer.MAX_VALUE, b = Integer.MIN_VALUE;\n\t\tint N;\n\t\tint[] arr;\n\t\tint[] sPtr;\n\t\tWT sWav = null, bWav = null;\n\t\tWT(int[] arr){\n\t\t\tthis.arr = arr;\n\t\t\tN = arr.length;\n\t\t\t\n\t\t\tfor(int n=0;n<N;n++) {\n\t\t\t\ts = Math.min(s, arr[n]);\n\t\t\t\tb = Math.max(b, arr[n]);\n\t\t\t}\n\t\t\tsPtr = new int[N+1];\n\t\t\tfor(int n=0;n<N;n++) {\n\t\t\t\tsPtr[n+1] = sPtr[n];\n\t\t\t\tif(arr[n] <= s + (b-s) / 2) sPtr[n+1]++;\n\t\t\t}\n\t\t\tif(s == b) return;\n\t\t\t\n\t\t\tint[] sArr = new int[sPtr[N]];\n\t\t\tint[] bArr = new int[N - sPtr[N]];\n\t\t\t\n\t\t\tfor(int n=0;n<N;n++) {\n\t\t\t\tif(sPtr[n] != sPtr[n+1]) sArr[sPtr[n]] = arr[n];\n\t\t\t\telse bArr[n-sPtr[n]] = arr[n];\n\t\t\t}\n\t\t\t\n\t\t\tsWav = new WT(sArr);\n\t\t\tbWav = new WT(bArr);\n\t\t}\n\t\tint hasMoreThanKOfOne(int k, int l, int r) {\n//\t\t\tSystem.out.println(l+\" \"+r+\" \"+k);\n\t\t\tif(r - l <= k) return -1;\n\t\t\tif(s == b) return s;\n\t\t\tint ret = sWav.hasMoreThanKOfOne(k, sPtr[l], sPtr[r]);\n\t\t\tif(ret != -1) return ret;\n\t\t\treturn bWav.hasMoreThanKOfOne(k, l-sPtr[l], r-sPtr[r]);\n\t\t}\n\t\tint kthLowestValue(int k, int l, int r) {\n\t\t\tif(s == b) return s;\n\t\t\tif(sPtr[r] - sPtr[l] < k) return bWav.kthLowestValue(k - sPtr[r] + sPtr[l], l-sPtr[l], r-sPtr[r]);\n\t\t\treturn sWav.kthLowestValue(k, sPtr[l], sPtr[r]);\n\t\t}\n\t}\n}\n", "complexity": "cubic", "problem": "0840_D", "from": "CODEFORCES", "tags": "data structures,probabilities"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.FileNotFoundException;\n\nimport java.io.FileReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.util.Arrays;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class Main {\n\n\tstatic int[] di = {-1,0,1,0};\n\n\tstatic int[] dj = {0,1,0,-1};\n\n\tpublic static void main(String[] args) throws IOException \n\n\t{\n\n\t\tScanner sc = new Scanner(\"input.txt\");\n\n\t\tPrintWriter out = new PrintWriter(\"output.txt\");\n\n\t\tQueue<Pair> q = new LinkedList<Pair>();\n\n\t\tint n = sc.nextInt(),m = sc.nextInt() , k = sc.nextInt();\n\n\t\tboolean [][] vis = new boolean[n][m];\n\n\t\twhile(k-->0)\n\n\t\t\tq.add(new Pair(sc.nextInt()-1,sc.nextInt()-1));\n\n\t\n\n\t\tint ansX = 1 , ansY = 1;\n\n\t\t\n\n\t\twhile(!q.isEmpty())\n\n\t\t{\n\n\t\t\tPair cur = q.poll();\n\n\t\t\tif(vis[cur.i][cur.j])continue;\n\n\t\t\tansX = cur.i ; ansY = cur.j;\n\n\t\t\tvis[cur.i][cur.j] = true;\n\n\t\t\tfor (int i = 0; i < di.length; i++) {\n\n\t\t\t\tint ni = cur.i + di[i] , nj = cur.j + dj[i];\n\n\t\t\t\tif(ni>=0 && ni<n && nj>=0 && nj<m && !vis[ni][nj])\n\n\t\t\t\t\tq.add(new Pair(ni,nj));\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\tout.append(++ansX+\" \"+ ++ansY);\n\n\t\tout.flush();\n\n\t\t\n\n\t}\n\n\tstatic class Pair\n\n\t{\n\n\t\tint i,j;\n\n\t\tpublic Pair(int a,int b) {\n\n\t\t\ti = a; j = b;\n\n\t\t}\n\n\t}\n\n\t\n\n\tstatic class Scanner \n\n\t{\n\n\t\tStringTokenizer st;\n\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic Scanner(String s) throws FileNotFoundException {\n\n\t\t\tbr = new BufferedReader(new FileReader(s));\n\n\t\t}\n\n\t\tpublic String next() throws IOException \n\n\t\t{\n\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\t\t\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\t\t\n\n\t\tpublic double nextDouble() throws IOException {return Double.parseDouble(next());}\t\n\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\n\t}\n\n\t\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jenish\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        APaintTheNumbers solver = new APaintTheNumbers();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class APaintTheNumbers {\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            int n = in.scanInt();\n            int arr[] = new int[n];\n            in.scanInt(arr);\n            CodeX.sort(arr);\n            int ans = 0;\n            boolean vissited[] = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                if (!vissited[i]) {\n                    ans++;\n                    for (int j = 0; j < n; j++) {\n                        if (arr[j] % arr[i] == 0) {\n                            vissited[j] = true;\n                        }\n                    }\n                }\n            }\n\n\n            out.println(ans);\n        }\n\n    }\n\n    static class CodeX {\n        public static void sort(int arr[]) {\n            merge_sort(arr, 0, arr.length - 1);\n        }\n\n        private static void merge_sort(int A[], int start, int end) {\n            if (start < end) {\n                int mid = (start + end) / 2;\n                merge_sort(A, start, mid);\n                merge_sort(A, mid + 1, end);\n                merge(A, start, mid, end);\n            }\n\n        }\n\n        private static void merge(int A[], int start, int mid, int end) {\n            int p = start, q = mid + 1;\n            int Arr[] = new int[end - start + 1];\n            int k = 0;\n\n            for (int i = start; i <= end; i++) {\n                if (p > mid)\n                    Arr[k++] = A[q++];\n\n                else if (q > end)\n                    Arr[k++] = A[p++];\n\n                else if (A[p] < A[q])\n                    Arr[k++] = A[p++];\n\n                else\n                    Arr[k++] = A[q++];\n            }\n            for (int i = 0; i < k; i++) {\n                A[start++] = Arr[i];\n            }\n\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int INDEX;\n        private BufferedInputStream in;\n        private int TOTAL;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (INDEX >= TOTAL) {\n                INDEX = 0;\n                try {\n                    TOTAL = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (TOTAL <= 0) return -1;\n            }\n            return buf[INDEX++];\n        }\n\n        public int scanInt() {\n            int I = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    I *= 10;\n                    I += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * I;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n        public void scanInt(int[] A) {\n            for (int i = 0; i < A.length; i++) A[i] = scanInt();\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class D\n{\n\n\tstatic FastIO f;\n\tstatic long ve[][], he[][];\n\n\tpublic static void main(String args[]) throws IOException\n\t{\n\t\tf = new FastIO();\n\n\t\tint n = f.ni(), m = f.ni(), k = f.ni(), i, j;\n\t\tve = new long[n-1][];\n\t\the = new long[n][];\n\n\t\tlong[][] ans = new long[n][m], pans = new long[n][m], temp;\n\n\t\tfor(i = 0; i < n; i++)\n\t\t\the[i] = f.nla(m-1);\n\n\t\tfor(i = 0; i < n-1; i++)\n\t\t\tve[i] = f.nla(m);\n\n\t\tif(k%2 == 1)\n\t\t{\n\t\t\tfor(i = 0; i < n; i++)\n\t\t\t\tArrays.fill(ans[i], -1L);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk /= 2;\n\n\t\t\twhile(k-->0)\n\t\t\t{\n\t\t\t\tfor(i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(j = 0; j < m; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i][j] = Integer.MAX_VALUE;\n\n\t\t\t\t\t\tif(i != 0)\n\t\t\t\t\t\t\tans[i][j] = Math.min(ans[i][j], pans[i-1][j] + 2*edge(i, j, i-1, j));\n\n\t\t\t\t\t\tif(i != n-1)\n\t\t\t\t\t\t\tans[i][j] = Math.min(ans[i][j], pans[i+1][j] + 2*edge(i, j, i+1, j));\n\n\t\t\t\t\t\tif(j != 0)\n\t\t\t\t\t\t\tans[i][j] = Math.min(ans[i][j], pans[i][j-1] + 2*edge(i, j, i, j-1));\n\n\t\t\t\t\t\tif(j != m-1)\n\t\t\t\t\t\t\tans[i][j] = Math.min(ans[i][j], pans[i][j+1] + 2*edge(i, j, i, j+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// f.err(k + \"\\n\");\n\t\t\t\t// errorprint(ans, n, m);\n\n\t\t\t\ttemp = pans;\n\t\t\t\tpans = ans;\n\t\t\t\tans = temp;\n\t\t\t}\n\n\t\t\ttemp = pans;\n\t\t\tpans = ans;\n\t\t\tans = temp;\n\t\t}\n\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tf.out(ans[i][j] + \" \");\n\t\t\t}\n\n\t\t\tf.out(\"\\n\");\n\t\t}\n\n\t\tf.flush();\n\t}\n\n\tpublic static void errorprint(long[][] p, int n, int m) throws IOException\n\t{\n\t\tint i, j;\n\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tf.err(p[i][j] + \" \");\n\t\t\t}\n\n\t\t\tf.err(\"\\n\");\n\t\t}\n\t\t\n\t\tf.err(\"\\n\");\n\t}\n\n\tpublic static long edge(int i, int j, int x, int y)\n\t{\n\t\tif(i == x)\n\t\t\treturn he[i][Math.min(j, y)];\n\t\telse\n\t\t\treturn ve[Math.min(i, x)][j];\n\t}\n\n\tpublic static class FastIO\n\t{\n\t\tBufferedReader br;\n\t\tBufferedWriter bw, be;\n\t\tStringTokenizer st;\n\n\t\tpublic FastIO()\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t\tbe = new BufferedWriter(new OutputStreamWriter(System.err));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\n\t\tprivate void read() throws IOException\n\t\t{\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t}\n\n\t\tpublic String ns() throws IOException\n\t\t{\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t\tread();\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int ni() throws IOException\n\t\t{\n\t\t\treturn Integer.parseInt(ns());\n\t\t}\n\n\t\tpublic long nl() throws IOException\n\t\t{\n\t\t\treturn Long.parseLong(ns());\n\t\t}\n\n\t\tpublic float nf() throws IOException\n\t\t{\n\t\t\treturn Float.parseFloat(ns());\n\t\t}\n\n\t\tpublic double nd() throws IOException\n\t\t{\n\t\t\treturn Double.parseDouble(ns());\n\t\t}\n\n\t\tpublic char nc() throws IOException\n\t\t{\n\t\t\treturn ns().charAt(0);\n\t\t}\n\n\t\tpublic int[] nia(int n) throws IOException\n\t\t{\n\t\t\tint[] a = new int[n];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\ta[i] = ni();\n\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nla(int n) throws IOException\n\t\t{\n\t\t\tlong[] a = new long[n];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\ta[i] = nl();\n\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[] nca() throws IOException\n\t\t{\n\t\t\treturn ns().toCharArray();\n\t\t}\n\n\t\tpublic void out(String s) throws IOException\n\t\t{\n\t\t\tbw.write(s);\n\t\t}\n\n\t\tpublic void flush() throws IOException\n\t\t{\n\t\t\tbw.flush();\n\t\t\tbe.flush();\n\t\t}\n\n\t\tpublic void err(String s) throws IOException\n\t\t{\n\t\t\tbe.write(s);\n\t\t}\n\t}\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\npublic class Main\n{\n    static double arr[][];\n    public static void main(String[] args)\n    {\n        try\n        {\n            Parserdoubt pd=new Parserdoubt(System.in);\n            PrintWriter pw=new PrintWriter(System.out);\n            int fishes=pd.nextInt();\n            arr=new double[fishes][fishes];\n            for(int i=0;i<fishes;i++)\n                for(int j=0;j<fishes;j++)\n                    arr[i][j]=Double.parseDouble(pd.nextString());\n            double dp[]=new double[(1<<fishes)];\n            dp[dp.length-1]=1.0;\n            for(int c=dp.length-1;c>=0;c--)\n            {\n                int count=Integer.bitCount(c);\n                if(count<=1)\n                    continue;\n                for(int i=0;i<fishes;i++)\n                    for(int j=i+1;j<fishes;j++)\n                    {\n                        if(((1<<i)&c)!=0&&((1<<j)&c)!=0)\n                        {\n                            dp[c&~(1<<j)]+=arr[i][j]*dp[c];\n                            dp[c&~(1<<i)]+=arr[j][i]*dp[c];\n                        }\n                    }\n            }\n            double s=0.0;\n            for(int i=0;i<fishes;i++)\n                s+=dp[1<<i];\n            for(int i=0;i<fishes;i++)\n                dp[1<<i]/=s;\n            int i=0;\n            for(i=0;i<fishes-1;i++)\n                pw.printf(\"%.6f \",dp[1<<i]);\n            pw.printf(\"%.6f\\n\",dp[1<<i]);\n            pw.close();\n        }\n        catch(Exception e)\n        {}\n    }\n}\nclass Parserdoubt\n    {\n       final private int BUFFER_SIZE = 1 << 17;\n\n       private DataInputStream din;\n       private byte[] buffer;\n       private int bufferPointer, bytesRead;\n\n       public Parserdoubt(InputStream in)\n       {\n          din = new DataInputStream(in);\n          buffer = new byte[BUFFER_SIZE];\n          bufferPointer = bytesRead = 0;\n       }\n       public String nextString() throws Exception\n       {\n           StringBuffer sb=new StringBuffer(\"\");\n           byte c = read();\n           while (c <= ' ') c = read();\n           do\n           {\n               sb.append((char)c);\n               c=read();\n           }while(c>' ');\n           return sb.toString();\n       }\n       public char nextChar() throws Exception\n       {\n           byte c=read();\n           while(c<=' ') c= read();\n           return (char)c;\n       }\n       public int nextInt() throws Exception\n       {\n          int ret = 0;\n          byte c = read();\n          while (c <= ' ') c = read();\n          boolean neg = c == '-';\n          if (neg) c = read();\n          do\n          {\n              ret = ret * 10 + c - '0';\n             c = read();\n          } while (c > ' ');\n          if (neg) return -ret;\n          return ret;\n       }\n       public long nextLong() throws Exception\n       {\n          long ret = 0;\n          byte c = read();\n          while (c <= ' ') c = read();\n          boolean neg = c == '-';\n          if (neg) c = read();\n          do\n          {\n              ret = ret * 10 + c - '0';\n             c = read();\n          } while (c > ' ');\n          if (neg) return -ret;\n          return ret;\n       }\n       private void fillBuffer() throws Exception\n       {\n          bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n          if (bytesRead == -1) buffer[0] = -1;\n       }\n\n       private byte read() throws Exception\n       {\n          if (bufferPointer == bytesRead) fillBuffer();\n          return buffer[bufferPointer++];\n       }\n    }\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\tpublic A () throws IOException {\n\t\tString input = r.readLine();\n\t\tint N = Integer.parseInt(input);\n\t\tint [] A = new int [N];\n\t\tinput = r.readLine();\n\t\tString [] S = input.split(\" \");\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tA[i] = Integer.parseInt(S[i]);\n\t\tsolve(N, A);\n\t}\n\t\n\tpublic void solve (int N, int [] A) {\n\t\tt = millis();\n\t\tArrays.sort(A);\n\t\tif (A[N-1] > 1) A[N-1] = 1;\n\t\telse A[N-1] = 2;\n\t\tArrays.sort(A);\n\t\tSystem.out.print(A[0]);\n\t\tfor (int i = 1; i < N; ++i)\n\t\t\tSystem.out.print(\" \" + A[i]);\n\t\tSystem.out.println();\n\t}\n\n\t////////////////////////////////////////////////////////////////////////////////////\n\n\tstatic BufferedReader r;\n\tstatic long t;\n\t\n\tstatic void print2 (Object o) {\n\t\tSystem.out.println(o);\n\t}\n\t\n\tstatic void print (Object o) {\n\t\tprint2(o);\n\t\t//print2((millis() - t) / 1000.0);\n\t\tSystem.exit(0);\n\t}\n\t\n\tstatic void run () throws IOException {\n\t\tr = new BufferedReader(new InputStreamReader(System.in));\n\t\tnew A();\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\trun();\n\t}\n\t\n\tstatic long millis() {\n\t\treturn System.currentTimeMillis();\n\t}\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.* ;\nimport java.util.* ;\nimport java.text.* ;\nimport java.math.* ;\nimport static java.lang.Math.min ;\nimport static java.lang.Math.max ;\nimport static java.lang.Math.sqrt ;\npublic class Codeshefcode{\n\tpublic static void main(String[] args) throws IOException{\n\t\tSolver Machine = new Solver() ;\n\t\tMachine.Solve() ;\n\t\tMachine.Finish() ;\n\t\t// new Thread(null,new Runnable(){\n\t\t// \tpublic void run(){\n\t\t// \t\tSolver Machine = new Solver() ;\n\t\t// \t\ttry{\n\t\t// \t\t\tMachine.Solve() ;\n\t\t// \t\t\tMachine.Finish() ;\n\t\t// \t\t}catch(Exception e){\n\t\t// \t\t\te.printStackTrace() ;\n\t\t// \t\t\tSystem.out.flush() ;\n\t\t// \t\t\tSystem.exit(-1) ;\n\t\t// \t\t}catch(Error e){\n\t\t// \t\t\te.printStackTrace() ;\n\t\t// \t\t\tSystem.out.flush() ;\n\t\t// \t\t\tSystem.exit(-1) ;\n\t\t// \t\t}\n\t\t// \t}\n\t\t// },\"Solver\",1l<<27).start() ;\n\t}\n}\nclass Mod{\n\tstatic long mod=1000000007 ;\n\tstatic long d(long a,long b){ return (a*MI(b))%mod ; }\n\tstatic long m(long a,long b){ return (a*b)%mod ; }\n\tstatic private long MI(long a){ return pow(a,mod-2) ; }\n\tstatic long pow(long a,long b){\n\t\tif(b<0) return pow(MI(a),-b) ;\n\t\tlong val=a ; long ans=1 ;\n\t\twhile(b!=0){\n\t\t\tif((b&1)==1) ans = (ans*val)%mod ; \n\t\t\tval = (val*val)%mod ; \n\t\t\tb/=2 ;\n\t\t}\n\t\treturn ans ;\n\t}\t\n}\nclass pair implements Comparable<pair>{\n\tint x ; int y ; \n\tpair(int x,int y){ this.x=x ; this.y=y ;} \n\tpublic int compareTo(pair p){\n\t\treturn (this.x<p.x ? -1 : (this.x>p.x ? 1 : (this.y<p.y ? -1 : (this.y>p.y ? 1 : 0)))) ;\n\t}\n}\nclass Solver{\n\tReader ip = new Reader(System.in) ;\t  \n\tPrintWriter op = new PrintWriter(System.out) ;\n\tpublic void Solve() throws IOException{\n\t\tint n = ip.i() ; int r = ip.i() ;\n\t\tdouble x[] = new double[n] ;\n\t\tdouble y[] = new double[n] ;\n\t\tfor(int i=0 ; i<n ; i++) x[i] = ip.i() ;\n\t\tfor(int i=0 ; i<n ; i++){\n\t\t\tdouble my = 0 ;\n\t\t\tfor(int j=0 ; j<i ; j++)\n\t\t\t\tmy = max(my,func(x[j],y[j],r,x[i])) ;\n\t\t\ty[i] = my ;\n\t\t}\n\t\tfor(int i=0 ; i<n ; i++) p((y[i]+r)+\" \") ;\n\t\tpln(\"\") ; \n\t}\n\tdouble abd(double x,double y){\n\t\treturn x>y ? x-y : y-x ;\n\t}\n\tdouble func(double x1,double y1,double r,double x2){\n\t\tif(abd(x1,x2)>(2*r)) return 0 ;\n\t\tif(abd(x1,x2)==(2*r)) return y1 ;\n\t\tdouble dx = x1-x2 ; \n\t\tdouble dx2 = dx*dx ; \n\t\tdouble val = sqrt(4*r*r-dx2) ;\n\t\treturn y1+val ;\n\t}\n\tvoid Finish(){\n\t\top.flush();\n\t\top.close();\n\t}\n\tvoid p(Object o){\n\t\top.print(o) ;\n\t}\n\tvoid pln(Object o){\n\t\top.println(o) ;\n\t}\t\t\n}\nclass mylist extends ArrayList<Integer>{}\nclass myset extends TreeSet<Integer>{}\nclass mystack extends Stack<Integer>{}\nclass mymap extends TreeMap<Long,Integer>{}\nclass Reader{\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tReader(InputStream input) {\n\t\treader = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(input) );\n\t\ttokenizer = new StringTokenizer(\"\") ;\n\t}\n\tString s() throws IOException {\n\t\twhile (!tokenizer.hasMoreTokens()){\n\t\t\ttokenizer = new StringTokenizer(\n\t\t\treader.readLine()) ;\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\tint i() throws IOException {\n\t\treturn Integer.parseInt(s()) ;\n\t}\n\tlong l() throws IOException{\n\t\treturn Long.parseLong(s()) ;\n\t}\n\tdouble d() throws IOException {\n\t\treturn Double.parseDouble(s()) ;\n\t}\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            long k=Long.parseLong(br.readLine());\n            long l=1,h=1000000000000l;\n            long p[]=new long[13];\n            for(int i=1;i<=12;i++)\n            {\n                  long ll=9*i;\n                  p[i]=ll*(long)Math.pow(10,i-1);\n                  p[i]+=p[i-1];\n            }\n            while(h-l>1)\n            {\n                  long mid=(l+h)/2;\n                  long num=(long)(Math.log(mid)/Math.log(10));\n                  long l1=p[(int)num]+(num+1)*(mid-(long)Math.pow(10,num));\n                  long l2=p[(int)num]+(num+1)*(mid-(long)Math.pow(10,num)+1);\n                  if(k<=l1)\n                   h=mid;\n                  else if(k>l2)\n                   l=mid;\n                  else\n                  { l=mid; h=mid; }\n            }\n            \n            if(h-l==1)\n            { \n                long num=(long)(Math.log(h)/Math.log(10));\n                long l1=p[(int)num]+(num+1)*(h-(long)Math.pow(10,num));\n                long l2=p[(int)num]+(num+1)*(h-(long)Math.pow(10,num)+1);\n                if(k>l1 && k<=l2)\n                { l=h; }\n            }\n            \n            long n=(long)(Math.log(l)/Math.log(10));\n            long u=p[(int)n]+(n+1)*(l-(long)Math.pow(10,n));\n            k-=u;\n            String ss=String.valueOf(l);\n            //System.out.println(l+\" \"+k);\n            System.out.println(ss.charAt((int)(k-1)));\n      }\n}", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.util.Scanner;\n\n\n\npublic class C {\n\n\tpublic static void main(String[] args) {\n\n\n\n\t\tScanner scan = new Scanner(System.in);\n\n\n\n\t\tlong n = scan.nextLong();\n\n\t\tlong s = scan.nextLong();\n\n\t\tlong low = 0;\n\n\t\tlong high = n + 1;\n\n\t\twhile (high-low>1) {\n\n\t\t\tlong sum = 0;\n\n\t\t\tlong mid = (high + low) / 2;\n\n\t\t\tlong value = findSum(mid, sum);\n\n\t\t\tif (mid - value >= s)\n\n\t\t\t\thigh = mid;\n\n\t\t\telse\n\n\t\t\t\tlow = mid;\n\n\t\t}\n\n\t\t\n\n\t\tSystem.out.println(n - high + 1);\n\n\n\n\t\tscan.close();\n\n\t}\n\n\n\n\tpublic static long findSum(long n, long sum) {\n\n\t\tif (n == 0)\n\n\t\t\treturn sum;\n\n\t\treturn findSum(n / 10, sum + n % 10);\n\n\t}\n\n\n\n}", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint N = Integer.parseInt(br.readLine());\n\t\tString[] s = {\"XXXS\", \"XXS\", \"XS\", \"S\", \"M\", \"L\", \"XL\", \"XXL\", \"XXXL\"};\n\t\tint[] size = new int[9];\n\t\tfor(int i=0; i<N; i++){\n\t\t\tString c = br.readLine();\n\t\t\tfor(int j=0; j<9; j++){\n\t\t\t\tif(s[j].equals(c)){\n\t\t\t\t\tsize[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<N; i++){\n\t\t\tString c = br.readLine();\n\t\t\tfor(int j=0; j<9; j++){\n\t\t\t\tif(s[j].equals(c)){\n\t\t\t\t\tsize[j]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i=0; i<9; i++){\n\t\t\tif(size[i]>0)\n\t\t\t\tsum += size[i];\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n}", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class taskA {\n\n\tvoid solve() throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\n\t\tlong ans = 0;\n\t\twhile (a  != 0 && b != 0) {\n\t\t\tif (a > b) {\n\t\t\t\tans += a / b;\n\t\t\t\ta %= b;\n\t\t\t} else {\n\t\t\t\tlong c = b % a;\n\t\t\t\tans += b / a;\n\t\t\t\tb = a;\n\t\t\t\ta = c;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tBufferedReader br;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\ttry {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\t// br = new BufferedReader(new FileReader(new File(\"taskA.in\")));\n\t\t\t// out = new PrintWriter(\"taskA.out\");\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew taskA().run();\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile ((st == null) || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws NumberFormatException, IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tlong nextLong() throws NumberFormatException, IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int N = in.nextInt();\n            String word = in.next();\n\n            int cnt[] = new int[1000];\n\n            int let = 0;\n            Set<Character> set = new TreeSet<>();\n            for (int i = 0; i < word.length(); i++) {\n                set.add(word.charAt(i));\n            }\n            int uniq = set.size();\n            int i = 0, j = -1;\n            int ans = Integer.MAX_VALUE;\n            while (i < N && j < N) {\n                while (j + 1 < N && let < uniq) {\n                    j++;\n                    if (cnt[word.charAt(j)] == 0) {\n                        let++;\n                    }\n                    cnt[word.charAt(j)]++;\n                }\n                if (let == uniq)\n                    ans = Math.min(ans, j - i + 1);\n                cnt[word.charAt(i)]--;\n                if (cnt[word.charAt(i)] == 0) let--;\n                i++;\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class B implements Runnable {\n\n    int a;\n    int[] b;\n    int[] l;\n\n    public void solve() throws IOException {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        a = in.nextInt();\n        b = new int[n];\n        l = new int[n];\n        for ( int i = 0; i < n; i ++ ) {\n            b[i] = in.nextInt();\n            l[i] = in.nextInt();\n        }\n        out.println( best( 0, k ));\n    }\n\n    double best( int cur, int left ) {\n        double r = 0.0;\n        if ( cur < l.length ) {\n            for ( int i = 0; i <= left && l[cur] + 10 * i <= 100; i ++ ) {\n                l[cur] += i * 10;\n                r = Math.max( r, best( cur + 1, left - i ) );\n                l[cur] -= i * 10;\n            }\n        } else {\n            for ( int m = 0; m < ( 1 << l.length ); m ++ ) {\n                int sum = 0;\n                double p = 1.0;\n                int pro = 0;\n                for ( int i = 0; i < l.length; i ++ ) {\n                    if ( ( m & ( 1 << i ) ) == 0 ) {\n                        p *= 1.0 - l[i] * 0.01;\n                        sum += b[i];\n                    } else {\n                        p *= l[i] * 0.01;\n                        pro ++;\n                    }\n                }\n                if ( pro * 2 > l.length ) {\n                    r += p;\n                } else {\n                    r += ( p * a ) / ( a + sum );\n                }\n            }\n        }\n        return r;\n    }\n\n    public Scanner in;\n\n    public PrintWriter out;\n\n    B() throws IOException {\n        in = new Scanner(System.in);\n        // in = new StreamTokenizer( new InputStreamReader( System.in ) );\n        out = new PrintWriter(System.out);\n    }\n\n//    int nextInt() throws IOException {\n//        in.nextToken();\n//        return ( int ) in.nval;\n//    }\n\n    void check(boolean f, String msg) {\n        if (!f) {\n            out.close();\n            throw new RuntimeException(msg);\n        }\n    }\n\n    void close() throws IOException {\n        out.close();\n    }\n\n    public void run() {\n        try {\n            solve();\n            close();\n        } catch (Exception e) {\n            e.printStackTrace(out);\n            out.flush();\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Thread(new B()).start();\n    }\n}", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        int BUBEN = 120;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            // zzzz\n            Random random = new Random(94739534513L + System.currentTimeMillis());\n            int n = in.nextInt();\n            int q = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++i) {\n                a[i] = in.nextInt();\n            }\n            int buben = (int) Math.round(Math.sqrt(n));\n            TaskD.Query[] queries = new TaskD.Query[q];\n            for (int i = 0; i < q; ++i) {\n                queries[i] = new TaskD.Query();\n                queries[i].l = in.nextInt() - 1;\n                queries[i].r = in.nextInt();\n                queries[i].k = in.nextInt();\n                queries[i].bucket = queries[i].l / buben;\n            }\n            TaskD.Query[] originalQueries = queries.clone();\n            Arrays.sort(queries, new Comparator<TaskD.Query>() {\n\n                public int compare(TaskD.Query o1, TaskD.Query o2) {\n                    if (o1.bucket != o2.bucket) return o1.bucket - o2.bucket;\n                    if (o1.r != o2.r) {\n                        if ((o1.bucket & 1) == 0) return o1.r - o2.r;\n                        else return o2.r - o1.r;\n                    }\n                    return o1.l - o2.l;\n                }\n            });\n            int[] counts = new int[n + 1];\n            int cl = 0;\n            int cr = 0;\n            for (TaskD.Query qq : queries) {\n                while (cr < qq.r) {\n                    ++counts[a[cr++]];\n                }\n                while (cl > qq.l) {\n                    ++counts[a[--cl]];\n                }\n                while (cr > qq.r) {\n                    --counts[a[--cr]];\n                }\n                while (cl < qq.l) {\n                    --counts[a[cl++]];\n                }\n                int res = -1;\n                int need = (qq.r - qq.l) / qq.k + 1;\n                for (int attempt = 0; attempt < BUBEN; ++attempt) {\n                    int x = a[qq.l + random.nextInt(qq.r - qq.l)];\n                    if (counts[x] >= need) {\n                        if (res < 0 || res > x) res = x;\n                    }\n                }\n                qq.answer = res;\n            }\n            for (TaskD.Query qq : originalQueries) {\n                out.println(qq.answer);\n            }\n        }\n\n        static class Query {\n            int l;\n            int r;\n            int k;\n            int answer;\n            int bucket;\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "cubic", "problem": "0840_D", "from": "CODEFORCES", "tags": "data structures,probabilities"}
{"src": "/*\n    JAI MATA DI\n */\n\nimport java.util.*;\n\n//import javax.print.attribute.HashAttributeSet;\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.sql.Array;\n\npublic class CP {\n\t  static class FR{\n\t\t\tBufferedReader br;\n\t\t\tStringTokenizer st;\n\t\t\tpublic FR() {\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t}\n\t\t\tString next() \n\t\t    { \n\t\t        while (st == null || !st.hasMoreElements()) \n\t\t        { \n\t\t            try\n\t\t            { \n\t\t                st = new StringTokenizer(br.readLine()); \n\t\t            } \n\t\t            catch (IOException  e) \n\t\t            { \n\t\t                e.printStackTrace(); \n\t\t            } \n\t\t        } \n\t\t        return st.nextToken(); \n\t\t    } \n\n\t\t    int nextInt() \n\t\t    { \n\t\t        return Integer.parseInt(next()); \n\t\t    } \n\n\t\t    long nextLong() \n\t\t    { \n\t\t        return Long.parseLong(next()); \n\t\t    } \n\n\t\t    double nextDouble() \n\t\t    { \n\t\t        return Double.parseDouble(next()); \n\t\t    } \n\n\t\t    String nextLine() \n\t\t    { \n\t\t        String str = \"\"; \n\t\t        try\n\t\t        { \n\t\t            str = br.readLine(); \n\t\t        } \n\t\t        catch (IOException e) \n\t\t        { \n\t\t            e.printStackTrace(); \n\t\t        } \n\t\t        return str; \n\t\t    } \n\t\t}\n\t static int mod  = 1000000007;\n\t static long gcd(long a, long b)\n\t  {      \n\t     if (b == 0)\n\t        return a;\n\t     return gcd(b, a % b); \n\t  }\n\t static boolean[] prime(int num) {\n\t\t\tboolean[] bool = new boolean[num];\n\t\t     \n\t\t      for (int i = 0; i< bool.length; i++) {\n\t\t         bool[i] = true;\n\t\t      }\n\t\t      for (int i = 2; i< Math.sqrt(num); i++) {\n\t\t         if(bool[i] == true) {\n\t\t            for(int j = (i*i); j<num; j = j+i) {\n\t\t               bool[j] = false;\n\t\t            }\n\t\t         }\n\t\t      }\n\t\t      if(num >= 0) {\n\t\t    \t  bool[0] = false;\n\t\t    \t  bool[1] = false;\n\t\t      }\n\t\t      \n\t\t      return bool;\n\t\t}\n\t static class Pair implements Comparable<Pair>{\n\t\t \tint x;\n\t \t\tint y;\n\t \t\tPair(int key , int value){\n\t \t\t\tthis.x = key;\n\t \t\t\tthis.y = value;\n\t \t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(Pair o) {\n\t\t\t\treturn this.x - o.x;\n\t\t\t}\n//\t\t\t@Override\n//\t\t\tpublic int hashCode(){\n//\t\t\t\treturn val + ind;\n//\t\t\t}\n\t \t}\n\t \t\n\t\n\t public static void main(String args[]) {\n\t\t \n\t\t FR sc = new FR();\n\t\t int n = sc.nextInt() , m = sc.nextInt() , k = sc.nextInt();\n\t\t int[][] arr = new int[n][m];\n\t\t if(k%2 == 1) {\n\t\t\t for(int i = 0 ; i<n ; i++) {\n\t\t\t\t for(int j = 0 ;j<m ; j++) System.out.print(\"-1 \");\n\t\t\t\t System.out.println();\n\t\t\t }\n\t\t\t return;\n\t\t }\n\t\t x = n; y = m;\n\t\t int[][] he = new int[n][m-1];\n\t\t int[][] ve = new int[n-1][m];\n\t\t for(int i = 0 ; i <he.length ; i++) {\n\t\t\t for(int j = 0 ; j<he[0].length ; j++) he[i][j] = sc.nextInt();\n\t\t }\n\t\t for(int i = 0 ; i<ve.length ; i++) {\n\t\t\t for(int j = 0 ; j<ve[0].length ; j++) ve[i][j] = sc.nextInt();\n\t\t }\n\t\t int[][][] dp = new int[n+1][m+1][11];\n\t\tfor(int i = 0 ; i<x ; i++) {\n\t\t\tfor(int j = 0 ; j<y; j++) arr[i][j] = 2*fnc(he, ve, i, j, k/2, dp);\n\t\t}\n\t\tfor(int i = 0 ; i<x;i++) {\n\t\t\tfor(int j = 0 ;j<y;j++) System.out.print(arr[i][j]+\" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t }\n\t static int  x , y;\n\t \n\t static int edge(int[][] he , int[][] ve , int i ,int j , char cc) {\n\t\tif(cc == 'L') {\n\t\t\treturn he[i][j];\n\t\t}\n\t\tif(cc == 'R') {\n\t\t\treturn he[i][j-1];\n\t\t}\n\t\tif(cc == 'U') return ve[i][j];\n\t\t return ve[i-1][j];\n\t\t \n\t }\n\t \n\tstatic int fnc(int[][] he, int[][] ve ,int i , int j , int k ,int[][][] dp) {\n\t\tif(k == 0) return 0;\n\t\tif(dp[i][j][k]!=0) return dp[i][j][k];\n\t\tint tot = Integer.MAX_VALUE;\n\t\tif(i+1 < x) {\n\t\t\ttot = Math.min(tot, fnc(he, ve, i + 1, j,k-1, dp) + edge(he, ve, i+1, j, 'D'));\n\t\t}\n\t\tif(i-1>=0) {\n\t\t\ttot = Math.min(tot, fnc(he, ve, i-1, j, k-1, dp) + edge(he, ve, i-1, j, 'U'));\n\t\t}\n\t\tif(j-1>=0) {\n\t\t\ttot = Math.min(tot, fnc(he, ve, i, j-1, k-1, dp) + edge(he, ve, i, j-1, 'L') );\n\t\t}\n\t\tif(j+1<y) {\n\t\t\ttot = Math.min(tot, fnc(he, ve, i, j+1, k-1, dp) + edge(he, ve, i, j+1, 'R'));\n\t\t}\n\t\tdp[i][j][k] = tot;\n\t\treturn dp[i][j][k];\n\t}\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class _1190_B {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        int n = Integer.parseInt(in.readLine());\n        int[] a = new int[n];\n        StringTokenizer line = new StringTokenizer(in.readLine());\n        for(int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(line.nextToken());\n        }\n        Arrays.sort(a);\n        int dupecount = 0;\n        boolean escape = false;\n        for(int i = 1; i < n; i++) {\n            if(a[i] == a[i - 1]) {\n                dupecount++;\n                if(a[i] > 0 && (i < 2 || a[i - 2] + 1 < a[i])) {\n                    escape = true;\n                }\n            }\n        }\n        if(dupecount > 1 || (dupecount == 1 && !escape)) {\n            out.println(\"cslnb\");\n        }else {\n            long dif = 0;\n            for(int i = 0; i < n; i++) {\n                dif += a[i] - i;\n            }\n            if(dif % 2 == 0) {\n                out.println(\"cslnb\");\n            }else {\n                out.println(\"sjfnb\");\n            }\n        }\n        in.close();\n        out.close();\n    }\n}\n", "complexity": "linear", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "/**\n * Mx 04:06:52 \u0635 14/01/2014\n */\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder line = new StringBuilder(reader.readLine());\n        int length = 0;\n        for (int head = 0; head < line.length(); head++) {\n            for (int tail = line.length() - 1; tail > head; tail--) {\n                String subString = line.substring(head, tail);\n                if(line.indexOf(subString,head+1)>-1){\n                    length = Math.max(subString.length(), length);\n                }\n            }\n        }\n        System.out.println(length);\n    }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner input = new Scanner(System.in);\n\n        int n = input.nextInt();\n        int m = input.nextInt();\n        int [] arr1 = new int [n];\n        int [] arr2 = new int [m];\n        String result = \"\";\n\n        for(int i = 0; i < n; i++){\n            int num1 = input.nextInt();\n            arr1[i] = num1;\n        }\n\n        for(int i = 0; i < m; i++){\n            int num2 = input.nextInt();\n            arr2[i] = num2;\n        }\n\n\n        for(int i = 0; i < arr1.length; i++){\n\n            for(int j = 0; j < arr2.length; j++){\n\n                if(arr1[i] == arr2[j]){\n                    result += String.valueOf(arr1[i]) + \" \";\n\n                }\n            }\n        }\n        \n        System.out.println(result);\n    }\n}\n", "complexity": "quadratic", "problem": "0994_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\nimport com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;\nimport com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;\nimport org.omg.CORBA.INTERNAL;\nimport org.omg.CORBA.MARSHAL;\nimport sun.nio.cs.ext.MacThai;\n\nimport javax.swing.plaf.basic.BasicTreeUI;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class Main {\n    private static Scanner sc;\n    private static Printer pr;\n    static boolean []visited;\n    static int []color;\n    static int []pow=new int[(int)3e5+1];\n    static int []count;\n    static boolean check=true;\n    static boolean checkBip=true;\n    static TreeSet<Integer>[]list;\n    private static long aLong=(long)(Math.pow(10,9)+7);\n    static final long div=998244353;\n    static  int answer=0;\n    static int[]countSubTree;\n    static int[]colorNode;\n    static boolean con=true;\n    static ArrayList<Integer>dfsPath=new ArrayList<>();\n    static ArrayList<Integer>ans=new ArrayList<>();\n    static boolean[]rec;\n    static int min=Integer.MAX_VALUE;\n    static ArrayList<Task>tasks=new ArrayList<>();\n    static  boolean []checkpath;\n    static long []out;\n    static TreeSet<Integer>[]dp;\n    private static void solve() throws IOException {\n        long l=sc.nextLong(),r=sc.nextLong();\n        int maxPow=(int)(Math.log(r)/Math.log(2));\n        long val=(long)Math.pow(2,maxPow);\n        long anss=0;\n        if (l==r)anss=0;\n        else if (r-1==l)anss=l^r;\n        else {\n            while (true){\n                if (val>l&&val<=r){\n                    anss=2l*val-1;\n                    break;\n                }\n                else {\n                    l-=val;\n                    r-=val;\n                    maxPow=(int)(Math.log(r)/Math.log(2));\n                    //pr.println(\"maxp:\"+maxPow+\" l:\"+l+\" r:\"+r+\" val:\"+val);\n                    val=(long)Math.pow(2,maxPow);\n                }\n            }\n        }\n        pr.println(anss);\n    }\n    public static class pp{\n        int val,pos;\n\n        public pp(int val, int pos) {\n            this.val = val;\n            this.pos = pos;\n        }\n    }\n    public static class dsu{\n        int []rank;\n        int[]parent;\n        long []sum;\n        int n;\n        public dsu(int n) {\n            this.n = n;\n            parent=new int[n];\n            rank=new int[n];\n            sum=new long[n];\n            for (int i=0;i<n;++i){\n                rank[i]=1;\n                parent[i]=i;\n                sum[i]=0;\n            }\n        }\n        public int dad(int child){\n            if (parent[child]==child)return child;\n            else return dad(parent[child]);\n        }\n        public void merge(int u,int v){\n            int dadU=dad(u);\n            int dadV=dad(v);\n            if (dadU==dadV)return ;\n            if (u!=v){\n                if (rank[u]<rank[v]){\n                    parent[u]=v;\n                    rank[v]+=rank[u];\n                }\n                else if (rank[u]==rank[v]){\n                    parent[u]=v;\n                    rank[v]+=rank[u];\n                }\n                else{\n                    parent[v]=u;\n                    rank[u]+=rank[v];\n                }\n            }\n        }\n    }\n    public static long power(long x,long y,long mods){\n        if (y==0) return 1%mods;\n        long u=power(x,y/2,mods);\n        u=((u)*(u))%mods;\n        if (y%2==1) u=(u*(x%mods))%mods;\n        return u;\n    }\n    public static class Task implements Comparable<Task>{\n        long l,r;\n        public Task(long w,long v) {\n            this.l=w;\n            this.r=v;\n        }\n\n        @Override\n        public int compareTo(Task o) {\n            if (o.l<this.l)return 1;\n            else if (o.l>this.l)return -1;\n            else {\n                if (o.r>this.r)return 1;\n                else if (o.r<this.r)return -1;\n            }\n            return 0;\n        }\n    }\n    public static void printSolve(StringBuilder str, int[] colors, int n,int color){\n        for(int i = 1;i<=n;++i)\n            if(colors[i] == color)\n                str.append(i + \" \");\n        str.append('\\n');\n    }\n    public static class pairTask{\n        int  val;\n        int size;\n        public pairTask(int   x, int  y) {\n            this.val = x;\n            this.size = y;\n        }\n    }\n    public static void subTree(int src,int parent,int x){\n        countSubTree[src]=1;\n        if (src==x) {\n            checkpath[src]=true;\n            //System.out.println(\"src:\"+src);\n        }\n        else checkpath[src]=false;\n        for (int v:list[src]){\n            if (v==parent)\n                continue;\n            subTree(v,src,x);\n            countSubTree[src]+=countSubTree[v];\n            checkpath[src]|=checkpath[v];\n        }\n    }\n    public static boolean prime(long src){\n        for (int i=2;i*i<=src;i++){\n            if (src%i==0)\n                return false;\n        }\n        return true;\n    }\n    public static void bfsColor(int src){\n        Queue<Integer>queue = new ArrayDeque<>();\n        queue.add(src);\n        while (!queue.isEmpty()){\n            boolean b=false;\n            int vertex=-1,p=-1;\n            int poll=queue.remove();\n            for (int v:list[poll]){\n                if (color [v]==0){\n                    vertex=v;\n                    break;\n                }\n            }\n            for (int v:list[poll]){\n                if (color [v]!=0&&v!=vertex){\n                    p=v;\n                    break;\n                }\n            }\n            for (int v:list[p]){\n                if (color [v]!=0){\n                    color[vertex]=color[v];\n                    b=true;\n                    break;\n                }\n            }\n            if (!b){\n                color[vertex]=color[poll]+1;\n            }\n        }\n    }\n    static int add(int a,int b ){\n        if (a+b>=div)\n            return (int)(a+b-div);\n        return (int)a+b;\n    }\n    public static int isBipartite(ArrayList<Integer>[]list,int src){\n        color[src]=0;\n        Queue<Integer>queue=new LinkedList<>();\n        int []ans={0,0};\n        queue.add(src);\n        while (!queue.isEmpty()){\n            ans[color[src=queue.poll()]]++;\n            for (int v:list[src]){\n                if (color[v]==-1){\n                    queue.add(v);\n                    color[v]=color[src]^1;\n                }else if (color[v]==color[src])\n                    check=false;\n            }\n        }\n        return add(pow[ans[0]],pow[ans[1]]);\n    }\n    public static int powerMod(long b, long e){\n        long ans=1;\n        while (e-->0){\n            ans=ans*b%div;\n        }\n        return (int)ans;\n    }\n    public static int dfs(int s){\n        int ans=1;\n        visited[s]=true;\n        for (int k:list[s]){\n            if (!visited[k]){\n                ans+=dfs(k);\n            }\n        }\n        return ans;\n    }\n    public static int[] radixSort(int[] f) {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] & 0xffff)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] & 0xffff]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] >>> 16)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] >>> 16]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n        return f;\n    }\n    public static long []primeFactor(int n){\n        long []prime=new long[n+1];\n        prime[1]=1;\n        for (int i=2;i<=n;i++)\n            prime[i]=((i&1)==0)?2:i;\n        for (int i=3;i*i<=n;i++){\n            if (prime[i]==i){\n                for (int j=i*i;j<=n;j+=i){\n                    if (prime[j]==j)\n                        prime[j]=i;\n                }\n            }\n        }\n        return prime;\n    }\n    public static StringBuilder binaryradix(long number){\n        StringBuilder builder=new StringBuilder();\n        long remainder;\n        while (number!=0) {\n            remainder = number % 2;\n            number >>= 1;\n            builder.append(remainder);\n        }\n        builder.reverse();\n        return builder;\n    }\n    public static int binarySearch(long[] a, int index,long target) {\n            int l = index;\n            int h = a.length - 1;\n            while (l<=h) {\n                int med = l + (h-l)/2;\n                if(a[med] - target <= target) {\n                    l = med + 1;\n                }\n                else h = med  - 1;\n            }\n            return h;\n    }\n    public static int val(char c){\n        return c-'0';\n    }\n    public static long gcd(long a,long b) {\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n        private static class Pair implements Comparable<Pair> {\n            long x;\n            long y;\n\n            Pair() {\n                this.x = 0;\n                this.y = 0;\n            }\n\n            Pair(long x, long y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            @Override\n            public boolean equals(Object obj) {\n                if (this == obj) {\n                    return true;\n                }\n                if (obj == null) return false;\n                Pair other = (Pair) obj;\n                if (this.x == other.x && this.y == other.y) {\n                    return true;\n                }\n                return false;\n            }\n\n            @Override\n            public int compareTo(Pair other) {\n                if (this.x != other.x) return Long.compare(this.x, other.x);\n                return Long.compare(this.y*other.x, this.x*other.y);\n            }\n    }\n\n    public static void main(String[] args) throws IOException {\n        sc = new Scanner(System.in);\n        pr = new Printer(System.out);\n        solve();\n\n        pr.close();\n       // sc.close();\n    }\n    private static class Scanner {\n        BufferedReader br;\n\n        Scanner (InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        private boolean isPrintable(int ch) {\n            return ch >= '!' && ch <= '~';\n        }\n\n        private boolean isCRLF(int ch) {\n            return ch == '\\n' || ch == '\\r' || ch == -1;\n        }\n\n        private int nextPrintable() {\n            try {\n                int ch;\n                while (!isPrintable(ch = br.read())) {\n                    if (ch == -1) {\n                        throw new NoSuchElementException();\n                    }\n                }\n\n                return ch;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        String next() {\n            try {\n                int ch = nextPrintable();\n                StringBuilder sb = new StringBuilder();\n                do {\n                    sb.appendCodePoint(ch);\n                } while (isPrintable(ch = br.read()));\n\n                return sb.toString();\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        int nextInt() {\n            try {\n                // parseInt from Integer.parseInt()\n                boolean negative = false;\n                int res = 0;\n                int limit = -Integer.MAX_VALUE;\n                int radix = 10;\n\n                int fc = nextPrintable();\n                if (fc < '0') {\n                    if (fc == '-') {\n                        negative = true;\n                        limit = Integer.MIN_VALUE;\n                    } else if (fc != '+') {\n                        throw new NumberFormatException();\n                    }\n                    fc = br.read();\n                }\n                int multmin = limit / radix;\n\n                int ch = fc;\n                do {\n                    int digit = ch - '0';\n                    if (digit < 0 || digit >= radix) {\n                        throw new NumberFormatException();\n                    }\n                    if (res < multmin) {\n                        throw new NumberFormatException();\n                    }\n                    res *= radix;\n                    if (res < limit + digit) {\n                        throw new NumberFormatException();\n                    }\n                    res -= digit;\n\n                } while (isPrintable(ch = br.read()));\n\n                return negative ? res : -res;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        long nextLong() {\n            try {\n                // parseLong from Long.parseLong()\n                boolean negative = false;\n                long res = 0;\n                long limit = -Long.MAX_VALUE;\n                int radix = 10;\n\n                int fc = nextPrintable();\n                if (fc < '0') {\n                    if (fc == '-') {\n                        negative = true;\n                        limit = Long.MIN_VALUE;\n                    } else if (fc != '+') {\n                        throw new NumberFormatException();\n                    }\n                    fc = br.read();\n                }\n                long multmin = limit / radix;\n\n                int ch = fc;\n                do {\n                    int digit = ch - '0';\n                    if (digit < 0 || digit >= radix) {\n                        throw new NumberFormatException();\n                    }\n                    if (res < multmin) {\n                        throw new NumberFormatException();\n                    }\n                    res *= radix;\n                    if (res < limit + digit) {\n                        throw new NumberFormatException();\n                    }\n                    res -= digit;\n\n                } while (isPrintable(ch = br.read()));\n\n                return negative ? res : -res;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            try {\n                int ch;\n                while (isCRLF(ch = br.read())) {\n                    if (ch == -1) {\n                        throw new NoSuchElementException();\n                    }\n                }\n                StringBuilder sb = new StringBuilder();\n                do {\n                    sb.appendCodePoint(ch);\n                } while (!isCRLF(ch = br.read()));\n\n                return sb.toString();\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n            }\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class List {\n        String Word;\n        int length;\n\n        List(String Word, int length) {\n            this.Word = Word;\n            this.length = length;\n        }\n    }\n    private static class Printer extends PrintWriter {\n        Printer(PrintStream out) {\n            super(out);\n        }\n    }\n}", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "\nimport java.util.*;\npublic class Main {\n\tstatic char kk[] = new char[100010];\n\tstatic String to26(int x){\n\t\tint t = 0;\n\t\tint cnt = 0;\n\t\twhile(x != 0){\n\t\t\tint k = x%26;\n\t\t\tif(k != 0)\n\t\t\t    kk[cnt++] = (char)(k+'A'-1);\n\t\t\telse{\n\t\t\t\tkk[cnt++] = 'Z';\n\t\t\t\tx -= 26;\n\t\t\t}\n\t\t\tx /= 26;\n\t\t}\n\t\tchar tt[] = new char[cnt];\n\t\tint j = 0;\n\t\tfor(int i = cnt-1;i >= 0;i--)\n\t\t\ttt[j++] = kk[i];\n\t\treturn String.valueOf(tt);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tString s = sc.next();\n\t\t\tif(s.charAt(0) == 'R' && s.charAt(1) >= '0' && s.charAt(1) <= '9' && s.indexOf('C') != -1){\n\t\t\t\tString a[] = s.split(\"\\\\D+\");\n\t\t\t\tint t = Integer.valueOf(a[2]);\n\t\t\t\tSystem.out.println(to26(t)+a[1]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint ans = 0;\n\t\t\t\tString t1[] = s.split(\"\\\\D+\");\n\t\t\t\tint k = 0;\n\t\t\t\tfor(int j = s.length()-1;j >= 0;j--)\n\t\t\t\t\tif(s.charAt(j) >= 'A' && s.charAt(j) <= 'Z')\n\t\t\t\t\t\tans += (s.charAt(j)-'A'+1)*Math.pow(26,k++);\n\t\t\t\tSystem.out.print(\"R\"+t1[1]+\"C\");\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n}", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class a{\n    static BufferedReader br;\n    static PrintWriter pw;\n    static int N, M, K;\n    static ArrayList<Integer> graph[][];\n    public static void main(String args[]) throws IOException{\n        br = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        N = Integer.parseInt(st.nextToken());\n        M = Integer.parseInt(st.nextToken());\n        K = Integer.parseInt(st.nextToken());\n        if(K % 2 == 1){\n            for(int i = 0; i < N; i++){\n                for(int j = 0; j < M; j++){\n                    pw.print(\"-1 \");\n                }\n                pw.println();\n            }\n            br.close(); pw.close();\n            return;\n        }\n        graph = new ArrayList[N][M];\n        for(int i = 0; i < N; i++){\n            for(int j = 0; j < M; j++){\n                graph[i][j] = new ArrayList<Integer>();\n            }\n        }\n        for(int i = 0; i < N; i++){\n            st = new StringTokenizer(br.readLine());\n            for(int j = 0; j < M-1; j++){\n                int w = Integer.parseInt(st.nextToken());\n                graph[i][j].add(w);\n            }\n        }\n        for(int i = 0; i < N; i++){\n            graph[i][M-1].add(0);\n        }\n        for(int i = 0; i < N-1; i++){\n            st = new StringTokenizer(br.readLine());\n            for(int j = 0; j < M; j++){\n                int w = Integer.parseInt(st.nextToken());\n                graph[i][j].add(w);\n            }\n        }\n        K /= 2;\n        for(int i = 0; i < M; i++) graph[N-1][i].add(0);\n        long ans[][][] = new long[K+1][N][M];\n        for(int i = 0; i < N; i++){\n            Arrays.fill(ans[0][i], 0);\n        }\n        for(int i = 1; i <= K; i++){\n            for(int x = 0; x < N; x++){\n                for(int y = 0; y < M; y++){\n                    long cur = (long)1e17;\n                    if(x < N-1){\n                        cur = (long)Math.min(cur, graph[x][y].get(1) + ans[i-1][x+1][y]);\n                    }\n                    if(y < M-1){\n                        cur = (long)Math.min(cur, graph[x][y].get(0) + ans[i-1][x][y+1]);\n                    }\n                    if(x > 0){\n                        cur = (long)Math.min(cur, graph[x-1][y].get(1) + ans[i-1][x-1][y]);\n                        //pw.println(\"CUR: \" + cur + \" X: \" + x + \" Y: \" + y + \" get = \" + graph[x-1][y].get(0));\n                    }\n                    if(y > 0){\n                        cur = (long)Math.min(cur, graph[x][y-1].get(0) + ans[i-1][x][y-1]);\n                    }\n                    ans[i][x][y] = cur;\n                }\n            }\n        }\n        for(int i = 0; i < N; i++){\n            for(int j = 0; j < M; j++){\n                pw.print(ans[K][i][j] * 2 + \" \");\n            }\n            pw.println();\n        }\n        br.close(); pw.close();\n    }\n    static class pii implements Comparable<pii>{\n        int f, s, k;\n        pii(int f, int s, int k){\n            this.f = f;\n            this.s = s;\n            this.k = k;\n        }\n        public int compareTo(pii x){\n            return Integer.compare(f, x.f);\n        }\n    }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.Scanner;\n\n\npublic class R025A {\n\tint n;\n\tint[] nums;\n\tpublic R025A() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tnums = new int[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tnums[i] = scanner.nextInt();\n\t\t}\n\t}\n\n\tprivate void process() {\n\t\tint[] c = new int[2];\n\t\tint[] r = new int[2];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tc[nums[i] % 2]++;\n\t\t\tif(r[nums[i] %2] == 0) {\n\t\t\t\tr[nums[i] % 2] = i+1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r[c[0]==1 ? 0 : 1]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew R025A().process();\n\t}\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\n/**\n * Created by IntelliJ IDEA.\n * User: piyushd\n * Date: Dec 5, 2010\n * Time: 4:09:41 PM\n * To change this template use File | Settings | File Templates.\n */\npublic class HamstersTigers {\n    private BufferedReader in;\n    private PrintWriter out;\n    private StringTokenizer st;\n\n\tint solve(String a, int k){\n\t\tint n = a.length(), ret = 0;\n\t\tint temp[] = new int[n];\n\t\tfor(int i = 0; i < n; i++) temp[(n + i - k) % n] = (a.charAt(i) == 'T') ? 1: 0;\n\t\tint left = 0, right = n - 1;\n\t\twhile(left < right){\n\t\t\twhile(temp[left] == 0) left++;\n\t\t\twhile(temp[right] == 1) right--;\n\t\t\tif(left < right){\n\t\t\t\tint t = temp[left];\n\t\t\t\ttemp[left] = temp[right];\n\t\t\t\ttemp[right] = t;\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n    void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tString a = next();\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int fix = 0; fix < n; fix++){\n\t\t\tans = Math.min(ans, solve(a, fix));\n\t\t}\n\t\tout.println(ans);\n    }\n\n    HamstersTigers() throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        //in  = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"C://Users/piyushd/Desktop/codeforces/sample.txt\"))));\n        out = new PrintWriter(System.out);\n\n        eat(\"\");\n\n        solve();\n\n        in.close();\n        out.close();\n    }\n\n    private void eat(String str) {\n        st = new StringTokenizer(str);\n    }\n\n    String next() throws IOException {\n        while (!st.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) {\n                return null;\n            }\n            eat(line);\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new HamstersTigers();\n    }\n}\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int k = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = in.nextInt();\n        Arrays.sort(a);\n        if (k >= m) {\n            out.println(0);\n            return;\n        }\n        for (int i = 1; i <= n; i++) {\n            int sockets = k - 1;\n            for (int j = 0; j < i; j++)\n                sockets += a[n - j - 1];\n            sockets -= i - 1;\n            if (sockets >= m) {\n                out.println(i);\n                return;\n            }\n        }\n        out.println(-1);\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A implements Runnable {\n    private MyScanner in;\n    private PrintWriter out;\n\n    private void solve() {\n        int n = in.nextInt();\n        int[] a = new int[n];\n        int all = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = in.nextInt();\n            all += a[i];\n        }\n        Arrays.sort(a);\n        int sum = 0, ans = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            sum += a[i];\n            ++ans;\n            if (sum > all - sum) {\n                break;\n            }\n        }\n        out.println(ans);\n    }\n\n    @Override\n    public void run() {\n        in = new MyScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        in.close();\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new A().run();\n    }\n\n    static class MyScanner {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return null;\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() {\n            try {\n                st = null;\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public boolean hasNext() {\n            if (st != null && st.hasMoreTokens()) {\n                return true;\n            }\n            try {\n                while (br.ready()) {\n                    st = new StringTokenizer(br.readLine());\n                    if (st != null && st.hasMoreTokens()) {\n                        return true;\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return false;\n        }\n    }\n}", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakhar897\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        APaintTheNumbers solver = new APaintTheNumbers();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class APaintTheNumbers {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int arr[] = in.nextIntArray(n);\n            Arrays.sort(arr);\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (arr[i] == -1)\n                    continue;\n                else {\n                    //out.println(arr[i]);\n                    ans++;\n                    for (int j = i + 1; j < n; j++) {\n                        if (arr[j] % arr[i] == 0)\n                            arr[j] = -1;\n                    }\n                    arr[i] = -1;\n                    //out.println(arr);\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n\n    public static Stack<Integer> s = new Stack<>();\n\n    public static StringBuilder stackToString() {\n        StringBuilder sb = new StringBuilder();\n        Iterator<Integer> it = s.iterator();\n        while (it.hasNext()) {\n            sb.append(it.next());\n            sb.append(it.hasNext() ? \".\" : \"\\n\");\n        }\n        return sb;\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        int ntc = Integer.parseInt(br.readLine());\n        for (int tc = 1; tc <= ntc; tc++) {\n            s.clear();\n            s.push(1);\n            out.append(stackToString());\n            int n = Integer.parseInt(br.readLine());\n            br.readLine();  // first one gets discarded\n            for (int i = 0; i < n-1; i++) {\n                int x = Integer.parseInt(br.readLine());\n                if (x == 1) s.push(x);\n                else if (x == s.peek()+1) {\n                    s.pop();\n                    s.push(x);\n                }\n                else {\n                    while (s.pop() != x-1);\n                    s.push(x);\n                }\n                out.append(stackToString());\n            }\n        }\n        System.out.print(out);\n    }\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.util.*;\npublic class Main {\n\tstatic int a[][],n;\n\tstatic boolean isClique[];\n\tstatic int maxClique[];\n\tstatic void DFS1(int p,int n,int S)\n\t{\n\t\tif(p>n)\n\t\t{\n\t\t\tisClique[S]=true;\n\t\t\treturn ;\n\t\t}\n\t\tDFS1(p+1,n,S);\n\t\tboolean mark=true;\n\t\tfor(int i=1;i<p;++i)\n\t\t\tif((S>>(i-1)&1)==1&&a[p][i]==0)\n\t\t\t\tmark=false;\n\t\tif(mark)\n\t\t\tDFS1(p+1,n,1<<(p-1)|S);\n\t}\n\tstatic void DFS2(int p,int n,int m,int S)\n\t{\n\t\tif(p>n)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int i=m;i<=n;++i)\n\t\t\t\tif((S>>(i-m)&1)==1)\n\t\t\t\t\t++cnt;\n\t\t\tmaxClique[S]=cnt;\n\t\t\treturn ;\n\t\t}\n\t\tDFS2(p+1,n,m,S);\n\t\tboolean mark=true;\n\t\tfor(int i=m;i<p;++i)\n\t\t\tif((S>>(i-m)&1)==1&&a[p][i]==0)\n\t\t\t\tmark=false;\n\t\tif(mark)\n\t\t\tDFS2(p+1,n,m,1<<(p-m)|S);\n\t}\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tn=Integer.parseInt(sc.next());\n\t\ta=new int [n+10][n+10];\n\t\tint cap=Integer.parseInt(sc.next());\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t\ta[i][j]=Integer.parseInt(sc.next());\n\t\tint m=(n+1)>>1;\n\t\tisClique=new boolean [1<<m];\n\t\tArrays.fill(isClique,false);\n\t\tDFS1(1,m,0);\n\t\tmaxClique=new int [1<<(n-m)];\n\t\tArrays.fill(maxClique,0);\n\t\tDFS2(m+1,n,m+1,0);\n\t\tfor(int i=1;i<1<<(n-m);++i)\n\t\t\tfor(int j=m+1;j<=n;++j)\n\t\t\t\tif((i>>(j-m-1)&1)==1)\n\t\t\t\t\tmaxClique[i]=Math.max(maxClique[i],maxClique[i-(1<<(j-m-1))]);\n\t\tint ans=0,tmp[]=new int [m+10];\n\t\tfor(int i=0;i<1<<m;++i)\n\t\t\tif(isClique[i])\n\t\t\t{\n\t\t\t\tint mask=0,cnt=0;\n\t\t\t\tfor(int j=1;j<=m;++j)\n\t\t\t\t\tif((i>>(j-1)&1)==1)\n\t\t\t\t\t\ttmp[++cnt]=j;\n\t\t\t\tfor(int j=m+1;j<=n;++j)\n\t\t\t\t{\n\t\t\t\t\tboolean mark=true;\n\t\t\t\t\tfor(int k=1;k<=cnt;++k)\n\t\t\t\t\t\tif(a[j][tmp[k]]==0)\n\t\t\t\t\t\t\tmark=false;\n\t\t\t\t\tif(mark)\n\t\t\t\t\t\tmask|=1<<(j-m-1);\n\t\t\t\t}\n\t\t\t\tans=Math.max(ans,cnt+maxClique[mask]);\n\t\t\t}\n\t\tSystem.out.printf(\"%.9f\\n\",cap*cap*(ans-1)/2.0/ans);\n\t}\n}\n", "complexity": "np", "problem": "0839_E", "from": "CODEFORCES", "tags": "brute force,graphs,math,meet-in-the-middle"}
{"src": "\nimport java.util.Scanner;\n\npublic class A {\n\n    public static void main(String args[]) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int f1 = 0;\n        int f2 = 1;\n        int f3 = 1;\n        while (f3 < n) {\n            f1 = f2;\n            f2 = f3;\n            f3 = f1 + f2;\n        }\n        if (n == 0) {\n            System.out.println(0 + \" \" + 0 + \" \" + 0);\n        } else if (f3 == n) {\n            System.out.println(f1 + \" \" + f1 + \" \" + (f2 - f1));\n        } else {\n            System.out.println(\"I'm too stupid to solve this problem\");\n        }\n    }\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.util.*;\npublic class A\n{\n    public static int palin(String str)\n    {\n        int flag=0;\n        int l=str.length();\n        for(int i=0;i<l/2;i++)\n        {\n            if(str.charAt(i)!=str.charAt(l-i-1))\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==1)\n        return 0;\n        else\n        return 1;\n    }\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        String str=sc.next();\n        HashSet<Character> hs=new HashSet<>();\n        for(int i=0;i<str.length();i++)\n        {\n            hs.add(str.charAt(i));\n        }\n        if(hs.size()==1)\n        System.out.println(0);\n        else if(palin(str)==0)\n        System.out.println(str.length());\n        else\n        System.out.println(str.length()-1);\n    }\n}", "complexity": "linear", "problem": "0981_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String [] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int numbers[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            numbers[i] = scanner.nextInt();\n        }\n        scanner.close();\n        Arrays.sort(numbers);\n\n        boolean[] colored = new boolean[n];\n        int res = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (!colored[i]) {\n                res += 1;\n            }\n            for (int j = i; j < n; j++) {\n                if (numbers[j] % numbers[i] == 0) {\n                    colored[j] = true;\n                }\n            }\n        }\n\n        System.out.println(res);\n    }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.io.IOException;\n\npublic class kresz {\n\tpublic static double a;\n\tpublic static double v;\n\tpublic static double l;\n\tpublic static double d;\n\tpublic static double w;\n\t\t\n\tpublic static double gyorsulut (double v1, double v2) { //v1 -> v2 mennyi utat tesz meg\n\t\treturn Math.abs((v2*v2-v1*v1)/(2*a));\n\t}\n\tpublic static double gyorsulido (double v1, double v2) { //v1 -> v2 mennyi id\u0151\n\t\treturn Math.abs((v2-v1)/a);\n\t}\n\t\n\t\n\tpublic static void beolvas () throws IOException {\n\t\tScanner be = new Scanner (new InputStreamReader (System.in));\n\t\t\ta = be.nextDouble();\n\t\t\tv = be.nextDouble();\n\t\t\tl = be.nextDouble();\n\t\t\td = be.nextDouble();\n\t\t\tw = be.nextDouble();\n\t\tbe.close();\n\t}\n\t\n\t\n\tpublic static void main (String args[]) throws IOException {\n\t\t\tbeolvas();\n\t\t\tdouble s = l; //h\u00e1tral\u00e9v\u0151 \u00fat\n\t\t\tdouble t = 0; //eltelt id\u0151\n\t\t\t\n\t\t\tif (v <= w ||  Math.sqrt(2*a*d) <= w) { //nincs korl\u00e1toz\u00e1s\n\t\t\t\tif (gyorsulut(0,v) > l) {\n\t\t\t\t\tt+=gyorsulido(0, Math.sqrt(2*a*l));\n\t\t\t\t\ts = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts-=gyorsulut(0,v);\n\t\t\t\t\tt+=gyorsulido(0,v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\n\t\t\t\t//gyorsul\u00f3 szakaszok a korl\u00e1toz\u00e1sig\n\t\t\t\tif (d < gyorsulut(0,v)+gyorsulut(v,w)) {\n\t\t\t\t\tdouble x = Math.sqrt(a*(d-w*w/(2*a))+w*w);\n\t\t\t\t\ts-=gyorsulut(0,w)+2*gyorsulut(w,x);\n\t\t\t\t\tt+=gyorsulido(0,w)+2*gyorsulido(w,x);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts-=gyorsulut(0,v)+gyorsulut(w,v);\n\t\t\t\t\tt+=gyorsulido(0,v)+gyorsulido(w,v);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//gyorsul\u00f3 szakaszok a korl\u00e1toz\u00e1st\u00f3l\n\t\t\t\tif (gyorsulut(v,w) > l-d) {\n\t\t\t\t\tdouble y = Math.sqrt(2*a*(l-d)+w*w);\n\t\t\t\t\ts-= gyorsulut(w,y);\n\t\t\t\t\tt+=gyorsulido(w,y);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts-=gyorsulut(w,v);\n\t\t\t\t\tt+=gyorsulido(w,v);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tt+=s/v; //nem gyorsul\u00f3 szakaszok ideje\n\t\t\t\n\t\t\tSystem.out.println(t);\n\t\t\t\n\t}\n\t\n}\n", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "//package A;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String args[]) throws IOException {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int k = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; ++i)\n            a[i] = in.nextInt();\n        Arrays.sort(a);\n        \n        int res = 0, p = n - 1;\n        while (k < m && p >= 0) {\n            ++res;\n            k += a[p] - 1;\n            --p;\n        }\n        if (k >= m)\n            System.out.println(res);\n        else\n            System.out.println(\"-1\");\n    }\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n\npublic class PetyaAndOrigami {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tint red=2,green=5;int blue=8;\n\t\tStringTokenizer st=new StringTokenizer(br.readLine());\n\t\tint friend=Integer.parseInt(st.nextToken());\n\t\tint nsheet=Integer.parseInt(st.nextToken());\n\t\t\n\t\tint r=nsheet,g=nsheet,b=nsheet;\n\t\tint j=1;\n\t\twhile(r<red*friend)\n\t\t{\n\t\t\tr=nsheet*++j;\n\t\t}\n\t\tint sum=j;\n\t\t\n\t\tj=1;\n\t\twhile(g<green*friend)\n\t\t{\n\t\t\tg=nsheet*++j;\n\t\t}\n\t\tsum+=j;\n\t\t\n\t\tj=1;\n\t\twhile(b<blue*friend)\n\t\t{\n\t\t\tb=nsheet*++j;\n\t\t}\n\t\tsum+=j;\n\t\t\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\n}\n", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class tree_small_distance {\n\n\tstatic ArrayList<Integer> [] adj; static int [][] dp; static int ans;\n\t\n    public static void main(String[] args) throws Exception{\n    \t\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        \n        StringTokenizer line = new StringTokenizer(in.readLine());\n        \n        int n = Integer.parseInt(line.nextToken());\n        \n        adj = new ArrayList[n + 1];\n        \n        for (int i = 1; i <= n; i++) {\n        \tadj[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n        \tline = new StringTokenizer(in.readLine());\n            int x = Integer.parseInt(line.nextToken()); \n            int y = Integer.parseInt(line.nextToken());\n            adj[x].add(y); adj[y].add(x);\n        }\n        \n        dp = new int[n + 1][3]; ans = 0;\n        for (int [] arr: dp) {\n            Arrays.fill(arr, Integer.MAX_VALUE / 2);\n        }\n        \n        dfs(1, -1, 0);\n        out.println(ans);\n        out.close();\n    }\n \n    static void dfs(int cur, int par, int dep) {\n    \t\n        for (Integer next: adj[cur]) {\n            if (next != par) {\n                dfs(next, cur, dep + 1);\n            }\n        }\n        \n        if (dep == 0) {\n        \treturn;\n        }\n        \n        if (dep == 1) {\n            dp[cur][0] = 0;\n            for (Integer next: adj[cur]) {\n                if (next != par) {\n                    dp[cur][0] += Math.min(dp[next][0], dp[next][1]);\n                }\n            }\n            ans += dp[cur][0];\n        } else if (dep == 2) {\n            dp[cur][0] = 0; dp[cur][1] = 0;\n            for (Integer next: adj[cur]) {\n                if (next != par) {\n                    dp[cur][0] += Math.min(dp[next][0], dp[next][1]);\n                    dp[cur][1] += Math.min(dp[next][0], dp[next][2]);\n                }\n            }\n            dp[cur][0]++;\n        } else {\n            int temp = 0; dp[cur][0] = 0; dp[cur][1] = 0;\n            for (Integer next: adj[cur]) {\n                if (next != par) {\n                    dp[cur][0] += Math.min(dp[next][0], dp[next][1]);\n                    dp[cur][1] += Math.min(dp[next][0], dp[next][2]);\n                    temp += Math.min(dp[next][0], dp[next][2]);\n                }\n            }\n            \n            for (Integer next: adj[cur]) {\n                if (next != par) {\n                    dp[cur][2] = Math.min(dp[cur][2], temp - Math.min(dp[next][0], dp[next][2]) + dp[next][0]);\n                }\n            }\n            dp[cur][0]++;\n        }\n    }\n\t\n}\n", "complexity": "linear", "problem": "1029_E", "from": "CODEFORCES", "tags": "dp,graphs,greedy"}
{"src": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class d {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint N = in.nextInt();\n\t\tint[] arr = new int[N];\n\t\tfor(int n=0;n<N;n++){\n\t\t\tarr[n] = in.nextInt();\n\t\t}\n\t\t\n\t\tWavelet waveyMcWaveFace = new Wavelet(arr);\n\t\t\n\t\tBigInteger bigSum = BigInteger.ZERO;\n\t\tfor(int n=0;n<N;n++){\n\t\t\t// calculate the amount added for all j = n all at once\n\t\t\t// it's a[j] - a[i]\n\t\t\t\n\t\t\t// step one\n\t\t\t// positive part\n\t\t\tlong amtPlus = arr[n] * (long)(waveyMcWaveFace.numValsBtwn(1, arr[n] - 2, 0, n)\n\t\t\t\t\t\t\t\t\t\t+ waveyMcWaveFace.numValsBtwn(arr[n] + 2, 2147483647, 0, n));\n\t\t\t\n\t\t\t// step two\n\t\t\t// negative part\n\t\t\tlong amtMinus = waveyMcWaveFace.sumOfValsBtwn(1, arr[n] - 2, 0, n)\n\t\t\t\t\t\t\t+ waveyMcWaveFace.sumOfValsBtwn(arr[n] + 2, 2147483647, 0, n);\n\t\t\t\n//\t\t\tSystem.out.println(amtPlus+\" \"+amtMinus);\n\t\t\tbigSum = bigSum.add(new BigInteger(\"\"+(amtPlus - amtMinus)));\n\t\t}\n\t\t\n\t\tSystem.out.println(bigSum);\n\t}\n\tstatic class Wavelet{\n\t\tint l = 2147483647, h = -2147483648;\n\t\tint[] arr, ldex, hdex;\n\t\tlong[] sum;\n\t\tWavelet low = null, high = null;\n\t\tWavelet(int[] arr){\n\t\t\tthis.arr = arr;\n\t\t\tfor(int i : arr){\n\t\t\t\tl = Math.min(l, i);\n\t\t\t\th = Math.max(h, i);\n\t\t\t}\n\t\t\tldex = new int[arr.length + 1];\n\t\t\thdex = new int[arr.length + 1];\n\t\t\tsum = new long[arr.length + 1];\n\t\t\tint mid = l + (h - l) / 2;\n\t\t\tfor(int n = 0; n < arr.length; n++){\n\t\t\t\tsum[n+1] = sum[n] + arr[n];\n\t\t\t\tif(arr[n] > mid){\n\t\t\t\t\tldex[n+1] = ldex[n];\n\t\t\t\t\thdex[n+1] = hdex[n] + 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tldex[n+1] = ldex[n] + 1;\n\t\t\t\t\thdex[n+1] = hdex[n];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(l == h) return;\n\t\t\tint[] larr = new int[ldex[arr.length]];\n\t\t\tint[] harr = new int[hdex[arr.length]];\n\t\t\tfor(int n=0;n<arr.length;n++){\n\t\t\t\tif(hdex[n] == hdex[n+1]){\n\t\t\t\t\tlarr[ldex[n]] = arr[n];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tharr[hdex[n]] = arr[n];\n\t\t\t\t}\n\t\t\t}\n\t\t\tlow = new Wavelet(larr);\n\t\t\thigh = new Wavelet(harr);\n\t\t}\n\t\t// range [ll, rr)\n\t\tint kthLowest(int k, int ll, int rr){\n\t\t\tif(l == h){\n\t\t\t\treturn arr[ll + k-1];\n\t\t\t}\n\t\t\tif(ldex[rr] - ldex[ll] >= k){\n\t\t\t\treturn low.kthLowest(k, ldex[ll], ldex[rr]);\n\t\t\t}\n\t\t\treturn high.kthLowest(k - ldex[rr] + ldex[ll], hdex[ll], hdex[rr]);\n\t\t}\n\t\t// number of values in between [lo, hi] in range [ll, rr)\n\t\tint numValsBtwn(int lo, int hi, int ll, int rr){\n\t\t\tif(hi < lo) return 0;\n\t\t\tif(lo <= l && h <= hi){\n\t\t\t\treturn rr - ll;\n\t\t\t}\n\t\t\tif(l == h) return 0;\n\t\t\tif(hi < high.l){\n\t\t\t\treturn low.numValsBtwn(lo, hi, ldex[ll], ldex[rr]);\n\t\t\t}\n\t\t\tif(low.h < lo){\n\t\t\t\treturn high.numValsBtwn(lo, hi, hdex[ll], hdex[rr]);\n\t\t\t}\n\t\t\treturn low.numValsBtwn(lo, hi, ldex[ll], ldex[rr])\n\t\t\t\t\t+ high.numValsBtwn(lo, hi, hdex[ll], hdex[rr]);\n\t\t}\n\t\t// sum of values between [lo, hi] in range [ll, rr)\n\t\tlong sumOfValsBtwn(int lo, int hi, int ll, int rr){\n\t\t\tif(lo <= l && h <= hi){\n\t\t\t\treturn sum[rr] - sum[ll];\n\t\t\t}\n\t\t\tif(l == h) return 0;\n\t\t\tif(hi < high.l){\n\t\t\t\treturn low.sumOfValsBtwn(lo, hi, ldex[ll], ldex[rr]);\n\t\t\t}\n\t\t\tif(low.h < lo){\n\t\t\t\treturn high.sumOfValsBtwn(lo, hi, hdex[ll], hdex[rr]);\n\t\t\t}\n\t\t\treturn low.sumOfValsBtwn(lo, hi, ldex[ll], ldex[rr])\n\t\t\t\t\t+ high.sumOfValsBtwn(lo, hi, hdex[ll], hdex[rr]);\n\t\t}\n\t}\n}\n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "//package learning;\n\nimport java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\npublic class NitsLocal {\n    static ArrayList<String> s1;\n    static boolean[] prime;\n    static int n = (int)1e7;\n     static void sieve() {\nArrays.fill(prime\t, true);\nprime[0] = prime[1] = false;\nfor(int i = 2 ; i * i <= n ; ++i) {\nif(prime[i]) {\nfor(int k = i * i; k<= n ; k+=i) {\nprime[k] = false;\n}\n}\n}\n\n}\n    public static void main(String[] args) {\n        InputReader sc = new InputReader(System.in);\n        \n           prime  = new boolean[n + 1];\nsieve();\n                prime[1] = false;\n         \n          \n             long n = sc.nl();\n             long k = sc.nl();\n             long b = 2*n + 3;\n             long c = n*n - 2*k + n;\n             long q1 = (b + (long)Math.sqrt(b*b - 4*c))/2;\n             long q2 = (b - (long)Math.sqrt(b*b - 4*c))/2;\n             if(q1 >= q2 && q1 <= n)\n                 w.println(q1);\n             else\n                 w.println(q2);\n                 \n                \n       \n             \n       w.close();\n        \n    }\n    static int nextPowerOf2(int n) \n    { \n        int count = 0; \n  \n        // First n in the below  \n        // condition is for the  \n        // case where n is 0 \n        if (n > 0 && (n & (n - 1)) == 0) \n            return n; \n  \n        while(n != 0) \n        { \n            n >>= 1; \n            count += 1; \n        } \n  \n        return 1 << count; \n    } \n    \n   static long sum1(int t1,int t2,int x,int []t)\n   {\n       int mid = (t2-t1+1)/2;\n  if(t1==t2)\n      return 0;\n    \n   else\n   return sum1(t1,mid-1,x,t) + sum1(mid,t2,x,t);\n    \n     \n   }\n  \n   \n    static String replace(String s,int a,int n)\n    {\n        char []c = s.toCharArray();\n        for(int i=1;i<n;i+=2)\n        {\n            int num = (int) (c[i] - 48);\n            num += a;\n            num%=10;\n            c[i] = (char) (num+48);\n        }\n        return new String(c);\n    }\n    static String move(String s,int h,int n)\n    {\n        h%=n;\n        char []c = s.toCharArray();\n        char []temp = new char[n];\n        for(int i=0;i<n;i++)\n        {\n            temp[(i+h)%n] = c[i];\n        }\n        return new String(temp);\n    }\n    \n     public static int ip(String s){\nreturn Integer.parseInt(s);\n}\n     static class multipliers implements Comparator<Long>{\n  \n         \n  public int compare(Long a,Long b) {\n   if(a<b)\n    return 1;\n   else if(b<a)\n    return -1;\n   else\n    return 0;\n  }\n }\n     static class multipliers1 implements Comparator<Student>{\n  \n  public int compare(Student a,Student b) {\n   if(a.y<b.y)\n    return 1;\n   else if(b.y<a.y)\n    return -1;\n   else\n   {\n       if(a.id < b.id)\n           return 1;\n       else if(b.id<a.id)\n           return -1;\n       else\n           return 0;\n           \n    //return 0;\n   }\n  }\n }\n    // Java program to generate power set in \n// lexicographic order. \n\n    \n    \n    \n      static class InputReader {\n \nprivate final InputStream stream;\nprivate final byte[] buf = new byte[8192];\nprivate int curChar, snumChars;\n \npublic InputReader(InputStream st) {\nthis.stream = st;\n}\n \npublic int read() {\nif (snumChars == -1)\nthrow new InputMismatchException();\nif (curChar >= snumChars) {\ncurChar = 0;\ntry {\nsnumChars = stream.read(buf);\n} catch (IOException e) {\nthrow new InputMismatchException();\n}\nif (snumChars <= 0)\nreturn -1;\n}\nreturn buf[curChar++];\n}\n \npublic int ni() {\nint c = read();\nwhile (isSpaceChar(c)) {\nc = read();\n}\nint sgn = 1;\nif (c == '-') {\nsgn = -1;\nc = read();\n}\nint res = 0;\ndo {\nres *= 10;\nres += c - '0';\nc = read();\n} while (!isSpaceChar(c));\nreturn res * sgn;\n}\n \npublic long nl() {\nint c = read();\nwhile (isSpaceChar(c)) {\nc = read();\n}\nint sgn = 1;\nif (c == '-') {\nsgn = -1;\nc = read();\n}\nlong res = 0;\ndo {\nres *= 10;\nres += c - '0';\nc = read();\n} while (!isSpaceChar(c));\nreturn res * sgn;\n}\n \npublic int[] nia(int n) {\nint a[] = new int[n];\nfor (int i = 0; i < n; i++) {\na[i] = ni();\n}\nreturn a;\n}\n \npublic String rs() {\nint c = read();\nwhile (isSpaceChar(c)) {\nc = read();\n}\nStringBuilder res = new StringBuilder();\ndo {\nres.appendCodePoint(c);\nc = read();\n} while (!isSpaceChar(c));\nreturn res.toString();\n}\n \npublic String nextLine() {\nint c = read();\nwhile (isSpaceChar(c))\nc = read();\nStringBuilder res = new StringBuilder();\ndo {\nres.appendCodePoint(c);\nc = read();\n} while (!isEndOfLine(c));\nreturn res.toString();\n}\n \npublic boolean isSpaceChar(int c) {\nreturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n}\n \nprivate boolean isEndOfLine(int c) {\nreturn c == '\\n' || c == '\\r' || c == -1;\n}\n \n}\n\n\n\n\n\n   \nstatic PrintWriter w = new PrintWriter(System.out);\n                  static class Student\n    {\n        int id;\n        //int x;\n       \n        int y;\n        //long z;\n        \n        Student(int id,int y)\n        {\n            this.id = id;\n            //this.x = x;\n            //this.s = s;\n            this.y = y;\n           // this.z = z;\n            \n            \n            \n        }\n        \n    }\n}\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        Scanner entrada = new Scanner (System.in);\n        int Primos []= {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,\n                71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,\n                151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,\n                233,239,\n                241,\n                251,\n                257,\n                263,\n                269,\n                271,\n                277,\n                281,\n                283,\n                293,\n                307,\n                311,\n                313,\n                317,\n                331,\n                337,\n                347,\n                349,\n                353,\n                359,\n                367,\n                373,\n                379,\n                383,\n                389,\n                397,\n                401,\n                409,\n                419,\n                421,\n                431,\n                433,\n                439,\n                443,\n                449,\n                457,\n                461,\n                463,\n                467,\n                479,\n                487,\n                491,\n                499,\n                503,\n                509,\n                521,\n                523,\n                541,\n                547,\n                557,\n                563,\n                569,\n                571,\n                577,\n                587,\n                593,\n                599,\n                601,\n                607,\n                613,\n                617,\n                619,\n                631,\n                641,\n                643,\n                647,\n                653,\n                659,\n                661,\n                673,\n                677,\n                683,\n                691,\n                701,\n                709,\n                719,\n                727,\n                733,\n                739,\n                743,\n                751,\n                757,\n                761,\n                769,\n                773,\n                787,\n                797,\n                809,\n                811,\n                821,\n                823,\n                827,\n                829,\n                839,\n                853,\n                857,\n                859,\n                863,\n                877,\n                881,\n                883,\n                887,\n                907,\n                911,\n                919,\n                929,\n                937,\n                941,\n                947,\n                953,\n                967,\n                971,\n                977,\n                983,\n                991,\n                997\n                };\n        boolean sw=true;\n        int Indices [] = new int [Primos.length];\n        int cantidad = 0;\n        for(int i=0;i<Primos.length-1 && sw;i++)\n        {\n            int suma=Primos[i]+Primos[i+1]+1;\n            int posicion = Arrays.binarySearch(Primos,suma);\n            if(posicion>-1)\n                Indices[posicion]=1;\n        }\n        while(entrada.hasNextInt())\n        {\n            int N = entrada.nextInt();\n            int K = entrada.nextInt();\n            int contador=0;\n            for(int i=0;Primos[i]<=N && i<Primos.length-1;i++)\n                contador+=Indices[i];\n            if(contador>=K)\n                System.out.println(\"YES\");\n            else\n                System.out.println(\"NO\");\n        }\n    }\n\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\n/**\n * \n */\n\n/**\n * @author burdakovd\n * \n */\npublic class A {\n\n\tstatic class House {\n\t\tint x, a;\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(final String[] args) {\n\t\tfinal Scanner in = new Scanner(System.in);\n\t\tfinal PrintWriter out = new PrintWriter(System.out);\n\n\t\ttry {\n\t\t\tfinal int n = in.nextInt();\n\t\t\tfinal int t = in.nextInt();\n\n\t\t\tfinal House[] h = new House[n];\n\t\t\tfor (int i = 0; i < h.length; ++i) {\n\t\t\t\th[i] = new House();\n\t\t\t\th[i].x = in.nextInt();\n\t\t\t\th[i].a = in.nextInt();\n\t\t\t}\n\n\t\t\tArrays.sort(h, new Comparator<House>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(final House o1, final House o2) {\n\t\t\t\t\treturn Integer.valueOf(o1.x).compareTo(o2.x);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tint ans = 2;\n\t\t\tfor (int i = 1; i < n; ++i) {\n\t\t\t\tfinal int dspace = 2 * h[i].x - h[i].a\n\t\t\t\t\t\t- (2 * h[i - 1].x + h[i - 1].a);\n\t\t\t\tif (dspace == 2 * t) {\n\t\t\t\t\t++ans;\n\t\t\t\t} else if (dspace > 2 * t) {\n\t\t\t\t\tans += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(ans);\n\n\t\t} finally {\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t}\n\t}\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "/*input\n2\n4\n1\n1\n2\n3\n9\n1\n1\n1\n2\n2\n1\n2\n1\n2\n\n*/\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tstatic PrintWriter out;\n\tstatic int MOD = 1000000007;\n\tstatic FastReader scan;\n\n    /*-------- I/O usaing short named function ---------*/\n\tpublic static String ns(){return scan.next();}\n\tpublic static int ni(){return scan.nextInt();}\n\tpublic static long nl(){return scan.nextLong();}\n\tpublic static double nd(){return scan.nextDouble();}\n\tpublic static String nln(){return scan.nextLine();}\n\tpublic static void p(Object o){out.print(o);}\n\tpublic static void ps(Object o){out.print(o + \" \");}\n\tpublic static void pn(Object o){out.println(o);}\n    /*-------- for output of an array ---------------------*/\n     static void iPA(int arr []){\n     \t StringBuilder output = new StringBuilder();\n\t     for(int i=0; i<arr.length; i++)output.append(arr[i] + \" \");out.println(output);\n\t}\n\tstatic void lPA(long arr []){\n\t     StringBuilder output = new StringBuilder();\n\t     for(int i=0; i<arr.length; i++)output.append(arr[i] + \" \");out.println(output);\n\t}\n\tstatic void sPA(String arr []){\n\t     StringBuilder output = new StringBuilder();\n\t     for(int i=0; i<arr.length; i++)output.append(arr[i] + \" \");out.println(output);\n\t}\n\tstatic void dPA(double arr []){\n\t     StringBuilder output = new StringBuilder();\n\t     for(int i=0; i<arr.length; i++)output.append(arr[i] + \" \");out.println(output);\n\t}\n    /*-------------- for input in an array ---------------------*/\n\tstatic void iIA(int arr[]){\n\t     for(int i=0; i<arr.length; i++)arr[i] = ni();\n\t}\n\tstatic void lIA(long arr[]){\n\t     for(int i=0; i<arr.length; i++)arr[i] = nl(); \n\t}\n\tstatic void sIA(String arr[]){\n\t     for(int i=0; i<arr.length; i++)arr[i] = ns(); \n\t}\n\tstatic void dIA(double arr[]){\n\t     for(int i=0; i<arr.length; i++)arr[i] = nd();\n\t}\n\t/*------------ for taking input faster ----------------*/\n     static class FastReader\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader()\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next()\n\t\t{\n\t\t\twhile (st == null || !st.hasMoreElements())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine()\n\t\t{\n\t\t\tString str = \"\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstr = br.readLine();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\t// Method to check if x is power of 2\n    static boolean isPowerOfTwo (int x) { return x!=0 && ((x&(x-1)) == 0);}\n    //Method to return lcm of two numbers\n    static int gcd(int a, int b){return a==0?b:gcd(b % a, a); }\n    //Method to count digit of a number\n    static int countDigit(long n){return (int)Math.floor(Math.log10(n) + 1);}\n\n    //Method for sorting\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t//Method for checking if a number is prime or not\n\tstatic boolean isPrime(int n) { \n        if (n <= 1) return false; \n        if (n <= 3) return true; \n        if (n % 2 == 0 || n % 3 == 0) return false; \n        for (int i = 5; i * i <= n; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n            \treturn false; \n        return true; \n    } \n\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tOutputStream outputStream =System.out;\n        out =new PrintWriter(outputStream);\n        scan =new FastReader();\n\t\t//for fast output sometimes\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint t = ni();\n\t\twhile(t-->0){\n\t\t\tint n = ni();\n\t\t\tint arr[] = new int[n];\n\t\t\tiIA(arr);\n\n\t\t\tint stack[] = new int[n+1];\n\t\t\tint size = 0;\n\n\t\t\tfor(int num : arr){\n\t\t\t\tif(num == 1){\n\t\t\t\t\tstack[size++] = 1;\n\t\t\t\t}else{\n\t\t\t\t\twhile (stack[size-1] != num-1) {\n\t\t\t\t\t\tsize--;\n\t\t\t\t\t}\n\t\t\t\t\tstack[size-1] = num;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<size; i++){\n\t\t\t\t\tsb.append(stack[i]);\n\t\t\t\t\tif(i != size-1){\n\t\t\t\t\t\tsb.append(\".\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n        }\n        p(sb);\n        out.flush();\n\t\tout.close();\n\t}\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "/*\n\tAuthor\t:\tImran Khan\n\tLanguage:\tJava\n\t\n*/\n\nimport java.io.*;\nimport java.util.*;\npublic class Main\n{\n\tpublic class BasicInputOutput\n\t{\n\n\t\tprivate StringTokenizer strtoken;\n\t\tprivate BufferedReader bufferReader;\n\t\tprivate BufferedWriter bufferWriter;\n\t\tprivate String delim = \" \\t\\n\\r\\f\";\n\t\tBasicInputOutput()\n\t\t{\n\t\t\tdelim = \" \\t\\n\\r\\f\";\n\t\t\tinitialize();\n\t\t}\n\t\tBasicInputOutput( String s )\n\t\t{\n\t\t\tdelim = s;\n\t\t\tinitialize();\n\t\t}\n\t\tprivate void initialize()\n\t\t{\n\t\t\tbufferReader = new BufferedReader( new InputStreamReader( System.in ));\n\t\t\tbufferWriter = new BufferedWriter( new PrintWriter( System.out ));\n\t\t\tstrtoken = null;\n\t\t}\n\t\tprivate void checkStringTokenizer()throws IOException\n\t\t{\n\t\t\tif ( strtoken == null || strtoken.hasMoreTokens() == false )\n\t\t\t\tstrtoken = new StringTokenizer( bufferReader.readLine(), delim );\n\t\t}\n\t\tpublic int getNextInt()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn Integer.parseInt( strtoken.nextToken());\n\t\t}\n\n\t\tpublic long getNextLong()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn Long.parseLong( strtoken.nextToken());\n\t\t}\n\n\t\tpublic double getNextDouble()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn Double.parseDouble( strtoken.nextToken());\n\t\t}\n\n\t\tpublic float getNextFloat()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn Float.parseFloat( strtoken.nextToken());\n\t\t}\n\n\t\tpublic String getNextString()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn strtoken.nextToken();\n\t\t}\n\n\t\tpublic String getNextLine()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\treturn bufferReader.readLine();\n\t\t}\n\n\t\tpublic void skipCurrentLine()throws IOException\n\t\t{\n\t\t\tcheckStringTokenizer();\n\t\t\tstrtoken = null;\n\t\t}\n\t\tpublic void write( String var )throws IOException\n\t\t{\n\t\t\tbufferWriter.write( var );\n\t\t}\n\n\t\tpublic < T > void write( char sep, T... var )throws IOException\n\t\t{\n\t\t\tif ( var.length == 0 )\n\t\t\t\treturn ;\n\t\t\tbufferWriter.write( var[0].toString());\n\t\t\tfor ( int i = 1; i < var.length; i++ )\n\t\t\t\tbufferWriter.write( sep + var[i].toString());\n\t\t}\n\n\t\tpublic void flush()throws IOException\n\t\t{\n\t\t\tbufferWriter.flush();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args)\n\t{\n\t\ttry\n\t\t{\n\t\t\tnew Main().run();\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tex.printStackTrace();\n\t\t}\n\t}\n\tprivate BasicInputOutput iohandler;\n\tprivate int n;\n\tprivate double[][] mat;\n\tprivate double[][] sum;\n\tprivate double[] dp;\n\tprivate int tolive;\n\tprivate void run()throws Exception\n\t{\n\t\tinitialize();\n\t\tsolve();\n\t}\n\tprivate void initialize() throws Exception\n\t{\n\t\tiohandler=new BasicInputOutput();\n\t\tn=iohandler.getNextInt();\n\t\tmat=new double[n][n];\n\t\tsum=new double[(1<<n)+10][n];\n\t\tdp=new double[1<<n];\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++)\n\t\t{\n\t\t\tmat[i][j]=iohandler.getNextDouble();\n\t\t}\n\t}\n\tprivate int bitCount(int mask)\n\t{\n\t\tint ret=0;\n\t\twhile(mask>0) {\n\t\t\tret++;\n\t\t\tmask&=(mask-1);\n\t\t}\n\t\treturn ret;\n\t}\n\tprivate void solve() throws Exception\n\t{\n\t\tdouble[] ans=new double[n];\n\t\tint ub=1<<n;\n\t\tfor(int i=1;i<ub;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tsum[i][j]=0;\n\t\t\t\tfor(int k=0;k<n;k++) if ((i&(1<<k))!=0) sum[i][j]+=mat[k][j];\n\t\t\t\tint cntbit=bitCount(i);\n\t\t\t\tif (cntbit>1)\n\t\t\t\tsum[i][j]/=((double)cntbit*(cntbit-1.))/2.;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int mask=1;mask<ub;mask++) {\n\t\t\t\tdp[mask]=0;\n\t\t\t\tif ((mask&(1<<i))==0) continue;\n\t\t\t\tif (bitCount(mask)==1)\n\t\t\t\t{\n\t\t\t\t\tdp[mask]=1.;\n\t\t\t\t} else\n\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\tif ((mask&(1<<k))==0) continue;\n\t\t\t\t\tif (i==k) continue;\n\t\t\t\t\tdp[mask]+=sum[mask][k]*dp[mask-(1<<k)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[i]=dp[ub-1];\n\t\t}\n\t\tiohandler.write(ans[0]+\"\");\n\t\tfor(int i=1;i<n;i++) iohandler.write(\" \"+ans[i]);\n\t\tiohandler.write(\"\\n\");\n\t\tiohandler.flush();\n\t}\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class ProblemA {\n\tpublic static void main(String[] args) throws Exception{\n\t\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tStringTokenizer st = new StringTokenizer(bf.readLine());\n\t\t\tStringTokenizer st1 = new StringTokenizer(bf.readLine());\n\t\t\tint n = Integer.parseInt(st.nextToken());\n\t\t\tint r = Integer.parseInt(st.nextToken());\n\t\t\tint[] xcoords = new int[n];\n\t\t\tfor(int i = 0;i<n;i++){\n\t\t\t\txcoords[i] = Integer.parseInt(st1.nextToken());\n\t\t\t}\n\t\t\tdouble[] ycoords = new double[n];\n\t\t\t\n\t\t\tfor(int i = 0;i<n;i++){\n\t\t\t\tArrayList<Integer> nodes = new ArrayList<Integer>();\n\t\t\t\tfor(int j = 0;j<i;j++){\n\t\t\t\t\tif (Math.abs(xcoords[j] - xcoords[i]+0.0) <= 2*r)\n\t\t\t\t\t\tnodes.add(j);\n\t\t\t\t}\n\t\t\t\tif (nodes.isEmpty()){\n\t\t\t\t\tycoords[i] = r;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble min = -1;\n\t\t\t\t\tfor(int k = 0;k<nodes.size();k++){\n\t\t\t\t\t\tdouble tmp = ycoords[nodes.get(k)] + Math.sqrt(4*r*r - (xcoords[i] - xcoords[nodes.get(k)])*(xcoords[i] - xcoords[nodes.get(k)]));\n\t\t\t\t\t\tif (tmp > min){\n\t\t\t\t\t\t\tmin = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tycoords[i] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<ycoords.length;i++){\n\t\t\t\tSystem.out.print(ycoords[i] + \" \");\n\t\t\t}\n\t\t\t\n\t}\n}", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1209e1_2 {\n\n    public static void main(String[] args) throws IOException {\n        int t = ri();\n        while (t --> 0) {\n            int n = rni(), m = ni(), a[][] = new int[m][n], dp[] = new int[1 << n];\n            for (int i = 0; i < n; ++i) {\n                int[] row = ria(m);\n                for (int j = 0; j < m; ++j) {\n                    a[j][i] = row[j];\n                }\n            }\n            for (int i = 0; i < m; ++i) {\n                for (int r = 0; r < 1 << n; ++r) {\n                    for (int j = 0; j < n; ++j) {\n                        if ((r & (1 << j)) == 0) {\n                            continue;\n                        }\n                        dp[r] = max(dp[r], dp[r ^ (1 << j)] + a[i][j]);\n                    }\n                }\n                for (int r = 0; r < 1 << n; ++r) {\n                    int s = r;\n                    for (int j = 0; j < n; ++j) {\n                        if ((s & 1) != 0) {\n                            s = (s >> 1) | (1 << (n - 1));\n                        } else {\n                            s >>= 1;\n                        }\n                        dp[s] = max(dp[s], dp[r]);\n                    }\n                }\n            }\n            prln(dp[(1 << n) - 1]);\n        }\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(\"yes\");}\n    static void pry() {prln(\"Yes\");}\n    static void prY() {prln(\"YES\");}\n    static void prno() {prln(\"no\");}\n    static void prn() {prln(\"No\");}\n    static void prN() {prln(\"NO\");}\n    static boolean pryesno(boolean b) {prln(b ? \"yes\" : \"no\"); return b;};\n    static boolean pryn(boolean b) {prln(b ? \"Yes\" : \"No\"); return b;}\n    static boolean prYN(boolean b) {prln(b ? \"YES\" : \"NO\"); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(\"hlfd\"); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "/**\n * BaZ :D\n */\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\npublic class Main\n{\n    static MyScanner scan;\n    static PrintWriter pw;\n    static long MOD = 1_000_000_007;\n    static long INF = 1_000_000_000_000_000_000L;\n    static long inf = 2_000_000_000;\n    public static void main(String[] args) {\n        new Thread(null, null, \"BaZ\", 1 << 27) {\n            public void run() {\n                try {\n                    solve();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n    static int n,m,need,a[][],dp[][][],real[][];\n    static void solve() throws IOException\n    {\n        //initIo(true);\n        initIo(false);\n        StringBuilder sb = new StringBuilder();\n        int t = ni();\n        while(t-->0) {\n            n = ni();\n            m = ni();\n            a = new int[n][m];\n            for(int i=0;i<n;++i) {\n                for(int j=0;j<m;++j) {\n                    a[i][j] = ni();\n                }\n            }\n            need = min(n,m);\n            Pair max_in_cols[] = new Pair[m];\n            for(int COL=0;COL<m;++COL) {\n                int max = 0;\n                for(int i=0;i<n;++i) {\n                    max = max(max, a[i][COL]);\n                }\n                max_in_cols[COL] = new Pair(max, COL);\n            }\n            real = new int[n][need];\n            Arrays.sort(max_in_cols);\n            for(int i=0;i<need;++i) {\n                int COL = max_in_cols[m-1-i].y;\n                for(int j=0;j<n;++j) {\n                    real[j][i] = a[j][COL];\n                }\n            }\n//            pl(\"need : \"+need);\n//            pa(\"Real\", real);\n            dp = new int[need][n+1][(1<<n)];\n            for(int i=0;i<need;++i) {\n                for(int j=0;j<=n;++j) {\n                    for(int k=0;k<(1<<n);++k) {\n                        dp[i][j][k] = -1;\n                    }\n                }\n            }\n            pl(f(0, n, 0));\n        }\n        pw.flush();\n        pw.close();\n    }\n    static int f(int idx, int bias, int mask) {\n        //pl(\"idx: \"+idx+\" bias : \"+bias + \" mask : \"+mask);\n        if(idx==need) {\n            return 0;\n        }\n        if(dp[idx][bias][mask]!=-1) {\n            return dp[idx][bias][mask];\n        }\n\n        //didn't fix bias yet\n        if(bias==n) {\n            int max = 0;\n            for(int b=0;b<n;++b) {\n                max = max(max, f(idx, b, mask));\n            }\n            //pl(\"maxxxxxxx : \"+max);\n            dp[idx][bias][mask] = max;\n            return max;\n        }\n        else {\n            int max = f(idx+1, n, mask);\n            for(int i=0;i<n;++i) {\n                if((mask&(1<<i))==0) {\n                    max = max(max, real[(i-bias+n)%n][idx] + f(idx, bias, mask | (1<<i)));\n                }\n            }\n            //pl(\"max : \"+max);\n            dp[idx][bias][mask] = max;\n            return max;\n        }\n    }\n    static class Pair implements Comparable<Pair>\n    {\n        int x,y;\n        Pair(int x,int y)\n        {\n            this.x=x;\n            this.y=y;\n        }\n        public int compareTo(Pair other)\n        {\n            if(this.x!=other.x)\n                return this.x-other.x;\n            return this.y-other.y;\n        }\n        public String toString()\n        {\n            return \"(\"+x+\",\"+y+\")\";\n        }\n    }\n    static void initIo(boolean isFileIO) throws IOException {\n        scan = new MyScanner(isFileIO);\n        if(isFileIO) {\n            pw = new PrintWriter(\"/Users/amandeep/Desktop/output.txt\");\n        }\n        else {\n            pw = new PrintWriter(System.out, true);\n        }\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static String ne() throws IOException\n    {\n        return scan.next();\n    }\n    static String nel() throws IOException\n    {\n        return scan.nextLine();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class MyScanner\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        MyScanner(boolean readingFromFile) throws IOException\n        {\n            if(readingFromFile) {\n                br = new BufferedReader(new FileReader(\"/Users/amandeep/Desktop/input.txt\"));\n            }\n            else {\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n        }\n        String nextLine()throws IOException\n        {\n            return br.readLine();\n        }\n        String next() throws IOException\n        {\n            if(st==null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        int nextInt() throws IOException\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong() throws IOException\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble() throws IOException\n        {\n            return Double.parseDouble(next());\n        }\n    }\n}", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tFastReader reader = new FastReader();\n\t\tPrintWriter writer = new PrintWriter(System.out);\n\n\t\tlong n = reader.nextLong();\n\t\tlong k = reader.nextLong();\n\n\t\tlong s=0;\n\t\tlong e=n;\n\n\t\tlong ans = -1;\n\t\twhile (s<=e) {\n\t\t\tlong m = (s+e)/2;\n\t\t\tlong temp = ((n-m)*(n-m+1))/2 - m;\n\n\t\t\tif (temp < k) \n\t\t\t\te = m-1;\n\t\t\telse if (temp > k)\n\t\t\t\ts = m+1;\n\t\t\telse {\n\t\t\t\tans = m;\n\t\t\t\tbreak;\n\t\t\t} \n\t\t}\n\n\t\twriter.println(ans);\n\t\twriter.close();\n\t}\n\n\tstatic class FastReader\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader()\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next()\n\t\t{\n\t\t\twhile (st == null || !st.hasMoreElements())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine()\n\t\t{\n\t\t\tString str = \"\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstr = br.readLine();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main2 {\n\n\tstatic List<List<Integer>> getLayers(int[] numbers, int a, int b) {\n\t\tboolean[] used = new boolean[numbers.length];\n\t\tHashSet<Integer> hs = new HashSet<Integer>();\n\t\tfor (int i = 0; i < numbers.length; i++) {\n\t\t\ths.add(numbers[i]);\n\t\t}\n\t\tHashMap<Integer, Integer> numberToIndex = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < numbers.length; i++) {\n\t\t\tnumberToIndex.put(numbers[i], i);\n\t\t}\n\n\t\tList<List<Integer>> ans = new ArrayList<List<Integer>>();\n\t\tfor (int i = 0; i < numbers.length; i++) {\n\t\t\tif (!used[i]) {\n\n\t\t\t\tList<Integer> ansRow = new ArrayList<Integer>();\n\t\t\t\tLinkedList<Integer> current = new LinkedList<Integer>();\n\t\t\t\tcurrent.add(numbers[i]);\n\t\t\t\twhile (!current.isEmpty()) {\n\t\t\t\t\tint c = current.removeFirst();\n\t\t\t\t\tused[numberToIndex.get(c)] = true;\n\n\t\t\t\t\tboolean found = false;\n\n\t\t\t\t\tif (hs.contains(a - c)) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tif (a - c != c)\n\t\t\t\t\t\t\tcurrent.add(a - c);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hs.contains(b - c)) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tif (b - c != c)\n\t\t\t\t\t\t\tcurrent.add(b - c);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (found || ansRow.size() > 0)\n\t\t\t\t\t\tansRow.add(c);\n\n\t\t\t\t\ths.remove(c);\n\t\t\t\t}\n\n\t\t\t\tans.add(ansRow);\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\n\t\tint[] numbers = new int[n];\n\t\tfor (int i = 0; i < numbers.length; i++) {\n\t\t\tnumbers[i] = sc.nextInt();\n\t\t}\n\n\t\tHashSet<Integer> hs = new HashSet<Integer>();\n\t\tfor (int i = 0; i < numbers.length; i++) {\n\t\t\ths.add(numbers[i]);\n\t\t}\n\n\t\tint[] belongs = new int[n];\n\t\tfor (int i = 0; i < belongs.length; i++) {\n\t\t\tbelongs[i] = -1;\n\t\t}\n\n\t\tHashMap<Integer, Integer> numberToIndex = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < numbers.length; i++) {\n\t\t\tnumberToIndex.put(numbers[i], i);\n\t\t}\n\n\t\tboolean possible = true;\n\n\t\tList<List<Integer>> layers = getLayers(numbers, a, b);\n\t\tfor (List<Integer> layer : layers) {\n\n\t\t\tif (layer.size() == 0) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint starting = -1;\n\t\t\tfor (int j = 0; j < layer.size(); j++) {\n\t\t\t\tint cur = layer.get(j);\n\n\t\t\t\tint nei = 0;\n\t\t\t\tif (hs.contains(a - cur)) {\n\t\t\t\t\tnei++;\n\t\t\t\t}\n\n\t\t\t\tif (hs.contains(b - cur)) {\n\t\t\t\t\tnei++;\n\t\t\t\t}\n\n\t\t\t\tif (nei == 1 || (a == b && nei == 2)) {\n\t\t\t\t\tstarting = j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (starting == -1)\n\t\t\t\tthrow new Error();\n\n\t\t\tint c = layer.get(starting);\n\t\t\tHashSet<Integer> layerset = new HashSet<Integer>(layer);\n\t\t\twhile (true) {\n\n\t\t\t\tif (layerset.contains(c) && layerset.contains(a - c)) {\n\t\t\t\t\tbelongs[numberToIndex.get(c)] = 0;\n\t\t\t\t\tbelongs[numberToIndex.get(a - c)] = 0;\n\t\t\t\t\tlayerset.remove(c);\n\t\t\t\t\tlayerset.remove(a - c);\n\t\t\t\t\tc = b - (a - c);\n\t\t\t\t} else if (layerset.contains(c) && layerset.contains(b - c)) {\n\t\t\t\t\tbelongs[numberToIndex.get(c)] = 1;\n\t\t\t\t\tbelongs[numberToIndex.get(b - c)] = 1;\n\t\t\t\t\tlayerset.remove(c);\n\t\t\t\t\tlayerset.remove(b - c);\n\t\t\t\t\tc = a - (b - c);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tprintResult(belongs);\n\n\t}\n\n\tstatic void printResult(int[] belongs) {\n\n\t\tboolean ok = true;\n\t\tfor (int i = 0; i < belongs.length; i++) {\n\t\t\tif (belongs[i] < 0)\n\t\t\t\tok = false;\n\t\t}\n\n\t\tif (ok) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t\tStringBuffer sb = new StringBuffer();\n\n\t\t\tfor (int i = 0; i < belongs.length; i++) {\n\t\t\t\tsb.append(belongs[i]);\n\t\t\t\tif (i != belongs.length - 1)\n\t\t\t\t\tsb.append(\" \");\n\t\t\t}\n\n\t\t\tSystem.out.println(sb.toString());\n\t\t} else {\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n\n}", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Div1_526C {\n\n\tstatic int nV;\n\n\tstatic ArrayList<Integer>[] chldn;\n\n\tstatic int root;\n\n\tstatic int[][] anc;\n\tstatic int[] depth;\n\n\tstatic int[] num;\n\n\tstatic int[] nLoc;\n\n\tstatic int[][] tree;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tnV = Integer.parseInt(reader.readLine());\n\n\t\tchldn = new ArrayList[nV];\n\t\tfor (int i = 0; i < nV; i++) {\n\t\t\tchldn[i] = new ArrayList<>();\n\t\t}\n\n\t\tanc = new int[nV][21];\n\t\tdepth = new int[nV];\n\n\t\tnum = new int[nV];\n\t\tnLoc = new int[nV];\n\t\ttree = new int[nV * 4][2];\n\t\tfor (int[] a : tree) {\n\t\t\ta[0] = a[1] = -1;\n\t\t}\n\n\t\troot = 0;\n\n\t\tStringTokenizer inputData = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0; i < nV; i++) {\n\t\t\tnum[i] = Integer.parseInt(inputData.nextToken());\n\t\t\tnLoc[num[i]] = i;\n\t\t}\n\n\t\tinputData = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 1; i < nV; i++) {\n\t\t\tanc[i][0] = Integer.parseInt(inputData.nextToken()) - 1;\n\t\t\tchldn[anc[i][0]].add(i);\n\t\t}\n\n\t\tpreprocess();\n\n\t\tbuild(1, 0, nV - 1);\n\n\t\tint nQ = Integer.parseInt(reader.readLine());\n\n\t\twhile (nQ-- > 0) {\n\t\t\tinputData = new StringTokenizer(reader.readLine());\n\t\t\tif (inputData.nextToken().equals(\"1\")) {\n\t\t\t\tint a = Integer.parseInt(inputData.nextToken()) - 1;\n\t\t\t\tint b = Integer.parseInt(inputData.nextToken()) - 1;\n\n\t\t\t\tint temp = num[a];\n\t\t\t\tnum[a] = num[b];\n\t\t\t\tnum[b] = temp;\n\n\t\t\t\tnLoc[num[a]] = a;\n\t\t\t\tnLoc[num[b]] = b;\n\n\t\t\t\tupdate(1, 0, nV - 1, num[a]);\n\t\t\t\tupdate(1, 0, nV - 1, num[b]);\n\t\t\t} else {\n\t\t\t\tprinter.println(query(1, 0, nV - 1, nLoc[0], nLoc[0]) + 1);\n\t\t\t}\n\t\t}\n\t\tprinter.close();\n\t}\n\n\tstatic void build(int nI, int cL, int cR) {\n\t\tif (cL == cR) {\n\t\t\ttree[nI][0] = nLoc[cL];\n\t\t\ttree[nI][1] = nLoc[cL];\n\t\t} else {\n\t\t\tint mid = (cL + cR) >> 1;\n\t\t\tbuild(nI * 2, cL, mid);\n\t\t\tbuild(nI * 2 + 1, mid + 1, cR);\n\t\t\tif (tree[nI * 2][0] != -1 && tree[nI * 2 + 1][0] != -1) {\n\t\t\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], tree[nI * 2 + 1][0], tree[nI * 2 + 1][1]);\n\t\t\t\ttree[nI][0] = mResp[0];\n\t\t\t\ttree[nI][1] = mResp[1];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int query(int nI, int cL, int cR, int e1, int e2) {\n\t\tif (cL == cR) {\n\t\t\tmerge(e1, e2, nLoc[cL], nLoc[cL]);\n\t\t\tif (mResp[0] != -1) {\n\t\t\t\treturn cL;\n\t\t\t} else {\n\t\t\t\treturn cL - 1;\n\t\t\t}\n\t\t}\n\t\tint mid = (cL + cR) >> 1;\n\n\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], e1, e2);\n\t\tif (mResp[0] != -1) {\n\t\t\treturn query(nI * 2 + 1, mid + 1, cR, mResp[0], mResp[1]);\n\t\t}\n\t\treturn query(nI * 2, cL, mid, e1, e2);\n\t}\n\n\tstatic void update(int nI, int cL, int cR, int uI) {\n\t\tif (cL == cR) {\n\t\t\ttree[nI][0] = nLoc[cL];\n\t\t\ttree[nI][1] = nLoc[cL];\n\t\t} else {\n\t\t\tint mid = (cL + cR) >> 1;\n\t\t\tif (uI <= mid) {\n\t\t\t\tupdate(nI * 2, cL, mid, uI);\n\t\t\t} else {\n\t\t\t\tupdate(nI * 2 + 1, mid + 1, cR, uI);\n\t\t\t}\n\t\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], tree[nI * 2 + 1][0], tree[nI * 2 + 1][1]);\n\t\t\ttree[nI][0] = mResp[0];\n\t\t\ttree[nI][1] = mResp[1];\n\t\t}\n\t}\n\n\tstatic int[] mResp = new int[2];\n\n\tstatic void merge1(int... a) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (a[i] == -1) {\n\t\t\t\tmResp[0] = mResp[1] = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (onPath(a[0], a[1], a[2])) {\n\t\t\tmResp[0] = a[0];\n\t\t\tmResp[1] = a[1];\n\t\t\treturn;\n\t\t}\n\t\tif (onPath(a[0], a[2], a[1])) {\n\t\t\tmResp[0] = a[0];\n\t\t\tmResp[1] = a[2];\n\t\t\treturn;\n\t\t}\n\t\tif (onPath(a[1], a[2], a[0])) {\n\t\t\tmResp[0] = a[1];\n\t\t\tmResp[1] = a[2];\n\t\t\treturn;\n\t\t}\n\t\tmResp[0] = mResp[1] = -1;\n\t}\n\n\tstatic void merge(int... a) {\n\t\tmerge1(a[0], a[1], a[2]);\n\t\tmerge1(mResp[0], mResp[1], a[3]);\n\t}\n\n\tstatic boolean onPath(int a, int b, int c) {\n\t\tif (a == c || b == c) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (depth[a] > depth[c]) {\n\t\t\ta = jump(a, depth[a] - depth[c] - 1);\n\t\t}\n\t\tif (depth[b] > depth[c]) {\n\t\t\tb = jump(b, depth[b] - depth[c] - 1);\n\t\t}\n\t\tif (a == b) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (anc[a][0] == c || anc[b][0] == c) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// good for depth of up to 1_048_576 = 2^20\n\n\tstatic void preprocess() {\n\t\tanc[root][0] = root;\n\t\tfParent(root);\n\n\t\tfor (int k = 1; k <= 20; k++) {\n\t\t\tfor (int i = 0; i < nV; i++) {\n\t\t\t\tanc[i][k] = anc[anc[i][k - 1]][k - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void fParent(int cV) {\n\t\tfor (int aV : chldn[cV]) {\n\t\t\tanc[aV][0] = cV;\n\t\t\tdepth[aV] = depth[cV] + 1;\n\t\t\tfParent(aV);\n\t\t}\n\t}\n\n\tstatic int fLCA(int a, int b) {\n\t\tif (depth[a] > depth[b]) {\n\t\t\tint temp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\t\tb = jump(b, depth[b] - depth[a]);\n\t\tif (a == b) {\n\t\t\treturn a;\n\t\t}\n\t\tfor (int i = 20; i >= 0; i--) {\n\t\t\tif (anc[a][i] != anc[b][i]) {\n\t\t\t\ta = anc[a][i];\n\t\t\t\tb = anc[b][i];\n\t\t\t}\n\t\t}\n\t\treturn anc[a][0];\n\t}\n\n\tstatic int jump(int cV, int d) {\n\t\tfor (int i = 0; i <= 20; i++) {\n\t\t\tif ((d & (1 << i)) != 0) {\n\t\t\t\tcV = anc[cV][i];\n\t\t\t}\n\t\t}\n\t\treturn cV;\n\t}\n\n\tstatic Comparator<Integer> BY_DEPTH = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn -Integer.compare(depth[o1], depth[o2]); // greatest depth first\n\t\t}\n\t};\n}", "complexity": "nlogn", "problem": "1084_F", "from": "CODEFORCES", "tags": "data structures,trees"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF817C {\n\tstatic long count(long x) {\n\t\treturn x < 10 ? x : count(x / 10) + x % 10;\n\t}\n\tstatic boolean check(long x, long s) {\n\t\treturn x - count(x) >= s;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tlong n = Long.parseLong(st.nextToken());\n\t\tlong s = Long.parseLong(st.nextToken());\n\t\tint d = 9 * 18;\n\t\tlong cnt;\n\t\tif (n >= s + d) {\n\t\t\tcnt = n - s - d;\n\t\t\tfor (long x = s; x <= s + d; x++)\n\t\t\t\tif (check(x, s))\n\t\t\t\t\tcnt++;\n\t\t} else {\n\t\t\tcnt = 0;\n\t\t\tfor (long x = s; x <= n; x++)\n\t\t\t\tif (check(x, s))\n\t\t\t\t\tcnt++;\n\t\t}\n\t\tSystem.out.println(cnt);\n\t}\n}\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main { \n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n=sc.nextInt(),x=sc.nextInt();\n\t\tint a[]=sc.readArray(n);\n\t\tboolean flag=false;\n\t\tHashMap<Integer,Integer> map = new HashMap<>();\n\t\tfor(int i=0 ; i<n ; i++) {\n\t\t\tif(map.containsKey(a[i])) {\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t\tmap.put(a[i],1);\n\t\t}\n\t\tif(flag==true) {\n\t\t\tout.println(0);\n\t\t}\n\t\telse {\n\t\t\tHashSet<Integer> set = new HashSet<>();\n\t\t\tfor(int i=0 ; i<n ; i++) {\n\t\t\t\tif(map.containsKey(a[i]&x) && (a[i]&x)!=a[i]) {\n\t\t\t\t\tflag=true;break;\n\t\t\t\t}\n\t\t\t\tset.add(a[i]&x);\n\t\t\t}\n\t\t\tif(flag==true) {\n\t\t\t\tout.println(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(set.size()<n) {\n\t\t\t\t\tout.println(2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout.println(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint [] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n} \n\n", "complexity": "linear", "problem": "1013_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class E {\n    public static void main(String[] args) throws Exception {\n        new Thread(null ,new Runnable(){\n            public void run(){\n                try{solveIt();} catch(Exception e){e.printStackTrace(); System.exit(1);}\n            }\n        },\"Main\",1<<28).start();\n    }\n\n    static int dp[][], a[][], rows, cols;\n\n    public static void solveIt() throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int test = in.nextInt();\n        for (int t = 1; t <= test; t++) {\n            rows = in.nextInt();\n            cols = in.nextInt();\n            dp = new int[cols][1 << rows];\n            for (int x[] : dp) Arrays.fill(x, -1);\n            a = new int[cols][rows];\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    a[j][i] = in.nextInt();\n                }\n            }\n            debug(a);\n            pw.println(solve(0, 0));\n        }\n\n        pw.close();\n    }\n\n    static int solve(int pos, int mask) {\n        if (pos >= cols) return 0;\n        if (dp[pos][mask] != -1) return dp[pos][mask];\n        int res = 0;\n        for (int i = 0; i < rows; i++) {\n            for (int k = 0; k < (1 << rows); k++) {\n                if ((mask & k) != 0) continue;\n                int sum = 0;\n                for (int bit = 0; bit < rows; bit++) {\n                    if (check(k, bit)) sum += a[pos][bit];\n                }\n                res = max(res, sum + solve(pos + 1, mask | k));\n            } \n            cyclicShift(pos);\n        }\n        return dp[pos][mask] = res;\n    }\n\n    static boolean check(int N, int pos) {\n        return (N & (1 << pos)) != 0;\n    }\n\n    static void cyclicShift(int col) {\n        int m = a[col].length;\n        int last = a[col][m - 1];\n        for (int i = m - 1; i >= 1; i--) {\n            a[col][i] = a[col][i - 1];\n        }\n        a[col][0] = last;\n    }\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n\n        public FastReader(InputStream is) {\n            this.is = is;\n        }\n\n        public int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (ptrbuf >= lenbuf) {\n                ptrbuf = 0;\n                try {\n                    lenbuf = is.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public int skip() {\n            int b;\n            while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n            return b;\n        }\n\n        public String next() {\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while (!(isSpaceChar(b))) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n\n        public String nextLine() {\n            int c = skip();\n            StringBuilder sb = new StringBuilder();\n            while (!isEndOfLine(c)) {\n                sb.appendCodePoint(c);\n                c = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int num = 0, b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public char[] next(int n) {\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while (p < n && !(isSpaceChar(b))) {\n                buf[p++] = (char) b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        public char readChar() {\n            return (char) skip();\n        }\n    }\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "/**\n * Created by Omar on 7/22/2016.\n */\n\nimport java.util.*;\nimport java.io.*;\n\npublic class CF364C {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n=Integer.parseInt(br.readLine());\n        String input=br.readLine();\n        Set<Character> set = new HashSet<Character>();\n        for(int i=0;i<input.length();i++){\n            set.add(input.charAt(i));\n        }\n        StringBuilder sb= new StringBuilder();\nfor(char x:set){\n    sb.append(x);\n}\n        String substring1=sb.toString();\n//        //System.out.println(substring1);\n//        int[] count= new int[52];\n//        int[] b= new int[52];\n//\n//        char k;\n//        for(int i=0;i<substring1.length();i++){\n//            k=substring1.charAt(i);\n//            //System.out.println((int)'a');\n//            count[(k-'A')]++;\n//\n//        }\n//        for(int i=0;i<52;i++){\n//          b[i]=count[i];\n//\n//            //System.out.println(\"count \"+count[i]);\n//        }\n//        int answer=set.size();\n//\n//\n//        for(int i=0;i<input.length();i++){\n//\n//        }\n//        System.out.println(answer);\n//\n        //System.out.println(\"WAIT\");\n        System.out.println(solve(input,substring1).length());\n        pw.close();\n        br.close();\n    }\n    public static boolean isEmpty(int[] a){\n        for(int i=0;i<a.length;i++){\n            if(a[i]!=0){\n                return false;\n            }\n\n        }\n\nreturn true;\n    }\n    public static String solve(String S, String T) {\n        HashMap<Character, Integer> D = new HashMap<>();\n        HashMap<Character, Integer> GET = new HashMap<>();\n        int B,E;\n        for (int i=0; i<T.length();i++) {\n            char c=T.charAt(i);\n            if (!D.containsKey(c))\n            {\n                D.put(c, 1);\n            }\n            else\n            {\n                D.put(c, D.get(c) + 1);\n            }\n        }\n        int ccc = 0;\n       B=0; E=0;\n        int min = Integer.MAX_VALUE;\n        // int max = Integer.MIN_VALUE;\n\n        String RESULT = \"\";\n        while (E < S.length()) {\n\n            char c = S.charAt(E);\n\n            if (D.containsKey(c)) {\n\n                if (GET.containsKey(c)) {\n\n                    if (GET.get(c) < D.get(c))\n                        ccc++;\n                    //ccc--\n                    GET.put(c, GET.get(c) + 1);\n                } else {\n\n                    GET.put(c, 1);\n\n                    ccc++;\n                    //ccc--\n                }\n            }\n            if (ccc == T.length()) {\n               // if (ccc != B.length()) {\n                char test = S.charAt(B);\n                while (!GET.containsKey(test) ||\n                        GET.get(test) > D.get(test)) {\n\n                    if (GET.containsKey(test)\n                            && GET.get(test) >\n                            D.get(test))\n                       // GET.put(test, GET.get(test) - 24);\n\n                    GET.put(test, GET.get(test) - 1);\n                    //B-=B;\n                    B++;\n\n                    test = S.charAt(B);\n                    //test += S.charAt(B);\n\n                }\n                if (E - B + 1 < min) {\n                    RESULT = S.substring(B, E + 1);\n                    min = E - B + 1;\n                }\n                //}\n            }\n            E++;\n        }\n        //if(E==0)\n        return RESULT;\n    }\n\n\n}\n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "//Edwin Lunando template for online algorithm contest\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n//  class node implements Comparable<node> {\n//\n//    public int a;\n//    public int b;\n//\n//    public int compareTo(node a) {\n//      if (a.b == this.b) {\n//        return a.a - this.a;\n//      } else {\n//        return a.b - this.b;\n//      }\n//    }\n//\n//    public node(int a, int b) {\n//      this.a = a;\n//      this.b = b;\n//    }\n//  }\n\n  private void solve() throws IOException {\n    int n = nextInt();\n    int[] arr = new int[n];\n    int count = 0;\n    for (int x = 0; x < n; x++) {\n      arr[x] = nextInt();\n      count+= arr[x];\n    }\n    Arrays.sort(arr);\n    count /=2;\n    int result = 0, sum = 0;\n    for (int x = arr.length - 1; x >= 0; x--) {\n      sum += arr[x];\n      result++;\n      if (sum > count) {\n        break;\n      }\n    }\n    System.out.println(result);\n  } \n\n  public static void main(String[] args) {\n    try {\n      br = new BufferedReader(new InputStreamReader(System.in));\n      //br = new BufferedReader(new FileReader(\"input.txt\"));\n      out = new PrintWriter(System.out);\n      //out = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n      new Main().solve();\n      out.close();\n    } catch (Throwable e) {\n      System.out.println(e);\n      System.exit(239);\n    }\n  }\n  static BufferedReader br;\n  static StringTokenizer st;\n  static PrintWriter out;\n\n  static String nextToken() throws IOException {\n    while (st == null || !st.hasMoreTokens()) {\n      String line = br.readLine();\n      if (line == null) {\n        return null;\n      }\n      st = new StringTokenizer(line);\n    }\n    return st.nextToken();\n  }\n\n  static int nextInt() throws IOException {\n    return Integer.parseInt(nextToken());\n  }\n\n  static long nextLong() throws IOException {\n    return Long.parseLong(nextToken());\n  }\n\n  static double nextDouble() throws IOException {\n    return Double.parseDouble(nextToken());\n  }\n\n  static int[] nextIntArray(int n) throws IOException {\n    int[] temp = new int[n];\n    for (int x = 0; x < n; x++) {\n      temp[x] = nextInt();\n    }\n    return temp;\n  }\n\n  static long[] nextLongArray(int n) throws IOException {\n    long[] temp = new long[n];\n    for (int x = 0; x < n; x++) {\n      temp[x] = nextLong();\n    }\n    return temp;\n  }\n\n  static String[] nextArray(int n) throws IOException {\n    String[] temp = new String[n];\n    for (int x = 0; x < n; x++) {\n      temp[x] = nextToken();\n    }\n    return temp;\n  }\n}\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.util.*;\n\npublic class a{\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tString str = in.next();\n\t\tint max = 0;\n\t\tfor(int i=0; i<str.length(); i++) {\n\t\t\tfor(int j=i+1; j<=str.length(); j++) {\n\t\t\t\tString first = str.substring(i,j);\n\t\t\t\tfor(int k=i+1; k<=str.length()-first.length(); k++) {\n\t\t\t\t\tif(str.substring(k,k+first.length()).equals(first))\n\t\t\t\t\t\tmax = Math.max(max,first.length());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            CCompressionAndExpansion solver = new CCompressionAndExpansion();\n            int testCount = Integer.parseInt(in.next());\n            for (int i = 1; i <= testCount; i++)\n                solver.solve(i, in, out);\n            out.close();\n        }\n    }\n\n    static class CCompressionAndExpansion {\n        Node end = new Node(null, -1);\n        FastOutput out;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n\n            List<Node> seq = new ArrayList<>(n);\n            Deque<Node> dq = new ArrayDeque<>(n);\n            end = new Node(null, -1);\n            dq.addLast(end);\n            for (int i = 0; i < n; i++) {\n                int x = in.ri();\n                while (true) {\n                    Node last = dq.peekLast();\n                    if (last.nextChild != x) {\n                        dq.removeLast();\n                        continue;\n                    }\n                    last.nextChild++;\n                    dq.addLast(new Node(dq.peekLast(), x));\n                    break;\n                }\n                seq.add(dq.peekLast());\n            }\n\n            this.out = out;\n            for (Node node : seq) {\n                print(node);\n                out.println();\n            }\n        }\n\n        void print(Node root) {\n            if (root.p != end) {\n                print(root.p);\n                out.append('.');\n            }\n            out.append(root.index);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n\n            return rev ? val : -val;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n\n    static class Node {\n        Node p;\n        int index;\n        int nextChild = 1;\n\n        public Node(Node p, int index) {\n            this.p = p;\n            this.index = index;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println() {\n            return append('\\n');\n        }\n\n        public FastOutput flush() {\n            try {\n//            boolean success = false;\n//            if (stringBuilderValueField != null) {\n//                try {\n//                    char[] value = (char[]) stringBuilderValueField.get(cache);\n//                    os.write(value, 0, cache.length());\n//                    success = true;\n//                } catch (Exception e) {\n//                }\n//            }\n//            if (!success) {\n                os.append(cache);\n//            }\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Test {\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer;\n\tstatic PrintWriter writer;\n\n\tstatic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tstatic String nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\ttokenizer = null;\n\t\twriter = new PrintWriter(System.out);\n\t\tsolve();\n\t\treader.close();\n\t\twriter.close();\n\t}\n\n\tprivate static void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint[] mas = new int[n];\n\t\tint sum=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tmas[i]=nextInt();\n\t\t\tsum+=mas[i];\n\t\t}\n\t\tArrays.sort(mas);\n\t\tint cs=0;\n\t\tint res=0;\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tcs+=mas[i];\n\t\t\tsum-=mas[i];\n\t\t\tres++;\n\t\t\tif(cs>sum)\n\t\t\t\tbreak;\n\t\t}\n\t\twriter.println(res);\t\t\n\t}\n}", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.util.*;import java.io.*;import java.math.*;\npublic class Main\n{\n    public static void process()throws IOException\n    {\n        long l=nl();\n        long r=nl();\n        int pow=-1;\n        for(int i=0;i<=63;i++)\n        {\n            if((((l>>i)&1)^((r>>i)&1))==1)\n                pow=i;\n        }\n        pn((long)Math.pow(2,pow+1)-1);\n    }\n\n    static AnotherReader sc;\n    static PrintWriter out;\n    public static void main(String[]args)throws IOException\n    {\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        if(oj){sc=new AnotherReader();out=new PrintWriter(System.out);}\n        else{sc=new AnotherReader(100);out=new PrintWriter(\"output.txt\");}\n        int t=1;\n        // t=ni();\n        while(t-->0) {process();}\n        out.flush();out.close();  \n    }\n\n    static void pn(Object o){out.println(o);}\n    static void p(Object o){out.print(o);}\n    static void pni(Object o){out.println(o);out.flush();}\n    static int ni()throws IOException{return sc.nextInt();}\n    static long nl()throws IOException{return sc.nextLong();}\n    static double nd()throws IOException{return sc.nextDouble();}\n    static String nln()throws IOException{return sc.nextLine();}\n    static int[] nai(int N)throws IOException{int[]A=new int[N];for(int i=0;i!=N;i++){A[i]=ni();}return A;}\n    static long[] nal(int N)throws IOException{long[]A=new long[N];for(int i=0;i!=N;i++){A[i]=nl();}return A;}\n    static long gcd(long a, long b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int gcd(int a, int b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int bit(long n)throws IOException{return (n==0)?0:(1+bit(n&(n-1)));}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    static class AnotherReader{BufferedReader br; StringTokenizer st;\n    AnotherReader()throws FileNotFoundException{\n    br=new BufferedReader(new InputStreamReader(System.in));}\n    AnotherReader(int a)throws FileNotFoundException{\n    br = new BufferedReader(new FileReader(\"input.txt\"));}\n    String next()throws IOException{\n    while (st == null || !st.hasMoreElements()) {try{\n    st = new StringTokenizer(br.readLine());}\n    catch (IOException  e){ e.printStackTrace(); }}\n    return st.nextToken(); } int nextInt() throws IOException{\n    return Integer.parseInt(next());}\n    long nextLong() throws IOException\n    {return Long.parseLong(next());}\n    double nextDouble()throws IOException { return Double.parseDouble(next()); }\n    String nextLine() throws IOException{ String str = \"\"; try{\n    str = br.readLine();} catch (IOException e){\n    e.printStackTrace();} return str;}}\n   \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n}", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class G{\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.flush();out.close();\n    }\n        static class TaskE {\n        class MinCostMaxFlow{\n                ArrayList<Edge> al[];\n                Edge ja[][]; \n                int d[]; // shortest distances\n                int N , S , T , maxFlow ; int minCost;\n                final int gmax = Integer.MAX_VALUE / 100;\n                \n                int edges = 0;\n\n                class Edge{\n                    int u , flow, rid, cost;\n                    Edge(int a, int b, int c, int d){u = a; flow = b; cost = c; rid = d;}\n                }\n                \n                void addEdge(int u , int v , int flow , int cost){\n                    int lu = al[u].size(), lv = al[v].size();\n                    al[u].add(new Edge(v, flow, cost, lv)); \n                    al[v].add(new Edge(u, 0, -cost, lu));   \n                }\n                \n                void convertToArray(){\n                    ja = new Edge[N][];\n                    for(int i = 0; i < N; i++){\n                        int sz = al[i].size();\n                        ja[i] = new Edge[sz];\n                        for(int j = 0; j < sz; j++){\n                            ja[i][j] = al[i].get(j);\n                        }\n                        al[i].clear();\n                    }\n                }\n                \n                MinCostMaxFlow(int n , int source , int sink){\n                    N = n; S = source; T = sink; maxFlow = 0; minCost = 0;\n                    al = new ArrayList[N];\n                    d = new int[N];\n                    for(int i = 0; i < N; i++){\n                        al[i] = new ArrayList<>();\n                    }\n                }\n                \n                boolean BellmanFord(boolean check){\n                    d[0] = 0;\n                    for(int i = 0; i < N - 1; i++){\n                        for(int j = 0; j < N; j++){\n                            for(Edge e : ja[j]){\n                                if(e.flow == 0)continue; // not to consider reverse edges\n                                d[e.u] = Math.min(d[e.u] , d[j] + e.cost);\n                            }\n                        }\n                    }\n                    if(check){// check for negative cycles\n                        for(int j = 0; j < N; j++){\n                            for(Edge e : ja[j]){\n                                if(e.flow == 0)continue;\n                                if(d[j] + e.cost < d[e.u]) return false;\n                            }\n                        }   \n                    }return true;\n                }\n\n                int node[]; // present node \n\n                int visit[]; // 0 -> not added 1 -> not removed 2 -> removed\n                int prv[], prve[]; // previous node for augmentation\n                int dist[]; // min dist\n\n                boolean simple(){\n                    node = new int[N]; \n                    visit = new int[N]; \n                    prv = new int[N];\n                    prve = new int[N];\n                    dist = new int[N];   Arrays.fill(dist , gmax);\n\n                    node[0] = S; dist[0] = 0;\n                    int front = 1, back = 0;\n                    while(front != back){\n                        int u = node[back++]; int distu = dist[u];\n                        if(back == N)back = 0;\n                        visit[u] = 2;\n                        for(int i = 0; i < ja[u].length; i++){\n                            Edge e = ja[u][i];\n                            if(e.flow == 0)continue;\n                            int cdist = distu + e.cost; // no need of reduced cost\n                            if(cdist < dist[e.u]){\n                                if(visit[e.u] == 0){\n                                    node[front] = e.u; \n                                    if(++front == N)front = 0;\n                                }else if(visit[e.u] == 2){\n                                    if(--back == -1)back += N;\n                                    node[back] = e.u;\n                                }\n                                visit[e.u] = 1;\n                                prve[e.u] = i; prv[e.u] = u; dist[e.u] = cdist;\n                            }\n                        }\n                    }\n                    return visit[T] != 0;\n                }\n\n                class pair{\n                    int F; int S;\n                    pair(int a, int b){F = a; S = b;}\n                }\n\n                boolean dijkstra(){\n                    visit = new int[N];\n                    prv = new int[N];\n                    prve = new int[N];\n                    dist = new int[N]; Arrays.fill(dist, gmax);\n                    PriorityQueue<pair> pq = new PriorityQueue<>((A, B) -> Double.compare(A.S , B.S));\n\n                    pq.add(new pair(S , 0)); dist[0] = 0;\n                    o : while(!pq.isEmpty()){\n                        pair p = pq.poll();\n                        while(dist[p.F] < p.S){\n                            if(pq.isEmpty()) break o; // had a better val \n                            p = pq.poll();\n                        }\n                        visit[p.F] = 2;\n                        for(int i = 0; i < ja[p.F].length; i++){\n                            Edge e = ja[p.F][i];\n                            if(e.flow == 0)continue; // important\n                            int cdist = p.S + (e.cost + d[p.F] - d[e.u]); // reduced cost\n                            if(cdist < dist[e.u]){ \n                                if(visit[e.u] == 2) return false;\n                                pq.add(new pair(e.u , cdist));\n                                dist[e.u] = cdist; prv[e.u] = p.F; prve[e.u] = i;\n                                visit[e.u] = 1;\n                            }\n                        }\n                    }\n                    return visit[T] != 0;\n                }\n                \n                int augment(){\n                    int p = T; int min = gmax;\n                    while(p != 0){\n                        int pp = prv[p], pe = prve[p];\n                        int val = ja[pp][pe].flow;\n                        min = Math.min(min , val);\n                        p = pp;\n                    }\n                    p = T;\n                    while(p != 0){\n                        int pp = prv[p], pe = prve[p];\n                        ja[pp][pe].flow -= min;\n                        ja[p][ja[pp][pe].rid].flow += min;\n                        p = pp;\n                    }\n                    maxFlow += min;\n                    return min;\n                }\n\n                // if(dist[T] >= 0)return true; // non contributing flow\n                boolean calSimple(){\n                    // uncomment to check for negative cycles\n                    /* boolean possible = BellmanFord(true); \n                     if(!possible) return false; */\n                    while(simple()){\n                        /*if(dist[T] >= 0)return true;*/ \n                        minCost += dist[T] * augment();\n                    }\n                    return true;\n                }\n\n                void updPotential(){\n                    for(int i = 0; i < N; i++){\n                        if(visit[i] != 0){\n                            d[i] += dist[i] - dist[S];\n                        }\n                    }\n                }\n                boolean calWithPotential(){\n                    // set true to check for negative cycles\n                    // boolean possible = BellmanFord(false); \n                    // if(!possible) return false;\n                    while(dijkstra()){\n                        int min = dist[T] + d[T] - d[S]; // getting back the original cost\n                        /*if(dist[T] >= 0)return true;*/\n                        minCost += min * augment();\n                        updPotential();\n                    }\n                    return true;   \n                }\n            }\n            int n , m, k, c, d, a[], f[];\n           public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt(); m = in.nextInt(); k = in.nextInt(); c = in.nextInt(); d= in.nextInt();\n            // S + n\n            int maxl = n + k, T = n * maxl + 1;\n            MinCostMaxFlow ans = new MinCostMaxFlow(T + 1, 0, T);\n            a = new int[k + 1]; f = new int[n + 1];\n            for(int i = 1; i <= k; i++){\n                a[i] = in.nextInt();\n                f[a[i]]++;\n            }\n            for(int i = 1; i <= n; i++){\n                if(f[i] == 0)continue;\n                ans.addEdge(0 , i , f[i], 0);\n            }\n            for(int i = 2; i <= n; i++){\n                for(int l = 0; l < maxl - 1; l++){\n                    ans.addEdge(l * n + i , (l + 1) * n + i, k, c);\n                }\n            }\n            for(int i = 1; i <= m; i++){\n                int a = in.nextInt(), b = in.nextInt();\n                for(int l = 0; l < maxl - 1; l++){\n                    for(int p = 1; p <= k; p++){\n                        if(a != 1)\n                            ans.addEdge(n * l + a, n * (l + 1) + b, 1, d * (2 * p - 1) + c);\n                        if(b != 1)\n                            ans.addEdge(n * l + b, n * (l + 1) + a, 1, d * (2 * p - 1) + c);\n                    }\n                } \n            }\n            for(int l = 1; l < maxl; l++){\n                ans.addEdge(l * n + 1, T, k, 0);\n            }\n            ans.convertToArray();\n            // ans.calWithPotential();\n            ans.calSimple();\n            if(ans.maxFlow != k){\n                out.println(\"BUG\");\n            }else{\n                out.println((int)ans.minCost);\n            }\n          }\n    }\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream));\n            st = null;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}", "complexity": "cubic", "problem": "1187_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "/**\n * Created by IntelliJ IDEA.\n * User: Taras_Brzezinsky\n * Date: 8/14/11\n * Time: 9:53 PM\n * To change this template use File | Settings | File Templates.\n */\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.FileReader;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class Fish extends Thread {\n\n    public Fish() {\n        this.input = new BufferedReader(new InputStreamReader(System.in));\n        this.output = new PrintWriter(System.out);\n        this.setPriority(Thread.MAX_PRIORITY);\n    }\n\n    static int getOnes(int mask) {\n        int result = 0;\n        while (mask != 0) {\n            mask &= mask - 1;\n            ++result;\n        }\n        return result;\n    }\n\n    private void solve() throws Throwable {\n        int n = nextInt();\n        double[][] a = new double[n][n];\n        double[] dp = new double[(1 << n)];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                a[i][j] = nextDouble();\n            }\n        }\n        int limit = (1 << n) - 1;\n        //dp[mask] = probability of current subset (mask) to remain in the end\n        dp[limit] = 1.0;\n        for (int mask = limit; mask > 0; --mask) {\n            int cardinality = getOnes(mask);\n            if (cardinality < 2) {\n                continue;\n            }\n            int probability = cardinality * (cardinality - 1) / 2;\n            for (int first = 0; first < n; ++first) {\n                if ((mask & powers[first]) != 0) {\n                    for (int second = first + 1; second < n; ++second) {\n                        if ((mask & powers[second]) != 0) {\n                            dp[mask - powers[first]] += dp[mask] * a[second][first] / probability;\n                            dp[mask - powers[second]] += dp[mask] * a[first][second] / probability;\n                        }\n\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            output.printf(\"%.10f \", dp[powers[i]]);\n        }\n    }\n\n    public void run() {\n        try {\n            solve();\n        } catch (Throwable e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace();\n            System.exit(666);\n        } finally {\n            output.flush();\n            output.close();\n        }\n    }\n\n\n    public static void main(String[] args) {\n        new Fish().start();\n    }\n\n    private String nextToken() throws IOException {\n        while (tokens == null || !tokens.hasMoreTokens()) {\n            tokens = new StringTokenizer(input.readLine());\n        }\n        return tokens.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    static final int powers[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144};\n    private BufferedReader input;\n    private PrintWriter output;\n    private StringTokenizer tokens = null;\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "/*\n * Created on 17.05.2019\n */\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * @author Wolfgang Weck\n */\npublic class A01Easy {\n\tprivate static interface Matrix {\n\t\tboolean get(int i, int j);\n\n\t\tint size();\n\t}\n\n\tprivate static class MData implements Matrix {\n\t\tprivate final boolean[][] m;\n\n\t\tMData(boolean[][] m) {\n\t\t\tthis.m = m;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn m[i][j];\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn m.length;\n\t\t}\n\t}\n\n\tprivate static abstract class MDecorator implements Matrix {\n\t\tprotected final Matrix inner;\n\n\t\tMDecorator(Matrix inner) {\n\t\t\tthis.inner = inner;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn inner.size();\n\t\t}\n\t}\n\n\tprivate static class MHFlip extends MDecorator {\n\t\tMHFlip(Matrix inner) {\n\t\t\tsuper(inner);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn inner.get(size() - 1 - i, j);\n\t\t}\n\t}\n\n\tprivate static class MVFlip extends MDecorator {\n\t\tMVFlip(Matrix inner) {\n\t\t\tsuper(inner);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn inner.get(i, size() - 1 - j);\n\t\t}\n\t}\n\n\tprivate static class MRot extends MDecorator {\n\t\tMRot(Matrix inner) {\n\t\t\tsuper(inner);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn inner.get(j, size() - 1 - i);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry (BufferedReader r = new BufferedReader(new InputStreamReader(System.in))) {\n\t\t\tfinal int N = Integer.parseInt(r.readLine());\n\t\t\tMatrix m1 = readMatrix(r, N), m2 = readMatrix(r, N);\n\t\t\tboolean matched = matchesFlipped(m1, m2);\n\t\t\tint i = 0;\n\t\t\twhile (i < 3 && !matched) {\n\t\t\t\tm1 = new MRot(m1);\n\t\t\t\tmatched = matchesFlipped(m1, m2);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tSystem.out.println(matched ? \"Yes\" : \"No\");\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate static Matrix readMatrix(BufferedReader r, int n) throws IOException {\n\t\tboolean[][] m = new boolean[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString line = r.readLine();\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tm[i][j] = line.charAt(j) == 'X';\n\t\t\t}\n\t\t}\n\t\treturn new MData(m);\n\t}\n\n\tprivate static boolean matches(Matrix m1, Matrix m2) {\n\t\tint i = 0, j = 0, n = m1.size();\n\t\twhile (i < n && m1.get(i, j) == m2.get(i, j)) {\n\t\t\tj++;\n\t\t\tif (j == n) {\n\t\t\t\tj = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn i == n;\n\t}\n\n\tprivate static boolean matchesFlipped(Matrix m1, Matrix m2) {\n\t\treturn matches(m1, m2) || matches(new MHFlip(m1), m2) || matches(new MVFlip(m1), m2);\n\t}\n}\n", "complexity": "quadratic", "problem": "0958_A1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\n\n\nimport java.util.*;\n\npublic class Temppp {\n\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        long n = sc.nextLong();\n        long k = sc.nextLong();\n       \n        long ans = (long) ((java.lang.Math.sqrt((9+(8*(n+k))))-3)/2);\n        System.out.println(n-ans);\n        \n    }\n    \n}\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "\nimport java.util.*;\n\nimport java.lang.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\n\npublic class CF {\n\tprivate static FS sc = new FS();\n\t\n\tprivate static class FS {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\t\t\t\t               \n\t            } catch (IOException e) {}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\n\tprivate static class extra {\n\t\t\n\t\tstatic int[] intArr(int size) {\n\t\t\tint[] a = new int[size];\n\t\t\tfor(int i = 0; i < size; i++) a[i] = sc.nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tstatic long[] longArr(int size) {\n\t\t\tlong[] a = new long[size];\n\t\t\tfor(int i = 0; i < size; i++) a[i] = sc.nextLong();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tstatic long intSum(int[] a) {\n\t\t\tlong sum = 0; \n\t\t\tfor(int i = 0; i < a.length; i++) {\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tstatic long longSum(long[] a) {\n\t\t\tlong sum = 0; \n\t\t\tfor(int i = 0; i < a.length; i++) {\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tstatic LinkedList[] graphD(int vertices, int edges) {\n\t\t\tLinkedList[] temp = new LinkedList[vertices+1];\n\t\t\tfor(int i = 0; i <= vertices; i++) temp[i] = new LinkedList<>();\n\t\t\tfor(int i = 0; i < edges; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\ttemp[x].add(y);\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\t\t\n\t\tstatic LinkedList[] graphUD(int vertices, int edges) {\n\t\t\tLinkedList[] temp = new LinkedList[vertices+1];\n\t\t\tfor(int i = 0; i <= vertices; i++) temp[i] = new LinkedList<>();\n\t\t\tfor(int i = 0; i < edges; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\ttemp[x].add(y);\n\t\t\t\ttemp[y].add(x);\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\t\t\n\t\tstatic void printG(LinkedList[] temp) {\n\t\t\tfor(LinkedList<Integer> aa:temp) System.out.println(aa);\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class sieve {\n\t\tstatic final int MAXN = (int) (Math.pow(10, 7)+5);\n\t\t\n\t    static int spf[] = new int[MAXN];\n\t    \n\t    static void sieve() {\n\t        spf[1] = 1;\n\t        for (int i=2; i<MAXN; i++) spf[i] = i;\n\t        for (int i=4; i<MAXN; i+=2) spf[i] = 2;\n\t        for (int i=3; i*i<MAXN; i++) if (spf[i] == i) for (int j=i*i; j<MAXN; j+=i) if (spf[j]==j) spf[j] = i;\n\t    }\n\t      \n\t    static long get(int x) {\n\t    \tArrayList<Integer> ret = new ArrayList<>();\n\t        while (x != 1) {\n\t            ret.add(spf[x]);\n\t            x = x / spf[x];\n\t        }\n\t        HashMap<Integer, Integer> temp = new HashMap<>();\n\t        for(int aa:ret) temp.put(aa, (temp.getOrDefault(aa, 0)+1)%2);\n\t        long pro = 1;\n\t        for(int aa:temp.keySet()) pro *= Math.pow(aa, temp.get(aa));\n\t        return pro;\n\t    }\n\t    \n\t}\n\t\n\tstatic LinkedList[] temp;\n\tstatic int mod = (int)Math.pow(10, 9) + 7;\n\t\n\tpublic static void main(String[] args) {\t\n//\t\tint t = sc.nextInt();\n\t\tint t = 1;\n\t\tStringBuilder ret = new StringBuilder();\n\t\twhile(t-- > 0) {\n\t\t\tlong a = sc.nextLong();\n\t\t\tlong b = sc.nextLong();\n\t\t\tint bit = 62;\n\t\t\twhile(bit >= 0 && equal(a, bit) == equal(b, bit)) {\n\t\t\t\tbit--;\n\t\t\t}\n//\t\t\tSystem.out.println(bit);\n\t\t\tSystem.out.println((1L<<(bit+1)) - 1);\n\t\t}\t\n\t\tSystem.out.println(ret);\n\t}\n\t\n\tstatic boolean equal(long num, int bit) {\n\t\treturn (num & (1L << bit)) != 0;\n\t}\n\t\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n\tstatic BufferedReader br;\n\tstatic int[] ans;\n\tpublic static void main(String[] args) throws Exception{\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tans = new int[8];\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tSystem.out.println(\"?\"+\"1 1 \"+n+\" \"+n);\n\t\tSystem.out.flush();\n\t\tint q = Integer.parseInt(br.readLine());\n\t\tcut(n);\n\t\tSystem.out.print(\"! \");\n\t\tfor(int i=0 ; i<8 ; i++)\tSystem.out.print(ans[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void solve(int x1, int y1, int x2, int y2, int t) throws Exception{\n\t\tint l=x1, r=x2;\n\t\tint xx1,yy1,xx2,yy2;\n\t\twhile(l<r){\n\t\t\tint mid = (l+r)/2;\n\t\t\tif(query(x1,y1,mid,y2)==1)\tr=mid;\n\t\t\telse\tl=mid+1;\n\t\t}\n\t\txx2 = l;\n\t\tl=x1; r=x2;\n\t\twhile(r>l){\n\t\t\tint mid = (l+r+1)/2;\n\t\t\tif(query(mid,y1,x2,y2)==1)\tl = mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\txx1 = l;\n\t\tl=y1; r=y2;\n\t\twhile(l<r){\n\t\t\tint mid = (l+r)/2;\n\t\t\tif(query(x1,y1,x2,mid)==1)\tr=mid;\n\t\t\telse\tl=mid+1;\n\t\t}\n\t\tyy2=l;\n\t\tl=y1;r=y2;\n\t\twhile(r>l){\n\t\t\tint mid = (l+r+1)/2;\n\t\t\tif(query(x1,mid,x2,y2)==1)\tl=mid;\n\t\t\telse\tr=mid-1;\n\t\t}\n\t\tyy1 = l;\n\t\tans[t] = xx1;\tans[t+1] = yy1 ; ans[t+2] = xx2;\tans[t+3] = yy2;\n\t//\tSystem.out.println(\"!\"+xx1+\" \"+yy1+\" \"+xx2+\" \"+yy2);\n\t}\n\tpublic static void cut(int n) throws Exception{\n\t\tint l=1, r=n;\n\t\twhile(l<r){\n\t\t\tint mid = (l+r)/2;\n\t\t\tif(query(1,1,n,mid)==0)\tl=mid+1;\n\t\t\telse\tr = mid;\n\t\t}\n\t\tif(query(1,1,n,l)==1 && query(1,l+1,n,n)==1){\n\t\t\tsolve(1,1,n,l,0);\n\t\t\tsolve(1,l+1,n,n,4);\n\t\t\treturn;\n\t\t}\n\t\tl=1;r=n;\n\t\twhile(l<r){\n\t\t\tint mid = (l+r)/2;\n\t\t\tif(query(1,1,mid,n)==0)\tl=mid+1;\n\t\t\telse\tr=mid;\n\t\t}\n\t\tsolve(1,1,l,n,0);\n\t\tsolve(l+1,1,n,n,4);\n\t}\n\tpublic static int query(int x1, int y1, int x2, int y2) throws Exception{\n\t\tSystem.out.println(\"?\"+x1+\" \"+y1+\" \"+x2+\" \"+y2);\n\t\tSystem.out.flush();\n\t\tint q = Integer.parseInt(br.readLine());\n\t\treturn q;\n\t}\n}", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\n/**\n * Created by artur on 18/06/18\n */\npublic class A\n{\n    private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    private StringTokenizer tokenizer = null;\n\n    long mod = 1000000007;\n\n    public static void main(String[] args) throws IOException\n    {\n        new A().solve();\n    }\n\n    private void solve() throws IOException\n    {\n        long x = nl();\n        long k = nl();\n\n        if (x == 0)\n        {\n            System.out.println(0);\n            System.exit(0);\n        }\n\n        if (k == 0)\n        {\n            System.out.println((x * 2) % mod);\n            System.exit(0);\n        }\n\n//        for (int sx = 0; sx < 100; sx++)\n//        {\n//            for (int sk = 0; sk < 100; sk++)\n//            {\n//                BigInteger n = BigInteger.valueOf(2)\n//                        .modPow(BigInteger.valueOf(k + 1), BigInteger.valueOf(mod))\n//                        .multiply(BigInteger.valueOf(x))\n//                        .add(BigInteger.ONE)\n//                        .subtract(BigInteger.valueOf(2)\n//                                .modPow(BigInteger.valueOf(k), BigInteger.valueOf(mod)))\n//                        .mod(BigInteger.valueOf(mod));\n//                long res = n.longValue();\n//\n//                long aux = aux(sx, sk);\n//                if ((res % mod) != aux) {\n//                    System.out.println(sx + \" \" + sk + \": \" + res + \" \" + aux);\n//                }\n//            }\n//        }\n\n        BigInteger n = BigInteger.valueOf(2)\n                .modPow(BigInteger.valueOf(k + 1), BigInteger.valueOf(mod))\n                .multiply(BigInteger.valueOf(x))\n                .add(BigInteger.ONE)\n                .subtract(BigInteger.valueOf(2)\n                        .modPow(BigInteger.valueOf(k), BigInteger.valueOf(mod)))\n                .mod(BigInteger.valueOf(mod));\n\n        System.out.println(n.toString());\n    }\n\n    long aux(long x, long k) {\n        long p1 = 2 * x;\n        long p2 = 2 * x - 1;\n\n        for (int i = 0; i < k - 1; i++)\n        {\n            p1 = (p1 * 2) % mod;\n            p2 = (p2 * 2 - 1) % mod;\n        }\n\n        return ((p1 + p2) % mod);\n    }\n\n    void debug(Object... os)\n    {\n        System.out.println(Arrays.deepToString(os));\n    }\n\n    int ni() throws IOException\n    {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException\n    {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException\n    {\n        return Double.parseDouble(ns());\n    }\n\n    String ns() throws IOException\n    {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n            tokenizer = new StringTokenizer(br.readLine());\n        return tokenizer.nextToken();\n    }\n\n    String nline() throws IOException\n    {\n        tokenizer = null;\n        return br.readLine();\n    }\n\n    private static long gcd(long a, long b)\n    {\n        while (b > 0)\n        {\n            long temp = b;\n            b = a % b; // % is remainder\n            a = temp;\n        }\n        return a;\n    }\n\n    private static long lcm(long a, long b)\n    {\n        return a * (b / gcd(a, b));\n    }\n}\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "//package ContestEd69;\n\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class mainD {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n    public static long[] arr;\n    public static void main(String[] args) throws IOException {\n        int n=enter.nextInt();\n        int m=enter.nextInt();\n        long k=enter.nextLong();\n        arr=new long[n+1];\n        for (int i = 1; i <n+1 ; i++) {\n            arr[i]=enter.nextLong();\n        }\n        long[] summ=new long[n+1];\n        for (int i = 1; i <n+1 ; i++) {\n            summ[i]+=arr[i]+summ[i-1];\n        }\n\n        long[] best=new long[n+1];\n\n        for (int i = 1; i <n+1 ; i++) {\n            best[i]=Math.max(0, ((i-m>=0) ? best[i-m]+summ[i]-summ[i-m]-k:0));\n        }\n        long ans=best[1];\n\n        for (int i = 1; i <n+1 ; i++) {\n            ans=Math.max(ans,best[i]);\n            for (int j = 1; j <m ; j++) {\n                ans=Math.max(ans, ((i-j>=0) ? best[i-j] -k +summ[i]-summ[i-j]:0));\n            }\n        }\n        System.out.println(ans);\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "import java.io.*;\n\nimport java.io.ObjectInputStream.GetField;\n\nimport java.math.*;\n\nimport java.text.*;\n\nimport java.util.*;\n\n\n\n//Codeforces\n\npublic class MainCodeforces1 {\n\n\tprivate static MyScanner in;\n\n\tprivate static PrintStream out;\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// helpers for input/output\n\n\t\tboolean LOCAL_TEST = false;// change to false before submitting\n\n\t\tout = System.out;\n\n\t\tif (LOCAL_TEST) {\n\n\t\t\tin = new MyScanner(\"E:\\\\zin2.txt\");\n\n\t\t}\n\n\t\telse {\n\n\t\t\tboolean usingFileForIO = false;\n\n\t\t\tif (usingFileForIO) {\n\n\t\t\t\t// using input.txt and output.txt as I/O\n\n\t\t\t\tin = new MyScanner(\"input.txt\");\n\n\t\t\t\tout = new PrintStream(\"output.txt\");\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tin = new MyScanner();\n\n\t\t\t\tout = System.out;\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\tsolve();\n\n\t}\n\n\n\n\tprivate static void solve() throws IOException\n\n\t{\n\n\t\tLong n = in.nextLong();\n\n\t\tLong k = in.nextLong();\n\n\t\tif (n == 1) {\n\n\t\t\tout.println(0);\n\n\t\t\treturn;\n\n\t\t}\n\n\n\n\t\tLong left = 2L;\n\n\t\tLong right = k;\n\n\t\tLong totSplitter = 0L;\n\n\t\tLong minAns = Long.MAX_VALUE;\n\n\t\tLong mid;\n\n\t\twhile (true) {\n\n\t\t\tmid = (left + right) / 2;\n\n\t\t\ttotSplitter = GetOut(mid, k);\n\n\t\t\tif (totSplitter >= n) {\n\n\t\t\t\tleft = mid + 1;\n\n\t\t\t\tminAns = Math.min(minAns, k - mid + 1);\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tright = mid - 1;\n\n\t\t\t}\n\n\t\t\tif (left > right)\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif (minAns == Long.MAX_VALUE)\n\n\t\t\tout.println(-1);\n\n\t\telse\n\n\t\t\tout.println(minAns);\n\n\t}\n\n\n\n\tstatic long GetOut(long k1, long k)\n\n\t{\n\n\t\treturn k1 + (k1 + k - 1) * (k - k1) / 2;\n\n\t}\n\n\n\n\t// =====================================\n\n\tstatic class MyScanner {\n\n\t\tScanner inp = null;\n\n\n\n\t\tpublic MyScanner() throws IOException\n\n\t\t{\n\n\t\t\tinp = new Scanner(System.in);\n\n\t\t}\n\n\n\n\t\tpublic MyScanner(String inputFile) throws IOException {\n\n\t\t\tinp = new Scanner(new FileInputStream(inputFile));\n\n\t\t}\n\n\n\n\t\tpublic int nextInt() throws IOException {\n\n\t\t\treturn inp.nextInt();\n\n\t\t}\n\n\n\n\t\tpublic long nextLong() throws IOException {\n\n\t\t\treturn inp.nextLong();\n\n\t\t}\n\n\n\n\t\tpublic double nextDouble() throws IOException {\n\n\t\t\treturn inp.nextDouble();\n\n\t\t}\n\n\n\n\t\tpublic String nextString() throws IOException {\n\n\t\t\treturn inp.next();\n\n\t\t}\n\n\n\n\t}\n\n\n\n}", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.util.Scanner;\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString ns = sc.next();\n\t\tsc.close();\n\t\t\n\t\tint n1 = Integer.parseInt(ns);\n\t\tint n2 = Integer.parseInt(ns.substring(0, ns.length() - 1));\n\t\tint n3 = Integer.parseInt(ns.substring(0, ns.length() - 2) + ns.substring(ns.length() - 1));\n\t\t\n\t\tint max = n1;\n\t\tmax = (n2 > max) ? (n2) : (max);\n\t\tmax = (n3 > max) ? (n3) : (max);\n\t\t\n\t\tSystem.out.println(max);\t\t\n\t}\n}", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n    protected static final double EPS = 1e-11;\n    private static StreamTokenizer in;\n    private static Scanner ins;\n    private static PrintWriter out;\n    protected static final Double[] BAD = new Double[]{null, null};\n    private boolean[][] layouts;\n    private int c;\n    private int b;\n    private int a;\n    private String word;\n\n    public static void main(String[] args) {\n\n        try {\n            in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n            ins = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n            out = new PrintWriter(System.out);\n            try {\n                if (System.getProperty(\"xDx\") != null) {\n                    in = new StreamTokenizer(new BufferedReader(new FileReader(\"input.txt\")));\n                    ins = new Scanner(new FileReader(\"input.txt\"));\n                    out = new PrintWriter(new FileWriter(\"output.txt\"));\n                }\n            } catch (Exception e) {\n                in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n                ins = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n                out = new PrintWriter(System.out);\n            }\n            new Main().run();\n        } catch (Throwable e) {\n//            e.printStackTrace();\n            throw new RuntimeException(e);\n        } finally {\n            out.close();\n        }\n    }\n\n    private int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    private long nextLong() throws IOException {\n        in.nextToken();\n        return (long) in.nval;\n    }\n\n    private double nextDouble() throws IOException {\n        in.nextToken();\n        return in.nval;\n    }\n\n    private String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    private char nextChar() throws IOException {\n        in.nextToken();\n        return (char) in.ttype;\n    }\n\n    private void run() throws Exception {\n        /*int t = nextInt();\n        for (int i = 0; i < t; i++) {\n            out.printf(Locale.US, \"Case #%d: %d\\n\", i + 1, solve());\n        }*/\n        solve();\n    }\n\n    private void solve() throws IOException {\n        int n = ins.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = ins.nextInt();\n        }\n\n        Map<Long, Integer> map = new HashMap<>();\n\n        BigInteger res = BigInteger.ZERO;\n        long sum = 0;\n        long amount = 0;\n\n        for (int i = n - 1; i >= 0; i--) {\n            long cur = a[i];\n            Pair same = getZeroAmount(cur, map);\n\n            res = res.add(BigInteger.valueOf((sum - same.sum) - cur * (amount - same.amount)));\n            amount++;\n            sum += cur;\n            map.put(cur, map.getOrDefault(cur, 0) + 1);\n        }\n\n        out.println(res);\n    }\n\n    class Pair {\n        long amount;\n        long sum;\n\n        public Pair(long amount, long sum) {\n            this.amount = amount;\n            this.sum = sum;\n        }\n    }\n\n    private Pair getZeroAmount(long cur, Map<Long, Integer> map) {\n        long amount = 0;\n        long sum = 0;\n        for (long i = cur - 1; i <= cur + 1; i++) {\n            long amountI = map.getOrDefault(i, 0);\n            amount += amountI;\n            sum += amountI * i;\n        }\n        return new Pair(amount, sum);\n    }\n\n    private List<Integer> iterate(List<Integer> a) {\n        ArrayList<Integer> b = new ArrayList<>();\n        int prev = -1;\n        for (int x : a) {\n            if (x == prev) {\n                b.add(x);\n            } else {\n                prev = x;\n            }\n        }\n        return b;\n    }\n\n    private long gcd(long a, long b) {\n        while (a > 0 && b > 0) {\n            long k = a % b;\n            a = b;\n            b = k;\n        }\n\n        return a | b;\n    }\n\n}", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.util.*;\n\nimport java.math.*;\n\nimport java.io.*;\n\n\n\npublic class Main\n\n    {\n\n    public static void main(String args[]) throws IOException\n\n        {\n\n        Scanner c=new Scanner(System.in);\n\n        PrintWriter out=new PrintWriter(System.out);\n\n        long N=c.nextLong()-1;\n\n        long K=c.nextLong()-1;\n\n        long tot=(K*(K+1))/2;\n\n        //System.out.println(tot);\n\n        if(N>tot)\n\n            {\n\n            System.out.println(-1);\n\n            return;\n\n            }\n\n        long lo=1;\n\n        long hi=K;\n\n        while(hi-lo>=10)\n\n            {\n\n            long mid=(hi+lo)/2;\n\n            //maximum outlets using mid pipes\n\n            long sum=(mid*(mid-1))/2;\n\n            long left=mid*K-sum;\n\n            if(left>=N)\n\n                hi=mid+1;\n\n            else\n\n                lo=mid-1;\n\n            }\n\n        for(int num=(int)lo-1000;num<lo+1000;num++)\n\n            {\n\n            if(num>=0)\n\n                {\n\n                long sum=((long)num*(num-1))/2;\n\n                long left=(long)num*K-sum;\n\n                if(left>=N)\n\n                    {\n\n                    System.out.println(num);\n\n                    return;\n\n                    }\n\n                }\n\n            }\n\n        out.close();\n\n        }\n\n    }\n\n\n\nclass InputReader\n\n    {\n\n    private InputStream stream;\n\n    private byte[] buf=new byte[1024];\n\n    private int curChar;\n\n    private int numChars;\n\n    private SpaceCharFilter filter;\n\n\n\n    public InputReader(InputStream stream)\n\n        {\n\n        this.stream=stream;\n\n        }\n\n\n\n    public int read()\n\n        {\n\n        if(numChars==-1)\n\n            throw new InputMismatchException();\n\n        if(curChar>=numChars)\n\n            {\n\n            curChar=0;\n\n            try\n\n                {\n\n                numChars=stream.read(buf);\n\n                } catch (IOException e)\n\n                {\n\n                throw new InputMismatchException();\n\n                }\n\n            if(numChars<=0)\n\n                return -1;\n\n            }\n\n        return buf[curChar++];\n\n        }\n\n\n\n    public int readInt()\n\n        {\n\n        int c=read();\n\n        while (isSpaceChar(c))\n\n            c=read();\n\n        int sgn=1;\n\n        if(c=='-')\n\n            {\n\n            sgn=-1;\n\n            c=read();\n\n            }\n\n        int res=0;\n\n        do\n\n            {\n\n            if(c<'0'||c>'9')\n\n                throw new InputMismatchException();\n\n            res*=10;\n\n            res+=c-'0';\n\n            c=read();\n\n            } while (!isSpaceChar(c));\n\n        return res*sgn;\n\n        }\n\n\n\n    public boolean isSpaceChar(int c)\n\n        {\n\n        if(filter!=null)\n\n            return filter.isSpaceChar(c);\n\n        return isWhitespace(c);\n\n        }\n\n\n\n    public static boolean isWhitespace(int c)\n\n        {\n\n        return c==' '||c=='\\n'||c=='\\r'||c=='\\t'||c==-1;\n\n        }\n\n\n\n    public char readCharacter()\n\n        {\n\n        int c=read();\n\n        while (isSpaceChar(c))\n\n            c=read();\n\n        return (char) c;\n\n        }\n\n\n\n    public interface SpaceCharFilter\n\n        {\n\n        public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.FileNotFoundException;\n\nimport java.io.FileReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.math.BigInteger;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.LinkedList;\n\nimport java.util.Map.Entry;\n\nimport java.util.Queue;\n\nimport java.util.Scanner;\n\nimport java.util.Set;\n\nimport java.util.Stack;\n\nimport java.util.StringTokenizer;\n\nimport java.util.TreeMap;\n\nimport java.util.Vector;\n\n \n\n \n\n \n\npublic class codeforces {\n\n\tstatic int k;\n\n\tpublic static void main(String[] args) throws IOException{\n\n \n\n\t\tFastScanner sc = new FastScanner();\n\n\t    PrintWriter out = new PrintWriter(System.out);\n\n\t    long l =sc.nextLong();\n\n\t    long r=sc.nextLong();\n\n\t    long ans =0 ;\n\n\t    long i=62;\n\n\t    for( ;i>=0&& on(l,i)==on(r,i);){\n\n\t    \t--i;\n\n\t    }\n\n\t    System.out.println((long)Math.pow(2, i+1)-1);\n\n\t    \n\n}\n\n\t\n\n\tstatic boolean on(long n, long i) {\n\n        return (n & (1L << i)) != 0;\n\n    }\n\n    \n\n\t\n\n\t\n\n\t\n\n\n\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*static boolean next_permutation(int[] p) {\n\n\t\t  for (int a = p.length - 2; a >= 0; --a)\n\n\t\t    if (p[a] < p[a + 1])\n\n\t\t      for (int b = p.length - 1;; --b)\n\n\t\t        if (p[b] > p[a]) {\n\n\t\t          int t = p[a];\n\n\t\t          p[a] = p[b];\n\n\t\t          p[b] = t;\n\n\t\t          for (++a, b = p.length - 1; a < b; ++a, --b) {\n\n\t\t            t = p[a];\n\n\t\t            p[a] = p[b];\n\n\t\t            p[b] = t;\n\n\t\t          }\n\n\t\t          return true;\n\n\t\t        }\n\n\t\t  return false;\n\n\t\t}\n\n \n\n\t  */  \n\n \n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nclass FastScanner {\n\n \n\n \n\n \n\n \n\n    BufferedReader br;\n\n    StringTokenizer st;\n\n \n\n    public FastScanner() {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n\n    }\n\n \n\n    public FastScanner(String s) {\n\n        try {\n\n            br = new BufferedReader(new FileReader(s));\n\n        } catch (FileNotFoundException e) {\n\n            e.printStackTrace();\n\n        }\n\n    }\n\n \n\n    String nextToken() {\n\n        while (st == null || !st.hasMoreElements()) {\n\n            try {\n\n \n\n                st = new StringTokenizer(br.readLine());\n\n            } catch (IOException e) {\n\n                e.printStackTrace();\n\n            }\n\n        }\n\n        return st.nextToken();\n\n    }\n\n \n\n    int nextInt() {\n\n        return Integer.parseInt(nextToken());\n\n    }\n\n \n\n    long nextLong() {\n\n        return Long.parseLong(nextToken());\n\n    }\n\n \n\n    double nextDouble() {\n\n        return Double.parseDouble(nextToken());\n\n    }\n\n \n\n \n\n}", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "//package first;\n\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static int red=2,green=5,blue=8;\n\t@SuppressWarnings(\"unused\")\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(in.hasNext()) \n\t\t{\n\t\t\tint n,k;\n\t\t\tn=in.nextInt();\n\t\t\tk=in.nextInt();\n\t\t\tint sum=0;\n\t\t\tif(red*n%k==0)\n\t\t\t\tsum+=(red*n)/k;\n\t\t\telse\n\t\t\t\tsum+=(red*n)/k+1;\n\t\t\tif(green*n%k==0)\n\t\t\t\tsum+=(green*n)/k;\n\t\t\telse\n\t\t\t\tsum+=(green*n)/k+1;\n\t\t\tif(blue*n%k==0)\n\t\t\t\tsum+=(blue*n)/k;\n\t\t\telse\n\t\t\t\tsum+=(blue*n)/k+1;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n}\n", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.Comparator;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int count = in.readInt();\n        int[] array = IOUtils.readIntArray(in, count);\n        int[] sorted = array.clone();\n        ArrayUtils.sort(sorted, IntComparator.DEFAULT);\n        int differs = 0;\n        for (int i = 0; i < count; i++) {\n            if (array[i] != sorted[i])\n                differs++;\n        }\n        if (differs <= 2)\n            out.printLine(\"YES\");\n        else\n            out.printLine(\"NO\");\n    }\n}\n\nclass InputReader {\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n    }\n\nclass IOUtils {\n\n    public static int[] readIntArray(InputReader in, int size) {\n        int[] array = new int[size];\n        for (int i = 0; i < size; i++)\n            array[i] = in.readInt();\n        return array;\n    }\n\n    }\n\nclass ArrayUtils {\n    private static int[] tempInt = new int[0];\n\n    public static int[] sort(int[] array, IntComparator comparator) {\n        return sort(array, 0, array.length, comparator);\n    }\n\n    public static int[] sort(int[] array, int from, int to, IntComparator comparator) {\n        ensureCapacityInt(to - from);\n        System.arraycopy(array, from, tempInt, 0, to - from);\n        sortImpl(array, from, to, tempInt, 0, to - from, comparator);\n        return array;\n    }\n\n    private static void ensureCapacityInt(int size) {\n        if (tempInt.length >= size)\n            return;\n        size = Math.max(size, tempInt.length << 1);\n        tempInt = new int[size];\n    }\n\n    private static void sortImpl(int[] array, int from, int to, int[] temp, int fromTemp, int toTemp, IntComparator comparator) {\n        if (to - from <= 1)\n            return;\n        int middle = (to - from) >> 1;\n        int tempMiddle = fromTemp + middle;\n        sortImpl(temp, fromTemp, tempMiddle, array, from, from + middle, comparator);\n        sortImpl(temp, tempMiddle, toTemp, array, from + middle, to, comparator);\n        int index = from;\n        int index1 = fromTemp;\n        int index2 = tempMiddle;\n        while (index1 < tempMiddle && index2 < toTemp) {\n            if (comparator.compare(temp[index1], temp[index2]) <= 0)\n                array[index++] = temp[index1++];\n            else\n                array[index++] = temp[index2++];\n        }\n        if (index1 != tempMiddle)\n            System.arraycopy(temp, index1, array, index, tempMiddle - index1);\n        if (index2 != toTemp)\n            System.arraycopy(temp, index2, array, index, toTemp - index2);\n    }\n\n    }\n\ninterface IntComparator {\n    public static final IntComparator DEFAULT = new IntComparator() {\n        public int compare(int first, int second) {\n            if (first < second)\n                return -1;\n            if (first > second)\n                return 1;\n            return 0;\n        }\n    };\n\n    public int compare(int first, int second);\n}", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class A {\n\n    public static void main(String[] args) {\n    \tScanner s = new Scanner(System.in);\n    \tlong n = s.nextLong();\n    \tif(n >= 0)\n    \t\tSystem.out.println(n);\n    \telse {\n    \t\tString str = (\"\" + n).substring(1);\n    \t\tif(str.length() == 1)\n    \t\t\tSystem.out.println(\"-\" + str);\n    \t\telse {\n    \t\t\tlong one = Long.parseLong(str.substring(0, str.length()-1));\n    \t\t\tlong two = Long.parseLong(str.substring(0, str.length()-2) + str.substring(str.length()-1));\n    \t\t\tif(one > two)\n    \t\t\t\tSystem.out.println((two!=0?\"-\":\"\") + two);\n    \t\t\telse\n    \t\t\t\tSystem.out.println((one!=0?\"-\":\"\") + one);\n    \t\t}\n    \t}\n    }\n}\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public int mod = 1000000007;\n        public int MAXN = 333;\n        public int[][] w1;\n        public long[] fact;\n        public long[] ifact;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            long[][] e = Factorials.getFIF(MAXN, mod);\n            fact = e[0];\n            ifact = e[1];\n            w1 = new int[MAXN][MAXN];\n            w1[0][0] = 1;\n            for (int i = 1; i < MAXN; i++) {\n                for (int j = 1; j < MAXN; j++) {\n                    for (int k = 1; k <= i; k++) {\n                        w1[i][j] += w1[i - k][j - 1];\n                        if (w1[i][j] >= mod) w1[i][j] -= mod;\n                    }\n                }\n            }\n\n            int n = in.nextInt();\n            int[] arr = in.readIntArray(n);\n            boolean[] marked = new boolean[n];\n            int[] fs = new int[n];\n            int fidx = 0;\n            for (int i = 0; i < n; i++) {\n                if (marked[i]) continue;\n                int count = 0;\n                for (int j = 0; j < n; j++) {\n                    if (isSquare(1L * arr[i] * arr[j])) {\n                        if (marked[j]) System.exit(1);\n                        marked[j] = true;\n                        count++;\n                    }\n                }\n                fs[fidx++] = count;\n            }\n\n            fs = Arrays.copyOf(fs, fidx);\n            long x = 1;\n            for (int j : fs) x = x * fact[j] % mod;\n            x = x * solve(fs) % mod;\n            out.println(x);\n        }\n\n        public boolean isSquare(long x) {\n            long d = (long) (Math.sqrt(x));\n            while (d * d < x) d++;\n            while (d * d > x) d--;\n            return d * d == x;\n        }\n\n        public int solve(int[] freq) {\n            int d = AUtils.sum(freq);\n            int b = AUtils.max(freq);\n            if (d == 0) return 1;\n            if (b + b - 1 > d) return 0;\n            int[] dp = new int[1];\n            dp[0] = 1;\n            for (int j = 0; j < freq.length; j++) {\n                if (freq[j] == 0) continue;\n                int[] nxt = new int[dp.length + freq[j]];\n                for (int pgr = 0; pgr < dp.length; pgr++) {\n                    for (int cgr = 1; cgr <= freq[j]; cgr++) {\n                        nxt[pgr + cgr] += 1L * dp[pgr] * w1[freq[j]][cgr] % mod * ifact[cgr] % mod;\n                        if (nxt[pgr + cgr] >= mod) nxt[pgr + cgr] -= mod;\n                    }\n                }\n                dp = nxt;\n            }\n\n            int res = 0;\n            for (int i = 0; i < dp.length; i++) {\n                long x = 1L * dp[i] * fact[i] % mod;\n                if ((d - i) % 2 == 0) res += x;\n                else res -= x;\n                if (res >= mod) res -= mod;\n                if (res < 0) res += mod;\n            }\n            return res;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int tokens) {\n            int[] ret = new int[tokens];\n            for (int i = 0; i < tokens; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n\n    static class AUtils {\n        public static int max(int[] arr) {\n            int res = arr[0];\n            for (int x : arr) res = Math.max(res, x);\n            return res;\n        }\n\n        public static int sum(int[] arr) {\n            int sum = 0;\n            for (int x : arr) {\n                sum += x;\n            }\n            return sum;\n        }\n\n    }\n\n    static class Factorials {\n        public static long[][] getFIF(int max, int mod) {\n            long[] fact = new long[max];\n            long[] ifact = new long[max];\n            long[] inv = new long[max];\n            inv[1] = 1;\n            for (int i = 2; i < max; i++) {\n                inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n            }\n            fact[0] = 1;\n            ifact[0] = 1;\n            for (int i = 1; i < max; i++) {\n                fact[i] = fact[i - 1] * i % mod;\n                ifact[i] = ifact[i - 1] * inv[i] % mod;\n            }\n            return new long[][]{fact, ifact, inv};\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "complexity": "cubic", "problem": "0840_C", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author George Marcus\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        long a = in.nextLong();\n        long b = in.nextLong();\n\n        long res = 0;\n\n        while(a > 1 && b > 1) {\n            if(a < b) {\n                res += b / a;\n                b %= a;\n            }\n            else {\n                res += a / b;\n                a %= b;\n            }\n        }\n\n        if(a == 1)\n            res += b;\n        else\n            res += a;\n\n        out.println(res);\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public long nextLong() {\n        return Long.parseLong(nextString());\n    }\n\n    public String nextString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n\n        return res.toString();\n    }\n\n    private boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    }\n\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.Scanner;\n\npublic class GivenString {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        \n        String s = input.nextLine();\n        \n        int max = 0;\n        \n        for(int i = 0; i < s.length(); i++) {\n            for(int j = i + 1; j <= s.length(); j++) {\n                String tmp = s.substring(i, j);\n                int match = 0;\n                for(int k = 0; k + tmp.length() <= s.length(); k++) {\n                    if(tmp.equals(s.substring(k, k + tmp.length()))) {\n                        match++;                        \n                    }\n                }\n                if(match >= 2) {\n                    max = Math.max(max, tmp.length());\n                }\n            }\n        }\n        System.out.println(max);\n        System.exit(0);\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n    String fileName = \"<name>\";\n\n    public TreeSet<Integer> set = new TreeSet<>();\n\n    public int getLowerDist(int x) {\n        Integer higher = set.higher(x);\n        Integer lower = set.lower(x);\n        if (higher == null)\n            return lower;\n        if (lower == null)\n            return higher;\n        if (Math.abs(x - higher) < Math.abs(x - lower)) {\n            return higher;\n        } else {\n            return lower;\n        }\n    }\n\n    public void solve() throws IOException {\n        int n = nextInt();\n        int d = nextInt();\n        int[] a = new int[n];\n        Set<Integer> ans = new HashSet<>((int) 1e6, 1f);\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n            set.add(a[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            int pos1 = a[i] + d;\n            int pos2 = a[i] - d;\n            if (!set.contains(pos1) && Math.abs(pos1 - getLowerDist(pos1)) == d) {\n                ans.add(pos1);\n            }\n            if (!set.contains(pos2) && Math.abs(pos2 - getLowerDist(pos2)) == d) {\n                ans.add(pos2);\n            }\n        }\n        out.print(ans.size());\n    }\n\n    public void run() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    BufferedReader br;\n    StringTokenizer in;\n    PrintWriter out;\n\n    public String nextToken() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n        return in.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public static void main(String[] args) throws IOException {\n        Locale.setDefault(Locale.US);\n        new A().run();\n    }\n}", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.*;\nimport java.util.Arrays;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\tint n = nextInt();\n\t\tint a = nextInt();\n\t\tint b = nextInt();\n\t\tint[] tasks = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ttasks[i] = nextInt();\n\t\t}\n\t\tArrays.sort(tasks);\n\t\texit(tasks[b] - tasks[b-1]);\n\t\t\n\t}\n\t\n\tprivate static PrintWriter out;\n\tprivate static BufferedReader inB;\n\tprivate static boolean FILE = false; \n\t\n\tstatic {\n\t\ttry {\n\t\t\tout = new PrintWriter(FILE ? (new FileOutputStream(\"output.txt\")) : System.out);\n\t\t\tinB = new BufferedReader(new InputStreamReader(FILE ? new FileInputStream(\"input.txt\") : System.in));\n\t\t} catch(Exception e) {e.printStackTrace();}\n\t}\n\t\n\tprivate static StreamTokenizer in = new StreamTokenizer(inB);\n\t\n\tprivate static void exit(Object o) throws Exception {\n\t\tout.println(o);\n\t\tout.flush();\n\t\tSystem.exit(0);\n\t}\n\tprivate static void println(Object o) throws Exception{\n\t\tout.println(o);\n\t\tout.flush();\n\t}\n\tprivate static void print(Object o) throws Exception{\n\t\tout.print(o);\n\t\tout.flush();\n\t}\n\tprivate static int nextInt() throws Exception {\n\t\tin.nextToken();\n\t\treturn (int)in.nval;\n\t}  \n\tprivate static String nextString() throws Exception {\n\t\tin.nextToken();\n\t\treturn in.sval;        \n\t}\n} ", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport static java.lang.Math.PI;\nimport static java.lang.System.in;\nimport static java.lang.System.out;\nimport static java.lang.System.err;\n/*\n11\n1\n1\n1\n2\n2\n1\n2\n1\n2\n2\n3\n*/\npublic class C {    \n    static public void main(String... args) throws Exception {   \n        Foster sc = new Foster();\n        PrintWriter p = new PrintWriter(out);\n        int t = sc.nextInt();\n        while(t--!=0){\n            int n = sc.nextInt();\n            int a[] = sc.intArray(n);\n            ArrayList<ArrayList<Integer>> arr = new ArrayList<>();\n            for(int i = 0; i < n; i++){\n                ArrayList<Integer> temp = new ArrayList<>();\n                if(i-1 < 0){\n                    temp.add(1);\n                }\n                else{\n                    ArrayList<Integer> inner = arr.get(i-1);\n                    int last = inner.get(inner.size()-1);\n                    ArrayDeque<Integer> q = new ArrayDeque<>();\n                    for(int j : inner){\n                        q.addLast(j);\n                    }\n                    // if current is one greater then increment\n                    if(last+1 == a[i]){\n                        q.pollLast();\n                        q.addLast(a[i]);\n                    }\n                    // move the chain\n                    else if(a[i]==1){\n                        q.addLast(a[i]);\n                    }\n                    // move back\n                    else{\n                        while(!q.isEmpty() && a[i]-q.peekLast() != 1){\n                            q.pollLast();\n                        }\n                        if(q.isEmpty()) q.addLast(a[i]);\n                        else{\n                            q.pollLast();\n                            q.addLast(a[i]);\n                        }\n                    }\n                    // transfer queue to list\n                    while(!q.isEmpty()){\n                        temp.add(q.pollFirst());\n                    }\n                }\n                arr.add(temp);\n            }\n\n            // output answer\n            for(int i = 0; i < arr.size(); i++){\n                p.print(arr.get(i).get(0));\n                for(int j = 1; j < arr.get(i).size(); j++){\n                    p.print(\".\" + arr.get(i).get(j));\n                }\n                p.println();\n            }\n        }\n        p.close();\n    }\n    \n    static long[] sort(long a[]){\n        ArrayList<Long> arr = new ArrayList<>();\n        for(long i : a){\n            arr.add(i);\n        }\n        Collections.sort(arr);\n        for(int i = 0; i < arr.size(); i++){\n            a[i] = arr.get(i);\n        }\n        return a;\n    }\n    static int[] sort(int a[]){\n        ArrayList<Integer> arr = new ArrayList<>();\n        for(int i : a){\n            arr.add(i);\n        }\n        Collections.sort(arr);\n        // Collections.reverse(arr);\n        for(int i = 0; i < arr.size(); i++){\n            a[i] = arr.get(i);\n        }\n        return a;\n    }\n    \n    \n/* \n*/    \n/*\n1. Check overflow in pow function or in general\n2. Check indices of read array function\n3. Think of an easier solution because the problems you solve are always easy\n4. Check iterator of loop\n5. If still doesn't work, then jump from the 729th floor 'coz \"beta tumse na ho paayega\"\n\n    Move to top!!\n*/\n    static class Foster {\n        BufferedReader br = new BufferedReader(new InputStreamReader(in));\n        StringTokenizer st = new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        int[] intArray(int n) {                   // Check indices\n            int arr[] = new int[n];\n            for(int i = 0; i < n; i++) {\n                arr[i] = nextInt();\n            }\n            return arr;\n        }\n        long[] longArray(int n) {                 // Check indices\n            long arr[] = new long[n];\n            for(int i = 0; i < n; i++) {\n                arr[i] = nextLong();\n            }\n            return arr;\n        }\n        int[] getBits(int n) {                   //in Reverse Order\n            int a[] = new int[31];\n            for(int i = 0; i < 31; i++) {\n                if(((1<<i) & n) != 0)\n                    a[i] = 1;\n            }\n            return a;\n        }\n        static long pow(long... a) {\n            long mod = Long.MAX_VALUE;\n            if(a.length == 3)   mod = a[2];\n            long res = 1;\n            while(a[1] > 0) {\n                if((a[1] & 1) == 1)\n                    res = (res * a[0]) % mod;\n                a[1] /= 2;\n                a[0] = (a[0] * a[0]) % mod;\n            }\n            return res;\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.util.List;\nimport java.util.Scanner;\nimport java.util.Comparator;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author @zhendeaini6001\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n     class Pair{\n\t\tpublic int a;\n\t\tpublic int b;\n\t\tpublic Pair(int a, int b) {\n\t\t\t// TODO Auto-generated constructor stub\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        int n = in.nextInt();\n        int k = in.nextInt();  --k;\n        ArrayList<Pair> list = new ArrayList<Pair>();\n\t\tfor (int i = 1; i <= n; ++i){\n            int num = in.nextInt();\n            int pen = in.nextInt();\n\t\t\tPair t = new Pair(num, pen);\n\t\t    list.add(t);\n        }\n        Collections.sort(list, new Comparator<Pair>(){\n\t\t\t\tpublic int compare(Pair o1, Pair o2){\n\t\t\t\t\tif (o1.a != o2.a){\n\t\t\t\t\t\treturn (o2.a - o1.a);\n\t\t\t\t\t}\n\t\t\t\t\treturn (o1.b - o2.b);\n\t\t\t\t}\n\t\t});\n\n        int res = 1;\n        Pair compare = list.get(k);\n        int i = k - 1;\n        while (i >= 0){\n            Pair t = list.get(i);\n            if (t.a == compare.a && t.b == compare.b){\n                --i;\n                ++res;\n                continue;\n            }else{\n                break;\n            }\n        }\n       i = k + 1;\n        while (i < list.size()){\n            Pair t = list.get(i);\n            if (t.a == compare.a && t.b == compare.b){\n                ++res; ++i;\n                continue;\n            }else{\n                break;\n            }\n        }\n        out.println(res);\n       return;\n    }\n}\n\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tFastReader sc=new FastReader();\n\t\tlong n=sc.L();\n\t\tlong k=sc.L();\n\t\tlong x=8*(n+k);\n\t\tx+=9;\n\t\tx=(long)Math.sqrt(x)-3;\n\t\tx/=2;\n\t\t\n\t\tSystem.out.println(n-x);\n\t }\n\t static int binarysearch(int x,int[] b,int n)\n\t {\n\t     int l=0,r=n-1,m=(l+r)/2;\n\t     if(x<b[0]||x>b[r])\n\t     return -1;\n\t     while(l<=r)\n\t     {\n\t         m=(l+r)/2;\n\t         if(b[m]==x)\n\t         return m;\n\t         if(b[m]>x)\n\t         r=m-1;\n\t         else\n\t         l=m+1;\n\t     }\n\t     return -1;\n\t }\n\t static int lower(int x,int b[],int n)\n\t {\n\t     if(x<b[0])\n\t     return -1;\n\t     else if(x==b[0])\n\t     return 0;\n\t     if(x>=b[n-1])\n\t     return n-1;\n\t     int l=0,r=n-1,m=(l+r)/2;\n\t     while(l<=r)\n\t     {\n\t         m=(l+r)/2;\n\t         if(b[m]<=x&&b[m+1]>x)\n\t         return m;\n\t         else if(b[m]>x&&b[m-1]<=x)\n\t         return m-1;\n\t         if(b[m]>x)\n\t         r=m-1;\n\t         else if(b[m]<x)\n\t         l=m+1;\n\t     }\n\t     return -1;\n\t }\n\t static int upper(int x,int b[],int n)\n\t {\n\t     if(x<=b[0])\n\t     return 0;\n\t     else if(x==b[n-1])\n\t     return n-1;\n\t     if(x>b[n-1])\n\t     return -1;\n\t     int l=0,r=n-1,m=(l+r)/2;\n\t     while(l<=r)\n\t     {\n\t         m=(l+r)/2;\n\t         if(b[m]<x&&b[m+1]>=x)\n\t         return m+1;\n\t         else if(b[m]>=x&&b[m-1]<x)\n\t         return m;\n\t         if(b[m]>x)\n\t         r=m-1;\n\t         else if(b[m]<x)\n\t         l=m+1;\n\t     }\n\t     return -1;\n\t }\n\t \n\t static long power(long x, long y, long p) \n    { \n        // Initialize result \n        long res = 1;      \n         \n        // Update x if it is more   \n        // than or equal to p \n        x = x % p;  \n      \n        while (y > 0) \n        { \n            // If y is odd, multiply x \n            // with result \n            if((y & 1)==1) \n                res = (res * x) % p; \n      \n            // y must be even now \n            // y = y / 2 \n            y = y >> 1;  \n            x = (x * x) % p;  \n        } \n        return res; \n    } \n\t  static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int I() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long L() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double D() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n    static int gcd(int a,int b)\n\t\t{\n\t\t    if(a%b==0)\n\t\t    return b;\n\t\t    return gcd(b,a%b);\n\t\t}\n\tstatic float power(float x, int y) \n    { \n        float temp; \n        if( y == 0) \n            return 1; \n        temp = power(x, y/2);  \n          \n        if (y%2 == 0) \n            return temp*temp; \n        else\n        { \n            if(y > 0) \n                return x * temp * temp; \n            else\n                return (temp * temp) / x; \n        } \n    } \n    static long pow(int a,int b)\n    {\n        long result=1;\n        if(b==0)\n        return 1;\n        long x=a;\n        while(b>0)\n        {\n            if(b%2!=0)\n            result*=x;\n            \n            x=x*x;\n            b=b/2;\n        }\n        return result;\n    }\n    \n    static ArrayList<Integer> sieveOfEratosthenes(int n) \n    { \n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        boolean prime[] = new boolean[n+1]; \n        for(int i=2;i<n;i++) \n            prime[i] = true; \n          \n        for(int p = 2; p*p <=n; p++) \n        { \n            if(prime[p] == true) \n            { \n                arr.add(p);\n                for(int i = p*p; i <= n; i += p) \n                    prime[i] = false; \n            } \n        } \n        return arr;\n    } \n}", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Traffic extends Template{\n\tpublic double search1(int a, int w, int d){\n\t\tdouble s = 0;\n\t\tdouble l = 2*w+2*a*d;\n\t\tint repeat = 100;\n\t\twhile( repeat-- > 0 ){\n\t\t\tdouble x = (s+l)/2;\n\t\t\tif( a*a*x*x + 2*a*w*x - w*w - 4*a*d > 0 ){\n\t\t\t\tl = x;\n\t\t\t} else {\n\t\t\t\ts = x;\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\t\n\tpublic double search2(int a, double lim, int k){\n\t\tdouble s = 0;\n\t\tdouble l = lim + 2*a*k;\n\t\tint repeat = 100;\n\t\twhile( repeat-- > 0 ){\n\t\t\tdouble x = (s+l)/2;\n\t\t\tif( a*x*x + 2*lim*x - 2*k > 0 ){\n\t\t\t\tl = x;\n\t\t\t} else {\n\t\t\t\ts = x;\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\t\n\tpublic void solve() throws IOException {\n\t\tint a = nextInt();\n\t\tint v = nextInt();\n\t\tint l = nextInt();\n\t\tint d = nextInt();\n\t\tint w = nextInt();\n\t\tif( w > v ){\n\t\t\tw = v;\n\t\t}\n\t\tdouble time_max = Math.sqrt((double)2*d/a);\n\t\tdouble time_d = search1(a,w,d);\n\t//\twriter.println(time_max*a < w); writer.println(v <= (w+a*time_d)/2); writer.println(w < v); \n\t\tdouble t1 = (time_max*a < w) ? time_max : (v >= (w+a*time_d)/2) ? time_d : (w < v) ? (double)(2*v*v-2*v*w+2*a*d+w*w)/(2*a*v) : (double)v/a + (double)(d-(double)v*v/(2*a))/v;\n\t\tdouble lim = (time_max*a < w) ? time_max*a : w;\n\t\tdouble t3 = Math.min((double)(v-lim)/a, search2(a, lim, l-d));\n//\t\tdouble t = (Math.sqrt(limit*limit+2*a*(l-d))-limit)/a;\n\t\tdouble dist2 = (l-d) - t3*t3*a/2 - t3*lim;\n\t\tdouble t4 = dist2/v;\n//\t\twriter.println(\"t1 = \" + t1);\n//\t\twriter.println(\"dist1 = \" + dist1);\n//\t\twriter.println(\"t3 = \" + t3);\n//\t\twriter.println(\"dist2 = \" + dist2);\n//\t\twriter.println(\"t4 = \" + t4);\n\t\twriter.println((t1+t3+t4));\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Traffic().run();\n\t}\n}\n\nabstract class Template implements Runnable{\n\tpublic abstract void solve() throws IOException;\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run(){\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch(Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class C {\n\n    public static void main(String[] args) throws IOException {\n        init(System.in);\n        BigInteger x = new BigInteger(next());\n        if (x.compareTo(BigInteger.ZERO) == 0) {\n            System.out.println(0);\n            return;\n        }\n        BigInteger k = new BigInteger(next());\n        BigInteger mod = new BigInteger(\"1000000007\");\n        BigInteger two = BigInteger.ONE.add(BigInteger.ONE);\n        BigInteger ans = two.modPow(k, mod);\n        ans = ans.multiply(two.multiply(x).subtract(BigInteger.ONE)).add(BigInteger.ONE).mod(mod);\n        System.out.println(ans);\n    }\n\n    //Input Reader\n    private static BufferedReader reader;\n    private static StringTokenizer tokenizer;\n\n    private static void init(InputStream inputStream) {\n        reader = new BufferedReader(new InputStreamReader(inputStream));\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    private static String next() throws IOException {\n        String read;\n        while (!tokenizer.hasMoreTokens()) {\n            read = reader.readLine();\n            if (read == null || read.equals(\"\"))\n                return \"-1\";\n            tokenizer = new StringTokenizer(read);\n        }\n\n        return tokenizer.nextToken();\n    }\n\n//    private static int nextInt() throws IOException {\n//        return Integer.parseInt(next());\n//    }\n\n//    private static long nextLong() throws IOException {\n//        return Long.parseLong(next());\n//    }\n//\n//    //    Get a whole line.\n//    private static String line() throws IOException {\n//        return reader.readLine();\n//    }\n//\n//    private static double nextDouble() throws IOException {\n//        return Double.parseDouble(next());\n//    }\n}\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.*;\npublic class main {\n\tpublic static void main(String[] args) {\n\t\tScanner kb=new Scanner(System.in);\n\t\twhile(kb.hasNext()){\n\t\t\tlong a=kb.nextLong();\n\t\t\tlong b=kb.nextLong();\n\t\t\tif(a<b){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}else{\n\t\t\t\tint n=0;\n\t\t\t\tlong i=0;\n\t\t\t\tfor (i = b; i <= a; i++) {\n\t\t\t\t\tint sum=0;\n\t\t\t\t\tlong aa=i;\n\t\t\t\t\twhile(aa!=0){\n\t\t\t\t\t\tsum=(int) (sum+aa%10);\n\t\t\t\t\t\taa=aa/10;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i-sum>=b){\n\t\t\t\t\t\tif(i%10==9){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(n+a-i+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \t\t \t\t\t\t\t    \t\t \t\t  \t \t\t\t \t\t\t\t", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.awt.Point;\n\nimport java.io.File;\n\nimport java.io.FileInputStream;\n\nimport java.io.FileNotFoundException;\n\nimport java.io.PrintStream;\n\nimport java.util.HashSet;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\nimport java.util.Scanner;\n\n\n\npublic class FireAgain {\n\n\n\n\tPoint coordinate;\n\n\tQueue<Point> q = new LinkedList<Point>();\n\n\tint m, n;\n\n\tboolean[][] arr;\n\n\tPrintStream out ;\n\n\n\n\tvoid bfs(Point start) {\n\n\n\n\t\twhile (!q.isEmpty()) {\n\n\t\t\tPoint front = q.poll();\n\n\t\t\tPoint p = new Point();\n\n\n\n\t\t\tp.x = front.x - 1;\n\n\t\t\tp.y = front.y;\n\n\t\t\tif (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1) {\n\n\t\t\t\tif (!arr[p.x][p.y]) {\n\n\t\t\t\t\tarr[p.x][p.y] = true;\n\n\t\t\t\t\tq.add(p);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tp = new Point();\n\n\t\t\tp.x = front.x + 1;\n\n\t\t\tp.y = front.y;\n\n\t\t\tif (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1)\n\n\t\t\t\tif (!arr[p.x][p.y]) {\n\n\t\t\t\t\tarr[p.x][p.y] = true;\n\n\t\t\t\t\tq.add(p);\n\n\t\t\t\t}\n\n\n\n\t\t\tp = new Point() ;\n\n\t\t\tp.x = front.x;\n\n\t\t\tp.y = front.y + 1;\n\n\t\t\tif (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1)\n\n\t\t\t\tif (!arr[p.x][p.y]) {\n\n\t\t\t\t\tarr[p.x][p.y] = true;\n\n\t\t\t\t\tq.add(p);\n\n\t\t\t\t}\n\n\n\n\t\t\tp = new Point() ;\n\n\t\t\tp.x = front.x;\n\n\t\t\tp.y = front.y - 1;\n\n\t\t\tif (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1)\n\n\t\t\t\tif (!arr[p.x][p.y]) {\n\n\t\t\t\t\tarr[p.x][p.y] = true;\n\n\t\t\t\t\tq.add(p);\n\n\t\t\t\t}\n\n\n\n\t\t\tif (q.size() == 0)\n\n\t\t\t\tout.print(front.x + \" \" + front.y);\n\n\t\t}\n\n\t}\n\n\n\n\t/**\n\n\t * @param args\n\n\t * @throws FileNotFoundException \n\n\t */\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\t// TODO Auto-generated method stub\n\n\t\tFireAgain fa = new FireAgain();\n\n\t\tScanner Scan = new Scanner(new FileInputStream(\"input.txt\"));\n\n\t\tfa.out = new PrintStream(new File(\"output.txt\"));\n\n\t\tfa.n = Scan.nextInt();\n\n\t\tfa.m = Scan.nextInt();\n\n\t\tint k = Scan.nextInt();\n\n\t\tfa.arr = new boolean[2001][2001];\n\n\n\n\t\tfor (int i = 0; i < k; i++) {\n\n\t\t\tfa.coordinate = new Point();\n\n\t\t\tfa.coordinate.x = Scan.nextInt();\n\n\t\t\tfa.coordinate.y = Scan.nextInt();\n\n\t\t\tfa.q.add(fa.coordinate);\n\n\t\t\tfa.arr[fa.coordinate.x][fa.coordinate.y] = true;\n\n\t\t}\n\n\n\n\t\tfa.bfs(fa.q.peek());\n\n\n\n\t}\n\n\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n/**\n *\n * @author rohan\n */\npublic class Main {\n\n        static int mod = (int) (1e9+7);\n        static int MAX = (int)2e5+5;\n        static void solve() \n        {\n                int n = i();\n                String[] s = new String[n];\n                for(int i = 0 ; i<n ; i++)\n                {\n                    s[i] = s();\n                }\n                int[][] dp = new int[n][n];\n                dp[0][0] = 1;\n                for(int i = 1; i<n; i++)\n                {\n                    if(s[i-1].equals(\"f\"))\n                    {\n                        for (int j = i-1 ; j>=0 ; j--)\n                        {\n                            dp[i][j+1] = dp[i-1][j];\n                        }\n                    }\n                    else\n                    {\n                        int suff = 0;\n                        for(int j = i-1; j>=0 ; j--)\n                        {\n                            suff += dp[i-1][j];\n                            if(suff>=mod) suff-= mod;\n                            dp[i][j] = suff;\n                        }\n                    }\n                }\n\n                int sum = 0;\n                for (int i=0 ; i<n; i++)\n                {\n                    sum = sum+dp[n-1][i];\n                    if(sum>=mod)\n                        sum-=mod;\n                }\n                out.println(sum);\n                out.close();\n        }\n  \n\n    ///////////////////////////////////////////////////////////////////\n        static InputReader sc = new InputReader(System.in);\n        static PrintWriter out = new PrintWriter(System.out); \n        public static void main(String[] args)\n        {\n                new Thread(null,new Runnable() {\n                @Override\n                public void run() {\n                    try{\n                        solve();\n                    }\n                    catch(Exception e){\n                        e.printStackTrace();\n                    }\n                }\n                },\"1\",1<<26).start();\n        }\n\n        static class Pair implements Comparable<Pair>{\n                int x,y,i;\n                Pair (int x,int y,int i)\n                {\n                        this.x = x;\n                        this.y = y;\n                        this.i = i;\n                }\n                    \n                Pair (int x,int y)\n                {\n                        this.x = x;\n                        this.y = y;\n                }\n        \n                public int compareTo(Pair o)\n                {\n                        return -(this.y-o.y);\n                }               \n                public boolean equals(Object o)\n                {\n                        if (o instanceof Pair) {\n                            Pair p = (Pair)o;\n                            return p.x == x && p.y==y;\n                        }\n                        return false;\n                }\n\n                @Override\n                public String toString()\n                {\n                        return x + \" \"+ y + \" \"+i;\n                }\n        \n                public int hashCode()\n                {\n                        return new Long(x).hashCode() * 31 + new Long(y).hashCode();\n                }\n        } \n\n\n        static class Merge \n        {\n\n                public static void sort(int inputArr[]) \n                {\n                        int length = inputArr.length;\n                        doMergeSort(inputArr,0, length - 1);\n                }\n\n                private static void doMergeSort(int[] arr,int lowerIndex, int higherIndex) {        \n                        if (lowerIndex < higherIndex) {\n                            int middle = lowerIndex + (higherIndex - lowerIndex) / 2;\n                            doMergeSort(arr,lowerIndex, middle);\n                            doMergeSort(arr,middle + 1, higherIndex);\n                            mergeParts(arr,lowerIndex, middle, higherIndex);\n                        }\n                }\n\n                private static void mergeParts(int[]array,int lowerIndex, int middle, int higherIndex)\n                {\n                        int[] temp=new int[higherIndex-lowerIndex+1];\n                        for (int i = lowerIndex; i <= higherIndex; i++) {\n                                temp[i-lowerIndex] = array[i];\n                        }\n                        int i = lowerIndex;\n                        int j = middle + 1;\n                        int k = lowerIndex;\n                        while (i <= middle && j <= higherIndex) {\n                                if (temp[i-lowerIndex] < temp[j-lowerIndex])\n                                {\n                                        array[k] = temp[i-lowerIndex];\n                                        i++;\n                                } \n                                else\n                                {\n                                        array[k] = temp[j-lowerIndex];\n                                        j++;\n                                }\n                                k++;\n                        }\n                        while (i <= middle) {\n                                array[k] = temp[i-lowerIndex];\n                                k++;\n                                i++;\n                        }\n                        while(j<=higherIndex){\n                                array[k]=temp[j-lowerIndex];\n                                k++;\n                                j++;\n                        }\n                }\n        }\n\n        static long add(long a,long b){\n                long x=(a+b);\n                while(x>=mod) x-=mod;\n                return x;\n        }\n\n        static long sub(long a,long b){\n                long x=(a-b);\n                while(x<0) x+=mod;\n                return x;\n        }\n\n        static long mul(long a,long b){\n                a%=mod;\n                b%=mod;\n                long x=(a*b);\n                return x%mod;\n        }\n\n\n        static boolean isPal(String s){\n                for(int i=0, j=s.length()-1;i<=j;i++,j--){\n                        if(s.charAt(i)!=s.charAt(j)) return false;\n                }\n                return true;\n        }\n        static String rev(String s){\n                StringBuilder sb=new StringBuilder(s);\n                sb.reverse();\n                return sb.toString();\n        }\n\n        static long gcd(long x,long y){\n                if(y==0)\n                        return x;\n                else\n                        return gcd(y,x%y);\n        }\n\n        static int gcd(int x,int y){\n                if(y==0)\n                        return x;\n                else \n                        return gcd(y,x%y);\n        }\n\n        static long gcdExtended(long a,long b,long[] x){\n                if(a==0){\n                        x[0]=0;\n                        x[1]=1;\n                        return b;\n                }\n                long[] y=new long[2];\n                long gcd=gcdExtended(b%a, a, y);\n                x[0]=y[1]-(b/a)*y[0];\n                x[1]=y[0];\n                return gcd;\n        }\n\n\n        static long mulmod(long  a,long b,long m) {\n                if (m <= 1000000009) return a * b % m;\n\n                long res = 0;\n                while (a > 0)\n                {\n                        if ((a&1)!=0)\n                        {\n                                res += b;\n                                if (res >= m) res -= m;\n                        }\n                        a >>= 1;\n                        b <<= 1;\n                        if (b >= m) b -= m;\n                }\n                return res;\n        }\n\n        static int abs(int a,int b){\n                return (int)Math.abs(a-b);\n        }\n\n        public static long abs(long a,long b){\n                return (long)Math.abs(a-b);\n        }\n\n        static long pow(long n,long p){\n                long  result = 1;\n                if(p==0)\n                        return 1;\n\n                while(p!=0)\n                {\n                        if(p%2==1)\n                                result *= n;        \n                        p >>=1;\n                        n*=n;       \n                }\n                return result;\n        }\n\n        static void debug(Object... o) {\n                System.out.println(Arrays.deepToString(o));\n        }\n\n        static class InputReader \n        {\n\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n                this.stream = stream;\n        }\n\n        public int snext() {\n                if (snumChars == -1)\n                        throw new InputMismatchException();\n                if (curChar >= snumChars) {\n                        curChar = 0;\n                        try {\n                                snumChars = stream.read(buf);\n                        } catch (IOException e) {\n                                throw new InputMismatchException();\n                        }\n                        if (snumChars <= 0)\n                                return -1;\n                }\n                return buf[curChar++];\n        }\n\n        public int nextInt() {\n                int c = snext();\n                while (isSpaceChar(c)) {\n                        c = snext();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                        sgn = -1;\n                        c = snext();\n                }\n                int res = 0;\n                do {\n                        if (c < '0' || c > '9')\n                                throw new InputMismatchException();\n                        res *= 10;\n                        res += c - '0';\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n        }\n\n        public long nextLong() {\n                int c = snext();\n                while (isSpaceChar(c)) {\n                        c = snext();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                        sgn = -1;\n                        c = snext();\n                }\n                long res = 0;\n                do {\n                        if (c < '0' || c > '9')\n                                throw new InputMismatchException();\n                        res *= 10;\n                        res += c - '0';\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n                int a[] = new int[n];\n                for (int i = 0; i < n; i++) {\n                        a[i] = nextInt();\n                }\n                return a;\n        }\n\n        public long[] nextLongArray(int n) {\n                long a[] = new long[n];\n                for (int i = 0; i < n; i++) {\n                        a[i] = nextLong();\n                }\n                return a;\n        }\n\n        \n        public String nextLine() {\n                int c = snext();\n                while (isSpaceChar(c))\n                        c = snext();\n                StringBuilder res = new StringBuilder();\n                do {\n                        res.appendCodePoint(c);\n                        c = snext();\n                } while (!isEndOfLine(c));\n                return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n                if (filter != null)\n                        return filter.isSpaceChar(c);\n                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n                return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n                public boolean isSpaceChar(int ch);\n        }\n\n    }\n    static int i()\n    {\n        return sc.nextInt();\n    }\n    static long l(){\n        return sc.nextLong();\n    }\n    static int[] iarr(int n)\n    {\n        return sc.nextIntArray(n);\n    }\n    static long[] larr(int n)\n    {\n        return sc.nextLongArray(n);\n    }\n    static String s(){\n        return sc.nextLine();\n    }\n} ", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class c {\n\t\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t//BEGIN HERE\n\t\tint n = in.nextInt();\n\t\tint r = in.nextInt();\n\t\tint xs[] = new int[n];\n\t\tfor(int i = 0; i < n; i++) xs[i] = in.nextInt();\n\t\tdouble ys[] = new double[n];\n\t\tys[0] = r;\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tdouble worst = r;\n\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\tif(xs[i] == xs[j]) {\n\t\t\t\t\tworst = Math.max(worst, ys[j] + r + r);\n\t\t\t\t}else if((xs[i] - xs[j]) * (xs[i] - xs[j]) <= 4*r*r ) {\n\n\t\t\t\t\tdouble hypot = r + r;\n\t\t\t\t\tdouble adj = Math.abs((xs[i] - xs[j]));\n\t\t\t\t\tdouble theta = Math.acos(adj/hypot);\n\t\t\t\t\tworst = Math.max(hypot * Math.sin(theta) + ys[j], worst);\n\t\t\t\t}\n\t\t\t}\n\t\t\tys[i] = worst;\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tout.printf(\"%.10f \",ys[i]);\n\t\tout.close();\n\t}\n\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(InputStream i) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(i));\n\t\t\tst = null;\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\tif (st == null) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\tString line = st.nextToken(\"\\n\");\n\t\t\tst = null;\n\t\t\treturn line;\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static class combinatorics {\n\t\tstatic long modInv(long a, long b) {\n\t\t\treturn 1 < a ? b - modInv(b % a, a) * b / a : 1;\n\t\t}\n\n\t\tstatic long factorial[], mod;\n\n\t\tcombinatorics(int n, long MOD) {\n\t\t\tmod = MOD;\n\t\t\tfactorial = new long[n + 1];\n\t\t\tfactorial[0] = 1;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfactorial[i] = i * factorial[i - 1];\n\t\t\t\tfactorial[i] %= mod;\n\t\t\t}\n\t\t}\n\n\t\tstatic long nCr(int n, int r) {\n\t\t\tif (r > n)\n\t\t\t\treturn 0;\n\t\t\treturn (factorial[n] * modInv((factorial[n - r] * factorial[r]) % mod, mod)) % mod;\n\t\t}\n\n\t\tstatic long gcd(long a, long b) {\n\t\t\treturn b == 0 ? a : gcd(b, a % b);\n\t\t}\n\n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n\t}\n\n\tpublic static class DisjointSet {\n\t\tint p[], r[], s[];\n\t\tint numDisjoint;\n\n\t\tDisjointSet(int N) {\n\t\t\tnumDisjoint = N;\n\t\t\tr = new int[N];\n\t\t\ts = new int[N];\n\t\t\tp = new int[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tp[i] = i;\n\t\t}\n\n\t\tint findSet(int i) {\n\t\t\treturn (p[i] == i) ? i : (p[i] = findSet(p[i]));\n\t\t}\n\n\t\tboolean isSameSet(int i, int j) {\n\t\t\treturn findSet(i) == findSet(j);\n\t\t}\n\n\t\tvoid unionSet(int i, int j) {\n\t\t\tif (!isSameSet(i, j)) // if from different set\n\t\t\t{\n\t\t\t\tnumDisjoint--;\n\t\t\t\tint x = findSet(i), y = findSet(j);\n\t\t\t\tif (r[x] > r[y]) {\n\t\t\t\t\tp[y] = x; // rank keeps the tree short\n\t\t\t\t\ts[x] += s[y];\n\t\t\t\t} else {\n\t\t\t\t\tp[x] = y;\n\t\t\t\t\tif (r[x] == r[y])\n\t\t\t\t\t\tr[y]++;\n\t\t\t\t\ts[y] += s[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint sizeOfSet(int i) {\n\t\t\treturn s[findSet(i)];\n\t\t}\n\t};\n\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.util.Scanner;\n\n/**\n * Created by misanand on 9/20/14.\n */\npublic class Recovery {\n    public static void main(String [] args) {\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        if( N%2 == 0) {\n            System.out.println( (4)+\" \"+(N-4));\n        }\n        else System.out.println( (9)+\" \"+(N-9));\n        scan .close();\n    }\n}", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Hieu Le\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        private int n;\n        private InputReader in;\n        private PrintWriter out;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt();\n            this.in = in;\n            this.out = out;\n            query(new Point(1, 1), new Point(n, n), new Rectangle());\n        }\n\n        private boolean query(Point bottomLeft, Point topRight, Rectangle rectangle) {\n            if (bottomLeft.r > topRight.r || bottomLeft.c > topRight.c)\n                return false;\n\n            // Find the column of the right edge.\n            int low = bottomLeft.c, high = topRight.c;\n            while (low < high) {\n                int mid = low + (high - low) / 2;\n                int answer = ask(bottomLeft.r, bottomLeft.c, topRight.r, mid);\n                if (answer > 0)\n                    high = mid;\n                else\n                    low = mid + 1;\n            }\n            int rightCol = low;\n\n            // Find the column of the left edge.\n            low = bottomLeft.c;\n            high = topRight.c;\n            while (low < high) {\n                int mid = low + (high - low + 1) / 2;\n                int answer = ask(bottomLeft.r, mid, topRight.r, topRight.c);\n                if (answer > 0)\n                    low = mid;\n                else\n                    high = mid - 1;\n            }\n            int leftCol = low;\n\n            // Find the topmost row.\n            low = bottomLeft.r;\n            high = topRight.r;\n            while (low < high) {\n                int mid = low + (high - low) / 2;\n                int answer = ask(bottomLeft.r, bottomLeft.c, mid, topRight.c);\n                if (answer > 0)\n                    high = mid;\n                else\n                    low = mid + 1;\n            }\n            int topRow = low;\n\n            // Find the bottommost row.\n            low = bottomLeft.r;\n            high = topRight.r;\n            while (low < high) {\n                int mid = low + (high - low + 1) / 2;\n                int answer = ask(mid, bottomLeft.c, topRight.r, topRight.c);\n                if (answer > 0)\n                    low = mid;\n                else\n                    high = mid - 1;\n            }\n            int bottomRow = low;\n\n            if (leftCol > rightCol) {\n                Rectangle first = new Rectangle();\n                query(new Point(1, leftCol), new Point(n, n), first);\n                Rectangle second = new Rectangle();\n                query(new Point(1, 1), new Point(n, rightCol), second);\n                out.printf(\"! %d %d %d %d %d %d %d %d\\n\",\n                        first.bottomLeft.r, first.bottomLeft.c, first.topRight.r, first.topRight.c,\n                        second.bottomLeft.r, second.bottomLeft.c, second.topRight.r, second.topRight.c);\n                return true;\n            }\n\n            if (bottomRow > topRow) {\n                Rectangle first = new Rectangle();\n                query(new Point(bottomRow, 1), new Point(n, n), first);\n                Rectangle second = new Rectangle();\n                query(new Point(1, 1), new Point(topRow, n), second);\n                out.printf(\"! %d %d %d %d %d %d %d %d\\n\",\n                        first.bottomLeft.r, first.bottomLeft.c, first.topRight.r, first.topRight.c,\n                        second.bottomLeft.r, second.bottomLeft.c, second.topRight.r, second.topRight.c);\n                return true;\n            }\n\n            rectangle.bottomLeft.r = bottomRow;\n            rectangle.bottomLeft.c = leftCol;\n            rectangle.topRight.r = topRow;\n            rectangle.topRight.c = rightCol;\n            return true;\n        }\n\n        private int ask(int r1, int c1, int r2, int c2) {\n            out.printf(\"? %d %d %d %d\\n\", r1, c1, r2, c2);\n            out.flush();\n            return in.nextInt();\n        }\n\n        private class Point {\n            private int r;\n            private int c;\n\n            public Point(int r, int c) {\n                this.r = r;\n                this.c = c;\n            }\n\n        }\n\n        private class Rectangle {\n            private Point bottomLeft;\n            private Point topRight;\n\n            public Rectangle() {\n                bottomLeft = new Point(-1, -1);\n                topRight = new Point(-1, -1);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n        private static final int BUFFER_SIZE = 32768;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), BUFFER_SIZE);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class A {\n    static MyScanner sc;\n    static PrintWriter pw;\n\n    public static void main(String[] args) throws Throwable {\n        sc = new MyScanner();\n        pw = new PrintWriter(System.out);\n\n        n = sc.nextInt();\n        T = sc.nextLong();\n        p = new int[n];\n        l = new int[n];\n        x = new int[n];\n        t = new int[n];\n        adj = new ArrayList[n];\n\n        for (int i = 0; i < n; i++)\n            x[i] = sc.nextInt();\n        for (int i = 0; i < n; i++)\n            t[i] = sc.nextInt();\n        adj[0] = new ArrayList<>();\n        for (int i = 1; i < n; i++) {\n            adj[i] = new ArrayList<>();\n            p[i] = sc.nextInt() - 1;\n            l[i] = sc.nextInt();\n            adj[p[i]].add(i);\n        }\n\n        ftCnt = new long[N];\n        ftSum = new long[N];\n        ans = new long[n];\n\n        dfs(0);\n        pw.println(ans[0]);\n\n        pw.flush();\n        pw.close();\n    }\n\n    static int n;\n    static long T;\n    static int[] p, l, x, t;\n    static ArrayList<Integer>[] adj;\n\n    static long[] ans;\n\n    static void dfs(int u) {\n        update(t[u], x[u], 1L * x[u] * t[u]);\n        ans[u] = getMaxCnt();\n        long[] vals = {-1, -1, -1};\n        for (int v : adj[u]) {\n            T -= 2 * l[v];\n            dfs(v);\n            vals[0] = ans[v];\n            Arrays.sort(vals);\n            T += 2 * l[v];\n        }\n        if (u != 0) {\n            if (vals[1] != -1)\n                ans[u] = Math.max(ans[u], vals[1]);\n        } else {\n            if (vals[2] != -1)\n                ans[u] = Math.max(ans[u], vals[2]);\n        }\n        update(t[u], -x[u], -1L * x[u] * t[u]);\n    }\n\n    static int N = (int) 1e6 + 2;\n    static long[] ftCnt, ftSum;\n\n    static void update(int idx, long cnt, long val) {\n        while (idx < N) {\n            ftCnt[idx] += cnt;\n            ftSum[idx] += val;\n            idx += (idx & -idx);\n        }\n    }\n\n    static long getSum(int idx) {\n        long ret = 0;\n        while (idx > 0) {\n            ret += ftSum[idx];\n            idx -= (idx & -idx);\n        }\n        return ret;\n    }\n\n    static long getCnt(int idx) {\n        long ret = 0;\n        while (idx > 0) {\n            ret += ftCnt[idx];\n            idx -= (idx & -idx);\n        }\n        return ret;\n    }\n\n    static long getMaxCnt() {\n        int start = 1, end = N - 1, ans = N - 1;\n        while (start <= end) {\n            int mid = (start + end) / 2;\n            if (getSum(mid) >= T) {\n                ans = mid;\n                end = mid - 1;\n            } else\n                start = mid + 1;\n        }\n        long remT = T - (ans > 1 ? getSum(ans - 1) : 0);\n        long cnt = (ans > 1 ? getCnt(ans - 1) : 0);\n        long cntOfVal = getCnt(ans) - cnt;\n        cnt += Math.min(cntOfVal, remT / ans);\n        return cnt;\n    }\n\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "nlogn", "problem": "1099_F", "from": "CODEFORCES", "tags": "binary search,data structures,dfs and similar,dp,games,trees"}
{"src": "import static java.lang.Math.*;\nimport static java.lang.System.currentTimeMillis;\nimport static java.lang.System.exit;\nimport static java.lang.System.arraycopy;\nimport static java.util.Arrays.sort;\nimport static java.util.Arrays.binarySearch;\nimport static java.util.Arrays.fill;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry {\n\t\t\tif (new File(\"input.txt\").exists())\n\t\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n\t\t} catch (SecurityException e) {\n\t\t}\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tnew Main().run();\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\texit(999);\n\t\t\t\t}\n\t\t\t}\n\t\t}, \"1\", 1 << 23).start();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st = new StringTokenizer(\"\");\n\n\tint n, m;\n\tint dp[][][];\n\tint MV = Integer.MAX_VALUE >> 1;\n\tint ans = MV;\n\t\n\tprivate void run() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\n\t\tn = nextInt();\n\t\tm = nextInt();\n\t\tif(n < m){ int d = n; n = m; m = d; }\n\t\tint M = 1 << m;\n\t\tdp = new int[n][M][M];\n\t\tfor(int a[][] : dp)\n\t\t\tfor(int b[] : a)\n\t\t\t\tfill(b, MV);\n\t\t\n//\t\tfor(int i = 0 ; i < M; i++){\n//\t\t\tint next = (( i | (i << 1) | (i >> 1) ) & (M - 1));\n//\t\t\tif(  next!= (M -1))\n//\t\t\t\tcontinue;\n//\t\t\tif(n > 1)\n//\t\t\t\tdp[0][next][0] = Integer.bitCount(i);\n//\t\t\telse\n//\t\t\t\tans = min(ans, Integer.bitCount(i));\n//\t\t}\n\t\tdp[0][0][0] = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor(int m1 = 0; m1 < M; m1++)\n\t\t\t\tfor(int m2 = 0; m2 < M; m2++){\n\t\t\t\t\tif(dp[i][m1][m2] == MV)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(int nm1 = 0; nm1 < M; nm1++)\n\t\t\t\t\t\tfor(int nm2 = 0; nm2 < M; nm2++){\n\t\t\t\t\t\t\tint res1 = m1 | (nm1) | (nm1 << 1) | (nm1 >> 1) | (nm2);\n\t\t\t\t\t\t\tres1 &= (M - 1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(res1 != (M - 1))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tint res2 = m2 | (nm1) | (nm2 << 1) | (nm2 >> 1) | (nm2);\n\t\t\t\t\t\t\tres2 &= (M - 1);\n\t\t\t\t\t\t\t\n//\t\t\t\t\t\t\tif(i == 2 && m1 == 3 && m2 == 2 && nm1 == 0 && nm2 == 0){\n//\t\t\t\t\t\t\t\tSystem.err.println(\"kek\");\n//\t\t\t\t\t\t\t\tSystem.err.println(dp[i][m1][m2]);\n//\t\t\t\t\t\t\t\tSystem.err.println(res1 + \" | \" + res2);\n//\t\t\t\t\t\t\t\tSystem.err.println(M);\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tint next1 = res2 & (M - 1);\n\t\t\t\t\t\t\tint next2 = nm2 & ( M - 1);\n\t\t\t\t\t\t\tint over = Integer.bitCount(nm1) + Integer.bitCount(nm2);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(i < n - 1)\n\t\t\t\t\t\t\t\tdp[i+1][next1][next2] = min(dp[i + 1][next1][next2], dp[i][m1][m2] + over);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tif((res1 & (M - 1)) == (M - 1)){\n\t\t\t\t\t\t\t\t\tans = min(dp[i][m1][m2] + over, ans);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n//\t\tSystem.err.println(ans);\n\t\tout.println(n * m - ans);\n\t\t\n\t\tin.close();\n\t\tout.close();\n\t}\n\tString nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\tString nextLine() throws IOException {\n\t\tst = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\tboolean EOF() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString s = in.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn true;\n\t\t\tst = new StringTokenizer(s);\n\t\t}\n\t\treturn false;\n\t}\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution{\n    \n    public static void main(String[] args) throws Exception{\n        int[] nm = in.readA();\n        int n = nm[0], m = nm[1];\n        // System.out.println(n+\",\"+m);\n        char[][] matstr = new char[n][m];\n        for(int i = 0; i < n; i++){\n            matstr[i] = in.readLine().toCharArray();\n        }\n        int[][] mat = new int[n][m];\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < m; j++)\n                mat[i][j] = matstr[i][j] == '#'?1:0;\n        boolean valid = true;\n\n        int[][] dir = {\n            {-1,-1}, {-1,0}, {-1,1},\n            {0,-1}, {0,1},\n            {1,-1}, {1,0}, {1,1}\n        };\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m; j++){\n                \n                if(mat[i][j] == 1){\n                    boolean check = false;\n                    for(int[] d: dir){\n                        int x = d[0]+i,y=d[1]+j;\n                        if(x >= mat.length || y >= mat[0].length || x < 0 || y < 0)\n                            continue;\n                        check = check || dfs(x,y,mat);\n                    }\n                    if(!check)\n                        valid = false;\n                }\n            }\n        }\n        if(valid)\n            System.out.println(\"YES\");\n        else \n            System.out.println(\"NO\");\n    }\n\n    public static boolean dfs(int i,int j,int[][] mat){\n        // if(x >= mat.length || y >= mat[0].length || x < 0 || y < 0 || mat[x][y] != 0)  return;\n        int[][] dir = {\n            {-1,-1}, {-1,0}, {-1,1},\n            {0,-1}, {0,1},\n            {1,-1}, {1,0}, {1,1}\n        };\n        boolean possible = true;\n        for(int[] d: dir){\n            int x = d[0]+i,y=d[1]+j;\n            if(x >= mat.length || y >= mat[0].length || x < 0 || y < 0){\n                possible = false;\n                break;\n            }\n            if(mat[x][y] == 0)\n                possible = false;\n        }\n        return possible;\n    }\n\n    static Inputer in;\n    static {\n        in = new Inputer();\n    }\n\n    static class Inputer{\n        BufferedReader br;\n        Inputer(){\n            try{\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n            catch(Exception e){}\n        }\n        public int readInt() throws Exception{\n            return Integer.parseInt(readLine());\n        }\n        public long readLong() throws Exception{\n            return Long.parseLong(readLine());\n        }\n        public int[] readA(String delim) throws Exception{\n            String[] s = readLine().split(delim);\n            int[] A = new int[s.length];\n            for(int i = 0; i < s.length; i++)\n                A[i] = Integer.parseInt(s[i]);\n            return A;\n        }\n        public int[] readA() throws Exception{\n            String[] s = readLine().split(\"\\\\s+\");\n            int[] A = new int[s.length];\n            for(int i = 0; i < s.length; i++)\n                A[i] = Integer.parseInt(s[i]);\n            return A;\n        }\n        public long[] readLA() throws Exception{\n            String[] s = readLine().split(\"\\\\s+\");\n            long[] A = new long[s.length];\n            for(int i = 0; i < s.length; i++)\n                A[i] = Long.parseLong(s[i]);\n            return A;\n        }\n        public String readLine() throws Exception{\n            return br.readLine();\n        }\n        public int[] copyA(int[] A){\n            int[] B = new int[A.length];\n            for(int i= 0 ; i < A.length; i++)\n                B[i] = A[i];\n            return B;\n        }\n    }\n    static void shuffle(int[] A){\n        int n = A.length;\n        Random rand = new Random();\n        for(int t = 0; t < A.length; t++){\n            int i1 = rand.nextInt(n);\n            int i2 = rand.nextInt(n);\n            int tmp = A[i1];\n            A[i1] = A[i2];\n            A[i2] = tmp;\n        }\n    }\n}", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n\n    static int myLevel;\n    static int[] level;\n    static int[] loyalty;\n\n    static double get(int n) {\n        double ret = 0;\n        for (int mask = 0; mask < 1 << n; mask++) {\n            int k = Integer.bitCount(mask);\n            double prob = 1.;\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                if (((mask >> i) & 1) == 1) {\n                    prob *= loyalty[i] * .1;\n                } else {\n                    prob *= (10 - loyalty[i]) * .1;\n                    sum += level[i];\n                }\n            }\n            if (k * 2 > n) {\n                ret += prob;\n            } else {\n                ret += prob * myLevel / (myLevel + sum);\n            }\n        }\n        return ret;\n    }\n\n    static double go(int x, int k, int n) {\n        if (x == n) {\n            return get(n);\n        }\n        double ret = 0;\n        for (int i = 0; i <= k && loyalty[x] + i <= 10; i++) {\n            loyalty[x] += i;\n            ret = Math.max(go(x + 1, k - i, n), ret);\n            loyalty[x] -= i;\n        }\n        return ret;\n    }\n\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        myLevel = in.nextInt();\n        level = new int[n];\n        loyalty = new int[n];\n        for (int i = 0; i < n; i++) {\n            level[i] = in.nextInt();\n            loyalty[i] = in.nextInt() / 10;\n        }\n        out.println(go(0, k, n));\n    }\n}\n\nclass FastScanner extends BufferedReader {\n\n    boolean isEOF;\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n            if (isEOF && ret < 0) {\n                throw new InputMismatchException();\n            }\n            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= -1 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (!isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.io.*;\n\nimport java.math.BigDecimal;\n\nimport java.math.BigInteger;\n\nimport java.math.RoundingMode;\n\nimport java.text.DecimalFormat;\n\nimport java.util.*;\n\n\n\nimport static java.lang.Math.*;\n\n\n\npublic class Main {\n\n\n\n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    BufferedReader in;\n\n    PrintWriter out;\n\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n\n\n    void init() throws FileNotFoundException {\n\n        if (ONLINE_JUDGE) {\n\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n\n            out = new PrintWriter(\"output.txt\");\n\n        } else {\n\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n\n            out = new PrintWriter(\"output.txt\");\n\n        }\n\n    }\n\n\n\n    String readString() throws IOException {\n\n        while (!tok.hasMoreTokens()) {\n\n            tok = new StringTokenizer(in.readLine());\n\n        }\n\n        return tok.nextToken();\n\n    }\n\n\n\n    int readInt() throws IOException {\n\n        return Integer.parseInt(readString());\n\n    }\n\n\n\n    long readLong() throws IOException {\n\n        return Long.parseLong(readString());\n\n    }\n\n\n\n    double readDouble() throws IOException {\n\n        return Double.parseDouble(readString());\n\n    }\n\n\n\n    public static void main(String[] args) {\n\n        new Main().run();\n\n        // Sworn to fight and die\n\n    }\n\n\n\n    public static void mergeSort(int[] a) {\n\n        mergeSort(a, 0, a.length - 1);\n\n    }\n\n\n\n    private static void mergeSort(int[] a, int levtIndex, int rightIndex) {\n\n        final int MAGIC_VALUE = 50;\n\n        if (levtIndex < rightIndex) {\n\n            if (rightIndex - levtIndex <= MAGIC_VALUE) {\n\n                insertionSort(a, levtIndex, rightIndex);\n\n            } else {\n\n                int middleIndex = (levtIndex + rightIndex) / 2;\n\n                mergeSort(a, levtIndex, middleIndex);\n\n                mergeSort(a, middleIndex + 1, rightIndex);\n\n                merge(a, levtIndex, middleIndex, rightIndex);\n\n            }\n\n        }\n\n    }\n\n\n\n    private static void merge(int[] a, int levtIndex, int middleIndex,\n\n                              int rightIndex) {\n\n        int length1 = middleIndex - levtIndex + 1;\n\n        int length2 = rightIndex - middleIndex;\n\n        int[] levtArray = new int[length1];\n\n        int[] rightArray = new int[length2];\n\n        System.arraycopy(a, levtIndex, levtArray, 0, length1);\n\n        System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n\n        for (int k = levtIndex, i = 0, j = 0; k <= rightIndex; k++) {\n\n            if (i == length1) {\n\n                a[k] = rightArray[j++];\n\n            } else if (j == length2) {\n\n                a[k] = levtArray[i++];\n\n            } else {\n\n                a[k] = levtArray[i] <= rightArray[j] ? levtArray[i++]\n\n                        : rightArray[j++];\n\n            }\n\n        }\n\n    }\n\n\n\n    private static void insertionSort(int[] a, int levtIndex, int rightIndex) {\n\n        for (int i = levtIndex + 1; i <= rightIndex; i++) {\n\n            int current = a[i];\n\n            int j = i - 1;\n\n            while (j >= levtIndex && a[j] > current) {\n\n                a[j + 1] = a[j];\n\n                j--;\n\n            }\n\n            a[j + 1] = current;\n\n        }\n\n    }\n\n\n\n    public void run() {\n\n        try {\n\n            long t1 = System.currentTimeMillis();\n\n            init();\n\n            solve();\n\n            out.close();\n\n            long t2 = System.currentTimeMillis();\n\n            System.err.println(\"Time = \" + (t2 - t1));\n\n        } catch (Exception e) {\n\n            e.printStackTrace(System.err);\n\n            System.exit(-1);\n\n        }\n\n    }\n\n\n\n\n\n\n\n    class LOL implements Comparable<LOL> {\n\n\n\n        int x;\n\n        int y;\n\n\n\n\n\n\n\n        public LOL(int x, int y) {\n\n            this.x = x;\n\n            this.y = y;\n\n\n\n        }\n\n\n\n        @Override\n\n        public int compareTo(LOL o) {\n\n\n\n            return (x - o.x); // ---->\n\n            //return o.x * o.y - x * y; // <----\n\n        }\n\n\n\n    }\n\n\n\n    class LOL2 implements Comparable<LOL2> {\n\n\n\n        int x;\n\n        int y;\n\n        int z;\n\n\n\n\n\n\n\n        public LOL2(int x, int y, int z) {\n\n            this.x = x;\n\n            this.y = y;\n\n            this.z = z;\n\n        }\n\n\n\n        @Override\n\n        public int compareTo(LOL2 o) {\n\n\n\n            return (z - o.z); // ---->\n\n            //return o.x * o.y - x * y; // <----\n\n        }\n\n\n\n    }\n\n\n\n    class test implements Comparable<test> {\n\n\n\n        long x;\n\n        long y;\n\n\n\n\n\n\n\n        public test(long x, long y) {\n\n            this.x = x;\n\n            this.y = y;\n\n\n\n        }\n\n\n\n        @Override\n\n        public int compareTo(test o) {\n\n            //int compareResult = Long.compare(y, o.y); // ---->\n\n\n\n            //if (compareResult != 0) {\n\n            //    return -compareResult;\n\n            //}\n\n\n\n            int compareResult = Long.compare(x, o.x);\n\n\n\n            if (compareResult != 0) {\n\n                return compareResult;\n\n            }\n\n\n\n            return Long.compare(y, o.y);\n\n\n\n            //return o.x * o.y - x * y; // <----\n\n        }\n\n\n\n    }\n\n\n\n    class data {\n\n        String name;\n\n        String city;\n\n\n\n        data(String name, String city) {\n\n            this.city = city;\n\n            this.name = name;\n\n        }\n\n    }\n\n\n\n    class Point {\n\n        double x;\n\n        double y;\n\n\n\n\n\n        Point(double x, double y) {\n\n            this.x = x;\n\n            this.y = y;\n\n\n\n        }\n\n\n\n        double distance(Point temp) {\n\n            return Math.sqrt((x - temp.x) * (x - temp.x) + (y - temp.y) * (y - temp.y));\n\n        }\n\n\n\n        double sqrDist(Point temp) {\n\n            return ((x - temp.x) * (x - temp.x) + (y - temp.y) * (y - temp.y));\n\n        }\n\n\n\n        Point rotate(double alpha) {\n\n            return new Point(x * cos(alpha) - y * sin(alpha), x * sin(alpha) + y * cos(alpha));\n\n        }\n\n\n\n        void sum(Point o) {\n\n            x += o.x;\n\n            y += o.y;\n\n        }\n\n\n\n        void scalarProduct(int alpha) {\n\n            x *= alpha;\n\n            y *= alpha;\n\n        }\n\n\n\n    }\n\n\n\n    class Line {\n\n        double a;\n\n        double b;\n\n        double c;\n\n\n\n        Line(Point A, Point B) {\n\n            a = B.y - A.y;\n\n            b = A.x - B.x;\n\n            c = -A.x * a - A.y * b;\n\n        }\n\n        Line(double a, double b, double c) {\n\n            this.a = a;\n\n            this.b = b;\n\n            this.c = c;\n\n        }\n\n\n\n      Point intersection(Line o) {\n\n            double det = a * o.b - b * o.a;\n\n            double det1 = -c * o.b + b * o.c;\n\n            double det2 = -a * o.c + c * o.a;\n\n            return new Point(det1 / det, det2 / det);\n\n        }\n\n    }\n\n\n\n /*   class Plane {\n\n        double a;\n\n        double b;\n\n        double c;\n\n        double d;\n\n\n\n        Plane (Point fir, Point sec, Point thi) {\n\n            double del1 = (sec.y - fir.y) * (thi.z - fir.z) - (thi.y - fir.y) * (sec.z - fir.z);\n\n            double del2 = (thi.x - fir.x) * (sec.z - fir.z) - (thi.z - fir.z) * (sec.x - fir.x);\n\n            double del3 = (thi.y - fir.y) * (sec.x - fir.x) - (thi.x - fir.x) * (sec.y - fir.y);\n\n            a = del1;\n\n            b = del2;\n\n            c = del3;\n\n            d = -fir.x * del1 - fir.y * del2 - fir.z * del3;\n\n        }\n\n\n\n        double distance(Point point) {\n\n            return abs(a * point.x + b * point.y + c * point.z + d) / sqrt(a * a + b * b + c * c);\n\n        }\n\n\n\n\n\n    } */\n\n\n\n    class record implements Comparable<record> {\n\n        String city;\n\n        Long score;\n\n\n\n        public record(String name, Long score) {\n\n            this.city = name;\n\n            this.score = score;\n\n        }\n\n\n\n        @Override\n\n        public int compareTo(record o) {\n\n            if (o.city.equals(city)) {\n\n                return 0;\n\n            }\n\n\n\n            if (score.equals(o.score)) {\n\n                return 1;\n\n            }\n\n\n\n            if (score > o.score) {\n\n                return 666;\n\n            } else {\n\n                return -666;\n\n            }\n\n\n\n            //return Long.compare(score, o.score);\n\n\n\n        }\n\n\n\n    }\n\n\n\n    public long gcd(long a, long b) {\n\n        if (a == 0 || b == 0) return max(a, b);\n\n\n\n        if (a % b == 0)\n\n            return b;\n\n        else\n\n            return gcd(b, a % b);\n\n    }\n\n\n\n    boolean prime(long n) {\n\n        if (n == 1) return false;\n\n        for (int i = 2; i <= sqrt(n); i++)\n\n            if (n % i == 0)\n\n                return false;\n\n        return true;\n\n    }\n\n\n\n    public int sum(long n) {\n\n        int s = 0;\n\n\n\n        while (n > 0) {\n\n            s += (n % 10);\n\n            n /= 10;\n\n        }\n\n\n\n        return s;\n\n\n\n    }\n\n\n\n /*   public void simulation(int k) {\n\n        long ans = 0;\n\n        int start = 1;\n\n        for (int i = 0; i < k; i++) {\n\n            start *= 10;\n\n        }\n\n        for (int i = start/10; i < start; i++) {\n\n            int locAns = 0;\n\n            for (int j = start/10; j < start; j++) {\n\n                if  (sum(i + j) == sum(i) + sum(j) ) {\n\n                    ans += 1;\n\n                    locAns += 1;\n\n                } else {\n\n                    //.println(i + \"!!!\" + j);\n\n                }\n\n            }\n\n            //out.println(i + \" \" + locAns);\n\n        }\n\n        out.println(ans);\n\n    }*/\n\n\n\n\n\n\n\n\n\n    ArrayList<Integer> primes;\n\n    boolean[] isPrime;\n\n\n\n    public void getPrimes (int n) {\n\n        isPrime[0] = false;\n\n        isPrime[1] = false;\n\n        for (int i = 2; i <= n; i++) {\n\n            if (isPrime[i]) {\n\n                primes.add(i);\n\n                if (1l * i * i <= n) {\n\n                    for (int j = i * i; j <= n; j += i) {\n\n                        isPrime[j] = false;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n\n\n\n\n\n\n    public long binPowMod(long a, long b, long mod) {\n\n        if (b == 0) {\n\n            return 1 % mod;\n\n        }\n\n\n\n        if (b % 2 != 0) {\n\n            return ((a % mod) * (binPowMod(a, b - 1, mod) % mod)) % mod;\n\n        } else {\n\n            long temp = binPowMod(a, b / 2, mod) % mod;\n\n            long ans = (temp * temp) % mod;\n\n            return ans;\n\n\n\n        }\n\n    }\n\n\n\n\n\n    int type[];\n\n    boolean vis[];\n\n\n\n    HashMap<Integer, HashSet<Integer>> g;\n\n\n\n    int componentNum[];\n\n\n\n  /*  void dfs(int u, int numOfComponent) {\n\n        vis[u] = true;\n\n        componentNum[u] = numOfComponent;\n\n\n\n        for (Integer v: g.get(u)) {\n\n            if (!vis[v]) {\n\n                dfs(v, numOfComponent);\n\n            }\n\n        }\n\n    } */\n\n\n\n    int p[];\n\n\n\n    int find(int x) {\n\n        if (x == p[x]) {\n\n            return x;\n\n        }\n\n\n\n        return p[x] = find(p[x]);\n\n    }\n\n\n\n    boolean merge(int x, int y) {\n\n        x = find(x);\n\n        y = find(y);\n\n        if (p[x] == p[y]) {\n\n            return false;\n\n        }\n\n        p[y] = x;\n\n        return true;\n\n    }\n\n\n\n    class Trajectory {\n\n        double x0;\n\n        double y0;\n\n        double vx;\n\n        double vy;\n\n\n\n\n\n        Trajectory(double vx, double vy, double x0, double y0) {\n\n            this.vx = vx;\n\n            this.vy = vy;\n\n\n\n            this.x0 = x0;\n\n            this.y0 = y0;\n\n        }\n\n\n\n        double y (double x) {\n\n            return y0 + (x - x0) * (vy / vx) - 5 * (x - x0) * (x - x0) / (vx * vx);\n\n        }\n\n\n\n        double der(double x) {\n\n            return (vy / vx) - 10 * (x - x0) / (vx * vx);\n\n        }\n\n\n\n\n\n    }\n\n\n\n    int s;\n\n    int n;\n\n    int m;\n\n    boolean isVisited[][];\n\n    char[][] maze;\n\n    int[] dx = {0, 0, -1, 1};\n\n    int[] dy = {1, -1, 0, 0};\n\n\n\n    void dfs(int x, int y) {\n\n        isVisited[x][y] = true;\n\n\n\n        for (int i = 0; i < 4; i++) {\n\n            int currX = x + dx[i];\n\n            int currY = y + dy[i];\n\n\n\n            if (maze[currX][currY] == '.' && !isVisited[currX][currY]) {\n\n                dfs(currX, currY);\n\n            }\n\n\n\n        }\n\n\n\n\n\n\n\n    }\n\n\n\n\n\n\n\n\n\n    public void solve() throws IOException {\n\n\n\n        n = readInt();\n\n        m = readInt();\n\n\n\n        maze = new char[n + 2][m + 2];\n\n\n\n        for (int i = 0; i < n + 2; i++) {\n\n            maze[i][0] = '#';\n\n            maze[i][m + 1] = '#';\n\n        }\n\n\n\n        for (int j = 0; j < m + 2; j++) {\n\n            maze[0][j] = '#';\n\n            maze[n + 1][j] = '#';\n\n        }\n\n\n\n        for (int i = 1; i <= n; i++) {\n\n            for (int j = 1; j <= m; j++) {\n\n                maze[i][j] = '.';\n\n            }\n\n        }\n\n\n\n        int[][] dist = new int[n + 2][m + 2];\n\n\n\n        for (int i = 0; i < n + 2; i++) {\n\n            for (int j = 0; j < m + 2; j++) {\n\n                dist[i][j] = Integer.MAX_VALUE;\n\n            }\n\n        }\n\n\n\n        ArrayDeque<Integer> xValues = new ArrayDeque<Integer>();\n\n        ArrayDeque<Integer> yValues = new ArrayDeque<Integer>();\n\n\n\n        int k = readInt();\n\n        for (int i = 0; i < k; i++) {\n\n            int currX = readInt();\n\n            int currY = readInt();\n\n            xValues.add(currX);\n\n            yValues.add(currY);\n\n            dist[currX][currY] = 0;\n\n        }\n\n\n\n\n\n\n\n        while(!xValues.isEmpty()) {\n\n            int x = xValues.poll();\n\n            int y = yValues.poll();\n\n\n\n            for (int i = 0; i < 4; i++) {\n\n                int currX = x + dx[i];\n\n                int currY = y + dy[i];\n\n\n\n                if (maze[currX][currY] == '.' && dist[currX][currY] > dist[x][y] + 1) {\n\n                    dist[currX][currY] = dist[x][y] + 1;\n\n                    xValues.add(currX);\n\n                    yValues.add(currY);\n\n                }\n\n\n\n            }\n\n\n\n        }\n\n\n\n        int maxDist = 0;\n\n        int indexX = 0;\n\n        int indexY = 0;\n\n\n\n        for (int i = 1; i <= n; i++) {\n\n            for (int j = 1; j <= m; j++) {\n\n                if (dist[i][j] >= maxDist) {\n\n                    maxDist = dist[i][j];\n\n                    indexX = i;\n\n                    indexY = j;\n\n                }\n\n            }\n\n        }\n\n\n\n        out.print(indexX + \" \" + indexY);\n\n\n\n\n\n\n\n\n\n\n\n    }\n\n\n\n\n\n\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "//package codeforces.contests.cf159;\n\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class ProblemA {\n    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out));\n\n    int[] readInts() throws IOException {\n        String[] strings = reader.readLine().split(\" \");\n        int[] ints = new int[strings.length];\n        for(int i = 0; i < ints.length; i++) {\n            ints[i] = Integer.parseInt(strings[i]);\n        }\n        return ints;\n    }\n\n    void solve() throws IOException {\n        int[] tt = readInts();\n        int n = tt[0];\n        int m = tt[1];\n        int k = tt[2];\n        int[] a = readInts();\n        Arrays.sort(a);\n        for(int i = 0, j = a.length - 1; i < j; i++, j--) {\n            int t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n        }\n        int ix = 0;\n        while(k < m && ix < n) {\n            k += a[ix++] - 1;\n        }\n        if(k < m) {\n            writer.println(-1);\n        }\n        else {\n            writer.println(ix);\n        }\n        writer.flush();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new ProblemA().solve();\n    }\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\t/**\n\t * @author hunglee\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tStreamTokenizer in = new StreamTokenizer(new BufferedReader(\n\t\t\t\tnew InputStreamReader(System.in)));\n\t\t\n\t\tin.nextToken();\n\t\tString s = in.sval;\n\t\tint l = s.length();\n\t\tint n = l - 1;\n\t\tString st, sub;\n\t\twhile (n > 0) {\n\t\t\tfor (int i = 0; i < l - n; ++i) {\n\t\t\t\tst = s.substring(i, n + i);\n\t\t\t\tsub = s.substring(i + 1);\n\t\t\t\tif (sub.indexOf(st) != -1) {\n\t\t\t\t\tSystem.out.println(n);\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t\tSystem.out.println(0);\n\t}\n\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic int n, memo[], dS[], dd[][];\n\n\tstatic int dp(int idx, int msk)\n\t{\n\t\tif(msk == (1 << n) - 1)\n\t\t\treturn 0;\n\t\tif(memo[msk] != -1)\n\t\t\treturn memo[msk];\n\t\twhile((msk & 1 << idx) != 0)\n\t\t\t++idx;\n\t\tint ret = dS[idx] * 2 + dp(idx + 1, msk | 1 << idx);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif((msk & 1 << i) == 0)\n\t\t\t\tret = Math.min(ret, dS[i] + dS[idx] + dd[i][idx] + dp(idx + 1, msk | 1 << i | 1 << idx));\n\t\treturn memo[msk] = ret;\n\t}\n\t\n\tstatic StringBuilder sb = new StringBuilder(\"0 \");\n\t\n\tstatic void print(int idx, int msk)\n\t{\n\t\tif(msk == (1 << n) - 1)\n\t\t\treturn;\n\t\tint opt = dp(idx, msk);\n\t\twhile((msk & 1 << idx) != 0)\n\t\t\t++idx;\n\t\tif(dS[idx] * 2 + dp(idx + 1, msk | 1 << idx) == opt)\n\t\t{\n\t\t\tsb.append((idx + 1) + \" 0 \");\n\t\t\tprint(idx + 1, msk | 1 << idx);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif((msk & 1 << i) == 0)\n\t\t\t\tif(opt == dS[i] + dS[idx] + dd[i][idx] + dp(idx + 1, msk | 1 << i | 1 << idx))\n\t\t\t\t{\n\t\t\t\t\tsb.append((idx + 1) + \" \" + (i + 1) + \" 0 \");\n\t\t\t\t\tprint(idx + 1, msk | 1 << i | 1 << idx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tPoint s = new Point(sc.nextInt(), sc.nextInt());\n\t\tn = sc.nextInt();\n\t\tPoint[] a = new Point[n];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\ta[i] = new Point(sc.nextInt(), sc.nextInt());\n\t\tdS = new int[n];\n\t\tdd = new int[n][n];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tdS[i] = dist2(s, a[i]);\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tdd[i][j] = dist2(a[i], a[j]);\n\t\t}\n\n\t\tmemo = new int[1 << n];\n\t\tArrays.fill(memo, -1);\n\t\tout.println(dp(0, 0));\n\t\tprint(0, 0);\n\t\tout.println(sb);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic int dist2(Point a, Point b) { return sq(a.x - b.x) + sq(a.y - b.y); }\n\n\tstatic int sq(int x) { return x * x; }\n\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(next()); }\n\n\t\tpublic boolean ready() throws IOException {return br.ready();} \n\t}\n} ", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        TaskC.InputReader in = new TaskC.InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.Solve(in, out);\n        out.close();\n    }\n\n\n    static class TaskC {\n\n        void Solve(InputReader in, PrintWriter out) {\n            int n = in.NextInt();\n            double r = in.NextInt();\n            double[] x = new double[n];\n            for (int i = 0; i < n; i++) x[i] = in.NextInt();\n            double[] y = new double[n];\n            for (int i = 0; i < n; i++) {\n                double maxY = r;\n                for (int j = 0; j < i; j++) {\n                    if (Math.abs(x[i] - x[j]) <= 2 * r) {\n                        double currentY = Math.sqrt((2 * r) * (2 * r) - (x[i] - x[j]) * (x[i] - x[j])) + y[j];\n                        maxY = Math.max(maxY, currentY);\n                    }\n                }\n                y[i] = maxY;\n            }\n            out.print(y[0]);\n            for (int i = 1; i < n; i++) {\n                out.print(\" \" + y[i]);\n            }\n            out.println();\n        }\n\n        static int GetMax(int[] ar) {\n            int max = Integer.MIN_VALUE;\n            for (int a : ar) {\n                max = Math.max(max, a);\n            }\n            return max;\n        }\n\n        static int GetMin(int[] ar) {\n            int min = Integer.MAX_VALUE;\n            for (int a : ar) {\n                min = Math.min(min, a);\n            }\n            return min;\n        }\n\n        static long GetSum(int[] ar) {\n            long s = 0;\n            for (int a : ar) s += a;\n            return s;\n        }\n\n        static int[] GetCount(int[] ar) {\n            return GetCount(ar, GetMax(ar));\n        }\n\n        static int[] GetCount(int[] ar, int maxValue) {\n            int[] dp = new int[maxValue + 1];\n            for (int a : ar) {\n                dp[a]++;\n            }\n            return dp;\n        }\n\n        static class InputReader {\n            BufferedReader reader;\n            StringTokenizer tokenizer;\n\n            InputReader(InputStream stream) {\n                reader = new BufferedReader(new InputStreamReader(stream), 32768);\n                tokenizer = null;\n            }\n\n            String Next() {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    try {\n                        tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n                return tokenizer.nextToken();\n            }\n\n            int NextInt() {\n                return Integer.parseInt(Next());\n            }\n\n            long NextLong() {\n                return Long.parseLong(Next());\n            }\n\n            double NextDouble() {\n                return Double.parseDouble(Next());\n            }\n\n            int[] NextIntArray(int n) {\n                return NextIntArray(n, 0);\n            }\n\n            int[] NextIntArray(int n, int offset) {\n                int[] a = new int[n];\n                for (int i = 0; i < n; i++) {\n                    a[i] = NextInt() - offset;\n                }\n                return a;\n            }\n\n            int[][] NextIntMatrix(int n, int m) {\n                return NextIntMatrix(n, m, 0);\n            }\n\n            int[][] NextIntMatrix(int n, int m, int offset) {\n                int[][] a = new int[n][m];\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < m; j++) {\n                        a[i][j] = NextInt() - offset;\n                    }\n                }\n                return a;\n            }\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.util.*;\npublic class a {\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tlong a=in.nextInt(),b=in.nextInt(),x=in.nextInt(),y=in.nextInt(),z=in.nextInt();\n\t\tlong needa=x*2+y,needb=z*3+y;\n\t\tSystem.out.println(Math.max(needa-a,0)+Math.max(needb-b,0));\n\t}\n}\n", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.Scanner;\n\npublic class Main {\n  public long LCM(long n) {\n    if(n== 1){\n        return 1;\n    }\n    else if(n==2){\n        return 2;\n    }\n    else if(n%2==0){\n        if(n%3==0){\n            return (n-1)*(n-2)*(n-3);\n        }\n        else{\n            return n*(n-1)*(n-3);\n        }\n    }\n    else{\n        return n*(n-1)*(n-2);\n    }\n   \n  }\n\n  public static void main(String[] args) {\n    Main m = new Main();\n    Scanner s = new Scanner(System.in);\n    long input = s.nextInt();\n    long output = m.LCM(input);\n    System.out.println(output);\n  }\n}", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": " \n\nimport java.util.ArrayList;\n\nimport java.util.Scanner;\n\nimport java.io.BufferedReader;\n\nimport java.io.File;\n\nimport java.io.FileNotFoundException;\n\nimport java.io.FileReader;\n\nimport java.io.FileWriter;\n\nimport java.io.IOException;\n\nimport java.io.PrintWriter;\n\nimport java.nio.*;\n\n public class Main {\n\n\n\n\n\n    public static void main(String[] args) throws NumberFormatException, IOException \n\n    {\n\n        Scanner sc = new Scanner(new File(\"input.txt\"));\n\n        \n\n        int n = sc.nextInt();\n\n        int m =sc.nextInt();\n\n        sc.nextLine();\n\n        int k =sc.nextInt();\n\n        int les[][] = new int[n][m];\n\n        PrintWriter out = new PrintWriter(new FileWriter(\"output.txt\")); \n\n        //sc.nextLine();\n\n        ArrayList<Integer[]> list = new ArrayList();\n\n        sc.nextLine();\n\n        for(int i = 0;i<k;i++)\n\n        {\n\n            \n\n            Integer[] ii = new Integer[2];\n\n            ii[0] = sc.nextInt()-1;\n\n            ii[1] = sc.nextInt()-1;\n\n            list.add(ii);\n\n            \n\n        }\n\n        sc.close(); \n\n        int maxr = 0;\n\n        int maxi = 0;\n\n        int maxj = 0;\n\n        for(int i = 0;i<n;i++)\n\n        {\n\n            for(int j = 0;j<m;j++)\n\n            {\n\n                int minr = 100000;\n\n                int mini = 0;\n\n                int minj = 0;\n\n                for(int f = 0;f<k;f++)\n\n                {\n\n                    Integer[] ii = list.get(f);\n\n                    int ww = Math.abs(ii[0] - i);\n\n                    int hh = Math.abs(ii[1] - j);\n\n                    int r = ww+hh;\n\n                    if(r<minr)\n\n                    {\n\n                        minr = r;\n\n                        mini=i;\n\n                        minj=j;\n\n                    }\n\n                    \n\n                }\n\n                if(maxr<minr&&minr<100000)\n\n                {\n\n                    maxi = mini;\n\n                    maxj = minj;\n\n                    maxr = minr;\n\n                }\n\n            }\n\n        }\n\n        \n\n        out.print((maxi+1)+\" \"+(maxj+1));\n\n        out.close();\n\n        \n\n    }\n\n    \n\n    \n\n\n\n\n\n    \n\n    \n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "/**\n * @author derrick20\n */\nimport java.io.*;\nimport java.util.*;\n\npublic class SameSumBlocks {\n    public static void main(String[] args) throws Exception {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int N = sc.nextInt();\n        int[] pre = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            pre[i] = pre[i - 1] + sc.nextInt();\n        }\n//        var sumMap = new HashMap<Integer, ArrayList<Pair>>();\n//        var sums = new ArrayList<Pair>();\n        Pair[] sums = new Pair[N * (N + 1) / 2];\n        int k = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = i; j <= N; j++) {\n                int sum = pre[j] - pre[i - 1];\n//                sumMap.computeIfAbsent(sum, val -> new ArrayList<>()).add(new Pair(i, j, sum));\n                sums[k++] = new Pair(i, j, sum);\n            }\n        }\n        Arrays.sort(sums, (p1, p2) -> p1.sum - p2.sum != 0 ? p1.sum - p2.sum : p1.r - p2.r);\n        var ans = new ArrayList<Pair>();\n        int i = 0;\n        while (i < k) {\n            var group = new ArrayList<Pair>();\n            int last = 0;\n            int j = i;\n            while (j < k && sums[j].sum == sums[i].sum) {\n                if (sums[j].l > last) {\n                    group.add(sums[j]);\n                    last = sums[j].r;\n                }\n                j++;\n            }\n//            System.out.println(group);\n            if (group.size() > ans.size()) {\n                ans = group;\n            }\n            i = j;\n        }\n        out.println(ans.size());\n        for (Pair p : ans) {\n            out.println(p);\n        }\n        out.close();\n    }\n\n    static class Pair {\n        int l, r, sum;\n        public Pair(int ll, int rr, int ss) {\n            l = ll; r = rr; sum = ss;\n        }\n        public String toString() {\n            return l + \" \" + r;\n        }\n    }\n\n    static class FastScanner {\n        private int BS = 1<<16;\n        private char NC = (char)0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n\n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n\n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            }\n            catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n\n        private char getChar(){\n            while(bId==size) {\n                try {\n                    size = in.read(buf);\n                }catch(Exception e) {\n                    return NC;\n                }\n                if(size==-1)return NC;\n                bId=0;\n            }\n            return (char)buf[bId++];\n        }\n\n        public int nextInt() {\n            return (int)nextLong();\n        }\n\n        public int[] nextInts(int N) {\n            int[] res = new int[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = (int) nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongs(int N) {\n            long[] res = new long[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long nextLong() {\n            cnt=1;\n            boolean neg = false;\n            if(c==NC)c=getChar();\n            for(;(c<'0' || c>'9'); c = getChar()) {\n                if(c=='-')neg=true;\n            }\n            long res = 0;\n            for(; c>='0' && c <='9'; c=getChar()) {\n                res = (res<<3)+(res<<1)+c-'0';\n                cnt*=10;\n            }\n            return neg?-res:res;\n        }\n\n        public double nextDouble() {\n            double cur = nextLong();\n            return c!='.' ? cur:cur+nextLong()/cnt;\n        }\n\n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while(c<=32)c=getChar();\n            while(c>32) {\n                res.append(c);\n                c=getChar();\n            }\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while(c<=32)c=getChar();\n            while(c!='\\n') {\n                res.append(c);\n                c=getChar();\n            }\n            return res.toString();\n        }\n\n        public boolean hasNext() {\n            if(c>32)return true;\n            while(true) {\n                c=getChar();\n                if(c==NC)return false;\n                else if(c>32)return true;\n            }\n        }\n    }\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.UncheckedIOException;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public void exec() {\n        int n = stdin.nextInt();\n        int[] a = stdin.nextIntArray(n);\n        List<Node> nodes = Arrays.stream(a).mapToObj(v -> {\n            Node node = new Node();\n            node.value = v;\n            return node;\n        }).collect(Collectors.toList());\n\n        int maxValue = -1;\n        int maxIndex = -1;\n        for (int i = 0, len = nodes.size(); i < len; i++) {\n            Node node = nodes.get(i);\n\n            if (maxValue < node.value) {\n                maxValue = node.value;\n                maxIndex = i;\n            }\n\n            if (i == 0) {\n                node.right = nodes.get(i+1);\n            } else if (i == len - 1) {\n                node.left = nodes.get(i-1);\n            } else {\n                node.left = nodes.get(i-1);\n                node.right = nodes.get(i+1);\n            }\n        }\n\n        Node node = nodes.get(maxIndex);\n        for (int i = 0; i < n-1; i++) {\n            if (node.left != null && node.value == node.left.value+1) {\n                node.left.right = node.right;\n                node = node.left;\n            } else if (node.right != null && node.value == node.right.value+1) {\n                node.right.left = node.left;\n                node = node.right;\n            } else {\n                stdout.println(\"NO\");\n                return ;\n            }\n        }\n        stdout.println(\"YES\");\n    }\n\n    public class Node {\n        private Node left;\n        private Node right;\n        private int value;\n    }\n\n    private static final Stdin stdin = new Stdin(System.in);\n    private static final Stdout stdout = new Stdout(System.out);\n    private static final Stderr stderr = new Stderr(System.err, false);\n\n    public static void main(String[] args) {\n        try {\n            new Main().exec();\n        } finally {\n            stdout.flush();\n        }\n    }\n\n    // ASCII ONLY\n    public static class Stdin {\n        private InputStream in;\n        private byte[] buf;\n        private int ptr;\n        private int len;\n\n        public Stdin(InputStream in) {\n            this.in = in;\n            this.buf = new byte[1024];\n            this.ptr = 0;\n            this.len = 0;\n        }\n\n        public String nextString() {\n            StringBuilder sb = new StringBuilder();\n            byte b;\n            while ((b = read()) != -1) {\n                sb.appendCodePoint(b);\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            return (int)nextLong();\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextString());\n        }\n\n        public long nextLong() {\n            boolean negative = false;\n            int x = 0;\n\n            byte b = read();\n            if (b == '-') {\n                negative = true;\n            } else {\n                x += b-'0';\n            }\n\n            while ((b=read()) != -1) {\n                x *= 10;\n                x += b-'0';\n            }\n\n            return negative ? -x : x;\n        }\n\n        private byte read() {\n            byte b = readByte();\n            if (b == '\\r') {\n                readByte(); // LF\u3092\u8aad\u307f\u98db\u3070\u3059\n                return -1;\n            } else if (b == '\\n' || b == ' ') {\n                return -1;\n            } else {\n                return b;\n            }\n        }\n\n        private byte readByte(){\n            if (len == ptr) {\n                try {\n                    ptr = 0;\n                    len = in.read(buf);\n                    if (len == -1) return -1;\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public String[] nextStringArray(int n) {\n            String[] a = new String[n];\n            for (int i = 0; i < n; i++) a[i] = nextString();\n            return a;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++) a[i] = nextDouble();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    public static class Stdout {\n        private PrintWriter stdout;\n\n        public Stdout(PrintStream stdout) {\n            this.stdout =  new PrintWriter(stdout, false);\n        }\n\n        public void println(Object ... objs) {\n            for (int i = 0, len = objs.length; i < len; i++) {\n                stdout.print(objs[i]);\n                if (i != len-1) stdout.print(' ');\n            }\n            stdout.println();\n        }\n\n        public void flush() {\n            stdout.flush();\n        }\n    }\n\n    public static class Stderr {\n        private PrintWriter stderr;\n        private boolean debug;\n\n        public Stderr(PrintStream stderr, boolean debug) {\n            this.stderr =  new PrintWriter(stderr, false);\n            this.debug = debug;\n        }\n\n        public void println(Object ... objs) {\n            if (!debug) return ;\n\n            stderr.print(\"DEBUG: \");\n            for (int i = 0, len = objs.length; i < len; i++) {\n                stderr.print(deepToString(objs[i]));\n                if (i != len-1) stderr.print(' ');\n            }\n            stderr.println();\n            stderr.flush();\n        }\n\n        private String deepToString(Object o) {\n            if (o == null) {\n                return \"null\";\n            }\n\n            // \u914d\u5217\u306e\u5834\u5408\n            if (o.getClass().isArray()) {\n                int len = Array.getLength(o);\n                String[] tokens = new String[len];\n                for (int i = 0; i < len; i++) {\n                    tokens[i] = deepToString(Array.get(o, i));\n                }\n                return \"{\" + String.join(\", \", tokens) + \"}\";\n            }\n\n            return Objects.toString(o);\n        }\n    }\n}", "complexity": "linear", "problem": "1197_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EIncreasingFrequency solver = new EIncreasingFrequency();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EIncreasingFrequency {\n        int n;\n        int c;\n        int[] arr;\n        ArrayList<Integer>[] lists;\n        int[] countC;\n\n        public void readInput(Scanner sc) {\n            n = sc.nextInt();\n            c = sc.nextInt();\n            arr = new int[n];\n            lists = new ArrayList[(int) 5e5 + 1];\n            for (int i = 0; i < lists.length; i++)\n                lists[i] = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                arr[i] = sc.nextInt();\n                if (arr[i] != c)\n                    lists[arr[i]].add(i);\n            }\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int q = 1;\n            while (q-- > 0) {\n                readInput(sc);\n                int max = 0;\n                countC = new int[n];\n                for (int i = 0; i < n; i++) {\n                    if (arr[i] == c)\n                        countC[i] = 1;\n                    if (i != 0)\n                        countC[i] += countC[i - 1];\n                }\n                for (int i = 0; i < lists.length; i++) {\n                    if (lists[i].isEmpty())\n                        continue;\n                    max = Math.max(max, maxSubSeg(lists[i]));\n                }\n                pw.println(max + countC[n - 1]);\n            }\n        }\n\n        private int maxSubSeg(ArrayList<Integer> list) {\n            int sum = 1;\n            int max = 1;\n            for (int i = 1; i < list.size(); i++) {\n                int idx = list.get(i);\n                int prev = list.get(i - 1);\n                int remove = countC[idx] - countC[prev];\n                sum += -remove + 1;\n                if (sum <= 0)\n                    sum = 1;\n                max = Math.max(max, sum);\n            }\n            return max;\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "1082_E", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * @author Mubtasim Shahriar\n */\n\npublic class Cgr14 {\n\n    public static void main(String[] args) {\n\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader sc = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n\t\tint t = sc.nextInt();\n//        int t = 1;\n        while (t-- != 0) {\n            solver.solve(sc, out);\n        }\n        out.close();\n\n    }\n\n    static class Solver {\n        public void solve(InputReader sc, PrintWriter out) {\n            long n = sc.nextInt();\n            long l = 1;\n            long r = (long)1e5;\n            while(l<=r) {\n                long mid = (l+r)/2;\n                long needed = (mid*mid)*2;\n                if(needed==n) {\n                    out.println(\"YES\");\n                    return;\n                }\n                if(needed>n) {\n                    r = mid-1;\n                } else {\n                    l = mid+1;\n                }\n            }\n            l = 1;\n            r = (long)1e5;\n            while(l<=r) {\n                long mid = (l+r)/2;\n                long needed = (mid*mid)*4;\n                if(needed==n) {\n                    out.println(\"YES\");\n                    return;\n                }\n                if(needed>n) {\n                    r = mid-1;\n                } else {\n                    l = mid+1;\n                }\n            }\n            out.println(\"NO\");\n        }\n\n    }\n\n    static void sort(int[] arr) {\n        Random rand = new Random();\n        int n = arr.length;\n        for (int i = 0; i < n; i++) {\n            int idx = rand.nextInt(n);\n            if (idx == i) continue;\n            arr[i] ^= arr[idx];\n            arr[idx] ^= arr[i];\n            arr[i] ^= arr[idx];\n        }\n        Arrays.sort(arr);\n    }\n\n    static void sort(long[] arr) {\n        Random rand = new Random();\n        int n = arr.length;\n        for (int i = 0; i < n; i++) {\n            int idx = rand.nextInt(n);\n            if (idx == i) continue;\n            arr[i] ^= arr[idx];\n            arr[idx] ^= arr[i];\n            arr[i] ^= arr[idx];\n        }\n        Arrays.sort(arr);\n    }\n\n    static void sortDec(int[] arr) {\n        Random rand = new Random();\n        int n = arr.length;\n        for (int i = 0; i < n; i++) {\n            int idx = rand.nextInt(n);\n            if (idx == i) continue;\n            arr[i] ^= arr[idx];\n            arr[idx] ^= arr[i];\n            arr[i] ^= arr[idx];\n        }\n        Arrays.sort(arr);\n        int l = 0;\n        int r = n - 1;\n        while (l < r) {\n            arr[l] ^= arr[r];\n            arr[r] ^= arr[l];\n            arr[l] ^= arr[r];\n            l++;\n            r--;\n        }\n    }\n\n    static void sortDec(long[] arr) {\n        Random rand = new Random();\n        int n = arr.length;\n        for (int i = 0; i < n; i++) {\n            int idx = rand.nextInt(n);\n            if (idx == i) continue;\n            arr[i] ^= arr[idx];\n            arr[idx] ^= arr[i];\n            arr[i] ^= arr[idx];\n        }\n        Arrays.sort(arr);\n        int l = 0;\n        int r = n - 1;\n        while (l < r) {\n            arr[l] ^= arr[r];\n            arr[r] ^= arr[l];\n            arr[l] ^= arr[r];\n            l++;\n            r--;\n        }\n    }\n\n    static class InputReader {\n        private boolean finished = false;\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int peek() {\n            if (numChars == -1) {\n                return -1;\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private String readLine0() {\n            StringBuilder buf = new StringBuilder();\n            int c = read();\n            while (c != '\\n' && c != -1) {\n                if (c != '\\r') {\n                    buf.appendCodePoint(c);\n                }\n                c = read();\n            }\n            return buf.toString();\n        }\n\n        public String readLine() {\n            String s = readLine0();\n            while (s.trim().length() == 0) {\n                s = readLine0();\n            }\n            return s;\n        }\n\n        public String readLine(boolean ignoreEmptyLines) {\n            if (ignoreEmptyLines) {\n                return readLine();\n            } else {\n                return readLine0();\n            }\n        }\n\n        public BigInteger readBigInteger() {\n            try {\n                return new BigInteger(nextString());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n\n        public char nextCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E') {\n                    return res * Math.pow(10, nextInt());\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E') {\n                        return res * Math.pow(10, nextInt());\n                    }\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public boolean isExhausted() {\n            int value;\n            while (isSpaceChar(value = peek()) && value != -1) {\n                read();\n            }\n            return value == -1;\n        }\n\n        public String next() {\n            return nextString();\n        }\n\n        public SpaceCharFilter getFilter() {\n            return filter;\n        }\n\n        public void setFilter(SpaceCharFilter filter) {\n            this.filter = filter;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public int[] nextSortedIntArray(int n) {\n            int array[] = nextIntArray(n);\n            Arrays.sort(array);\n            return array;\n        }\n\n        public int[] nextSumIntArray(int n) {\n            int[] array = new int[n];\n            array[0] = nextInt();\n            for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();\n            return array;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] array = new long[n];\n            for (int i = 0; i < n; ++i) array[i] = nextLong();\n            return array;\n        }\n\n        public long[] nextSumLongArray(int n) {\n            long[] array = new long[n];\n            array[0] = nextInt();\n            for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();\n            return array;\n        }\n\n        public long[] nextSortedLongArray(int n) {\n            long array[] = nextLongArray(n);\n            Arrays.sort(array);\n            return array;\n        }\n    }\n\n\n}\n", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.util.Scanner;\n \npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner scan=new Scanner(System.in);\n\t\tint n=scan.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tString s=scan.next();\n\t\t\tif(s.matches(\"R[0-9]+C[0-9]+\")){\n\t\t\t\tString[] nums=s.split(\"R|C\");\n\t\t\t\tint x=Integer.parseInt(nums[2]);\n\t\t\t\tString t=\"\";\n\t\t\t\twhile(x!=0){\n\t\t\t\t\tint m=x%26;\n\t\t\t\t\tif(m==0){\n\t\t\t\t\t\tt=\"Z\"+t;\n\t\t\t\t\t\tx-=26;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tt=(char)(m+'A'-1)+t;\n\t\t\t\t\tx/=26;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(t+nums[1]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tString x1 = s.replaceAll(\"[0-9]\", \"\");\n\t\t\t\tString x2 = s.replaceAll(\"[A-Z]\", \"\");\n\t\t\t\tint base=1;\n\t\t\t\tint t=0;\n\t\t\t\tfor(int j=x1.length()-1;j>=0;j--) {\n\t\t\t\t\tt+=base*(x1.charAt(j)-'A'+1);\n\t\t\t\t\tbase*=26;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"R\"+ x2 + \"C\"+t);\n\t\t\t}\n\t\t}\n\t}\n}", "complexity": "linear", "problem": "0001_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\n\nimport java.math.BigInteger;\n\nimport java.util.*;\n\n\n\npublic class Pipeline\n\n{\n\n\n\n    \n\n   \n\n static StringTokenizer st;\n\n static BufferedReader in;\n\n static PrintWriter out;\n\n\n\n\n\n private static int nextInt() throws IOException \n\n {\n\n        return Integer.parseInt(next());\n\n }\n\n\n\n  private static long nextLong() throws IOException\n\n  {\n\n        return Long.parseLong(next());\n\n  }\n\n  private static byte nextByte() throws IOException\n\n  {\n\n        return Byte.parseByte(next());\n\n  }\n\n  \n\n   private static String next() throws IOException\n\n {\n\n        while(st == null || ! st.hasMoreTokens())\n\n        {\n\n            st = new StringTokenizer(in.readLine());\n\n        }\n\n        return st.nextToken();\n\n }\n\n    static long sum(long k)\n\n{\n\n    return k*(k+1)/2;\n\n}\n\n   \n\n   static long sum(long s, long e)\n\n{\n\n    \n\n    if(s <= 1)\n\n        return sum(e);\n\n \n\n    return sum(e) - sum(s-1);\n\n}\n\n\n\n   \n\n   static long BS_MinSplitters(long k,long n)\n\n   {\n\n       long Start=1    , End =k;\n\n       \n\n       while (Start < End)\n\n       {\n\n           long mid=(Start+End)/2;\n\n           long s=sum(mid,k);\n\n           \n\n            if(s == n)\n\n            return k - mid + 1;\n\n           if (s > n)\n\n           {\n\n               Start=mid+1;\n\n           }\n\n           else\n\n               End=mid;\n\n       }\n\n       \n\n       return  k-Start+2;\n\n   }\n\n \n\n  \n\n    public static void  main(String[] args) throws IOException \n\n    {\n\n        in = new BufferedReader(new InputStreamReader(System.in));\n\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n        \n\n        long n=nextLong();\n\n        long k=nextLong();\n\n        \n\n        if (n==1)\n\n            System.out.println(0);\n\n        else if (n<=k)\n\n        {\n\n            System.out.println(1);\n\n        }\n\n        else\n\n        {\n\n            k--;\n\n            n--;\n\n           \n\n            if (sum(k)<n)\n\n            {\n\n                System.out.println(\"-1\");\n\n            }\n\n            else\n\n            {\n\n                System.out.println(BS_MinSplitters(k, n));\n\n            }\n\n        }\n\n        \n\n        \n\n       \n\n        \n\n    }\n\n    \n\n}\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Cf1017A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int result = 1;\n        int thomasSum = 0;\n        StringTokenizer stk;\n        stk = new StringTokenizer(br.readLine());\n        int first = Integer.parseInt(stk.nextToken());\n        int second = Integer.parseInt(stk.nextToken());\n        int third = Integer.parseInt(stk.nextToken());\n        int fourth = Integer.parseInt(stk.nextToken());\n        thomasSum = first + second + third + fourth;\n        int tmp;\n        for (int i = 1; i < n; i++) {\n            stk = new StringTokenizer(br.readLine());\n            first = Integer.parseInt(stk.nextToken());\n            second = Integer.parseInt(stk.nextToken());\n            third = Integer.parseInt(stk.nextToken());\n            fourth = Integer.parseInt(stk.nextToken());\n            tmp = first + second + third + fourth;\n            if (tmp > thomasSum)\n                result++;\n        }\n        System.out.println(result);\n    }\n}", "complexity": "linear", "problem": "1017_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "//package pack;\n\nimport java.util.*;\n\npublic class first\n{\n\tpublic static long power(long x, long y, long p)\n    {\n        long res = 1;\n        x = x % p; \n        while (y > 0)\n        {\tif((y & 1)==1)\n                res = (res * x) % p;\n            y = y >> 1; \n            x = (x * x) % p; \n        }\n        return res;\n    }\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tlong x=sc.nextLong();\n\t\tlong k=sc.nextLong();\n\t\tlong mod=1000000007;\n\t\tif(k==0 || x==0)\n\t\t\tSystem.out.println((2*x)%mod);\n\t\telse\n\t\t{\tlong answer=1;\n\t\t\tanswer+=(power(2,k,mod))*(((2*x)-1)%mod);\n\t\t\tSystem.out.println(answer%mod);\n\t\t}\n\t}\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.BigInteger; \n\npublic class test1 {\n    \n    static int[][] dir={{0,1},{1,0},{-1,0},{0,-1}};\n   static class sort implements Comparator<int[]>\n   {\n        public int compare(int[] a,int[] b)\n        {\n            if(a[0] == b[0]) return a[1]-b[1];\n           return a[0]-b[0];\n        }\n   }\n   \n   public static void pri(PrintWriter out,Object o)\n   {\n      \n    out.println(o.toString());\n    \n   }\n   public static void prW(PrintWriter out,Object o)\n   {\n      \n    out.print(o.toString());\n    \n   }\n   public static int intIn(String st)\n   {\n      return Integer.parseInt(st);\n   }\n   \n   \n    \n    public static void pr(Object o)\n    {\n        System.out.println(o.toString());\n    }\n    public static void prW(Object o)\n    {\n        System.out.print(o.toString());\n    }\n    \n   \n    public static int inInt(String s)\n    {\n        return Integer.parseInt(s);\n    }\n    public static long in(String s)\n    {\n        return Long.parseLong(s);\n    }\n\n    static long power(long x, long y, long p)\n      {\n        long res = 1; // Initialize result\n     \n        x = x % p; // Update x if it is more than or\n        // equal to p\n     \n        if (x == 0)\n          return 0l; // In case x is divisible by p;\n     \n        while (y > 0)\n        {\n     \n          // If y is odd, multiply x with result\n          if ((y & 1) != 0)\n            res = (res * x) % p;\n     \n          // y must be even now\n          y = y >> 1; // y = y/2\n          x = (x * x) % p;\n        }\n        return res;\n      }\n      static long gcd(long a, long b)\n        {\n          if (b == 0)\n            return a;\n          return gcd(b, a % b); \n        }\n        static int gcd(int a, int b,int o)\n        {\n          if (b == 0)\n            return a;\n          return gcd(b, a % b,o); \n        }\n    \n      \n    \n    \n    static int[] toIntArray(String[] m) \n    { \n        int[] p=new int[m.length];\n        for(int o=0;o<m.length;o++)\n        {\n            p[o]= inInt(m[o]);\n        }\n        return p;\n    }\n    static long[] toLArray(String[] m) \n    { \n       long[] p=new long[m.length];\n        for(int o=0;o<m.length;o++)\n        {\n            p[o]= in(m[o]);\n        }\n        return p;\n    }\n    public static long F(long[] arr)\n    {\n        //int len=arr.length;\n        \n       // Arrays.sort(arr);\n        long med;\n        if((arr.length%2) == 0)\n        {\n            med = (arr[arr.length/2] + arr[(arr.length/2)-1])/(2);\n        }\n        else\n        {\n            med = (arr[arr.length/2]);\n        }\n        long dis = 0l;\n\n        for(long x : arr)\n        {\n            dis += (Math.abs(x-med));\n           // prW(x+\" \");\n        }\n        //prW(med);\n       // pr(\"\");\n       // arr=tem;\n        return dis;\n\n\n    }\n    static int[][] pre;// = new int[n][27];\n    static int[][] fin;//\n    public static String[] F(BufferedReader bf) throws Exception\n    {\n        return (bf.readLine().split(\" \"));\n    }\n   \n    public static void main (String[] args) throws Exception {\n        \n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n       // PrintWriter out = new PrintWriter(System.out);;;\n        \n        //int[] map=new int[1000001];\n      \n        int y=1;//Integer.parseInt(bf.readLine());\n        \n        for(int h=0;h<y;h++)\n        {\n\n            \n    \n            String[] xlp = bf.readLine().split(\" \");\n            \n            int n,k,t;//boolean bol=false; int[] arr = toIntArray(F(bf));\n\n            n=intIn(xlp[0]);\n            k = intIn(xlp[1]);\n            long s1,s2;\n            s1=s2=0;\n            for(int o=0;o<n;o++) s1+=(o+0l);\n            for(int o=0;o<=((n-1)/2);o++)\n            {\n                s2+=(o+0l);\n\n            }\n            s2 = (2+0l)*s2;\n\n            if((n%2) == 0) \n            {\n                s2+= (n/2)+0l;\n            }\n\n            double x=0.00;\n            double other=0.00;long sum=0l;\n            for(int o=0;o<k;o++)\n            {\n                xlp = bf.readLine().split(\" \");\n                x+=(intIn(xlp[0]) +0.00);\n                int d = intIn(xlp[1]);\n                long v;\n                if(d>0)\n                {\n                    v = (d+0l)*(s1+0l);\n                }\n                else\n                {\n                    v = (d+0l)*(s2+0l);\n                }\n                sum += (v);\n            }\n\n            double res = (x) + ((sum+0.00)/(n+0.00));\n            pr(res);\n\n\n\n            \n\n            \n            \n            \n        }\n       // out.close();\n\n    }\n}\n/*\n3 10\n10 10 10Output\nNO\nAnswer\nstatic class SegmentTreeRMQ \n    { \n    int st[]; \n    int minVal(int x, int y) { \n        return (x > y) ? x : y; \n    } \n  \n    \n    int getMid(int s, int e) { \n        return s + (e - s) / 2; \n    } \n  \n    \n    int RMQUtil(int ss, int se, int qs, int qe, int index) \n    { \n        \n        if (qs <= ss && qe >= se) \n            return st[index]; \n  \n        // If segment of this node is outside the given range \n        if (se < qs || ss > qe) \n            return Integer.MIN_VALUE; \n  \n        // If a part of this segment overlaps with the given range \n        int mid = getMid(ss, se); \n        return minVal(RMQUtil(ss, mid, qs, qe, 2 * index + 1), \n                RMQUtil(mid + 1, se, qs, qe, 2 * index + 2)); \n    } \n  \n    // Return minimum of elements in range from index qs (query \n    // start) to qe (query end).  It mainly uses RMQUtil() \n    int RMQ(int n, int qs, int qe) \n    { \n        // Check for erroneous input values \n        \n  \n        return RMQUtil(0, n - 1, qs, qe, 0); \n    } \n  \n    // A recursive function that constructs Segment Tree for \n    // array[ss..se]. si is index of current node in segment tree st \n    int constructSTUtil(int arr[], int ss, int se, int si) \n    { \n        // If there is one element in array, store it in current \n        //  node of segment tree and return \n        if (ss == se) { \n            st[si] = arr[ss]; \n            return arr[ss]; \n        } \n  \n        // If there are more than one elements, then recur for left and \n        // right subtrees and store the minimum of two values in this node \n        int mid = getMid(ss, se); \n        st[si] = minVal(constructSTUtil(arr, ss, mid, si * 2 + 1), \n                constructSTUtil(arr, mid + 1, se, si * 2 + 2)); \n        return st[si]; \n    } \n  \n    \n    void con(int arr[]) \n    { \n        // Allocate memory for segment tree \n  \n        //Height of segment tree \n        int n = (arr.length);\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2))); \n  \n        //Maximum size of segment tree \n        int max_size = 2 * (int) Math.pow(2, x) - 1; \n        st = new int[max_size]; // allocate memory \n  \n        // Fill the allocated memory st \n        constructSTUtil(arr, 0, n - 1, 0); \n    }\n    }\n     static class DSU {\n    \n    int[] p;int[] sz;int op;int c;;\n    int[] last;\n    public void G(int n)\n    {\n        last=new int[n];\n        p=new int[n];\n        sz=new int[n];c=n;\n        op=n;\n        for(int h=0;h<n;h++)\n        {\n            sz[h]=1;p[h]=h;\n            last[h]=h;\n        }\n    }\n    public int find(int x)\n    {\n        int y=x;\n        while(x!=p[x]) x=p[x];\n        while(y!=p[y])\n        {\n            int tem=p[y];\n            p[y]=x;y=tem;\n        }\n        return p[y];\n    }\n    public void union(int a,int b)\n    {\n        int x,y;\n        x=find(a);y=find(b);\n        if(x==y) return;\n        if(sz[x]>sz[y])\n        {\n            p[y] = x;\n            sz[x]+=sz[y];\n            last[x]=Math.max(last[x],last[y]);\n        }\n        else\n        {\n          p[x]=y;sz[y]+=sz[x];\n            last[y]=Math.max(last[y],last[x]);\n        }\n        c--;\n        \n    }}\n*/\n", "complexity": "linear", "problem": "1009_C", "from": "CODEFORCES", "tags": "greedy,math"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class D911 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        StringTokenizer st;\n\n        int n = Integer.parseInt(br.readLine());\n        st = new StringTokenizer(br.readLine());\n        int[] num = new int[n];\n        for (int i = 0; i < n; i++) {\n            num[i] = Integer.parseInt(st.nextToken());\n        }\n\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (num[i] < num[j]) {\n                    count++;\n                }\n            }\n        }\n\n        boolean ans = count % 2 == 0;\n        for (int m = Integer.parseInt(br.readLine()); m-- > 0; ) {\n            st = new StringTokenizer(br.readLine());\n            int l = Integer.parseInt(st.nextToken());\n            int r = Integer.parseInt(st.nextToken());\n            if (((r - l + 1) / 2) % 2 != 0) {\n                ans = !ans;\n            }\n            out.println(ans ? \"even\" : \"odd\");\n        }\n        out.close();\n    }\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.Scanner;\n\n/**\n * Created by Gantushig on 2/18/2016.\n */\n\npublic class A {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        long n = input.nextLong();\n        System.out.println(\"25\");\n    }\n\n}\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\nimport java.util.*;\nimport java.util.Scanner;\n\npublic class Def {\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s = new Scanner(System.in);\n\t\tint t = s.nextInt();\n\t\twhile (t-->0) {\n\t\t\t\n\t\t\tint n = s.nextInt();\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tarr[i] = s.nextInt();\n\t\t\t}\n\n//\t\t\tint deep = 0;\n//\t\t\tSystem.out.println(n+\"     n\");\n\t\t\tList<Integer> al = new ArrayList<>();\n\t\t\tal.add(1);\n\t\t\tSystem.out.println(1);\n\t\t\tfor(int i=1; i<n;i++) {\n\t\t\t\tint len = al.size();\n//\t\t\t\tfor (int d =0; d<len; d++) {\n//\t\t\t\t\tSystem.out.print(al.get(d)+\" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t\tif (arr[i] == 1) {\n\t\t\t\t\tfor(int j=0; j<len; j++) {\n\t\t\t\t\t\tSystem.out.print(al.get(j)+\".\");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tal.add(1);\n\t\t\t\t}else if (arr[i] == arr[i-1] && arr[i]==1) {\n\t\t\t\t\t\n\t\t\t\t\tfor(int j=0; j<len; j++) {\n\t\t\t\t\t\tSystem.out.print(al.get(j)+\".\");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tal.add(1);\n\t\t\t\t}else {\n\t\t\t\t\tfor (int j=len-1; j>-1; j--) {\n\t\t\t\t\t\tif (al.get(j)+1 == arr[i]) {\n\t\t\t\t\t\t\tfor(int k=0; k<j; k++) {\n\t\t\t\t\t\t\t\tSystem.out.print(al.get(k)+\".\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t\t\t\tal.set(j, al.get(j)+1);\n\t\t\t\t\t\t\tal.subList(j+1, len).clear();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\ts.close();\n\t\t\n\n\t}\n\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        FastReader in;\n        PrintWriter out;\n        int n;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.nextInt();\n            if (n % 4 != 0) {\n                out.println(\"! -1\");\n                return;\n            }\n            int low = 0;\n            int high = n >> 1;\n            int fSign = Integer.signum(BValue(low));\n            if (fSign == 0) {\n                out.println(\"! \" + (low + 1));\n                return;\n            }\n            while (high - low > 1) {\n                int mid = (high + low) >> 1;\n                int mSign = Integer.signum(BValue(mid));\n                if (mSign == 0) {\n                    out.println(\"! \" + (mid + 1));\n                    return;\n                }\n                if (mSign == -fSign) {\n                    high = mid;\n                } else {\n                    low = mid;\n                }\n            }\n            out.println(\"! -1\");\n        }\n\n        public int BValue(int index) {\n            out.println(\"? \" + (index + 1));\n            out.flush();\n            int f = in.nextInt();\n            out.println(\"? \" + (index + 1 + (n >> 1)));\n            out.flush();\n            int s = in.nextInt();\n            return f - s;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\n\n\npublic class D_faster {\n\n\n\n\tstatic final int K = 4;\n\n\n\n\tstatic class Node {\n\n\t\tint l, r;\n\n\t\tNode left, right;\n\n\n\n\t\tint[] info;\n\n\n\n\t\tpublic Node(int l, int r, int[] a) {\n\n\t\t\tthis.l = l;\n\n\t\t\tthis.r = r;\n\n\t\t\tif (r - l == 1) {\n\n\t\t\t\tinfo = new int[] { a[l], 1 };\n\n\t\t\t} else {\n\n\t\t\t\tint m = (l + r) >> 1;\n\n\t\t\t\tleft = new Node(l, m, a);\n\n\t\t\t\tright = new Node(m, r, a);\n\n\t\t\t\tinfo = merge(left.info, right.info);\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\tint[] getInfo(int ql, int qr) {\n\n\t\t\tif (ql >= r || l >= qr) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tif (ql <= l && r <= qr) {\n\n\t\t\t\treturn info;\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tint[] infoL = left.getInfo(ql, qr);\n\n\t\t\tint[] infoR = right.getInfo(ql, qr);\n\n\t\t\treturn merge(infoL, infoR);\n\n\t\t}\n\n\n\n\t}\n\n\n\n\tstatic int[] merge(int[] a, int[] b) {\n\n\t\t\n\n\t\tif (a == null) {\n\n\t\t\treturn b;\n\n\t\t}\n\n\t\t\n\n\t\tif (b == null) {\n\n\t\t\treturn a;\n\n\t\t}\n\n\n\n\t\tint[] all = Arrays.copyOf(a, a.length + b.length);\n\n\n\n\t\tint ptr = a.length;\n\n\n\n\t\touter: for (int i = 0; i < b.length; i += 2) {\n\n\n\n\t\t\tint val = b[i];\n\n\t\t\tint cnt = b[i + 1];\n\n\n\n\t\t\tfor (int j = 0; j < ptr; j += 2) {\n\n\t\t\t\tif (val == all[j]) {\n\n\t\t\t\t\tall[j + 1] += cnt;\n\n\t\t\t\t\tcontinue outer;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\t\tall[ptr++] = val;\n\n\t\t\tall[ptr++] = cnt;\n\n\t\t}\n\n\n\n\t\twhile (ptr > 2 * K) {\n\n\t\t\tint idx = -1;\n\n\t\t\tint leastCnt = Integer.MAX_VALUE;\n\n\t\t\tfor (int i = 0; i < ptr; i += 2) {\n\n\t\t\t\tif (all[i + 1] < leastCnt) {\n\n\t\t\t\t\tidx = i;\n\n\t\t\t\t\tleastCnt = all[i + 1];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\t\tfor (int i = 0; i < ptr; i += 2) {\n\n\t\t\t\tall[i + 1] -= leastCnt;\n\n\t\t\t}\n\n\n\n\t\t\tfor (int i = idx + 2; i < ptr; i++) {\n\n\t\t\t\tall[i - 2] = all[i];\n\n\t\t\t}\n\n\n\n\t\t\tptr -= 2;\n\n\t\t}\n\n\n\n\t\tall = Arrays.copyOf(all, ptr);\n\n\t\t\n\n//\t\tSystem.err.println(Arrays.toString(a));\n\n//\t\tSystem.err.println(Arrays.toString(b));\n\n//\t\tSystem.err.println(Arrays.toString(all));\n\n//\t\tSystem.err.println(\"-----------\");\n\n\t\treturn all;\n\n\t}\n\n\t\n\n\tvoid submit() {\n\n\t\tint n = nextInt();\n\n\t\tint q = nextInt();\n\n\t\t\n\n\t\tint[] a = new int[n];\n\n\t\tint[] occ = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\ta[i] = nextInt() - 1;\n\n\t\t\tocc[a[i]]++;\n\n\t\t}\n\n\t\t\n\n\t\tint[][] arr = new int[n][];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tarr[i] = new int[occ[i]];\n\n\t\t}\n\n\t\t\n\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\n\t\t\t\n\n\t\t\tint x = a[i];\n\n\t\t\t\n\n\t\t\tarr[x][--occ[x]] = i;\n\n\t\t}\n\n\t\t\n\n\t\tNode root = new Node(0, n, a);\n\n\t\t\n\n\t\twhile (q-- > 0) {\n\n\t\t\tint l = nextInt() - 1;\n\n\t\t\tint r = nextInt();\n\n\t\t\tint k = nextInt();\n\n\t\t\t\n\n\t\t\tint need = (r - l) / k + 1;\n\n\t\t\t\n\n\t\t\tint[] info = root.getInfo(l, r);\n\n\t\t\t\n\n\t\t\tint cand = n;\n\n\t\t\t\n\n\t\t\tfor (int i = 0; i < info.length; i += 2) {\n\n\t\t\t\tint x = info[i];\n\n//\t\t\t\tSystem.err.println(count(arr[x], r));\n\n//\t\t\t\tSystem.err.println(count(arr[x], l));\n\n\t\t\t\tif (count(arr[x], r) - count(arr[x], l) >= need) {\n\n\t\t\t\t\tcand = Math.min(cand, x);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tout.println(cand == n ? -1 : (cand + 1));\n\n\t\t}\n\n\t}\n\n\t\n\n\tint count(int[] arr, int x) {\n\n\t\tint tmp = Arrays.binarySearch(arr, x);\n\n\t\tif (tmp < 0) {\n\n\t\t\treturn -tmp - 1;\n\n\t\t}\n\n\t\treturn tmp;\n\n\t}\n\n\n\n\tvoid preCalc() {\n\n\n\n\t}\n\n\n\n\tvoid stress() {\n\n\n\n\t}\n\n\n\n\tvoid test() {\n\n\n\n\t}\n\n\n\n\tD_faster() throws IOException {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tout = new PrintWriter(System.out);\n\n\t\tpreCalc();\n\n\t\tsubmit();\n\n\t\t// stress();\n\n\t\t// test();\n\n\t\tout.close();\n\n\t}\n\n\n\n\tstatic final Random rng = new Random();\n\n\n\n\tstatic int rand(int l, int r) {\n\n\t\treturn l + rng.nextInt(r - l + 1);\n\n\t}\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew D_faster();\n\n\t}\n\n\n\n\tBufferedReader br;\n\n\tPrintWriter out;\n\n\tStringTokenizer st;\n\n\n\n\tString nextToken() {\n\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\n\t\t\ttry {\n\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\t} catch (IOException e) {\n\n\t\t\t\tthrow new RuntimeException(e);\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn st.nextToken();\n\n\t}\n\n\n\n\tString nextString() {\n\n\t\ttry {\n\n\t\t\treturn br.readLine();\n\n\t\t} catch (IOException e) {\n\n\t\t\tthrow new RuntimeException(e);\n\n\t\t}\n\n\t}\n\n\n\n\tint nextInt() {\n\n\t\treturn Integer.parseInt(nextToken());\n\n\t}\n\n\n\n\tlong nextLong() {\n\n\t\treturn Long.parseLong(nextToken());\n\n\t}\n\n\n\n\tdouble nextDouble() {\n\n\t\treturn Double.parseDouble(nextToken());\n\n\t}\n\n}\n\n", "complexity": "cubic", "problem": "0840_D", "from": "CODEFORCES", "tags": "data structures,probabilities"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\nimport java.math.*;\nimport static java.lang.Integer.*;\nimport static java.lang.Double.*;\nimport java.lang.Math.*;\n\npublic class two_squares {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew two_squares().run();\n\t}\n\n\tpublic void run() throws Exception {\n\t\tFastIO file = new FastIO();\n\t\tdouble x1 = file.nextInt();\n\t\tdouble y1 = file.nextInt();\n\t\tdouble x2 = file.nextInt();\n\t\tdouble y2 = file.nextInt();\n\t\tdouble x3 = file.nextInt();\n\t\tdouble y3 = file.nextInt();\n\t\tdouble x4 = file.nextInt();\n\t\tdouble y4 = file.nextInt();\n\t\tdouble minx1, maxx1, miny1, maxy1;\n\t\tminx1 = Math.min(x1, Math.min(x2, Math.min(x3, x4)));\n\t\tmaxx1 = Math.max(x1, Math.max(x2, Math.max(x3, x4)));\n\t\tminy1 = Math.min(y1, Math.min(y2, Math.min(y3, y4)));\n\t\tmaxy1 = Math.max(y1, Math.max(y2, Math.max(y3, y4)));\n\t\tdouble x5 = file.nextInt();\n\t\tdouble y5 = file.nextInt();\n\t\tdouble x6 = file.nextInt();\n\t\tdouble y6 = file.nextInt();\n\t\tdouble x7 = file.nextInt();\n\t\tdouble y7 = file.nextInt();\n\t\tdouble x8 = file.nextInt();\n\t\tdouble y8 = file.nextInt();\n\t\tdouble minx2, maxx2, miny2, maxy2;\n\t\tminx2 = Math.min(x5, Math.min(x6, Math.min(x7, x8)));\n\t\tmaxx2 = Math.max(x5, Math.max(x6, Math.max(x7, x8)));\n\t\tminy2 = Math.min(y5, Math.min(y6, Math.min(y7, y8)));\n\t\tmaxy2 = Math.max(y5, Math.max(y6, Math.max(y7, y8)));\n\t\tPoint _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16;\n\t\t_1 = new Point(x1, y1);\n\t\t_2 = new Point(x2, y2);\n\t\t_3 = new Point(x3, y3);\n\t\t_4 = new Point(x4, y4);\n\t\t_5 = new Point(x5, y5);\n\t\t_6 = new Point(x6, y6);\n\t\t_7 = new Point(x7, y7);\n\t\t_8 = new Point(x8, y8);\n\t\t_9 = new Point(minx1, maxy1);\n\t\t_10 = new Point(minx1, miny1);\n\t\t_11 = new Point(maxx1, maxy1);\n\t\t_12 = new Point(maxx1, miny1);\n\t\tdouble m1 = (minx2 + maxx2) / 2;\n\t\tdouble m2 = (miny2 + maxy2) / 2;\n\t\t_13 = new Point(minx2, m2);\n\t\t_14 = new Point(m1, miny2);\n\t\t_15 = new Point(maxx2, m2);\n\t\t_16 = new Point(m1, maxy2);\n\t\tPoint[] a = {_1, _2, _3, _4};\n\t\tPoint[] b = {_5, _6, _7, _8};\n\t\tboolean works = false;\n\t\tLine[] aa = {new Line(_9,_10), new Line(_10, _12), new Line(_12, _11), new Line(_11, _9)};\n\t\tLine[] bb = {new Line(_13, _14), new Line(_14, _15), new Line(_15, _16), new Line(_16, _13)};\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (aa[i].intersection(bb[i]) != null) {\n\t\t\t\t\tworks = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Point p : b) {\n\t\t\tif (p.x >= minx1 && p.x <= maxx1 && p.y >= miny1 && p.y <= maxy1) {\n\t\t\t\tworks = true;\n\t\t\t}\n\t\t}\n\t\tfor (Point p : a) {\n\t\t\tboolean result = false;\n\t\t      for (int i = 0, j = b.length - 1; i < b.length; j = i++) {\n\t\t        if ((b[i].y > p.y) != (b[j].y > p.y) &&\n\t\t            (p.x < (b[j].x - b[i].x) * (p.y - b[i].y) / (b[j].y-b[i].y) + b[i].x)) {\n\t\t          result = !result;\n\t\t         }\n\t\t      }\n\t\t      if (result) works = true;\n\t\t}\n\t\tSystem.out.println(works ? \"YES\" : \"NO\");\n\t}\n\tpublic static class Point {\n\t\tdouble x, y;\n\t\tpublic Point(double a, double b) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\t}\n\tpublic static class Line {\n\t\tPoint a, b;\n\t\tpublic Line(Point x, Point y) {\n\t\t\ta = x;\n\t\t\tb = y;\n\t\t}\n\t\tpublic Point intersection(Line o) {\n\t\t\tdouble x1 = a.x;\n\t\t\tdouble y1 = a.y;\n\t\t\tdouble x2 = b.x;\n\t\t\tdouble y2 = b.y;\n\t\t\tdouble x3 = o.a.x;\n\t\t\tdouble y3 = o.a.y;\n\t\t\tdouble x4 = o.b.x;\n\t\t\tdouble y4 = o.b.y;\n\t\t\tdouble denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\t\t\t  double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3))/denom;\n\t\t\t  double ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3))/denom;\n\t\t\t    if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {\n\t\t\t        return new Point((int) (x1 + ua*(x2 - x1)), (int) (y1 + ua*(y2 - y1)));\n\t\t\t    }\n\n\t\t\t  return null;\n\t\t}\n\t}\n\tpublic static class FastIO {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastIO() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\tpublic static long pow(long n, long p, long mod) {\n\t\tif (p == 0)\n\t\t\treturn 1;\n\t\tif (p == 1)\n\t\t\treturn n % mod;\n\t\tif (p % 2 == 0) {\n\t\t\tlong temp = pow(n, p / 2, mod);\n\t\t\treturn (temp * temp) % mod;\n\t\t} else {\n\t\t\tlong temp = pow(n, p / 2, mod);\n\t\t\ttemp = (temp * temp) % mod;\n\t\t\treturn (temp * n) % mod;\n\n\t\t}\n\t}\n\n\tpublic static long pow(long n, long p) {\n\t\tif (p == 0)\n\t\t\treturn 1;\n\t\tif (p == 1)\n\t\t\treturn n;\n\t\tif (p % 2 == 0) {\n\t\t\tlong temp = pow(n, p / 2);\n\t\t\treturn (temp * temp);\n\t\t} else {\n\t\t\tlong temp = pow(n, p / 2);\n\t\t\ttemp = (temp * temp);\n\t\t\treturn (temp * n);\n\n\t\t}\n\t}\n\n\tpublic static long gcd(long x, long y) {\n\t\tif (x == 0)\n\t\t\treturn y;\n\t\telse\n\t\t\treturn gcd(y % x, x);\n\t}\n\n\tpublic static boolean isPrime(int n) {\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\n\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\treturn false;\n\n\t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\n\t\treturn true;\n\t}\n}\n", "complexity": "constant", "problem": "0994_C", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.*;\nimport java.util.Map.Entry;\n\nimport java.math.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic int[][] to = { { 1, 0 }, { 0, 1 }, { -1, 0 }, { 0, -1 } };\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tInputReader in = new InputReader(System.in);\n\t\t// Scanner in = new Scanner(System.in);\n\t\t// Scanner in = new Scanner(new BufferedReader(new\n\t\t// InputStreamReader(System.in)));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t// InputReader in = new InputReader(new\n\t\t// File(\"ethan_traverses_a_tree.txt\"));\n\t\t// PrintWriter out = new PrintWriter(new\n\t\t// File(\"ethan_traverses_a_tree-output.txt\"));\n\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint k = in.nextInt();\n\n\t\tint[][][] cost = new int[n][m][4];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m - 1; j++) {\n\t\t\t\tint u = in.nextInt();\n\t\t\t\tcost[i][j][1] = u;\n\t\t\t\tcost[i][j + 1][3] = u;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tint u = in.nextInt();\n\t\t\t\tcost[i][j][0] = u;\n\t\t\t\tcost[i + 1][j][2] = u;\n\t\t\t}\n\t\t}\n\n\t\tif (k % 2 == 0) {\n\t\t\tk = k / 2;\n\t\t\tint[][][] dp = new int[k + 1][n][m];\n\n\t\t\tfor (int i = 0; i <= k; i++) {\n\t\t\t\tfor (int x = 0; x < n; x++) {\n\t\t\t\t\tfor (int y = 0; y < m; y++) {\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\tdp[i][x][y] = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint min = 1000000000;\n\n\t\t\t\t\t\t\tfor (int way = 0; way < to.length; way++) {\n\t\t\t\t\t\t\t\tint nextx = x + to[way][0];\n\t\t\t\t\t\t\t\tint nexty = y + to[way][1];\n\n\t\t\t\t\t\t\t\tif (nextx >= 0 && nextx < n && nexty >= 0 && nexty < m) {\n\t\t\t\t\t\t\t\t\tmin = Math.min(min, dp[i - 1][nextx][nexty] + cost[x][y][way]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdp[i][x][y] = min;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (j == m - 1) {\n\t\t\t\t\t\tout.printf(\"%d\\n\", dp[k][i][j] * 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.printf(\"%d \", dp[k][i][j] * 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (j == m - 1) {\n\t\t\t\t\t\tout.printf(\"-1\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.printf(\"-1 \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.close();\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic InputReader(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.math.*;\n\npublic class E1 {\n\tstatic byte[] buf = new byte[1<<26];\n    static int bp = -1;\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t/**/\n\t\tDataInputStream in = new DataInputStream(System.in);\n\t\t/*/\n\t\tDataInputStream in = new DataInputStream(new FileInputStream(\"src/e.in\"));\n\t\t/**/\n\t\t\n\t\tin.read(buf, 0, 1<<26);\n\t\tint t = nni();\n\t\tfor (int z = 0; z < t; z++) {\n\t\t\tint n = nni();\n\t\t\tint m = nni();\n\t\t\tint[][] mat = new int[n][m];\n\t\t\tint[] rmax = new int[n];\n\t\t\tint tot = 0;\n\t\t\tHashSet<Integer> care = new HashSet<>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tPriorityQueue<Integer> cols = new PriorityQueue<>();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tmat[i][j] = nni();\n\t\t\t\t\tcols.add(-(mat[i][j]*2000+j));\n\t\t\t\t\trmax[i] = Math.max(rmax[i], mat[i][j]);\n\t\t\t\t}\n\t\t\t\ttot += rmax[i];\n\t\t\t\tfor (int j = 0; j < Math.min(m, n); j++)\n\t\t\t\t\tcare.add((-cols.poll())%2000);\n\t\t\t}\n\t\t\tList<Integer> cal = care.stream().sorted().collect(Collectors.toList());\n\t\t\tint ret = tot;\n\t\t\tif (Math.min(m, n)==1) {\n\t\t\t\tSystem.out.println(ret);\n\t\t\t} else if (Math.min(m, n)==2) {\n\t\t\t\tfor (int a = 0; a < cal.size(); a++) {\n\t\t\t\t\tint la = cal.get(a);\n\t\t\t\t\tfor (int d = 0; d < cal.size(); d++) {\n\t\t\t\t\t\tif (d==a)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint ld = cal.get(d);\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\tint tret = 0;\n\t\t\t\t\t\t\tfor (int x = 0; x < n; x++) {\n\t\t\t\t\t\t\t\ttret += Math.max(mat[x][ld], mat[(i+x)%n][la]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = Math.max(ret, tret);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ret);\n\t\t\t} else if (Math.min(m, n)==3) {\n\t\t\t\tfor (int a = 0; a < cal.size(); a++) {\n\t\t\t\t\tint la = cal.get(a);\n\t\t\t\t\tfor (int b = a+1; b < cal.size(); b++) {\n\t\t\t\t\t\tint lb = cal.get(b);\n\t\t\t\t\t\tfor (int d = 0; d < cal.size(); d++) {\n\t\t\t\t\t\t\tif (d==a)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif (d==b)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tint ld = cal.get(d);\n\t\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\t\tint tret = 0;\n\t\t\t\t\t\t\t\t\tfor (int x = 0; x < n; x++) {\n\t\t\t\t\t\t\t\t\t\ttret += Math.max(mat[x][ld], Math.max(mat[(i+x)%n][la], mat[(j+x)%n][lb]));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tret = Math.max(ret, tret);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ret);\n\t\t\t} else if (Math.min(m, n)==4) {\n\t\t\t\tfor (int a = 0; a < cal.size(); a++) {\n\t\t\t\t\tint la = cal.get(a);\n\t\t\t\t\tfor (int b = a+1; b < cal.size(); b++) {\n\t\t\t\t\t\tint lb = cal.get(b);\n\t\t\t\t\t\tfor (int c = b+1; c < cal.size(); c++) {\n\t\t\t\t\t\t\tint lc = cal.get(c);\n\t\t\t\t\t\t\tfor (int d = 0; d < cal.size(); d++) {\n\t\t\t\t\t\t\t\tif (d==a)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif (d==b)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif (d==c)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tint ld = cal.get(d);\n\t\t\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\t\t\t\t\t\tint tret = 0;\n\t\t\t\t\t\t\t\t\t\t\tfor (int x = 0; x < n; x++) {\n\t\t\t\t\t\t\t\t\t\t\t\ttret += Math.max(mat[x][ld], Math.max(mat[(i+x)%n][la], Math.max(mat[(j+x)%n][lb], mat[(k+x)%n][lc])));\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tret = Math.max(ret, tret);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ret);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static int nni() {\n        int ret = 0;\n        byte b = buf[++bp];\n        while (true) {\n            ret = ret*10+b-'0';\n            b = buf[++bp];\n            if (b<'0'||b>'9') {\n            \twhile (buf[bp+1]=='\\r'||buf[bp+1]=='\\n'||buf[bp+1]==' ') {++bp;}\n            \tbreak;\n            }\n        }\n        return ret;\n    }\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "//package round584;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class E4 {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\t\n\tvoid solve()\n\t{\n\t\tfor(int T = ni(); T> 0;T--){\n\t\t\tint n = ni(), m = ni();\n\t\t\tint[][] a = new int[n][];\n\t\t\tfor(int i = 0;i < n;i++)a[i] = na(m);\n\t\t\t\n\t\t\tint[][] mx = new int[m][];\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tint u = 0;\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tu = Math.max(u, a[j][i]);\n\t\t\t\t}\n\t\t\t\tmx[i] = new int[]{u, i};\n\t\t\t}\n\t\t\tArrays.sort(mx, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\t\treturn -(a[0] - b[0]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tint[] dp = new int[1<<n];\n\t\t\tfor(int i = 0;i < n && i < m;i++){\n\t\t\t\tint c = mx[i][1];\n\t\t\t\tint[] ls = new int[1<<n];\n\t\t\t\tfor(int j = 1;j < 1<<n;j++){\n\t\t\t\t\tls[j] = ls[j&j-1] + a[Integer.numberOfTrailingZeros(j)][c];\n\t\t\t\t}\n\t\t\t\tfor(int j = 1;j < 1<<n;j++){\n\t\t\t\t\tint r = rot(j, n);\n\t\t\t\t\tls[r] = Math.max(ls[r], ls[j]);\n\t\t\t\t}\n\t\t\t\tint[] ndp = new int[1<<n];\n\t\t\t\tfor(int j = 0;j < 1<<n;j++){\n\t\t\t\t\tif(rot(j, n) == j){\n\t\t\t\t\t\tint cur = j;\n\t\t\t\t\t\tfor(int sh = 0;sh < n;sh++){\n\t\t\t\t\t\t\tcur = cur>>1|(cur&1)<<n-1;\n\t\t\t\t\t\t\tint mask = (1<<n)-1^cur;\n\t\t\t\t\t\t\tfor(int k = mask;k >= 0;k--){\n\t\t\t\t\t\t\t\tk &= mask;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tndp[k|cur] = Math.max(\n\t\t\t\t\t\t\t\t\t\tndp[k|cur], dp[k] + ls[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp = ndp;\n\t\t\t}\n\t\t\tout.println(dp[(1<<n)-1]);\n\t\t}\n\t}\n\t\n\tint rot(int x, int n)\n\t{\n\t\tint ret = x;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tx = x>>>1|(x&1)<<n-1;\n\t\t\t\tret = Math.min(ret, x);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n//\t\tint n = 12, m = 2000;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(40 + \" \");\n//\t\tfor(int rep = 0;rep < 40;rep++){\n//\t\t\tsb.append(n + \" \");\n//\t\t\tsb.append(m + \" \");\n//\t\t\tfor (int i = 0; i < n*m; i++) {\n//\t\t\t\tsb.append(gen.nextInt(100000) + \" \");\n//\t\t\t}\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\t\t\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new E4().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.io.BufferedWriter;\n\nimport java.util.InputMismatchException;\n\nimport java.io.InputStream;\n\nimport java.util.NoSuchElementException;\n\nimport java.io.OutputStreamWriter;\n\nimport java.math.BigInteger;\n\nimport java.io.OutputStream;\n\nimport java.io.PrintWriter;\n\nimport java.io.Writer;\n\nimport java.io.IOException;\n\n\n\n/**\n\n * Built using CHelper plug-in\n\n * Actual solution is at the top\n\n * @author ashiqmostofa\n\n */\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        InputStream inputStream = System.in;\n\n        OutputStream outputStream = System.out;\n\n        InputReader in = new InputReader(inputStream);\n\n        OutputWriter out = new OutputWriter(outputStream);\n\n        TaskD solver = new TaskD();\n\n        solver.solve(1, in, out);\n\n        out.close();\n\n    }\n\n}\n\n\n\nclass TaskD {\n\n    long a,b;\n\n\n\n\n\n\n\n\n\n\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n        a=in.readLong();\n\n        b=in.readLong();\n\n\n\n\n\n        long tem=b-a;\n\n        long cur=1;\n\n        long pos=0;\n\n        long ans=0;\n\n\n\n        while(tem>=cur) {\n\n            ans+=cur;\n\n            cur*=2;\n\n            pos++;\n\n        }\n\n        while(b>=cur) {\n\n            if((b&(1L<<pos))!=(a&(1L<<pos)))ans+=(1L<<pos);\n\n            cur*=2;\n\n            pos++;\n\n        }\n\n\n\n        out.print(ans);\n\n\n\n\n\n    }\n\n}\n\n\n\nclass InputReader {\n\n\n\n    private InputStream stream;\n\n    private byte[] buf = new byte[1024];\n\n    private int curChar;\n\n    private int numChars;\n\n    private SpaceCharFilter filter;\n\n\n\n    public InputReader(InputStream stream) {\n\n        this.stream = stream;\n\n    }\n\n\n\n    public int read() {\n\n        if (numChars == -1)\n\n            throw new InputMismatchException();\n\n        if (curChar >= numChars) {\n\n            curChar = 0;\n\n            try {\n\n                numChars = stream.read(buf);\n\n            } catch (IOException e) {\n\n                throw new InputMismatchException();\n\n            }\n\n            if (numChars <= 0)\n\n                return -1;\n\n        }\n\n        return buf[curChar++];\n\n    }\n\n\n\n    public long readLong() {\n\n        int c = read();\n\n        while (isSpaceChar(c))\n\n            c = read();\n\n        int sgn = 1;\n\n        if (c == '-') {\n\n            sgn = -1;\n\n            c = read();\n\n        }\n\n        long res = 0;\n\n        do {\n\n            if (c < '0' || c > '9')\n\n                throw new InputMismatchException();\n\n            res *= 10;\n\n            res += c - '0';\n\n            c = read();\n\n        } while (!isSpaceChar(c));\n\n        return res * sgn;\n\n    }\n\n\n\n    public boolean isSpaceChar(int c) {\n\n        if (filter != null)\n\n            return filter.isSpaceChar(c);\n\n        return isWhitespace(c);\n\n    }\n\n\n\n    public static boolean isWhitespace(int c) {\n\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\n    }\n\n\n\n    public interface SpaceCharFilter {\n\n        public boolean isSpaceChar(int ch);\n\n    }\n\n}\n\n\n\nclass OutputWriter {\n\n    private final PrintWriter writer;\n\n\n\n    public OutputWriter(OutputStream outputStream) {\n\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\n    }\n\n\n\n    public void close() {\n\n        writer.close();\n\n    }\n\n\n\n    public void print(long i) {\n\n        writer.print(i);\n\n    }\n\n\n\n}", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D {\n\tstatic byte[] buf = new byte[1<<26];\n    static int bp = -1;\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t/**/\n\t\tDataInputStream in = new DataInputStream(System.in);\n\t\t/*/\n\t\tDataInputStream in = new DataInputStream(new FileInputStream(\"src/d.in\"));\n\t\t/**/\n\t\t\n\t\tin.read(buf, 0, 1<<26);\n\t\t\n\t\tint n = nni();\n\t\tint m = nni();\n\t\tint k = nni();\n\t\t\n\t\tif (k%2==1) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tStringBuilder ans = new StringBuilder();\n\t\t\t\tString sp = \"\";\n\t\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\t\tans.append(sp+\"-1\");\n\t\t\t\t\tsp = \" \";\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint[][] lr = new int[n][m-1];\n\t\tint[][] ud = new int[n-1][m];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < m-1; ++j) {\n\t\t\t\tlr[i][j] = nni();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n-1; ++i) {\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tud[i][j] = nni();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][][] ans = new int[k/2+1][n][m];\n\t\t\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tfor (int q = 1; q <= k/2; ++q) {\n\t\t\t\t\tans[q][i][j] = 123456789;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int uq = 0; uq < k/2; ++uq) {\n\t\t\tfor (int ui = 0; ui < n; ++ui) {\n\t\t\t\tfor (int uj = 0; uj < m; ++uj) {\n\t\t\t\t\tint w = ans[uq][ui][uj];\n\t\t\t\t\tif (ui>0 && w+ud[ui-1][uj]<ans[uq+1][ui-1][uj]) {\n\t\t\t\t\t\tans[uq+1][ui-1][uj] = w+ud[ui-1][uj];\n\t\t\t\t\t}\n\t\t\t\t\tif (ui<n-1 && w+ud[ui][uj]<ans[uq+1][ui+1][uj]) {\n\t\t\t\t\t\tans[uq+1][ui+1][uj] = w+ud[ui][uj];\n\t\t\t\t\t}\n\t\t\t\t\tif (uj>0 && w+lr[ui][uj-1]<ans[uq+1][ui][uj-1]) {\n\t\t\t\t\t\tans[uq+1][ui][uj-1] = w+lr[ui][uj-1];\n\t\t\t\t\t}\n\t\t\t\t\tif (uj<m-1 && w+lr[ui][uj]<ans[uq+1][ui][uj+1]) {\n\t\t\t\t\t\tans[uq+1][ui][uj+1] = w+lr[ui][uj];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tStringBuilder as = new StringBuilder();\n\t\t\tString sp = \"\";\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tas.append(sp+ans[k/2][i][j]*2);\n\t\t\t\tsp = \" \";\n\t\t\t}\n\t\t\tSystem.out.println(as);\n\t\t}\n\t}\n\t\n\tpublic static int nni() {\n        int ret = 0;\n        byte b = buf[++bp];\n        while (true) {\n            ret = ret*10+b-'0';\n            b = buf[++bp];\n            if (b<'0'||b>'9') {\n            \twhile (buf[bp+1]=='\\r'||buf[bp+1]=='\\n'||buf[bp+1]==' ') {++bp;}\n            \tbreak;\n            }\n        }\n        return ret;\n    }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Round111ProbA {\n\n    \n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        \n        int n = in.nextInt();\n        int[]a = new int[n];\n        int s =0;\n        for(int i =0 ; i < n;i++)\n        {\n            a[i] = in.nextInt();\n            s += a[i];\n        }\n        Arrays.sort(a);\n        int x =0;\n        int c =0;\n        for(int i =n-1 ; i >-1;i-- )\n        {\n            x +=a[i];\n            s -= a[i];\n            c++;\n            if(x > s)break;\n        }\n        System.out.println(c);\n    }\n    \n}\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Handbag\n{\n\t// http://codeforces.com/problemset/problem/8/C\t\n\t// Source of most code : http://codeforces.com/contest/8/submission/3492661\n\t\n\t// Keep track of each item location and also be able to \n\t// calculate distance between it and another object\n\tpublic static class Item{\n\t\tint x;\n\t\tint y;\n\t\t\n\t\tItem(int x, int y){\n\t\t\tthis.x = x; \n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\t// Return distance between two points\n\t\tpublic int dist(Item i){\n\t\t\tint dx = x - i.x;\n\t\t\tint dy = y - i.y;\n\t\t\treturn dx*dx + dy*dy;\n\t\t}\n\t}\n\t\n\t// Each value in bits[] is the min time to get certain objects\n    // Ex. bits[6] = 110 is the fastest time to get items that correspond with the '1s'\n\tpublic static int solve(int bitNum){\n\t\t\n\t\tif(bitNum == (1 << N) - 1) // If bitNum is too big for the array\n\t\t\treturn 0;\n\t\t\n\t\tif(bits[bitNum] != -1) // If bit value has already been calculated\n\t\t\treturn bits[bitNum];\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint j = 0;\n\t\tfor(int i = 1; i < N; i++){\n\t\t\t\n\t\t\tif((bitNum & (1 << i)) == 0){ // Performs bitwise AND operation to see if bitNum and i have no bits in common\n\t\t\t\t\n\t\t\t\tif(j == 0){ // Only happens on the first time in IF statement\n\t\t\t\t\t// One item that can be picked up before returning to handbag\n\t\t\t\t\tans = 2 * items[0].dist(items[i]) + solve(bitNum | (1 << i)); // Performs bitwise exclusive OR operation\n\t\t\t\t\tj = i; // Change value so this case isn't ever hit again && to store value to use in else statement dists\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// Find the distance between the handbag and the first item\n\t\t\t\t\tint dist1 = items[0].dist(items[i]);\n\t\t\t\t\t// Find the distance between the first item and the second item\n\t\t\t\t\tint dist2 = items[i].dist(items[j]);\n\t\t\t\t\t// Find the distance between the second item and the handbag\n\t\t\t\t\tint dist3 = items[j].dist(items[0]);\n\t\t\t\t\t\n\t\t\t\t\t// Two items that can be picked up before returning to handbag\n\t\t\t\t\t// distance covered between any two objects in the time equal \n\t\t\t\t\t// to the squared length of the segment between the points of the objects\n\t\t\t\t\tans = Math.min(ans, dist1 + dist2 + dist3 + solve(bitNum | (1 << i) | (1 << j))); // Performs bitwise exclusive OR operation\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bits[bitNum] = ans; // Store all values in bits[] to speed up solve and for use in printOptPath\n\t}\n\t\n\tstatic void printOptPath(int bitNum) {\n\t\tif (bitNum == (1 << N) - 1)\n\t\t\treturn;\n\t\t\n\t\t// Almost identical to solve equation except it doesn't calculate the answer, it checks the stored answer in bits \n\t\tint j = 0;\n\t\tfor (int i = 1; i < N; i++)\n\t\t\t\n\t\t\tif ((bitNum & (1 << i)) == 0) {\t\t\t\t\n\t\t\t\tif (j == 0) {\t\t\t\t\t\n\t\t\t\t\tj = i; // Change value so this case isn't ever hit again && to find distance to this specific item in else if statement\n\t\t\t\t\tif (bits[bitNum] == 2 * items[0].dist(items[i]) + solve(bitNum | (1 << i))) { // solve() should quickly return an answer because the bits[] has already been calculated\t\t\t\t\t\t\n\t\t\t\t\t\tpw.print(\" \" + i + \" 0\"); // One item that can be picked up before returning to handbag\n\t\t\t\t\t\tprintOptPath(bitNum | (1 << i)); // Recursively call print with new bitNum\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\telse if (bits[bitNum] == \n\t\t\t\t\t\t\t\titems[0].dist(items[i]) + items[i].dist(items[j]) + items[j].dist(items[0]) + solve(bitNum | (1 << i) | (1 << j))) {\n\t\t\t\t\t\n\t\t\t\t\tpw.print(\" \" + j + \" \" + i + \" 0\"); // Two items that can be picked up before returning to handbag\n\t\t\t\t\tprintOptPath(bitNum | (1 << i) | (1 << j)); // Recursively call print with new bitNum\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\n\tprivate static int N = 0;\n\tprivate static Item[] items;\n\tprivate static int[] bits;\n\t\n\t// PrintWriter needs to be class member because of recursive print strategy\n\tprivate static PrintWriter pw = new PrintWriter(System.out);\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\n\t\t\n\t\tString[] input = br.readLine().split(\" \");\n\t\tItem handbag = new Item(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\t\t\n\t\tN = Integer.parseInt(br.readLine()) + 1;\n\t\titems = new Item[N];\n\t\tfor(int n = 1; n < N; n++){\n\t\t\tinput = br.readLine().split(\" \");\n\t\t\titems[n] = new Item(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\t\t}\t\t\n\t\titems[0] = handbag;\n\t\t\n\t\t// x << n is a right shift operator \n\t\t// which will remove the last n bits from x\n\t\t// Ex 1 << 2 => 4\n\t\tbits = new int[1 << N]; // Ex: 1 << 3 = 8; 1 << 5 = 64\n\t\tArrays.fill(bits, -1); // Init bits array to hold -1 values\n\t\t\n\t\tint ans = solve(1 << 0); // Start solving with bit #1\n\t\tpw.println(ans); // Min time needed to put items in handbag\n\t\t\n\t\tpw.print(\"0\"); // Init output with handbag location\n\t\tprintOptPath(1 << 0); // Print possible optimum path to pick up items\n\t\t\n\t\tpw.close();\n\t}\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.lang.*;\nimport java.math.*;\n \npublic class Main{\n\t\n\tstatic ArrayList a[]=new ArrayList[200001];\n\tstatic int Count(int a[][],int n) {\n\t\tdsu d=new dsu(n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tif(a[i][j]==0) {\n\t\t\t\t\td.union(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tboolean chk[]=new boolean [n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint p=d.root(i);\n\t\t\tif(!chk[p]) {\n\t\t\t\tchk[p]=true;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t    return cnt;\n\t}\n\tpublic void solve () {\n\t\tInputReader in = new InputReader(System.in);\n\t    PrintWriter pw = new PrintWriter(System.out); \n\t    int n=in.nextInt();\n\t    int a=in.nextInt();\n\t    int b=in.nextInt();\n\t    if(a==1 || b==1) {\n\t    \tint ans[][]=new int [n][n];\n\t    \tint temp=(a==1)?b:a;\n\t    \tfor(int i=1;i<=n-temp;i++) {\n\t    \t\tans[i][i-1]=1;\n\t    \t\tans[i-1][i]=1;\n\t    \t}\n\t    \tint freq=Count(ans,n);\n\t    \tif(freq!=1) {\n\t    \t\tpw.println(\"NO\");\n\t    \t}\n\t    \telse {\n\t    \t\tpw.println(\"YES\");\n\t    \t\tfor(int i=0;i<n;i++) {\n\t    \t\t\tfor(int j=0;j<n;j++) {\n\t    \t\t\t\tif(i==j) {\n\t    \t\t\t\t\tpw.print(0);\n\t    \t\t\t\t}\n\t    \t\t\t\telse\n\t    \t\t\t\t\tpw.print((ans[i][j]+((temp==b)?1:0))%2);\n\t    \t\t\t}\n\t    \t\t\tpw.println();\n\t    \t\t}\n\t    \t}\n\t    }\n\t    else {\n\t    \tpw.print(\"NO\");\n\t    }\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\tpublic static void main(String[] args) throws Exception {\n        \n        \n        new Thread(null,new Runnable() {\n        \tpublic void run() {\n        \t\tnew Main().solve();\n        \t}\n        },\"1\",1<<26).start();\n        \n        \n    }\n    static void debug(Object... o) {\n    \tSystem.out.println(Arrays.deepToString(o));\n        }\n        \n        static class InputReader \n        {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) \n        {\n            this.stream = stream;\n        }\n        public int snext() \n        {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) \n            {\n                curChar = 0;\n                try \n                {\n                    snumChars = stream.read(buf);\n                } \n                catch (IOException e) \n                {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public int nextInt() \n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public long nextLong()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') \n            {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public int[] nextIntArray(int n) \n        {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) \n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n \n        public String readString()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n \n        public String nextLine() \n        {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n \n        public boolean isSpaceChar(int c) \n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        private boolean isEndOfLine(int c) \n        {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n        public static long mod = 1000000007;\n        public static int d;\n        public static int p;\n        public static int q;\n        public void extended(int a,int b) {\n        \tif(b==0) {\n        \t\td=a;\n        \t\tp=1;\n        \t\tq=0;\n        \t}\n        \telse\n        \t{\n        \t\textended(b,a%b);\n        \t\tint temp=p;\n        \t\tp=q;\n        \t\tq=temp-(a/b)*q;\n        \t}\n        }\n        public static long[] shuffle(long[] a,Random gen)\n        {\n            int n = a.length;\n            for(int i=0;i<n;i++)\n            {\n                int ind = gen.nextInt(n-i)+i;\n                long temp = a[ind];\n                a[ind] = a[i];\n                a[i] = temp;\n            }\n            return a;\n        }\n        \n        public static void swap(int a, int b){\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        public static HashSet<Integer> primeFactorization(int n)\n        {\n            HashSet<Integer> a =new HashSet<Integer>();\n            for(int i=2;i*i<=n;i++)\n            {\n                while(n%i==0)\n                {\n                    a.add(i);\n                    n/=i;\n                }\n            }\n            if(n!=1)\n                a.add(n);\n            return a;\n        }\n        \n        public static void sieve(boolean[] isPrime,int n)\n        {\n            for(int i=1;i<n;i++)\n                isPrime[i] = true;\n            \n            isPrime[0] = false;\n            isPrime[1] = false;\n            \n            for(int i=2;i*i<n;i++)\n            {\n                if(isPrime[i] == true)\n                {\n                    for(int j=(2*i);j<n;j+=i)\n                        isPrime[j] = false;\n                }\n            }\n        }\n        \n        public static int GCD(int a,int b)\n        {\n            if(b==0)\n                return a;\n            else\n                return GCD(b,a%b);\n        }\n        \n        static class pair implements Comparable<pair>\n        {\n            Integer x;\n            Long y;\n            pair(int x,long y)\n            {\n                this.x=x;\n                this.y=y;\n                \n            }\n            \n           \n            public int compareTo(pair o) {\n                int result = x.compareTo(o.x);\n                if(result==0)\n                    result = y.compareTo(o.y);\n                \n                return result;\n            }  \n            \n            public String toString()\n            {\n                return x+\" \"+y;\n            }\n            \n            public boolean equals(Object o)\n            {\n                if (o instanceof pair)\n                {\n                    pair p = (pair)o;\n                    return p.x == x && p.y == y ;\n                }\n                return false;\n            }\n            \n            public int hashCode()\n            {\n                return new Long(x).hashCode()*31 + new Long(y).hashCode();\n            }\n        }\n        \n    \n}\nclass pair implements Comparable<pair>\n{\n    Integer x;\n    Long y;\n    pair(int x,long y)\n    {\n        this.x=x;\n        this.y=y;\n        \n    }\n    \n   \n    public int compareTo(pair o) {\n        int result = x.compareTo(o.x);\n        if(result==0)\n            result = y.compareTo(o.y);\n        \n        return result;\n    }  \n    \n    public String toString()\n    {\n        return x+\" \"+y;\n    }\n    \n    public boolean equals(Object o)\n    {\n        if (o instanceof pair)\n        {\n            pair p = (pair)o;\n            return p.x == x && p.y == y ;\n        }\n        return false;\n    }\n    \n    public int hashCode()\n    {\n        return new Long(x).hashCode()*31 + new Long(y).hashCode();\n    }\n}\nclass dsu{\n\tint parent[];\n\tdsu(int n){\n\t\tparent=new int[n+1];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tparent[i]=i;\n\t\t}\n\t}\n\tint root(int n) {\n\t\twhile(parent[n]!=n)\n\t\t{ \n\t\t\tparent[n]=parent[parent[n]];\n\t\t\tn=parent[n];\n\t\t}\n\t\treturn n;\n\t}\n\tvoid union(int _a,int _b) {\n\t\tint p_a=root(_a);\n\t\tint p_b=root(_b);\n\t\t\n\t\t\tparent[p_a]=p_b;\n\t\t\n\t\t\t\n\t}\n\tboolean find(int a,int b) {\n\t\tif(root(a)==root(b))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn  false;\n\t}\n\t\n\t\n}\n", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class LookingForOrder {\n    private int[][] distance;\n    private int[] dp;\n    private int[] prev;\n\n    public static void main(String[] args) throws IOException {\n        new LookingForOrder().solve();\n    }\n\n    public void solve() throws IOException {\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(f.readLine());\n        int x = Integer.parseInt(tokenizer.nextToken());\n        int y = Integer.parseInt(tokenizer.nextToken());\n        int n = Integer.parseInt(f.readLine());\n        int[][] coords = new int[n + 1][2];\n        coords[0][0] = x;\n        coords[0][1] = y;\n        for (int i = 1; i <= n; i++) {\n            tokenizer = new StringTokenizer(f.readLine());\n            x = Integer.parseInt(tokenizer.nextToken());\n            y = Integer.parseInt(tokenizer.nextToken());\n            coords[i][0] = x;\n            coords[i][1] = y;\n        }\n\n        this.distance = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= n; j++) {\n                distance[i][j] += (coords[i][0] - coords[j][0]) * (coords[i][0] - coords[j][0]);\n                distance[i][j] += (coords[i][1] - coords[j][1]) * (coords[i][1] - coords[j][1]);\n            }\n        }\n\n        int lastSet = 1 << n;\n        this.prev = new int[lastSet];\n\n        this.dp = new int[lastSet];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        this.dp[0] = 0;\n       // this.getMinPath(lastSet);\n\n        for (int i = 1; i < lastSet; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) != 0 && this.dp[i ^ (1 << j)] + distance[0][j + 1] * 2 < this.dp[i]) {\n                    //System.out.println(Integer.toBinaryString(i) + \" \" + Integer.toBinaryString(j) + \" \" + this.dp[i ^ (1 << j)]);\n                    this.dp[i] = this.dp[i ^ (1 << j)] + distance[0][j + 1] * 2;\n                    this.prev[i] = i ^ (1 << j);\n                }\n            }\n            //System.out.println(this.dp[i]);\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) != 0) {\n                    for (int k = j + 1; k < n; k++) {\n                        if ((i & (1 << k)) != 0) {\n                           // System.out.println(i + \" \" + j + \" \" + (i ^ (1 << j) ^ (1 << k)));\n                            if (this.dp[i ^ (1 << j) ^ (1 << k)] + this.distance[0][j + 1] + this.distance[0][k + 1] + this.distance[j + 1][k + 1] < this.dp[i]) {\n                                this.dp[i] = this.dp[i ^ (1 << j) ^ (1 << k)] + this.distance[0][j + 1] + this.distance[0][k + 1] + this.distance[j + 1][k + 1];\n                                this.prev[i] = i ^ (1 << j) ^ (1 << k);\n                            }\n                        }\n                    }\n\n                    break;\n                }\n            }\n          //  System.out.println(this.dp[i]);\n        }\n\n        lastSet--;\n        PrintWriter out = new PrintWriter(System.out);\n        out.println(dp[lastSet]);\n        ArrayDeque<Integer> stack = new ArrayDeque<Integer>();\n        boolean started = false;\n        while (lastSet != 0) {\n            // System.out.println(lastSet);\n            stack.addFirst(0);\n            int diff = lastSet - prev[lastSet];\n            //System.out.println(diff);\n            for (int i = 1, j = 1; j <= n; j++, i *= 2) {\n                if ((diff & i) != 0) {\n                    stack.addFirst(j);\n                }\n            }\n\n            lastSet = this.prev[lastSet];\n        }\n        stack.addFirst(0);\n\n        while (!stack.isEmpty()) {\n            if (!started) {\n                out.print(stack.pop());\n                started = true;\n            } else {\n                out.print(\" \");\n                out.print(stack.pop());\n            }\n        }\n\n        out.println();\n        out.close();\n    }\n\n    /*\n    private int getMinPath(int set) {\n        if (this.dp[set] != Integer.MAX_VALUE) {\n            return this.dp[set];\n        }\n\n        for (int i = 1, j = 1; i < this.dp.length; i *= 2, j++) {\n            if ((set & i) == i) {\n                int subPath;\n                int possibleMin = getMinPath(set & (set - i)) + (this.distance[0][j] * 2);\n                if (possibleMin < this.dp[set]) {\n                    this.dp[set] = possibleMin;\n                    this.prev[set] = set - i;\n                }\n            }\n        }\n        for (int i0 = 1, j0 = 1; i0 < this.dp.length; i0 *= 2, j0++) {\n            if ((set & i0) == i0) {\n                for (int i1 = i0 * 2, j1 = j0 + 1; i1 < this.dp.length; i1 *= 2, j1++) {\n                    if ((set & i1) == i1) {\n                        //System.out.println(set + \" \" + (set & (set - i0 - i1)));\n                        int possibleMin = getMinPath(set & (set - i0 - i1)) + this.distance[0][j0] + this.distance[0][j1] + this.distance[j0][j1];\n                        if (possibleMin < this.dp[set]) {\n                            this.dp[set] = possibleMin;\n                            this.prev[set] = set - i0 - i1;\n                        }\n                    }\n                }\n                break;\n            }\n        }\n\n        // System.out.println(this.dp[set] + \" \" + Integer.toBinaryString(set));\n        return this.dp[set];\n    } */\n}", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class B {\n    static Scanner in; static int next() throws Exception {return in.nextInt();};\n//\tstatic StreamTokenizer in; static int next() throws Exception {in.nextToken(); return (int) in.nval;}\n//\tstatic BufferedReader in;\n    static PrintWriter out;\n\n    public static long count(long k, long x, long y, long n) {\n        long sum = 2*k*(k+1)+1;\n        if (k >= x-1) {\n            sum -= (k-x+1)*(k-x+1);\n        }\n        if (k >= y-1) {\n            sum -= (k-y+1)*(k-y+1);\n        }\n        if (k + x >= n) {\n            sum -= (k+x-n)*(k+x-n);\n        }\n        if (k + y >= n) {\n            sum -= (k+y-n)*(k+y-n);\n        }\n\n        if (k > x+y-1) {\n            sum += ((k+1-x-y)*(k+1-x-y+1))/2;\n        }\n\n        if (k > n-x+y) {\n            sum += ((k+x-n-y)*(k+x-n-y+1))/2;\n        }\n\n        if (k > n-y+x) {\n\n            sum += ((k+y-n-x)*(k+y-n-x+1))/2;\n        }\n\n        if (k > 2*n-x-y+1) {\n\n            sum += ((k-2*n+x+y-1)*(k-2*n+x+y))/2;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) throws Exception {\n        in = new Scanner(System.in);\n//\t\tin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n//\t\tin = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n\n        long n = in.nextLong(), x = in.nextLong(), y = in.nextLong(), c = in.nextLong();\n\n        long res = 0;\n        while (count(res, x, y, n) < c) res++;\n        out.println(res);\n\n\n        out.println();\n        out.close();\n    }\n}", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "import java.util.Scanner;\n\n//import java.util.Scanner;\n\n\n\n\npublic class SingleWildcard {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner input =new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tchar[] s1 =new char[a];\n\t\ts1 = input.next().toCharArray();\n\t\t\n\t\tchar[] s2 = new char[b];\n\t\ts2 = input.next().toCharArray();\n\t    boolean condition = false;\n\t    for(int i=0; i<a;i++){\n\t    \tif(s1[i]=='*'){\n\t    \t\tcondition= true;\n\t    \t\tbreak;\n\t    \t}\n\t    }\n\t   \n\t    if(!condition){\n\t    \tif(match(s1,s2)){\n\t    \t\tSystem.out.println(\"YES\");\n\t    \t\t\n\t    \t}\n\t    \telse\n\t    \t\tSystem.out.println(\"NO\");\n\t       return;\n\t    }\n\t    else{\n\t    \tint i=0;\n\t    \tif(s1.length-1>s2.length){\n\t    \t\tSystem.out.println(\"NO\");\n\t    \t\treturn;\n\t    \t}\n\t    \twhile(i<s1.length && i<s2.length && s1[i]==s2[i]){\n\t    \t\ti++;\n\t    \t}\n\t    \tint j=s2.length-1;\n\t    \tint k = s1.length-1;\n\t    \twhile(j>=0 && k>=0 &&  s1[k]==s2[j] && i<=j){\n\t    \t\tj--;\n\t    \t\tk--;\n\t    \t}\n\t    \t//System.out.println(i);\n\t    \tif(i==k && i>=0 && i<s1.length && s1[i]=='*' ){\n\t    \t\tSystem.out.println(\"YES\");\n\t    \t\treturn;\n\t    \t}\n\t    \tSystem.out.println(\"NO\");\n\t    }\n\t\t\n\t\t\n\t}\n\t\n\tstatic boolean match(char[] s1,char[] s2){\n\t\tif(s1.length!=s2.length)return false;\n\t\tfor(int i=0; i<s1.length;i++){\n\t\t\tif(s1[i]!=s2[i])return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\n}\n", "complexity": "linear", "problem": "1023_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "import java.util.*;\n\npublic class ehab4 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint a = 0, b = 0;\n\tSystem.out.println( \"? 0 0 \" );\n\tSystem.out.flush();\n\tint c = in.nextInt();\n\tfor ( int i = 29; i >= 0; i-- ) {\n\t    System.out.println( \"? \" + ( a + ( 1 << i ) ) + \" \" + b );\n\t    System.out.flush();\n\t    int q1 = in.nextInt();\n\t    System.out.println( \"? \" + a + \" \" + ( b + ( 1 << i ) ) );\n\t    System.out.flush();\n\t    int q2 = in.nextInt();\n\t    if ( q1 == q2 ) {\n\t\tif ( c == 1 )\n\t\t    a += ( 1 << i );\n\t\telse if ( c == -1 )\n\t\t    b += ( 1 << i );\n\t\tc = q1;\n\t    }\n\t    else if ( q1 == -1 ) {\n\t\ta += ( 1 << i );\n\t\tb += ( 1 << i );\n\t    }\n\t    else if ( q1 == -2 )\n\t\treturn;\n\t}\n\tSystem.out.println( \"! \" + a + \" \" + b );\n\tSystem.out.flush();\n    }\n}\n", "complexity": "logn", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static ArrayList<BigInteger> bs = new ArrayList<>();\n\n    static void getBs(int n, BigInteger k) {\n        BigInteger four = BigInteger.valueOf(4);\n        BigInteger tmp4 = BigInteger.valueOf(1);\n        BigInteger sum = BigInteger.ZERO;\n        for (int i = 1; i <= n; i++) {\n            sum = sum.add(tmp4);\n            bs.add(sum);\n            if (sum.compareTo(k) >= 0) break;\n            tmp4 = tmp4.multiply(four);\n        }\n    }\n\n    static int ss(int n, BigInteger k) {\n        bs = new ArrayList<>();\n        BigInteger two = BigInteger.valueOf(2);\n        BigInteger s1;\n        BigInteger ts = BigInteger.ZERO;\n        getBs(n - 1, k);\n        int idx = bs.size() - 1;\n        BigInteger tx = BigInteger.valueOf(-1);\n        int ans = -1;\n        for (int i = 1; i <= n; i++) {\n            two = two.shiftLeft(1);\n            s1 = two.add(BigInteger.valueOf(-i - 2));\n            if (idx >= 0) {\n                tx = tx.add(BigInteger.ONE).multiply(BigInteger.valueOf(2)).add(BigInteger.ONE);\n                ts = ts.add(tx.multiply(bs.get(idx--)));\n            }\n            if (k.compareTo(s1) >= 0) {\n                if (k.subtract(s1).compareTo(ts) <= 0) {\n                    ans = n - i;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int T = sc.nextInt();\n        while (T-- > 0) {\n            int n = sc.nextInt();\n            BigInteger k = sc.nextBigInteger();\n            int ans = ss(n, k);\n            if (ans == -1) {\n                System.out.println(\"NO\");\n            } else {\n                System.out.println(\"YES \" + ans);\n            }\n        }\n    }\n}", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class B {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t/**/\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\t/*/\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(\"src/b.in\"))));\n\t\t/**/\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint l1 = 1;\n\t\tint r1 = n;\n\t\tint b1 = 1;\n\t\tint t1 = n;\n\t\tint min = b1;\n\t\tint max = t1;\n\t\twhile (min != max) {\n\t\t\tint mid = (min+max)/2;\n\t\t\tSystem.out.println(\"? \"+l1+\" \"+b1+\" \"+r1+\" \"+mid);\n\t\t\tSystem.out.flush();\n\t\t\tif (sc.nextInt() >= 1)\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\tmin = mid+1;\n\t\t}\n\t\tt1 = min;\n\t\tmin = l1;\n\t\tmax = r1;\n\t\twhile (min != max) {\n\t\t\tint mid = (min+max)/2;\n\t\t\tSystem.out.println(\"? \"+l1+\" \"+b1+\" \"+mid+\" \"+t1);\n\t\t\tSystem.out.flush();\n\t\t\tif (sc.nextInt() >= 1)\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\tmin = mid+1;\n\t\t}\n\t\tr1 = min;\n\t\tmin = b1;\n\t\tmax = t1;\n\t\twhile (min != max) {\n\t\t\tint mid = (min+max+1)/2;\n\t\t\tSystem.out.println(\"? \"+l1+\" \"+mid+\" \"+r1+\" \"+t1);\n\t\t\tSystem.out.flush();\n\t\t\tif (sc.nextInt() >= 1)\n\t\t\t\tmin = mid;\n\t\t\telse\n\t\t\t\tmax = mid-1;\n\t\t}\n\t\tb1 = min;\n\t\tmin = l1;\n\t\tmax = r1;\n\t\twhile (min != max) {\n\t\t\tint mid = (min+max+1)/2;\n\t\t\tSystem.out.println(\"? \"+mid+\" \"+b1+\" \"+r1+\" \"+t1);\n\t\t\tSystem.out.flush();\n\t\t\tif (sc.nextInt() >= 1)\n\t\t\t\tmin = mid;\n\t\t\telse\n\t\t\t\tmax = mid-1;\n\t\t}\n\t\tl1 = min;\n\t\tint l2 = 1;\n\t\tint r2 = n;\n\t\tint b2 = 1;\n\t\tint t2 = n;\n\t\tmin = b2;\n\t\tmax = t2;\n\t\twhile (min != max) {\n\t\t\tint mid = (min+max+1)/2;\n\t\t\tSystem.out.println(\"? \"+l2+\" \"+mid+\" \"+r2+\" \"+t2);\n\t\t\tSystem.out.flush();\n\t\t\tif (sc.nextInt() >= 1)\n\t\t\t\tmin = mid;\n\t\t\telse\n\t\t\t\tmax = mid-1;\n\t\t}\n\t\tb2 = min;\n\t\tmin = l2;\n\t\tmax = r2;\n\t\twhile (min != max) {\n\t\t\tint mid = (min+max+1)/2;\n\t\t\tSystem.out.println(\"? \"+mid+\" \"+b2+\" \"+r2+\" \"+t2);\n\t\t\tSystem.out.flush();\n\t\t\tif (sc.nextInt() >= 1)\n\t\t\t\tmin = mid;\n\t\t\telse\n\t\t\t\tmax = mid-1;\n\t\t}\n\t\tl2 = min;\n\t\tmin = b2;\n\t\tmax = t2;\n\t\twhile (min != max) {\n\t\t\tint mid = (min+max)/2;\n\t\t\tSystem.out.println(\"? \"+l2+\" \"+b2+\" \"+r2+\" \"+mid);\n\t\t\tSystem.out.flush();\n\t\t\tif (sc.nextInt() >= 1)\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\tmin = mid+1;\n\t\t}\n\t\tt2 = min;\n\t\tmin = l2;\n\t\tmax = r2;\n\t\twhile (min != max) {\n\t\t\tint mid = (min+max)/2;\n\t\t\tSystem.out.println(\"? \"+l2+\" \"+b2+\" \"+mid+\" \"+t2);\n\t\t\tSystem.out.flush();\n\t\t\tif (sc.nextInt() >= 1)\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\tmin = mid+1;\n\t\t}\n\t\tr2 = min;\n\t\tSystem.out.println(\"! \"+l1+\" \"+b1+\" \"+r1+\" \"+t1+\" \"+l2+\" \"+b2+\" \"+r2+\" \"+t2);\n\t\tSystem.out.flush();\n\t}\n}", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * Date 22.11.2011\n * Time 17:49:45\n * Author Woodey\n * $\n */\n\npublic class A15 {\n\t\n\tfinal double eps = 10e-9;\n\t\n\tclass Pair implements Comparable<Pair>{\n\t\tint x;\n\t\tint length;\n\t\t\n\t\tPair(int x, int length) {\n\t\t\tthis.x = x;\n\t\t\tthis.length = length;\n\t\t}\n\n\t\tpublic int compareTo(Pair p) {\n\t\t\treturn x - p.x;\n\t\t}\n\t}\n\t\n\tprivate void Solution() throws IOException {\n\t\tint n = nextInt(), t = nextInt(), ans = 2;\n\t\tPair[] pairs = new Pair[n];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tint x = nextInt(), length = nextInt();\n\t\t\tpairs[i] = new Pair(x, length);\n\t\t}\n\t\tArrays.sort(pairs);\n\t\tfor (int i = 0; i < n-1; i ++) {\n\t\t\tdouble place = pairs[i+1].x - pairs[i].x - (double) pairs[i+1].length/2 - (double) pairs[i].length/2;\n\t\t\tif (place > t)\n\t\t\t\tans += 2; else\n\t\t\t\t\tif ((int) (place+eps) == t)\n\t\t\t\t\t\tans ++;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A15().run();\n\t}\n\n\tBufferedReader in;\n\tStringTokenizer tokenizer;\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\tSolution();\n\t\t\tin.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\ttokenizer = new StringTokenizer(in.readLine());\n\t\treturn tokenizer.nextToken();\n\t}\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        long num=in.nextLong();\n        long lcm=1;\n        if(num==2){\n            System.out.println(2);\n            System.exit(0);\n        }//End if\n        else if(num%2==0&&num%3!=0)\n            lcm=(num)*(num-1)*(num-3);\n        else if(num%2==0&&num%3==0)\n            lcm=(num-1)*(num-2)*(num-3);\n        else if(num%2!=0&&num>2)\n            lcm=num*(num-1)*(num-2);\n        System.out.println(lcm);\n    }//End main()\n}//End class\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class YouAreGivenAString {\n\n    void run() {\n        try {\n            BufferedReader bfd = new BufferedReader(new InputStreamReader(\n                    System.in));\n            int i, j, k, mxLen = 0;\n            String s= bfd.readLine();\n            for(i=0; i<s.length(); ++i){\n                for(j=i+1; j<s.length()+1; ++j){\n                    String s2 = s.substring(i, j);\n                    if(s2.length()<=mxLen) continue;\n                    int cnt=0;\n                    for(k=0; k<s.length(); ++k){\n                        if(s.length()>=k+s2.length())\n                        if(s2.equals(s.substring(k,k+s2.length()))){\n                            cnt++;\n                            if(cnt>1)mxLen = Math.max(mxLen, s2.length());\n                        }\n                    }\n                }\n            }\n            System.out.println(mxLen);\n        } catch (Exception e) {\n\n        }\n    }\n    public static void main(String[] args) {\n        new YouAreGivenAString().run();\n    }\n\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A{\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tpublic void solve(){\n\t\tint n=ni();\n\t\tchar[] arr=new char[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tarr[i]=ns().charAt(0);\n\t\t}\n\n\t\tlong mod=1000000007;\n\t\tlong[][] memo=new long[n][n];\n\t\tmemo[0][0]=1L;\n\t\tint k=0;\n\t\tfor(int i=1; i<n; i++){\n\t\t\tif( (arr[i]=='f' && arr[i-1]=='s') || (arr[i]=='s' && arr[i-1]=='s') ){\n\t\t\t\tlong sum=0;\n\t\t\t\tfor(int j=k; j>=0; j--){\n\t\t\t\t\tsum=(sum+(memo[i-1][j]%mod))%mod;\n\t\t\t\t\tmemo[i][j]=sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tk+=1;\n\t\t\t\tfor(int j=1; j<=k; j++){\n\t\t\t\t\tmemo[i][j] = memo[i-1][j-1] % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//print(n, memo);\n\t\tlong sum=0;\n\t\tfor(int i=0;i<=k;i++){\n\t\t\tsum=(sum+(memo[n-1][i])%mod)%mod;\n\t\t}\n\t\tout.println(sum);\n\t}\n\tvoid print(int n, long[][] memo){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tout.print(memo[i][j]+\" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tis = new DataInputStream(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tint t=1;while(t-->0)solve();\n\t\tout.flush();\n\t}\n\tpublic static void main(String[] args)throws Exception{new A().run();}\n\t//Fast I/O code is copied from uwi code.\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\tprivate int readByte(){\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\tprivate String ns(){\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tprivate char[] ns(int n){\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\tprivate char[][] nm(int n, int m){\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\tprivate int[] na(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\tprivate int ni(){\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tprivate long nl(){\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tstatic  int i(long x){return (int)Math.round(x);}\n\tstatic class Pair implements Comparable<Pair>{\n\t\tlong fs,sc;\n\t\tPair(long a,long b){\n\t\t\tfs=a;sc=b;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\tif(this.fs>p.fs)return 1;\n\t\t\telse if(this.fs<p.fs)return -1;\n\t\t\telse{\n\t\t\t\treturn i(this.sc-p.sc);\n\t\t\t}\n\t\t\t//return i(this.sc-p.sc);\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+fs+\",\"+sc+\")\";\n\t\t}\t\n\t}\n\t\n}", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.Scanner;\npublic class main\n{\npublic static void main(String[]args)\n{\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();\nint k=sc.nextInt();\nint res=0;\nres=k/n;\nint r=k%n;\nif(r!=0)\nSystem.out.println(res+1);\nelse if(r==0)\nSystem.out.println(res);\n}\n}", "complexity": "constant", "problem": "1061_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.Scanner;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport java.math.*;\n\nimport java.lang.*;\n\nimport static java.lang.Math.*;\n\n \n\npublic class TestClass implements Runnable\n\n{\n\n\t/*int x,y;\n\n\tpublic TestClass(int x,int y)\n\n\t{\n\n\t\tthis.x=x;\n\n\t\tthis.y=y;\n\n\t}*/\n\n\tpublic static void main(String args[])\n\n\t{\n\n\t\tnew Thread(null, new TestClass(),\"TESTCLASS\",1<<18).start();\n\n\t}\n\n\tpublic void run()\n\n\t{\n\n\t\t//Scanner scan=new Scanner(System.in);\n\n\t\tInputReader hb=new InputReader(System.in);\n\n\t\tPrintWriter w=new PrintWriter(System.out);\n\n\t\t\n\n\t\tlong n=hb.nextLong();\n\n\t\tlong s=hb.nextLong();\n\n\t\t\n\n\t\tlong start=0;\n\n\t\tlong end=n;\n\n\t\tlong ans=0;\n\n\t\twhile(start<=end)\n\n\t\t{\n\n\t\t\tlong mid=(start+end)/2;\n\n\t\t\tif(mid-get(mid)>=s)\n\n\t\t\t{\n\n\t\t\t\tend=mid-1;\n\n\t\t\t\tans=mid;\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t{\n\n\t\t\t\tstart=mid+1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif(ans<1)\n\n\t\t\tw.print(0);\n\n\t\telse\n\n\t\t\tw.print(n-ans+1);\n\n\t\tw.close();\n\n\t}\n\n\t\n\n\tpublic long get(long a)\n\n\t{\n\n\t\tString str = Long.toString(a);\n\n\t\tint ans = 0;\n\n\t\tfor(char ch : str.toCharArray())\n\n\t\t\tans += (ch-'0');\n\n\t\treturn ans;\n\n\t}\n\n\t\n\n\t\n\n\tprivate void shuffle(int[] arr)\n\n\t{\n\n\t\tRandom ran = new Random();\n\n\t\tfor (int i = 0; i < arr.length; i++) {\n\n\t\t\tint i1 = ran.nextInt(arr.length);\n\n\t\t\tint i2 = ran.nextInt(arr.length);\n\n\n\n\t\t\tint temp = arr[i1];\n\n\t\t\tarr[i1] = arr[i2];\n\n\t\t\tarr[i2] = temp;\n\n\t\t}\n\n\t}\n\n\t\n\n\tstatic class DSU\n\n\t{\n\n\t\tint parent[];\n\n\t\tint sizeParent[];\n\n\t\tDSU(int n)\n\n\t\t{\n\n\t\t\tparent=new int[n];\n\n\t\t\tsizeParent=new int[n];\n\n\t\t\tArrays.fill(sizeParent,1);\n\n\t\t\tfor(int i=0;i<n;i++)\n\n\t\t\t\tparent[i]=i;\n\n\t\t}\n\n\t\t\n\n\t\tint find(int x)\n\n\t\t{\n\n\t\t\tif(x!=parent[x])\n\n\t\t\t\tparent[x]=find(parent[x]);\n\n\t\t\treturn parent[x];\n\n\t\t}\n\n\t\t\n\n\t\tvoid union(int x,int y)\n\n\t\t{\n\n\t\t\tx=find(x);\n\n\t\t\ty=find(y);\n\n\t\t\tif(sizeParent[x]>=sizeParent[y])\n\n\t\t\t{\n\n\t\t\t\tif(x!=y)\n\n\t\t\t\t\tsizeParent[x]+=sizeParent[y];\n\n\t\t\t\tparent[y]=x;\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t{\n\n\t\t\t\tif(x!=y)\n\n\t\t\t\t\tsizeParent[y]+=sizeParent[x];\n\n\t\t\t\tparent[x]=y;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t\n\n\tstatic class InputReader\n\n\t{\n\n\t\tprivate InputStream stream;\n\n\t\tprivate byte[] buf = new byte[1024];\n\n\t\tprivate int curChar;\n\n\t\tprivate int numChars;\n\n\t\tprivate SpaceCharFilter filter;\n\n\t\t\n\n\t\tpublic InputReader(InputStream stream)\n\n\t\t{\n\n\t\t\tthis.stream = stream;\n\n\t\t}\n\n\t\t\n\n\t\tpublic int read()\n\n\t\t{\n\n\t\t\tif (numChars==-1) \n\n\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\n\n\t\t\tif (curChar >= numChars)\n\n\t\t\t{\n\n\t\t\t\tcurChar = 0;\n\n\t\t\t\ttry \n\n\t\t\t\t{\n\n\t\t\t\t\tnumChars = stream.read(buf);\n\n\t\t\t\t}\n\n\t\t\t\tcatch (IOException e)\n\n\t\t\t\t{\n\n\t\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\t}\n\n\t\t\t\t\n\n\t\t\t\tif(numChars <= 0)\t\t\t\t\n\n\t\t\t\t\treturn -1;\n\n\t\t\t}\n\n\t\t\treturn buf[curChar++];\n\n\t\t}\n\n\t \n\n\t\tpublic String nextLine()\n\n\t\t{\n\n\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n\t\t\tString str = \"\";\n\n\t\t\ttry\n\n\t\t\t{\n\n\t\t\t\tstr = br.readLine();\n\n\t\t\t}\n\n\t\t\tcatch (IOException e)\n\n\t\t\t{\n\n\t\t\t\te.printStackTrace();\n\n\t\t\t}\n\n\t\t\treturn str;\n\n\t\t}\n\n\t\tpublic int nextInt()\n\n\t\t{\n\n\t\t\tint c = read();\n\n\t\t\t\n\n\t\t\twhile(isSpaceChar(c)) \n\n\t\t\t\tc = read();\n\n\t\t\t\n\n\t\t\tint sgn = 1;\n\n\t\t\t\n\n\t\t\tif (c == '-') \n\n\t\t\t{\n\n\t\t\t\tsgn = -1;\n\n\t\t\t\tc = read();\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tint res = 0;\n\n\t\t\tdo \n\n\t\t\t{\n\n\t\t\t\tif(c<'0'||c>'9') \n\n\t\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\tres *= 10;\n\n\t\t\t\tres += c - '0';\n\n\t\t\t\tc = read();\n\n\t\t\t}\n\n\t\t\twhile (!isSpaceChar(c)); \n\n\t\t\t\n\n\t\t\treturn res * sgn;\n\n\t\t}\n\n\t\t\n\n\t\tpublic long nextLong() \n\n\t\t{\n\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\n\t\t\t\tc = read();\n\n\t\t\tint sgn = 1;\n\n\t\t\tif (c == '-') \n\n\t\t\t{\n\n\t\t\t\tsgn = -1;\n\n\t\t\t\tc = read();\n\n\t\t\t}\n\n\t\t\tlong res = 0;\n\n\t\t\t\n\n\t\t\tdo \n\n\t\t\t{\n\n\t\t\t\tif (c < '0' || c > '9')\n\n\t\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\tres *= 10;\n\n\t\t\t\tres += c - '0';\n\n\t\t\t\tc = read();\n\n\t\t\t}\n\n\t\t\twhile (!isSpaceChar(c));\n\n\t\t\t\treturn res * sgn;\n\n\t\t}\n\n\t\t\n\n\t\tpublic double nextDouble() \n\n\t\t{\n\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\n\t\t\t\tc = read();\n\n\t\t\tint sgn = 1;\n\n\t\t\tif (c == '-') \n\n\t\t\t{\n\n\t\t\t\tsgn = -1;\n\n\t\t\t\tc = read();\n\n\t\t\t}\n\n\t\t\tdouble res = 0;\n\n\t\t\twhile (!isSpaceChar(c) && c != '.') \n\n\t\t\t{\n\n\t\t\t\tif (c == 'e' || c == 'E')\n\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\n\t\t\t\tif (c < '0' || c > '9')\n\n\t\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\tres *= 10;\n\n\t\t\t\tres += c - '0';\n\n\t\t\t\tc = read();\n\n\t\t\t}\n\n\t\t\tif (c == '.') \n\n\t\t\t{\n\n\t\t\t\tc = read();\n\n\t\t\t\tdouble m = 1;\n\n\t\t\t\twhile (!isSpaceChar(c)) \n\n\t\t\t\t{\n\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\n\t\t\t\t\tif (c < '0' || c > '9')\n\n\t\t\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\t\tm /= 10;\n\n\t\t\t\t\tres += (c - '0') * m;\n\n\t\t\t\t\tc = read();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn res * sgn;\n\n\t\t}\n\n\t\t\n\n\t\tpublic String readString() \n\n\t\t{\n\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\n\t\t\t\tc = read();\n\n\t\t\tStringBuilder res = new StringBuilder();\n\n\t\t\tdo \n\n\t\t\t{\n\n\t\t\t\tres.appendCodePoint(c);\n\n\t\t\t\tc = read();\n\n\t\t\t} \n\n\t\t\twhile (!isSpaceChar(c));\n\n\t\t\t\n\n\t\t\treturn res.toString();\n\n\t\t}\n\n\t \n\n\t\tpublic boolean isSpaceChar(int c) \n\n\t\t{\n\n\t\t\tif (filter != null)\n\n\t\t\t\treturn filter.isSpaceChar(c);\n\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\n\t\t}\n\n\t \n\n\t\tpublic String next() \n\n\t\t{\n\n\t\t\treturn readString();\n\n\t\t}\n\n\t\t\n\n\t\tpublic interface SpaceCharFilter \n\n\t\t{\n\n\t\t\tpublic boolean isSpaceChar(int ch);\n\n\t\t}\n\n\t}\n\n \n\n\tstatic class Pair implements Comparable<Pair>\n\n\t{\n\n\t\tint a;\n\n\t\tint b;\n\n\t\tString str;\n\n\t\tpublic Pair(int a,int b)\n\n\t\t{\n\n\t\t\tthis.a=a;\n\n\t\t\tthis.b=b;\n\n\t\t\tstr=min(a,b)+\" \"+max(a,b);\n\n\t\t}\n\n \n\n\t\tpublic int compareTo(Pair pair)\n\n\t\t{\n\n\t\t\tif(Integer.compare(a,pair.a)==0)\n\n\t\t\t\treturn Integer.compare(b,pair.b);\n\n \n\n\t\t\treturn Integer.compare(a,pair.a);\n\n\t\t}\n\n\t}\n\n \n\n\t\n\n}", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.util.*;\n\npublic class Pipeline {\n\n    public static long sumOfPipes(long n, long k) {\n\n        long left = 1;\n        long right = k;\n\n        while (left < right) {\n            long mid = (left + right) / 2;\n            long s = sum(mid, k);\n            if (s == n) {\n                return k - mid + 1;\n            } else if (s > n) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n\n        return k - left + 2;\n    }\n\n    static long sum(long left, long right) {\n        long s = 0;\n        if (left <= right) {\n            s = sum(right) - sum(left - 1);\n        }\n        return s;\n    }\n\n    static long sum(long k) {\n        return k * (k + 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong();\n        long k = in.nextLong();\n        if (n == 1) {\n            System.out.println(0);\n        } else if (k >= n) {\n            System.out.println(1);\n        } else {\n            n -= 1;\n            k -= 1;\n\n            if (sum(k) < n) {\n                System.out.println(-1);\n            } else {\n\n                System.out.println(sumOfPipes(n, k));\n\n            }\n        }\n    }\n}\n\t \t \t\t\t\t  \t\t  \t\t\t\t\t\t\t\t  \t \t\t\t \t", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n        }\n        Arrays.sort(arr);\n        int cnt = 0;\n        int pos = 0;\n        while (true) {\n            while (pos < n && arr[pos] == -1) pos++;\n            if (pos == n) break;\n            int min = arr[pos];\n            arr[pos] = -1;\n            cnt++;\n            for (int i = pos + 1; i < n; i++) {\n                if (arr[i] % min == 0) {\n                    arr[i] = -1;\n                }\n            }\n        }\n        System.out.println(cnt);\n    }\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\n\npublic class CF1238E {\n    public static void main(String[] args) throws Exception {\n        boolean local = System.getSecurityManager() == null;\n        boolean async = false;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"dalt\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        long lInf = (long) 1e18;\n        double dInf = 1e50;\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n\n        int[][] fee;\n        int m;\n        long[] dp;\n        int mask;\n        int[][] maskFee;\n\n        public void solve() {\n            int n = io.readInt();\n            m = io.readInt();\n            char[] s = new char[n];\n            io.readString(s, 0);\n            for (int i = 0; i < n; i++) {\n                s[i] -= 'a';\n            }\n            fee = new int[m][m];\n            for (int i = 1; i < n; i++) {\n                fee[s[i]][s[i - 1]]++;\n                fee[s[i - 1]][s[i]]++;\n            }\n\n            mask = (1 << m) - 1;\n            maskFee = new int[m][mask + 1];\n            SubsetGenerator sg = new SubsetGenerator();\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < m; j++) {\n                    sg.meanings[j] = fee[i][j];\n                }\n                for (int j = 0; j <= mask; j++) {\n                    maskFee[i][j] = sg.next();\n                }\n            }\n\n            dp = new long[mask + 1];\n            Arrays.fill(dp, -1);\n            dp[0] = 0;\n\n            io.cache.append(dp(mask));\n        }\n\n        BitOperator bo = new BitOperator();\n\n        public long dp(int s) {\n            if (dp[s] == -1) {\n                long extra = 0;\n                int remainSet = mask - s;\n                for (int j = 0; j < m; j++) {\n                    if (bo.bitAt(s, j) == 0) {\n                        continue;\n                    }\n                    extra += maskFee[j][remainSet];\n                }\n\n                dp[s] = lInf;\n                for (int j = 0; j < m; j++) {\n                    if (bo.bitAt(s, j) == 0) {\n                        continue;\n                    }\n                    int ss = bo.setBit(s, j, false);\n                    dp[s] = Math.min(dp[s], extra + dp(ss));\n                }\n            }\n\n            return dp[s];\n        }\n    }\n\n    /**\n     * Bit operations\n     */\n    public static class BitOperator {\n        public int bitAt(int x, int i) {\n            return (x >> i) & 1;\n        }\n\n        public int bitAt(long x, int i) {\n            return (int) ((x >> i) & 1);\n        }\n\n        public int setBit(int x, int i, boolean v) {\n            if (v) {\n                x |= 1 << i;\n            } else {\n                x &= ~(1 << i);\n            }\n            return x;\n        }\n\n        public long setBit(long x, int i, boolean v) {\n            if (v) {\n                x |= 1L << i;\n            } else {\n                x &= ~(1L << i);\n            }\n            return x;\n        }\n\n        public long swapBit(long x, int i, int j) {\n            int bi = bitAt(x, i);\n            int bj = bitAt(x, j);\n            x = setBit(x, i, bj == 1);\n            x = setBit(x, j, bi == 1);\n            return x;\n        }\n\n        public int swapBit(int x, int i, int j) {\n            int bi = bitAt(x, i);\n            int bj = bitAt(x, j);\n            x = setBit(x, i, bj == 1);\n            x = setBit(x, j, bi == 1);\n            return x;\n        }\n\n        /**\n         * Determine whether x is subset of y\n         */\n        public boolean subset(long x, long y) {\n            return intersect(x, y) == x;\n        }\n\n        /**\n         * Merge two set\n         */\n        public long merge(long x, long y) {\n            return x | y;\n        }\n\n        public long intersect(long x, long y) {\n            return x & y;\n        }\n\n        public long differ(long x, long y) {\n            return x - intersect(x, y);\n        }\n    }\n\n    public static class SubsetGenerator {\n        private int[] meanings = new int[33];\n        private int[] bits = new int[33];\n        private int remain;\n        private int next;\n\n        public void setSet(int set) {\n            int bitCount = 0;\n            while (set != 0) {\n                meanings[bitCount] = set & -set;\n                bits[bitCount] = 0;\n                set -= meanings[bitCount];\n                bitCount++;\n            }\n            remain = 1 << bitCount;\n            next = 0;\n        }\n\n        public boolean hasNext() {\n            return remain > 0;\n        }\n\n        private void consume() {\n            remain = remain - 1;\n            int i;\n            for (i = 0; bits[i] == 1; i++) {\n                bits[i] = 0;\n                next -= meanings[i];\n            }\n            bits[i] = 1;\n            next += meanings[i];\n        }\n\n        public int next() {\n            int returned = next;\n            consume();\n            return returned;\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder(1 << 13);\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() throws IOException {\n            os.write(cache.toString().getBytes(charset));\n            os.flush();\n            cache.setLength(0);\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}\n", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.util.*;\n \npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\t int[][] x = new int [200010][10];\n     String a = sc.nextLine(); \n     String b = sc.nextLine(); \n \t  int n = a.length();\n\t  int m = b.length();\n       for (int i = 1; i <= m; i++) {\n         for (int j = 0; j < 2; j++) {\n           x[i][j] = x[i - 1][j];\n         }\n         ++x[i][b.charAt(i - 1) - '0'];\n       }\n       long res = 0;\n        for (int i = 0, c; i < n; i++) {\n          c = a.charAt(i) - '0';\n           for (int j = 0; j < 2; j++) {\n             res += Math.abs(c - j) * (x[m - n + i + 1][j] - x[i][j]);\n           }\n        }\n         System.out.println(res);\n  }\n}", "complexity": "linear", "problem": "0608_B", "from": "CODEFORCES", "tags": "combinatorics,strings"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class F531 {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt(); int m = sc.nextInt();\n        long [][] mn1 = new long[n][n];\n        long [][] mn2 = new long[n][n];\n        long [][] grid = new long[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) grid[i][j] = sc.nextInt();\n        }\n        if (n == 1) {\n            long ans = Integer.MAX_VALUE;\n            for (int i = 0; i < m - 1; i++) ans = Math.min(ans, Math.abs(grid[0][i] - grid[0][i + 1]));\n            out.println(ans);\n            out.close();\n            return;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                long min = Long.MAX_VALUE;\n                for (int k = 0; k < m; k++) min = Math.min(min, Math.abs(grid[i][k] - grid[j][k]));\n                mn1[i][j] = min;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                long min = Long.MAX_VALUE;\n                for (int k = 0; k < m - 1; k++) min = Math.min(min, Math.abs(grid[i][k] - grid[j][k + 1]));\n                mn2[i][j] = min;\n            }\n        }\n        long [][] dp = new long[1 << n][n];\n\n        // start vertex\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (long [] a: dp) Arrays.fill(a, -1);\n            for (int j = 0; j < n; j++) {\n                if (j == i) dp[1 << j][j] = Long.MAX_VALUE;\n                else dp[1 << j][j] = 0;\n            }\n            for (int mask = 1; mask < (1 << n); mask++) {\n                for (int last = 0; last < n; last++) {\n                    if (dp[mask][last] != -1) continue;\n                    for (int prev = 0; prev < n; prev++) {\n                        if (prev == last) continue;\n                        if (((mask >> prev) & 1) == 1) {\n                            dp[mask][last] = Math.max(dp[mask][last], Math.min(mn1[prev][last], dp[mask ^ (1 << last)][prev]));\n                        }\n                    }\n                }\n            }\n            // end vertex\n            for (int j = 0; j < n; j++) {\n                // step from the last vertex to the first\n                long end = mn2[j][i];\n                ans = Math.max(ans, Math.min(dp[(1 << n) - 1][j], end));\n            }\n        }\n        out.println(ans);\n        out.close();\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "import java.util.Scanner;\n\npublic class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint beacon[] = new int[1000001];\n\t\tint pos[] = new int[num];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tint position = sc.nextInt();\n\t\t\tbeacon[position] = sc.nextInt();\n\t\t\tpos[i] = position;\n\t\t}\n\t\tint dp[] = new int[1000001];\n\t\tint max = 1;\n\t\tif (beacon[0] != 0)\n\t\t\tdp[0] = 1;\n\t\t\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} \n\t\t\telse {\n\t\t\t\tint j = i - beacon[i] - 1;\n\t\t\t\tif (j < 0) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = dp[j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\t\t\n\t\tSystem.out.println(num-max);\n\t}\n\n}\n", "complexity": "linear", "problem": "0608_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.Scanner;\n\npublic class N1_CF_199A {\n    public static void main(String[] args) {\n    int n = new Scanner(System.in).nextInt();\n    if( n == 0)\n    {\n        System.out.println(0);\n        System.out.println(0);\n        System.out.println(0);\n        return;\n    }\n    int i = 0 , j = 1;\n    while(true)\n    {\n        int t = i + j;\n        if( t == n)\n        break;\n        i = j;\n        j = t;\n    }\n    System.out.println(i);\n    System.out.println(j);\n    System.out.println(0);\n    }\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.*;         \nimport java.util.*;         \nimport java.math.*;         \n \npublic class Main  implements Runnable {\n//public static final String FileName = \"test\";\nStreamTokenizer ST;      \nPrintWriter out;      \nBufferedReader br;   \nScanner in;\nstatic final int inf = 1000000000+10;\n \nint nextInt() throws IOException{      \n    ST.nextToken();      \n    return (int)ST.nval;      \n}\nlong nextLong() throws IOException{      \n    ST.nextToken();      \n    return (long)ST.nval;      \n}      \nString next() throws IOException{      \n    ST.nextToken();      \n    return ST.sval;      \n}      \ndouble nextD() throws IOException{      \n    ST.nextToken();      \n    return ST.nval;      \n}      \npublic static void main(String[] args) throws IOException {       \n   new Thread(new Main()).start();\n//\tnew Main().run();\n}\n \npublic void run()  {      \n    try {\n    \tbr = new BufferedReader(new InputStreamReader(System.in));\n    \tout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));    \t\n    \t//br = new BufferedReader(new FileReader(new File(FileName+\".in\")));\n    \t//out = new PrintWriter(new BufferedWriter(new FileWriter(FileName+\".out\")));\n    \t//in = new Scanner(br);\n        ST = new StreamTokenizer(br);      \n        solve();      \n        out.close();\n        //in.close();\n        br.close();   \n    }         \n    catch (IOException e) {       \n    \te.printStackTrace();\n    \tthrow new IllegalStateException(e);  \n    }      \n}\n\n\npublic void solve() throws IOException {\n\tint[] x = new int[32];\n\tint[] y = new int[32];\n\tx[0] = nextInt();\n\ty[0] = nextInt();\t\n\tint n = nextInt();\n\tfor (int i=1; i<=n; i++) {\n\t\tx[i] = nextInt();\n\t\ty[i] = nextInt();\n\t}\n\tn++;\n\tint[][] a = new int[n][n];\n\tint[][] b = new int[n-1][n-1];\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<n; j++)\n\t\t\ta[i][j] = (x[i]-x[j])*(x[i]-x[j])+ (y[i]-y[j])*(y[i]-y[j]);\n\tfor (int i=1; i<n; i++)\n\t\tfor (int j=1; j<n; j++)\n\t\t\tif (i!=j) b[i-1][j-1] = a[0][i]+a[i][j]+a[j][0]; else b[i-1][j-1] = 2*a[0][i];\n\tn--;\n\t\n\tint sz = 1<<n;\n\tint[] d = new int[sz];\n\tint[] p = new int[sz];\n\td[1] = 0;\n\tfor (int msk=1; msk<sz; msk++) {\n\t\tint j = 0;\n\t\twhile ((msk&(1<<j))==0) j++;\n\t\tint t = inf;\t\t\n\t\tfor (int i=0; i<n; i++)\n\t\t\tif ((msk&(1<<i))>0)\n\t\t\tif (t>d[msk^((1<<i)|(1<<j))]+b[i][j]) {\n\t\t\t\tt = d[msk^((1<<i)|(1<<j))]+b[i][j];\n\t\t\t\tp[msk] = i*n+j;\n\t\t\t}\t\n\t\td[msk] = t;\n\t\t\n\t}\n\tout.println(d[sz-1]);\n\tout.print(\"0 \");\n\tint t = sz-1;\n\twhile (t>0) {\n\t\tint hz = p[t];\n\t\tint i = hz/n;\n\t\tint j = hz%n;\n\t\tif (i!=j) out.print((i+1)+\" \"+(j+1)+\" 0 \");else out.print((i+1)+\" 0 \");\n\t\tt ^= (1<<i)|(1<<j);\n\t}\n\t\n}\n  \n}\n \n \n  ", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.BufferedWriter;\n\timport java.io.IOException;\n\timport java.io.InputStream;\n\timport java.io.OutputStream;\n\timport java.io.OutputStreamWriter;\n\timport java.io.PrintWriter;\n\timport java.io.Writer;\n\timport java.util.Arrays;\n\timport java.util.InputMismatchException;\n\timport java.util.*;\n\timport java.io.*;\n\timport java.math.*;\n\tpublic class Main7{\n\n\tstatic class Pair\n\t\t{ \n\t\t\tint x;\n\t\t\tint y;\n\t\t\tpublic Pair(int x,int y) \n\t\t\t{\t \n\t\t\t\tthis.x= x; \n\t\t\t\tthis.y= y;\n\t\t\t}\t \n\t\t\t\n\t\t\t@Override\n\t\t\t\t\tpublic int hashCode() \n\t\t\t\t\t{ \n\t\t\t\t\t\tfinal int temp = 14; \n\t\t\t\t\t\tint ans = 1; \n\t\t\t\t\t\tans =x*31+y*13; \n\t\t\t\t\t\treturn ans; \n\t\t\t\t\t} \n\t\t\t  \n\t\t\t\t\t// Equal objects must produce the same \n\t\t\t\t\t// hash code as long as they are equal \n\t\t\t\t@Override\n\t\t\t\tpublic boolean equals(Object o) \n\t\t\t\t{ \n\t\t\t\t\tif (this == o) { \n\t\t\t\t\t\treturn true; \n\t\t\t\t\t} \n\t\t\t\t\tif (o == null) { \n\t\t\t\t\t\treturn false; \n\t\t\t\t\t} \n\t\t\t\t\tif (this.getClass() != o.getClass()) { \n\t\t\t\t\t\treturn false; \n\t\t\t\t\t} \n\t\t\t\t\tPair other = (Pair)o; \n\t\t\t\t\tif (this.x != other.x || this.y!=other.y) { \n\t\t\t\t\t\treturn false; \n\t\t\t\t\t} \n\t\t\t\t\treturn true; \n\t\t\t\t} \n\t\t\t\t\t\n\t\t} \n\t\tstatic class Pair1\n\t\t{\n\t\t\tString x;\n\t\t\tint y;\n\t\t\tint z;\n\t\t\t\n\t\t}\n\t\tstatic class Compare\n\t\t{ \n\t\t\t/*static void compare(Pair arr[], int n) \n\t\t\t{ \n\t\t\t\t// Comparator to sort the pair according to second element \n\t\t\t\tArrays.sort(arr, new Comparator<Pair>() { \n\t\t\t\t\t@Override public int compare(Pair p1, Pair p2) \n\t\t\t\t\t{ \n\t\t\t\t\t\tif(p1.start>p2.start)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(p1.start==p2.start)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}); \n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t\n\t\t\n\t\tpublic static long pow(long a, long b)\n\t\t{\n\t\t\tlong result=1;\n\t\t\twhile(b>0)\n\t\t\t{\n\t\t\t\tif (b % 2 != 0)\n\t\t\t\t{\n\t\t\t\t\tresult=(result*a)%mod;\n\t\t\t\t\tb--;\n\t\t\t\t} \n\t\t\t\ta=(a*a)%mod;\n\t\t\t\tb /= 2;\n\t\t\t}   \n\t\t\treturn result;\n\t\t}\n\t\tpublic static long fact(long num)\n\t\t{\n\t\t\t\t\tlong value=1;\n\t\t\t\t\tint i=0;\n\t\t\t\t\tfor(i=2;i<num;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue=((value%mod)*i%mod)%mod;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tpublic static int gcd(int a, int b)\n\t\t\t\t{\n\t\t\t\t\tif (a == 0)\n\t\t\t\t\t\treturn b;\n\t\t\t\t\treturn gcd(b%a, a);\n\t\t\t\t}\n\t\t\t\t\n\t\t/*\t\tpublic static long lcm(long a,long b)\n\t\t\t\t{\n\t\t\t\t\treturn a * (b / gcd(a, b));\n\t\t\t\t}\n\t\t\t*/\tpublic static long sum(int h)\n\t\t\t\t{\n\t\t\t\t\treturn (h*(h+1)/2);\n\t\t\t\t}\n\t\t\t\t/*public static void dfs(int parent,boolean[] visited)\n\t\t\t\t{\n\t\t\t\t\tTreeSet<Integer> arr=new TreeSet<Integer>();\n\t\t\t\t\tarr=graph.get(parent);\n\t\t\t\t\tvisited[parent]=true;\n\t\t\t\t\tif(a[parent]==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(a[parent]==2)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag1=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==1 && flag1==1)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tIterator itr=arr.iterator();\n\t\t\t\t\twhile(itr.hasNext())\n\t\t\t\t\t{\n\t\t\t\t\t\tint num=(int)itr.next();\n\t\t\t\t\t\tif(visited[num]==false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdfs(num,visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx1x`\n\t\t\t\t}*/\n\t\t\t//\tstatic int flag1=0;\n\t\t\t\tstatic int[] dis;\n\t\t\t\tstatic int mod=1000000007;\n\t\t\t\tstatic ArrayList<ArrayList<Integer>> graph;\n\t\t\t\t\n\t\t\t\tpublic static void bfs(int num,int size)\n\t\t\t\t{\n\t\t\t\t\tboolean[] visited=new boolean[size+1];\n\t\t\t\t\tQueue<Integer> q=new LinkedList<>();\n\t\t\t\t\tq.add(num);\n\t\t\t\t\tans[num]=1;\n\t\t\t\t\tvisited[num]=true;\n\t\t\t\t\twhile(!q.isEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tint x=q.poll();\n\t\t\t\t\t\tArrayList<Integer> al=graph.get(x);\n\t\t\t\t\t\tfor(int i=0;i<al.size();i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint y=al.get(i);\t\n\t\t\t\t\t\t\tif(visited[y]==false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tq.add(y);\n\t\t\t\t\t\t\t\tans[y]=ans[x]+1;\n\t\t\t\t\t\t\t\tvisited[y]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic int[] ans;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t//\tstatic int[] a;\t\t\t  \n\t\t\t\t\n\t\t\t\tpublic static int[] sort(int[] a)\n\t\t\t\t{\n\t\t\t\t\tint n=a.length;\n\t\t\t\t\tArrayList<Integer> ar=new ArrayList<>();\n\t\t\t\t\tfor(int i=0;i<a.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tar.add(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tCollections.sort(ar);\n\t\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i]=ar.get(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t\t//\tstatic int flag=1;\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tstatic public void main(String args[])throws IOException\n\t\t\t\t{\n\t\t//\t\t    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\t/*\tboolean[] prime=new boolean[1000001];\n\t\t\t\t\tfor(int i=2;i*i<=1000000;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(prime[i]==false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int j=2*i;j<=1000000;j+=i)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprime[j]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\tint n=i();\n\t\t\t\t\tint k=i();\n\t\t\t\t\tlong low=0;\n\t\t\t\t\tlong high=k;\n\t\t\t\t\tlong fin=0;\n\t\t\t\t\tlong ans=0;\n\t\t\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=i;\n\t\t\t\t\t\tif(Math.abs(ans-k)+i==n && ans>=k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfin=Math.abs(ans-k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpln(fin+\"\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/**/\n\t\t\t\tstatic InputReader in=new InputReader(System.in);\n\t\t\t\t\tstatic OutputWriter out=new OutputWriter(System.out);\n\t\t\t\t\tpublic static long l()\n\t\t\t\t\t{\n\t\t\t\t\t\tString s=in.String();\n\t\t\t\t\t\treturn Long.parseLong(s);\n\t\t\t\t\t}\n\t\t\t\t\tpublic static void pln(String value)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(value);\n\t\t\t\t\t}\n\t\t\t\t\tpublic static int i()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn in.Int();\n\t\t\t\t\t}\n\t\t\t\t\tpublic static String s()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn in.String();\n\t\t\t\t\t}\n\t\t}\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tclass InputReader {\n\t\t\t\t \n\t\t\t\tprivate InputStream stream;\n\t\t\t\tprivate byte[] buf = new byte[1024];\n\t\t\t\tprivate int curChar;\n\t\t\t\tprivate int numChars;\n\t\t\t\tprivate SpaceCharFilter filter;\n\t\t\t \n\t\t\t\tpublic InputReader(InputStream stream) {\n\t\t\t\t\tthis.stream = stream;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic int read() {\n\t\t\t\t\tif (numChars== -1)\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tif (curChar >= numChars) {\n\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (numChars <= 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic int Int() {\n\t\t\t\t\tint c = read();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = read();\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-') {\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t}\n\t\t\t\t\tint res = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic String String() {\n\t\t\t\t\tint c = read();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = read();\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo {\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic boolean isSpaceChar(int c) {\n\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic String next() {\n\t\t\t\t\treturn String();\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic interface SpaceCharFilter {\n\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tclass OutputWriter {\n\t\t\t\tprivate final PrintWriter writer;\n\t\t\t \n\t\t\t\tpublic OutputWriter(OutputStream outputStream) {\n\t\t\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic OutputWriter(Writer writer) {\n\t\t\t\t\tthis.writer = new PrintWriter(writer);\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic void print(Object...objects) {\n\t\t\t\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\t\twriter.print(' ');\n\t\t\t\t\t\twriter.print(objects[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic void printLine(Object...objects) {\n\t\t\t\t\tprint(objects);\n\t\t\t\t\twriter.println();\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic void close() {\n\t\t\t\t\twriter.close();\n\t\t\t\t}\n\t\t\t \n\t\t\t\tpublic void flush() {\n\t\t\t\t\twriter.flush();\n\t\t\t\t}\n\t\t\t \n\t\t\t\t}\n\t\t\t \n\t\t\t\tclass IOUtils {\n\t\t\t \n\t\t\t\tpublic static int[] readIntArray(InputReader in, int size) {\n\t\t\t\t\tint[] array = new int[size];\n\t\t\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\t\t\tarray[i] = in.Int();\n\t\t\t\t\treturn array;\n\t\t\t\t}\n\t\t\t \n\t\t\t\t} ", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "/**\n\n * Practiced on 3/28/2013\n\n * \n\n * http://www.codeforces.com/contest/287/problem/B\n\n * \n\n * =========================================\n\n * The maximum number of pipes that can be built out of i splitters are\n\n * k + k-1 + ... + k-i+1 - (i-1). So it can be calculated by the calculate(k, i)\n\n * function. \n\n * \n\n * Binary search. Find the smallest i such that n < calculate(k, i).\n\n */\n\n\n\n//package com.congli.codeforces;\n\n\n\nimport java.io.BufferedReader;\n\nimport java.io.FileReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.util.Locale;\n\nimport java.util.Stack;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class C176Div2B_Pipeline implements Runnable {\n\n\n\n\tBufferedReader in;\n\n\tPrintWriter out;\n\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Thread(null, new C176Div2B_Pipeline(), \"\", 256 * (1L << 20)).start();\n\n\t}\n\n\t\n\n\tpublic void solve() throws IOException \n\n\t{\n\n\t\tlong n = readLong();\n\n\t\tint k = readInt();\n\n\n\n\t\tint start = 0;\n\n\t\tint end = k;\n\n\t\tint mid = 0;\n\n\t\twhile(start <= end)\n\n\t\t{\n\n\t\t\tmid = start + (end-start)/2;\n\n\t\t\tlong val_mid = calculate(k, mid);\n\n\t\t\t\n\n\t\t\tif(n == val_mid)\n\n\t\t\t{\n\n\t\t\t\tSystem.out.println(mid);\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif(n < val_mid)\n\n\t\t\t\tend = mid-1;\n\n\t\t\telse\n\n\t\t\t\tstart = mid+1;\n\n\t\t}\n\n\t\tif(start > k)\n\n\t\t\tSystem.out.println(-1);\n\n\t\telse if(n < calculate(k, end))\n\n\t\t\tSystem.out.println(end);\n\n\t\telse\n\n\t\t\tSystem.out.println(start);\n\n\t}\t\n\n\t\n\n\tpublic long calculate(int k, int level)\n\n\t{\n\n\t\tlong start = k;\n\n\t\tlong end = k-level+1;\n\n\t\treturn (start+end) * level / 2 - level + 1;\n\n\t}\n\n\t\n\n\tpublic void run() {\n\n\t\ttry {\n\n\t\t\tlong t1 = System.currentTimeMillis();\n\n\t\t\tif (System.getProperty(\"ONLINE_JUDGE\") != null) {\n\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t\t\tout = new PrintWriter(System.out);\n\n\t\t\t} else {\n\n\t\t\t\tin = new BufferedReader(new FileReader(\"..\\\\Codeforces\\\\src\\\\com\\\\congli\\\\codeforces\\\\input.txt\"));\n\n\t\t\t\tout = new PrintWriter(System.out);\n\n\t\t\t}\n\n\t\t\tLocale.setDefault(Locale.US);\n\n\t\t\tsolve();\n\n\t\t\tin.close();\n\n\t\t\tout.close();\n\n\t\t\tlong t2 = System.currentTimeMillis();\n\n\t\t\tSystem.err.println(\"Time = \" + (t2 - t1));\n\n\t\t} catch (Throwable t) {\n\n\t\t\tt.printStackTrace(System.err);\n\n\t\t\tSystem.exit(-1);\n\n\t\t}\n\n\t}\n\n\n\n\tpublic String readString() throws IOException {\n\n\t\twhile (!tok.hasMoreTokens()) {\n\n\t\t\ttok = new StringTokenizer(in.readLine());\n\n\t\t}\n\n\t\treturn tok.nextToken();\n\n\t}\n\n\n\n\tpublic int readInt() throws IOException {\n\n\t\treturn Integer.parseInt(readString());\n\n\t}\n\n\n\n\tpublic long readLong() throws IOException {\n\n\t\treturn Long.parseLong(readString());\n\n\t}\n\n\n\n\tpublic double readDouble() throws IOException {\n\n\t\treturn Double.parseDouble(readString());\n\n\t}\n\n}\n\n\n\n\n\n\n\n\n\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.util.*;\n\npublic class Solution {\n    public void doMain() throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt();\n        boolean[][] adj = new boolean[n][n];\n        for (int i=0; i<m; i++) {\n            int a = sc.nextInt()-1, b = sc.nextInt()-1;\n            adj[a][b] = adj[b][a] = true;\n        }\n        \n        long res = 0;\n        \n        for (int st=0; st+1<n; st++) {\n            //System.out.println(\"st=\"+st);\n            long[][] numWays = new long[1<<(n-st-1)][n-st-1];\n            for (int i=st+1; i<n; i++)\n                if (adj[st][i]) numWays[1<<(i-st-1)][i-st-1] = 1;\n            \n            for (int mask=1; mask < (1<<(n-st-1)); mask++) {\n                boolean simple = ((mask & (mask-1)) == 0);\n                for (int last=0; last<n-st-1; last++) if (numWays[mask][last]!=0) {\n                    if (adj[last+st+1][st] && !simple) res += numWays[mask][last];\n                    for (int next=0; next<n-st-1; next++)\n                        if (adj[last+st+1][next+st+1] && (mask & (1<<next)) == 0)\n                            numWays[mask | (1<<next)][next] += numWays[mask][last];\n                }\n            }\n        }\n        \n        System.out.println(res/2);\n    }\n    public static void main(String[] args) throws Exception {\n        (new Solution()).doMain();\n    }\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\n\npublic class Main\n{\n    /********************************************** a list of common variables **********************************************/\n    private MyScanner scan = new MyScanner();\n    private PrintWriter out = new PrintWriter(System.out);\n    private final double PI = Math.PI;\n    private final int INF = (int)(1e9);\n    private final double EPS = 1e-6;\n    private final int SIZEN = (int)(1e7);\n    private final int MOD = (int)(1e9 + 7);\n    private final long MODH = 10000000007L, BASE = 10007;\n    private final int[] DX = {0, 1, 0, -1}, DY = {-1, 0, 1, 0};\n    int n;\n    int[] sum;\n    int[][] a;\n\n    public void foo1() {\n        int n = scan.nextInt();\n        int sum = 0;\n        int[] a = new int[n];\n        for (int i = 0;i < n;++i) {\n            a[i] = scan.nextInt();\n            sum += a[i];\n        }\n        int avg = sum * 2 / n;\n        for (int i = 0;i < n;++i) {\n            if (a[i] == 0) {\n                continue;\n            }\n            for (int j = i + 1;j < n;++j) {\n                if (a[i] + a[j] == avg) {\n                    a[j] = 0;\n                    System.out.println((i + 1) + \" \" + (j + 1));\n                    break;\n                }\n            }\n        }\n    }\n\n    public void foo2() {\n        int n = scan.nextInt();\n        int m = scan.nextInt();\n        HashSet<Integer> row = new HashSet<Integer>();\n        HashSet<Integer> col = new HashSet<Integer>();\n        for (int i = 0;i < m;++i) {\n            int x = scan.nextInt();\n            int y = scan.nextInt();\n            row.add(x);\n            col.add(y);\n            out.print((long) (n - row.size()) * (n - col.size()) + \" \");\n        }\n    }\n\n    public int getId(char c) {\n        return (c >= 'a' && c <= 'z') ? c - 'a': c - 'A' + 26;\n    }\n\n    public boolean isOk(int len) {\n        for (int i = 0;i + len <= n;++i) {\n            boolean flag = true;\n            for (int j = 0;j < 52;++j) {\n                if (a[i + len][j] - a[i][j] == 0 && sum[j] != 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void foo() {\n        n = scan.nextInt();\n        char[] s = scan.next().toCharArray();\n        a = new int[n + 1][52];\n        sum = new int[52];\n        for (int i = 0;i < n;++i) {\n            for (int j = 0;j < 52;++j) a[i + 1][j] = a[i][j];\n            ++a[i + 1][getId(s[i])];\n            ++sum[getId(s[i])];\n        }\n        int left = 1, right = n, ans = n;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            if (isOk(mid)) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        out.println(ans);\n    }\n\n    public static void main(String[] args)\n    {\n        Main m = new Main();\n        m.foo();\n        m.out.close();\n    }\n\n    /********************************************** a list of common algorithms **********************************************/\n    /**\n     * 1---Get greatest common divisor\n     * @param a :\tfirst number\n     * @param b :\tsecond number\n     * @return\t\tgreatest common divisor\n     */\n    public long gcd(long a, long b)\n    {\n        return 0 == b ? a : gcd(b, a % b);\n    }\n\n    /**\n     * 2---Get the distance from a point to a line\n     * @param x1\tthe x coordinate of one endpoint of the line\n     * @param y1\tthe y coordinate of one endpoint of the line\n     * @param x2\tthe x coordinate of the other endpoint of the line\n     * @param y2\tthe y coordinate of the other endpoint of the line\n     * @param x\t\tthe x coordinate of the point\n     * @param y\t\tthe x coordinate of the point\n     * @return\t\tthe distance from a point to a line\n     */\n    public double getDist(long x1, long y1, long x2, long y2, long x, long y)\n    {\n        long a = y2 - y1;\n        long b = x1 - x2;\n        long c = y1 * (x2 - x1) - x1 * (y2 - y1);\n        return Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);\n    }\n\n    /**\n     * 3---Get the distance from one point to a segment (not a line)\n     * @param x1\tthe x coordinate of one endpoint of the segment\n     * @param y1\tthe y coordinate of one endpoint of the segment\n     * @param x2\tthe x coordinate of the other endpoint of the segment\n     * @param y2\tthe y coordinate of the other endpoint of the segment\n     * @param x\t\tthe x coordinate of the point\n     * @param y\t\tthe y coordinate of the point\n     * @return\t\tthe distance from one point to a segment (not a line)\n     */\n    public double ptToSeg(long x1, long y1, long x2, long y2, long x, long y)\n    {\n        double cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n        if(cross <= 0)\n        {\n            return (x - x1) * (x - x1) + (y - y1) * (y - y1);\n        }\n        double d = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n        if(cross >= d)\n        {\n            return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n        }\n        double r = cross / d;\n        double px = x1 + (x2 - x1) * r;\n        double py = y1 + (y2 - y1) * r;\n        return (x - px) * (x - px) + (y - py) * (y - py);\n    }\n\n    /**\n     * 4---KMP match, i.e. kmpMatch(\"abcd\", \"bcd\") = 1, kmpMatch(\"abcd\", \"bfcd\") = -1.\n     * @param t:\tString to match.\n     * @param p:\tString to be matched.\n     * @return\t\tif can match, first index; otherwise -1.\n     */\n    public int kmpMatch(char[] t, char[] p)\n    {\n        int n = t.length;\n        int m = p.length;\n        int[] next = new int[m + 1];\n        next[0] = -1;\n        int j = -1;\n        for(int i = 1;i < m;++i)\n        {\n            while(j >= 0 && p[i] != p[j + 1])\n            {\n                j = next[j];\n            }\n            if(p[i] == p[j + 1])\n            {\n                ++j;\n            }\n            next[i] = j;\n        }\n        j = -1;\n        for(int i = 0;i < n;++i)\n        {\n            while(j >= 0 && t[i] != p[j + 1])\n            {\n                j = next[j];\n            }\n            if(t[i] == p[j + 1])\n            {\n                ++j;\n            }\n            if(j == m - 1)\n            {\n                return i - m + 1;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 5---Get the hash code of a String\n     * @param\ts:\tinput string\n     * @return\thash code\n     */\n    public long hash(String s)\n    {\n        long key = 0, t = 1;\n        for(int i = 0;i < s.length();++i)\n        {\n            key = (key + s.charAt(i) * t) % MODH;\n            t = t * BASE % MODH;\n        }\n        return key;\n    }\n\n    /**\n     * 6---Get x ^ n % MOD quickly.\n     * @param\tx:\tbase\n     * @param \tn:\ttimes\n     * @return\tx ^ n % MOD\n     */\n    public long quickMod(long x, long n)\n    {\n        long ans = 1;\n        while(n > 0)\n        {\n            if(1 == n % 2)\n            {\n                ans = ans * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return ans;\n    }\n\n    /**\n     * 7---judge if a point is located inside a polygon\n     * @param x0\tthe x coordinate of the point\n     * @param y0\tthe y coordinate of the point\n     * @return true if it is inside the polygon, otherwise false\n     */\n\t/*public boolean contains(double x0, double y0)\n\t{\n\t\tint cross = 0;\n\t\tfor(int i = 0;i < n;++i)\n\t\t{\n\t\t\tdouble s = x[i + 1] == x[i] ? 100000000 : (double)(y[i + 1] - y[i]) / (x[i + 1] - x[i]);\n\t\t\tboolean b1 = x[i] <= x0 && x0 < x[i + 1];\n\t\t\tboolean b2 = x[i + 1] <= x0 && x0 < x[i];\n\t\t\tboolean b3 = y0 < s * (x0 - x[i]) + y[i];\n\t\t\tif((b1 || b2) && b3) ++cross;\n\t\t}\n\t\treturn cross % 2 != 0;\n\t}*/\n\n    /**\n     * 8---judge if a point is located on the segment\n     * @param\tx1\tthe x coordinate of one point of the segment\n     * @param\ty1\tthe y coordinate of one point of the segment\n     * @param \tx2\tthe x coordinate of another point of the segment\n     * @param \ty2\tthe y coordinate of another point of the segment\n     * @param\tx\tthe x coordinate of the point\n     * @param \ty\tthe y coordinate of the point\n     * @return\ttrue if it is located on the segment, otherwise false\n     */\n    public boolean isOnSeg(long x1, long y1, long x2, long y2, long x, long y)\n    {\n        return (x - x1) * (y2 - y1) == (x2 - x1) * (y - y1) &&\n                x >= Math.min(x1, x2) && x <= Math.max(x1, x2) &&\n                y >= Math.min(y1, y2) && y <= Math.max(y1, y2);\n    }\n\n    /**\n     * 9---get the cross product\n     * @param \tp1\tpoint A\n     * @param \tp2\tpoint B\n     * @param \tp\tpoint O\n     * @return\tcross product of OA x OB\n     */\n\t/*public long cross(Point p1, Point p2, Point p)\n\t{\n\t\treturn (long)(p1.x - p.x) * (p2.y - p.y) - (long)(p2.x - p.x) * (p1.y - p.y);\n\t}*/\n\n    /**\n     * 10---implement topsort and tell if it is possible\n     * @return true if it is possible to implement topsort, otherwise false\n     */\n\t/*public boolean topsort()\n\t{\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tStringBuilder ans = new StringBuilder();\n\t\tint[] in = new int[26];\n\t\tfor(int i = 0;i < 26;++i)\n\t\t{\n\t\t\tif(0 == in[i]) \n\t\t\t{\n\t\t\t\tans.append((char)('a' + i));\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t}\n\t\twhile(!q.isEmpty())\n\t\t{\n\t\t\tint u = q.poll();\n\t\t\tfor(int i = 0;i < 26;++i)\n\t\t\t{\n\t\t\t\tif(map[u][i])\n\t\t\t\t{\n\t\t\t\t\t--in[i];\n\t\t\t\t\tif(0 == in[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tans.append((char)('a' + i));\n\t\t\t\t\t\tq.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 26 == ans.length();\n\t}*/\n\n    class MyScanner\n    {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        BufferedInputStream bis = new BufferedInputStream(System.in);\n\n        public int read()\n        {\n            if (-1 == numChars)\n            {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars)\n            {\n                curChar = 0;\n                try\n                {\n                    numChars = bis.read(buf);\n                }\n                catch (IOException e)\n                {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n            {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n            {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n            {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.')\n            {\n                if (c == 'e' || c == 'E')\n                {\n                    return res * Math.pow(10, nextInt());\n                }\n                if (c < '0' || c > '9')\n                {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c & 15;\n                c = read();\n            }\n            if (c == '.')\n            {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c))\n                {\n                    if (c == 'e' || c == 'E')\n                    {\n                        return res * Math.pow(10, nextInt());\n                    }\n                    if (c < '0' || c > '9')\n                    {\n                        throw new InputMismatchException();\n                    }\n                    m /= 10;\n                    res += (c & 15) * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String next()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n            {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c)\n        {\n            return ' ' == c || '\\n' == c || '\\r' == c || '\\t' == c || -1 == c;\n        }\n    }\n}", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "// https://codeforces.com/problemset/problem/981/A\n\n// https://codeforces.com/problemset/problem/1428/C\n\n//logic: keep taking away stuff under the condition that the length is > 0\n//prioritize AB first, then BB\n//use the string builder class and the subtract function\n\nimport java.util.*;\nimport java.io.*;\n\npublic class AntiPal{\n    \n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        \n        String input = scan.next();\n        \n        StringBuilder rev = new StringBuilder(input);\n        rev.reverse();\n        \n        // System.out.println(rev); // TESTING \n        \n        if(!input.equals(rev.toString())){\n            System.out.println(input.length());\n        }\n        else{\n            boolean allSame = true;\n            for(int j=1; j<input.length(); j++) {\n                if(input.charAt(j)!=input.charAt(j-1)){\n                    allSame = false;\n                    break;\n                }\n            }\n            if(allSame == true){\n                System.out.println(0);\n            }\n            else{\n                System.out.println(input.length()-1);\n            }\n            \n        }\n        \n        \n    }\n    \n}\n", "complexity": "linear", "problem": "0981_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "import java.io.BufferedReader;\nimport java.io.DataInputStream;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\n\n\n \n\npublic class Main{\n    private static Parser in;\n    private static PrintWriter out;\n    \n    public static void main(String[] args){\n        in = new Parser(System.in);\n        out = new PrintWriter(System.out);\n        \n//        \n//        char[] ccc = new char[1];\n//        String ddd = \"abcdef\";\n//        ddd.getChars(2, 3, ccc, 0);\n//        \n//        String sssss = new String(ccc);\n//      \n//        System.out.println(sssss);\n//        \n        String s = in.nextString(100);\n        int len = 0;\n        String ss = \"\";\n        \n       \n        l:for (int i = 1; i<=s.length(); i++){\n            for(int j = 0; j+i<=s.length();j++){\n                char[] c = new char[i];\n                char[] cc = new char[i];\n                s.getChars(j, j+i, c, 0);\n                String sss = new String(c);\n                //System.out.println(sss);\n                for(int k = j+1; k+i<=s.length();k++){\n                     \n                    s.getChars(k, k+i, cc, 0);\n                    String ssss = new String(cc);\n                    if(sss.equals(ssss)) {len = i; continue l;}\n                }\n            }\n        }\n        \n        \n        System.out.println(len);\n       // out.flush();\n    }\n}\n\n\nclass Parser {\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n \n    public Parser(InputStream in) {\n            din = new DataInputStream(in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n    }\n    public String nextString(int size) { \n        byte[] ch = new byte[size];\n        int point = 0;\n        try {\n            byte c = read();\n            while (c == ' ' || c == '\\n' || c=='\\r')\n                c = read();\n            while (c != ' ' && c != '\\n' && c!='\\r') {\n                ch[point++] = c;\n                c = read();\n            }\n        } catch (Exception e) {}\n        return new String(ch,0,point);\n        }\n    public int nextInt() { \n    int ret = 0;\n    boolean neg;\n    try {\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        neg = c == '-';\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n            c = read();\n        } while (c > ' ');\n    \n    if (neg) return -ret;\n    } catch (Exception e) {}\n    return ret;\n    }\n    public long nextLong() { \n        long ret = 0;\n        boolean neg;\n        try {\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            neg = c == '-';\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n                c = read();\n            } while (c > ' ');\n        \n        if (neg) return -ret;\n        } catch (Exception e) {}\n        return ret;\n        }\n    private void fillBuffer() {\n        try {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        } catch (Exception e) {}\n        if (bytesRead == -1) buffer[0] = -1;\n    }\n \n    private byte read() {\n        if (bufferPointer == bytesRead) fillBuffer();\n        return buffer[bufferPointer++];\n    }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n        public int[] arr(int n){int[] ret = new int[n];for (int i = 0; i < n; i++) {ret[i] = i();}return ret;}\n    }\n    \n    \n \n           //       |----|       /\\      |    |   -----   |\n           //       |   /       /  \\     |    |     |     |\n           //       |--/       /----\\    |----|     |     |\n           //       |   \\     /      \\   |    |     |     |\n           //       |    \\   /        \\  |    |   -----   -------\n\n    public static void main(String[] args)throws IOException\n    {\n        PrintWriter out= new PrintWriter(System.out);\n        Reader sc=new Reader();\n        int n=sc.i();\n        System.out.println(\"? \"+1);\n        int a=sc.i();\n        System.out.println(\"? \"+(1+n/2));\n        int b=sc.i();\n        if(a==b)\n        {\n            System.out.println(\"! \"+1);\n            System.exit(0);\n        }\n        int inv=0;\n        if(a>b)\n        inv=1;\n        \n        int low=2;\n        int high=n/2;\n        int q=0;\n        while(low<=high)\n        {\n            if(q==60)\n            break;\n            int mid=(low+high)/2;\n            System.out.println(\"? \"+mid);\n            a=sc.i();\n            System.out.println(\"? \"+(mid+n/2));\n            b=sc.i();\n            if(a==b)\n            {\n                System.out.println(\"! \"+mid);\n                System.exit(0);\n            }\n            else if(a<b)\n            {\n                if(inv==0)\n                low=mid+1;\n                else\n                high=mid-1;\n            }\n            \n            else\n            {\n                if(inv==0)\n                high=mid-1;\n                else\n                low=mid+1;\n            }\n            q++;\n        }\n        System.out.println(\"! -1\");\n        out.flush();\n    }\n}", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "import java.util.Scanner;\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tSystem.out.println(3 * n / 2);\n\t}\n\n}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\n\n// author @mdazmat9\npublic  class codeforces{\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int test = 1;\n        for (int ind = 0; ind < test; ind++) {\n          int [] a=new int[3];\n          a[0]=sc.nextInt();\n          a[1]=sc.nextInt();\n          a[2]=sc.nextInt();\n          Arrays.sort(a);\n          int k1=a[0];\n          int k2=a[1];\n          int k3=a[2];\n          if(k1==1 || k2==1 || k3==1){\n              out.println(\"YES\");\n          }\n          else if((k1==2 && k2==2)||(k2==2 && k3==2)){\n              out.println(\"YES\");\n            }\n            else if(k1==3 && k2==3 && k3==3){\n              out.println(\"YES\");\n          }\n          else if(k1==2 && k2==4 && k3==4){\n              out.println(\"YES\");\n          }\n          else\n              out.println(\"NO\");\n\n        }\n        out.flush();\n    }\n\n\n\n\n\n    static   void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n    static long gcd(long a , long b)\n    {\n        if(b == 0)\n            return a;\n        return gcd(b , a % b);\n    }\n\n}\nclass Scanner {\n    public BufferedReader reader;\n    public StringTokenizer st;\n\n    public Scanner(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        st = null;\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                String line = reader.readLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            } catch (Exception e) {\n                throw (new RuntimeException());\n            }\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n\nclass OutputWriter {\n    BufferedWriter writer;\n\n    public OutputWriter(OutputStream stream) {\n        writer = new BufferedWriter(new OutputStreamWriter(stream));\n    }\n\n    public void print(int i) throws IOException {\n        writer.write(i);\n    }\n\n    public void print(String s) throws IOException {\n        writer.write(s);\n    }\n\n    public void print(char[] c) throws IOException {\n        writer.write(c);\n    }\n\n    public void close() throws IOException {\n        writer.close();\n    }\n\n}", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class A {\n    BufferedReader in;\n    StringTokenizer st;\n    PrintWriter out;\n\n    void solve() throws IOException {\n        int n = nextInt();\n        int k = nextInt();\n        boolean[] sieve = new boolean[n + 1];\n        List<Integer> primes = new ArrayList<Integer>();\n        for (int i = 2; i <= n; ++i) {\n            if (!sieve[i]) {\n                primes.add(i);\n                for (int j = 2 * i; j <= n; j += i) {\n                    sieve[j] = true;\n                }\n            }\n        }\n        int count = 0;\n        for (int i = 0; i + 1 < primes.size(); ++i) {\n            int v = primes.get(i) + primes.get(i + 1) + 1;\n            if (v <= n && !sieve[v]) {\n                ++count;\n            }\n        }\n//        System.err.println(count);\n        out.println(count >= k ? \"YES\" : \"NO\");\n    }\n\n    public void run() throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        eat(\"\");\n        solve();\n        out.close();\n        in.close();\n    }\n\n    void eat(String s) {\n        st = new StringTokenizer(s);\n    }\n\n    String next() throws IOException {\n        while (!st.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) {\n                return null;\n            }\n            eat(line);\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new A().run();\n    }\n}", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.IOException;\nimport java.util.Scanner;\n\n\npublic class A {\n\tpublic static void main(String args[]) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tSystem.out.println((2*n) - (n/2));\n\t\t\n\t}\n\n}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tstatic class Segment {\n\t\tint l, r, id;\n\n\t\tpublic Segment(int l, int r, int id) {\n\t\t\tthis.l = l;\n\t\t\tthis.r = r;\n\t\t\tthis.id = id;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"[l=\" + l + \", r=\" + r + \", id=\" + id + \"]\";\n\t\t}\n\t}\n\n\tstatic Comparator<Segment> byL = (Segment a, Segment b) -> {\n\t\tif (a.l != b.l) {\n\t\t\treturn a.l < b.l ? -1 : 1;\n\t\t}\n\t\treturn Integer.compare(a.id, b.id);\n\t};\n\n\tstatic Comparator<Segment> byR = (Segment a, Segment b) -> {\n\t\tif (a.r != b.r) {\n\t\t\treturn a.r < b.r ? -1 : 1;\n\t\t}\n\t\treturn Integer.compare(a.id, b.id);\n\t};\n\n\tstatic Segment min(Segment a, Segment b, Comparator<Segment> comp) {\n\t\treturn comp.compare(a, b) < 0 ? a : b;\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tSegment[] a = new Segment[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint mid = nextInt();\n\t\t\tint delta = nextInt();\n\t\t\ta[i] = new Segment(mid - delta, mid + delta, i);\n\t\t}\n\t\tArrays.sort(a, byL);\n\t\tSegment[] suffMinR = new Segment[n];\n\t\tsuffMinR[n - 1] = a[n - 1];\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tsuffMinR[i] = min(a[i], suffMinR[i + 1], byR);\n\t\t}\n//\t\tSystem.err.println(Arrays.toString(a) + \"\\n\" + Arrays.toString(suffMinR));\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < n;) {\n\t\t\tSegment pick = suffMinR[i];\n\t\t\tret++;\n\t\t\twhile (i < n && a[i].l < pick.r) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tout.println(ret);\n\t}\n\n\tB() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew B();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "complexity": "nlogn", "problem": "0528_B", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class A_122 {\npublic static void main(String[] args) throws NumberFormatException, IOException {\n\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\tint n = Integer.parseInt(bf.readLine());\n\t  System.out.println((n%4==0||n%7==0||n%47==0||n%74==0||n%447==0||n%474==0||n%477==0||n%744==0||n%747==0||n%774==0)?\"YES\":\"NO\");\n}\n}\n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static void solve(InputReader in, OutputWriter out) {\n        int n = in.nextInt();\n\n        List<List<Integer>> g = new ArrayList<>(n + 1);\n        for (int i = 0; i < n + 1; i++) {\n            g.add(new LinkedList<>());\n        }\n\n        int degree1 = 0, degree2 = 0, root = 0;\n        for (int i = 0; i < n - 1; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n\n            g.get(a).add(b);\n            g.get(b).add(a);\n\n            if (g.get(a).size() > degree1) {\n\n                if (a == root) {\n                    degree1 = g.get(a).size();\n                } else {\n                    degree2 = degree1;\n                    degree1 = g.get(a).size();\n                    root = a;\n                }\n\n            } else if (g.get(a).size() > degree2) {\n                degree2 = g.get(a).size();\n            }\n\n            if (g.get(b).size() > degree1) {\n\n                if (b == root) {\n                    degree1 = g.get(b).size();\n                } else {\n                    degree2 = degree1;\n                    degree1 = g.get(b).size();\n                    root = b;\n                }\n\n            } else if (g.get(b).size() > degree2) {\n                degree2 = g.get(b).size();\n            }\n        }\n\n        if (degree2 > 2) {\n            out.print(\"No\");\n        } else {\n            out.println(\"Yes\");\n\n            List<Integer> leaves = new LinkedList<>();\n            for (int i = 1; i <= n; i++) {\n                if (i != root) {\n                    if (g.get(i).size() == 1) {\n                        leaves.add(i);\n                    }\n                }\n            }\n\n            out.println(leaves.size());\n            for (int i : leaves) {\n                out.println(root + \" \" + i);\n            }\n        }\n    }\n\n    private static void shuffleArray(int[] array) {\n        int index;\n        Random random = new Random();\n        for (int i = array.length - 1; i > 0; i--) {\n            index = random.nextInt(i + 1);\n            if (index != i) {\n                array[index] ^= array[i];\n                array[i] ^= array[index];\n                array[index] ^= array[i];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        solve(in, out);\n        in.close();\n        out.close();\n    }\n\n    private static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        InputReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n            st = null;\n        }\n\n        String nextLine() {\n            String line = null;\n            try {\n                line = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return line;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = nextLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        byte nextByte() {\n            return Byte.parseByte(next());\n        }\n\n        short nextShort() {\n            return Short.parseShort(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class OutputWriter {\n        BufferedWriter bw;\n\n        OutputWriter(OutputStream os) {\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n        }\n\n        void print(int i) {\n            print(Integer.toString(i));\n        }\n\n        void println(int i) {\n            println(Integer.toString(i));\n        }\n\n        void print(long l) {\n            print(Long.toString(l));\n        }\n\n        void println(long l) {\n            println(Long.toString(l));\n        }\n\n        void print(double d) {\n            print(Double.toString(d));\n        }\n\n        void println(double d) {\n            println(Double.toString(d));\n        }\n\n        void print(boolean b) {\n            print(Boolean.toString(b));\n        }\n\n        void println(boolean b) {\n            println(Boolean.toString(b));\n        }\n\n        void print(char c) {\n            try {\n                bw.write(c);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(char c) {\n            println(Character.toString(c));\n        }\n\n        void print(String s) {\n            try {\n                bw.write(s);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(String s) {\n            print(s);\n            print('\\n');\n        }\n\n        void close() {\n            try {\n                bw.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n", "complexity": "linear", "problem": "0981_C", "from": "CODEFORCES", "tags": "implementation,trees"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class P111C{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint h, w;\n\n\tvoid run(){\n\t\th=sc.nextInt();\n\t\tw=sc.nextInt();\n\t\tsolve();\n\t}\n\n\tvoid shuffle(int[] is){\n\t\tRandom rand=new Random();\n\t\tfor(int i=is.length-1; i>=1; i--){\n\t\t\tint j=rand.nextInt(i+1);\n\t\t\tint t=is[i];\n\t\t\tis[i]=is[j];\n\t\t\tis[j]=t;\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tn=w*h;\n\t\tg=new long[n];\n\t\tint[] dx={0, 0, -1, 1};\n\t\tint[] dy={-1, 1, 0, 0};\n\t\tfor(int y=0; y<h; y++){\n\t\t\tfor(int x=0; x<w; x++){\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\tint x2=x+dx[k];\n\t\t\t\t\tint y2=y+dy[k];\n\t\t\t\t\tif(x2>=0&&x2<w&&y2>=0&&y2<h){\n\t\t\t\t\t\tg[y*w+x]|=1L<<(y2*w+x2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcandidate=new int[n];\n\t\txs=new Xorshift();\n\t\tmds=(1L<<n)-1;\n\t\tmds(0, 0, 0);\n\t\tprintln((n-Long.bitCount(mds))+\"\");\n\t}\n\n\tint n;\n\tlong[] g;\n\tlong mds;\n\tint[] candidate;\n\tXorshift xs;\n\n\tvoid mds(long choosed, long removed, long covered){\n\t\tif(Long.bitCount(choosed)>=Long.bitCount(mds))\n\t\t\treturn;\n\t\tif(covered==((1L<<n)-1)){\n\t\t\tif(Long.bitCount(choosed)<Long.bitCount(mds))\n\t\t\t\tmds=choosed;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t{\n\t\t\tlong s=covered;\n\t\t\tfor(long remained=~removed&((1L<<n)-1); remained!=0; remained&=remained-1){\n\t\t\t\tint i=Long.numberOfTrailingZeros(remained);\n\t\t\t\ts|=(1L<<i)|g[i];\n\t\t\t}\n\t\t\tif(s!=((1L<<n)-1)){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n//\t\tint index=0;\n\t\tint k=-1;\n\t\tfor(long remained=~removed&((1L<<n)-1); remained!=0; remained&=remained-1){\n\t\t\tint i=Long.numberOfTrailingZeros(remained);\n\t\t\tif((covered>>>i&1)==1){\n\t\t\t\tif(Long.bitCount(g[i]&~covered)==0){\n\t\t\t\t\tmds(choosed, removed|(1L<<i), covered);\n\t\t\t\t\treturn;\n\t\t\t\t}else if(Long.bitCount(g[i]&~covered)==1\n\t\t\t\t\t\t&&(g[i]&~covered&~removed)!=0){\n\t\t\t\t\tmds(choosed, removed|(1L<<i), covered);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(Long.bitCount(g[i]&~removed)==0){\n\t\t\t\t\tmds(choosed|(1L<<i), removed|(1L<<i), covered|(1L<<i)|g[i]);\n\t\t\t\t\treturn;\n\t\t\t\t}else if(Long.bitCount(g[i]&~removed)==1\n\t\t\t\t\t\t&&((g[i]&~removed)|(g[i]&~covered))==(g[i]&~removed)){\n\t\t\t\t\tint j=Long.numberOfTrailingZeros(g[i]&~removed);\n\t\t\t\t\tmds(choosed|(1L<<j), removed|(1L<<i)|(1L<<j), covered\n\t\t\t\t\t\t\t|(1L<<j)|g[j]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t if(k==-1||Long.bitCount(g[i]&~covered)>Long.bitCount(g[k]&~covered))\n\t\t\t k=i;\n\t\t\t /*\n\t\t\tif(k==-1||Long.bitCount(g[i]&~covered)>Long.bitCount(g[k]&~covered)){\n\t\t\t\tindex=0;\n\t\t\t\tcandidate[index++]=i;\n\t\t\t\tk=i;\n\t\t\t}else if(Long.bitCount(g[i]&~covered)==Long.bitCount(g[k]&~covered)){\n\t\t\t\tcandidate[index++]=i;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tif(k==-1)\n\t\t\treturn;\n\n\t\t// k=candidate[xs.nextInt(index)];\n\n\t\tmds(choosed|(1L<<k), removed|(1L<<k), covered|(1L<<k)|g[k]);\n\t\tmds(choosed, removed|(1L<<k), covered);\n\t}\n\n\tclass Xorshift{\n\n\t\tint x, y, z, w;\n\n\t\tpublic Xorshift(){\n\t\t\tx=123456789;\n\t\t\ty=362436069;\n\t\t\tz=521288629;\n\t\t\tw=88675123;\n\t\t}\n\n\t\tpublic Xorshift(int seed){\n\t\t\tx=_(seed, 0);\n\t\t\ty=_(x, 1);\n\t\t\tz=_(y, 2);\n\t\t\tw=_(z, 3);\n\t\t}\n\n\t\tint _(int s, int i){\n\t\t\treturn 1812433253*(s^(s>>>30))+i+1;\n\t\t}\n\n\t\t// 32bit signed\n\t\tpublic int nextInt(){\n\t\t\tint t=x^(x<<11);\n\t\t\tx=y;\n\t\t\ty=z;\n\t\t\tz=w;\n\t\t\treturn w=w^(w>>>19)^t^(t>>>8);\n\t\t}\n\n\t\t// error = O(n*2^-32)\n\t\tpublic int nextInt(int n){\n\t\t\treturn (int)(n*nextDouble());\n\t\t}\n\n\t\t// [0, 1) (53bit)\n\t\tpublic double nextDouble(){\n\t\t\tint a=nextInt()>>>5, b=nextInt()>>>6;\n\t\t\treturn (a*67108864.0+b)*(1.0/(1L<<53));\n\t\t}\n\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args){\n\t\tLocale.setDefault(Locale.US);\n\t\tnew P111C().run();\n\t}\n\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.util.Map;\nimport java.io.IOException;\nimport java.util.TreeMap;\nimport java.util.InputMismatchException;\nimport java.io.PrintStream;\nimport java.io.OutputStream;\nimport java.util.ArrayDeque;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Queue;\nimport java.util.Collection;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author karan173\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskB\n{\n    int val[];\n    int p[];\n    int aneigh[], bneight[], deg[];\n    public void solve(int testNumber, FastReader in, PrintWriter out)\n    {\n        int n = in.ni ();\n        val = new int[n];\n        int a = in.ni ();\n        int b = in.ni ();\n        Map<Integer, Integer> set = new TreeMap<Integer, Integer> ();\n        p = in.iArr (n);\n        for (int i = 0; i < n; i++)\n        {\n            set.put (p[i], i);\n        }\n        aneigh = new int[n];\n        bneight = new int[n];\n        deg = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            aneigh[i] = val[i] = bneight[i] = -1;\n            deg[i] = 0;\n        }\n        Queue<Integer> queue = new ArrayDeque<Integer> ();\n        for (int i = 0; i < n; i++)\n        {\n            Integer x1 = set.get (a - p[i]);\n            Integer x2 = set.get (b - p[i]);\n            if (x1 != null)\n            {\n                aneigh[i] = x1;\n                deg[i]++;\n            }\n            if (x2 != null && a != b)\n            {\n                bneight[i] = x2;\n                deg[i]++;\n            }\n            if (deg[i] == 1)\n            {\n                queue.add (i);\n            }\n        }\n\n        while (!queue.isEmpty ())\n        {\n            int idx = queue.remove ();\n            if (deg[idx] != 1)\n            {\n                continue;\n            }\n            int aa = aneigh[idx];\n            int bb = bneight[idx];\n            if (aa != -1)\n            {\n                val[idx] = val[aa] = 0;\n                deg[aa]--;\n                deg[idx]--;\n                aneigh[aa] = -1;\n                aneigh[idx] = -1;\n                if (deg[aa] == 1)\n                {\n                    int zz = bneight[aa];\n                    bneight[zz] = -1;\n                    deg[zz]--;\n                    if(deg[zz] == 1)\n                    queue.add (zz);\n                }\n            }\n            else\n            {\n                val[idx] = val[bb] = 1;\n                deg[bb]--;\n                deg[idx]--;\n                bneight[idx] = bneight[bb] = -1;\n                if (deg[bb] == 1)\n                {\n                    //queue.add (bb);\n                    int zz = aneigh[bb];\n                    aneigh[zz] = -1;\n                    deg[zz]--;\n                    if(deg[zz] == 1)\n                        queue.add (zz);\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++)\n        {\n            if (val[i] == -1 && cantBePaired(i))\n            {\n                out.println (\"NO\");\n                return;\n            }\n        }\n        //every person has two neighbours\n\n        out.println (\"YES\");\n        for (int i = 0; i < n; i++)\n        {\n            out.print (val[i] + \" \");\n        }\n        out.println ();\n    }\n\n    private boolean cantBePaired(int i)\n    {\n        int aa = aneigh[i];\n        int bb = bneight[i];\n        if (aa != -1 && val[aa] == -1)\n        {\n            return false;\n        }\n        if (bb != -1 && val[bb] == -1)\n        {\n            return false;\n        }\n        return true;\n    }\n}\n\nclass FastReader\n{\n\n    public InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public FastReader(InputStream stream)\n    {\n        this.stream = stream;\n    }\n\n    public FastReader()\n    {\n\n    }\n\n    public int read()\n    {\n        if (numChars == -1)\n        {\n            throw new InputMismatchException ();\n        }\n        if (curChar >= numChars)\n        {\n            curChar = 0;\n            try\n            {\n                numChars = stream.read (buf);\n            } catch (IOException e)\n            {\n                throw new InputMismatchException ();\n            }\n            if (numChars <= 0)\n            {\n                return -1;\n            }\n        }\n        return buf[curChar++];\n    }\n\n    public int ni()\n    {\n        int c = read ();\n        while (isSpaceChar (c))\n            c = read ();\n        int sgn = 1;\n        if (c == '-')\n        {\n            sgn = -1;\n            c = read ();\n        }\n        int res = 0;\n        do\n        {\n            if (c < '0' || c > '9')\n            {\n                throw new InputMismatchException ();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read ();\n        } while (!isSpaceChar (c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c)\n    {\n        if (filter != null)\n        {\n            return filter.isSpaceChar (c);\n        }\n        return isWhitespace (c);\n    }\n\n    public static boolean isWhitespace(int c)\n    {\n        return c==' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int[] iArr(int n)\n    {\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = ni ();\n        }\n        return a;\n    }\n\n    public interface SpaceCharFilter\n    {\n        public boolean isSpaceChar(int ch);\n    }\n}\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class A {\n\n\tprivate BufferedReader in;\t\n\tprivate StringTokenizer st;\n\t\n\t\n\tvoid solve() throws IOException{\n\t\t\n\t\tint len = 0;\n\t\tString x = next();\n\t\tHashSet<String> h = new HashSet<String>();\n\t\tfor (int i = 0; i < x.length(); i++) {\n\t\t\tfor (int j = i+1; j <= x.length(); j++) {\n\t\t\t\tString y = x.substring(i,j);\n\t\t\t\tif(h.contains(y)){\n\t\t\t\t\tif(y.length()>len) len = y.length();\n\t\t\t\t}\n\t\t\t\telse h.add(y);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(len);\n\t\t\n\t}\n\tA() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\t\t\t\n\t\teat(\"\");\n\t\tsolve();\t\t\t\n\t}\n\t\n\tprivate void eat(String str) {\n\t\tst = new StringTokenizer(str);\n\t}\n\n\tString next() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\teat(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\n\tpublic static void main(String[] args) throws IOException {\t\t\n\t\t\n\t\tnew A();\n\t}\n\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class virtual1{\n\n    static InputReader in = new InputReader();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) {\n            long x = in.nextLong();\n            long k = in.nextLong();\n            long mod = (long)1e9+7l;\n            //out.println(mod);\n            long mul1 = 1;\n            long mul2 = 2*x-1;\n            mul2 = mul2%mod;\n            long pow = k;\n            long to = 2;\n            while(pow>0l){\n                if(pow%2l==1l){\n                    mul1 = mul1*to;\n                    mul1%=mod;\n                }\n                to=to*to;\n                to%=mod;\n                pow = pow/2l;\n            }\n            mul1 = mul1*mul2;\n            mul1%=mod;\n            mul1+=1;\n            if(x!=0)\n            out.println(mul1%mod);\n            else\n            out.println(0);\n        \n        out.close();    \n    }\n\n    static class InputReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public InputReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\n\npublic class CF1209E2 {\n    public static void main(String[] args) throws Exception {\n        boolean local = System.getSecurityManager() == null;\n        boolean async = false;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"dalt\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            int t = io.readInt();\n            while (t-- > 0)\n                solve();\n        }\n\n        int[][] prefix = new int[12][1 << 12];\n        int[][] profits = new int[12][1 << 12];\n        Col[] cols = new Col[2000];\n\n        {\n            for (int i = 0; i < 2000; i++) {\n                cols[i] = new Col(12);\n            }\n        }\n\n        public void solve() {\n            int n = io.readInt();\n            int m = io.readInt();\n\n            for (int i = 0; i < m; i++) {\n                cols[i].max = 0;\n                cols[i].n = n;\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    cols[j].data[i] = io.readInt();\n                    cols[j].max = Math.max(cols[j].max, cols[j].data[i]);\n                }\n            }\n\n            Arrays.sort(cols, 0, m, (a, b) -> -(a.max - b.max));\n            Col[] cols = Arrays.copyOf(this.cols, Math.min(m, n));\n\n            int mask = (1 << n) - 1;\n            SubsetGenerator sg = new SubsetGenerator();\n            SubsetGenerator2 sg2 = new SubsetGenerator2();\n            BitOperator bo = new BitOperator();\n            for (int i = 0; i < cols.length; i++) {\n                Arrays.fill(profits[i], 0);\n                for (int j = 0; j < n; j++) {\n                    cols[i].rotate();\n                    for (int k = 0; k < n; k++) {\n                        sg2.values[k] = cols[i].data[k];\n                    }\n                    sg2.setSet(mask);\n                    while (sg2.hasNext()) {\n                        profits[i][sg2.next] = Math.max(profits[i][sg2.next], sg2.val);\n                        sg2.next();\n                    }\n                }\n            }\n\n            prefix[0] = profits[0];\n            for (int i = 1; i < cols.length; i++) {\n                for (int j = 0; j <= mask; j++) {\n                    sg.setSet(j);\n                    prefix[i][j] = prefix[i - 1][j];\n                    while (sg.hasNext()) {\n                        int next = sg.next();\n                        prefix[i][j] = Math.max(prefix[i][j],\n                                profits[i][next] + prefix[i - 1][j ^ next]);\n                    }\n                }\n            }\n\n            io.cache.append(prefix[cols.length - 1][mask]).append('\\n');\n        }\n    }\n\n\n    /**\n     * Bit operations\n     */\n    public static class BitOperator {\n        public int bitAt(int x, int i) {\n            return (x >> i) & 1;\n        }\n\n        public int bitAt(long x, int i) {\n            return (int) ((x >> i) & 1);\n        }\n\n        public int setBit(int x, int i, boolean v) {\n            if (v) {\n                x |= 1 << i;\n            } else {\n                x &= ~(1 << i);\n            }\n            return x;\n        }\n\n        public long setBit(long x, int i, boolean v) {\n            if (v) {\n                x |= 1L << i;\n            } else {\n                x &= ~(1L << i);\n            }\n            return x;\n        }\n\n        /**\n         * Determine whether x is subset of y\n         */\n        public boolean subset(long x, long y) {\n            return intersect(x, y) == x;\n        }\n\n        /**\n         * Merge two set\n         */\n        public long merge(long x, long y) {\n            return x | y;\n        }\n\n        public long intersect(long x, long y) {\n            return x & y;\n        }\n\n        public long differ(long x, long y) {\n            return x - intersect(x, y);\n        }\n    }\n\n    public static class SubsetGenerator2 {\n        private int[] meanings = new int[33];\n        private int[] values = new int[33];\n        private int[] bits = new int[33];\n        private int remain;\n        private int next;\n        private int val;\n\n        public void setSet(int set) {\n            int bitCount = 0;\n            while (set != 0) {\n                meanings[bitCount] = set & -set;\n                bits[bitCount] = 0;\n                set -= meanings[bitCount];\n                bitCount++;\n            }\n            remain = 1 << bitCount;\n            next = 0;\n            val = 0;\n        }\n\n        public boolean hasNext() {\n            return remain > 0;\n        }\n\n        private void consume() {\n            remain = remain - 1;\n            int i;\n            for (i = 0; bits[i] == 1; i++) {\n                bits[i] = 0;\n                next -= meanings[i];\n                val -= values[i];\n            }\n            bits[i] = 1;\n            next += meanings[i];\n            val += values[i];\n        }\n\n        public int next() {\n            int returned = next;\n            consume();\n            return returned;\n        }\n    }\n\n    public static class SubsetGenerator {\n        private int[] meanings = new int[33];\n        private int[] bits = new int[33];\n        private int remain;\n        private int next;\n\n        public void setSet(int set) {\n            int bitCount = 0;\n            while (set != 0) {\n                meanings[bitCount] = set & -set;\n                bits[bitCount] = 0;\n                set -= meanings[bitCount];\n                bitCount++;\n            }\n            remain = 1 << bitCount;\n            next = 0;\n        }\n\n        public boolean hasNext() {\n            return remain > 0;\n        }\n\n        private void consume() {\n            remain = remain - 1;\n            int i;\n            for (i = 0; bits[i] == 1; i++) {\n                bits[i] = 0;\n                next -= meanings[i];\n            }\n            bits[i] = 1;\n            next += meanings[i];\n        }\n\n        public int next() {\n            int returned = next;\n            consume();\n            return returned;\n        }\n    }\n\n    public static class Col {\n        int[] data;\n        int max;\n        int n;\n\n        public void rotate() {\n            int end = data[n - 1];\n            System.arraycopy(data, 0, data, 1, n - 1);\n            data[0] = end;\n        }\n\n        public Col(int n) {\n            data = new int[n];\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder(1 << 13);\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() throws IOException {\n            os.write(cache.toString().getBytes(charset));\n            os.flush();\n            cache.setLength(0);\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}\n", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\nimport java.math.*;\n\n\n\n\n\n\n\npublic class Main{\n\n\t\n\n\tpublic static void main(String[] Args) throws Exception {\n\n\t     Scanner sc = new Scanner(new FileReader(\"input.txt\"));\n\n\t     int n,m,k;\n\n\t     Integer lx,ly;\n\n\t     boolean d[][];\n\n\t     n = sc.nextInt(); m = sc.nextInt(); k = sc.nextInt();\n\n\t     d = new boolean [n+1][m+1];\n\n\t     for(int i=0;i<=n;++i)\n\n\t      for(int j=0;j<=m;++j)\n\n\t       d[i][j]=false;\n\n\t     \n\n\t     Queue< pair > q = new LinkedList< pair >();\n\n\t     lx = ly = -1;\n\n\t     for(int i=0;i<k;++i){\n\n\t     \tint x,y; x = sc.nextInt(); y = sc.nextInt();\n\n\t     \tq.add(new pair(x,y)); lx = x; ly = y;\n\n\t     \td[x][y]=true;\n\n\t     }\n\n\t     \n\n\t     int dx [] = {0,0,1,-1};\n\n\t     int dy [] = {-1,1,0,0};\n\n\t     \n\n\t     \n\n\t     while(!q.isEmpty()){\n\n\t     \t pair tp = q.remove();\n\n\t     \t int x = tp.x; int y = tp.y;\n\n\t     \t for(int i=0;i<4;++i){\n\n\t     \t \t int nx = x+dx[i]; int ny = y+dy[i];\n\n\t     \t \t if(nx<1 || nx>n || ny<1 || ny>m || d[nx][ny] ) continue;\n\n\t     \t     d[nx][ny]=true;\n\n\t     \t     q.add(new pair(nx,ny));\n\n\t     \t     lx = nx; ly = ny;\n\n\t     \t }\n\n\t     }\n\n\t     FileWriter fw = new FileWriter(\"output.txt\");\n\n\t     fw.write(lx.toString()); fw.write(\" \"); fw.write(ly.toString());;\n\n\t     fw.flush();\n\n\t     \t\n\n\t}\n\n}\n\nclass pair {\n\n\n\n  public int x,y;\n\n  public pair(int _x,int _y){ x = _x; y = _y; }\n\n\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.*;\nimport java.lang.*;\n\npublic class A {\n    public static void main(String[] args) {\n        // getting the inputs\n        Scanner in = new Scanner(System.in);\n        long l = in.nextLong();\n        long r = in.nextLong();\n        // printing the output\n        new Solver().solve(l, r);\n    }\n}\n\nclass Solver {\n    public void solve(long l, long r) {  \n        if(r-l==1 || r-l==0) {\n            System.out.println(-1);\n            return;\n        }\n        if(r-l==2 && l%2!=0) {\n            System.out.println(-1);\n            return;\n        }\n        // long i;\n        // long a = l, b = l+1, c = l+2;\n\n        // while(a < r-2) {\n        //     b = a+1;\n        //     while(b < r-1) {\n        //         c = b+1;\n        //         while(c < r) {\n        //             if(gcd(a,c) != 1 && gcd(a,b) == 1 && gcd(b,c) == 1) {\n        //                 System.out.println(a + \" \" + b + \" \" + c);\n        //                 return;\n        //             }\n        //             c++;\n        //         }\n        //         b++;\n        //     }\n        //     a++;\n        // }\n        if(l % 2 == 0) System.out.println(l + \" \" + (l+1) + \" \" + (l+2));\n        else System.out.println((l+1) + \" \" + (l+2) + \" \" + (l+3));\n    }\n    \n    // public long gcd(long a, long b) {\n    //     if(a == b) return -1;\n    //     long i;\n    //     long ans = 1;\n    //     for(i = 1; i < Math.max(a, b); i++) {\n    //         if(a%i==0 && b%i==0) ans = i;\n    //         if(ans > 1) return -1;\n    //     }\n    //     return ans;\n    // }\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "//package compressionandexpansion;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class compressionandexpansion {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader fin = new BufferedReader(new InputStreamReader(System.in));\n\t\tint t = Integer.parseInt(fin.readLine());\n\t\tStringBuilder fout = new StringBuilder();\n\t\twhile(t-- > 0) {\n\t\t\tArrayList<Integer> s = new ArrayList<Integer>();\n\t\t\tint n = Integer.parseInt(fin.readLine());\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint next = Integer.parseInt(fin.readLine());\n\t\t\t\tif(next == 1) {\n\t\t\t\t\ts.add(1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twhile(s.get(s.size() - 1) != next - 1) {\n\t\t\t\t\t\ts.remove(s.size() - 1);\n\t\t\t\t\t}\n\t\t\t\t\ts.set(s.size() - 1, next);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < s.size(); j++) {\n\t\t\t\t\tfout.append(s.get(j));\n\t\t\t\t\tif(j != s.size() - 1) {\n\t\t\t\t\t\tfout.append(\".\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfout.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(fout);\n\t}\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\n\npublic class Main {\n    static double max = 0.0;\n    public static void main(String[] args) {\n        Scanner r = new Scanner(System.in);\n        \n        int n = r.nextInt();\n        int k = r.nextInt();\n        int A = r.nextInt();\n        \n        Person[] p = new Person[n];\n        \n        for(int i = 0; i < n; i++){         \n            int l = r.nextInt();\n            int prob = r.nextInt();\n            \n            p[i] = new Person(l, prob);\n        }\n        \n        int[] add = new int[n];\n        \n        double res = dfs(0, k, p, add, n, A);\n        \n        System.out.println(res);\n        \n    }\n    private static double dfs(int ptr, int k, Person[] p, int[] add, int n, int A) {\n        if(k < 0)return 0;\n        \n        double res1 = 0;\n        for(int m = 0; m < 1<<n; m++){\n            double win = 1;\n            int cnt = 0;\n            for(int i = 0; i < n; i++){\n                if((m & (1 << i)) == 0){\n                    win *= (100-(p[i].p+add[i]))*1.0/100;\n                }else{\n                    win *= (add[i]+p[i].p)*1.0/100;                 \n                    cnt++;\n                }\n            }\n\n            if(cnt > n/2){\n                res1 += win; \n            }else{\n                int B = 0;\n                for(int i = 0; i < n; i++){\n                    if((m & (1 << i)) == 0){\n                        B += p[i].l;\n                    }\n                }\n                \n                win *= A*1.0/(A+B);\n                                \n                res1 += win; \n            }\n        }\n        \n        double res2 = 0, res3 = 0;\n        \n        if(add[ptr]+p[ptr].p < 100){\n            add[ptr] += 10;\n            res2 = dfs(ptr, k-1, p, add, n, A);\n            add[ptr] -= 10;\n        }\n        if(ptr+1 < n){\n            res3 = dfs(ptr+1, k, p, add, n, A);\n        }\n        \n        return Math.max(res1, Math.max(res2, res3));\n    }\n}\nclass Person{\n    int l, p;\n    public Person(int li, int pi){\n        l = li;\n        p = pi;\n    }\n    public String toString(){\n        return String.format(\"[%d, %d]\", l, p);\n    }\n}", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class D1_958 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        Point[] P = new Point[N];\n        for (int n=0; n<N; n++) {\n            P[n] = normalize(in.next());\n        }\n        Map<Point, Integer> map = new HashMap<>();\n        for (Point p : P) {\n            int count = map.getOrDefault(p, 0);\n            count++;\n            map.put(p, count);\n        }\n        StringBuilder output = new StringBuilder();\n        for (Point p : P) {\n            int count = map.get(p);\n            output.append(count).append(' ');\n        }\n        System.out.println(output);\n    }\n\n    static Point normalize(String s) {\n        int idx = s.indexOf('/');\n        int down = Integer.parseInt(s.substring(idx+1));\n        s = s.substring(1,idx-1);\n        idx = s.indexOf('+');\n        int left = Integer.parseInt(s.substring(0,idx));\n        int right = Integer.parseInt(s.substring(idx+1));\n        int up = left + right;\n        int gcd = gcd(up, down);\n        up /= gcd;\n        down /= gcd;\n        return new Point(up, down);\n    }\n\n    static int gcd(int a, int b) {\n        return (b == 0) ? a : gcd(b, a%b);\n    }\n\n}\n", "complexity": "linear", "problem": "0958_D1", "from": "CODEFORCES", "tags": "expression parsing,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            if (n > 32) {\n                out.println(m);\n            } else {\n                int pow = (int) Math.pow(2, n);\n                out.println(m % pow);\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\t\n\tvoid solve() throws Exception {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint a [] = new int [n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tif (k >= m) {\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint sum = k;\n\t\tfor (int j = n - 1; j >= 0; j--) {\n\t\t\tsum--;\n\t\t\tsum += a[j];\n\t\t\tif (sum >= m) {\n\t\t\t\tout.println((n - j));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(-1);\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tFastScanner sc;\n\n\tstatic Throwable uncaught;\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsc = new FastScanner(in);\n\t\t\tsolve();\n\t\t} catch (Throwable t) {\n\t\t\tSolution.uncaught = t;\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Throwable {\n\t\tThread t = new Thread(null, new Solution(), \"\", (1 << 26));\n\t\tt.start();\n\t\tt.join();\n\t\tif (uncaught != null) {\n\t\t\tthrow uncaught;\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n\n\tBufferedReader reader;\n\tStringTokenizer strTok;\n\n\tpublic FastScanner(BufferedReader reader) {\n\t\tthis.reader = reader;\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\twhile (strTok == null || !strTok.hasMoreTokens()) {\n\t\t\tstrTok = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn strTok.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n}", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "\n\nimport java.io.PrintWriter;\n\nimport java.util.*;\nimport java.util.Arrays ; \nimport java .lang.String.* ;\nimport java .lang.StringBuilder ;\n\n\npublic class Test{\n    static int pos = 0 ; \n    static int  arr[] ; \n  static LinkedList l1 = new  LinkedList() ; \nstatic void find(int p ,char[]x,int put[],String s){\n    int c= 0 ; \n    for (int i = 0; i < s.length(); i++) {\n        if(x[p]==s.charAt(i)){\n        c++ ; }\n    }\n    put[p] = c ;  \n}\nstatic int mode(int m ,int[]x ){\n    int temp = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return m-temp ; \n             \n        }\n    }\n     return m-temp ; \n}\nstatic int mode2(int m ,int[]x ){\n    int temp = 0 ; \n    \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return x[i] ; \n             \n        }\n    }\n     return 0 ; \n}\nstatic int find(int x[],int temp){\n    int j = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]==temp) return j+1 ; \n        j++ ; \n    }\n    return -1 ; \n}\nstatic String ch(long[]x,long b){\n    for (int i = 0; i < x.length; i++) {\n        if(x[i]==b)return \"YES\" ;\n    }\n    return \"NO\" ; \n}\n\n    public static void main(String[] args)  {\n\n        Scanner in = new Scanner(System.in) ;\n        PrintWriter pw = new PrintWriter(System.out);   \n     int k=in.nextInt(), n=in.nextInt(), s=in.nextInt(), p=in.nextInt() ;\n     int paper =n/s; \n     if(n%s!=0) paper++ ; \n     paper*=k ; \n     int fin = paper/p ; \n     if(paper%p!=0) fin++ ; \n        System.out.println( fin );\n       \n       \n }               \n}\n\n", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "\nimport java.util.Scanner;\n\n\npublic class composite {\n\n  \n    public static void main(String[] args) {\n        int b;\n        Scanner s3=new Scanner(System.in);\n         b=s3.nextInt();\n      \n          if(b%2==0)\n          {\n              b=b-4;\n              System.out.println(4+\" \"+b);\n          }\n          else\n          {\n              b=b-9;\n              System.out.println(9+\" \"+b);\n          }\n      \n    \n}\n}", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.text.DecimalFormat;\nimport java.io.*;\nimport java.util.*;\nimport java.lang.reflect.Array;\n\n/**\n * @author Mukesh Singh\n *\n */\n\n\npublic class AB {\n\n    private InputStream input;\n    private PrintStream output;\n    private Scanner inputSc;\n\n    public AB(InputStream input, PrintStream output) {\n        this.input = input;\n        this.output = output;\n        init();\n    }\n\n    private void init() {\n        inputSc = new Scanner(input);\n    }\n\n    static int lineToInt(String line) {\n        return Integer.parseInt(line);\n    }\n\n    static long lineToLong(String line) {\n        return Long.parseLong(line);\n    }\n    static double lineToDouble(String line) {\n        return Double.parseDouble(line);\n    }\n\n\n    public void solve() \n\t{\n            solveTestCase();\n    }\n\n/**\n * @define global / instance variables \n */\n\n\tHashMap<Integer,Integer> mat ;\n\tlong dist[] ;\n\tint vec[] ;\n\tint ar[] ;\n\tSet<Integer> st ;\n\tboolean isDone[] ;\n\tfinal long INF = 100000000000000000L ;\n/**\n * @solve test case \n */\n@SuppressWarnings(\"unchecked\")\n   private void solveTestCase() \n\t{\n\t\tint i , j  , k , n , m , d , l ,b  , p , q , r;\n\t\tlong N , M, K;\n\t\tint x1 , y1 , x2 , y2 ,x;\n\t\tint a1,a2,b1,b2,a ;\n\t\tDecimalFormat df = new DecimalFormat(\"#,###,##0.00\");\n        String str = inputSc.nextLine();\n        String delims = \"[ ]+\";\n\t\tString tokens[] = str.split(delims);\n\t\tn = lineToInt(tokens[0]);\n\t\ta = lineToInt(tokens[1]);\n\t\tb = lineToInt(tokens[2]);\n\t\tmat = new HashMap<Integer,Integer>() ;\n\t\tst = new TreeSet<Integer>();\n\t\tar = new int[n+4] ;\n\t\tvec = new int[n+4] ;\n\t\tstr = inputSc.nextLine();\n\t\ttokens = str.split(delims);\n\t\tfor( i = 1 ; i <= n ; i++ )\n\t\t{\n\t\t\tar[i] = lineToInt(tokens[i-1]);\n\t\t\tmat.put(ar[i],i) ;\n\t\t\tst.add(ar[i]);\n\t\t\tvec[i] = i ;\n\t\t}\n\t\tvec[n+1] = n+1 ;\n\t\tvec[n+2] = n+2 ;\n\t\tfor( i = 1 ; i <= n ; i++ )\n\t\t{\n\t\t\tx= ar[i];\n\t\t\n\t\t\tif(st.contains(a-x))\n\t\t\t{\n\t\t\t\tBing(mat.get(x),mat.get(a-x));\n\t\t\t}\n\t\t\telse\n\t\t\t\tBing(n+1 , mat.get(x));\n\t\t\tif(st.contains(b-x))\n\t\t\t{\n\t\t\t\tBing(mat.get(x),mat.get(b-x));\n\t\t\t}\n\t\t\telse\n\t\t\t\tBing(n+2 , mat.get(x));\n\t\t} \n\t\tif(find(n+1)==find(n+2))\n\t\t{\n\t\t\toutput.println(\"NO\");\n\t\t\treturn ;\n\t\t}\n\t\toutput.println(\"YES\");\n\t\tfor( i =1 ;  i<= n  ; i ++ )\n\t\t{\n\t\t\tif(find(i)==find(n+1))\n\t\t\t\toutput.print(\"1 \");\n\t\t\telse \n\t\t\t\toutput.print(\"0 \");\n\t\t}\n\t\toutput.println();\n\t\t\n\t}\n\tint find(int x)\n{\n\tif(x==vec[x]) return x;\n\treturn vec[x]=find(vec[x]);\n}\n\nvoid Bing(int a,int b)\n{\n\tint A=find(a);int B=find(b);\n\tif(A==B) return ;\n\tvec[B]=A;\n}\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) \n\t{\n\t\tFileInputStream in = null;\n      \tFileOutputStream out = null;\n\t\tPrintStream ps = null ;\n\t\tInputStream is = null ;\n\t\ttry \n\t\t{\n         \tis = new FileInputStream(\"file.in\");\n         \tout = new FileOutputStream(\"file.out\");\n\t\t\tps = new PrintStream(out);\n        }\n\t\tcatch ( Exception e )\n\t\t{}\n\n        AB sd = new AB(System.in, System.out);\n        sd.solve();\n\t\ttry\n\t\t{\n        if (is != null) \n\t\t{\n\t      is.close();\n\t    }\n       \tif (out != null) {\n           \tout.close();\n       \t}\n\t\tif (ps != null) {\n           \tps.close();\n         }\n      \t}catch (Exception e){}\n\n\t\t//SquareDetector sd = new SquareDetector(System.in, System.out);\n        //sd.solve();\n    }\n}\n   \n\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.util.Scanner;\n\npublic class Seq2 {\n\n    static void metod() {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = in.nextInt();\n\n        int min = a[0];\n        for (int i = 1; i < a.length; i++) {\n            if (a[i] < min)\n                min = a[i];\n        }\n        \n        int min2 = min;\n        boolean t = false;\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] != min) {\n                if (!t) {\n                    min2 = a[i];\n                    t = true;\n                } else {\n                    if (min2 > a[i])\n                        min2 = a[i];\n                }\n            }\n        }\n\n        System.out.println((min == min2) ? \"NO\" : min2);        \n    }\n\n    public static void main(String[] args) {\n        Seq2.metod();\n    }\n}", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Test {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 1024 * 48);\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        String str = br.readLine();\n        StringTokenizer st = new StringTokenizer(str, \" \");\n        long x = Long.parseLong(st.nextToken());\n        long k = Long.parseLong(st.nextToken());\n        if (x == 0) {\n            bw.write(0 + \"\\n\");\n        } else {\n            int power = power(k, 1000000007);\n            long answer = (((power * 2) % 1000000007) * (x % 1000000007)) % 1000000007;\n            answer -= power - 1;\n            answer = (answer + 1000000007) % 1000000007;\n            bw.write(answer + \"\\n\");\n        }\n        bw.flush();\n    }\n\n    public static int power(long a, int m) {\n        if (a == 0) {\n            return 1;\n        }\n        long pow = power(a / 2, m);\n        if (a % 2 == 1) {\n            return (int)(((pow * pow) % m) * 2) % m;\n        } else {\n            return (int)((pow * pow) % m);\n        }\n    }\n}\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.*;\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        int k = input.nextInt() - 1 ;\n        int a[][] = new int[n][2];\n        for (int i = 0;i <n; i++) {\n            a[i][0]=input.nextInt();\n            a[i][1]=input.nextInt();\n        }\n        for (int i = 0; i<n; i++) {\n            for (int j=i+1; j<n; j++) {\n                if (a[i][0]<a[j][0]) {\n                    int x=a[i][0];\n                    int y=a[i][1];\n                    a[i][0]=a[j][0];\n                    a[i][1]=a[j][1];\n                    a[j][0]=x;\n                    a[j][1]=y;\n                    \n                }\n            }\n        }\n        for (int i = 0; i<n; i++) {\n            for (int j=i+1; j<n; j++) {\n                if ((a[i][1]>a[j][1])&&(a[i][0]==a[j][0])) {\n                    int x=a[i][0];\n                    int y=a[i][1];\n                    a[i][0]=a[j][0];\n                    a[i][1]=a[j][1];\n                    a[j][0]=x;\n                    a[j][1]=y;\n                    \n                }\n            }\n        }\n        int x = a[k][0];\n        int y = a[k][1];\n        int s = 0;\n        for (int i = 0; i<n; i++) {\n            if ((a[i][0]==x)&&(a[i][1]==y)) {\n                s++;\n            }\n        }\n        System.out.println(s);\n    }\n}\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Task {\n\n    public static void solve() throws Exception {\n\tint n = nextInt();\n\tint[] S = new int[n];\n\tfor(int i=0;i<n;i++) {\n\t    S[i] = nextInt();\n\t    if(i > 0) {\n\t\tS[i] += S[i-1];\n\t    }\n\t}\n\tMap<Integer, List<L>> map = new HashMap<>();\n\tfor(int j=0;j<n;j++) {\n\t    for(int i=j;i>=0;i--) {\n\t\tint sum = S[j];\n\t\tif(i > 0) {\n\t\t    sum -= S[i-1];\n\t\t}\n\t\tL l = new L();\n\t\tl.a = i;\n\t\tl.b = j;\n\t\tList<L> list = map.get(sum);\n\t\tif(list == null) {\n\t\t    list = new ArrayList<>();\n\t\t    map.put(sum, list);\n\t\t}\n\t\tlist.add(l);\n\t    }\n\t}\n\tList<L> longest = null;\n\tfor(Integer sum: map.keySet()) {\n\t    List<L> list = map.get(sum);\n\t    Collections.sort(list);\n\t    List<L> list2 = new ArrayList<>(list.size());\n\t    int from = list.get(0).a;\n\t    for(L l: list) {\n\t\tif(l.a >= from) {\n\t\t    list2.add(l);\n\t\t    from = l.b + 1;\n\t\t}\n\t    }\n\t    if(longest == null || longest.size() < list2.size()) {\n\t\tlongest = list2;\n\t    }\n\t}\n\t\n\tprintln(longest.size());\n\tfor(int i=0;i<longest.size();i++) {\n\t    L l = longest.get(i);\n\t    println((l.a+1) + \" \" + (l.b+1));\n\t}\n    }\n    \n    private static class L implements Comparable<L>{\n\tint a;\n\tint b;\n\t\n\t@Override\n\tpublic int compareTo(L l2) {\n\t    return Integer.valueOf(b).compareTo(l2.b);\n\t}\n    }\n    \n    public static void main(String[] args) throws Exception {\n\ttry {\n\t    fastReader = new FastReader(System.in);\n\t    systemOut = new BufferedOutputStream(System.out);\n\t    solve();\n\t} finally {\n\t    systemOut.close();\n\t}\n    }\n\n    private static FastReader fastReader = null;\n    private static BufferedOutputStream systemOut = null;\n\n    public static void print(Object obj) {\n\tprint(obj.toString());\n    }\n\n    public static void print(String str) {\n\ttry {\n\t    systemOut.write(str.getBytes(\"utf-8\"));\n\t} catch (Exception ex) {\n\t    throw new RuntimeException(ex);\n\t}\n    }\n\n    public static void println(Object obj) {\n\tprintln(obj.toString());\n    }\n\n    public static void println(String str) {\n\ttry {\n\t    print(str);\n\t    systemOut.write('\\n');\n\t} catch (Exception ex) {\n\t    throw new RuntimeException(ex);\n\t}\n    }\n\n    public static String next() {\n\treturn fastReader.readNextToken(false);\n    }\n\n    public static String nextLine() {\n\treturn fastReader.readNextToken(true);\n    }\n\n    public static int nextInt() {\n\treturn Integer.parseInt(fastReader.readNextToken(false));\n    }\n\n    public static long nextLong() {\n\treturn Long.parseLong(fastReader.readNextToken(false));\n    }\n\n    public static double nextDouble() {\n\treturn Double.parseDouble(fastReader.readNextToken(false));\n    }\n\n    static class FastReader {\n\tprivate byte[] buf = new byte[65536];\n\tprivate int ind = 0;\n\tprivate int maxInd = -1;\n\tprivate InputStream is = null;\n\tprivate boolean eof = false;\n\tprivate boolean lastCharRead = false;\n\n\tpublic FastReader(InputStream is) {\n\t    this.is = is;\n\t}\n\n\tpublic String readNextToken(boolean endOfLine) {\n\t    try {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean found = false;\n\t\twhile (true) {\n\t\t    if (lastCharRead) {\n\t\t\treturn null;\n\t\t    } else if (ind > maxInd) {\n\t\t\tif (eof) {\n\t\t\t    lastCharRead = true;\n\t\t\t} else {\n\t\t\t    fillBuffer();\n\t\t\t}\n\t\t    }\n\t\t    byte b = '\\n';\n\t\t    if (!lastCharRead) {\n\t\t\tb = buf[ind++];\n\t\t    }\n\n\t\t    if (b == '\\r') {\n\t\t\t// ignore\n\t\t    } else if ((b == '\\n' && endOfLine) || (Character.isWhitespace(b) && !endOfLine)) {\n\t\t\tif (found) {\n\t\t\t    break;\n\t\t\t}\n\t\t    } else {\n\t\t\tsb.append((char) b);\n\t\t\tfound = true;\n\t\t    }\n\t\t}\n\t\treturn sb.toString();\n\t    } catch (Exception ex) {\n\t\tthrow new RuntimeException(ex);\n\t    }\n\t}\n\n\tprivate void fillBuffer() {\n\t    try {\n\t\tint read = is.read(buf, 0, buf.length);\n\t\tif (read < buf.length) {\n\t\t    eof = true;\n\t\t}\n\t\tind = 0;\n\t\tmaxInd = read - 1;\n\t    } catch (Exception ex) {\n\t\tthrow new RuntimeException(ex);\n\t    }\n\t}\n    }\n\n    public static class LST {\n\tpublic long[][] set;\n\tpublic int n;\n\n\tpublic LST(int n) {\n\t    this.n = n;\n\t    int d = 1;\n\t    for (int m = n; m > 1; m >>>= 6, d++)\n\t\t;\n\n\t    set = new long[d][];\n\t    for (int i = 0, m = n >>> 6; i < d; i++, m >>>= 6) {\n\t\tset[i] = new long[m + 1];\n\t    }\n\t}\n\n\t// [0,r)\n\tpublic LST setRange(int r) {\n\t    for (int i = 0; i < set.length; i++, r = r + 63 >>> 6) {\n\t\tfor (int j = 0; j < r >>> 6; j++) {\n\t\t    set[i][j] = -1L;\n\t\t}\n\t\tif ((r & 63) != 0)\n\t\t    set[i][r >>> 6] |= (1L << r) - 1;\n\t    }\n\t    return this;\n\t}\n\n\t// [0,r)\n\tpublic LST unsetRange(int r) {\n\t    if (r >= 0) {\n\t\tfor (int i = 0; i < set.length; i++, r = r + 63 >>> 6) {\n\t\t    for (int j = 0; j < r + 63 >>> 6; j++) {\n\t\t\tset[i][j] = 0;\n\t\t    }\n\t\t    if ((r & 63) != 0)\n\t\t\tset[i][r >>> 6] &= ~((1L << r) - 1);\n\t\t}\n\t    }\n\t    return this;\n\t}\n\n\tpublic LST set(int pos) {\n\t    if (pos >= 0 && pos < n) {\n\t\tfor (int i = 0; i < set.length; i++, pos >>>= 6) {\n\t\t    set[i][pos >>> 6] |= 1L << pos;\n\t\t}\n\t    }\n\t    return this;\n\t}\n\n\tpublic LST unset(int pos) {\n\t    if (pos >= 0 && pos < n) {\n\t\tfor (int i = 0; i < set.length && (i == 0 || set[i - 1][pos] == 0L); i++, pos >>>= 6) {\n\t\t    set[i][pos >>> 6] &= ~(1L << pos);\n\t\t}\n\t    }\n\t    return this;\n\t}\n\n\tpublic boolean get(int pos) {\n\t    return pos >= 0 && pos < n && set[0][pos >>> 6] << ~pos < 0;\n\t}\n\n\tpublic LST toggle(int pos) {\n\t    return get(pos) ? unset(pos) : set(pos);\n\t}\n\n\tpublic int prev(int pos) {\n\t    for (int i = 0; i < set.length && pos >= 0; i++, pos >>>= 6, pos--) {\n\t\tint pre = prev(set[i][pos >>> 6], pos & 63);\n\t\tif (pre != -1) {\n\t\t    pos = pos >>> 6 << 6 | pre;\n\t\t    while (i > 0)\n\t\t\tpos = pos << 6 | 63 - Long.numberOfLeadingZeros(set[--i][pos]);\n\t\t    return pos;\n\t\t}\n\t    }\n\t    return -1;\n\t}\n\n\tpublic int next(int pos) {\n\t    for (int i = 0; i < set.length && pos >>> 6 < set[i].length; i++, pos >>>= 6, pos++) {\n\t\tint nex = next(set[i][pos >>> 6], pos & 63);\n\t\tif (nex != -1) {\n\t\t    pos = pos >>> 6 << 6 | nex;\n\t\t    while (i > 0)\n\t\t\tpos = pos << 6 | Long.numberOfTrailingZeros(set[--i][pos]);\n\t\t    return pos;\n\t\t}\n\t    }\n\t    return -1;\n\t}\n\n\tprivate static int prev(long set, int n) {\n\t    long h = set << ~n;\n\t    if (h == 0L)\n\t\treturn -1;\n\t    return -Long.numberOfLeadingZeros(h) + n;\n\t}\n\n\tprivate static int next(long set, int n) {\n\t    long h = set >>> n;\n\t    if (h == 0L)\n\t\treturn -1;\n\t    return Long.numberOfTrailingZeros(h) + n;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t    List<Integer> list = new ArrayList<Integer>();\n\t    for (int pos = next(0); pos != -1; pos = next(pos + 1)) {\n\t\tlist.add(pos);\n\t    }\n\t    return list.toString();\n\t}\n    }\n}\n", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.util.*;\n\nimport java.io.*;\n\nimport java.math.*;\n\npublic class Main {\n\n    public static InputStream IN;\n\n    public static OutputStream OUT;\n\n    public static PrintWriter out;\n\n    public static BufferedReader in;\n\n    \n\n    public static StringTokenizer st = null;\n\n    public static int ni() throws Exception {\n\n        for (;st == null || !st.hasMoreTokens();){\n\n            st = new StringTokenizer(in.readLine());\n\n        }\n\n        return Integer.parseInt(st.nextToken());\n\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        IN = new FileInputStream(\"input.txt\");\n\n        OUT = new FileOutputStream(\"output.txt\");\n\n        out = new PrintWriter(OUT);\n\n        in = new BufferedReader(new InputStreamReader(IN));\n\n        int n = ni();\n\n        int m = ni();\n\n        int k = ni();\n\n        int[] x = new int[k];\n\n        int[] y = new int[k];\n\n        for (int i = 0 ; i < k; i++){\n\n            x[i] = ni() - 1;\n\n            y[i] = ni() - 1;\n\n        }\n\n        int w = Integer.MIN_VALUE;\n\n        int aa = -1;\n\n        int ab = -1;\n\n        for (int i = 0 ; i < n ; i++){\n\n            for (int j = 0; j < m; j++){\n\n                int min = Integer.MAX_VALUE;\n\n                for (int q = 0; q < k; q++){\n\n                    int cur = Math.abs(i - x[q]) + Math.abs(j - y[q]);\n\n                    min = Math.min(cur, min);\n\n                }\n\n                if (min > w){\n\n                    w = min;\n\n                    aa = i;\n\n                    ab = j;\n\n                }\n\n            }\n\n        }\n\n        out.println((aa + 1) + \" \" + (ab + 1));\n\n        \n\n        out.flush();\n\n    }\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\n\n// Solution\n\npublic class Main \n{    \n  public static void main (String[] argv) \n  {\n\t  new Main();\n  } \n     \n     \n  \n  boolean test = false;  \n  \n  \n  \n  public Main()  {\n\t  FastReader in = new FastReader(new BufferedReader(new InputStreamReader(System.in)));\n\t  //FastReader in = new FastReader(new BufferedReader(new FileReader(\"Main.in\")));\n      int n = in.nextInt();\n      int nM = 0;\n      int[] nS = new int[4];\n      int[] nL = new int[4];\n      for (int i = 0; i < n; i++) {\n          String s = in.next();\n          int ns = s.length();\n          if (s.charAt(0) == 'M') nM++;\n          else if (s.charAt(ns - 1) == 'S') nS[ns-1]++;\n          else nL[ns-1]++;\n      }\n      int c = 0;\n      int[] nSr = new int[4];\n      int[] nLr = new int[4];\n      int nMr = 0;\n      for (int i = 0; i < n; i++) {\n          String s = in.next();\n          int ns = s.length();\n          if (s.charAt(0) == 'M') {\n              if (nM > 0) --nM;\n              else ++nMr;\n          }else if (s.charAt(ns - 1) == 'S') {\n              if (nS[ns-1] > 0) --nS[ns-1];\n              else ++nSr[ns-1];\n          }else {\n              if (nL[ns-1] > 0) --nL[ns-1];\n              else ++nLr[ns-1];\n          }     \n      }\n      \n      for (int i = 0; i < 4; i++) c += nS[i] + nL[i];\n      c += nM;\n      \n      System.out.println(c);\n  }\n  \n  \n  \n \n  \n  private int nBit1(int v) {\n      int v0 = v;\n      int c = 0;\n      while (v != 0) {\n          ++c;\n          v = v & (v - 1);\n      }\n      return c;\n  }\n  \n  private int common(int v) {\n      int c = 0;\n      while (v != 1) {\n          v = (v >>> 1);\n          ++c;\n      }\n      \n      return c;\n  }\n  \n  private void reverse(char[] a, int i, int j) {\n      while (i < j) {\n          swap(a, i++, j--);\n      }\n  }\n  \n  private void swap(char[] a, int i, int j) {\n      char t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n  }\n  \n  \n  private long gcd(long x, long y) {\n      if (y == 0) return x;\n      return gcd(y, x % y);\n  }\n  private int max(int a, int b) {\n      return a >  b ? a : b;\n  }\n  \n  private int min(int a, int b) {\n      return a >  b ? b : a;\n  }\n  \n  \n  static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader(BufferedReader in)\n        {            \n            br = in;\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    String line = br.readLine();\n                    if (line == null || line.length() == 0) return \"\";\n                    st = new StringTokenizer(line);\n                }\n                catch (IOException  e)\n                {\n                    return \"\";\n                    //e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                return \"\";\n                //e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "\nimport java.util.Scanner;\n\npublic class three {\n    static boolean check;\n\n    public static void main(String[] args) {\n        check = true;\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        String s = n + \"\";\n        recurse(n, s.length(), \"4\");\n        if (!check)\n            System.out.println(\"YES\");\n        else {\n            recurse(n, s.length(), \"7\");\n            if (!check)\n                System.out.println(\"YES\");\n            else\n                System.out.println(\"NO\");\n        }\n    }\n\n    private static void recurse(int n, int length, String string) {\n        int k = Integer.parseInt(string);\n        if (n % k == 0) {\n            check = false;\n        } else if (string.length() <= length && check) {\n            recurse(n, length, string + \"4\");\n            recurse(n, length, string + \"7\");\n        }\n\n    }\n}", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint n = ir.nextInt();\n\t\tint t = ir.nextInt();\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ir.nextIntArray(2);\n\t\tlong[] f = fact(15);\n\t\tlong res = 0;\n\t\tfor (int i = 0; i < 1 << n; i++) {\n\t\t\tint[] ct = new int[4];\n\t\t\tint tot = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (((1 << j) & i) != 0) {\n\t\t\t\t\ttot += a[j][0];\n\t\t\t\t\tct[a[j][1]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tot != t)\n\t\t\t\tcontinue;\n\t\t\tlong[][][][] dp = new long[ct[1] + 1][ct[2] + 1][ct[3] + 1][4];\n\t\t\tdp[0][0][0][0] = 1;\n\t\t\tfor (int j = 0; j < ct[1] + ct[2] + ct[3]; j++) {\n\t\t\t\tfor (int k = 0; k <= ct[1]; k++) {\n\t\t\t\t\tfor (int l = 0; l <= ct[2]; l++) {\n\t\t\t\t\t\tif (k + l > j || j - k - l > ct[3])\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int m = 0; m <= 3; m++) {\n\t\t\t\t\t\t\tfor (int o = 0; o <= 3; o++) {\n\t\t\t\t\t\t\t\tif (m == o)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif (o == 1 && k == ct[1])\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif (o == 2 && l == ct[2])\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif (o == 3 && j - k - l == ct[3])\n\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t\tif (o == 1) {\n\t\t\t\t\t\t\t\t\tdp[k + 1][l][j - k - l][1] = add(dp[k + 1][l][j - k - l][1],\n\t\t\t\t\t\t\t\t\t\t\tdp[k][l][j - k - l][m]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (o == 2) {\n\t\t\t\t\t\t\t\t\tdp[k][l + 1][j - k - l][2] = add(dp[k][l + 1][j - k - l][2],\n\t\t\t\t\t\t\t\t\t\t\tdp[k][l][j - k - l][m]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (o == 3) {\n\t\t\t\t\t\t\t\t\tdp[k][l][j - k - l + 1][3] = add(dp[k][l][j - k - l + 1][3],\n\t\t\t\t\t\t\t\t\t\t\tdp[k][l][j - k - l][m]);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int m = 0; m <= 3; m++)\n\t\t\t\tres = add(res, mul(mul(f[ct[1]], f[ct[2]]), mul(f[ct[3]], dp[ct[1]][ct[2]][ct[3]][m])));\n\t\t}\n\t\tout.println(res);\n\t}\n\n\tstatic long mod = (long) 1e9 + 7;\n\n\tstatic long add(long a, long b) {\n\t\treturn (a + b) % mod;\n\t}\n\n\tstatic long sub(long a, long b) {\n\t\tlong d = a - b;\n\t\twhile (d < 0)\n\t\t\td += mod;\n\t\treturn d;\n\t}\n\n\tstatic long mul(long a, long b) {\n\t\treturn a * b % mod;\n\t}\n\n\tstatic long div(long a, long b) {\n\t\treturn a * mod_inverse(b) % mod;\n\t}\n\n\tprivate static long[] fact(int n) {\n\t\tlong[] ret = new long[n + 1];\n\t\tret[0] = 1 % mod;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tret[i] = mul(ret[i - 1], i);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate static long[] factInv(int n) {\n\t\tlong[] ret = new long[n + 1];\n\t\tret[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tret[i] = div(ret[i - 1], i);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static long comb(int n, int m, long[] fact, long[] factInv) {\n\t\tlong ret = fact[n];\n\t\tret = mul(ret, factInv[m]);\n\t\tret = mul(ret, factInv[n - m]);\n\t\treturn ret;\n\t}\n\n\tpublic static long[][] stirling(int n) {\n\t\tlong[][] ret = new long[n + 1][n + 1];\n\t\tret[0][0] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tret[i][j] = add(ret[i - 1][j - 1], mul(ret[i - 1][j], j));\n\t\treturn ret;\n\t}\n\n\tpublic static long mod_inverse(long a) {\n\t\tlong[] ret = extgcd(a, mod);\n\t\treturn add(mod, ret[0] % mod);\n\t}\n\n\tpublic static long[] extgcd(long a, long b) {\n\t\tlong[] ret = new long[3];\n\t\tret[2] = _extgcd(a, b, ret);\n\t\treturn ret;\n\t}\n\n\tprivate static long _extgcd(long a, long b, long[] x) {\n\t\tlong g = a;\n\t\tx[0] = 1;\n\t\tx[1] = 0;\n\t\tif (b != 0) {\n\t\t\tg = _extgcd(b, a % b, x);\n\t\t\tlong temp = x[0];\n\t\t\tx[0] = x[1];\n\t\t\tx[1] = temp;\n\t\t\tx[1] -= (a / b) * x[0];\n\t\t}\n\t\treturn g;\n\t}\n\n\tstatic long modpow(long a, long n) {\n\t\tlong res = 1;\n\t\twhile (n > 0) {\n\t\t\tif ((n & 1) != 0)\n\t\t\t\tres = res * a % mod;\n\t\t\ta = a * a % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class C2 {\n    String filename = null;\n    InputReader sc;\n\n    void solve() {\n        int n = sc.nextInt();\n        int[] a = sc.nextArray(n);\n\n        int[] ps = new int[n];\n        int[] q = new int[n];\n        int[] qs = new int[n];\n        int nq = 0;\n        for (int i = 1; i < n; i++) {\n            if (a[i] == 1) {\n                qs[nq] = i - 1;\n                q[nq++] = a[i - 1] + 1;\n                ps[i] = i - 1;\n            } else {\n                if (a[i] == a[i - 1] + 1) {\n                    qs[nq] = i - 1;\n                    q[nq++] = 1;\n                    ps[i] = i - 1;\n                } else {\n                    for (int j = nq - 1; j >= 0; j--) {\n                        if (a[i] == q[j]) {\n                            ps[i] = qs[j];\n                            nq = j;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        int[] parents = ps;\n        String[] strs = new String[n];\n        strs[0] = \"1\";\n        System.out.println(strs[0]);\n        for (int i = 1; i < n; i++) {\n            String p = strs[parents[i]];\n            if (a[i] == 1) {\n                strs[i] = p + \".1\";\n            } else {\n                int lastDot = p.lastIndexOf(\".\");\n                if (lastDot == -1) {\n                    strs[i] = a[i] + \"\";\n                } else {\n                    strs[i] = p.substring(0, lastDot) + \".\" + a[i];\n                }\n            }\n            System.out.println(strs[i]);\n        }\n    }\n\n    public void run() throws FileNotFoundException {\n        if (filename == null) {\n            sc = new InputReader(System.in);\n        } else {\n            sc = new InputReader(new FileInputStream(new File(filename)));\n        }\n\n        int nTests = sc.nextInt();\n        for (int test = 0; test < nTests; test++) {\n            solve();\n        }\n    }\n\n    public static void main(String[] args) {\n        C2 sol = new C2();\n        try {\n            sol.run();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        public double nextDouble() {\n            return Float.parseFloat(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int[] nextArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n    }\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n\t\n\tvoid randomShuffle(int[] arr) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = arr.length - 1; i >= 0; i--) {\n\t\t\tint pos = rnd.nextInt(i + 1);\n\t\t\tint temp = arr[pos];\n\t\t\tarr[pos] = arr[i];\n\t\t\tarr[i] = temp;\n\t\t}\n\t}\n\t\n\tvoid solve() throws Exception {\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] ac = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = ac[i] = sc.nextInt();\n\t\t}\n\t\trandomShuffle(ac);\n\t\tArrays.sort(ac);\n\t\tint diff = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] != ac[i]) {\n\t\t\t\tdiff++;\n\t\t\t}\n\t\t}\n\t\tif (diff <= 2) {\n\t\t\tout.println(\"YES\");\n\t\t} else {\n\t\t\tout.println(\"NO\");\n\t\t}\n\t}\n\t\n\tBufferedReader in;\n\tPrintWriter out;\n\tFastScanner sc;\n\t\n\tstatic Throwable uncaught;\n\t\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsc = new FastScanner(in);\n\t\t\tsolve();\n\t\t} catch (Throwable t) {\n\t\t\tMain.uncaught = t;\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Throwable {\n\t\tThread t = new Thread(null, new Main(), \"\", 128 * 1024 * 1024);\n\t\tt.start();\n\t\tt.join();\n\t\tif (uncaught != null) {\n\t\t\tthrow uncaught;\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n\t\n\tBufferedReader reader;\n\tStringTokenizer strTok;\n\t\n\tpublic FastScanner(BufferedReader reader) {\n\t\tthis.reader = reader;\n\t}\n\t\n\tpublic String nextToken() throws IOException {\n\t\twhile (strTok == null || !strTok.hasMoreTokens()) {\n\t\t\tstrTok = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn strTok.nextToken();\n\t}\n\t\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\t\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\t\n}", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic long mod = 1000000007;\n\tstatic int INF = 1000000000;\n \tpublic static void main(String[] args){\n\t\tFastScanner scanner = new FastScanner();\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tString s = scanner.next();\n\t\tint[][] cnt = new int[20][20];\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tcnt[s.charAt(i)-'a'][s.charAt(i+1)-'a']++;\n\t\t\tcnt[s.charAt(i+1)-'a'][s.charAt(i)-'a']++;\n\t\t}\n\t\t//dp[i]:= \u6587\u5b57\u5217i(\u3053\u306e\u4e2d\u306b\u540c\u4e00\u6587\u5b57\u306f\u542b\u307e\u308c\u306a\u3044)\u3092\u4f5c\u3063\u305f\u6642\u306e\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\n\t\tint[] dp = new int[(1<<m)];\n\t\tfor(int i = 0; i < (1<<m); i++){\n\t\t\tdp[i] = INF;\n\t\t}\n\t\tdp[0] = 0;\n\t\tfor(int i = 0; i < (1<<m); i++){\n\t\t\tint cost = 0;\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tif((i>>j & 1) == 0){\n\t\t\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\t\t\tif((~i>>k & 1) == 0){\n\t\t\t\t\t\t\tcost += cnt[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tdp[i|1<<j] = Math.min(dp[i|1<<j],dp[i]+cost);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[(1<<m)-1]);\n\t}\n\tstatic class BIT{\n\t\tint n;\n\t\tint[] bit;\n\t\tpublic BIT(int n){\n\t\t\tthis.n = n;\n\t\t\tbit = new int[n+1];\n\t\t}\n\t\tvoid add(int idx, int val){\n\t\t\tfor(int i = idx+1; i <= n; i += i&(-i)) bit[i-1] += val;\n\t\t}\n\t\tint sum(int idx){\n\t\t\tint res = 0;\n\t\t\tfor(int i = idx+1; i > 0; i -= i&(-i)) res += bit[i-1];\n\t\t\treturn res;\n\t\t}\n\t\tint sum(int begin, int end){\n\t\t\tif(begin == 0) return sum(end);\n\t\t\treturn sum(end)-sum(begin-1);\n\t\t}\n\t}\n\tstatic class Pair implements Comparable<Pair>{\n    int first, second;\n    Pair(int a, int b){\n        first = a;\n        second = b;\n    }\n    @Override\n    public boolean equals(Object o){\n        if (this == o) return true;\n        if (!(o instanceof Pair)) return false;\n        Pair p = (Pair) o;\n        return first == p.first && second == p.second;\n    }\n    @Override\n    public int compareTo(Pair p){\n        return first == p.first ? second - p.second : first - p.first; //first\u3067\u6607\u9806\u306b\u30bd\u30fc\u30c8\n        //return (first == p.first ? second - p.second : first - p.first) * -1; //first\u3067\u964d\u9806\u306b\u30bd\u30fc\u30c8\n        //return second == p.second ? first - p.first : second - p.second;//second\u3067\u6607\u9806\u306b\u30bd\u30fc\u30c8\n        //return (second == p.second ? first - p.first : second - p.second)*-1;//second\u3067\u964d\u9806\u306b\u30bd\u30fc\u30c8\n\t\t    //return first * 1.0 / second > p.first * 1.0 / p.second ? 1 : -1; // first/second\u306e\u6607\u9806\u306b\u30bd\u30fc\u30c8\n\t\t    //return first * 1.0 / second < p.first * 1.0 / p.second ? 1 : -1; // first/second\u306e\u964d\u9806\u306b\u30bd\u30fc\u30c8\n\t\t\t\t//return second * 1.0 / first > p.second * 1.0 / p.first ? 1 : -1; // second/first\u306e\u6607\u9806\u306b\u30bd\u30fc\u30c8\n\t\t    //return second * 1.0 / first < p.second * 1.0 / p.first ? 1 : -1; // second/first\u306e\u964d\u9806\u306b\u30bd\u30fc\u30c8\n\t\t\t\t//return Math.atan2(second, first) > Math.atan2(p.second, p.first) ? 1 : -1; // second/first\u306e\u6607\u9806\u306b\u30bd\u30fc\u30c8\n\t\t\t\t//return first + second > p.first + p.second ? 1 : -1; //first+second\u306e\u6607\u9806\u306b\u30bd\u30fc\u30c8\n\t\t\t\t//return first + second < p.first + p.second ? 1 : -1; //first+second\u306e\u964d\u9806\u306b\u30bd\u30fc\u30c8\n\t\t\t\t//return first - second < p.first - p.second ? 1 : -1; //first-second\u306e\u964d\u9806\u306b\u30bd\u30fc\u30c8\n\t\t}\n  }\n\n\tprivate static class FastScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\t\tif (ptr < buflen) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t}else{\n\t\t\t\t\t\tptr = 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t}\n\t\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\t\tpublic String next() {\n\t\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tint b = readByte();\n\t\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\t\t\tb = readByte();\n\t\t\t\t}\n\t\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\t\tlong n = 0;\n\t\t\t\tboolean minus = false;\n\t\t\t\tint b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\t\tminus = true;\n\t\t\t\t\t\tb = readByte();\n\t\t\t\t}\n\t\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\t\t\t\tn *= 10;\n\t\t\t\t\t\t\t\tn += b - '0';\n\t\t\t\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb = readByte();\n\t\t\t\t}\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\t\tlong nl = nextLong();\n\t\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\t\t\treturn (int) nl;\n\t\t}\n\t\tpublic double nextDouble() { return Double.parseDouble(next());}\n\t}\n}\n", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "\nimport java.util.*;\nimport java.io.*;\n\npublic class A{\n    \n    static int N, M, K;\n    static String s;\n    static StringTokenizer st;\n    static int[] d;\n    \n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        \n        PrintWriter out = new PrintWriter(System.out);\n        \n        int[][] d = new int[5][3];\n        int[][] d2 = new int[5][3];\n        \n        int N = Integer.parseInt(br.readLine());\n        for (int i = 0; i < N; i++) {\n            String r = br.readLine();\n            int len = r.length();\n            int fin = 0;\n            if(r.charAt(r.length()-1) == 'S')\n                fin = 0;\n            if(r.charAt(r.length()-1) == 'M')\n                fin = 1;\n            if(r.charAt(r.length()-1) == 'L')\n                fin = 2;\n            d[len][fin]++;\n        }\n        \n        for (int i = 0; i < N; i++) {\n            String r = br.readLine();\n            int len = r.length();\n            int fin = 0;\n            if(r.charAt(r.length()-1) == 'S')\n                fin = 0;\n            if(r.charAt(r.length()-1) == 'M')\n                fin = 1;\n            if(r.charAt(r.length()-1) == 'L')\n                fin = 2;\n            d2[len][fin]++;\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < d.length; i++) {\n            int sum = 0;\n            int sum2 = 0;\n            for (int j = 0; j < d[0].length; j++) {\n                sum += d[i][j];\n                sum2 += d2[i][j];\n                ans += Math.max(0, d2[i][j] - d[i][j]);\n            }\n            \n        }\n        System.out.println(ans);\n        out.close();\n    }    \n}\n", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.util.*;\npublic class A\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\t\n\t\tif(n % 2 == 1)\n\t\t{\n\t\t\tSystem.out.println(9 + \" \" + (n - 9));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.println(4 + \" \" + (n - 4));\n\t\t}\n\t}\n}\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\nimport static java.lang.Math.*;\n \n/* spar5h */\n \npublic class cf1 implements Runnable {   \n\t\n\tstatic void addMap(int curr, HashMap<Integer, Integer> map, HashMap<Integer, Integer>[] hm, int j) {\n\t\t\n\t\tint prev = 0;\n\t\t\n\t\tif(map.get(curr) != null)\n\t\t\tprev = map.get(curr);\n\t\t\n\t\tint val = 0;\n\t\t\n\t\tif(hm[j].get(curr) != null)\n\t\t\tval = hm[j].get(curr);\n\t\t\n\t\tif(prev + 1 <= val)\n\t\t\treturn;\n\t\t\n\t\thm[j].put(curr, prev + 1);\n\t}\n\t\n\tpublic void run() {\n\t\t\n\t\tInputReader s = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\n\t\tint n = s.nextInt();\n\t\t\n\t\tint[] a = new int[n];\n\t\t\n\t\tHashMap<Integer, Integer>[] hm = new HashMap[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ta[i] = s.nextInt();\n\t\t\thm[i] = new HashMap<Integer, Integer>();\n\t\t}\n\t\t\n\t\tHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\n\t\t\tint curr = 0;\n\t\t\t\n\t\t\tfor(int j = i; j < n; j++) {\n\t\t\t\tcurr += a[j];\n\t\t\t\taddMap(curr, map, hm, j);\n\t\t\t}\n\t\t\t\n\t\t\tfor(Map.Entry<Integer, Integer> e : hm[i].entrySet()) {\n\t\t\t\t\n\t\t\t\tif(map.get(e.getKey()) != null && map.get(e.getKey()) >= e.getValue())\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tmap.put(e.getKey(), e.getValue());\n\t\t\t}\n\t\t}\n\t\t\n\t\tint key = -1;\n\t\tint value = 0;\n\t\t\n\t\tfor(Map.Entry<Integer, Integer> e : map.entrySet()) {\n\t\t\t\n\t\t\tif(e.getValue() > value) {\n\t\t\t\tkey = e.getKey(); value = e.getValue();\n\t\t\t}\n\t\t}\n\t\t\n\t\tw.println(value);\n\t\t\n\t\tint prev = -1;\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\n\t\t\tint curr = 0;\n\t\t\t\n\t\t\tfor(int j = i; j > prev; j--) {\n\t\t\t\t\n\t\t\t\tcurr += a[j];\n\t\t\t\t\n\t\t\t\tif(curr == key) {\n\t\t\t\t\tw.println((j + 1) + \" \" + (i + 1));\n\t\t\t\t\tprev = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tw.close();\n\t}\n\t\n\tstatic class InputReader {\n\t\t\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\t\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\tpublic int read() {\n\t\t\t\n\t\t\tif (numChars==-1) \n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\n\t\t\tif (curChar >= numChars) {\n\t\t\t\t\n\t\t\t\tcurChar = 0;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\treturn buf[curChar++];\n\t\t}\n\t\t \n\t\tpublic String nextLine() {\n\t\t\t\n\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString str = \"\";\n\t        \n\t\t\ttry {\n\t            str = br.readLine();\n\t        }\n\t        catch (IOException e) {\n\t            e.printStackTrace();\n\t        }\n\t\t\t\n\t        return str;\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile(isSpaceChar(c)) \n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\t\n\t\t\tdo {\n\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\t\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tlong res = 0;\n\t\t\t\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() {\n\t\t\t\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tdouble res = 0;\n\t\t\t\n\t\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\t\t\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tif (c == '.') {\n\t\t\t\t\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() {\n\t\t\t\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\t\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\n\t\t\treturn res.toString();\n\t\t}\n\t \n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\t\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t \n\t\tpublic String next() {\n\t\t\treturn readString();\n\t\t}\n\t\t\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t\n\t}\n \n\tpublic static void main(String args[]) throws Exception {\n\t\tnew Thread(null, new cf1(),\"cf1\",1<<26).start();\n\t}\n} ", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n \n \n \npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\t\n\tstatic int oo = (int)1e9;\n\tstatic int mod = 1000000007;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint n = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tArrays.sort(a);\n\t\tboolean[] color = new boolean[n];\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(!color[i]) {\n\t\t\t\tcnt++;\n\t\t\t\tfor(int j = i; j < n; j++) {\n\t\t\t\t\tif(a[j] % a[i] == 0)\n\t\t\t\t\t\tcolor[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(cnt);\n\t\t\n\t\tout.close();\n\t}\n\t\n\t\n\tstatic class SegmentTree {\n\t\tint n;\n\t\tlong[] a, seg;\n\t\tint DEFAULT_VALUE = 0;\n\t\t\n\t\tpublic SegmentTree(long[] a, int n) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.n = n;\n\t\t\tseg = new long[n * 4 + 1];\n\t\t\tbuild(1, 0, n-1);\n\t\t}\n\t\t\n\t\tprivate long build(int node, int i, int j) {\n\t\t\tif(i == j)\n\t\t\t\treturn seg[node] = a[i];\n\t\t\tlong first = build(node * 2, i, (i+j) / 2);\n\t\t\tlong second = build(node * 2 + 1, (i+j) / 2 + 1, j);\n\t\t\treturn seg[node] = combine(first, second);\n\t\t}\n\t\t\n\t\tlong update(int k, long value) {\n\t\t\treturn update(1, 0, n-1, k, value);\n\t\t}\n\t\t\n\t\tprivate long update(int node, int i, int j, int k, long value) {\n\t\t\tif(k < i || k > j)\n\t\t\t\treturn seg[node];\n\t\t\tif(i == j && j == k) {\n\t\t\t\ta[k] = value;\n\t\t\t\tseg[node] = value;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t\n\t\t\tint m = (i + j) / 2;\n\t\t\tlong first = update(node * 2, i, m, k, value);\n\t\t\tlong second = update(node * 2 + 1, m + 1, j, k, value);\n\t\t\treturn seg[node] = combine(first, second);\n\t\t}\n\t\t\n\t\tlong query(int l, int r) {\n\t\t\treturn query(1, 0, n-1, l, r);\n\t\t}\n\t\t\n\t\tprivate long query(int node, int i, int j, int l, int r) {\n\t\t\tif(l <= i && j <= r)\n\t\t\t\treturn seg[node];\n\t\t\tif(j < l || i > r)\n\t\t\t\treturn DEFAULT_VALUE;\n\t\t\tint m = (i + j) / 2;\n\t\t\tlong first = query(node * 2, i, m, l, r);\n\t\t\tlong second = query(node * 2 + 1, m+1, j, l, r);\n\t\t\treturn combine(first, second);\n\t\t}\n \n\t\tprivate long combine(long a, long b) {\n\t\t\treturn a + b;\n\t\t}\n\t}\n\t\n\tstatic class DisjointSet {\n\t\tint n;\n\t\tint[] g;\n\t\tint[] h;\n\t\tpublic DisjointSet(int n) {\n\t\t\tsuper();\n\t\t\tthis.n = n;\n\t\t\tg = new int[n];\n\t\t\th = new int[n];\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = i;\n\t\t\t\th[i] = 1;\n\t\t\t}\n\t\t}\n\t\tint find(int x) {\n\t\t\tif(g[x] == x)\n\t\t\t\treturn x;\n\t\t\treturn g[x] = find(g[x]);\n\t\t}\n\t\tvoid union(int x, int y) {\n\t\t\tx = find(x); y = find(y);\n\t\t\tif(x == y)\n\t\t\t\treturn;\n\t\t\tif(h[x] >= h[y]) {\n\t\t\t\tg[y] = x;\n\t\t\t\tif(h[x] == h[y])\n\t\t\t\t\th[x]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg[x] = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tstatic int[] getPi(char[] a) {\n\t\tint m = a.length;\n\t\tint j = 0;\n\t\tint[] pi = new int[m];\n\t\tfor(int i = 1; i < m; ++i) {\n\t\t\twhile(j > 0 && a[i] != a[j])\n\t\t\t\tj = pi[j-1];\n\t\t\tif(a[i] == a[j]) {\n\t\t\t\tpi[i] = j + 1;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn pi;\n\t}\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class D {\n\t\n\tpublic void solve(Scanner in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\tint[] a = new int[n + 1];\n\t\tfor(int i = 1; i <= n; ++i) a[i] = in.nextInt();\n\t\t\n\t\tint[] rangeInv = new int[n + 1];\n\n\t\tBIT bit = new BIT(n + 1);\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tint cur = a[i];\n\t\t\tint inv = (int) bit.sum(cur, n);\n\t\t\trangeInv[i] = rangeInv[i - 1] + inv;\n\t\t\tbit.add(cur, 1);\n\t\t}\n\t\t\n\t\tint m = in.nextInt();\n\t\tint curTotal = rangeInv[n];\n\t\t\n\t\tfor(int qq = 0; qq < m; ++qq) {\n\t\t\tint l = in.nextInt();\n\t\t\tint r = in.nextInt();\n\t\t\t\n\t\t\tint N = r - l + 1;\n\t\t\tint total = N * (N - 1) / 2;\n\t\t\t\n\t\t\tint cur = rangeInv[r] - rangeInv[l - 1];\n\t\t\t\n\t\t\tint newInv = total - cur;\n\t\t\t\n\t\t\tcurTotal -= cur;\n\t\t\tcurTotal += newInv;\n\t\t\t\n\t\t\tif(curTotal % 2 == 0) {\n\t\t\t\tout.println(\"even\");\n\t\t\t} else {\n\t\t\t\tout.println(\"odd\");\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tnew D().solve(in, out);\n\n\t\tin.close();\n\t\tout.close();\n\t}\n\t\n\tclass BIT {\n\n\t    long[] tree;\n\t    int n;\n\n\t    public BIT(int n) {\n\t        this.n = n;\n\t        tree = new long[n + 1];\n\t    }\n\n\t    public void add(int i, long val)\n\t    {\n\t        while(i <= n)\n\t        {\n\t            tree[i] += val;\n\t            i += i & -i;\n\t        }\n\t    }\n\n\t    public long sum(int to)\n\t    {\n\t        long res = 0;\n\t        for(int i = to; i >= 1; i -= (i & -i))\n\t        {\n\t            res += tree[i];\n\t        }\n\t        return res;\n\t    }\n\n\t    public long sum(int from, int to) {\n\t        return sum(to) - sum(from - 1);\n\t    }\n\t}\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class D implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew D().run();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tboolean eof;\n\t\tString buf;\n\n\t\tpublic FastScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t\tnextToken();\n\t\t}\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(stream));\n\t\t\tnextToken();\n\t\t}\n\n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\teof = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString ret = buf;\n\t\t\tbuf = eof ? \"-1\" : st.nextToken();\n\t\t\treturn ret;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (Exception e) {\n\n\t\t\t}\n\t\t}\n\n\t\tboolean isEOF() {\n\t\t\treturn eof;\n\t\t}\n\t}\n\n\tFastScanner sc;\n\tPrintWriter out;\n\n\tpublic void run() {\n\t\tLocale.setDefault(Locale.US);\n\t\ttry {\n\t\t\tsc = new FastScanner(System.in);\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tsc.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn sc.nextInt();\n\t}\n\n\tString nextToken() {\n\t\treturn sc.nextToken();\n\t}\n\n\tlong nextLong() {\n\t\treturn sc.nextLong();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn sc.nextDouble();\n\t}\n\n\tvoid solve() {\n\t\t// long time = System.currentTimeMillis();\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tboolean[][] edges = new boolean[n][n];\n\t\tboolean[] edge = new boolean[(n << 5) | n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x = nextInt() - 1;\n\t\t\tint y = nextInt() - 1;\n\t\t\tedges[x][y] = edges[y][x] = true;\n\t\t\tedge[(x << 5) | y] = edge[(y << 5) | x] = true;\n\t\t}\n\t\tlong[][] dp = new long[n][1 << n];\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int mask2 = 1; mask2 < 1 << (n - i - 1); ++mask2) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tdp[j][mask2 << i << 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (edges[i][j]) {\n\t\t\t\t\tdp[j][1 << j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int mask2 = 1; mask2 < 1 << (n - i - 1); ++mask2) {\n\t\t\t\tint mask = (mask2 << i << 1);\n\t\t\t\tif ((mask & (mask - 1)) == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (((mask >> j) & 1) == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdp[j][mask] = 0;\n\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\tif (((mask >> k) & 1) == 0 || !edge[(j << 5) | k]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[j][mask] += dp[k][mask & ~(1 << j)];\n\t\t\t\t\t}\n\t\t\t\t\tif (edge[(i << 5) | j]) {\n\t\t\t\t\t\tans += dp[j][mask];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tif (n >= 3) {\n//\t\t\tif (edges[n - 3][n - 2] && edges[n - 3][n - 1]\n//\t\t\t\t\t&& edges[n - 2][n - 1]) {\n//\t\t\t\tans += 2;\n//\t\t\t}\n//\t\t}\n\t\tout.println(ans / 2);\n\t\t// System.err.println(System.currentTimeMillis() - time);\n\n\t\t// out.println(19 + \" \" + 19 * 9);\n\t\t// for (int i = 0; i < 19; ++i) {\n\t\t// for (int j = i + 1; j < 19; ++j) {\n\t\t// out.println((i + 1) + \" \" + (j + 1));\n\t\t// }\n\t\t// }\n\t}\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] in = br.readLine().split(\" \");\n\t\t\n\t\tint n=Integer.parseInt(in[0]),m=Integer.parseInt(in[1]),k=Integer.parseInt(in[2]);\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint[] caps = new int[n];\n\t\tfor (int i = 0; i < caps.length; i++) {\n\t\t\tcaps[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tArrays.sort(caps);\n\t\t\n\t\tint curSockets=k, neededLines=0;\n\t\tint i = n-1;\n\t\twhile(curSockets<m && i>=0){\n\t\t\tcurSockets+=caps[i]-1;\n\t\t\tneededLines++;\n\t\t\ti--;\n\t\t}\n\t\tif(curSockets>=m)\n\t\t\tSystem.out.println(neededLines);\n\t\telse\n\t\t\tSystem.out.println(-1);\n\t}\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Problem4 {\n\tpublic static void main(String[] args){\n\t\tFastScanner sc = new FastScanner();\n\t\tlong l = sc.nextLong();\n\t\tlong r = sc.nextLong();\n\t\t\n\t\tif(l == r){\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tlong lLength = countBinLength(l);\n\t\tlong rLength = countBinLength(r);\n\t\t\n\t\tif(rLength == lLength){\n\t\t\tlong xor = l ^ r;\n\t\t\tlong xorL = countBinLength(xor);\n\t\t\trLength = xorL;\n\t\t\t//long common = ((r >> xorL) << xorL);\n\t\t\t//l ^= common;\n\t\t\t//r ^= common;\n\t\t}\n\n\t\t//guaranteed l&r different lengths\n\t\t\n\t\tlong val = exp(2,rLength)-1;\n\t\tSystem.out.println(val);\n\t\t\n\t}\n\n\tpublic static long exp(long a, long n){\n\t\tif(n==0){\n\t\t\treturn 1;\n\t\t}\n\n\t\tif(n % 2 == 0){\n\t\t\tlong r = exp(a, n/2);\n\t\t\treturn (r*r);\n\t\t}else{\n\t\t\treturn (a * exp(a,n-1));\n\t\t}\n\t}\n\t\n\tpublic static long countBinLength(long value) {\n\t    return Long.SIZE-Long.numberOfLeadingZeros(value);\n\t}\n\t\n\t\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n}\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\n/** Oct 21, 2012 **/\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\n\n/**\n * @author DOAN Minh Quy\n * @email mquy.doan@gmail.com\n */\npublic class C236 {\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        new C236().run();\n    }\n    void run() {\n        InputScanner scanner = new InputScanner(System.in);\n        PrintStream printer = new PrintStream(System.out);\n        int n = scanner.nextInt();\n        long answer;\n        if ( n == 1 ){\n            answer = 1;\n        }else if ( n == 2 ){\n            answer = 2;\n        }else{\n            if ( (n & 1) != 0 ){\n                answer = (long)n * (long)(n-1) * (long)(n-2);\n            }else{\n                if ( n % 3 == 0 ){\n                    answer = (long)(n-1) * (long)(n-2) * (long)(n-3);\n                }else{\n                    answer = (long)(n) * (long)(n-1) * (long)(n-3);\n                }\n            }\n        }\n        printer.println(answer);\n    }\n    class InputScanner{\n        BufferedInputStream bis;\n        byte[] buffer = new byte[1024]; \n        int currentChar;\n        int charCount;\n        public InputScanner(InputStream stream){\n            bis = new BufferedInputStream(stream);\n        }\n        public byte read() {\n            if (charCount == -1)\n                throw new InputMismatchException();\n            if (currentChar >= charCount) {\n                currentChar = 0;\n                try {\n                    charCount = bis.read(buffer);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (charCount <= 0)\n                    return -1;\n            }\n            return buffer[currentChar++];\n        }\n        public int nextInt(){\n            int c = read();\n            while (isSpaceChar(c)){\n                c = read();\n            }\n            int sign = 1;\n            if (c == '-') {\n                sign = -1;\n                c = read();\n            }\n            int rep = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                rep *= 10;\n                rep += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return rep * sign;\n        }\n        public long nextLong(){\n            int c = read();\n            while (isSpaceChar(c)){\n                c = read();\n            }\n            int sign = 1;\n            if (c == '-') {\n                sign = -1;\n                c = read();\n            }\n            long rep = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                rep *= 10;\n                rep += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return rep * (long)sign;\n        }\n        public String next(){\n            char c = (char)read();\n            while (isSpaceChar(c)){\n                c = (char)read();\n            }\n            StringBuilder build = new StringBuilder();\n            do{\n                build.append(c);\n                c = (char)read();\n            }while(!isSpaceChar(c));\n            return build.toString();\n        }\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n        public void close(){\n            try {\n                bis.close();\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class CodeJ \n{\n\tstatic class Scanner\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\t\n\t\tpublic String nextLine()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn br.readLine();\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow(new RuntimeException());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String next()\n\t\t{\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t{\n\t\t\t\tString l = nextLine();\n\t\t\t\tif(l == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(l);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tpublic double nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n)\n\t\t{\n\t\t\tint[] res = new int[n];\n\t\t\tfor(int i = 0; i < res.length; i++)\n\t\t\t\tres[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n)\n\t\t{\n\t\t\tlong[] res = new long[n];\n\t\t\tfor(int i = 0; i < res.length; i++)\n\t\t\t\tres[i] = nextLong();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tpublic double[] nextDoubleArray(int n)\n\t\t{\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor(int i = 0; i < res.length; i++)\n\t\t\t\tres[i] = nextLong();\n\t\t\treturn res;\n\t\t}\n\t\tpublic void sortIntArray(int[] array)\n\t\t{\n\t\t\tInteger[] vals = new Integer[array.length];\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tvals[i] = array[i];\n\t\t\tArrays.sort(vals);\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tarray[i] = vals[i];\n\t\t}\n\t\t\n\t\tpublic void sortLongArray(long[] array)\n\t\t{\n\t\t\tLong[] vals = new Long[array.length];\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tvals[i] = array[i];\n\t\t\tArrays.sort(vals);\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tarray[i] = vals[i];\n\t\t}\n\t\t\n\t\tpublic void sortDoubleArray(double[] array)\n\t\t{\n\t\t\tDouble[] vals = new Double[array.length];\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tvals[i] = array[i];\n\t\t\tArrays.sort(vals);\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tarray[i] = vals[i];\n\t\t}\n\t}\n\t\n\tstatic int nFilas;\n\tstatic int nColumnas;\n\n\tstatic byte[][][][][] dp;\n\t\n\tstatic byte dp(int mascaraActual, int enviadosActual, int enviadosSiguiente, int filaActual, int columnaActual)\n\t{\n\t\tif(dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] != Byte.MAX_VALUE)\n\t\t\treturn dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual];\n\t\tif(filaActual == nFilas)\n\t\t\treturn dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] = 0;\n\t\tif(columnaActual == nColumnas)\n\t\t{\n\t\t\tint ambos = mascaraActual & enviadosSiguiente;\n\t\t\tint mascaraSiguiente = (1 << nColumnas) - 1;\n\t\t\tmascaraSiguiente ^= ambos;\n\t\t\tint mascaraEnviados = enviadosSiguiente;\n\t\t\tmascaraEnviados ^= ambos;\n\t\t\treturn dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] = (byte) (nColumnas - Integer.bitCount(mascaraActual) + dp(mascaraSiguiente, mascaraEnviados, 0, filaActual + 1, 0));\n\t\t}\n\t\tif(((mascaraActual & (1 << columnaActual)) == 0))\n\t\t{\n\t\t\t// me envian desde abajo\n\t\t\tbyte a = dp(mascaraActual | (1 << columnaActual), enviadosActual, enviadosSiguiente | (1 << columnaActual), filaActual, columnaActual + 1);\n\t\t\t// normal\n\t\t\tbyte b = dp(mascaraActual, enviadosActual, enviadosSiguiente, filaActual, columnaActual + 1);\n\t\t\treturn dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] = (byte) Math.max(a, b);\n\t\t}\n\t\tif((enviadosActual & (1 << columnaActual)) != 0)\n\t\t{\n\t\t\tbyte a = dp(mascaraActual, enviadosActual, enviadosSiguiente | (1 << columnaActual), filaActual, columnaActual + 1);\n\t\t\tbyte b = dp(mascaraActual, enviadosActual, enviadosSiguiente, filaActual, columnaActual + 1);\n\t\t\treturn dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] = (byte) Math.max(a, b);\n\t\t}\n\t\t// izquierda\n\t\tbyte ans = 0;\n\t\tif(columnaActual != 0)\n\t\t\tans = (byte) Math.max(ans, dp((mascaraActual ^ (1 << columnaActual)) | (1 << (columnaActual - 1)), enviadosActual, enviadosSiguiente, filaActual, columnaActual + 1));\n\t\t// derecha\n\t\tif(columnaActual != nColumnas - 1)\t\n\t\t\tans = (byte) Math.max(ans, dp((mascaraActual ^ (1 << columnaActual)) | (1 << (columnaActual + 1)), enviadosActual | (1 << (columnaActual + 1)), enviadosSiguiente, filaActual, columnaActual + 1));\n\t\t// abajo\n\t\tif(filaActual != nFilas - 1)\n\t\t\tans = (byte) Math.max(ans, dp((mascaraActual ^ (1 << columnaActual)), enviadosActual, enviadosSiguiente | (1 << columnaActual), filaActual, columnaActual + 1));\n\t\t// quieto\n\t\tans = (byte) Math.max(ans, dp(mascaraActual, enviadosActual, enviadosSiguiente, filaActual, columnaActual + 1));\n\t\treturn dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] = ans;\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner();\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tnFilas = Math.max(a, b);\n\t\tnColumnas = Math.min(a, b);\n\t\tdp = new byte[1 << nColumnas][1 << nColumnas][1 << nColumnas][nFilas + 1][nColumnas + 1];\n\t\tfor(byte[][][][] i : dp)\n\t\t\tfor(byte[][][] j : i)\n\t\t\t\tfor(byte[][] k : j)\n\t\t\t\t\tfor(byte[] l : k)\n\t\t\t\t\t\tArrays.fill(l, Byte.MAX_VALUE);\n\t\tSystem.out.println(dp((1 << nColumnas) - 1, 0, 0, 0, 0));\n\t}\n}", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        long K = Long.valueOf(br.readLine());\n        long n = 0;\n        long k = 0; //len * Math.pow(10, len) * 0.9;\n        long len = 0;\n        while(true){\n            len++;\n            long preK = k;\n            long preN = n;\n            k += len * Math.pow(10, len) * 0.9;\n            n += Math.pow(10, len) * 0.9;\n            if(K < k) {\n                k = preK;\n                n = preN;\n                break;\n            }\n        }\n        long step = len - 1;\n        while(true){\n            while(k <= K){\n                long preK = k;\n                long preN = n;\n                if(step == 0){\n                    k += len;\n                    n++;\n                }else{\n                    k += len * Math.pow(10, step) * 0.9;\n                    n += Math.pow(10, step) * 0.9;\n                }\n                if(k == K || (k >= K && k - K < len)){\n                    //System.out.println(k);\n                    //System.out.println(n);\n                    String nStr = Long.toString(n);\n                    System.out.println(nStr.charAt(nStr.length() - (int)(k-K) - 1));\n                    return;\n                }\n                if(K < k){\n                    k = preK;\n                    n = preN;\n                    break;\n                }\n            }\n            step--;\n        }\n    }\n}\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic PrintWriter out;\n\tstatic Reader in;\n\tpublic static void main(String[] args) throws IOException {\n\t\tinput_output();\n\t\tMain solver = new Main();\n\t\tsolver.solve();\n\t\tout.close();\n\t\tout.flush();\n\t}\n\n\tstatic int INF = (int)1e9;\n\tstatic int MAXN = (int)4e5 + 5;\n\tstatic int MOD = (int)1e9+7;\n\tstatic int q, t, n, m, k;\n\tstatic double pi = Math.PI;\n\n\tvoid solve() throws IOException {\n\t\tn = in.nextInt();\n\t\tm = in.nextInt();\n\t\tk = in.nextInt();\n\n\t\tint[][] right = new int[n][m],\n\t\t\t    left = new int[n][m],\n\t\t\t    up = new int[n][m],\n\t\t\t    down = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m-1; j++) {\n\t\t\t\tright[i][j] = in.nextInt();\n\t\t\t\tleft[i][j+1] = right[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tdown[i][j] = in.nextInt();\n\t\t\t\tup[i+1][j] = down[i][j];\n\t\t\t}\n\t\t}\n\n\t\tif (k%2 == 1) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tout.print(\"-1 \");\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tint[][][] dp = new int[n][m][k+1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tfor (int kk = 1; kk <= k; kk++) {\n\t\t\t\t\tdp[i][j][kk] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int step = 2; step <= k; step+=2) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\tdp[i][j][step] = Math.min(dp[i][j][step], dp[i-1][j][step-2]+up[i][j]*2);\n\t\t\t\t\t}\n\t\t\t\t\tif (i != n-1) {\n\t\t\t\t\t\tdp[i][j][step] = Math.min(dp[i][j][step], dp[i+1][j][step-2]+down[i][j]*2);\t\n\t\t\t\t\t}\n\t\t\t\t\tif (j != 0) {\n\t\t\t\t\t\tdp[i][j][step] = Math.min(dp[i][j][step], dp[i][j-1][step-2]+left[i][j]*2);\n\t\t\t\t\t}\n\t\t\t\t\tif (j != m-1) {\n\t\t\t\t\t\tdp[i][j][step] = Math.min(dp[i][j][step], dp[i][j+1][step-2]+right[i][j]*2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tout.print(dp[i][j][k]+\" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\n\tstatic class Reader {\n\t\tprivate InputStream mIs;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic Reader() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tpublic Reader(InputStream is) {\n\t\t\tmIs = is;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1) {\n\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t}\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = mIs.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t}\n\tstatic void input_output() throws IOException {\n\t\tFile f = new File(\"in.txt\");\n\t\tif (f.exists() && !f.isDirectory()) {\n\t\t\tin = new Reader(new FileInputStream(\"in.txt\"));\n\t\t} else in = new Reader();\n\t\tf = new File(\"out.txt\");\n\t\tif (f.exists() && !f.isDirectory()) {\n\t\t\tout = new PrintWriter(new File(\"out.txt\"));\n\t\t} else out = new PrintWriter(System.out);\n\t}\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tstatic int n, t[], g[], MOD = (int) 1e9 + 7;\n\tstatic int[][][] memo1, memo2[], memo3[];\n\n\tstatic int dp1(int idx, int remCnt, int remSum) {\n\t\tif (idx == n)\n\t\t\treturn remSum == 0 && remCnt == 0 ? 1 : 0;\n\t\tif (remCnt < 0 || remSum < 0)\n\t\t\treturn 0;\n\t\tif (memo1[idx][remCnt][remSum] != -1)\n\t\t\treturn memo1[idx][remCnt][remSum];\n\t\tint ans = dp1(idx + 1, remCnt, remSum);\n\t\tif (g[idx] == 0) {\n\t\t\tans += dp1(idx + 1, remCnt - 1, remSum - t[idx]);\n\t\t\tif (ans >= MOD)\n\t\t\t\tans -= MOD;\n\t\t}\n\t\treturn memo1[idx][remCnt][remSum] = ans;\n\t}\n\n\tstatic int dp2(int idx, int remCnt1, int remCnt2, int remSum) {\n\n\t\tif (idx == n)\n\t\t\treturn remSum == 0 && remCnt1 == 0 && remCnt2 == 0 ? 1 : 0;\n\t\tif (remSum < 0 || remCnt1 < 0 || remCnt2 < 0)\n\t\t\treturn 0;\n\t\tif (memo2[idx][remCnt1][remCnt2][remSum] != -1)\n\t\t\treturn memo2[idx][remCnt1][remCnt2][remSum];\n\t\tint ans = dp2(idx + 1, remCnt1, remCnt2, remSum);\n\n\t\tif (g[idx] == 1)\n\t\t\tans += dp2(idx + 1, remCnt1 - 1, remCnt2, remSum - t[idx]);\n\t\telse if (g[idx] == 2)\n\t\t\tans += dp2(idx + 1, remCnt1, remCnt2 - 1, remSum - t[idx]);\n\t\tif(ans>=MOD)\n\t\t\tans-=MOD;\n\t\treturn memo2[idx][remCnt1][remCnt2][remSum] = ans;\n\t}\n\n\tprivate static int dp3(int cnt0, int cnt1, int cnt2, int last) {\n\t\tif (cnt0 < 0 || cnt1 < 0 || cnt2 < 0)\n\t\t\treturn 0;\n\t\tif (cnt0 + cnt1 + cnt2 == 0)\n\t\t\treturn 1;\n\t\tif (memo3[last][cnt0][cnt1][cnt2] != -1)\n\t\t\treturn memo3[last][cnt0][cnt1][cnt2];\n\t\tlong ans = 0;\n\t\tif (last != 0)\n\t\t\tans += dp3(cnt0 - 1, cnt1, cnt2, 0);\n\t\tif (last != 1)\n\t\t\tans += dp3(cnt0, cnt1 - 1, cnt2, 1);\n\t\tif (last != 2)\n\t\t\tans += dp3(cnt0, cnt1, cnt2 - 1, 2);\n\t\treturn memo3[last][cnt0][cnt1][cnt2] = (int) (ans % MOD);\n\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tn = sc.nextInt();\n\t\tint[] fac = new int[n + 1];\n\t\tt = new int[n];\n\t\tg = new int[n];\n\t\tint[] cnt = new int[3];\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfac[i] = (int) (i * 1L * fac[i - 1] % MOD);\n\t\tint T = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tt[i] = sc.nextInt();\n\t\t\tg[i] = sc.nextInt() - 1;\n\t\t\tcnt[g[i]]++;\n\n\t\t}\n\t\tmemo1 = new int[n][cnt[0] + 1][T + 1];\n\t\tmemo2 = new int[n][cnt[1] + 1][cnt[2] + 1][T + 1];\n\t\tmemo3 = new int[4][cnt[0] + 1][cnt[1] + 1][cnt[2] + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= cnt[0]; j++)\n\t\t\t\tArrays.fill(memo1[i][j], -1);\n\t\t\tfor (int j = 0; j <= cnt[1]; j++)\n\t\t\t\tfor (int k = 0; k <= cnt[2]; k++)\n\t\t\t\t\tArrays.fill(memo2[i][j][k], -1);\n\n\t\t}\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j <= cnt[0]; j++)\n\t\t\t\tfor (int k = 0; k <= cnt[1]; k++)\n\t\t\t\t\tArrays.fill(memo3[i][j][k], -1);\n\t\tint ans = 0;\n\t\tfor (int cnt0 = 0; cnt0 <= cnt[0]; cnt0++)\n\t\t\tfor (int sum0 = 0; sum0 <= T; sum0++)\n\t\t\t\tfor (int cnt1 = 0; cnt1 <= cnt[1]; cnt1++)\n\t\t\t\t\tfor (int cnt2 = 0; cnt2 <= cnt[2]; cnt2++) {\n\t\t\t\t\t\tlong ways = dp1(0, cnt0, sum0) * 1L * dp2(0, cnt1, cnt2, T - sum0) % MOD;\n\t\t\t\t\t\tways = ways * dp3(cnt0, cnt1, cnt2, 3) % MOD;\n\t\t\t\t\t\tways *= fac[cnt0];\n\t\t\t\t\t\tways %= MOD;\n\t\t\t\t\t\tways *= fac[cnt1];\n\t\t\t\t\t\tways %= MOD;\n\t\t\t\t\t\tways *= fac[cnt2];\n\t\t\t\t\t\tways %= MOD;\n\t\t\t\t\t\tans += ways;\n\t\t\t\t\t\tif (ans >= MOD)\n\t\t\t\t\t\t\tans -= MOD;\n\t\t\t\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tboolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "complexity": "cubic", "problem": "1185_G2", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "    import java.util.*;\n    import java.io.*;\n    import java.lang.*;\n    import java.math.*;\n    public class D {\n        public static void main(String[] args) throws Exception {\n            BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n            PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n            // int n = Integer.parseInt(bf.readLine());\n            StringTokenizer st = new StringTokenizer(bf.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int k = Integer.parseInt(st.nextToken());\n            \n            for(int i=0; i<100000; i++) {\n              long mult = 1L*i*(i+1)/2;\n              long b = 1L*mult - k;\n              if(i+b == n*1L) {\n                out.println(b);\n                out.close(); System.exit(0);\n              }\n            }\n            //out.println(count);\n            out.close(); System.exit(0);\n        }\n    }\n\n    // a(a+1)/2 - b = k;   a+b = n   ", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class HexTheorem {\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));\n        int x = Integer.parseInt(read.readLine());\n        System.out.println(\"0 0 \"+x);\n    }\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class C {\n    public static void main(String[] args) throws Exception {\n        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb = new StringBuilder();\n        int t = Integer.parseInt(buffer.readLine());\n        while (t-- > 0) {\n            int n = Integer.parseInt(buffer.readLine());\n            ArrayList<Integer>list = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int a = Integer.parseInt(buffer.readLine());\n                if (a == 1)\n                    list.add(1);\n                else {\n                    for (int j = list.size()-1; j >= 0; j--) {\n                        if (list.get(j)+1 == a)\n                            break;\n                        list.remove(list.size()-1);\n                    }\n                    list.remove(list.size()-1);\n                    list.add(a);\n                }\n                for (int j = 0; j < list.size(); j++) {\n                    sb.append(list.get(j));\n                    if (j == list.size()-1)\n                        sb.append(\"\\n\");\n                    else\n                        sb.append(\".\");\n                }\n            }\n        }\n        System.out.println(sb);\n    }\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class ProblemA {\n\t\n\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tString line = s.readLine();\n\t\tint len = line.length();\n\t\tint max = 0;\n\t\tfor (int i = 0 ; i < len ; i++) {\n\t\t\tfor (int j = i+1 ; j <= len ; j++) {\n\t\t\t\tString sch = line.substring(i, j);\n\t\t\t\tfor (int k = i+1 ; k + (j - i) <= len ; k++) {\n\t\t\t\t\tString tch = line.substring(k, k+(j-i));\n\t\t\t\t\tif (sch.equals(tch)) {\n\t\t\t\t\t\tmax = Math.max(max, (j-i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(max);\n\t\tout.flush();\n\t}\n\n\n\tpublic static void debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\npublic class Main {\n    public static int n, m;\n    public static int[][] arr;\n    public static class Item implements Comparable<Item> {\n        int i, x;\n        public Item(int i, int x) {\n            this.i = i;\n            this.x = x;\n        }\n        public int compareTo(Item other) {\n            if (x == other.x) {\n                return i - other.i;\n            }\n            return other.x - x;\n        }\n    }\n    public static int calc(int[] cols, int k, String mask) {\n        if (k == cols.length) {\n            int res = 0;\n            for (int i = 0; i < n; i++) {\n                int max = 0;\n                for (int j = 0; j < cols.length; j++) {\n                    int shift = mask.charAt(j) - '0';\n                    max = Math.max(max, arr[(shift + i) % n][cols[j]]);\n                }\n                res += max;\n            }\n            return res;\n        } else {\n            int best = 0;\n            for (int i = 0; i < n; i++) {\n                best = Math.max(best, calc(cols, k + 1, mask + i));\n            }\n            return best;\n        }\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int t = in.nextInt();\n        for (int i = 0; i < t; i++) {\n            n = in.nextInt();\n            m = in.nextInt();\n            arr = new int[n][m];\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < m; k++) {\n                    arr[j][k] = in.nextInt();\n                }\n            }\n            Item[] max = new Item[m];\n            for (int j = 0; j < m; j++) {\n                max[j] = new Item(j, 0);\n                for (int k = 0; k < n; k++) {\n                    max[j].x = Math.max(max[j].x, arr[k][j]);\n                }\n            }\n            Arrays.sort(max);\n            int[] cols = new int[Math.min(n, m)];\n            for (int j = 0; j < cols.length; j++) {\n                cols[j] = max[j].i;\n            }\n            System.out.println(calc(cols, 0, \"\"));\n        }\n    }\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\n\npublic class CF22_1 {\n\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int num=sc.nextInt();\n    if(num!=1)\n    {\n        ArrayList<Integer>data=new ArrayList<Integer>();\n        for (int i=0;i<num;i++){\n            data.add(sc.nextInt());\n            \n        }\n        Collections.sort(data);\n        \n        int ind=1;\n    \n        while( data.get(ind-1)==data.get(ind) )\n            {\n            ind++;\n            if(ind ==data.size())\n                break;\n            }\n        \n        if(data.size()>ind)\n        System.out.println(data.get(ind));\n        else\n            System.out.println(\"NO\");\n        \n        \n    }\n    else\n        System.out.println(\"NO\");\n    }\n    \n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*; \n public class B{\nstatic int[] dx={-1,1,0,0};\nstatic int[] dy={0,0,1,-1};\n    static FastReader scan=new FastReader();\n   public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n  static ArrayList<Pair>es;\n  static LinkedList<Pair>edges[][];\n   static boolean prime[];\n   static void sieve(int n) \n    { \n        \n        prime = new boolean[n+1]; \n        for(int i=0;i<n;i++) \n            prime[i] = true; \n          \n        for(int p = 2; p*p <=n; p++) \n        { \n           \n            if(prime[p] == true) \n            { \n                \n                for(int i = p*p; i <= n; i += p) \n                    prime[i] = false; \n            } \n        } \n          \n        \n    }  \n  \n public static boolean areSame(int []arr)\n    {\n        // Put all array elements in a HashSet\n        Set<Integer>s=new HashSet<Integer>();\n        for(int i=0;i<arr.length;i++)\n            s.add(arr[i]);\n\n \n        // If all elements are same, size of\n        // HashSet should be 1. As HashSet contains only distinct values.\n        return (s.size() == 1);\n    }\n   \n\n    \n     public static int lowerBound(long[] array, int length, long value) {\n        int low = 0;\n        int high = length;\n        while (low < high) {\n            final int mid = (low + high) / 2;\n            //checks if the value is less than middle element of the array\n            if (value <= array[mid]) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    public static int upperBound(long[] array, int length, long value) {\n        int low = 0;\n        int high = length;\n        while (low < high) {\n            final int mid = low+(high-low) / 2;\n            if ( array[mid]>value) {\n                high = mid ;\n            } else {\n                low = mid+1;\n            }\n        }\n        return low;\n    }\nstatic long mod(long x,long y)\n    {\n        if(x<0)\n            x=x+(-x/y+1)*y;\n        return x%y;\n    }\n    \n    \n    static boolean isPowerOfTwo(int n)\n{\n    if(n==0)\n    return false;\n \nreturn (int)(Math.ceil((Math.log(n) / Math.log(2)))) == \n       (int)(Math.floor(((Math.log(n) / Math.log(2)))));\n}\nstatic int CeilIndex(int A[], int l, int r, int key) \n    { \n        while (r - l > 1) { \n            int m = l + (r - l) / 2; \n            if (A[m] >= key) \n                r = m; \n            else\n                l = m; \n        } \n  \n        return r; \n    } \n  \n    static int LongestIncreasingSubsequenceLength(int A[], int size) \n    { \n        // Add boundary case, when array size is one \n  \n        int[] tailTable = new int[size]; \n        int len; // always points empty slot \n  \n        tailTable[0] = A[0]; \n        len = 1; \n        for (int i = 1; i < size; i++) { \n            if (A[i] < tailTable[0]) \n                // new smallest value \n                tailTable[0] = A[i]; \n  \n            else if (A[i] >= tailTable[len - 1]) \n                // A[i] wants to extend largest subsequence \n                tailTable[len++] = A[i]; \n  \n            else\n                // A[i] wants to be current end candidate of an existing \n                // subsequence. It will replace ceil value in tailTable \n                tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]; \n        } \n  \n        return len; \n    } \nstatic boolean isprime(long x)\n           {\n            for(long i=2;i*i<=x;i++)\n                if(x%i==0)\n                    return false;\n                return true;\n           }\n           static long arr[];\n      \n        static int k;\n\n static boolean can(long x)\n {\n    int bl=0;\n    int i=0;\n    for(int kas=0;i<n&&kas<k;kas++)\n    {\n        long hasta=arr[i];\n        hasta+=x*2;\n        while(i<n-1&&arr[i+1]<=hasta)i++;\n        i++;\n        \n    }\nreturn (i>=n);\n }\nstatic int n,m;\nstatic boolean vis[][];\nstatic boolean light[][];\nstatic boolean e(int x,int y)\n{\n    return (x>=0&&x<n&&y>=0&&y<n);\n}\nstatic int ans=0;\nstatic void dfs(int x,int y)\n{\n    if(vis[x][y])\n        return;\n    vis[x][y]=true;\n   //light[x][y]=true;\n    for(Pair p:edges[x][y])\n    {\n        if(!light[p.x][p.y]){\n            light[p.y][p.y]=true;\n            ans++;\n            dfs(p.x,p.y);\n                    }\n    }\n    for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(e(nx,ny))\n        dfs(nx,ny);\n}\n\n}\nstatic int dist(int x1,int y1,int x2,int y2){\nreturn Math.abs(x1-x2)+Math.abs(y1-y2);\n}\nstatic int x;\nstatic int min(int y,int k)\n{\n    if(y==x)\n        return 0;\n    return Math.min(min(y+k,k++)+1,min(y-1,k)+1);\n}\nstatic boolean is(int arr[])\n{\n    for(int i=1;i<arr.length;i++)\n        if(arr[i]<arr[i-1])\n            return false;\n        return true;\n}\n  static void reverse(int myArray[]) \n    { \n        Collections.reverse(Arrays.asList(myArray)); \n    } \n    static boolean isPerfect(long n) \n{ \n    // To store sum of divisors \n    long sum = 1; \n  \n    // Find all divisors and add them \n    for (long i = 2; i * i <= n; i++) \n    { \n        if (n % i==0) \n        { \n            if(i * i != n) \n                sum = sum + i + n / i; \n            else\n                sum = sum + i; \n        } \n    }  \n    // If sum of divisors is equal to \n    // n, then n is a perfect number \n    if (sum == n && n != 1) \n        return true; \n  \n    return false; \n} \nstatic char []a,b,c;\nstatic char chose(int i)\n{\nchar ch='a';\nwhile(ch==a[i]||ch==b[i])\nch++;\nreturn ch;\n}\nstatic int v1,v2,t,d;\nstatic boolean can(int k,int l)\n{\nwhile(l>0)\n{\n    k-=d;\n    l--;\n}\nif(k<=v2)\n    return true;\nelse \n    return false;\n}\npublic static void main(String[] args)  throws IOException \n\n\n\n{\n//java.util.Scanner scan=new java.util.Scanner(new File(\"mootube.in\"));\n //PrintWriter out = new PrintWriter (new FileWriter(\"mootube.out\"));\n//java.util.Scanner scan=new java.util.Scanner(new File(\"lightson.in\"));\n//PrintWriter out = new PrintWriter (new FileWriter(\"lightson.out\"));\n    long n=scan.nextLong();\n    String s1=scan.next(),s2=scan.next(),s3=scan.next();\n    int f=0,s=0,fs=0;\n    long cnt1[]=new long[265];\n    long cnt2[]=new long[265];\n    long cnt3[]=new long[265];\n    for(int i=0;i<s1.length();i++)\n    {\n        cnt1[s1.charAt(i)]++;\n    }\n    for(int i=0;i<s2.length();i++)\n    {\n        cnt2[s2.charAt(i)]++;\n    }\n    for(int i=0;i<s3.length();i++)\n    {\n        cnt3[s3.charAt(i)]++;\n    }\n    long max1=0,max2=0,max3=0;\n    for(int i=0;i<265;i++)\n        max1=Math.max(max1,cnt1[i]);\n     for(int i=0;i<265;i++)\n        max2=Math.max(max2,cnt2[i]);\n     for(int i=0;i<265;i++)\n        max3=Math.max(max3,cnt3[i]);\n    long len1=(long)s1.length();\n    long len2=(long)s2.length();\n    long len3=(long)s3.length();\n    if(len1==max1&&n==1)\n        len1--;\n    if(len2==max2&&n==1)\n        len2--;\n    if(len3==max3&&n==1)\n        len3--;\n  max1=Math.min(max1+n,len1);\n   max2=Math.min(max2+n,len2);\n    max3=Math.min(max3+n,len3);\n    long maxall=Math.max(max1,Math.max(max2,max3));\n    if((maxall==max2&&maxall==max3)||(maxall==max1&&maxall==max2)||(maxall==max1&&maxall==max3))\n        out.println(\"Draw\");\n    else if(Math.max(max1,Math.max(max2,max3))==max1)\n        out.println(\"Kuro\");\n    else if(Math.max(max1,Math.max(max2,max3))==max2)\n        out.println(\"Shiro\");\n    else if(Math.max(max1,Math.max(max2,max3))==max3)\n        out.println(\"Katie\");\n\n\n    \n\n\n\nout.close();\n}\nstatic class special implements Comparable<special>{\n    String c;\n    int id;\n    special(String c,int id)\n    {\n        this.id=id;\n       this.c=c;\n    }\n    public int compareTo(special o)\n    {\n        if(id==o.id){\n            if(c.compareTo(o.c)>0)\n                return 1;\n            else if(c.compareTo(o.c)<0) return -1;\n                else return 0;\n        }\n        return o.id-id;\n    }\n   \n}\n public static  long pow(long b, long e) {\n            long r = 1;\n            while (e > 0) {\n                if (e % 2 == 1) r = r * b ;\n                b = b * b;\n                e >>= 1;\n            }\n            return r;\n        }\n\nprivate static void sort(long[] arr) {\n        List<Long> list = new ArrayList<>();\n        for (long object : arr) list.add(object);\n        Collections.sort(list);\n        for (int i = 0; i < list.size(); ++i) arr[i] = list.get(i);\n    }\n public static class FastReader {\n        BufferedReader br;\n        StringTokenizer root;\n        \n \n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        String next() {\n            while (root == null || !root.hasMoreTokens()) {\n                try {\n                    root = new StringTokenizer(br.readLine());\n                } catch (Exception addd) {\n                    addd.printStackTrace();\n                }\n            }\n            return root.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (Exception addd) {\n                addd.printStackTrace();\n            }\n            return str;\n        }\n         public int[] nextIntArray(int arraySize) {\n            int array[] = new int[arraySize];\n \n            for (int i = 0; i < arraySize; i++) {\n                array[i] = nextInt();\n            }\n \n            return array;\n        }\n}\npublic static class Pair implements Comparable<Pair>{\n         int x;\n        int  y;\n        int id;\n        public Pair(){}\n        public Pair(int x1, int y1,int id) {\n            x=x1;\n            y=y1;\n            this.id=id;\n        }\n        public Pair(int x1, int y1) {\n            x=x1;\n            y=y1;\n        \n        }\n        @Override\n        public int hashCode() {\n            return (int)(x + 31 * y);\n        }\n        public String toString() {\n            return x + \" \" + y;\n        }\n        @Override\n        public boolean equals(Object o){\n            if (o == this) return true;\n            if (o.getClass() != getClass()) return false;\n            Pair t = (Pair)o;\n            return t.x == x && t.y == y;\n        }\n        public  int compareTo(Pair o)\n        {\n            if(x==o.x)\n                return y-o.y;\n            return x-o.x;\n        }\n}\n\n}\n\n\n\n\n\n\n\n", "complexity": "linear", "problem": "0979_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.util.Arrays.copyOf;\nimport static java.util.Arrays.deepToString;\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class C {\n\tstatic int[] dx = new int[] { 0, 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 0, -1, 0, 1 };\n\tstatic int[][] g;\n\tstatic int ans;\n\n\tstatic void fill() {\n\t\tcache[1][1] = 0;\n\t\tcache[1][1] = 0;\n\t\tcache[2][1] = 1;\n\t\tcache[1][2] = 1;\n\t\tcache[2][2] = 2;\n\t\tcache[2][2] = 2;\n\t\tcache[3][1] = 2;\n\t\tcache[1][3] = 2;\n\t\tcache[3][2] = 4;\n\t\tcache[2][3] = 4;\n\t\tcache[3][3] = 6;\n\t\tcache[3][3] = 6;\n\t\tcache[4][1] = 2;\n\t\tcache[1][4] = 2;\n\t\tcache[4][2] = 5;\n\t\tcache[2][4] = 5;\n\t\tcache[4][3] = 8;\n\t\tcache[3][4] = 8;\n\t\tcache[4][4] = 12;\n\t\tcache[4][4] = 12;\n\t\tcache[5][1] = 3;\n\t\tcache[1][5] = 3;\n\t\tcache[5][2] = 7;\n\t\tcache[2][5] = 7;\n\t\tcache[5][3] = 11;\n\t\tcache[3][5] = 11;\n\t\tcache[5][4] = 14;\n\t\tcache[4][5] = 14;\n\t\tcache[5][5] = 18;\n\t\tcache[5][5] = 18;\n\t\tcache[6][1] = 4;\n\t\tcache[1][6] = 4;\n\t\tcache[6][2] = 8;\n\t\tcache[2][6] = 8;\n\t\tcache[6][3] = 13;\n\t\tcache[3][6] = 13;\n\t\tcache[6][4] = 17;\n\t\tcache[4][6] = 17;\n\t\tcache[6][5] = 22;\n\t\tcache[5][6] = 22;\n\t\tcache[6][6] = 26;\n\t\tcache[6][6] = 26;\n\t\tcache[7][1] = 4;\n\t\tcache[1][7] = 4;\n\t\tcache[7][2] = 10;\n\t\tcache[2][7] = 10;\n\t\tcache[7][3] = 15;\n\t\tcache[3][7] = 15;\n\t\tcache[7][4] = 21;\n\t\tcache[4][7] = 21;\n\t\tcache[7][5] = 26;\n\t\tcache[5][7] = 26;\n\t\tcache[8][1] = 5;\n\t\tcache[1][8] = 5;\n\t\tcache[8][2] = 11;\n\t\tcache[2][8] = 11;\n\t\tcache[8][3] = 17;\n\t\tcache[3][8] = 17;\n\t\tcache[8][4] = 24;\n\t\tcache[4][8] = 24;\n\t\tcache[8][5] = 29;\n\t\tcache[5][8] = 29;\n\t\tcache[9][1] = 6;\n\t\tcache[1][9] = 6;\n\t\tcache[9][2] = 13;\n\t\tcache[2][9] = 13;\n\t\tcache[9][3] = 20;\n\t\tcache[3][9] = 20;\n\t\tcache[9][4] = 26;\n\t\tcache[4][9] = 26;\n\t\tcache[10][1] = 6;\n\t\tcache[1][10] = 6;\n\t\tcache[10][2] = 14;\n\t\tcache[2][10] = 14;\n\t\tcache[10][3] = 22;\n\t\tcache[3][10] = 22;\n\t\tcache[10][4] = 30;\n\t\tcache[4][10] = 30;\n\t\tcache[11][1] = 7;\n\t\tcache[1][11] = 7;\n\t\tcache[11][2] = 16;\n\t\tcache[2][11] = 16;\n\t\tcache[11][3] = 24;\n\t\tcache[3][11] = 24;\n\t\tcache[12][1] = 8;\n\t\tcache[1][12] = 8;\n\t\tcache[12][2] = 17;\n\t\tcache[2][12] = 17;\n\t\tcache[12][3] = 26;\n\t\tcache[3][12] = 26;\n\t\tcache[13][1] = 8;\n\t\tcache[1][13] = 8;\n\t\tcache[13][2] = 19;\n\t\tcache[2][13] = 19;\n\t\tcache[13][3] = 29;\n\t\tcache[3][13] = 29;\n\t\tcache[14][1] = 9;\n\t\tcache[1][14] = 9;\n\t\tcache[14][2] = 20;\n\t\tcache[2][14] = 20;\n\t\tcache[15][1] = 10;\n\t\tcache[1][15] = 10;\n\t\tcache[15][2] = 22;\n\t\tcache[2][15] = 22;\n\t\tcache[16][1] = 10;\n\t\tcache[1][16] = 10;\n\t\tcache[16][2] = 23;\n\t\tcache[2][16] = 23;\n\t\tcache[17][1] = 11;\n\t\tcache[1][17] = 11;\n\t\tcache[17][2] = 25;\n\t\tcache[2][17] = 25;\n\t\tcache[18][1] = 12;\n\t\tcache[1][18] = 12;\n\t\tcache[18][2] = 26;\n\t\tcache[2][18] = 26;\n\t\tcache[19][1] = 12;\n\t\tcache[1][19] = 12;\n\t\tcache[19][2] = 28;\n\t\tcache[2][19] = 28;\n\t\tcache[20][1] = 13;\n\t\tcache[1][20] = 13;\n\t\tcache[20][2] = 29;\n\t\tcache[2][20] = 29;\n\t\tcache[21][1] = 14;\n\t\tcache[1][21] = 14;\n\t\tcache[22][1] = 14;\n\t\tcache[1][22] = 14;\n\t\tcache[23][1] = 15;\n\t\tcache[1][23] = 15;\n\t\tcache[24][1] = 16;\n\t\tcache[1][24] = 16;\n\t\tcache[25][1] = 16;\n\t\tcache[1][25] = 16;\n\t\tcache[26][1] = 17;\n\t\tcache[1][26] = 17;\n\t\tcache[27][1] = 18;\n\t\tcache[1][27] = 18;\n\t\tcache[28][1] = 18;\n\t\tcache[1][28] = 18;\n\t\tcache[29][1] = 19;\n\t\tcache[1][29] = 19;\n\t\tcache[30][1] = 20;\n\t\tcache[1][30] = 20;\n\t\tcache[31][1] = 20;\n\t\tcache[1][31] = 20;\n\t\tcache[32][1] = 21;\n\t\tcache[1][32] = 21;\n\t\tcache[33][1] = 22;\n\t\tcache[1][33] = 22;\n\t\tcache[34][1] = 22;\n\t\tcache[1][34] = 22;\n\t\tcache[35][1] = 23;\n\t\tcache[1][35] = 23;\n\t\tcache[36][1] = 24;\n\t\tcache[1][36] = 24;\n\t\tcache[37][1] = 24;\n\t\tcache[1][37] = 24;\n\t\tcache[38][1] = 25;\n\t\tcache[1][38] = 25;\n\t\tcache[39][1] = 26;\n\t\tcache[1][39] = 26;\n\t\tcache[40][1] = 26;\n\t\tcache[1][40] = 26;\n\t}\n\n\tstatic void go(int n, int m, long used, long left) {\n\t\t// debug(Long.toBinaryString(used) + \" \" + Long.toBinaryString(left));\n\t\tif (left == 0) {\n\t\t\tans = max(ans, n * m - Long.bitCount(used));\n\t\t\treturn;\n\t\t}\n\t\tif (n * m - Long.bitCount(used) <= ans)\n\t\t\treturn;\n\t\tint who = Long.numberOfTrailingZeros(left);\n\t\t// debug(who);\n\t\tfor (int w : g[who]) {\n\t\t\tlong nused = used | (1L << w);\n\t\t\tlong nleft = left;\n\t\t\tfor (int v : g[w]) {\n\t\t\t\tnleft &= ~(1L << v);\n\t\t\t}\n\t\t\tgo(n, m, nused, nleft);\n\t\t}\n\t}\n\n\tstatic int solve(int n, int m) throws Exception {\n\t\tans = 0;\n\t\tg = new int[n * m][];\n\t\tfor (int x = 0; x < m; x++) {\n\t\t\tfor (int y = 0; y < n; y++) {\n\t\t\t\tint[] w = new int[5];\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int dir = 0; dir < 5; dir++) {\n\t\t\t\t\tint nx = x + dx[dir];\n\t\t\t\t\tint ny = y + dy[dir];\n\t\t\t\t\tif (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n\t\t\t\t\t\tw[cnt++] = ny * m + nx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg[y * m + x] = copyOf(w, cnt);\n\t\t\t}\n\t\t}\n\t\tgo(n, m, 0, (1L << (n * m)) - 1);\n\t\treturn ans;\n\t}\n\n\tstatic int[][] cache;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\t// debug(solve(1, 4));\n\t\t\t// debug(solve(6, 6));\n\n\t\t\t// debug(solve(7,5) == solve(5,7));\n//\t\t\tPrintWriter out2 = new PrintWriter(\"file.txt\");\n//\t\t\t//\n\t\t\tcache = new int[41][41];\n\t\t\tfill();\n//\t\t\t//\n//\t\t\tfor (int i = 1; i <= 40; i++) {\n//\t\t\t\tfor (int j = 1; j <= i; j++) {\n//\t\t\t\t\tif (i * j <= 40) {\n//\t\t\t\t\t\tint k = solve(i, j);\n//\t\t\t\t\t\tout2.printf(\"cache[%d][%d] = %d;\\n\", i, j, k);\n//\t\t\t\t\t\tout2.printf(\"cache[%d][%d] = %d;\\n\", j, i, k);\n//\n//\t\t\t\t\t\tcache[i][j] = solve(i, j);\n//\t\t\t\t\t\tdebug(i + \" \" + j);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tout2.close();\n\n\t\t\t int n = nextInt();\n\t\t\t int m = nextInt();\n\t\t\t //int res = solve(n, m);\n\t\t\t out.println(cache[n][m]);\n\n\t\t\t// for (int i = 1; i <= 5; i++) {\n\t\t\t// for (int j = 1; j <= 5; j++) {\n\t\t\t// assert(solve(i, j) == cache[i][j]);\n\t\t\t// //debug(i + \" \" + j + \" \" + solve(i, j));\n\t\t\t// }\n\t\t\t// }\n\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\tstatic long launchTimer;\n\n\tstatic void debug(Object... o) {\n\t\tSystem.err.println(deepToString(o));\n\t}\n\n\tstatic void setTime() {\n\t\tlaunchTimer = System.currentTimeMillis();\n\t}\n\n\tstatic void printTime() {\n\t\tSystem.err.println(System.currentTimeMillis() - launchTimer);\n\t}\n\n\tstatic void printMemory() {\n\t\tSystem.err.println((Runtime.getRuntime().totalMemory() - Runtime\n\t\t\t\t.getRuntime().freeMemory()) / 1000 + \"kb\");\n\t}\n\n\tstatic boolean hasMoreTokens() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttok = new StringTokenizer(line);\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic String next() throws IOException {\n\t\treturn hasMoreTokens() ? tok.nextToken() : null;\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic BigInteger nextBig() throws IOException {\n\t\treturn new BigInteger(next());\n\t}\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "//Utilities\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic int n, m, k;\n\tstatic int[][] horW, verW;\n\tstatic int[][][] dp = new int[505][505][15];\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tfor (int i = 0; i < 505; i++) {\n\t\t\tfor (int j = 0; j < 505; j++) {\n\t\t\t\tfor (int k = 0; k < 15; k++) {\n\t\t\t\t\tdp[i][j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tn = in.iscan(); m = in.iscan(); k =in.iscan();\n\t\thorW = new int[n+1][m]; verW = new int[n][m+1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m-1; j++) {\n\t\t\t\thorW[i][j] = in.iscan();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n-1; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tverW[i][j] = in.iscan();\n\t\t\t}\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif (k % 2 == 1) {\n\t\t\t\t\tout.print(-1 + \" \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tout.print(dfs(i, j, k/2) * 2 + \" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.close();\n\t} \n\t\n\tstatic int dfs(int r, int c, int k) {\n\t\tif (dp[r][c][k] != -1) {\n\t\t\treturn dp[r][c][k];\n\t\t}\n\t\tif (k == 0) {\n\t\t\treturn dp[r][c][k] = 0;\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tif (r - 1 >= 1) {\n\t\t\tmin = Math.min(min, verW[r-1][c] + dfs(r-1, c, k-1));\n\t\t}\n\t\tif (r + 1 <= n) {\n\t\t\tmin = Math.min(min, verW[r][c] + dfs(r+1, c, k-1));\n\t\t}\n\t\tif (c - 1 >= 1) {\n\t\t\tmin = Math.min(min, horW[r][c-1] + dfs(r, c-1, k-1));\n\t\t}\n\t\tif (c + 1 <= m) {\n\t\t\tmin = Math.min(min, horW[r][c] + dfs(r, c+1, k-1));\n\t\t}\n\t\treturn dp[r][c][k] = min;\n\t}\n\t\n\tstatic INPUT in = new INPUT(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tprivate static class INPUT {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar, numChars;\n\n\t\tpublic INPUT (InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic INPUT (String file) throws IOException {\n\t\t\tthis.stream = new FileInputStream (file);\n\t\t}\n\n\t\tpublic int cscan () throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read (buf);\n\t\t\t}\n\t\t\t\n\t\t\tif (numChars == -1)\n\t\t\t\treturn numChars;\n\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int iscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String sscan () throws IOException {\n\t\t\tint c = cscan ();\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tStringBuilder res = new StringBuilder ();\n\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint (c);\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res.toString ();\n\t\t}\n\n\t\tpublic double dscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tdouble res = 0;\n\n\t\t\twhile (!space (c) && c != '.') {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\n\t\t\t\t\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tif (c == '.') {\n\t\t\t\tc = cscan ();\n\t\t\t\tdouble m = 1;\n\n\t\t\t\twhile (!space (c)) {\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\n\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = cscan ();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long lscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tlong res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean space (int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n\tpublic static class UTILITIES {\n\n\t\tstatic final double EPS = 10e-6;\n\n\t\tpublic static int lower_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] >= x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\n\t\tpublic static int upper_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] > x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\n\t\tpublic static long gcd (long a, long b) {\n\t\t\treturn b == 0 ? a : gcd (b, a % b);\n\t\t}\n\n\t\tpublic static long lcm (long a, long b) {\n\t\t\treturn a * b / gcd (a, b);\n\t\t}\n\n\t\tpublic static long fast_pow_mod (long b, long x, int mod) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\n\t\t\treturn b * fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\t\t}\n\n\t\tpublic static int fast_pow (int b, int x) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow (b * b, x / 2);\n\n\t\t\treturn b * fast_pow (b * b, x / 2);\n\t\t}\n\n\t\tpublic static long choose (long n, long k) {\n\t\t\tk = Math.min (k, n - k);\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = val * (n - i) / (i + 1);\n\n\t\t\treturn val;\n\t\t}\n\n\t\tpublic static long permute (int n, int k) {\n\t\t\tif (n < k) return 0;\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = (val * (n - i));\n\n\t\t\treturn val;\n\t\t}\n\t}\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tstatic int n;\n\tstatic int a;\n\tstatic int b;\n\tstatic int g;\n\tstatic int ref;\n\tstatic int refg;\n\tstatic HashSet<Integer> cgroup;\n\tstatic HashMap<Integer,Integer> indexmap;\n\tstatic HashSet<Integer> nums;\n\tstatic HashSet<Integer> used;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tn = scan.nextInt();\n\t\ta = scan.nextInt();\n\t\tb = scan.nextInt();\n\t\t\n\t\tboolean[] where = new boolean[n];\n\t\tindexmap = new HashMap<Integer,Integer>();\n\t\tused = new HashSet<Integer>();\n\t\tnums = new HashSet<Integer>();\n\t\t\n\t\tif (a==b)\n\t\t\tb = 0;\n\t\t\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tint x = scan.nextInt();\n\t\t\tnums.add(x);\n\t\t\tindexmap.put(x,i);\n\t\t}\n\t\tscan.close();\n\t\t\n\t\tfor (int x : nums) {\n\t\t\tif (used.contains(x))\n\t\t\t\tcontinue;\n\t\t\tcgroup = new HashSet<Integer>();\n\t\t\tcgroup.add(x);\n\t\t\tg = -1;\n\t\t\trefg = -1;\n\t\t\tref = -1;\n\t\t\tused.add(x);\n\t\t\tif (!spawn(x,a,b) || !spawn(x,b,a)) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (cgroup.size()%2==1 && ref == -1) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tboolean w = true;\n\t\t\t\tif (g == a)\n\t\t\t\t\tw = false;\n\t\t\t\tfor (int k : cgroup) {\n\t\t\t\t\twhere[indexmap.get(k)] = w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n\t\tfor (int i = 0; i<where.length; i++)\n\t\t\tif (where[i])\n\t\t\t\tSystem.out.print(\"1 \");\n\t\t\telse\n\t\t\t\tSystem.out.print(\"0 \");\n\t\t\n\t}\n\n\tprivate static boolean spawn(int x, int ab, int abo) {\n\t\tint xab = ab-x;\n\t\tif (xab == x) {\n\t\t\tref = x;\n\t\t\trefg = ab;\n\t\t} else {\n\t\t\tif (nums.contains(xab)) {\n\t\t\t\tcgroup.add(xab);\n\t\t\t\tused.add(xab);\n\t\t\t\tspawn(xab,abo,ab);\n\t\t\t} else {\n\t\t\t\tif (g == -1)\n\t\t\t\t\tg = abo;\n\t\t\t\telse if (g != abo) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n/**\n *\n * @author Dstoical\n */\n\npublic class G {\n\n\tprivate static int M = 1000000007, MM = 998244353;\n\tprivate static int N = 15,n,T;\n\tprivate static int[] time,gi;\n\tprivate static int[][][] dp;\n\n\tpublic static void process() throws IOException {\n\n\t\tn = sc.nextInt();T = sc.nextInt();\n\t\ttime = new int[n+1];\n\t\tgi = new int[n+1];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tint a = sc.nextInt(),b = sc.nextInt();\n\t\t\ttime[i] = a;\n\t\t\tgi[i] = b-1;\n\t\t}\n\t\t\n\t\tdp = new int[1<<n][T+1][3];\n\t\tfor(int i=0; i<1<<n; i++) {\n\t\t\tfor(int j=0; j<T+1; j++) {\n\t\t\t\tfor(int k=0; k<3; k++)dp[i][j][k] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tif(time[i] <= T) {\n\t\t\t\tans = (ans + solve(1<<i,time[i],gi[i]))%M;\n\t\t\t}\n\t\t}\n\t\tprintln(ans);\n\t}\n\n\tprivate static int solve(int mask, int tim, int code) {\n\t\tif(tim == T)return 1;\n\t\tif(dp[mask][tim][code] != -1)return dp[mask][tim][code];\n\t\tint ans = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tif((mask>>i & 1) > 0)continue;\n\t\t\tif(code == gi[i])continue;\n\t\t\tif(tim + time[i] > T)continue;\n\t\t\tans = (ans + solve(mask|(1<<i), time[i]+tim, gi[i]))%M;\n\t\t\t\n\t\t}\n\t\treturn dp[mask][tim][code] = (ans%M);\n\t}\n\n\t//=============================================================================\n\t//--------------------------The End---------------------------------\n\t//=============================================================================\n\n\tstatic FastScanner sc;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tboolean oj = true;\n\t\tif (oj) {\n\t\t\tsc = new FastScanner();\n\t\t\tout = new PrintWriter(System.out);\n\t\t} else {\n\t\t\tsc = new FastScanner(100);\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t}\n\t\tint t = 1;\n//\t\tt = sc.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tprocess();\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint x, y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn Integer.compare(this.x, o.x);\n\t\t}\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\tstatic void println(Object o) {\n\t\tout.println(o);\n\t}\n\n\tstatic void println() {\n\t\tout.println();\n\t}\n\n\tstatic void print(Object o) {\n\t\tout.print(o);\n\t}\n\n\tstatic void pflush(Object o) {\n\t\tout.println(o);\n\t\tout.flush();\n\t}\n\n\tstatic int ceil(int x, int y) {\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\n\t}\n\n\tstatic long ceil(long x, long y) {\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int abs(int x) {\n\t\treturn Math.abs(x);\n\t}\n\n\tstatic long abs(long x) {\n\t\treturn Math.abs(x);\n\t}\n\n\tstatic int log2(int N) {\n\t\tint result = (int) (Math.log(N) / Math.log(2));\n\t\treturn result;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tBigInteger b1 = BigInteger.valueOf(a);\n\t\tBigInteger b2 = BigInteger.valueOf(b);\n\t\tBigInteger gcd = b1.gcd(b2);\n\t\treturn gcd.intValue();\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tBigInteger b1 = BigInteger.valueOf(a);\n\t\tBigInteger b2 = BigInteger.valueOf(b);\n\t\tBigInteger gcd = b1.gcd(b2);\n\t\treturn gcd.longValue();\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner() throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tFastScanner(int a) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tint[] readArray(int n) throws IOException {\n\t\t\tint[] A = new int[n];\n\t\t\tfor (int i = 0; i != n; i++) {\n\t\t\t\tA[i] = sc.nextInt();\n\t\t\t}\n\t\t\treturn A;\n\t\t}\n\n\t\tlong[] readArrayLong(int n) throws IOException {\n\t\t\tlong[] A = new long[n];\n\t\t\tfor (int i = 0; i != n; i++) {\n\t\t\t\tA[i] = sc.nextLong();\n\t\t\t}\n\t\t\treturn A;\n\t\t}\n\t}\n\n\tstatic void ruffleSort(int[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\n\tstatic void ruffleSort(long[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tlong temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n}\n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.io.BufferedWriter;\n\nimport java.util.InputMismatchException;\n\nimport java.io.InputStream;\n\nimport java.util.NoSuchElementException;\n\nimport java.io.OutputStreamWriter;\n\nimport java.math.BigInteger;\n\nimport java.io.OutputStream;\n\nimport java.io.PrintWriter;\n\nimport java.io.Writer;\n\nimport java.io.IOException;\n\n\n\n/**\n\n * Built using CHelper plug-in\n\n * Actual solution is at the top\n\n * @author ashiqmostofa\n\n */\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        InputStream inputStream = System.in;\n\n        OutputStream outputStream = System.out;\n\n        InputReader in = new InputReader(inputStream);\n\n        OutputWriter out = new OutputWriter(outputStream);\n\n        TaskD solver = new TaskD();\n\n        solver.solve(1, in, out);\n\n        out.close();\n\n    }\n\n}\n\n\n\nclass TaskD {\n\n    long a,b;\n\n\n\n\n\n\n\n\n\n\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n        a=in.readLong();\n\n        b=in.readLong();\n\n\n\n\n\n        long tem=b-a;\n\n        long cur=1;\n\n        long pos=0;\n\n        long ans=0;\n\n\n\n        while(tem>=cur) {\n\n            ans+=cur;\n\n            cur*=2;\n\n            pos++;\n\n        }\n\n        while(b>=cur) {\n\n            if((b&(1L<<pos))!=(a&(1L<<pos)))ans+=(1L<<pos);\n\n            cur*=2;\n\n            pos++;\n\n        }\n\n\n\n        out.print(ans);\n\n\n\n\n\n    }\n\n}\n\n\n\nclass InputReader {\n\n\n\n    private InputStream stream;\n\n    private byte[] buf = new byte[1024];\n\n    private int curChar;\n\n    private int numChars;\n\n    private SpaceCharFilter filter;\n\n\n\n    public InputReader(InputStream stream) {\n\n        this.stream = stream;\n\n    }\n\n\n\n    public int read() {\n\n        if (numChars == -1)\n\n            throw new InputMismatchException();\n\n        if (curChar >= numChars) {\n\n            curChar = 0;\n\n            try {\n\n                numChars = stream.read(buf);\n\n            } catch (IOException e) {\n\n                throw new InputMismatchException();\n\n            }\n\n            if (numChars <= 0)\n\n                return -1;\n\n        }\n\n        return buf[curChar++];\n\n    }\n\n\n\n    public long readLong() {\n\n        int c = read();\n\n        while (isSpaceChar(c))\n\n            c = read();\n\n        int sgn = 1;\n\n        if (c == '-') {\n\n            sgn = -1;\n\n            c = read();\n\n        }\n\n        long res = 0;\n\n        do {\n\n            if (c < '0' || c > '9')\n\n                throw new InputMismatchException();\n\n            res *= 10;\n\n            res += c - '0';\n\n            c = read();\n\n        } while (!isSpaceChar(c));\n\n        return res * sgn;\n\n    }\n\n\n\n    public boolean isSpaceChar(int c) {\n\n        if (filter != null)\n\n            return filter.isSpaceChar(c);\n\n        return isWhitespace(c);\n\n    }\n\n\n\n    public static boolean isWhitespace(int c) {\n\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\n    }\n\n\n\n    public interface SpaceCharFilter {\n\n        public boolean isSpaceChar(int ch);\n\n    }\n\n}\n\n\n\nclass OutputWriter {\n\n    private final PrintWriter writer;\n\n\n\n    public OutputWriter(OutputStream outputStream) {\n\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\n    }\n\n\n\n    public void close() {\n\n        writer.close();\n\n    }\n\n\n\n    public void print(long i) {\n\n        writer.print(i);\n\n    }\n\n\n\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "/**\n * BaZ :D\n */\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\npublic class Main\n{\n    static MyScanner scan;\n    static PrintWriter pw;\n    static long MOD = 1_000_000_007;\n    static long INF = 1_000_000_000_000_000_000L;\n    static long inf = 2_000_000_000;\n    public static void main(String[] args) {\n        new Thread(null, null, \"BaZ\", 1 << 27) {\n            public void run() {\n                try {\n                    solve();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n    static int n,m;\n    static int dp[], cnt[][], sum[];\n    static void solve() throws IOException\n    {\n        //initIo(true);\n        initIo(false);\n        StringBuilder sb = new StringBuilder();\n        n = ni();\n        m = ni();\n        dp = new int[(1<<m)];\n        char c[] = ne().toCharArray();\n        cnt = new int[m][m];\n        for(int i=0;i+1<n;++i) {\n            if(c[i]!=c[i+1]) {\n                ++cnt[c[i] - 'a'][c[i+1] - 'a'];\n                ++cnt[c[i+1] - 'a'][c[i] - 'a'];\n            }\n        }\n        sum = new int[1<<m];\n        calc(0, 0, 0);\n        Arrays.fill(dp, -1);\n        pl(f(0));\n        pw.flush();\n        pw.close();\n    }\n    static void calc(int mask, int S, int pos) {\n        if(pos==m) {\n            sum[mask] = S;\n            return;\n        }\n        calc(mask, S, pos+1);\n        int newSum = S;\n        for(int i=0;i<pos;++i) {\n            if((mask&(1<<i))!=0) {\n                newSum-=cnt[i][pos];\n            }\n            else {\n                newSum+=cnt[i][pos];\n            }\n        }\n        for(int i=pos+1;i<m;++i) {\n            newSum+=cnt[i][pos];\n        }\n        calc(mask|(1<<pos), newSum, pos+1);\n    }\n    static int f(int mask) {\n        if(mask==(1<<m) - 1) {\n            return 0;\n        }\n        if(dp[mask]!=-1) {\n            return dp[mask];\n        }\n        int min = Integer.MAX_VALUE;\n        for(int i=0;i<m;++i) {\n            if((mask&(1<<i))==0) {\n                min  =  min(min, sum[mask]+f(mask|(1<<i)));\n            }\n        }\n        return dp[mask] = min;\n    }\n    static void initIo(boolean isFileIO) throws IOException {\n        scan = new MyScanner(isFileIO);\n        if(isFileIO) {\n            pw = new PrintWriter(\"/Users/amandeep/Desktop/output.txt\");\n        }\n        else {\n            pw = new PrintWriter(System.out, true);\n        }\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static String ne() throws IOException\n    {\n        return scan.next();\n    }\n    static String nel() throws IOException\n    {\n        return scan.nextLine();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class MyScanner\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        MyScanner(boolean readingFromFile) throws IOException\n        {\n            if(readingFromFile) {\n                br = new BufferedReader(new FileReader(\"/Users/amandeep/Desktop/input.txt\"));\n            }\n            else {\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n        }\n        String nextLine()throws IOException\n        {\n            return br.readLine();\n        }\n        String next() throws IOException\n        {\n            if(st==null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        int nextInt() throws IOException\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong() throws IOException\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble() throws IOException\n        {\n            return Double.parseDouble(next());\n        }\n    }\n}", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "/**\n * author: derrick20\n * created: 3/19/21 11:57 PM\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class E2_SquareFreeDivision2 {\n    static FastScanner sc = new FastScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n//        generate();\n        int T = sc.nextInt();\n        int MAX = (int) 1e7;\n        int[] canonical = new int[MAX + 1];\n        canonical[1] = 1;\n        for (int factor = 2; factor <= MAX; factor++) {\n            if (canonical[factor] == 0) {\n                for (int mult = factor; mult <= MAX; mult += factor) {\n                    int prev = canonical[mult / factor];\n                    if (prev % factor == 0) {\n                        canonical[mult] = prev / factor;\n                    } else {\n                        canonical[mult] = prev * factor;\n                    }\n                }\n            }\n        }\n//        System.out.println(Arrays.toString(canonical));\n        int[] freq = new int[MAX + 1];\n        while (T-->0) {\n            int N = sc.nextInt();\n            int K = sc.nextInt();\n            int[] a = new int[N + 1];\n            for (int i = 1; i <= N; i++) {\n                a[i] = canonical[sc.nextInt()];\n            }\n            int[][] transition = new int[K + 1][N + 1];\n//            HashMap<Integer, Integer> freq = new HashMap<>();\n            for (int k = 0; k <= K; k++) {\n                int l = N + 1;\n                int duplicates = 0;\n                for (int r = N; r >= 1; r--) {\n                    while (l - 1 >= 1) {\n                        int nextDuplicates = duplicates;\n                        if (freq[a[l - 1]] >= 1) {\n                            nextDuplicates++;\n                        }\n                        if (nextDuplicates <= k) {\n                            duplicates = nextDuplicates;\n                            freq[a[l - 1]]++;\n                            l--;\n                        } else {\n                            break;\n                        }\n                    }\n                    transition[k][r] = l;\n                    if (--freq[a[r]] >= 1) {\n                        duplicates--;\n                    }\n                }\n            }\n            int[][] dp = new int[K + 1][N + 1];\n            int oo = (int) 1e9;\n            for (int[] row : dp) {\n                Arrays.fill(row, oo);\n            }\n            for (int k = 0; k <= K; k++) {\n                dp[k][0] = 0;\n            }\n            for (int r = 1; r <= N; r++) {\n                for (int k = 0; k <= K; k++) {\n                    for (int delta = 0; delta <= k; delta++) {\n                        dp[k][r] = min(dp[k][r], dp[k - delta][transition[delta][r] - 1] + 1);\n                    }\n                }\n            }\n            out.println(dp[K][N]);\n        }\n        out.close();\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n    \n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n    \n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n    \n        char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n    \n        int nextInt() {\n            return (int) nextLong();\n        }\n    \n        long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n    \n        double nextDouble() {\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            double cur = nextLong();\n            if (c != '.') {\n                return neg ? -cur : cur;\n            } else {\n                double frac = nextLong() / cnt;\n                return neg ? -cur - frac : cur + frac;\n            }\n        }\n    \n        String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n    \n        String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n    \n        boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n    \n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n    \n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "//package educational.round049;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class F {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(2*n);\n\t\tint[] b = Arrays.copyOf(a, 2*n);\n\t\tint[] imap = shrinkX(b);\n\t\tif(!ok(imap.length-1, b)){\n\t\t\tout.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tint low = -1, high = imap.length;\n\t\twhile(high - low > 1){\n\t\t\tint h = high+low>>1;\n\t\t\tif(ok(h, b)){\n\t\t\t\thigh = h;\n\t\t\t}else{\n\t\t\t\tlow = h;\n\t\t\t}\n\t\t}\n\t\tout.println(imap[high]);\n\t}\n\t\n\tboolean ok(int h, int[] b)\n\t{\n\t\tint n = b.length/2;\n\t\tDJSet ds = new DJSet(2*n);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(b[2*i] > h)return false;\n\t\t\tif(b[2*i+1] > h){\n\t\t\t\tif(++ds.cycle[ds.root(b[2*i])] >= 2)return false;\n\t\t\t}else{\n\t\t\t\tif(ds.union(b[2*i], b[2*i+1])){\n\t\t\t\t\tif(++ds.cycle[ds.root(b[2*i])] >= 2)return false;\n\t\t\t\t}else{\n\t\t\t\t\tif(ds.cycle[ds.root(b[2*i])] >= 2)return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n\t\tpublic int[] cycle;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t\tcycle = new int[n];\n\t\t}\n\n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t\t\n\t\t\t\tcycle[x] += cycle[y];\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\t\n\tpublic static int[] shrinkX(int[] a) {\n\t\tint n = a.length;\n\t\tlong[] b = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tb[i] = (long) a[i] << 32 | i;\n\t\tArrays.sort(b);\n\t\tint[] ret = new int[n];\n\t\tint p = 0;\n\t\tret[0] = (int) (b[0] >> 32);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0) {\n\t\t\t\tp++;\n\t\t\t\tret[p] = (int) (b[i] >> 32);\n\t\t\t}\n\t\t\ta[(int) b[i]] = p;\n\t\t}\n\t\treturn Arrays.copyOf(ret, p + 1);\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new F().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "quadratic", "problem": "1027_F", "from": "CODEFORCES", "tags": "binary search,dfs and similar,dsu,graph matchings,graphs"}
{"src": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class first {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s=new Scanner(System.in);\n\t\tint n=s.nextInt();\n\t\tint[] a=new int[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i]=s.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tint count=0;\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif(a[i]!=0) {\n\t\t\t\tint x=a[i];\n\t\t\t\tcount++;\n\t\t\t\tfor (int j = i; j < a.length; j++) {\n\t\t\t\t\tif(a[j]%x==0) {\n\t\t\t\t\t\ta[j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class test {\n\n    public static void main(String[] args) {\n        Scanner kb = new Scanner(System.in);\n        int n = kb.nextInt();\n        int a = kb.nextInt();\n        int b = kb.nextInt();\n        int array[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = kb.nextInt();\n        }\n        Arrays.sort(array);\n        int k = 0;\n        int t1 = 0;\n        int t2 = 0;\n        for (int i = 0; i < b; i++) {\n            t1= array[i];\n            if(i<n-1){\n                t2=array[i+1];\n                k=t2-t1;\n            }\n            else k=0;\n        }\n        System.out.println(k);\n\n    }\n}", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "\nimport java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.ObjectInputStream.GetField;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Global14 {\n\tstatic PrintWriter out;\n\tstatic Scanner sc;\n\tstatic ArrayList<int[]>q,w,x;\n\tstatic ArrayList<Integer>adj[];\n\tstatic HashSet<Integer>primesH;\n\tstatic boolean prime[];\n\t//static ArrayList<Integer>a;\n\tstatic HashSet<Long>tmp;\n\tstatic int[][][]dist;\n\tstatic boolean[]v;\n\tstatic int[]a,b,c,d;\n\tstatic Boolean[][]dp;\n\tstatic char[][]mp;\n\tstatic int A,B,n,m,h,ans,sum;\n\t//static String a,b;\n\tstatic long oo=(long)1e9+7;\n\tpublic static void main(String[]args) throws IOException {\n\t\tsc=new Scanner(System.in);\n\t\tout=new PrintWriter(System.out);\n\t\t//A();\n\t\t//B();\n\t\t//C();\n\t\t//D();\n\t\tE();\n\t\t//F();\n\t\t//G();\n\t\tout.close();\n\t}\n\t  private static void A() throws IOException {\n\t\t  int t=ni();\n\t\t  while(t-->0) {\n\t\t\t\tint n=ni(),w=ni();\n\t\t\t\ta=nai(n);\n\t\t\t\tint sum=0;\n\t\t\t\tfor(int i=0;i<n;i++)sum+=a[i];\n\t\t\t\tif(sum==w) {ol(\"NO\");continue;}\n\t\t\t\tif(sum<w) {\n\t\t\t\t\tol(\"YES\");\n\t\t\t\t\tdisp2(a);continue;\n\t\t\t\t}\n\t\t\t\tArrays.sort(a);\n\t\t\t\tint cur=0;\n\t\t\t\tfor(int i=n-1;i>=0;i--) {\n\t\t\t\t\tif(cur==w) {\n\t\t\t\t\t\tint tmp=a[i+1];\n\t\t\t\t\t\ta[i+1]=a[i];\n\t\t\t\t\t\ta[i]=tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcur+=a[i];\n\t\t\t\t}\n\t\t\t\tol(\"YES\");\n\t\t\t\tdisp2(a);\n\t\t\t\t\n\t\t  }\n\t\t\n\t   }\n\t\tstatic void B() throws IOException {\n\t\t\tint t=ni();\n\t\t\twhile(t-->0) {\n\t\t\t\tlong n=nl();\n\t\t\t\tif(n%2==0) {\n\t\t\t\tn/=2;\n\t\t\t\tint sq=(int)Math.sqrt(n);\n\t\t\t\tif(sq*sq==n&&sq!=0) {\n\t\t\t\t\tol(\"YES\");continue;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(n%2==0) {\n\t\t\t\tn/=2;\n\t\t\t\t int sq=(int)Math.sqrt(n);\n\t\t\t\tif(sq*sq==n&&sq!=0) {\n\t\t\t\t\tol(\"YES\");continue;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tol(\"NO\");\n\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\tstatic void C() throws IOException{\n\t\t\t int t=ni();\n\t\t\t while(t-->0) {\n\t\t\t\tint n=ni(),m=ni(),x=ni();\n\t\t\t\tint[][]a=new int[n][2];\n\t\t\t\tint mx=0;\n\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\ta[i][0]=ni();\n\t\t\t\t\ta[i][1]=i;\n\t\t\t\t\tmx=Math.max(mx, a[i][0]);\n\t\t\t\t}\n\t\t\t\tArrays.sort(a,(u,v)->u[0]-v[0]);\n\t\t\t\tPriorityQueue<int[]>vals=new PriorityQueue<int[]>((u,v)->u[0]-v[0]);\n\t\t\t\tint[]ans=new int[n];\n\t\t\t\t//int grp=1;\n\t\t\t\tvals.add(new int[] {a[0][0],1});\n\t\t\t\tans[a[0][1]]=1;\n\t\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\t\tif(vals.size()<m) {\n\t\t\t\t\t\tans[a[i][1]]=vals.size()+1;\n\t\t\t\t\t\tvals.add(new int[] {a[i][0],vals.size()+1});\n\t\t\t\t\t\tmx=Math.max(mx, a[i][0]);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tint[]p=vals.poll();\n\t\t\t\t\t\tvals.add(new int[] {p[0]+a[i][0],p[1]});\n\t\t\t\t\t\tans[a[i][1]]=p[1];\n\t\t\t\t\t\tmx=Math.max(mx, a[i][0]+p[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(mx-vals.peek()[0]>x)ol(\"NO\");\n\t\t\t\telse {\n\t\t\t\t\t\n\t\t\t\t\tol(\"YES\");\n\t\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\t\tout.print(ans[i]+\" \");\n\t\t\t\t\t}\n\t\t\t\t\tol(\"\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t }\n\t\t}\n\t\tprivate static Boolean dp(int i, int j) {\n\t\t\tif(j>sum/2)return false;\n\t\t\tif(i==x.size()) {\n\t\t\t\treturn sum/2==j;\n\t\t\t}\n\t\t\tif(dp[i][j]!=null)return dp[i][j];\n\t\t\t\n\t\t\treturn dp[i][j]=dp(i+1,j+x.get(i)[0])||dp(i+1,j);\n\t\t}\n\t\tstatic boolean isPrime(long n) {\n\t\t\tif(n==2)return true;\n\t\t\tif(n<2||n%2==0)return false;\n\t\t\t\n\t\t\tfor(long i=3L;i*i<n;i+=2l) {\n\t\t\t\tlong rem=(n%i);\n\t\t\t\tif(rem==0)return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tstatic void D() throws IOException {\n\t\t\tint t=ni();\n\t\t\twhile(t-->0) {\n\t\t\t\tint n=ni(),l=ni(),r=ni();\n\t\t\t\tint[]occ1=new int[n+1];\n\t\t\t\ta=nai(n);\n\t\t\t\tfor(int i=0;i<l;i++) {\n\t\t\t\t\tocc1[a[i]]++;\n\t\t\t\t}\n\t\t\t\tint[]occ2=new int[n+1];\n\t\t\t\tfor(int i=l;i<n;i++) {\n\t\t\t\t\tocc2[a[i]]++;\n\t\t\t\t}\n\t\t\t\tint base=Math.abs((n/2)-l);\n\t\t\t\tint tk=0;\n\t\t\t\tint[]lrg=l>r?occ1:occ2;\n\t\t\t\tint[]sml=l<=r?occ1:occ2;\n\t\t\t\tfor(int i=0;i<=n&&tk<base;i++) {\n\t\t\t\t\tint rem=base-tk;\n\t\t\t\t\tint taken=Math.min(rem, \n\t\t\t\t\t\t\tMath.max(0,(lrg[i]-sml[i])/2));\n\t\t\t\t\tlrg[i]-=taken;\n\t\t\t\t\tsml[i]+=taken;\n\t\t\t\t\ttk+=taken;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n&&tk<base;i++) {\n\t\t\t\t\tif(lrg[i]<=sml[i])continue;\n\t\t\t\t\tlrg[i]--;\n\t\t\t\t\tsml[i]++;\n\t\t\t\t\ttk++;\n\t\t\t\t}\n\t\t\t\tint c1=0,c2=0;\n\t\t\t\tfor(int i=0;i<=n;i++) {\n\t\t\t\t\tif(lrg[i]>sml[i]) {\n\t\t\t\t\t\tif(c1<0) {\n\t\t\t\t\t\t\tint diff=Math.min(-c1, -sml[i]+lrg[i]);\n\t\t\t\t\t\t\tlrg[i]-=diff;\n\t\t\t\t\t\t\tc1+=diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint nd=lrg[i]-sml[i];\n\t\t\t\t\t\tc2-=nd;\n\t\t\t\t\t\tbase+=nd;\n\t\t\t\t\t\tsml[i]=lrg[i];\n\t\t\t\t\t}else if(lrg[i]<sml[i]) {\n\t\t\t\t\t\tif(c2<0) {\n\t\t\t\t\t\t\tint diff=Math.min(-c2, sml[i]-lrg[i]);\n\t\t\t\t\t\t\tsml[i]-=diff;\n\t\t\t\t\t\t\tc2+=diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint nd=-lrg[i]+sml[i];\n\t\t\t\t\t\tbase+=nd;\n\t\t\t\t\t\tc1-=nd;\n\t\t\t\t\t\tlrg[i]=sml[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tol(base);\n\t\t\t}\n\t\t}\n\t\tprivate static int bfs(int i, int j,int k) {\n\t\t\tboolean [][]vis=new boolean[dist.length][dist[0].length];\n\t\t\tQueue<int[]>q=new LinkedList<int[]>();\n\t\t\tint mn=Integer.MAX_VALUE;\n\t\t\tq.add(new int[] {i,j,0,0});\n\t\t\tint[]dx=new int[] {-1,1,0,0};\n\t\t\tint[]dy=new int[] {0,0,1,-1};\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tint []x=q.poll();\n\t\t\t\tvis[x[0]][x[1]]=true;\n\t\t\t\tint c=x[2];\n\t\t\t\tif(c>k/2)continue;\n\t\t\t\tif(c>0&&k%c==0&&(k/c)%2==0) {\n\t\t\t\t\tmn=Math.min(mn,x[3]*k/c );\n\t\t\t\t}\n\t\t\t\tfor(int a=0;a<4;a++) {\n\t\t\t\t\tint nx=x[0]+dx[a];\n\t\t\t\t\tint ny=x[1]+dy[a];\n\t\t\t\t\tif(valid(nx,ny)&&!vis[nx][ny]) {\n\t\t\t\t\t\tq.add(new int[] {nx,ny,c+1,x[3]+dist[x[0]][x[1]][a]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn mn;\n\t\t}\n\t\tprivate static boolean valid(int nx, int ny) {\n\t\t\treturn nx>=0&&nx<dist.length&&ny>=0&&ny<dist[0].length;\n\t\t}\n\t\tstatic int gcd (int a, int b) {\n\t\t    return b==0?a:gcd (b, a % b);\n\t\t}\n\t\t\n\tstatic void E() throws IOException {\n\t\tint t=1;\n\t\twhile(t-->0) {\n\t\t\tint n=ni();\n\t\t\tlong oo=nl();\n\t\t\tlong fc[]=new long[n+1];\n\t\t\tfc[0]=fc[1]=1l;\n\t\t\tlong []pow2=new long[n+1];\n\t\t\tpow2[0]=1l;\n\t\t\tfor(int i=1;i<pow2.length;i++) {\n\t\t\t\tpow2[i]=(pow2[i-1]*2l)%oo;\n\t\t\t}\n\t\t\tfor(int i=2;i<fc.length;i++) {\n\t\t\t\tfc[i]=(fc[i-1]*1l*i)%oo;\n\t\t\t}\n\t\t\t\n\t\t\tlong ncr[][]=new long[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++) {\n\t\t\t\tfor(int j=0;j<=i;j++) {\n\t\t\t\t\tncr[i][j]=i==0||j==0?1l:(ncr[i-1][j-1]+ncr[i-1][j])%oo;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans=0;\n\t\t\tlong dp[][]=new long[n+2][n+2];\n\t\t\tdp[0][0]=1l;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<=i;j++) {\n\t\t\t\t\tfor(int k=1;i+k<=n;k++) {\n\t\t\t\t\t\tdp[i+k+1][j+k]+=((dp[i][j]*pow2[k-1]%oo)*ncr[j+k][k])%oo;\n\t\t\t\t\t\tdp[i+k+1][j+k]%=oo;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++) {\n\t\t\t\tans=(ans+dp[n+1][i])%oo;\n\t\t\t}\n\t\t\tol(\"\"+ans);\n\t\t\t//ol(\"\"+pow2[3]);\n\t\t}\n\t\t\n\t}\n\n\tstatic void F() throws IOException {\n\t\tint t=ni();\n\t\twhile(t-->0) {\n\t\t\t\n\t\t}\n\t}\n\tstatic void CC() throws IOException {\n\t\tfor(int kk=2;kk<21;kk++) {\n\t\t\tol(kk+\"   -------\");\n\t\tint n=kk;\n\t\tint k=n-2;\n\t\tint msk=1<<k;\n\t\tint[]a=new int[k];\n\t\tfor(int i=0;i<a.length;i++)a[i]=i+2;\n\t\tint mx=1;\n\t\tint ms=0;\n\t\tfor(int i=1;i<msk;i++) {\n\t\t\tlong prod=1;\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<a.length;j++) {\n\t\t\t\tif(((i>>j)&1)!=0) {\n\t\t\t\t\tprod*=a[j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt>=mx&&prod%n==1) {\n\t\t\t\tmx=cnt;\n\t\t\t\tms=i;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tol(mx==1?mx:mx+1);\n\t\tout.print(1+\" \");\n\t\tlong pr=1;\n\t\tfor(int j=0;j<a.length;j++) {\n\t\t\tif(((ms>>j)&1)!=0) {\n\t\t\t\tout.print(a[j]+\" \");\n\t\t\t\tpr*=a[j];\n\t\t\t}\n\t\t}\n\t\tol(\"\");\n\t\tol(\"Prod: \"+pr);\n\t\tol(n+\"*\"+((pr-1)/n)+\" + \"+1);\n\t\t}\n\t}\n\tstatic int ni() throws IOException {\n\t\treturn sc.nextInt();\n\t}\n\tstatic double nd() throws IOException {\n\t\treturn sc.nextDouble();\n\t}\n\tstatic long nl() throws IOException {\n\t\treturn  sc.nextLong();\n\t}\n\tstatic String ns() throws IOException {\n\t\treturn sc.next();\n\t}\n\tstatic int[] nai(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\treturn a;\n\t}\n\tstatic long[] nal(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = sc.nextLong();\n\t\treturn a;\n\t}\n\tstatic int[][] nmi(int n,int m) throws IOException{\n\t\tint[][]a=new int[n][m];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\ta[i][j]=sc.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tstatic long[][] nml(int n,int m) throws IOException{\n\t\tlong[][]a=new long[n][m];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\ta[i][j]=sc.nextLong();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\tstatic void o(String x) {\n\t\tout.print(x);\n\t}\n\tstatic void ol(String x) {\n\t\tout.println(x);\n\t}\n\tstatic void ol(int x) {\n\t\tout.println(x);\n\t}\n\tstatic void disp1(int []a) {\n\t\tfor(int i=0;i<a.length;i++) {\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tstatic void disp2(int []a) {\n\t\tfor(int i=a.length-1;i>=0;i--) {\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic boolean hasNext() {return st.hasMoreTokens();}\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\t\n\t\tpublic double nextDouble() throws IOException {return Double.parseDouble(next());}\n\t\t\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\t\t\t\n\t\tpublic boolean ready() throws IOException {return br.ready(); }\n\t\t\n\n\t}\n}\n\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String args[]) {\n    Scanner scanner = new Scanner(System.in);\n    int n = scanner.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; ++i) {\n        arr[i] = scanner.nextInt();\n    }\n    boolean isOdd = false;\n    if ((arr[0] % 2 == 0 && arr[1] % 2 == 0) || (arr[0] % 2 == 0 && arr[2] % 2 == 0)\n        || (arr[1] % 2 == 0 && arr[2] % 2 == 0)) {\n        isOdd = true;\n    }\n    if (isOdd) {\n        for (int i = 0; i < n; ++i) {\n        if (arr[i] % 2 == 1) {\n            System.out.println(i + 1);\n            break;\n        }\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n        if (arr[i] % 2 == 0) {\n            System.out.println(i + 1);\n            break;\n        }\n        }\n    }\n\n    }\n\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import static java.lang.Math.max;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class GivenString implements Runnable\n{\n  public static void main(String[] args) throws Exception\n  {\n    new GivenString().run();\n  }\n\n  private void solve() throws Exception\n  {\n    String s = nextToken();\n    int len = s.length();\n    KMP kmp = new KMP();\n    int r = 0;\n    for (int i = 0; i < len; i++)\n    {\n      for (int j = i + 1; j <= len; j++)\n      {\n        String cur = s.substring(i, j);\n        int count = kmp.search(s, cur);\n        if (count >= 2)\n          r = max(r, cur.length());\n      }\n    }\n    out.println(r);\n  }\n\n  class KMP\n  {\n    public int search(String text, String pattern)\n    {\n      int count = 0;\n      int n = text.length(), m = pattern.length(), matchPoint = -1;\n      char pat[] = pattern.toCharArray(), t[] = text.toCharArray();\n      int p[] = prefixTable(pattern);\n      int j = 0;\n      for (int i = 0; i < n; i++)\n      {\n        while (j > 0 && pat[j] != t[i])\n          j = p[j - 1];\n        if (pat[j] == t[i])\n          j++;\n        if (j == m)\n        {\n          matchPoint = i - m + 1;\n          j = p[j - 1];\n          count++;\n        }\n      }\n      return count;\n    }\n\n    private int[] prefixTable(String pat)\n    {\n      int m = pat.length(), p[] = new int[m];\n      char s[] = pat.toCharArray();\n      int j = 0;\n      for (int i = 1; i < m; i++)\n      {\n        while (j > 0 && s[j] != s[i])\n          j = p[j - 1];\n        if (s[j] == s[i])\n          j++;\n        p[i] = j;\n      }\n      return p;\n    }\n\n  }\n\n  // -------------- Input/Output routines below ---------------//\n  private BufferedReader in;\n  PrintWriter out;\n  StringTokenizer tokenizer;\n\n  public void run()\n  {\n    // String problem = this.getClass().getName();\n    try\n    {\n      in = new BufferedReader(new InputStreamReader(System.in));\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      solve();\n      out.flush();\n      in.close();\n      out.close();\n    }\n    catch (Exception e)\n    {\n      e.printStackTrace();\n      // System.exit(1);\n    }\n  }\n\n  String nextToken() throws IOException\n  {\n    while (tokenizer == null || !tokenizer.hasMoreTokens())\n    {\n      tokenizer = new StringTokenizer(in.readLine());\n    }\n    return tokenizer.nextToken();\n  }\n\n  int nextInt() throws IOException\n  {\n    return Integer.parseInt(nextToken());\n  }\n\n  long nextLong() throws IOException\n  {\n    return Long.parseLong(nextToken());\n  }\n\n  double nextDouble() throws IOException\n  {\n    return Double.parseDouble(nextToken());\n  }\n\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n   private static IO io;\n\n   public static void main(String[] args) throws IOException {\n       new Main().run();\n   }\n\n   private void run() throws IOException {\n       io = new IO(System.getProperty(\"ONLINE_JUDGE\")!=null);\n       solve();\n       io.flush();\n   }\n   \n   private void solve() throws IOException {\n       int n = io.nI(), a = io.nI(), b = io.nI(), h[] = new int[n], i;\n       for(i = 0; i<n; i++)h[i] = io.nI(); Arrays.sort(h);\n       io.wln(h[b]-h[b-1]);\n   }//2.2250738585072012e-308\n   \n   private int gcd(int a, int b) {\n       while(b>0) b^=a^=b^=a%=b;\n       return a;\n   }\n   \n   @SuppressWarnings(\"unused\")\n   private class IO{\n       StreamTokenizer in; PrintWriter out; BufferedReader br; Reader reader; Writer writer;\n       public IO(boolean oj) throws IOException{\n           Locale.setDefault(Locale.US);\n           reader = oj ? new InputStreamReader(System.in) : new FileReader(\"input.txt\");\n           writer = oj ? new OutputStreamWriter(System.out) : new FileWriter(\"output.txt\");\n           br = new BufferedReader(reader);\n           in = new StreamTokenizer(br);\n           out = new PrintWriter(writer);\n       }\n       public void wln(){out.println();}\n       public void wln(int arg){out.println(arg);}\n       public void wln(long arg){out.println(arg);}\n       public void wln(double arg){out.println(arg);}\n       public void wln(String arg){out.println(arg);}\n       public void wln(boolean arg){out.println(arg);}\n       public void wln(char arg){out.println(arg);}\n       public void wln(float arg){out.println(arg);}\n       public void wln(Object arg){out.println(arg);}\n       public void w(int arg){out.print(arg);}\n       public void w(long arg){out.print(arg);}\n       public void w(double arg){out.print(arg);}\n       public void w(String arg){out.print(arg);}\n       public void w(boolean arg){out.print(arg);}\n       public void w(char arg){out.print(arg);}\n       public void w(float arg){out.print(arg);}\n       public void w(Object arg){out.print(arg);}\n       public void wf(String format, Object...args){out.printf(format, args);}\n       public void flush(){out.flush();}\n       public int nI() throws IOException {in.nextToken(); return(int)in.nval;}\n       public long nL() throws IOException {in.nextToken(); return(long)in.nval;}\n       public String nS() throws IOException {in.nextToken(); return in.sval;}\n       public double nD() throws IOException {in.nextToken(); return in.nval;}\n       public float nF() throws IOException {in.nextToken(); return (float)in.nval;}\n       public void wc(char...a){for(char c : a){in.ordinaryChar(c);in.wordChars(c, c);}}\n       public void wc(char c1, char c2){in.ordinaryChars(c1, c2); in.wordChars(c1, c2);}\n   }\n}", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static BufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer tok;\n    static boolean hasNext()\n    {\n        while(tok==null||!tok.hasMoreTokens())\n            try{\n                tok=new StringTokenizer(in.readLine());\n            }\n            catch(Exception e){\n                return false;\n            }\n        return true;\n    }\n    static String next()\n    {\n        hasNext();\n        return tok.nextToken();\n    }\n    static long nextLong()\n    {\n        return Long.parseLong(next());\n    }\n    static int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) {\n        Map<Integer,Integer> map = new HashMap();\n        map.put(0,1);\n        int n = nextInt();\n        int m = nextInt();\n        int index = -1;\n        int a[] = new int[n];\n        for(int i=0;i<n;i++){\n            a[i]=nextInt();\n            if(a[i]==m)\n                index=i;\n        }\n        int sum = 0;\n        for(int i=0;i<index;i++){\n            if (a[i]<m)\n                sum--;\n            else\n                sum++;\n            if (map.containsKey(sum)){\n                map.put(sum,map.get(sum)+1);\n            }else {\n                map.put(sum,1);\n            }\n        }\n        long ans = 0;\n        for(int i=index;i<n;i++){\n            if (a[i]<m)\n                sum--;\n            else if(a[i]>m)\n                sum++;\n            if (map.containsKey(sum))\n                ans+=map.get(sum);\n            if (map.containsKey(sum-1))\n                ans+=map.get(sum-1);\n        }\n        out.print(ans);\n        out.flush();\n    }\n}\n", "complexity": "nlogn", "problem": "1005_E1", "from": "CODEFORCES", "tags": "sortings"}
{"src": "\nimport java.util.*;\n\n\npublic class B\n{\n   public static void main(String[] args)\n   {\n      new B(new FastScanner());\n   }\n\n   int hash(int i, int[] cc)\n   {\n      int res = i;\n      for (int ii : cc)\n      {\n         res *= 8;\n         res += ii;\n      }\n\n      return res;\n   }\n\n   int N, K, A;\n   int[] lvl;\n   int[] vs; // loyalty\n\n   \n   double calc(int i, int[] cc)\n   {\n      // Find the probability of winning\n      double res = 0;\n\n      int cnt = 0;\n      for (int m=0; m<1<<N; m++)\n      {\n         double pt = 1.0;\n         boolean passed = true;\n         int nG = 0;\n            \n         int lvlcnt = 0;\n         for (int j=0; j<N; j++)\n         {\n            int p = 10*cc[j]+vs[j];\n            int u = m&(1<<j);\n\n            boolean votesGood = (u > 0);\n            if (votesGood)\n               nG++;\n            else\n               lvlcnt += lvl[j];\n               \n            if ((p == 0)&&(votesGood))\n               passed = false;\n            if ((p == 100)&&(!votesGood))\n               passed = false;\n            if (!passed)\n               break;\n\n            if (votesGood)\n               pt *= (p/100.0);\n            else\n               pt *= ((100-p)/100.0);\n         }\n\n         if (passed == false)\n            continue;\n         \n         if (2*nG <= N)\n         {\n            // Calculate if we kill all senators\n            double p1 = A/(1.0*(A+lvlcnt));\n            \n            // Add in the probability of losing\n            res += (1-p1)*pt;\n         }\n      }\n\n      return 1.0-res;\n   }\n\n   HashMap<Integer, Double> memo;\n   double go(int i, int[] cc)\n   {\n      if (i == -1)\n         return calc(i, cc);\n\n      int hv = hash(i, cc);\n      Double rr = memo.get(hv);\n      if (rr != null)\n         return rr;\n\n      double res = go(i-1, cc);\n      for (int j=0; j<N; j++)\n      {\n         int cv = vs[j]+cc[j]*10;\n         if (cv == 100)\n            continue;\n\n         cc[j]++;\n         double rrr = go(i-1, cc);\n         cc[j]--;\n         \n         if (rrr > res)\n            res = rrr;\n      }\n      \n      memo.put(hv, res);\n      return res;\n   }\n\n   public B(FastScanner in)\n   {\n      N = in.nextInt();\n      K = in.nextInt();\n      A = in.nextInt();\n      memo = new HashMap<Integer, Double>();\n\n      lvl = new int[N];\n      vs = new int[N];\n      for (int i=0; i<N; i++)\n      {\n         lvl[i] = in.nextInt();\n         vs[i] = in.nextInt();\n      }\n\n      int[] cs = new int[8];\n      double res = go(K-1, cs);\n      System.out.printf(\"%.10f%n\", res);\n   }\n}\n\n\nclass FastScanner{\n    int nextInt(){\n        try{\n            int c=System.in.read();\n            if(c==-1) return c;\n            while(c!='-'&&(c<'0'||'9'<c)){\n                c=System.in.read();\n                if(c==-1) return c;\n            }\n            if(c=='-') return -nextInt();\n            int res=0;\n            do{\n                res*=10;\n                res+=c-'0';\n                c=System.in.read();\n            }while('0'<=c&&c<='9');\n            return res;\n        }catch(Exception e){\n            return -1;\n        }\n    }\n    \n    long nextLong(){\n        try{\n            int c=System.in.read();\n            if(c==-1) return -1;\n            while(c!='-'&&(c<'0'||'9'<c)){\n                c=System.in.read();\n                if(c==-1) return -1;\n            }\n            if(c=='-') return -nextLong();\n            long res=0;\n            do{\n                res*=10;\n                res+=c-'0';\n                c=System.in.read();\n            }while('0'<=c&&c<='9');\n            return res;\n        }catch(Exception e){\n            return -1;\n        }\n    }\n    \n    double nextDouble(){\n        return Double.parseDouble(next());\n    }\n    \n    String next(){\n        try{\n            StringBuilder res=new StringBuilder(\"\");\n            int c=System.in.read();\n            while(Character.isWhitespace(c))\n                c=System.in.read();\n            do{\n                res.append((char)c);\n            }while(!Character.isWhitespace(c=System.in.read()));\n            return res.toString();\n        }catch(Exception e){\n            return null;\n        }\n    }\n    \n    String nextLine(){\n        try{\n            StringBuilder res=new StringBuilder(\"\");\n            int c=System.in.read();\n            while(c=='\\r'||c=='\\n')\n                c=System.in.read();\n            do{\n                res.append((char)c);\n                c=System.in.read();\n            }while(c!='\\r'&&c!='\\n');\n            return res.toString();\n        }catch(Exception e){\n            return null;\n        }\n    }\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.util.Scanner;\n\n/**\n * <a href=\"http://codeforces.com/problemset/problem/122/A\"/>\n */\npublic class Problem122A {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        if (checkDivisible(s)) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n\n    private static boolean checkDivisible(String a) {\n        int num = Integer.parseInt(a);\n        if (num % 4 == 0 || num % 7 == 0 || num % 47 == 0) {\n            return true;\n        }\n        a = a.replace(\"4\", \"\");\n        a = a.replace(\"7\", \"\");\n        if (a.length() == 0) {\n            return true;\n        }\n        return false;\n    }\n}\n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.io.*;\n\nimport java.math.BigInteger;\n\nimport java.util.*;\n\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t(new Main()).solve();\n\n\t}\n\n\n\n\tpublic Main() {\n\n\t}\n\n\t\n\n\tMyReader in = new MyReader();\n\n\tPrintWriter out = new PrintWriter(System.out);\n\n\t\n\n\tvoid solve() throws IOException {\n\n\t\t// BufferedReader in = new BufferedReader(new\n\n\t\t// InputStreamReader(System.in));\n\n\t\t// Scanner in = new Scanner(System.in);\n\n\n\n\t\t//Scanner in = new Scanner(new FileReader(\"forbidden-triples.in\"));\n\n\t\t//PrintWriter out = new PrintWriter(\"forbidden-triples.out\");\n\n\t\tlong n = in.nextLong();\n\n\t\tlong k = in.nextLong();\n\n\t\tlong sum = 1;\n\n\t\tlong count = 0;\n\n\t\t\n\n\t\tlong index = k - 1;\n\n\t\t\n\n\t\tlong[] delta = {1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100, 10, 1, 0};\n\n\t\t\n\n\t\twhile (index > 0) {\n\n\t\t\tif (index + sum <= n) {\n\n\t\t\t\tfor (int d = 0; d < delta.length; d++) {\n\n\t\t\t\t\tif (delta[d] < index) {\n\n\t\t\t\t\t\tlong m = (2 * index - delta[d])*(delta[d] + 1)/2;\n\n\t\t\t\t\t\tif (m + sum <= n) {\n\n\t\t\t\t\t\t\tsum += m;\n\n\t\t\t\t\t\t\tindex -= (delta[d] + 1);\n\n\t\t\t\t\t\t\tcount += (delta[d] + 1);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tindex = n - sum;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (sum == n) {\n\n\t\t\tout.println(count);\n\n\t\t} else {\n\n\t\t\tout.println(-1);\n\n\t\t}\n\n\t\t\n\n\t\t\n\n\t\tout.close();\n\n\t}\t\n\n\n\n};\n\n\n\nclass MyReader {\n\n\tprivate BufferedReader in;\n\n\tString[] parsed;\n\n\tint index = 0;\n\n\n\n\tpublic MyReader() {\n\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\n\t}\n\n\n\n\tpublic int nextInt() throws NumberFormatException, IOException {\n\n\t\tif (parsed == null || parsed.length == index) {\n\n\t\t\tread();\n\n\t\t}\n\n\t\treturn Integer.parseInt(parsed[index++]);\n\n\t}\n\n\n\n\tpublic long nextLong() throws NumberFormatException, IOException {\n\n\t\tif (parsed == null || parsed.length == index) {\n\n\t\t\tread();\n\n\t\t}\n\n\t\treturn Long.parseLong(parsed[index++]);\n\n\t}\n\n\t\n\n\tpublic String nextString() throws IOException {\n\n\t\tif (parsed == null || parsed.length == index) {\n\n\t\t\tread();\n\n\t\t}\n\n\t\treturn parsed[index++];\n\n\t}\n\n\n\n\tprivate void read() throws IOException {\n\n\t\tparsed = in.readLine().split(\" \");\n\n\t\tindex = 0;\n\n\t}\n\n\n\n\tpublic String readLine() throws IOException {\n\n\t\treturn in.readLine();\n\n\t}\n\n};", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution{\n    \n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    public static void main(String args[] ) {\n        \n        FastReader sc = new FastReader();\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] arr = new int[105];\n        \n        for(int i=0;i<m;i++){\n            int a = sc.nextInt();\n            arr[a]++;\n        }\n        \n        for(int i=1;i<=1000;i++){\n            int sum=0;\n            \n            for(int a:arr){\n                if(a!=0){\n                    sum+=(a/i);\n                }\n            }\n            \n            \n            if(sum<n){\n                System.out.println(i-1);\n                return;\n            }\n            \n        }\n    }\n\n}\n", "complexity": "quadratic", "problem": "1011_B", "from": "CODEFORCES", "tags": "binary search,brute force,implementation"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.FileNotFoundException;\n\nimport java.io.FileReader;\n\nimport java.io.IOException;\n\nimport java.io.PrintWriter;\n\nimport java.util.Arrays;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\nimport java.util.StringTokenizer;\n\n\n\n\n\npublic class Main {\n\n\tstatic int n, m, k;\n\n\tstatic int inf = (int) 1e9;\n\n\tstatic class Pair {\n\n\t\tint x, y;\n\n\t\tPair(int a, int b) {\n\n\t\t\tx = a; y = b;\n\n\t\t}\n\n\t}\n\n\tstatic int[] dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};\n\n\tstatic boolean valid(int x, int y) {\n\n\t\treturn x >= 0 && x < n && y >= 0 && y < m;\n\n\t}\n\n\tstatic int[][] bfs(int[] xs, int[] ys) {\n\n\t\tint[][] dist = new int[n][m];\n\n\t\tfor(int i = 0; i < n; i++)\n\n\t\t\tArrays.fill(dist[i], inf);\n\n\t\tQueue<Pair> q = new LinkedList<>();\n\n\t\tfor(int i = 0; i < k; i++) {\n\n\t\t\tdist[xs[i]][ys[i]] = 0;\n\n\t\t\tq.add(new Pair(xs[i], ys[i]));\n\n\t\t}\n\n\n\n\t\twhile(!q.isEmpty()) {\n\n\t\t\tPair p = q.remove();\n\n\t\t\tfor(int d = 0; d < 4; d++) {\n\n\t\t\t\tint nx = p.x + dx[d], ny = p.y + dy[d];\n\n\t\t\t\tif(valid(nx, ny) && dist[nx][ny] == inf) {\n\n\t\t\t\t\tdist[nx][ny] = dist[p.x][p.y] + 1;\n\n\t\t\t\t\tq.add(new Pair(nx, ny));\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\treturn dist;\n\n\t}\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner in = new Scanner();\n\n\t\tint n = in.nextInt() ; \n\n\t\tint m = in.nextInt(); \n\n\t\tint k = in.nextInt(); \n\n\t\tint x[] = new int[k] ; \n\n\t\tint y[] = new int[k] ; \n\n\t\tint trees [][] = new int [n][m] ;\n\n\n\n\n\n\t\tfor (int i = 0; i < n; i++)\n\n\t\t\tfor (int j = 0; j < m; j++)\n\n\t\t\t\ttrees[i][j]=Integer.MAX_VALUE ;\n\n\n\n\t\tfor (int i = 0; i < k; i++)\n\n\t\t{\n\n\t\t\tx[i]=in.nextInt()-1; \n\n\t\t\ty[i]=in.nextInt()-1;\n\n\t\t\ttrees[x[i]][y[i]]=0 ;\n\n\t\t}\n\n\n\n\t\tint dis = Integer.MIN_VALUE ; ;\n\n\t\tint xp=0; ;\n\n\t\tint yp=0;\n\n\t\tfor (int i = 0; i < n; i++)\n\n\t\t\tfor (int j = 0; j < m; j++)\n\n\t\t\t\tif(trees[i][j] != 0)\n\n\t\t\t\t\tfor (int j2 = 0; j2 < k; j2++)\n\n\t\t\t\t\t\ttrees[i][j]=Math.min(trees[i][j], Math.abs(i-x[j2])+Math.abs(j-y[j2]));\n\n\n\n\t\tfor (int i = 0; i <n; i++)\n\n\t\t\tfor (int j = 0; j < m; j++)\n\n\t\t\t\tif(trees[i][j] > dis)\n\n\t\t\t\t{\n\n\t\t\t\t\tdis=trees[i][j];\n\n\t\t\t\t\txp=i+1;\n\n\t\t\t\t\typ=j+1;\n\n\t\t\t\t}\n\n\t\tPrintWriter out = new PrintWriter(\"output.txt\");\n\n\t\tout.printf(\"%d %d\\n\", xp ,yp);\n\n\t\tout.close();\n\n\t}\n\n\n\n\tstatic class Scanner {\n\n\t\tBufferedReader br;\n\n\t\tStringTokenizer st;\n\n\t\tScanner() throws FileNotFoundException {\n\n\t\t\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\n\t\t}\n\n\n\n\t\tString next() throws IOException {\n\n\t\t\twhile(st == null || !st.hasMoreTokens())\n\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\n\t\t}\n\n\n\n\t\tint nextInt() throws IOException {\n\n\t\t\treturn Integer.parseInt(next());\n\n\t\t}\n\n\t}\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E2RotateColumnsHardVersion solver = new E2RotateColumnsHardVersion();\n        int testCount = Integer.parseInt(in.next());\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class E2RotateColumnsHardVersion {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            E2RotateColumnsHardVersion.Column[] columns = new E2RotateColumnsHardVersion.Column[m];\n            for (int i = 0; i < columns.length; ++i) columns[i] = new E2RotateColumnsHardVersion.Column(new int[n]);\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    columns[j].vals[i] = in.nextInt();\n                }\n            }\n            for (E2RotateColumnsHardVersion.Column column : columns) column.initMax();\n            Arrays.sort(columns, new Comparator<E2RotateColumnsHardVersion.Column>() {\n\n                public int compare(E2RotateColumnsHardVersion.Column o1, E2RotateColumnsHardVersion.Column o2) {\n                    return o2.max - o1.max;\n                }\n            });\n            if (columns.length > n)\n                columns = Arrays.copyOf(columns, n);\n            out.println(solveOne(columns));\n        }\n\n        private int solveOne(E2RotateColumnsHardVersion.Column[] columns) {\n            int n = columns[0].vals.length;\n            int[] best = new int[1 << n];\n            int[] next = new int[1 << n];\n            int[] temp = new int[1 << n];\n\n            for (E2RotateColumnsHardVersion.Column nowColumn : columns) {\n                System.arraycopy(best, 0, next, 0, best.length);\n                for (int rot = 0; rot < n; ++rot) {\n                    System.arraycopy(best, 0, temp, 0, next.length);\n                    for (int i = 0, pos = rot; i < n; ++i, ++pos) {\n                        if (pos >= n) pos = 0;\n                        int val = nowColumn.vals[pos];\n                        for (int j = 0; j < temp.length; ++j) {\n                            if ((j & (1 << i)) == 0) {\n                                temp[j | (1 << i)] = Math.max(temp[j | (1 << i)], temp[j] + val);\n                            }\n                        }\n                    }\n                    for (int j = 0; j < temp.length; ++j) {\n                        next[j] = Math.max(next[j], temp[j]);\n                    }\n                }\n                int[] aa = best;\n                best = next;\n                next = aa;\n            }\n            return best[best.length - 1];\n        }\n\n        static class Column {\n            int[] vals;\n            int max;\n\n            public Column(int[] vals) {\n                this.vals = vals;\n            }\n\n            void initMax() {\n                max = 0;\n                for (int vv : vals) max = Math.max(max, vv);\n            }\n\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public String next() {\n            return nextString();\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class A {\n    public static void main(String[] args) throws Exception {\n        new A().solve();\n    }\n    void solve() throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        if (n == 0) {\n            System.out.println(\"0 0 0\");\n            return;\n        }\n        int p2 = 0;\n        int p1 = 1;\n        while (true) {\n            int now = p2 + p1;\n            if (n == now) {\n                System.out.println(\"0 \" + p1 + \" \" + p2);\n                return;\n            } else {\n                p2 = p1;\n                p1 = now;\n            }\n        }\n    }\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "\n\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader sc = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, sc, out);\n        out.close();\n    }\n\n    static class Task {\n        public void solve(int testNumber, InputReader sc, PrintWriter out) {\n            double n=sc.nextInt();\n            double k=sc.nextInt();\n            \n            double ans=n-(-1.5+Math.sqrt(9.0/4+2*(n+k)));\n            out.printf(\"%.0f\\n\",ans);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Answer23A{\n    public static void main(String[] args){\n\tBufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n\tnew Kai(reader).solve();\n    }\n}\nclass Kai{\n    BufferedReader reader;\n    public Kai(BufferedReader reader){\n\tthis.reader=reader;\n    }\n    public void solve(){\n\t//TODO\n\tString s=read();\n\tint max=0;\n\tfor(int i=1;i<=s.length()-1;i++){\n\t    for(int j=0;j<=s.length()-i;j++){\n\t\tString h=s.substring(j,j+i);\n\t\tfor(int k=j+1;k<=s.length()-i;k++){\n\t\t    if(h.equals(s.substring(k,k+i))){\n\t\t\tmax=i;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tpln(max);\n\t\t\t\n    }\n    //tools//////////////////////////////////////////////////\n    public String read(){\n\tString s=null;\n\ttry{\n\t    s=reader.readLine();\n\t}catch(IOException e){\n\t    e.printStackTrace();\n\t}\n\treturn s;\n    }\n    public int[] to_i(String[] s){\n\tint[] tmp=new int[s.length];\n\tfor(int i=0;i<s.length;i++){\n\t    tmp[i]=to_i(s[i]);\n\t}\n\treturn tmp;\n    }\n    public long[] to_l(String[] s){\n\tlong[] tmp=new long[s.length];\n\tfor(int i=0;i<s.length;i++){\n\t    tmp[i]=to_l(s[i]);\n\t}\n\treturn tmp;\n    }\n    public int to_i(String s){\n\treturn Integer.parseInt(s);\n    }\n    public long to_l(String s){\n\treturn Long.parseLong(s);\n    }\n    public void p(Object s){\n\tSystem.out.print(s);\n    }\n    public void pln(Object s){\n\tSystem.out.println(s);\n    }\n    public void debug(Object s){\n\tSystem.err.print(s);\n    }\n    public void debugln(Object s){\n\tSystem.err.println(s);\n    }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\npublic class c8 {\n    static int n;\n    static int[] ds;\n    static int[][] g;\npublic static void main(String[] args)\n{\n    Scanner input = new Scanner(System.in);\n    int x = input.nextInt(), y = input.nextInt();\n    n = input.nextInt();\n    int[] xs = new int[n], ys = new int[n];\n    for(int i = 0; i<n; i++)\n    {\n        xs[i] = input.nextInt();\n        ys[i] = input.nextInt();\n    }\n    ds = new int[n];\n    g = new int[n][n];\n    for(int i = 0; i<n; i++)\n    {\n        ds[i] = (x - xs[i])  *  (x - xs[i]) + (y - ys[i]) * (y - ys[i]);\n        for(int j = 0; j<n; j++)\n        {\n            g[i][j] = (xs[i] - xs[j]) * (xs[i] - xs[j]) + (ys[i] - ys[j]) * (ys[i] - ys[j]);\n        }\n    }\n    int[] dp = new int[1<<n];\n    Arrays.fill(dp, 987654321);\n    dp[0] = 0;\n    for(int i = 0; i<(1<<n); i++)\n    {\n        if(dp[i] == 987654321) continue;\n        for(int a = 0; a<n; a++)\n        {\n            if((i & (1<<a)) > 0) continue;\n            dp[i | (1<<a)] = Math.min(dp[i | (1<<a)], dp[i] + 2*ds[a]);\n            for(int b = a+1; b<n; b++)\n            {\n                if((i & (1<<b)) > 0) continue;\n                dp[i | (1<<a) | (1<<b)] = Math.min(dp[i | (1<<a) | (1<<b)], dp[i] + ds[a] + ds[b] + g[a][b]);\n            }\n            break;\n        }\n    }\n    Stack<Integer> stk = new Stack<Integer>();\n    stk.add(0);\n    int i = (1<<n) - 1;\n    //System.out.println(Arrays.toString(dp));\n\n    trace:\n    while(i > 0)\n    {\n        //System.out.println(i);\n        for(int a = 0; a<n; a++)\n        {\n            if((i & (1<<a)) == 0) continue;\n            if( dp[i] == dp[i - (1<<a)] + 2*ds[a])\n            {\n                stk.add(a+1);\n                stk.add(0);\n                i -= (1<<a);\n                continue trace;\n            }\n            for(int b = a+1; b<n; b++)\n            {\n                if((i & (1<<b)) == 0) continue;\n                if(dp[i] == dp[i - (1<<a) - (1<<b)] + ds[a] + ds[b] + g[a][b])\n                {\n                    stk.add(a+1);\n                    stk.add(b+1);\n                    stk.add(0);\n                    i -= (1<<a) + (1<<b);\n                    continue trace;\n                }\n            }\n            //break;\n        }\n    }\n    System.out.println(dp[(1<<n) - 1]);\n    while(!stk.isEmpty()) System.out.print(stk.pop()+\" \");\n}\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "/*\n    Author: @__goku__\n    ssrivastava990@gmail.com\n\n                   `\\-.   `\n                      \\ `.  `\n                       \\  \\ |\n              __.._    |   \\.       S O N - G O K U\n       ..---~~     ~ . |    Y\n         ~-.          `|    |\n            `.               `~~--.\n              \\                    ~.\n               \\                     \\__. . -- -  .\n         .-~~~~~      ,    ,            ~~~~~~---...._\n      .-~___        ,'/  ,'/ ,'\\          __...---~~~\n            ~-.    /._\\_( ,(/_. 7,-.    ~~---...__\n           _...>-  P\"\"6=`_/\"6\"~   6)    ___...--~~~\n            ~~--._ \\`--') `---'   9'  _..--~~~\n                  ~\\ ~~/_  ~~~   /`-.--~~\n                    `.  ---    .'   \\_\n                      `. \" _.-'     | ~-.,-------._\n                  ..._../~~   ./       .-'    .-~~~-.\n            ,--~~~ ,'...\\` _./.----~~.'/    /'       `-\n        _.-(      |\\    `/~ _____..-' /    /      _.-~~`.\n       /   |     /. ^---~~~~       ' /    /     ,'  ~.   \\\n      (    /    (  .           _ ' /'    /    ,/      \\   )\n      (`. |     `\\   - - - - ~   /'      (   /         .  |\n       \\.\\|       \\            /'        \\  |`.           /\n       /.'\\\\      `\\         /'           ~-\\         .  /\\\n      /,   (        `\\     /'                `.___..-      \\\n     | |    \\         `\\_/'                  //      \\.     |\n     | |     |                 _Seal_      /' |       |     |\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class C169D\n{\n    static PrintWriter out = new PrintWriter((System.out));\n\n    public static void main(String args[]) throws IOException\n    {\n        Kioken sc = new Kioken();\n        long l = sc.nextLong();\n        long r = sc.nextLong();\n        long d = l ^ r;\n        int c=0;\n        while (d > 0)\n        {\n            c++;\n            d>>=1;\n        }\n        long ans=0;\n        while(c-->0)\n        {\n            ans=ans<<1l;\n            ans++;\n        }\n        out.println(ans);\n        out.close();\n    }\n\n    public static void kamehameha()\n    {\n    }\n\n    public static int lower_bound(ArrayList<Integer> ar, int k)\n    {\n        int s = 0, e = ar.size();\n        while (s != e)\n        {\n            int mid = s + e >> 1;\n            if (ar.get(mid) <= k)\n            {\n                s = mid + 1;\n            }\n            else\n            {\n                e = mid;\n            }\n        }\n        return Math.abs(s) - 1;\n    }\n\n    public static int upper_bound(ArrayList<Integer> ar, int k)\n    {\n        int s = 0;\n        int e = ar.size();\n        while (s != e)\n        {\n            int mid = s + e >> 1;\n            if (ar.get(mid) < k)\n            {\n                s = mid + 1;\n            }\n            else\n            {\n                e = mid;\n            }\n        }\n        if (s == ar.size())\n        {\n            return -1;\n        }\n        return s;\n    }\n\n    static class Kioken\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        public String next()\n        {\n            while (!st.hasMoreTokens())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (Exception e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine()\n        {\n            try\n            {\n                return br.readLine();\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        public boolean hasNext()\n        {\n            String next = null;\n            try\n            {\n                next = br.readLine();\n            }\n            catch (Exception e)\n            {\n            }\n            if (next == null)\n            {\n                return false;\n            }\n            st = new StringTokenizer(next);\n            return true;\n        }\n    }\n}", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[])\n    {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=1;\n        while(T-->0)\n        {\n            int n=input.nextInt();\n            int m[]=new int[n];\n            long sum=0;\n            ArrayList<Integer> list=new ArrayList<>();\n            for(int i=0;i<n;i++)\n            {\n                m[i]=input.nextInt();\n                list.add(m[i]+1);\n                sum+=m[i];\n            }\n            int max=0;\n            for(int i=0;i<n;i++)\n            {\n                int v=list.get(i);\n                max=Math.max(max,v);\n                list.set(i,max);\n            }\n            for(int i=n-2;i>=0;i--)\n            {\n                if(list.get(i+1)-list.get(i)>1)\n                {\n                    list.set(i,list.get(i+1)-1);\n                }\n            }\n            long s1=0;\n            for(int i=0;i<list.size();i++)\n            {\n                s1+=list.get(i);\n            }\n            out.println(s1-sum-n);\n        }\n        out.close();\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "linear", "problem": "0924_C", "from": "CODEFORCES", "tags": "data structures,dp,greedy"}
{"src": "/*\nIf you want to aim high, aim high\nDon't let that studying and grades consume you\nJust live life young\n******************************\nIf I'm the sun, you're the moon\nBecause when I go up, you go down\n*******************************\nI'm working for the day I will surpass you\nhttps://www.a2oj.com/Ladder16.html\n*/\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n   public class x1238E\n   {\n      public static void main(String omkar[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));  \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int M = Integer.parseInt(st.nextToken());\n         String input = infile.readLine();\n         int[][] cnt = new int[M][M];\n         for(int i=0; i < N-1; i++)\n         if(input.charAt(i) != input.charAt(i+1))\n            {\n               cnt[input.charAt(i)-'a'][input.charAt(i+1)-'a']++;\n               cnt[input.charAt(i+1)-'a'][input.charAt(i)-'a']++;\n            }\n         int[] dp = new int[1 << M];\n         Arrays.fill(dp, Integer.MAX_VALUE);\n         dp[0] = 0;\n         for(int mask=0; mask < dp.length; mask++)\n            for(int b=0; b < M; b++)\n               if((mask&(1<<b)) == 0)\n               {\n                  int submask = mask|(1<<b);\n                  int cost = 0;\n                  for(int c=0; c < M; c++)\n                  {\n                     if((mask&(1<<c)) > 0)\n                        cost += cnt[b][c];\n                     else\n                        cost -= cnt[b][c];\n                  }\n                  dp[submask] = Math.min(dp[submask], dp[mask]+cost*Integer.bitCount(mask));\n               }\n         System.out.println(dp[(1<<M)-1]);\n      }\n   }", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "/*input\n2 2 4\n1\n3\n4 2\n\n*/\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tstatic PrintWriter out;\n\tstatic int MOD = 1000000007;\n\tstatic FastReader scan;\n\n    /*-------- I/O using short named function ---------*/\n\tpublic static String ns(){return scan.next();}\n\tpublic static int ni(){return scan.nextInt();}\n\tpublic static long nl(){return scan.nextLong();}\n\tpublic static double nd(){return scan.nextDouble();}\n\tpublic static String nln(){return scan.nextLine();}\n\tpublic static void p(Object o){out.print(o);}\n\tpublic static void ps(Object o){out.print(o + \" \");}\n\tpublic static void pn(Object o){out.println(o);}\n    /*-------- for output of an array ---------------------*/\n     static void iPA(int arr []){\n     \t StringBuilder output = new StringBuilder();\n\t     for(int i=0; i<arr.length; i++)output.append(arr[i] + \" \");out.println(output);\n\t}\n\tstatic void lPA(long arr []){\n\t     StringBuilder output = new StringBuilder();\n\t     for(int i=0; i<arr.length; i++)output.append(arr[i] + \" \");out.println(output);\n\t}\n\tstatic void sPA(String arr []){\n\t     StringBuilder output = new StringBuilder();\n\t     for(int i=0; i<arr.length; i++)output.append(arr[i] + \" \");out.println(output);\n\t}\n\tstatic void dPA(double arr []){\n\t     StringBuilder output = new StringBuilder();\n\t     for(int i=0; i<arr.length; i++)output.append(arr[i] + \" \");out.println(output);\n\t}\n    /*-------------- for input in an array ---------------------*/\n\tstatic void iIA(int arr[]){\n\t     for(int i=0; i<arr.length; i++)arr[i] = ni();\n\t}\n\tstatic void lIA(long arr[]){\n\t     for(int i=0; i<arr.length; i++)arr[i] = nl(); \n\t}\n\tstatic void sIA(String arr[]){\n\t     for(int i=0; i<arr.length; i++)arr[i] = ns(); \n\t}\n\tstatic void dIA(double arr[]){\n\t     for(int i=0; i<arr.length; i++)arr[i] = nd();\n\t}\n\t/*------------ for taking input faster ----------------*/\n     static class FastReader\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader()\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next()\n\t\t{\n\t\t\twhile (st == null || !st.hasMoreElements())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine()\n\t\t{\n\t\t\tString str = \"\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstr = br.readLine();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\t// Method to check if x is power of 2\n    static boolean isPowerOfTwo (int x) { return x!=0 && ((x&(x-1)) == 0);}\n    //Method to return lcm of two numbers\n    static int gcd(int a, int b){return a==0?b:gcd(b % a, a); }\n    //Method to count digit of a number\n    static int countDigit(long n){return (int)Math.floor(Math.log10(n) + 1);}\n\n    //Method for sorting\n\tstatic void ruffle_sort(int[] a) {\n\t\t//shandom_ruffle\n\t\tRandom r=new Random();\n\t\tint n=a.length;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint oi=r.nextInt(n);\n\t\t\tint temp=a[i];\n\t\t\ta[i]=a[oi];\n\t\t\ta[oi]=temp;\n\t\t}\n\t\t//sort\n\t\tArrays.sort(a);\n\t}\n\t//Method for checking if a number is prime or not\n\tstatic boolean isPrime(int n) { \n        if (n <= 1) return false; \n        if (n <= 3) return true; \n        if (n % 2 == 0 || n % 3 == 0) return false; \n        for (int i = 5; i * i <= n; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n            return false; \n        return true; \n    } \n\n    static int n, m;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tOutputStream outputStream =System.out;\n        out =new PrintWriter(outputStream);\n        scan =new FastReader();\n\t\t//for fast output sometimes\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint t = 1;\n\t\twhile(t-->0){\n\t\t\tn = ni(); m = ni();\n\t\t\tint k = ni();\n\n\n\t\t\tif(k %2 == 1){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\t\t\tsb.append(-1 + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(\"\\n\");\n\t\t\t\t}\n\t\t\t\tpn(sb.toString());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlong dp[][][] = new long[n][m][k/2+1];\n\t\t\tlong row[][] = new long[n][m];\n\t\t\tlong col[][] = new long[n][m];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<m-1; j++){\n\t\t\t\t\trow[i][j] = ni();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<n-1; i++){\n\t\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\t\tcol[i][j] = ni();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int a=1; a<=k/2; a++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\t\t\tdp[i][j][a] = Integer.MAX_VALUE;\n\t\t\t\t\t\tfor(int b = 0; b<4; b++){\n\t\t\t\t\t\t\tint X = i + dx[b];\n\t\t\t\t\t\t\tint Y = j + dy[b];\n\t\t\t\t\t\t\tif(isSafe(X, Y)){\n\t\t\t\t\t\t\t\tif(X == i){\n\t\t\t\t\t\t\t\t\tint min = Math.min(Y, j);\n\t\t\t\t\t\t\t\t\t//pn(row[X][min][min+1]);\n\t\t\t\t\t\t\t\t\t//pn(a + \" --- \" + dp[X][Y][a-1]);\n\t\t\t\t\t\t\t\t\tdp[i][j][a]= Math.min(dp[i][j][a], dp[X][Y][a-1] + row[X][min]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(Y == j){\n\t\t\t\t\t\t\t\t\tint min = Math.min(X, i);\n\t\t\t\t\t\t\t\t\t//pn(col[min][min+1][Y]);\n\t\t\t\t\t\t\t\t\tdp[i][j][a] = Math.min(dp[i][j][a], dp[X][Y][a-1] + col[min][Y]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*for(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\t\tp(dp[i][j][1]+ \" \");\n\t\t\t\t}\n\t\t\t\tpn(\"\");\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\t\tp(dp[i][j][2]+ \" \");\n\t\t\t\t}\n\t\t\t\tpn(\"\");\n\t\t\t}*/\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\t\tsb.append(dp[i][j][k/2]*2 + \" \");\n\t\t\t\t}\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t\tpn(sb.toString());\n\n        }\n        out.flush();\n\t\tout.close();\n\t} \n\tstatic int dx[] = {-1, 0, 0, 1};\n\tstatic int dy[] = {0, -1, 1, 0};\n\tstatic boolean isSafe(int x, int y){\n\t\treturn x>=0 && x<n && y>=0 && y<m;\n\t}\n\t\n\t\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "/*\n * Hello! You are trying to hack my solution, are you? =)\n * Don't be afraid of the size, it's just a dump of useful methods like gcd, or n-th Fib number.\n * And I'm just too lazy to create a new .java for every task.\n * And if you were successful to hack my solution, please, send me this test as a message or to Abrackadabraa@gmail.com.\n * It can help me improve my skills and i'd be very grateful for that.\n * Sorry for time you spent reading this message. =)\n * Good luck, unknown rival. =)\n * */\n\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Abra {\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tbr.readLine();\n\t\tint h = 0, t = 0;\n\t\tString s = br.readLine();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif ((char)s.charAt(i) == 'H') h++; else t++;\n\t\t}\n\t\tint m = 10001;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint z = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + 1 <= h) {\n\t\t\t\t\tif (s.charAt((i + j) % n) != 'H') z++;\n\t\t\t\t} else {\n\t\t\t\t\tif (s.charAt((i + j) % n) != 'T') z++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z < m) m = z;\n\t\t}\n\t\tout.println(m / 2);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Abra().run();\n\t}\n\t\n\n\tstatic class myLib {\n\t\tlong fact(long x) {\n\t\t\tlong a = 1;\n\t\t\tfor (long i = 2; i <= x; i++) {\n\t\t\t\ta *= i;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tlong digitSum(String x) {\n\t\t\tlong a = 0;\n\t\t\tfor (int i = 0; i < x.length(); i++) {\n\t\t\t\ta += x.charAt(i) - '0';\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tlong digitSum(long x) {\n\t\t\tlong a = 0;\n\t\t\twhile (x > 0) {\n\t\t\t\ta += x % 10;\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tlong digitMul(long x) {\n\t\t\tlong a = 1;\n\t\t\twhile (x > 0) {\n\t\t\t\ta *= x % 10;\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tint digitCubesSum(int x) {\n\t\t\tint a = 0;\n\t\t\twhile (x > 0) {\n\t\t\t\ta += (x % 10) * (x % 10) * (x % 10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tdouble pif(double ax, double ay, double bx, double by) {\n\t\t\treturn Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by));\n\t\t}\n\n\t\tdouble pif3D(double ax, double ay, double az, double bx, double by, double bz) {\n\t\t\treturn Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by) + (az - bz) * (az - bz));\n\t\t}\n\n\t\tdouble pif3D(double[] a, double[] b) {\n\t\t\treturn Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]) + (a[2] - b[2]) * (a[2] - b[2]));\n\t\t}\n\n\t\tlong gcd(long a, long b) {\n\t\t\tif (a == 0 || b == 0) return 1;\n\t\t\tif (a < b) {\n\t\t\t\tlong c = b;\n\t\t\t\tb = a;\n\t\t\t\ta = c;\n\t\t\t}\n\t\t\twhile (a % b != 0) {\n\t\t\t\ta = a % b;\n\t\t\t\tif (a < b) {\n\t\t\t\t\tlong c = b;\n\t\t\t\t\tb = a;\n\t\t\t\t\ta = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\n\t\tint gcd(int a, int b) {\n\t\t\tif (a == 0 || b == 0) return 1;\n\t\t\tif (a < b) {\n\t\t\t\tint c = b;\n\t\t\t\tb = a;\n\t\t\t\ta = c;\n\t\t\t}\n\t\t\twhile (a % b != 0) {\n\t\t\t\ta = a % b;\n\t\t\t\tif (a < b) {\n\t\t\t\t\tint c = b;\n\t\t\t\t\tb = a;\n\t\t\t\t\ta = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\n\t\tlong lcm(long a, long b) throws IOException {\n\t\t\treturn a * b / gcd(a, b);\n\t\t}\n\n\t\tint lcm(int a, int b) throws IOException {\n\t\t\treturn a * b / gcd(a, b);\n\t\t}\n\n\t\tint countOccurences(String x, String y) {\n\t\t\tint a = 0, i = 0;\n\t\t\twhile (true) {\n\t\t\t\ti = y.indexOf(x);\n\t\t\t\tif (i == -1) break;\n\t\t\t\ta++;\n\t\t\t\ty = y.substring(i + 1);\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tint[] findPrimes(int x) {\n\t\t\tboolean[] forErato = new boolean[x - 1];\n\t\t\tList<Integer> t = new Vector<Integer>();\n\t\t\tint l = 0, j = 0;\n\t\t\tfor (int i = 2; i < x; i++) {\n\t\t\t\tif (forErato[i - 2]) continue;\n\t\t\t\tt.add(i);\n\t\t\t\tl++;\n\t\t\t\tj = i * 2;\n\t\t\t\twhile (j < x) {\n\t\t\t\t\tforErato[j - 2] = true;\n\t\t\t\t\tj += i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] primes = new int[l];\n\t\t\tIterator<Integer> iterator = t.iterator();\n\t\t\tfor (int i = 0; iterator.hasNext(); i++) {\n\t\t\t\tprimes[i] = iterator.next().intValue();\n\t\t\t}\n\t\t\treturn primes;\n\t\t}\n\n\t\tint rev(int x) {\n\t\t\tint a = 0;\n\t\t\twhile (x > 0) {\n\t\t\t\ta = a * 10 + x % 10;\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tclass myDate {\n\t\t\tint d, m, y;\n\n\t\t\tint[] ml = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\n\t\t\tpublic myDate(int da, int ma, int ya) {\n\t\t\t\td = da;\n\t\t\t\tm = ma;\n\t\t\t\ty = ya;\n\t\t\t\tif ((ma > 12 || ma < 1 || da > ml[ma - 1] || da < 1) && !(d == 29 && m == 2 && y % 4 == 0)) {\n\t\t\t\t\td = 1;\n\t\t\t\t\tm = 1;\n\t\t\t\t\ty = 9999999;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid incYear(int x) {\n\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\ty++;\n\t\t\t\t\tif (m == 2 && d == 29) {\n\t\t\t\t\t\tm = 3;\n\t\t\t\t\t\td = 1;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (m == 3 && d == 1) {\n\t\t\t\t\t\tif (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)) {\n\t\t\t\t\t\t\tm = 2;\n\t\t\t\t\t\t\td = 29;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean less(myDate x) {\n\t\t\t\tif (y < x.y) return true;\n\t\t\t\tif (y > x.y) return false;\n\t\t\t\tif (m < x.m) return true;\n\t\t\t\tif (m > x.m) return false;\n\t\t\t\tif (d < x.d) return true;\n\t\t\t\tif (d > x.d) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvoid inc() {\n\t\t\t\tif ((d == 31) && (m == 12)) {\n\t\t\t\t\ty++;\n\t\t\t\t\td = 1;\n\t\t\t\t\tm = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)) {\n\t\t\t\t\t\tml[1] = 29;\n\t\t\t\t\t}\n\t\t\t\t\tif (d == ml[m - 1]) {\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\td = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint partition(int n, int l, int m) {// n - sum, l - length, m - every\n\t\t\t\t\t\t\t\t\t\t\t// part\n\t\t\t// <= m\n\t\t\tif (n < l) return 0;\n\t\t\tif (n < l + 2) return 1;\n\t\t\tif (l == 1) return 1;\n\t\t\tint c = 0;\n\t\t\tfor (int i = Math.min(n - l + 1, m); i >= (n + l - 1) / l; i--) {\n\t\t\t\tc += partition(n - i, l - 1, i);\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tint rifmQuality(String a, String b) {\n\t\t\tif (a.length() > b.length()) {\n\t\t\t\tString c = a;\n\t\t\t\ta = b;\n\t\t\t\tb = c;\n\t\t\t}\n\t\t\tint c = 0, d = b.length() - a.length();\n\t\t\tfor (int i = a.length() - 1; i >= 0; i--) {\n\t\t\t\tif (a.charAt(i) == b.charAt(i + d)) c++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tString numSym = \"0123456789ABCDEF\";\n\n\t\tString ZFromXToYNotation(int x, int y, String z) {\n\t\t\tif (z.equals(\"0\")) return \"0\";\n\t\t\tString a = \"\";\n\t\t\t// long q = 0, t = 1;\n\t\t\tBigInteger q = BigInteger.ZERO, t = BigInteger.ONE;\n\t\t\tfor (int i = z.length() - 1; i >= 0; i--) {\n\t\t\t\tq = q.add(t.multiply(BigInteger.valueOf(z.charAt(i) - 48)));\n\t\t\t\tt = t.multiply(BigInteger.valueOf(x));\n\t\t\t}\n\t\t\twhile (q.compareTo(BigInteger.ZERO) == 1) {\n\t\t\t\ta = numSym.charAt((int) (q.mod(BigInteger.valueOf(y)).intValue())) + a;\n\t\t\t\tq = q.divide(BigInteger.valueOf(y));\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tdouble angleFromXY(int x, int y) {\n\t\t\tif ((x == 0) && (y > 0)) return Math.PI / 2;\n\t\t\tif ((x == 0) && (y < 0)) return -Math.PI / 2;\n\t\t\tif ((y == 0) && (x > 0)) return 0;\n\t\t\tif ((y == 0) && (x < 0)) return Math.PI;\n\t\t\tif (x > 0) return Math.atan((double) y / x);\n\t\t\telse {\n\t\t\t\tif (y > 0) return Math.atan((double) y / x) + Math.PI;\n\t\t\t\telse\n\t\t\t\t\treturn Math.atan((double) y / x) - Math.PI;\n\t\t\t}\n\t\t}\n\n\t\tstatic boolean isNumber(String x) {\n\t\t\ttry {\n\t\t\t\tInteger.parseInt(x);\n\t\t\t} catch (NumberFormatException ex) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tstatic boolean stringContainsOf(String x, String c) {\n\t\t\tfor (int i = 0; i < x.length(); i++) {\n\t\t\t\tif (c.indexOf(x.charAt(i)) == -1) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tlong pow(long a, long n) { // b > 0\n\t\t\tif (n == 0) return 1;\n\t\t\tlong k = n, b = 1, c = a;\n\t\t\twhile (k != 0) {\n\t\t\t\tif (k % 2 == 0) {\n\t\t\t\t\tk /= 2;\n\t\t\t\t\tc *= c;\n\t\t\t\t} else {\n\t\t\t\t\tk--;\n\t\t\t\t\tb *= c;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\n\t\tint pow(int a, int n) { // b > 0\n\t\t\tif (n == 0) return 1;\n\t\t\tint k = n, b = 1, c = a;\n\t\t\twhile (k != 0) {\n\t\t\t\tif (k % 2 == 0) {\n\t\t\t\t\tk /= 2;\n\t\t\t\t\tc *= c;\n\t\t\t\t} else {\n\t\t\t\t\tk--;\n\t\t\t\t\tb *= c;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble pow(double a, int n) { // b > 0\n\t\t\tif (n == 0) return 1;\n\t\t\tdouble k = n, b = 1, c = a;\n\t\t\twhile (k != 0) {\n\t\t\t\tif (k % 2 == 0) {\n\t\t\t\t\tk /= 2;\n\t\t\t\t\tc *= c;\n\t\t\t\t} else {\n\t\t\t\t\tk--;\n\t\t\t\t\tb *= c;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble log2(double x) {\n\t\t\treturn Math.log(x) / Math.log(2);\n\t\t}\n\n\t\tint lpd(int[] primes, int x) {// least prime divisor\n\t\t\tint i;\n\t\t\tfor (i = 0; primes[i] <= x / 2; i++) {\n\t\t\t\tif (x % primes[i] == 0) {\n\t\t\t\t\treturn primes[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t;\n\t\t\treturn x;\n\t\t}\n\n\t\tint np(int[] primes, int x) {// number of prime number\n\t\t\tfor (int i = 0; true; i++) {\n\t\t\t\tif (primes[i] == x) return i;\n\t\t\t}\n\t\t}\n\n\t\tint[] dijkstra(int[][] map, int n, int s) {\n\t\t\tint[] p = new int[n];\n\t\t\tboolean[] b = new boolean[n];\n\t\t\tArrays.fill(p, Integer.MAX_VALUE);\n\t\t\tp[s] = 0;\n\t\t\tb[s] = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i != s) p[i] = map[s][i];\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tint m = Integer.MAX_VALUE, mi = -1;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (!b[i] && (p[i] < m)) {\n\t\t\t\t\t\tmi = i;\n\t\t\t\t\t\tm = p[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mi == -1) break;\n\t\t\t\tb[mi] = true;\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif (p[mi] + map[mi][i] < p[i]) p[i] = p[mi] + map[mi][i];\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\n\t\tboolean isLatinChar(char x) {\n\t\t\tif (((x >= 'a') && (x <= 'z')) || ((x >= 'A') && (x <= 'Z'))) return true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tboolean isBigLatinChar(char x) {\n\t\t\tif (x >= 'A' && x <= 'Z') return true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tboolean isSmallLatinChar(char x) {\n\t\t\tif (x >= 'a' && x <= 'z') return true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tboolean isDigitChar(char x) {\n\t\t\tif (x >= '0' && x <= '9') return true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tclass NotANumberException extends Exception {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\t\t\tString mistake;\n\n\t\t\tNotANumberException() {\n\t\t\t\tmistake = \"Unknown.\";\n\t\t\t}\n\n\t\t\tNotANumberException(String message) {\n\t\t\t\tmistake = message;\n\t\t\t}\n\t\t}\n\n\t\tclass Real {\n\t\t\tString num = \"0\";\n\t\t\tlong exp = 0;\n\t\t\tboolean pos = true;\n\n\t\t\tlong length() {\n\t\t\t\treturn num.length();\n\t\t\t}\n\n\t\t\tvoid check(String x) throws NotANumberException {\n\t\t\t\tif (!stringContainsOf(x, \"0123456789+-.eE\")) throw new NotANumberException(\"Illegal character.\");\n\t\t\t\tlong j = 0;\n\t\t\t\tfor (long i = 0; i < x.length(); i++) {\n\t\t\t\t\tif ((x.charAt((int) i) == '-') || (x.charAt((int) i) == '+')) {\n\t\t\t\t\t\tif (j == 0) j = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif (j == 5) j = 6;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tthrow new NotANumberException(\"Unexpected sign.\");\n\t\t\t\t\t} else\n\t\t\t\t\t\tif (\"0123456789\".indexOf(x.charAt((int) i)) != -1) {\n\t\t\t\t\t\t\tif (j == 0) j = 2;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tif (j == 1) j = 2;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tif (j == 2)\n\t\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tif (j == 3) j = 4;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tif (j == 4)\n\t\t\t\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\tif (j == 5) j = 6;\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (j == 6)\n\t\t\t\t\t\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new NotANumberException(\"Unexpected digit.\");\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tif (x.charAt((int) i) == '.') {\n\t\t\t\t\t\t\t\tif (j == 0) j = 3;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tif (j == 1) j = 3;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tif (j == 2) j = 3;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tthrow new NotANumberException(\"Unexpected dot.\");\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tif ((x.charAt((int) i) == 'e') || (x.charAt((int) i) == 'E')) {\n\t\t\t\t\t\t\t\t\tif (j == 2) j = 5;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tif (j == 4) j = 5;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tthrow new NotANumberException(\"Unexpected exponent.\");\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\tthrow new NotANumberException(\"O_o.\");\n\t\t\t\t}\n\t\t\t\tif ((j == 0) || (j == 1) || (j == 3) || (j == 5)) throw new NotANumberException(\"Unexpected end.\");\n\t\t\t}\n\n\t\t\tpublic Real(String x) throws NotANumberException {\n\t\t\t\tcheck(x);\n\t\t\t\tif (x.charAt(0) == '-') pos = false;\n\t\t\t\tlong j = 0;\n\t\t\t\tString e = \"\";\n\t\t\t\tboolean epos = true;\n\t\t\t\tfor (long i = 0; i < x.length(); i++) {\n\t\t\t\t\tif (\"0123456789\".indexOf(x.charAt((int) i)) != -1) {\n\t\t\t\t\t\tif (j == 0) num += x.charAt((int) i);\n\t\t\t\t\t\tif (j == 1) {\n\t\t\t\t\t\t\tnum += x.charAt((int) i);\n\t\t\t\t\t\t\texp--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j == 2) e += x.charAt((int) i);\n\t\t\t\t\t}\n\t\t\t\t\tif (x.charAt((int) i) == '.') {\n\t\t\t\t\t\tif (j == 0) j = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif ((x.charAt((int) i) == 'e') || (x.charAt((int) i) == 'E')) {\n\t\t\t\t\t\tj = 2;\n\t\t\t\t\t\tif (x.charAt((int) (i + 1)) == '-') epos = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile ((num.length() > 1) && (num.charAt(0) == '0'))\n\t\t\t\t\tnum = num.substring(1);\n\t\t\t\twhile ((num.length() > 1) && (num.charAt(num.length() - 1) == '0')) {\n\t\t\t\t\tnum = num.substring(0, num.length() - 1);\n\t\t\t\t\texp++;\n\t\t\t\t}\n\t\t\t\tif (num.equals(\"0\")) {\n\t\t\t\t\texp = 0;\n\t\t\t\t\tpos = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twhile ((e.length() > 1) && (e.charAt(0) == '0'))\n\t\t\t\t\te = e.substring(1);\n\t\t\t\ttry {\n\t\t\t\t\tif (e != \"\") if (epos) exp += Long.parseLong(e);\n\t\t\t\t\telse\n\t\t\t\t\t\texp -= Long.parseLong(e);\n\t\t\t\t} catch (NumberFormatException exc) {\n\t\t\t\t\tif (!epos) {\n\t\t\t\t\t\tnum = \"0\";\n\t\t\t\t\t\texp = 0;\n\t\t\t\t\t\tpos = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new NotANumberException(\"Too long exponent\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic Real() {\n\t\t\t}\n\n\t\t\tString toString(long mantissa) {\n\t\t\t\tString a = \"\", b = \"\";\n\t\t\t\tif (exp >= 0) {\n\t\t\t\t\ta = num;\n\t\t\t\t\tif (!pos) a = '-' + a;\n\t\t\t\t\tfor (long i = 0; i < exp; i++)\n\t\t\t\t\t\ta += '0';\n\t\t\t\t\tfor (long i = 0; i < mantissa; i++)\n\t\t\t\t\t\tb += '0';\n\t\t\t\t\tif (mantissa == 0) return a;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn a + \".\" + b;\n\t\t\t\t} else {\n\t\t\t\t\tif (exp + length() <= 0) {\n\t\t\t\t\t\ta = \"0\";\n\t\t\t\t\t\tif (mantissa == 0) {\n\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mantissa < -(exp + length() - 1)) {\n\t\t\t\t\t\t\tfor (long i = 0; i < mantissa; i++)\n\t\t\t\t\t\t\t\tb += '0';\n\t\t\t\t\t\t\treturn a + \".\" + b;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!pos) a = '-' + a;\n\t\t\t\t\t\t\tfor (long i = 0; i < mantissa; i++)\n\t\t\t\t\t\t\t\tif (i < -(exp + length())) b += '0';\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tif (i + exp >= 0) b += '0';\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tb += num.charAt((int) (i + exp + length()));\n\t\t\t\t\t\t\treturn a + \".\" + b;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!pos) a = \"-\";\n\t\t\t\t\t\tfor (long i = 0; i < exp + length(); i++)\n\t\t\t\t\t\t\ta += num.charAt((int) i);\n\t\t\t\t\t\tif (mantissa == 0) return a;\n\t\t\t\t\t\tfor (long i = exp + length(); i < exp + length() + mantissa; i++)\n\t\t\t\t\t\t\tif (i < length()) b += num.charAt((int) i);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb += '0';\n\t\t\t\t\t\treturn a + \".\" + b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean containsRepeats(int... num) {\n\t\t\tSet<Integer> s = new TreeSet<Integer>();\n\t\t\tfor (int d : num)\n\t\t\t\tif (!s.contains(d)) s.add(d);\n\t\t\t\telse\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tint[] rotateDice(int[] a, int n) {\n\t\t\tint[] c = new int[6];\n\t\t\tif (n == 0) {\n\t\t\t\tc[0] = a[1];\n\t\t\t\tc[1] = a[5];\n\t\t\t\tc[2] = a[2];\n\t\t\t\tc[3] = a[0];\n\t\t\t\tc[4] = a[4];\n\t\t\t\tc[5] = a[3];\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\tc[0] = a[2];\n\t\t\t\tc[1] = a[1];\n\t\t\t\tc[2] = a[5];\n\t\t\t\tc[3] = a[3];\n\t\t\t\tc[4] = a[0];\n\t\t\t\tc[5] = a[4];\n\t\t\t}\n\t\t\tif (n == 2) {\n\t\t\t\tc[0] = a[3];\n\t\t\t\tc[1] = a[0];\n\t\t\t\tc[2] = a[2];\n\t\t\t\tc[3] = a[5];\n\t\t\t\tc[4] = a[4];\n\t\t\t\tc[5] = a[1];\n\t\t\t}\n\t\t\tif (n == 3) {\n\t\t\t\tc[0] = a[4];\n\t\t\t\tc[1] = a[1];\n\t\t\t\tc[2] = a[0];\n\t\t\t\tc[3] = a[3];\n\t\t\t\tc[4] = a[5];\n\t\t\t\tc[5] = a[2];\n\t\t\t}\n\t\t\tif (n == 4) {\n\t\t\t\tc[0] = a[0];\n\t\t\t\tc[1] = a[2];\n\t\t\t\tc[2] = a[3];\n\t\t\t\tc[3] = a[4];\n\t\t\t\tc[4] = a[1];\n\t\t\t\tc[5] = a[5];\n\t\t\t}\n\t\t\tif (n == 5) {\n\t\t\t\tc[0] = a[0];\n\t\t\t\tc[1] = a[4];\n\t\t\t\tc[2] = a[1];\n\t\t\t\tc[3] = a[2];\n\t\t\t\tc[4] = a[3];\n\t\t\t\tc[5] = a[5];\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tint min(int... a) {\n\t\t\tint c = Integer.MAX_VALUE;\n\t\t\tfor (int d : a)\n\t\t\t\tif (d < c) c = d;\n\t\t\treturn c;\n\t\t}\n\n\t\tint max(int... a) {\n\t\t\tint c = Integer.MIN_VALUE;\n\t\t\tfor (int d : a)\n\t\t\t\tif (d > c) c = d;\n\t\t\treturn c;\n\t\t}\n\n\t\tdouble maxD(double... a) {\n\t\t\tdouble c = Double.MIN_VALUE;\n\t\t\tfor (double d : a)\n\t\t\t\tif (d > c) c = d;\n\t\t\treturn c;\n\t\t}\n\n\t\tdouble minD(double... a) {\n\t\t\tdouble c = Double.MAX_VALUE;\n\t\t\tfor (double d : a)\n\t\t\t\tif (d < c) c = d;\n\t\t\treturn c;\n\t\t}\n\n\t\tint[] normalizeDice(int[] a) {\n\t\t\tint[] c = a.clone();\n\t\t\tif (c[0] != 0) if (c[1] == 0) c = rotateDice(c, 0);\n\t\t\telse\n\t\t\t\tif (c[2] == 0) c = rotateDice(c, 1);\n\t\t\t\telse\n\t\t\t\t\tif (c[3] == 0) c = rotateDice(c, 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tif (c[4] == 0) c = rotateDice(c, 3);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif (c[5] == 0) c = rotateDice(rotateDice(c, 0), 0);\n\t\t\twhile (c[1] != min(c[1], c[2], c[3], c[4]))\n\t\t\t\tc = rotateDice(c, 4);\n\t\t\treturn c;\n\t\t}\n\n\t\tboolean sameDice(int[] a, int[] b) {\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t\tif (a[i] != b[i]) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal double goldenRatio = (1 + Math.sqrt(5)) / 2;\n\t\tfinal double aGoldenRatio = (1 - Math.sqrt(5)) / 2;\n\n\t\tlong Fib(int n) {\n\t\t\tif (n < 0) if (n % 2 == 0) return -Math.round((pow(goldenRatio, -n) - pow(aGoldenRatio, -n)) / Math.sqrt(5));\n\t\t\telse\n\t\t\t\treturn -Math.round((pow(goldenRatio, -n) - pow(aGoldenRatio, -n)) / Math.sqrt(5));\n\t\t\treturn Math.round((pow(goldenRatio, n) - pow(aGoldenRatio, n)) / Math.sqrt(5));\n\t\t}\n\n\t\tclass japaneeseComparator implements Comparator<String> {\n\t\t\t@Override\n\t\t\tpublic int compare(String a, String b) {\n\t\t\t\tint ai = 0, bi = 0;\n\t\t\t\tboolean m = false, ns = false;\n\t\t\t\tif (a.charAt(ai) <= '9' && a.charAt(ai) >= '0') {\n\t\t\t\t\tif (b.charAt(bi) <= '9' && b.charAt(bi) >= '0') m = true;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (b.charAt(bi) <= '9' && b.charAt(bi) >= '0') {\n\t\t\t\t\tif (a.charAt(ai) <= '9' && a.charAt(ai) >= '0') m = true;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ta += \"!\";\n\t\t\t\tb += \"!\";\n\t\t\t\tint na = 0, nb = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (a.charAt(ai) == '!') {\n\t\t\t\t\t\tif (b.charAt(bi) == '!') break;\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (b.charAt(bi) == '!') {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\tint ab = -1, bb = -1;\n\t\t\t\t\t\twhile (a.charAt(ai) <= '9' && a.charAt(ai) >= '0') {\n\t\t\t\t\t\t\tif (ab == -1) ab = ai;\n\t\t\t\t\t\t\tai++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (b.charAt(bi) <= '9' && b.charAt(bi) >= '0') {\n\t\t\t\t\t\t\tif (bb == -1) bb = bi;\n\t\t\t\t\t\t\tbi++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm = !m;\n\t\t\t\t\t\tif (ab == -1) {\n\t\t\t\t\t\t\tif (bb == -1) continue;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (bb == -1) return -1;\n\t\t\t\t\t\twhile (a.charAt(ab) == '0' && ab + 1 != ai) {\n\t\t\t\t\t\t\tab++;\n\t\t\t\t\t\t\tif (!ns) na++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (b.charAt(bb) == '0' && bb + 1 != bi) {\n\t\t\t\t\t\t\tbb++;\n\t\t\t\t\t\t\tif (!ns) nb++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (na != nb) ns = true;\n\t\t\t\t\t\tif (ai - ab < bi - bb) return -1;\n\t\t\t\t\t\tif (ai - ab > bi - bb) return 1;\n\t\t\t\t\t\tfor (int i = 0; i < ai - ab; i++) {\n\t\t\t\t\t\t\tif (a.charAt(ab + i) < b.charAt(bb + i)) return -1;\n\t\t\t\t\t\t\tif (a.charAt(ab + i) > b.charAt(bb + i)) return 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tm = !m;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tif (a.charAt(ai) <= 'z' && a.charAt(ai) >= 'a' && b.charAt(bi) <= 'z' && b.charAt(bi) >= 'a') {\n\t\t\t\t\t\t\t\tif (a.charAt(ai) < b.charAt(bi)) return -1;\n\t\t\t\t\t\t\t\tif (a.charAt(ai) > b.charAt(bi)) return 1;\n\t\t\t\t\t\t\t\tai++;\n\t\t\t\t\t\t\t\tbi++;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tif (a.charAt(ai) <= 'z' && a.charAt(ai) >= 'a') return 1;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tif (b.charAt(bi) <= 'z' && b.charAt(bi) >= 'a') return -1;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (na < nb) return 1;\n\t\t\t\tif (na > nb) return -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tRandom random = new Random();\n\t}\n\n\n\tvoid readIntArray(int[] a) throws IOException {\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = nextInt();\n\t}\n\n\tString readChars(int l) throws IOException {\n\t\tString r = \"\";\n\t\tfor (int i = 0; i < l; i++)\n\t\t\tr += (char) br.read();\n\t\treturn r;\n\t}\n\n\tStreamTokenizer in;\n\tPrintWriter out;\n\tboolean oj;\n\tBufferedReader br;\n\n\tvoid init() throws IOException {\n\t\toj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\tReader reader = oj ? new InputStreamReader(System.in) : new FileReader(\"input.txt\");\n\t\tWriter writer = oj ? new OutputStreamWriter(System.out) : new FileWriter(\"output.txt\");\n\t\tbr = new BufferedReader(reader);\n\t\tin = new StreamTokenizer(br);\n\t\tout = new PrintWriter(writer);\n\t}\n\n\tlong selectionTime = 0;\n\n\tvoid startSelection() {\n\t\tselectionTime -= System.currentTimeMillis();\n\t}\n\n\tvoid stopSelection() {\n\t\tselectionTime += System.currentTimeMillis();\n\t}\n\n\tvoid run() throws IOException {\n\t\tlong beginTime = System.currentTimeMillis();\n\t\tlong beginMem = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n\t\tinit();\n\t\tsolve();\n\t\tlong endMem = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n\t\tlong endTime = System.currentTimeMillis();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(\"Memory used = \" + (endMem - beginMem));\n\t\t\tSystem.out.println(\"Total memory = \" + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()));\n\t\t\tSystem.out.println(\"Running time = \" + (endTime - beginTime));\n\t\t}\n\t\tout.flush();\n\t}\n\n\tint nextInt() throws IOException {\n\t\tin.nextToken();\n\t\treturn (int) in.nval;\n\t}\n\n\tlong nextLong() throws IOException {\n\t\tin.nextToken();\n\t\treturn (long) in.nval;\n\t}\n\n\tString nextString() throws IOException {\n\t\tin.nextToken();\n\t\treturn in.sval;\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\tin.nextToken();\n\t\treturn in.nval;\n\t}\n\n\tmyLib lib = new myLib();\n\n\t/*\n\t * class cubeWithLetters { String consts = \"\u0427\u041a\u0422\u0424\u042d\u0426\"; char[][] letters = { {\n\t * '\u0410', '\u0411', '\u0413', '\u0412' }, { '\u0414', '\u0415', '\u0417', '\u0416' }, { '\u0418', '\u041b', '\u041d', '\u041c' }, {\n\t * '\u041e', '\u041f', '\u0421', '\u0420' }, { '\u0423', '\u0425', '\u0429', '\u0428' }, { '\u042b', '\u042c', '\u042f', '\u042e' } };\n\t * \n\t * char get(char x) { if (consts.indexOf(x) != -1) return x; for (int i = 0;\n\t * i < 7; i++) { for (int j = 0; j < 4; j++) { if (letters[i][j] == x) { if\n\t * (j == 0) return letters[i][3]; else return letters[i][j - 1]; } } }\n\t * return '!'; }\n\t * \n\t * void subrotate(int x) { char t = letters[x][0]; letters[x][0] =\n\t * letters[x][3]; letters[x][3] = letters[x][2]; letters[x][2] =\n\t * letters[x][1]; letters[x][1] = t; }\n\t * \n\t * void rotate(int x) { subrotate(x); char t; if (x == 0) { t =\n\t * letters[1][0]; letters[1][0] = letters[2][0]; letters[2][0] =\n\t * letters[3][0]; letters[3][0] = letters[5][2]; letters[5][2] = t;\n\t * \n\t * t = letters[1][1]; letters[1][1] = letters[2][1]; letters[2][1] =\n\t * letters[3][1]; letters[3][1] = letters[5][3]; letters[5][3] = t; } if (x\n\t * == 1) { t = letters[2][0]; letters[2][0] = letters[0][0]; letters[0][0] =\n\t * letters[5][0]; letters[5][0] = letters[4][0]; letters[4][0] = t;\n\t * \n\t * t = letters[2][3]; letters[2][3] = letters[0][3]; letters[0][3] =\n\t * letters[5][3]; letters[5][3] = letters[4][3]; letters[4][3] = t; } if (x\n\t * == 2) { t = letters[0][3]; letters[0][3] = letters[1][2]; letters[1][2] =\n\t * letters[4][1]; letters[4][1] = letters[3][0]; letters[3][0] = t;\n\t * \n\t * t = letters[0][2]; letters[0][2] = letters[1][1]; letters[1][1] =\n\t * letters[4][0]; letters[4][0] = letters[3][3]; letters[3][3] = t; } if (x\n\t * == 3) { t = letters[2][1]; letters[2][1] = letters[4][1]; letters[4][1] =\n\t * letters[5][1]; letters[5][1] = letters[0][1]; letters[0][1] = t;\n\t * \n\t * t = letters[2][2]; letters[2][2] = letters[4][2]; letters[4][2] =\n\t * letters[5][2]; letters[5][2] = letters[0][2]; letters[0][2] = t; } if (x\n\t * == 4) { t = letters[2][3]; letters[2][3] = letters[1][3]; letters[1][3] =\n\t * letters[5][1]; letters[5][1] = letters[3][3]; letters[3][3] = t;\n\t * \n\t * t = letters[2][2]; letters[2][2] = letters[1][2]; letters[1][2] =\n\t * letters[5][0]; letters[5][0] = letters[3][2]; letters[3][2] = t; } if (x\n\t * == 5) { t = letters[4][3]; letters[4][3] = letters[1][0]; letters[1][0] =\n\t * letters[0][1]; letters[0][1] = letters[3][2]; letters[3][2] = t;\n\t * \n\t * t = letters[4][2]; letters[4][2] = letters[1][3]; letters[1][3] =\n\t * letters[0][0]; letters[0][0] = letters[3][1]; letters[3][1] = t; } }\n\t * \n\t * public String toString(){ return \"  \" + letters[0][0] + letters[0][1] +\n\t * \"\\n\" + \"  \" + letters[0][3] + letters[0][2] + \"\\n\" + letters[1][0] +\n\t * letters[1][1] + letters[2][0] + letters[2][1] + letters[3][0] +\n\t * letters[3][1] + \"\\n\" + letters[1][3] + letters[1][2] + letters[2][3] +\n\t * letters[2][2] + letters[3][3] + letters[3][2] + \"\\n\" + \"  \" +\n\t * letters[4][0] + letters[4][1] + \"\\n\" + \"  \" + letters[4][3] +\n\t * letters[4][2] + \"\\n\" + \"  \" + letters[5][0] + letters[5][1] + \"\\n\" + \"  \"\n\t * + letters[5][3] + letters[5][2] + \"\\n\"; } }\n\t * \n\t * \n\t * Vector<Integer>[] a; int n, mc, c1, c2; int[] col;\n\t * \n\t * void wave(int x, int p) { for (Iterator<Integer> i = a[x].iterator();\n\t * i.hasNext(); ) { int t = i.next(); if (t == x || t == p) continue; if\n\t * (col[t] == 0) { col[t] = mc; wave(t, x); } else { c1 = x; c2 = t; } } }\n\t * \n\t * void solve() throws IOException {\n\t * \n\t * String s = \"\u0415\u041f\u041e\u0415\u042c\u0420\u0418\u0422\u0421\u0413\u0425\u0416\u0417\u0422\u042f\u041f\u0421\u0422\u0410\u041f\u0414\u0421\u0411\u0418\u0421\u0422\u0427\u041a\"; //String s =\n\t * \"\u0417\u042c\u0423\u041e\u042b\u0422\u0412\u0417\u0422\u042f\u041f\u0423\u0411\u041e\u042b\u0422\u0415\u0410\u042b\u0428\u0425\u042f\u0410\u0422\u0427\u041a\"; cubeWithLetters cube = new\n\t * cubeWithLetters(); for (int x = 0; x < 4; x++) { for (int y = x + 1; y <\n\t * 5; y++) { for (int z = y + 1; z < 6; z++) { cube = new cubeWithLetters();\n\t * out.println(cube.toString()); cube.rotate(x);\n\t * out.println(cube.toString()); cube.rotate(y);\n\t * out.println(cube.toString()); cube.rotate(z);\n\t * out.println(cube.toString()); out.print(x + \" \" + y + \" \" + z + \" = \");\n\t * for (int i = 0; i < s.length(); i++) { out.print(cube.get(s.charAt(i)));\n\t * } out.println(); } } }\n\t * \n\t * int a = nextInt(), b = nextInt(), x = nextInt(), y = nextInt();\n\t * out.print((lib.min(a / (x / lib.gcd(x, y)), b / (y / lib.gcd(x, y))) * (x\n\t * / lib.gcd(x, y))) + \" \" + (lib.min(a / (x / lib.gcd(x, y)), b / (y /\n\t * lib.gcd(x, y))) * (y / lib.gcd(x, y)))); }\n\t */\n\n}", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedOutputStream;\nimport java.util.StringTokenizer;\nimport java.io.Closeable;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.Flushable;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tstatic class TaskAdapter implements Runnable {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tInputStream inputStream = System.in;\n\t\t\tOutputStream outputStream = System.out;\n\t\t\tInput in = new Input(inputStream);\n\t\t\tOutput out = new Output(outputStream);\n\t\t\tCReallyBigNumbers solver = new CReallyBigNumbers();\n\t\t\tsolver.solve(1, in, out);\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tThread thread = new Thread(null, new TaskAdapter(), \"\", 1<<29);\n\t\tthread.start();\n\t\tthread.join();\n\t}\n\tstatic class CReallyBigNumbers {\n\t\tlong s;\n\n\t\tpublic CReallyBigNumbers() {\n\t\t}\n\n\t\tpublic boolean valid(long l) {\n\t\t\tlong sum = 0;\n\t\t\tString str = String.valueOf(l);\n\t\t\tfor(int i = 0; i<str.length(); i++) {\n\t\t\t\tsum += str.charAt(i)-'0';\n\t\t\t}\n\t\t\treturn l-sum >= s;\n\t\t}\n\n\t\tpublic void solve(int kase, Input in, Output pw) {\n\t\t\tlong n = in.nextLong();\n\t\t\ts = in.nextLong();\n\t\t\tlong l = 0, h = n+1;\n\t\t\twhile(l<h) {\n\t\t\t\tlong mid = l+h >> 1;\n\t\t\t\tif(valid(mid)) {\n\t\t\t\t\th = mid;\n\t\t\t\t}else {\n\t\t\t\t\tl = mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpw.println(n-l+1);\n\t\t}\n\n\t}\n\n\tstatic class Output implements Closeable, Flushable {\n\t\tpublic StringBuilder sb;\n\t\tpublic OutputStream os;\n\t\tpublic int BUFFER_SIZE;\n\t\tpublic boolean autoFlush;\n\t\tpublic String LineSeparator;\n\n\t\tpublic Output(OutputStream os) {\n\t\t\tthis(os, 1<<16);\n\t\t}\n\n\t\tpublic Output(OutputStream os, int bs) {\n\t\t\tBUFFER_SIZE = bs;\n\t\t\tsb = new StringBuilder(BUFFER_SIZE);\n\t\t\tthis.os = new BufferedOutputStream(os, 1<<17);\n\t\t\tautoFlush = false;\n\t\t\tLineSeparator = System.lineSeparator();\n\t\t}\n\n\t\tpublic void println(long l) {\n\t\t\tprintln(String.valueOf(l));\n\t\t}\n\n\t\tpublic void println(String s) {\n\t\t\tsb.append(s);\n\t\t\tprintln();\n\t\t\tif(autoFlush) {\n\t\t\t\tflush();\n\t\t\t}else if(sb.length()>BUFFER_SIZE >> 1) {\n\t\t\t\tflushToBuffer();\n\t\t\t}\n\t\t}\n\n\t\tpublic void println() {\n\t\t\tsb.append(LineSeparator);\n\t\t}\n\n\t\tprivate void flushToBuffer() {\n\t\t\ttry {\n\t\t\t\tos.write(sb.toString().getBytes());\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tsb = new StringBuilder(BUFFER_SIZE);\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\ttry {\n\t\t\t\tflushToBuffer();\n\t\t\t\tos.flush();\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic void close() {\n\t\t\tflush();\n\t\t\ttry {\n\t\t\t\tos.close();\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Input {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Input(InputStream is) {\n\t\t\tthis(is, 1<<20);\n\t\t}\n\n\t\tpublic Input(InputStream is, int bs) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is), bs);\n\t\t\tst = null;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\ttry {\n\t\t\t\twhile(st==null||!st.hasMoreTokens()) {\n\t\t\t\t\tString s = br.readLine();\n\t\t\t\t\tif(s==null) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(s);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}catch(Exception e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif(!hasNext()) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t}\n}\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;\nimport java.io.IOException;import java.io.PrintStream;import java.io.PrintWriter;\nimport java.security.AccessControlException;import java.util.Arrays;import java.util.Collection;\nimport java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Objects;\nimport java.util.PriorityQueue;import java.util.Scanner;import java.util.TreeMap;\nimport java.util.TreeSet;import java.util.function.Function;import java.util.stream.Collectors;\nimport java.util.stream.IntStream;import java.util.stream.LongStream;import java.util.stream.Stream;\npublic class _p001197B {static public void main(final String[] args) throws IOException\n{p001197B._main(args);}\nstatic private class p001197B extends Solver{public p001197B(){nameIn=\"in/1000/p001197B.in\";\nsingleTest=true;}@Override public void solve()throws IOException{int n=sc.nextInt();\nif(sc.hasNextLine()){sc.nextLine();}PriorityQueue<int[]>pq=new PriorityQueue<>((x,\ny)->y[0]-x[0]);for(int _if0=0;_if0<n;_if0++){int a=sc.nextInt();pq.add(new int[]{a,\n_if0});}if(sc.hasNextLine()){sc.nextLine();}TreeSet<Integer>ind=new TreeSet<>();\nind.addAll(list(IntStream.range(0,n)));boolean res=true;int[]prev=null;while(!pq.isEmpty())\n{int[]it=pq.poll();if(prev!=null){Integer floor=ind.floor(prev[1]);Integer ceiling\n=ind.ceiling(prev[1]);if((floor==null || floor!=it[1])&&(ceiling==null || ceiling\n!=it[1])){res=false;break;}}ind.remove(it[1]);prev=it;}pw.println(res?\"YES\":\"NO\");\n}static public void _main(String[]args)throws IOException{new p001197B().run();}}\nstatic private class Pair<K,V>{private K k;private V v;public Pair(final K t,final \nV u){this.k=t;this.v=u;}public K getKey(){return k;}public V getValue(){return v;\n}}static private abstract class Solver{protected String nameIn=null;protected String \nnameOut=null;protected boolean singleTest=false;protected boolean preprocessDebug\n=false;protected boolean doNotPreprocess=false;protected PrintStream debugPrintStream\n=null;protected Scanner sc=null;protected PrintWriter pw=null;final static String \nSPACE=\" \";final static String SPACES=\"\\\\s+\";private void process()throws IOException\n{if(!singleTest){int t=lineToIntArray()[0];while(t-->0){solve();}}else{solve();}\n}abstract protected void solve()throws IOException;protected String[]lineToArray()\nthrows IOException{return sc.nextLine().trim().split(SPACES);}protected int[]lineToIntArray()\nthrows IOException{return Arrays.stream(lineToArray()).mapToInt(Integer::valueOf).toArray();\n}protected long[]lineToLongArray()throws IOException{return Arrays.stream(lineToArray()).mapToLong(Long::valueOf).toArray();\n}protected void run()throws IOException{boolean done=false;try{if(nameIn!=null && \nnew File(nameIn).exists()){try(FileInputStream fis=new FileInputStream(nameIn);PrintWriter \npw0=select_output();){done=true;sc=new Scanner(fis);pw=pw0;process();}}}catch(IOException \nex){}catch(AccessControlException ex){}if(!done){try(PrintWriter pw0=select_output();\n){sc=new Scanner(System.in);pw=pw0;process();}}}private PrintWriter select_output()\nthrows FileNotFoundException{if(nameOut!=null){return new PrintWriter(nameOut);}\nreturn new PrintWriter(System.out);}public static Map<Integer,List<Integer>>mapi(final \nint[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<Integer,List<Integer>>(),\n(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static Map<Long,List<Integer>>\nmapi(final long[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<Long,\nList<Integer>>(),(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final T[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<T,List<Integer>>(),\n(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final T[]a,Comparator<T>cmp){return IntStream.range(0,a.length).collect(()->\nnew TreeMap<T,List<Integer>>(cmp),(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],\nStream.of(i).collect(Collectors.toList()));}else{res.get(a[i]).add(i);}},Map::putAll\n);}public static Map<Integer,List<Integer>>mapi(final IntStream a){int[]i=new int[]{0};\nreturn a.collect(()->new TreeMap<Integer,List<Integer>>(),(res,v)->{if(!res.containsKey(v))\n{res.put(v,Stream.of(i[0]).collect(Collectors.toList()));}else{res.get(v).add(i[0]);\n}i[0]++;},Map::putAll);}public static Map<Long,List<Integer>>mapi(final LongStream \na){int[]i=new int[]{0};return a.collect(()->new TreeMap<Long,List<Integer>>(),(res,\nv)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}i[0]++;},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final Stream<T>a,Comparator<T>cmp){int[]i=new int[]{0};return a.collect(()->\nnew TreeMap<T,List<Integer>>(cmp),(res,v)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final Stream<T>a){int[]i=new int[]{0};return a.collect(()->new TreeMap<T,List<Integer>>(),\n(res,v)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}},Map::putAll);}public static List<int[]>listi(final \nint[]a){return IntStream.range(0,a.length).mapToObj(i->new int[]{a[i],i}).collect(Collectors.toList());\n}public static List<long[]>listi(final long[]a){return IntStream.range(0,a.length).mapToObj(i\n->new long[]{a[i],i}).collect(Collectors.toList());}public static<T>List<Pair<T,\nInteger>>listi(final T[]a){return IntStream.range(0,a.length).mapToObj(i->new Pair<T,\nInteger>(a[i],i)).collect(Collectors.toList());}public static List<int[]>listi(final \nIntStream a){int[]i=new int[]{0};return a.mapToObj(v->new int[]{v,i[0]++}).collect(Collectors.toList());\n}public static List<long[]>listi(final LongStream a){int[]i=new int[]{0};return \na.mapToObj(v->new long[]{v,i[0]++}).collect(Collectors.toList());}public static<T>\nList<Pair<T,Integer>>listi(final Stream<T>a){int[]i=new int[]{0};return a.map(v->\nnew Pair<T,Integer>(v,i[0]++)).collect(Collectors.toList());}public static String \njoin(final int[]a){return Arrays.stream(a).mapToObj(Integer::toString).collect(Collectors.joining(SPACE));\n}public static String join(final long[]a){return Arrays.stream(a).mapToObj(Long::toString).collect(Collectors.joining(SPACE));\n}public static<T>String join(final T[]a){return Arrays.stream(a).map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final T[]a,final Function<T,String>toString){return \nArrays.stream(a).map(v->toString.apply(v)).collect(Collectors.joining(SPACE));}public \nstatic<T>String join(final Collection<T>a){return a.stream().map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Collection<T>a,final Function<T,String>toString)\n{return a.stream().map(v->toString.apply(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Stream<T>a){return a.map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Stream<T>a,final Function<T,String>toString){\nreturn a.map(v->toString.apply(v)).collect(Collectors.joining(SPACE));}public static\n<T>String join(final IntStream a){return a.mapToObj(Integer::toString).collect(Collectors.joining(SPACE));\n}public static<T>String join(final LongStream a){return a.mapToObj(Long::toString).collect(Collectors.joining(SPACE));\n}public static List<Integer>list(final int[]a){return Arrays.stream(a).mapToObj(Integer::valueOf).collect(Collectors.toList());\n}public static List<Integer>list(final IntStream a){return a.mapToObj(Integer::valueOf).collect(Collectors.toList());\n}public static List<Long>list(final long[]a){return Arrays.stream(a).mapToObj(Long::valueOf).collect(Collectors.toList());\n}public static List<Long>list(final LongStream a){return a.mapToObj(Long::valueOf).collect(Collectors.toList());\n}public static<T>List<T>list(final Stream<T>a){return a.collect(Collectors.toList());\n}public static<T>List<T>list(final T[]a){return Arrays.stream(a).collect(Collectors.toList());\n}}}\n", "complexity": "linear", "problem": "1197_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class _909C {\n\n    private static final int MOD = 1000000007;\n\n    private static void solve(Scanner scan, PrintWriter pw) {\n        int n = scan.nextInt();\n        scan.nextLine();\n\n        // dp[i][j] is the number ways the ith statement is indented j times\n        int[][] dp = new int[n][n];\n        int[][] dpSums = new int[n][n];\n\n        dp[0][0] = 1;\n\n        for(int i = 0; i < n; i++) {\n            dpSums[0][i] = 1;\n        }\n\n        boolean lastIsSimple = scan.nextLine().equals(\"s\");\n\n        for(int i = 1; i < n; i++) {\n\n            if(lastIsSimple) {\n                dp[i][0] = dpSums[i-1][n-1];\n                dpSums[i][0] = dp[i][0];\n\n                for(int j = 1; j < n; j++) {\n                    dp[i][j] = (dpSums[i-1][n-1] - dpSums[i-1][j-1] + MOD) % MOD;\n                    dpSums[i][j] = (dp[i][j] + dpSums[i][j-1]) % MOD;\n                }\n            }\n            else {\n                dp[i][0] = 0;\n                dpSums[i][0] = 0;\n\n                for(int j = 1; j < n; j++) {\n                    dp[i][j] = dp[i-1][j-1];\n                    dpSums[i][j] = (dp[i][j] + dpSums[i][j-1]) % MOD;\n                }\n\n            }\n\n            lastIsSimple = scan.nextLine().equals(\"s\");\n        }\n\n        System.out.println(dpSums[n-1][n-1]);\n    }\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(new BufferedInputStream(System.in, 1024 * 64));\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out, 1024 * 64));\n        solve(scan, pw);\n        pw.flush();\n    }\n\n}", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "/**\n * Created by Alyssa Herbst on 9/14/19 9:05 AM.\n */\n\nimport java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class B {\n    static StringBuilder sb;\n    static int N;\n    static int[] A;\n    static boolean[] B;\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        //Scanner sc = new Scanner(System.in);\n        sb = new StringBuilder();\n        N = sc.nextInt();\n        A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextInt();\n        }\n        Arrays.sort(A);\n        B = new boolean[N];\n        int count = 0;\n        for (int i = 0; i < A.length; i++) {\n            if(B[i]) {\n                continue;\n            }\n            else {\n                count++;\n                B[i] = true;\n            }\n            for (int j = i + 1; j < A.length; j++) {\n                if(A[j] % A[i] == 0) {\n                    B[j] = true;\n                }\n            }\n        }\n        sb.append(count);\n        System.out.println(sb);\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n\n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] readIntBrray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n\n        long[] readLongBrray(int n) {\n            long[] a = new long[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextLong();\n            }\n            return a;\n        }\n    }\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.TreeMap;\n\npublic class Main extends PrintWriter {\n\n    static BufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n    // static Scanner s=new Scanner(System.in);\n    Main () { super(System.out); }\n    public static void main(String[] args) throws IOException{\n        Main  d1=new Main   ();d1.main();d1.flush();\n    }\n    void main() throws IOException {\n        BufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n        StringBuffer sb = new StringBuffer();\n        StringBuffer sb1 = new StringBuffer();\n        PrintWriter out = new PrintWriter(System.out);\n        int t=1;\n//        t=i(s()[0]);\n        while(t-->0) {\n            //dp[i]=a[i]+max(dp[j]) S.T. j<i and h[j]<h[i];\n            String[] s1 = s();\n            int n = i(s1[0]);\n             long[] a=new long[n];\n             arr(a,n);\n             HashMap<Long,Integer>[] dp=new HashMap[n];\n\n             long[] presum=new long[n];\n             for(int i=0;i<n;i++){\n                 if(i==0){\n                     presum[i]=a[i];\n                 }else{\n                     presum[i]=a[i]+presum[i-1];\n                 }\n             }HashMap<Long,TreeMap<Integer,Long> > tm=new HashMap<>();int ans=0;long maxsum=0;\n             for(int i=0;i<n;i++){\n                  dp[i]=new HashMap<>();\n                 for(int j=-1;j<i;j++){\n                     long sum=0;\n                     if(j==-1) sum=presum[i];else sum=presum[i]-presum[j];\n//                     if(sum==5&&i==5) System.out.println(tm.get(sum).floorKey(4));\n                     if(tm.containsKey(sum)&&tm.get(sum).floorKey(j)!=null){\n                         dp[i].put(sum,Math.max(dp[i].getOrDefault(sum,0),dp[tm.get(sum).floorKey(j)].getOrDefault(sum,0)+1));\n                        if(dp[i].get(sum)>ans){\n                            maxsum=sum;\n                        }\n                         ans=Math.max(ans,dp[i].get(sum));\n                     }else if(dp[i].containsKey(sum)==false){\n                         if(dp[i].getOrDefault(sum,0)<1) dp[i].put(sum,1);\n                         if(dp[i].get(sum)>ans){\n                             maxsum=sum;\n                         }\n                         ans=Math.max(ans,1);\n                     }\n                     long val=dp[i].getOrDefault(sum,0);\n//                     if(tm.containsKey(sum)&&tm.get(sum).floorKey(i-1)!=null){\n                         if(!tm.containsKey(sum)||tm.get(sum).floorKey(i-1)==null||dp[tm.get(sum).floorKey(i-1)].getOrDefault(sum,0)<val) {\n//                             val = Math.max(val, dp[tm.get(sum).floorKey(i - 1)].getOrDefault(sum, 0));\n                             TreeMap<Integer, Long> tt = new TreeMap<>();\n                             tt.put(i, val);\n                             tm.put(sum, tt);\n                         }\n//                     }\n                     }\n             }int cnt=0;int last=-1;\n             for(int i=0;i<n;i++){\n                 for(int j=i-1;j>=-1;j--){\n                     long sum=0;\n                     if(j==-1) sum=presum[i];\n                     else sum=presum[i]-presum[j];\n                     if(dp[i].getOrDefault(maxsum,0)>cnt&&maxsum==sum){\n                         sb.append(j+2+\" \"+(i+1)+\"\\n\");cnt++;\n                         break;\n                     }\n                 }\n             } System.out.println(ans);\n//            System.out.println(dp[5].get(5L)+\" \"+dp[4].get(5L));\n            System.out.println(sb);\n        }\n\n    }\n    //        System.out.println(sb);\n    long[] st;\n    void buildtree(int i,int s,int e,long[] a){\n        if(s==e){\n            st[i]=a[s];\n            return;\n        }\n        int mid=(s+e)/2;\n        buildtree(2*i,s,mid,a);\n        buildtree(2*i+1,mid+1,e,a);\n        st[i]=Math.min(st[2*i],st[2*(i)+1]);\n    }\n    long query(int i,int s,int e,int qs,int qe){\n        if(qs>e||qe<s) return Integer.MIN_VALUE;\n        if(s>=qs&&e<=qe) return st[i];\n        int mid=(s+e)/2;\n        long l=query(2*i,s,mid,qs,qe);\n        long r=query(2*i+1,mid+1,e,qs,qe);\n        return Math.max(l,r);\n    }\n    void pointupdate(int i,int s,int e,int qi,long [] a){\n        if(s==e){\n            st[i]=a[s];return;\n        }\n        int mid=(s+e)/2;\n        if(qi<=mid) pointupdate(2*i,s,mid,qi,a);\n        else pointupdate(2*(i)+1,mid+1,e,qi,a);\n        st[i]=Math.max(st[2*i],st[2*i+1]);\n    }\n    public void arr(long[] a,int n) throws IOException{\n        //        BufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n        String[] s2=s();\n        for(int i=0;i<n;i++){\n            a[i]=i(s2[i]);\n        }\n    }\n    public void sort(int[] a,int l,int h){\n        if(l==h) return;\n        int mid=(l+h)/2;\n\n        sort(a,l,mid);\n        sort(a,mid+1,h);\n        merge(a,l,(l+h)/2,h);\n    }\n    void merge(int arr[], int l, int m, int r)\n    {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            }\n            else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    static String[] s() throws IOException {\n        return s.readLine().trim().split(\"\\\\s+\");\n    }\n\n    static int i(String ss) {\n        return Integer.parseInt(ss);\n    }\n    static long l(String ss) {\n        return Long.parseLong(ss);\n    }\n}\nclass Student {\n    long  a;int b;int c;\n    public Student(int a,int b) {\n        this.a=a;this.c=c;this.b=b;\n    }\n}\nclass Pair {\n    int  a,b,c;\n    public Pair(int  a,int b){\n        this.a=a;this.b=b;this.c=c;}\n}\nclass Sortbyroll implements Comparator<Student> {\n\n    public int compare(Student a, Student b){\n        if(a.b==b.b) return (int)b.a-(int)a.a;\n        return   a.b-b.b;}\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.util.*;\npublic class nolbach {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n =scan.nextInt();\n\t\tint k = scan.nextInt();\n\t\tboolean[] isPrime = new boolean[n + 1]; \n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = false;\n\t\tisPrime[1] = false;\n\t\tfor(int d = 2; d*d < isPrime.length; d++) {\n\t\t\tif(isPrime[d] == true) {\n\t\t\t\tfor(int m = d*d; m < isPrime.length; m+=d) {\n\t\t\t\t\tisPrime[m] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> prime = new ArrayList<>();\n\t\tfor(int i = 0; i < isPrime.length; i++) {\n\t\t\tif(isPrime[i] == true) {\n\t\t\t\tprime.add(i);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 2; i < prime.size(); i++) {\n\t\t\tif(prime.contains(prime.get(i - 2) + prime.get(i - 1) + 1)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(count >= k) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t}else {\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.util.stream.Collectors;\n\npublic class P1177A {\n    public static void main(String[] args) throws Exception {\n        BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n        long n = Long.parseLong(r.readLine());\n        if (n < 10) {\n            System.out.print(n);\n            return;\n        }\n        \n        int len = 1;\n        long edge = 10;\n        long prev = 0;\n        long prepow = 0;\n        while (edge - 1 < n) {\n            prepow = (long)Math.pow(10, len);\n            long pow = prepow * 10;\n            prev = edge;\n            edge = edge + (pow - prepow) * (len + 1);\n            len += 1;\n        }\n\n        long b = n - prev;\n        long c = b / len;\n        int rem = (int)(b % len);\n        String s = Long.toString(prepow + c).charAt(rem) + \"\";\n\n        System.out.print(s);\n    }\n}\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint t = ir.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tint n = ir.nextInt();\n\t\t\tint m = ir.nextInt();\n\t\t\tint[][] a = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = ir.nextIntArray(m);\n\t\t\t}\n\t\t\tint[][][] comx = new int[n + 1][m][2];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint[] b = new int[n];\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tb[j] = a[j][i];\n\t\t\t\t}\n\t\t\t\tArrays.sort(b);\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tcomx[j + 1][i][0] = comx[j][i][0] + b[n - 1 - j];\n\t\t\t\t\tcomx[j + 1][i][1] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][][] org = new int[n + 1][m][2];\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\torg[i][j][k] = comx[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tArrays.sort(comx[i], new Comparator<int[]>() {\n\t\t\t\t\tpublic int compare(int[] A, int[] B) {\n\t\t\t\t\t\treturn A[0] - B[0];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t// tr(org);\n\t\t\t// tr(comx);\n\t\t\tif (n == 1) {\n\t\t\t\tout.println(comx[1][m - 1][0]);\n\t\t\t} else if (n == 2) {\n\t\t\t\tout.println(Math.max(comx[2][m - 1][0], m >= 2 ? comx[1][m - 1][0] + comx[1][m - 2][0] : 0));\n\t\t\t} else if (n == 3) {\n\t\t\t\tint res = Math.max(comx[3][m - 1][0],\n\t\t\t\t\t\tm >= 3 ? comx[1][m - 1][0] + comx[1][m - 2][0] + comx[1][m - 3][0] : 0);\n\t\t\t\tif (m >= 2) {\n\t\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\t\tint p = comx[2][i][0];\n\t\t\t\t\t\tint ma = 0;\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tif (comx[2][i][1] == j)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tma = Math.max(org[1][j][0], ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = Math.max(res, p + ma);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(res);\n\t\t\t} else {\n\t\t\t\tint res = Math.max(comx[4][m - 1][0],\n\t\t\t\t\t\tm >= 4 ? comx[1][m - 1][0] + comx[1][m - 2][0] + comx[1][m - 3][0] + comx[1][m - 4][0] : 0);\n\t\t\t\tif (m >= 2) {\n\t\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\t\tint p = comx[3][i][0];\n\t\t\t\t\t\tint ma = 0;\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tif (comx[3][i][1] == j)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tma = Math.max(org[1][j][0], ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = Math.max(res, p + ma);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (m >= 3) {\n\t\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\t\tint p = comx[2][i][0];\n\t\t\t\t\t\tPriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tif (comx[2][i][1] == j)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tpq.add(org[1][j][0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = Math.max(res, p + pq.poll() + pq.poll());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (m >= 2) {\n\t\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\t\tint p = 0;\n\t\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\t\tp = Math.max(p, a[j][i] + a[(j + 1) % 4][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ma = 0;\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tif (i == j)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\t\tma = Math.max(ma, a[k][j] + a[(k + 1) % 4][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = Math.max(res, p + ma);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\t\tint p = 0;\n\t\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\t\tp = Math.max(p, a[j][i] + a[(j + 2) % 4][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ma = 0;\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tif (i == j)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\t\tma = Math.max(ma, a[k][j] + a[(k + 2) % 4][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = Math.max(res, p + ma);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(res);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class C {\n\t\n\tpublic static void main(String[] args){\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tString[] ins = new String[N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tins[i] = sc.next();\n\t\t\t}\n\t\t\t\n\t\t\tfinal long MOD = 1000000007;\n\t\t\tlong[] DP = new long[N];\n\t\t\tlong[] nextDP = new long[N];\n\t\t\t\n\t\t\tDP[0] = 1;\n\t\t\t\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tArrays.fill(nextDP, 0);\n\t\t\t\tif(\"f\".equals(ins[i - 1])){\n\t\t\t\t\tfor(int j = 0; j < N - 1; j++){\n\t\t\t\t\t\tnextDP[j + 1] += DP[j];\n\t\t\t\t\t\tnextDP[j + 1] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int j = N - 1; j >= 0; j--){\n\t\t\t\t\t\tnextDP[j] += DP[j];\n\t\t\t\t\t\tnextDP[j] %= MOD;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(j < N - 1){\n\t\t\t\t\t\t\tnextDP[j] += nextDP[j + 1];\n\t\t\t\t\t\t\tnextDP[j] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tlong[] tmp = DP;\n\t\t\t\t\tDP = nextDP;\n\t\t\t\t\tnextDP = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong answer = 0;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tanswer += DP[i];\n\t\t\t\tanswer %= MOD;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() {\n\t\t\ttry {\n\t\t\t\twhile (!hasNext()) {\n\t\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t} catch (IOException e) { /* ignore */\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) { /* ignore */\n\t\t\t}\n\t\t}\n\t}\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.*;\npublic class prob\n{\n\t\t\n\tpublic static long ans(long x, long y, long p)\n    {\n        long r = 1;     \n        x = x % p;\n        while (y > 0)\n        {\n            if((y & 1)==1)\n                r = (r * x) % p;\n            y = y >> 1; \n            x = (x * x) % p; \n        }\n        return r;\n    }\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong x = scan.nextLong();\n\t\tlong k = scan.nextLong();\n\t\tlong v = 1000000007L;\n\t\tif(x>0){\n\t\t\tlong p = ((2*x)-1)%v;\n\t\t\tlong a = ans(2L,k,v);\n\t\t\tlong b = (p*a)%v;\n\t\t\tSystem.out.println((b+1)%v);\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(0);\n\t\t}\n\t}\n}\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main\n{\n\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer tokenizer=null;\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tnew Main().execute();\n\t}\n\t\n\tvoid debug(Object...os)\n\t{\n\t\tSystem.out.println(Arrays.deepToString(os));\n\t}\n\t\n\tint ni() throws IOException\n\t{\n\t\treturn Integer.parseInt(ns());\n\t}\n\t\n\tlong nl() throws IOException \n\t{\n\t\treturn Long.parseLong(ns());\n\t}\n\t\n\tdouble nd() throws IOException \n\t{\n\t\treturn Double.parseDouble(ns());\n\t}\n\t\t\n\tString ns() throws IOException \n\t{\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) \n\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\treturn tokenizer.nextToken();\n\t}\n\t\n\tString nline() throws IOException\n\t{\n\t\ttokenizer=null;\n\t\treturn br.readLine();\n\t}\n\t\t\n\t\n\t//Main Code starts Here\n\tint totalCases, testNum;\t\n\tint k,n;\n\t\n\tvoid execute() throws IOException\n\t{\n\t\ttotalCases = 1;\n\t\tfor(testNum = 1; testNum <= totalCases; testNum++)\n\t\t{\n\t\t\tinput();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve()\n\t{\n\t\tint a = arr[k-1].a;\n\t\tint b = arr[k-1].b;\n\t\t//debug(a,b);\n\t\tint count = 0;\n\t\tfor(int i = 0;i<n;i++)\n\t\t{\n\t\t\tif(arr[i].a == a && arr[i].b == b)\n\t\t\t\tcount++;\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\t\n\tvoid printarr(int [] a,int b)\n\t{\n\t\tfor(int i = 0;i<=b;i++)\n\t\t{\n\t\t\tif(i==0)\n\t\t\t\tSystem.out.print(a[i]);\n\t\t\telse\n\t\t\t\tSystem.out.print(\" \"+a[i]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tclass Pair implements Comparable<Pair>\n{\t\n\tint a,b;\n\tPair(int _a,int _b)\n\t{\n\t\ta=_a;\n\t\tb=_b;\n\t}\n\t\n\tpublic int compareTo(Pair x)\n\t{\n\t\tif(a == x.a) return b-x.b;\n\t\treturn -(a-x.a);\n\t}\n\t\t\n\tpublic boolean equals(Pair x)\n\t{\n\t\treturn a==x.a && b==x.b;\n\t}\n}\n\n\tPair[] arr;\n\tboolean input() throws IOException\n\t{\n\t\tn = ni();\n\t\tk = ni();\n\t\tarr = new Pair[n];\n\t\tfor(int i = 0 ;i<n;i++)\n\t\t{\n\t\t\tPair p =new Pair(ni(),ni());\n\t\t\tarr[i]  = p;\n\t\t}\n\t\tArrays.sort(arr);\n\t\t//debug(arr);\n\t\treturn true;\n\t}\n}", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FireAgain \n{\n\n\tpublic static void main(String[] args) throws IOException \n\t{\n\n\t      FileInputStream in = null;\n\t      FileOutputStream out = null;\n\t\n\t      try \n\t      {\n\t         in = new FileInputStream(\"input.txt\");\n\t         out = new FileOutputStream(\"output.txt\");\n\t         \n\t\t  \t\tScanner sc = new Scanner(in);\n\n\t      \n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\t\n\t\tint k = sc.nextInt();\n\t\t\n\t\tint[] xk = new int[k];\n\t\tint[] yk = new int[k];\n\t\t\n\t\tfor(int i = 0; i < k; i++)\n\t\t{\n\t\t\tint y = sc.nextInt()-1;\n\t\t\tint x = sc.nextInt()-1;\n\t\t\t\n\t\t\txk[i] = x;\n\t\t\tyk[i] = y;\n\t\t}\n\n\t\tint best = -1;\n\t\tint bestx = -1;\n\t\tint besty = -1;\n\t\tfor(int x = 0; x < w; x++)\n\t\t{\n\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t{\n\t\t\t\tint cur = 99999;\n\t\t\t\tfor(int f = 0; f < k; f++)\n\t\t\t\t{\n\t\t\t\t\tcur = Math.min(cur, Math.abs(xk[f] - x)+Math.abs(yk[f] - y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(cur > best)\n\t\t\t\t{\n\t\t\t\t\tbest = cur;\n\t\t\t\t\tbestx = x;\n\t\t\t\t\tbesty = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tSystem.out.println((besty+1) + \" \" + (bestx+1));\n\t\tString s = (besty+1) + \" \" + (bestx+1);\n\n\t\tout.write(s.getBytes());\n\t\t\n\t      }finally \n\t      {\n\t         if (in != null) \n\t         {\n\t            in.close();\n\t         }\n\t         if (out != null) \n\t         {\n\t            out.close();\n\t         }\n\t      }\t\t\n\t}\n\n}\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class C {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner in= new FastScanner(System.in);\n\t\tPrintWriter out= new PrintWriter(System.out);\n\t\t\n\t\tint n= in.nextInt();\n\t\tint r= in.nextInt();\n\t\tint [] x= new int[n];\n\t\tfor (int i = 0; i < x.length; i++) {\n\t\t\tx[i]= in.nextInt();\n\t\t}\n\t\tdouble [] res= new double[n];\n\t\tres[0]= r;\n\t\tfor (int i = 1; i < x.length; i++) {\n\t\t\tboolean found = false;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tdouble dis= Math.abs(x[i]-x[j]);\n\t\t\t\tdouble rr= 4.0*r*r-1.0*dis*dis;\n\t\t\t\tif(rr>=0) {\n\t\t\t\t\tdouble del= Math.sqrt(rr);\n\t\t\t\t\tres[i]= Math.max(res[i], res[j]+del);\n\t\t\t\t\tfound= true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found) {\n\t\t\t\tres[i]= r;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < res.length; i++) {\n\t\t\tout.print(res[i]+\" \");\n\t\t}\n\t\tout.close();\n\t\t\n\t}\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tif (!st.hasMoreTokens()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\treturn next();\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic double nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E1RotateColumnsEasyVersion solver = new E1RotateColumnsEasyVersion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E1RotateColumnsEasyVersion {\n        int n;\n        int m;\n        int[][] arr;\n        int[][] mskValue;\n        int[][] memo;\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int q = sc.nextInt();\n            while (q-- > 0) {\n                n = sc.nextInt();\n                m = sc.nextInt();\n                arr = new int[n][m];\n                for (int i = 0; i < n; i++)\n                    for (int j = 0; j < m; j++)\n                        arr[i][j] = sc.nextInt();\n                int[][] temp = new int[m][n];\n                for (int i = 0; i < m; i++)\n                    for (int j = 0; j < n; j++)\n                        temp[i][j] = arr[j][i];\n                Arrays.sort(temp, (a, b) -> getMax(b) - getMax(a));\n                for (int i = 0; i < m; i++)\n                    for (int j = 0; j < n; j++)\n                        arr[j][i] = temp[i][j];\n                mskValue = new int[n][1 << n];\n                for (int i = 0; i < Math.min(n, m); i++) {\n                    for (int j = 0; j < 1 << n; j++) {\n                        int max = 0;\n                        for (int shift = 0; shift < n; shift++) {\n                            int sum = 0;\n                            for (int k = 0; k < n; k++)\n                                if ((j & 1 << k) != 0)\n                                    sum += arr[(k + shift) % n][i];\n                            max = Math.max(max, sum);\n                        }\n                        mskValue[i][j] = max;\n                    }\n                }\n                memo = new int[Math.min(n, m)][1 << n];\n                for (int[] x : memo)\n                    Arrays.fill(x, -1);\n                pw.println(dp(0, 0));\n            }\n        }\n\n        private int getMax(int[] a) {\n            int max = 0;\n            for (int x : a)\n                max = Math.max(max, x);\n            return max;\n        }\n\n        private int dp(int idx, int msk) {\n            if (msk == (1 << n) - 1)\n                return 0;\n            if (idx == Math.min(n, m))\n                return (int) -1e9;\n            int max = Integer.MIN_VALUE;\n            if (memo[idx][msk] != -1)\n                return memo[idx][msk];\n            int availableBits = msk ^ ((1 << n) - 1);\n            for (int colMask = availableBits; colMask != 0; colMask = (colMask - 1) & availableBits) {\n\n                max = Math.max(max, mskValue[idx][colMask] + dp(idx + 1, msk | colMask));\n\n            }\n            return memo[idx][msk] = max;\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class D{\n\n\tpublic static int grid[][][] = new int[505][505][11];\n\tpublic static int[][] rows = new int[505][505];\n\tpublic static int[][] cols = new int[505][505];\n\tpublic static int N,M,K;\n\n\tpublic static int dp(int i, int j, int k){\n\t\t\n\t\tif(D.grid[i][j][k] != 0 || k == 0){\n\t\t\treturn D.grid[i][j][k];\n\t\t}\n\t\tint res = 1<<30;\n\t\tif(i != 0) res = Math.min(res, D.cols[i-1][j] + dp(i-1, j, k-1));\n\t\tif(i != D.N-1) res = Math.min(res, D.cols[i][j] + dp(i+1, j, k-1));\n\t\tif(j != 0) res = Math.min(res, D.rows[i][j-1] + dp(i, j-1, k-1));\n\t\tif(j != D.M-1) res = Math.min(res, D.rows[i][j] + dp(i, j+1, k-1));\n\t\tD.grid[i][j][k] = res;\n\t\t//System.out.println(i + \" \" + j + \" \" + k + \": \" + res);\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tD.N = scan.nextInt();\n\t\tD.M = scan.nextInt();\n\t\tD.K = scan.nextInt();\n\n\t\tfor(int i = 0; i < D.N; i++){\n\t\t\tfor(int j = 0; j < D.M-1; j++){\n\t\t\t\tD.rows[i][j] = scan.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < D.N-1; i++){\n\t\t\tfor(int j = 0; j < D.M; j++){\n\t\t\t\tD.cols[i][j] = scan.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < D.N; i++){\n\t\t\tfor(int j = 0; j < D.M; j++){\n\t\t\t\tif(D.K%2 == 1){\n\t\t\t\t\tSystem.out.print(\"-1 \");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(2*D.dp(i, j, D.K/2) + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t\t//System.out.println(grid[0][0][1]);\n\t}\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n@SuppressWarnings(\"unused\")\npublic class Solution{\n\t\n\tstatic long inf = (long)1e18+100;\n\tstatic final long mod = (long)1e9+7;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner fs = new FastScanner();\n    \tPrintWriter out = new PrintWriter(System.out);\n    \t\n    \tint tt = 1;\n    \touter:\n    \twhile(tt-->0) {\n    \t\t\n    \t\tint n = fs.nextInt(), T = fs.nextInt();\n    \t\tint[] t = new int[n], g = new int[n];\n    \t\t\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\tt[i] = fs.nextInt(); g[i] = fs.nextInt();\n    \t\t}\n    \t\t\n    \t\t//dp[mask][pre] -- number of ways to order mask songs last song has prev genre\n    \t\tlong[][] dp = new long[1<<n][4];\n    \t\tdp[0][0] = 1;\n    \t\t\n    \t\tlong ans = 0;\n    \t\t\n    \t\tfor(int mask=0;mask<(1<<n);mask++) {\n    \t\t\tfor(int pre=0;pre<=3;pre++) {\n    \t\t\t\tfor(int i=0;i<n;i++)\n    \t\t\t\t\tif((mask&(1<<i))==0 && g[i]!=pre) \n    \t\t\t\t\t\tdp[mask^(1<<i)][g[i]] = add(dp[mask^(1<<i)][g[i]], dp[mask][pre]);\n    \t\t\t\tint sum = 0;\n    \t\t\t\tfor(int i=0;i<n;i++) {\n    \t\t\t\t\tif((mask&(1<<i))!=0) sum += t[i];\n    \t\t\t\t}\n    \t\t\t\tif(sum==T) ans = add(ans, dp[mask][pre]);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tout.println(ans);\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t}\n    \t\n    \tout.close();\n    }\n\t\n\tstatic long add(long a, long b) {\n\t\ta += b;\n\t\tif(a>mod) return a - mod;\n\t\treturn a;\n\t}\n\t\n\t\n    static final Random random=new Random();\n    \n    static <T> void shuffle(T[] arr) {\n    \tint n = arr.length;\n    \tfor(int i=0;i<n;i++\t) {\n    \t\tint k = random.nextInt(n);\n    \t\tT temp = arr[k]; arr[k] = arr[i]; arr[i] = temp;\n    \t}\n    }\n    \n    \t\n    static void ruffleSort(int[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); int temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n    \n    static void ruffleSort(long[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); long temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n   \n  \n    \n    static void reverse(int[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tint temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    static void reverse(long[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tlong temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    \n    static <T> void reverse(T[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++) {\n    \t\tT temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \t\n    \t\n    static class FastScanner{\n    \tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \tStringTokenizer st = new StringTokenizer(\"\");\n     \n    \tpublic String next(){\n    \t\twhile(!st.hasMoreElements()){\n    \t\t\ttry{\n    \t\t\t\tst = new StringTokenizer(br.readLine());\n    \t\t\t} catch(IOException e){\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t\treturn st.nextToken();\n    \t}\n    \t\t\n    \tpublic String nextLine() throws IOException {\n    \t\treturn br.readLine();\n    \t}\n    \t\t\n    \tpublic int nextInt(){\n    \t\treturn Integer.parseInt(next());\n    \t}\n     \n    \tpublic int[] readArray(int n){\n    \t\tint[] a = new int[n];\n    \t\tfor(int i=0;i<n;i++)\n    \t\t\ta[i] = nextInt();\n    \t\treturn a;\n    \t}\n    \t\t\n    \tpublic long nextLong() {\n    \t\treturn Long.parseLong(next());\n    \t}\n    \t\t\n    \tpublic char nextChar() {\n    \t\treturn next().toCharArray()[0];\n    \t}\n    }\n\n\n   \t\n}\n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class Contest1_1{\n    \n    public static void main(String ar[]) throws Exception { \n        \n        BufferedReader buff = new BufferedReader(new InputStreamReader(System.in));\n        int input = Integer.parseInt(buff.readLine());\n        if(input==0){\n            System.out.println(\"0 0 0\");\n        }else if(input==1){\n            System.out.println(\"0 0 1\");\n        }else if(input==2){\n            System.out.println(\"0 1 1\");\n        }else if(input==3){\n            System.out.println(\"1 1 1\");\n        }else {\n            int output[] = checkFibo(input);\n            int get[] = checkFibo(output[1]);\n            output[0] = get[1];\n            output[1] = get[2];\n            System.out.print(output[0]);\n            System.out.print(\" \" + output[1]);\n            System.out.println(\" \" + output[2]);    \n        }\n    }\n    \n    public static int[] checkFibo(int input){\n        int output[] = new int[3];\n        int fibo_1 = 0;\n        int fibo_2 = 1;\n        int temp = 0;\n        while(fibo_2!=input){\n            temp = fibo_2;\n            output[1] = fibo_1;\n            output[2] = fibo_2;\n            fibo_2 += fibo_1;\n            fibo_1 = temp;\n        }\n        return output;\n    }   \n}", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\tfinal String filename = new String(\"A\").toLowerCase();\n\n\tvoid solve() throws Exception {\n\t\tint n = nextInt();\n\t\tint[] a = new int[n];\n\t\tint m = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t\tif (m == -1 || a[i] > a[m]) {\n\t\t\t\tm = i;\n\t\t\t}\n\t\t}\n\t\tif (a[m] == 1)\n\t\t\ta[m] = 2;\n\t\telse\n\t\t\ta[m] = 1;\n\t\tArrays.sort(a);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tout.print(a[i] + \" \");\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t// out = new PrintWriter(\"output.txt\");\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tString nextToken() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A().run();\n\t}\n\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.*;\n\n\npublic class Main {\n\tprivate static Scanner in = new Scanner(System.in);\n\tpublic static void main(String args[]){\n\t\tint n = in.nextInt();\n\t\tString s = in.next();\n\t\tif(n==1)\n\t\t\tSystem.out.println(\"1\");\n\t\telse{\n\t\t\tint j=0,i=1,ans=s.length();\n\t\t\tint h[]=new int[128];\n\t\t\th[(int)s.charAt(0)]=1;\n\t\t\twhile(i<n){\n\t\t\t\tif(h[(int)s.charAt(i)]==0)\n\t\t\t\t\tans = i-j+1;\n\t\t\t\th[(int) s.charAt(i)]++;\n\t\t\t\twhile(j<i && h[(int)s.charAt(j)]>1){\n\t\t\t\t\th[(int)s.charAt(j)]--;\n\t\t\t\t\tj++;\n\t\t\t\t\tans = Math.min(ans, i-j+1);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.util.*;\npublic class algo_1802\n{\n    public static void main(String args[])\n    {\n        Scanner ex=new Scanner(System.in);\n        int n=ex.nextInt();\n        int k=ex.nextInt();\n        int x=(int)((Math.sqrt(9.0+8.0*((double)n+(double)k))-3.0)/2.0);\n        System.out.println(n-x);\n    }\n}", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class SolutionC extends Thread {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                                            InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    private static final FastReader scanner = new FastReader();\n    private static final PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        new Thread(null, new SolutionC(), \"Main\", 1 << 28).start();\n    }\n\n    public void run() {\n        int t = scanner.nextInt();\n        for (int i = 0; i < t; i++) {\n            solve();\n        }\n        out.close();\n    }\n\n    private static void solve() {\n        int n = scanner.nextInt();\n        List<Integer> numbers = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            int ai = scanner.nextInt();\n            if (ai == 1) {\n                numbers.add(1);\n            } else {\n                while (numbers.get(numbers.size()-1) + 1 != ai) {\n                    numbers.remove(numbers.size()-1);\n                }\n                numbers.set(numbers.size()-1, ai);\n            }\n            StringBuilder s = new StringBuilder();\n            for (int j = 0; j < numbers.size(); j++) {\n                s.append(numbers.get(j))\n                 .append(\".\");\n            }\n            out.println(s.substring(0, s.length()-1));\n        }\n    }\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.util.*;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tComp c1 = getComp(scanner);\n\t\tComp c2 = getComp(scanner);\n\t\tc1.sortByPrice();\n\t\tc2.sortByPrice();\t\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < c1.num || j < c2.num) {\n\t\t\tElem xi = (i < c1.num) ? c1.elems.get(i) : null;\n\t\t\tElem yj = (j < c2.num) ? c2.elems.get(j) : null;\n\t\t\tif(xi != null && yj != null) {\n\t\t\t\tif(xi.price >= yj.price) {\n\t\t\t\t\tif(!c2.resultSet.contains(xi)) {\n\t\t\t\t\t\tc1.resultSet.add(xi);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tif(!c1.resultSet.contains(yj)) {\n\t\t\t\t\t\tc2.resultSet.add(yj);\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t} else\n\t\t\tif(xi != null) {\n\t\t\t\tif(!c2.resultSet.contains(xi)) {\n\t\t\t\t\tc1.resultSet.add(xi);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tif(!c1.resultSet.contains(yj)) {\n\t\t\t\t\tc2.resultSet.add(yj);\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\t\t\t\t\n\t\t}\n\t\t\n\t\tlong result = c1.getResultPrice() + c2.getResultPrice();\n\t\tSystem.out.println(result);\n   }\n   \n   private static Comp getComp(Scanner scanner) {\n\t   Comp c = new Comp();\n\t   c.num = scanner.nextInt();\n\t   for(int i = 0; i < c.num; i++) {\n\t\t   c.addElem(scanner.nextLong(), scanner.nextLong());\n\t   }\n\t   return c;\n   }\n}\n\nclass Comp {\n\tint num;\n\tList<Elem> elems = new ArrayList<>();\n\tSet<Elem> resultSet = new HashSet<>();\n\t\n\tvoid addElem(long el, long pr) {\n\t\tElem elem = new Elem(el, pr);\n\t\telems.add(elem);\n\t}\n\t\n\tvoid sortByPrice() {\n\t\tCollections.sort(elems);\n\t}\n\t\n\tlong getResultPrice() {\n\t\tlong sumPrice = 0;\n\t\tfor(Elem elem : resultSet) {\n\t\t\tsumPrice += elem.price;\n\t\t}\n\t\t\n\t\treturn sumPrice;\n\t}\n}\n\nclass Elem implements Comparable<Elem> {\n\tlong elem;\n\tlong price;\n\t\n\tpublic Elem(long el, long pr) {\n\t\tthis.elem = el;\n\t\tthis.price = pr;\n\t}\n\t\n\tpublic int compareTo(Elem other) {\n\t\treturn (int) (other.price - price);\n\t}\n\t\n\tpublic boolean equals(Object o) {\n\t\tif(!(o instanceof Elem)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tElem other = (Elem) o;\n\t\treturn (other.elem == elem);\n\t}\n\t\n\tpublic int hashCode() {\n\t\treturn (int) elem;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"(\" + elem + \", \" + price + \")\";\n\t}\n}\n", "complexity": "nlogn", "problem": "0981_B", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.util.Scanner;\n\n\npublic class A {\n\n    public static void main(String[] args) {\n         \n        Scanner x=new Scanner(System.in);\n        \n        int n=x.nextInt();\n                \n                if(n%2==0){\n                    \n                    System.out.println((n-4)+\" \"+\"4\");\n                }\n                else{\n                    \n                    System.out.println((n-9)+\" \"+\"9\");\n                    \n                }\n        \n        \n        \n        \n    }\n\n}\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author Saransh\n */\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n\n\npublic class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        try\n        {\n            Parserdoubt pd=new Parserdoubt(System.in);\n            //BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            int n=pd.nextInt();\n            PrintWriter pw=new PrintWriter(System.out);\n            pw.println((n*3)/2);\n            pw.flush();\n        }\n        catch(Exception e)\n        {}\n\n    }\n\n}\n\n\nclass Parserdoubt\n    {\n       final private int BUFFER_SIZE = 1 << 17;\n\n       private DataInputStream din;\n       private byte[] buffer;\n       private int bufferPointer, bytesRead;\n\n       public Parserdoubt(InputStream in)\n       {\n          din = new DataInputStream(in);\n          buffer = new byte[BUFFER_SIZE];\n          bufferPointer = bytesRead = 0;\n       }\n       public String nextString() throws Exception\n       {\n           StringBuffer sb=new StringBuffer(\"\");\n           byte c = read();\n           while (c <= ' ') c = read();\n           do\n           {\n               sb.append((char)c);\n               c=read();\n           }while(c>' ');\n           return sb.toString();\n       }\n       public char nextChar() throws Exception\n       {\n           byte c=read();\n           while(c<=' ') c= read();\n           return (char)c;\n       }\n       public int nextInt() throws Exception\n       {\n          int ret = 0;\n          byte c = read();\n          while (c <= ' ') c = read();\n          boolean neg = c == '-';\n          if (neg) c = read();\n          do\n          {\n              ret = ret * 10 + c - '0';\n             c = read();\n          } while (c > ' ');\n          if (neg) return -ret;\n          return ret;\n       }\n       public long nextLong() throws Exception\n       {\n          long ret = 0;\n          byte c = read();\n          while (c <= ' ') c = read();\n          boolean neg = c == '-';\n          if (neg) c = read();\n          do\n          {\n              ret = ret * 10 + c - '0';\n             c = read();\n          } while (c > ' ');\n          if (neg) return -ret;\n          return ret;\n       }\n       private void fillBuffer() throws Exception\n       {\n          bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n          if (bytesRead == -1) buffer[0] = -1;\n       }\n\n       private byte read() throws Exception\n       {\n          if (bufferPointer == bytesRead) fillBuffer();\n          return buffer[bufferPointer++];\n       }\n    }", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class C implements Runnable {\n\n\tprivate void Solution() throws IOException {\n\t\tint n = nextInt(), max = 0, maxi = 0;\n\t\tArrayList<Integer> mas = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint num = nextInt();\n\t\t\tif (num > max) {\n\t\t\t\tmax = num;\n\t\t\t\tmaxi = i;\n\t\t\t}\n\t\t\tmas.add(num);\n\t\t}\n\t\tmas.remove(maxi);\n\t\tmas.add(max == 1 ? 2 : 1);\n\t\tCollections.shuffle(mas);\n\t\tCollections.sort(mas);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(mas.get(i) + \" \");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew C().run();\n\t}\n\n\tBufferedReader in;\n\tStringTokenizer tokenizer;\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\tSolution();\n\t\t\tin.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\ttokenizer = new StringTokenizer(in.readLine());\n\t\treturn tokenizer.nextToken();\n\t}\n}", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CF495A {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        long d = s.nextLong();\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextLong();\n        }\n        Arrays.sort(arr);\n        long ans  = 2;\n        for (int i = 0; i < n - 1; i++) {\n            if(arr[i + 1] - arr[i] > 2 * d){\n                ans += 2;\n            }else if(arr[i + 1] - arr[i] == 2 * d){\n                ans += 1;\n            }\n        }\n        System.out.println(ans);\n    }\n}\n", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\n\npublic class Main{\n\n    static long MOD = 1_000_000_007L;\n    //static long MOD = 998_244_353L;\n    //static long MOD = 1_000_000_033L;\n    static long inv2 = (MOD + 1) / 2;\n\n    static int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    static long lMax = 0x3f3f3f3f3f3f3f3fL;\n    static int iMax = 0x3f3f3f3f;\n    static HashMap <Long, Long> memo = new HashMap();\n    static MyScanner sc = new MyScanner();\n    //static ArrayList <Integer> primes;\n\n    static int nn = 300000;\n    static long[] pow2;\n    static long [] fac;\n    static long [] pow;\n    static long [] inv;\n    static long [] facInv;\n    static int[] base;\n    static int[] numOfDiffDiv;\n    static int[] numOfDiv;\n    static ArrayList <Integer> primes;\n    //static int[] primes;\n    static int ptr = 0;\n    static boolean[] isPrime;\n\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n    public static void main(String[] args) {\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        // Start writing your solution here. -------------------------------------\n\n\n\n        /*fac = new long[nn + 1];\n        fac[1] = 1;\n        for(int i = 2; i <= nn; i++)\n            fac[i] = fac[i - 1] * i % MOD;*/\n\n\n        /*pow2 = new long[nn + 1];\n        pow2[0] = 1L;\n        for(int i = 1; i <= nn; i++)\n            pow2[i] = pow2[i - 1] * 2L;*/\n\n\n        /*inv = new long[nn + 1];\n        inv[1] = 1;\n        for (int i = 2; i <= nn; ++i)\n            inv[i] = (MOD - MOD / i) * inv[(int)(MOD % i)] % MOD;*/\n\n        /*facInv = new long[nn + 1];\n        facInv[0] = facInv[1] = 1;\n        for (int i = 2; i <= nn; ++i)\n            facInv[i] = facInv[i - 1] * inv[i] % MOD;*/\n\n\n        /*numOfDiffDiv = new int[nn + 1];\n        for(int i = 2; i <= nn; i++)\n            if(numOfDiffDiv[i] == 0)\n                for(int j = i; j <= nn; j += i)\n                    numOfDiv[j] ++;*/\n\n        /*numOfDiv = new int[nn + 1];\n        numOfDiv[1] = 1;\n        for(int i = 2; i <= nn; i++) {\n            for(int j = 2; j * j <= i; j++) {\n                if(i % j == 0) {\n                    numOfDiv[i] = numOfDiv[i / j] + 1;\n                    break;\n                }\n            }\n        }*/\n\n        //primes = sieveOfEratosthenes(100001);\n\n        /*\n        int t = 1;\n        //t = sc.ni();\n        while(t-- > 0) {\n            //boolean res = solve();\n            //out.println(res ? \"YES\" : \"NO\");\n            long res = solve();\n            out.println(res);\n        }*/\n\n\n        int t = 1, tt = 0;\n        t = sc.ni();\n        for(int i = 1; i <40000; i++) squares.add(i * i);\n        while(tt++ < t) {\n            boolean res = solve();\n            //out.println(\"Case #\" + tt + \": \" + res);\n            out.println(res ? \"YES\" : \"NO\");\n        }\n        out.close();\n    }\n    static HashSet <Integer> squares = new HashSet();\n\n    static boolean solve() {\n        /*String s = sc.nextLine();\n        char[] c = s.toCharArray();\n        int n = c.length;*/\n        //int n = sc.ni();\n        //long[] a =  new long[n];\n        //for(int i = 0; i < n; i++) a[i] = sc.nl();\n        long res = 0;\n        int n = sc.ni();\n        if(n % 2 == 0 && squares.contains(n / 2)) return true;\n        if(n % 4 == 0 && squares.contains(n / 4)) return true;\n        return false;\n    }\n\n    // edges to adjacency list by uwi\n    public static int[][] packU(int n, int[] from, int[] to) {\n        return packU(n, from, to, from.length);\n    }\n\n    public static int[][] packU(int n, int[] from, int[] to, int sup) {\n        int[][] g = new int[n][];\n        int[] p = new int[n];\n        for (int i = 0; i < sup; i++) p[from[i]]++;\n        for (int i = 0; i < sup; i++) p[to[i]]++;\n        for (int i = 0; i < n; i++) g[i] = new int[p[i]];\n        for (int i = 0; i < sup; i++) {\n            g[from[i]][--p[from[i]]] = to[i];\n            g[to[i]][--p[to[i]]] = from[i];\n        }\n        return g;\n    }\n\n    // tree diameter by uwi\n    public static int[] diameter(int[][] g) {\n        int n = g.length;\n        int f0 = -1, f1 = -1, d01 = -1;\n        int[] q = new int[n];\n        boolean[] ved = new boolean[n];\n        {\n            int qp = 0;\n            q[qp++] = 0; ved[0] = true;\n            for(int i = 0;i < qp;i++){\n                int cur = q[i];\n                for(int e : g[cur]){\n                    if(!ved[e]){\n                        ved[e] = true;\n                        q[qp++] = e;\n                        continue;\n                    }\n                }\n            }\n            f0 = q[n-1];\n        }\n        {\n            int[] d = new int[n];\n            int qp = 0;\n            Arrays.fill(ved, false);\n            q[qp++] = f0; ved[f0] = true;\n            for(int i = 0;i < qp;i++){\n                int cur = q[i];\n                for(int e : g[cur]){\n                    if(!ved[e]){\n                        ved[e] = true;\n                        q[qp++] = e;\n                        d[e] = d[cur] + 1;\n                        continue;\n                    }\n                }\n            }\n            f1 = q[n-1];\n            d01 = d[f1];\n        }\n        return new int[]{d01, f0, f1};\n    }\n\n    public static long c(int n, int k) {\n        return (fac[n] * facInv[k] % MOD) * facInv[n - k] % MOD;\n    }\n\n\n    // SegmentTree range min/max query by uwi\n    public static class SegmentTreeRMQ {\n        public int M, H, N;\n        public int[] st;\n\n        public SegmentTreeRMQ(int n)\n        {\n            N = n;\n            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n            H = M>>>1;\n            st = new int[M];\n            Arrays.fill(st, 0, M, Integer.MAX_VALUE);\n        }\n\n        public SegmentTreeRMQ(int[] a)\n        {\n            N = a.length;\n            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n            H = M>>>1;\n            st = new int[M];\n            for(int i = 0;i < N;i++){\n                st[H+i] = a[i];\n            }\n            Arrays.fill(st, H+N, M, Integer.MAX_VALUE);\n            for(int i = H-1;i >= 1;i--)propagate(i);\n        }\n\n        public void update(int pos, int x)\n        {\n            st[H+pos] = x;\n            for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);\n        }\n\n        private void propagate(int i)\n        {\n            st[i] = Math.min(st[2*i], st[2*i+1]);\n        }\n\n        public int minx(int l, int r){\n            int min = Integer.MAX_VALUE;\n            if(l >= r)return min;\n            while(l != 0){\n                int f = l&-l;\n                if(l+f > r)break;\n                int v = st[(H+l)/f];\n                if(v < min)min = v;\n                l += f;\n            }\n\n            while(l < r){\n                int f = r&-r;\n                int v = st[(H+r)/f-1];\n                if(v < min)min = v;\n                r -= f;\n            }\n            return min;\n        }\n\n        public int min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}\n\n        private int min(int l, int r, int cl, int cr, int cur)\n        {\n            if(l <= cl && cr <= r){\n                return st[cur];\n            }else{\n                int mid = cl+cr>>>1;\n                int ret = Integer.MAX_VALUE;\n                if(cl < r && l < mid){\n                    ret = Math.min(ret, min(l, r, cl, mid, 2*cur));\n                }\n                if(mid < r && l < cr){\n                    ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));\n                }\n                return ret;\n            }\n        }\n    }\n\n    public static char[] rev(char[] a){char[] b = new char[a.length];for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];return b;}\n\n    public static double dist(double a, double b){\n        return Math.sqrt(a * a + b * b);\n    }\n\n    public static long inv(long a){\n        return quickPOW(a, MOD - 2);\n    }\n\n    public class Interval {\n        int start;\n        int end;\n        public Interval(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    public static ArrayList<Integer> sieveOfEratosthenes(int n) {\n        boolean prime[] = new boolean[n + 1];\n        Arrays.fill(prime, true);\n        for (int p = 2; p * p <= n; p++) {\n            if (prime[p]) {\n                for (int i = p * 2; i <= n; i += p) {\n                    prime[i] = false;\n                }\n            }\n        }\n        ArrayList<Integer> primeNumbers = new ArrayList<>();\n        for (int i = 2; i <= n; i++) {\n            if (prime[i]) {\n                primeNumbers.add(i);\n            }\n        }\n        return primeNumbers;\n    }\n\n\n    public static int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }\n    public static int lowerBound(int[] a, int l, int r, int v)\n    {\n        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();\n        int low = l-1, high = r;\n        while(high-low > 1){\n            int h = high+low>>>1;\n            if(a[h] >= v){\n                high = h;\n            }else{\n                low = h;\n            }\n        }\n        return high;\n    }\n    public static int rlowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }\n    public static int rlowerBound(int[] a, int l, int r, int v)\n    {\n        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();\n        int low = l-1, high = r;\n        while(high-low > 1){\n            int h = high+low>>>1;\n            if(a[h] <= v){\n                high = h;\n            }else{\n                low = h;\n            }\n        }\n        return high;\n    }\n    public static long C(int n, int m)\n    {\n        if(m == 0 || m == n) return 1l;\n        if(m > n || m < 0) return 0l;\n        long res = fac[n] * quickPOW((fac[m] * fac[n - m]) % MOD, MOD - 2) % MOD;\n\n        return res;\n    }\n    public static long quickPOW(long n, long m)\n    {\n        long ans = 1l;\n        while(m > 0)\n        {\n            if(m % 2 == 1)\n                ans = (ans * n) % MOD;\n            n = (n * n) % MOD;\n            m >>= 1;\n        }\n        return ans;\n    }\n    public static long quickPOW(long n, long m, long mod)\n    {\n        long ans = 1l;\n        while(m > 0)\n        {\n            if(m % 2 == 1)\n                ans = (ans * n) % mod;\n            n = (n * n) % mod;\n            m >>= 1;\n        }\n        return ans;\n    }\n\n    public static int gcd(int a, int b)\n    {\n        if(a % b == 0) return b;\n        return gcd(b, a % b);\n    }\n    public static long gcd(long a, long b)\n    {\n        if(a % b == 0) return b;\n        return gcd(b, a % b);\n    }\n\n    static class Randomized {\n        public static void shuffle(int[] data) {\n            shuffle(data, 0, data.length - 1);\n        }\n\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static void shuffle(long[] data) {\n            shuffle(data, 0, data.length - 1);\n        }\n\n        public static void shuffle(long[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                long tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return RandomWrapper.INSTANCE.nextInt(l, r);\n        }\n    }\n\n    static class RandomWrapper {\n        private Random random;\n        public static final RandomWrapper INSTANCE = new RandomWrapper(new Random());\n\n        public RandomWrapper() {\n            this(new Random());\n        }\n\n        public RandomWrapper(Random random) {\n            this.random = random;\n        }\n\n        public int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int ni() {\n            return Integer.parseInt(next());\n        }\n        long nl() {\n            return Long.parseLong(next());\n        }\n        double nd() {\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    //--------------------------------------------------------\n}", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "\npublic class Main {\n\n\tprivate static void solve() {\n\t\tint n = ni();\n\t\tdouble r = ni();\n\n\t\tdouble[][] p = new double[n][2];\n\t\tdouble EPS = 0.0000000000001;\n\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tdouble x = ni();\n\t\t\tdouble y = r;\n\t\t\tfor (int j = 0; j < i; j ++) {\n\t\t\t\tdouble dx = Math.abs(p[j][0] - x);\n\t\t\t\tif (dx <= r * 2 + EPS) {\n\t\t\t\t\tdouble dy = Math.sqrt(4.0 * r * r - dx * dx);\n\t\t\t\t\ty = Math.max(y, p[j][1] + dy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.printf(\"%.12f \", y);\n\t\t\tp[i][0] = x;\n\t\t\tp[i][1] = y;\n\t\t}\n\t\tout.println();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tlong start = System.currentTimeMillis();\n\t\t\t\tString debug = args.length > 0 ? args[0] : null;\n\t\t\t\tif (debug != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tis = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n\t\t\t\tsolve();\n\t\t\t\tout.flush();\n\t\t\t\ttr((System.currentTimeMillis() - start) + \"ms\");\n\t\t\t}\n\t\t}, \"\", 64000000).start();\n\t}\n\n\tprivate static java.io.InputStream is = System.in;\n\tprivate static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n\tprivate static java.util.StringTokenizer tokenizer = null;\n\tprivate static java.io.BufferedReader reader;\n\n\tpublic static String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new java.util.StringTokenizer(reader.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tprivate static long nl() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static char[] ns() {\n\t\treturn next().toCharArray();\n\t}\n\n\tprivate static long[] nal(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int[][] ntable(int n, int m) {\n\t\tint[][] table = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ttable[i][j] = ni();\n\t\t\t}\n\t\t}\n\t\treturn table;\n\t}\n\n\tprivate static int[][] nlist(int n, int m) {\n\t\tint[][] table = new int[m][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ttable[j][i] = ni();\n\t\t\t}\n\t\t}\n\t\treturn table;\n\t}\n\n\tprivate static int ni() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tif (is != System.in)\n\t\t\tSystem.out.println(java.util.Arrays.deepToString(o));\n\t}\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(br.readLine());\n        StringTokenizer st;\n        for(int z=0;z<t;z++){\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            st = new StringTokenizer(br.readLine());\n            int min=1;\n            int max=1;\n            for(int i=0;i<n;i++){\n                int k = Integer.parseInt(st.nextToken());\n                if(max<k){\n                    min = max;\n                    max = k;\n                }else if(min<k){\n                    min = k;\n                }\n            }\n            int res = Math.min(n-2,min-1);\n            System.out.println(res);\n        }\n    }\n}\n\n", "complexity": "linear", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n\n    long mod = (long) (1e9 + 7);\n\n    void solve() throws Throwable {\n        long x = readLong(), k = readLong();\n        if (x == 0) {\n            System.out.println(0);\n            return;\n        }\n        long r = solveFast(x, k);\n        //long r2 = solveSlow(x, k) % mod;\n        System.out.println(r);\n        //System.out.println(r2);\n    }\n\n    private long solveSlow(long x, long k) {\n        List<Long> a = new ArrayList<>();\n        a.add(x);\n        for (int i = 0; i < k; i++) {\n            dodouble(a);\n            a = eat(a);\n        }\n        dodouble(a);\n        long sum = 0;\n        for (Long v : a) {\n            sum = (sum + v) % mod;\n        }\n        return sum * rev(a.size(), mod) % mod;\n    }\n\n    private List<Long> eat(List<Long> a) {\n        List<Long> r = new ArrayList<>();\n        for (Long v : a) {\n            r.add(v);\n            r.add((v - 1 + mod) % mod);\n        }\n        return r;\n    }\n\n    private void dodouble(List<Long> a) {\n        for (int i = 0; i < a.size(); i++) {\n            a.set(i, a.get(i) * 2 % mod);\n        }\n    }\n\n    private long solveFast(long x, long k) {\n        long n = binpow(2, k, mod);\n        long ma = (binpow(2, k + 1, mod) * (x % mod)) % mod;\n        long mi = (ma - n * 2 + 2 + mod * 100) % mod;\n        return ((ma + mi) * rev(2, mod)) % mod;\n    }\n\n    private long rev(long a, long mod) {\n        return binpow(a, mod - 2, mod);\n    }\n\n    //-------------------------------------------------\n\n    final boolean ONLINE_JUDGE = !new File(\"input.txt\").exists();\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok;\n\n    public void run() {\n        Runnable run = () -> {\n            try {\n                long startTime = System.currentTimeMillis();\n                Locale.setDefault(Locale.US);\n                if (ONLINE_JUDGE) {\n                    in = new BufferedReader(new InputStreamReader(System.in));\n                    out = new PrintWriter(System.out);\n                } else {\n                    in = new BufferedReader(new FileReader(\"input.txt\"));\n                    out = new PrintWriter(\"output.txt\");\n                }\n                tok = new StringTokenizer(\"\");\n                solve();\n                in.close();\n                out.close();\n                long endTime = System.currentTimeMillis();\n                long totalMemory = Runtime.getRuntime().totalMemory();\n                long freeMemory = Runtime.getRuntime().freeMemory();\n                System.err.println();\n                System.err.println(\"Time = \" + (endTime - startTime) + \" ms\");\n                //System.err.println(\"Memory = \" + ((totalMemory - freeMemory) / 1024) + \" KB\");\n            } catch (Throwable e) {\n                e.printStackTrace(System.err);\n                System.exit(-1);\n            }\n        };\n        new Thread(null, run, \"run\", 256 * 1024 * 1024).start();\n        min(0, 0);\n    }\n\n    String readString() {\n        while (!tok.hasMoreTokens()) {\n            String line;\n            try {\n                line = in.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            if (line == null) return null;\n            tok = new StringTokenizer(line);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    void debug(Object... o) {\n        if (!ONLINE_JUDGE) {\n            System.err.println(Arrays.deepToString(o));\n        }\n    }\n\n    /*long binpow(long a, long n) {\n        long r = 1;\n        while (n > 0) {\n            if ((n & 1) > 0) {\n                r *= a;\n            }\n            a *= a;\n            n /= 2;\n        }\n        return r;\n    }/**/\n\n    long binpow(long a, long n, long mod) {\n        long r = 1;\n        while (n > 0) {\n            if ((n & 1) > 0) {\n                r = (r * a) % mod;\n            }\n            a = (a * a) % mod;\n            n /= 2;\n        }\n        return r;\n    }/**/\n\n    static long gcd(long x, long y) {\n        return y == 0 ? x : gcd(y, x % y);\n    }\n\n    private long[] readLongArray(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = readLong();\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public void solve() throws IOException {\n        int n = nextInt();\n        output.println(n / 2 * 3);\n    }\n\n    public void run() throws IOException {\n        input = new BufferedReader(new InputStreamReader(System.in));\n        output = new PrintWriter(System.out);\n        solve();\n        input.close();\n        output.close();\n    }\n\n    BufferedReader input;\n    PrintWriter output;\n    StringTokenizer tok;\n\n    String nextToken() throws IOException {\n        while(tok == null || !tok.hasMoreTokens())\n            tok = new StringTokenizer(input.readLine());\n\n        return tok.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.valueOf(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.valueOf(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.valueOf(nextToken());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class LittleGirlAndMaximumXOR {\n\n\tpublic static PrintWriter out;\n\tprivate static final long MOD = 1000000007;\n\tprivate static final double INFINITY = 1e18;\n\n\tpublic static void main(String[] args) {\n\t\tLittleGirlAndMaximumXOR ans = new LittleGirlAndMaximumXOR();\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\t\t \t\t\n\t\tans.solve();\n\t\tout.close();\n\t}\n\n\tprivate void solve() {\n\t\tScanner sc =new Scanner(System.in);\n\t\tlong a = sc.nextLong();\n\t\tlong b = sc.nextLong();\n\t\tlong [] arrayOne = convertToBinary(a);\n\t\tlong [] arrayTwo = convertToBinary(b);\n\t\tint N1=arrayOne.length;\n\t\tint N2=arrayTwo.length;\n \n \n\t\tif(N1!=N2) {\n\t\t\tlong [] temp;\n\t\t\tif(N1>N2) {\n\t\t\t\ttemp = new long[N1];\n\t\t\t\tarrayTwo = copyToArrayFromBack(temp, arrayTwo);\n\t\t\t} else {\n\t\t\t\ttemp = new long[N2];\n\t\t\t\tarrayOne = copyToArrayFromBack(temp, arrayOne);\n\t\t\t}\n\t\t}\n\n\t\tint i=0;\n\t\tlong result=0;\n\t\tint N = arrayTwo.length; \n\t\tfor(i=0;i<arrayTwo.length;i++) {\n\t\t\tif(arrayTwo[i]!=arrayOne[i]) break;\t\t\t \n\t\t}\n\t\t \n\t\twhile(i<arrayTwo.length) {\n\t\t\t//out.println(1);\n\t\t\tresult = result + (1L<<(N-i-1));\n\t\t\t//out.printf(\"%d-%d-1: %d, result: %d\\n\",N, i, N-i-1, result);\n\t\t\ti++;\n\t\t}\n\t\tout.println(result);\n\n\t\t/*\n\t\twhile(i>=0 && j>=0){\n\t\t\tif(arrayOne[i]==arrayTwo[i]) result += (arrayOne[i]*(1<<pos));\n\t\t\telse if(arrayOne[i]!=arrayTwo[i]){\n\n\t\t\t}\n\t\t\tpos++;\n\t\t}*/\n\t\t//System.out.println(Arrays.toString(arrayOne));\n\t\t//System.out.println(Arrays.toString(arrayTwo));\n\n\t}\n\n\tprivate long[] copyToArrayFromBack(long[]to, long []from) {\n\t\tint j = to.length-1;\n\t\tfor(int i=from.length-1;i>=0;i--) {\n\t\t\tto[j--] = from[i];\n\t\t}\n\t\treturn to;\n\t}\n\n\tprivate void printPrecision(double val, int precision) {\n\t\tout.printf(\"%.\"+precision+\"f\\n\",val);\n\t}\n\n\tprivate boolean isBitSet(int N, int i) {\n\t\treturn (N&(1<<i))>0;\n\t}\n\n\tprivate long[] convertToBinary(long N) {\n\t\tint LOGN=0;\t\t \n        while((1L<<(LOGN))<=N) LOGN++;\n        long []array  = new long[LOGN];         \n        for(int i=LOGN-1;i>=0;i--){\n        \tarray[i] = N&1;\n        \tN=N>>1;        \t \n        }         \n        return array;\n\t}\n\n\tprivate int setBit(int N, int i) {\n\t\treturn N|(1<<i);\n\t}\n\n\tprivate int clearBit(int N, int i) {\n\t\tint mask = ~(1<<i);\n\t\treturn N&mask;\n\t}\n\n\tprivate int updateBit(int N, int pos, int value) {\n\t\tclearBit(N, pos);\n\t\treturn N|(1<<value);\n\t}\n\n\tprivate int blowLastIBits(int N, int i) {\n\t\tint mask = -1<<i;\n\t\treturn N&mask;\n\t}\n\n\tprivate Equation extendedGCD(long a, long b) {\n\t\tif (a==0) return new Equation(b, 0, 1);\n\t\tEquation e = extendedGCD(b%a, a);\n\t\treturn new Equation(e.gcd, e.y-((b/a)*e.x), e.x);\n\t}\n\n   \n\tprivate long modularInverse(long a, long M) {\n\t\tEquation e = extendedGCD(a, M);\n\t\treturn e.x%M;\n\t}\n\t \n\n\tprivate int blowBitsBetweenRange(int N, int i, int j) {\n\t\tint a = -1<<(i+1);\n\t\tint b = (1<<j)-1;\n\t\tint mask = a|b;\n\t\treturn N&mask;\n\t}\n\n\tprivate long gcd(long a, long b) {\n\t\tif(b==0) return a;\n\t\treturn gcd(b, a%b);\n\t}\n\n\tprivate long power(long a, int N) {\n\t\tlong result = 1;\n\t\twhile(N>0) {\n\t\t\tif((N&1)>0) {\n\t\t\t\tresult *=a;\n\t\t\t}\n\t\t\ta*=a;\n\t\t\tN=N>>1;\n\t\t}\n\t\treturn result; \n\t}\n\t \n\tprivate int countOfSetBits(int N) {\n\t\tint result =0;\n\t\twhile(N>0) {\n\t\t\t// blows of the last bit\n\t\t\tN=N&(N-1);\n\t\t\tresult++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate int closestLeft(long[] array, long target) {\n \n\t\tint N = array.length;\n\t\tint lo=0, hi=N-1;\n\t\tif(array[0]>target) return 0;\n\t\tif(array[hi]<target) return N;\n\t\tint ans =0;\n\t\twhile(lo<=hi) {\n\t\t\tint mid = lo+(hi-lo)/2;\t\t\t \n\t\t\tif (array[mid]<=target) {\n\t\t\t\tans = mid;\n\t\t\t\tlo= mid+1;\n\t\t\t} else {\n\t\t\t\thi= mid-1;\n\t\t\t}\n\t\t}\n\t\treturn ans+1;\n\t}\n\n\tprivate int closestLeftInList(List<Long> array, long target) {\n \n\t\tint N = array.size();\n\t\tint lo=0, hi=N-1;\n\t\tif(array.get(0)>target) return 0;\n\t\tif(array.get(hi)<target) return N;\n\t\tint ans =0;\n\t\twhile(lo<=hi) {\n\t\t\tint mid = lo+(hi-lo)/2;\t\t\t \n\t\t\tif (array.get(mid)<=target) {\n\t\t\t\tans = mid;\n\t\t\t\tlo= mid+1;\n\t\t\t} else {\n\t\t\t\thi= mid-1;\n\t\t\t}\n\t\t}\n\t\treturn ans+1;\n\t}\n\n\tprivate int closestRightInList(List<Long> array, long target) {\n\t\tint N = array.size();\n\t\tint lo=0, hi=N-1;\n\t\tif(array.get(lo)>=target) return 1;\n\t\tif(array.get(hi)<target) return N+1;\n\t\tint ans=0;\n\t\twhile(lo<=hi) {\n\t\t\tint mid = lo+ (hi-lo)/2;\n\t\t\tif(array.get(mid)>=target) {\n\t\t\t\tans=mid;\n\t\t\t\thi=mid-1;\n\t\t\t} else {\n\t\t\t\tlo=mid+1;\n\t\t\t}\n\t\t}\t\t \t\t\n\t\treturn ans+1;\n\t}\n\n\tprivate int closestRight(long[] array, long target) {\n\t\tint N = array.length;\n\t\tint lo=0, hi=N-1;\n\t\tif(array[lo]>=target) return 1;\n\t\tif(array[hi]<target) return N+1;\n\t\tint ans=0;\n\t\twhile(lo<=hi) {\n\t\t\tint mid = lo+ (hi-lo)/2;\n\t\t\tif(array[mid]>=target) {\n\t\t\t\tans=mid;\n\t\t\t\thi=mid-1;\n\t\t\t} else {\n\t\t\t\tlo=mid+1;\n\t\t\t}\n\t\t}\t\t \t\t\n\t\treturn ans+1;\n\t}\n\t \n}\nclass Equation {\n\tlong gcd,x,y;\n\tpublic Equation(long gcd, long x, long y) {\n\t\tthis.gcd = gcd;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n/**\n * @author Egor Kulikov (egor@egork.net)\n *         Created on 14.03.2010\n */\npublic class TaskD implements Runnable {\n\tprivate InputReader in;\n\tprivate PrintWriter out;\n\tprivate int n;\n\tprivate int m;\n\tprivate boolean[][] e;\n\tprivate long[][] qp;\n\n\tprivate static class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1000];\n\t\tprivate int curChar, numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int readInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long readLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuffer res = new StringBuffer();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate String readLine0() {\n\t\t\tStringBuffer buf = new StringBuffer();\n\t\t\tint c = read();\n\t\t\twhile (c != '\\n' && c != -1) {\n\t\t\t\tbuf.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\treturn buf.toString();\n\t\t}\n\n\t\tpublic String readLine() {\n\t\t\tString s = readLine0();\n\t\t\twhile (s.trim().length() == 0)\n\t\t\t\ts = readLine0();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic String readLine(boolean ignoreEmptyLines) {\n\t\t\tif (ignoreEmptyLines)\n\t\t\t\treturn readLine();\n\t\t\telse\n\t\t\t\treturn readLine0();\n\t\t}\n\n\t\tpublic BigInteger readBigInteger() {\n\t\t\ttry {\n\t\t\t\treturn new BigInteger(readString());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tpublic char readCharacter() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\treturn (char) c;\n\t\t}\n\n\t\tpublic double readDouble() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') {\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n//\t\tnew Thread(new Template()).start();\n\t\tnew TaskD().run();\n\t}\n\n\tpublic TaskD() {\n//\t\tString id = getClass().getName().toLowerCase();\n//\t\ttry {\n//\t\t\tSystem.setIn(new FileInputStream(id + \".in\"));\n//\t\t\tSystem.setOut(new PrintStream(new FileOutputStream(id + \".out\")));\n//\t\t} catch (FileNotFoundException e) {\n//\t\t\tthrow new RuntimeException();\n//\t\t}\n\t\tin = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t}\n\n\tpublic void run() {\n//        int numTests = in.readInt();\n//        for (int testNumber = 0; testNumber < numTests; testNumber++) {\n//        }\n\t\tn = in.readInt();\n\t\tm = in.readInt();\n\t\te = new boolean[n][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = in.readInt() - 1;\n\t\t\tint b = in.readInt() - 1;\n\t\t\te[a][b] = e[b][a] = true;\n\t\t}\n//\t\tn = 19;\n//\t\te = new boolean[n][n];\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tfor (int j = 0; j < n; j++)\n//\t\t\t\te[i][j] = i != j;\n//\t\t}\n\t\tint msk = (1 << n) - 1;\n\t\tqp = new long[n - 1][1 << (n - 1)];\n\t\tlong ans = 0;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tmsk -= (1 << i);\n\t\t\tfor (int k = 0; k < i; k++)\n\t\t\t\tArrays.fill(qp[k], 0, 1 << i, -1);\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (e[i][j]) {\n\t\t\t\t\te[i][j] = e[j][i] = false;\n\t\t\t\t\tans += go(j, msk - (1 << j), i);\n\t\t\t\t\te[i][j] = e[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans / 2);\n\t\tout.close();\n\t}\n\n\tprivate long go(int v, int msk, int u) {\n\t\tif (qp[v][msk] != -1)\n\t\t\treturn qp[v][msk];\n\t\tqp[v][msk] = 0;\n\t\tif (e[v][u])\n\t\t\tqp[v][msk] = 1;\n\t\tfor (int i = 0; i < u; i++) {\n\t\t\tif (e[v][i] && ((msk >> i) & 1) != 0)\n\t\t\t\tqp[v][msk] += go(i, msk - (1 << i), u);\n\t\t}\n\t\treturn qp[v][msk];\n\t}\n}", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class CottageVillage {\n    \n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        \n        TreeMap<Integer, Integer> tm = new TreeMap<Integer, Integer>();\n        while (n-->0) {\n            tm.put(sc.nextInt(), sc.nextInt());\n        }\n        \n        int cnt=2, x=0, a=0; \n        double diff=0;\n        for(Map.Entry<Integer, Integer> e : tm.entrySet()) {\n            if (x!=0 || a!=0) {\n                diff = Math.abs(e.getKey()-x-e.getValue()*0.5-a*0.5); \n                if (diff-k>0) cnt+=2;\n                else if (diff-k==0) cnt++;\n            }\n            x=e.getKey();\n            a=e.getValue();\n        }\n        System.out.println(cnt);\n    }\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n\npublic class a{ \n     static int[] count,count1,count2;\n     static Node[] nodes;\n     static long[] arr;\n     static int[] dp,arrInt,darrInt;\n     static char[] ch,ch1;\n     static long[] darr,farr;\n     static char[][] mat,mat1;\n     static int[][] space;\n     static boolean[][] vis;\n     static long x,h;\n     static long maxl;\n     static double dec;\n     static long mx = (long)1e10;\n     static String s,s1,s2,s3,s4;\n     static long minl;\n     static int start_row;\n     static int start_col;     \n     static int end_row;     \n     static int end_col;     \n     static long mod = 998244353;\n     // static int minl = -1;\n     // static long n;\n     static int n,n1,n2,q,r1,c1,r2,c2;\n     static long a;\n     static long b;\n     static long c;\n     static long d;\n     static long y,z;\n     static int m;\n     static long k;\n     static FastScanner sc;\n     static String[] str,str1;\n     static Set<Long> set,set1,set2;\n     static SortedSet<Long> ss;\n     static List<Long> list,list1,list2,list3;\n     static PriorityQueue<Integer> pq,pq1;\n     static LinkedList<Node> ll;\n     static Map<Integer,List<Integer>> map1;\n     static Map<Long,Integer> map;\n     static StringBuilder sb,sb1,sb2;\n     static int index;\n     static long[] sum;\n     static int[] dx = {0,-1,0,1,-1,1,-1,1};\n     static int[] dy = {-1,0,1,0,-1,-1,1,1};\n\n     // public static void solve(){\n\n     //    FastScanner sc = new FastScanner();\n     //    // int t = sc.nextInt();\n     //    int t = 1;\n     //    for(int tt = 0 ; tt < t ; tt++){\n\n     //        // s = sc.next();\n     //        // s1 = sc.next();\n\n     //        n = sc.nextInt();\n     //        m = sc.nextInt();\n     //        sb = new StringBuilder();\n     //        // map = new HashMap<>();\n     //        // q = sc.nextInt();\n     //        // k = sc.nextLong();\n     //        // ch = sc.next().toCharArray();\n     //        // boolean ans = false;\n     //        // int charge = n;\n     //        // int prev = 0;\n\n     //        count = new int[m+1];\n           \n     //        // m = sc.nextInt();\n     //        long ans = 0;\n     //        // long added = 0;\n\n     //        for(int j = 0 ; j < n ; j++){\n\n     //            int l = sc.nextInt();\n     //            int r = sc.nextInt();\n     //            for(int i = l ; i <= r; i++)\n     //                count[i] = 1;\n\n     //        }\n\n     //        for(int i = 1 ; i <= m ; i++){\n     //            if(count[i] == 0){\n     //                ans += 1;\n     //                sb.append((i)+\" \");\n     //            }\n     //        }\n     //        System.out.println(ans);\n     //        System.out.println(sb);\n     //    }\n        \n     // }\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n\n     public static void solve(){\n\n        int k = 0;\n        long ans = 0;\n        for(int i = 0 ; i < n ;i++){\n            if(k == m)\n                break;\n            if(darr[k] >= arr[i]){\n                ans += 1;\n                k += 1;\n            }\n        }\n\n        System.out.println(ans);\n\n     }\n        \n     public static void main(String[] args) {\n\n            sc = new FastScanner();\n            // Scanner sc = new Scanner(System.in);\n            // int t = sc.nextInt();\n            int t = 1;\n            // int l = 1;\n            while(t > 0){\n                \n                n = sc.nextInt();\n                // n = sc.nextLong();\n                // k = sc.nextLong();\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // z = sc.nextLong();\n\n                // a = sc.nextLong();\n                // b = sc.nextLong();\n                // c = sc.nextLong();\n                // d = sc.nextLong();\n\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // z = sc.nextLong();\n                // d = sc.nextLong();\n                \n                // n = sc.nextLong();\n                // n = sc.nextInt();\n                // n = 3;\n                // n1 = sc.nextInt();\n\n                m = sc.nextInt();\n                // q = sc.nextInt();\n\n                // k = sc.nextLong();\n                // d = sc.nextLong();\n                // s = sc.next();\n\n                // ch = sc.next().toCharArray();\n                // ch1 = sc.next().toCharArray();\n\n                // n = 3;\n                arr = new long[n];\n                for(int i = 0 ; i < n ; i++){\n                    arr[i] = sc.nextLong();\n                }\n\n                // arrInt = new int[n];\n                // for(int i = 0 ; i < n ; i++){\n                //     arrInt[i] = sc.nextInt();\n                // }\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // ch = sc.next().toCharArray();\n                // m = n;\n                darr = new long[m];\n                for(int i = 0 ; i < m ; i++){\n                    darr[i] = sc.nextLong();\n                }\n\n                // m = n;\n                // darrInt = new int[m];\n                // for(int i = 0 ; i < m ; i++){\n                //     darrInt[i] = sc.nextInt();\n                // }\n\n                // farr = new int[n];\n                // for(int i = 0; i < n ; i++){\n                //     farr[i] = sc.nextInt();\n                // }\n\n                // mat = new long[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat[i][j] = sc.nextLong();\n                //     }\n                // }\n\n                // m = n;\n                // mat = new char[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     String s = sc.next();\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat[i][j] = s.charAt(j);\n                //     }\n                // }\n\n                // m = n;\n                // mat1 = new char[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     String s = sc.next();\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat1[i][j] = s.charAt(j);\n                //     }\n                // }\n\n                // n= 5 ;\n                // str = new String[n];\n                // for(int i = 0 ; i < n ; i++)\n                //     str[i] = sc.next();\n\n                // nodes = new Node[n];\n                // for(int i = 0 ; i < n ;i++)\n                //     nodes[i] = new Node(sc.nextInt(),(i+1));\n\n                // m = sc.nextInt();\n\n                // System.out.println(solve()?\"YES\":\"NO\");\n                 solve();       \n                 // System.out.println(solve());\n                 t -= 1;\n            }\n\n     }\n\n     // public static dfs(int i){\n\n     //    if(count[i] == 1)\n     //        return;\n     //    list = map.get(i);\n     //    for(Integer j : list){\n     //        if(j == i)\n     //            continue;\n     //        dfs(j);\n     //    }\n     // }\n\n    public static int log(long n,long base){\n\n         if(n == 0 || n == 1)\n             return 0;\n\n         if(n == base)\n             return 1;\n\n         double num = Math.log(n);\n         double den = Math.log(base);\n\n         if(den == 0)\n             return 0;\n\n         return (int)(num/den);\n     }\n\n    public static boolean isPrime(long n) { \n    // Corner cases \n        if (n <= 1)  \n            return false; \n\n        if (n <= 3)  \n            return true; \n      \n        // This is checked so that we can skip  \n        // middle five numbers in below loop \n        if (n%2 == 0 || n%3 == 0) \n            return false; \n      \n        for (int i=5; i*i<=n; i=i+6) \n            if (n%i == 0 || n%(i+2) == 0) \n               return false; \n      \n        return true; \n    } \n\n    public static long gcd(long a, long b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b); \n    }\n\n     public static long mod_inverse(long a,long mod){\n        long x1=1,x2=0;\n        long p=mod,q,t;\n        while(a%p!=0){\n          q = a/p;\n          t = x1-q*x2;\n          x1=x2; x2=t;\n          t=a%p;\n          a=p; p=t;\n        }\n        return x2<0 ? x2+mod : x2;\n    }\n\n     public static void swap(int i,int j){\n         long temp = arr[j];\n         arr[j] = arr[i];\n         arr[i] = temp;\n     } \n\n    static final Random random=new Random();\n\n    static void ruffleSortLong(long[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            long temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSortInt(int[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            int temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n    \n    static void ruffleSortChar(char[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            char temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class Node{\n        Integer first;\n        Integer second;\n        Node(Integer f,Integer s){\n            this.first = f;\n            this.second = s;\n        }\n    }\n\n     static class FastScanner {\n\n                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n                StringTokenizer st=new StringTokenizer(\"\");\n                String next() {\n                        while (!st.hasMoreTokens())\n                                try {\n                                        st=new StringTokenizer(br.readLine());\n                                } catch (IOException e) {\n                                        e.printStackTrace();\n                                }\n                        return st.nextToken();\n                }\n                \n                int nextInt() {\n                        return Integer.parseInt(next());\n                }\n                int[] readArray(int n) {\n                        int[] a=new int[n];\n                        for (int i=0; i<n; i++) a[i]=nextInt();\n                        return a;\n                }\n                long nextLong() {\n                        return Long.parseLong(next());\n                }\n        }\n\n}", "complexity": "linear", "problem": "1009_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.io.FilterInputStream;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeSet;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Zyflair Griffane\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputUtil in = new InputUtil(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    HashMap<Integer, Integer> left = new HashMap<Integer, Integer>();\n\n    public void solve(int testNumber, InputUtil in, PrintWriter out) {\n        int n = in.nextInt();\n        int a = in.nextInt();\n        int b = in.nextInt();\n\n        int[] res = new int[n];\n        int[] arr = in.nextIntArray(n);\n\n        IntDeque[] adj = IntDeque.IntDeques(n);\n        boolean[] self = new boolean[n];\n        boolean[] assigned = new boolean[n];\n\n        for (int i = 0; i < n; i++) {\n            left.put(arr[i], i);\n        }\n        for (int i = 0; i < n; i++) {\n            int x = arr[i];\n\n            boolean canA = left.containsKey(a - x);\n            boolean canB = left.containsKey(b - x);\n            if (!canA && !canB) {\n                out.println(\"NO\");\n                return;\n            }\n\n            if (left.containsKey(a - x)) {\n                self[i] |= x == a - x;\n                if (x != a - x) {\n                    adj[i].add(left.get(a - x));\n                }\n            }\n\n            if (left.containsKey(b - x)) {\n                self[i] |= x == b - x;\n                if (x != b - x) {\n                    adj[i].add(left.get(b - x));\n                }\n            }\n        }\n\n        if (a == b) {\n            out.println(\"YES\");\n            out.println(IntArrayUtil.toString(res));\n            return;\n        }\n\n        for (int iter = 0; iter < 2; iter++) {\n            for (int i = 0; i < n; i++) {\n                if (!self[i] && !assigned[i] && (iter == 1 || adj[i].size() == 1)) {\n                    int u = i;\n                    DFS:\n                    while (true) {\n                        assigned[u] = true;\n                        if (self[u] && arr[u] == b - arr[u]) {\n                            res[u] = 1;\n                            break;\n                        }\n                        for (int v : adj[u]) {\n                            if (!assigned[v]) {\n                                assigned[v] = true;\n                                if (arr[u] == b - arr[v]) {\n                                    res[u] = res[v] = 1;\n                                }\n                                for (int newU : adj[v]) {\n                                    if (!assigned[newU]) {\n                                        u = newU;\n                                        continue DFS;\n                                    }\n                                }\n                                break DFS;\n                            }\n                        }\n                        out.println(\"NO\");\n                        return;\n                    }\n                }\n                else if (iter == 1 && !assigned[i] && adj[i].size() == 0 && arr[i] == b - arr[i]) {\n                    res[i] = 1;\n                }\n            }\n        }\n\n        out.println(\"YES\");\n        out.println(IntArrayUtil.toString(res));\n    }\n\n\n}\n\nclass InputUtil {\n\n    JoltyScanner in;\n\n    public InputUtil(InputStream istream) {\n        in = new JoltyScanner(istream);\n    }\n\n    public String next() {\n        return in.next();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public int[] nextIntArray (int size) {\n        int[] arr = new int[size];\n        for (int i = 0; i < size; i++) {\n            arr[i] = in.nextInt();\n        }\n        return arr;\n    }\n\n}\n\nclass IntDeque implements Iterable<Integer> {\n\n    private int capacity;\n    private int size = 0;\n    private int front = 0;\n    private int back = 0;\n    private int[] deque;\n    public IntDeque() {\n        this(16);\n    }\n    public IntDeque(int capacity) {\n        this.capacity = capacity;\n        deque = new int[capacity];\n    }\n    public static IntDeque[] IntDeques(int length) {\n        IntDeque[] arr = new IntDeque[length];\n        for (int i = 0; i < length; i++) {\n            arr[i] = new IntDeque();\n        }\n        return arr;\n    }\n    public <T extends Iterable<Integer>>IntDeque(T intList) {\n        this(16);\n        addAll(intList);\n    }\n    public IntDeque(int[] intArr) {\n        this(16);\n        for (int i: intArr) {\n            addLast(i);\n        }\n    }\n    public void add(int x) {\n        addLast(x);\n    }\n    public <T extends Iterable<Integer>>void addAll(T intList) {\n        for (int i: intList) {\n            addLast(i);\n        }\n    }\n    public void addLast(int x) {\n        ensureCapacity();\n        size++;\n        deque[back++] = x;\n        if (back == capacity) {\n            back = 0;\n        }\n    }\n\n    public void ensureCapacity() {\n        if (size < capacity) {\n            return;\n        }\n        int[] newDeque = new int[capacity << 1];\n        for (int i = 0, j = front; i < size; i++, j++) {\n            if (j == capacity) {\n                j = 0;\n            }\n            newDeque[i] = deque[j];\n        }\n        deque = newDeque;\n        capacity <<= 1;\n        front = 0;\n        back = size;\n    }\n\n    public Iterator<Integer> iterator() {\n        return new Iterator<Integer>() {\n            int done = 0;\n            int curr = front;\n            public boolean hasNext() {\n                return done < size;\n            }\n            public Integer next() {\n                Integer res = deque[curr++];\n                if (curr == capacity) {\n                    curr = 0;\n                }\n                done++;\n                return res;\n            }\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    public int size() {\n        return size;\n    }\n\n    public String toString() {\n        if (size == 0) {\n            return \"\";\n        }\n        StringBuilder res = new StringBuilder();\n        for (int i: this) {\n            res.append(i);\n            res.append(\" \");\n        }\n        res.setLength(res.length() - 1);\n        return res.toString();\n    }\n}\n\nclass IntArrayUtil {\n\n    public static String toString(int[] arr) {\n        return toString(arr, \" \");\n    }\n\n    public static String toString(int[] arr, String delimiter) {\n        StringBuilder res = new StringBuilder();\n        for (int i: arr) {\n            res.append(i);\n            res.append(delimiter);\n        }\n        res.setLength(res.length() - delimiter.length());\n        return res.toString();\n    }\n\n}\n\nclass JoltyScanner {\n    public static final int BUFFER_SIZE = 1 << 16;\n\tpublic static final char NULL_CHAR = (char) -1;\n\n\tStringBuilder str = new StringBuilder();\n\tbyte[] buffer = new byte[BUFFER_SIZE];\n\tboolean EOF_FLAG = false;\n\tint bufferIdx = 0, size = 0;\n\tchar c = NULL_CHAR;\n\tBufferedInputStream in;\n\n\tpublic JoltyScanner(InputStream in) {\n\t\tthis.in = new BufferedInputStream(in, BUFFER_SIZE);\n\t}\n\n\tpublic int nextInt() {\n\t\tlong x = nextLong();\n\t\tif (x > Integer.MAX_VALUE || x < Integer.MIN_VALUE) {\n\t\t\tthrow new ArithmeticException(\"Scanned value overflows integer\");\n\t\t}\n\t\treturn (int) x;\n\t}\n\n\tpublic long nextLong() {\n\t\tboolean negative = false;\n\t\tif (c == NULL_CHAR) {\n\t\t\tc = nextChar();\n\t\t}\n\t\tfor (; !EOF_FLAG && (c < '0' || c > '9'); c = nextChar()) {\n\t\t\tif (c == '-') {\n\t\t\t\tnegative = true;\n\t\t\t}\t\t\t\t\n\t\t}\n\t\tcheckEOF();\n\t\tlong res = 0;\n\t\tfor (; c >= '0' && c <= '9'; c = nextChar()) {\n\t\t\tres = (res << 3) + (res << 1) + c - '0';\n\t\t}\n\t\treturn negative ? -res : res;\n\t}\n\n    public String next() {\n\t\tcheckEOF();\n\t\tif (c == NULL_CHAR) {\n\t\t\tc = nextChar();\n\t\t}\n\t\twhile (Character.isWhitespace(c)) {\n\t\t\tc = nextChar();\n\t\t\tcheckEOF();\n\t\t}\n\t\tstr.setLength(0);\n\t\tfor (; !EOF_FLAG && !Character.isWhitespace(c); c = nextChar()) {\n\t\t\tstr.append(c);\n\t\t}\n\t\treturn str.toString();\n\t}\n\n    public char nextChar() {\n\t\tif (EOF_FLAG) {\n\t\t\treturn NULL_CHAR;\n\t\t}\n\t\twhile (bufferIdx == size) {\n\t\t\ttry {\n\t\t\t\tsize = in.read(buffer);\n\t\t\t\tif (size == -1) {\n\t\t\t\t\tthrow new Exception();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tEOF_FLAG = true;\n\t\t\t\treturn NULL_CHAR;\n\t\t\t}\n\t\t\tif (size == -1) {\n\t\t\t\tsize = BUFFER_SIZE;\n\t\t\t}\n\t\t\tbufferIdx = 0;\n\t\t}\n\t\treturn (char) buffer[bufferIdx++];\n\t}\n\n    public void checkEOF() {\n\t\tif (EOF_FLAG) {\n\t\t\tthrow new EndOfFileException();\n\t\t}\n\t}\n\n\tpublic class EndOfFileException extends RuntimeException {\n\t}\n}\n\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport static java.util.Collections.list;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\n/**\n *\n * @author is2ac\n */\npublic class D_CF {\n\n    static Integer[][] dp;\n\n    public static void main(String[] args) {\n        FastScanner58 fs = new FastScanner58();\n        PrintWriter pw = new PrintWriter(System.out);\n        //int t = fs.ni();\n        int t = 1;\n        // for (int tc = 0; tc < t; tc++) {\n        for (int tc = 0; tc < t; tc++) {\n            int n = fs.ni();\n            long k = fs.nl();\n            long[] a = fs.longArray(n);\n            List<Map<Long, Integer>> list = new ArrayList();\n            for (int i = 0; i <= 10; i++) {\n                Map<Long, Integer> temp = new HashMap();\n                list.add(temp);\n            }\n            long res = 0;\n            for (int i = 0; i < n; i++) {\n                long x = a[i] % k;\n                for (int j = 1; j <= 10; j++) {\n                    x *= 10L;\n                    x %= k;\n                    if (x == 0) {\n                        if (list.get(j).containsKey(0L)) res += list.get(j).get(0L);\n                    } else {\n                        if (list.get(j).containsKey(k-x)) res += list.get(j).get(k - x);\n                    }\n                }\n                int l = (a[i] + \"\").length();\n                list.get(l).put(a[i] % k, list.get(l).getOrDefault(a[i] % k, 0) + 1);\n            }\n            list = new ArrayList();\n            for (int i = 0; i <= 10; i++) {\n                Map<Long, Integer> temp = new HashMap();\n                list.add(temp);\n            }\n            for (int i = n - 1; i > -1; i--) {\n                long x = a[i] % k;\n                for (int j = 1; j <= 10; j++) {\n                    x *= 10L;\n                    x %= k;\n                    if (x == 0) {\n                        if (list.get(j).containsKey(0L)) res += list.get(j).get(0L);\n                    } else {\n                        if (list.get(j).containsKey(k-x)) res += list.get(j).get(k - x);\n                    }\n                }\n                int l = (a[i] + \"\").length();\n                list.get(l).put(a[i] % k, list.get(l).getOrDefault(a[i] % k, 0) + 1);\n            }\n            pw.println(res);\n        }\n        pw.close();\n    }\n}\n\nclass UnionFind18 {\n\n    int[] id;\n\n    public UnionFind18(int size) {\n        id = new int[size];\n        for (int i = 0; i < size; i++) {\n            id[i] = i;\n        }\n    }\n\n    public int find(int p) {\n        int root = p;\n        while (root != id[root]) {\n            root = id[root];\n        }\n        while (p != root) {\n            int next = id[p];\n            id[p] = root;\n            p = next;\n        }\n        return root;\n    }\n\n    public void union(int p, int q) {\n        int a = find(p), b = find(q);\n        if (a == b) {\n            return;\n        }\n        id[b] = a;\n    }\n}\n\nclass FastScanner58 {\n\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastScanner58() {\n        br = new BufferedReader(new InputStreamReader(System.in), 32768);\n        st = null;\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int ni() {\n        return Integer.parseInt(next());\n    }\n\n    int[] intArray(int N) {\n        int[] ret = new int[N];\n        for (int i = 0; i < N; i++) {\n            ret[i] = ni();\n        }\n        return ret;\n    }\n\n    long nl() {\n        return Long.parseLong(next());\n    }\n\n    long[] longArray(int N) {\n        long[] ret = new long[N];\n        for (int i = 0; i < N; i++) {\n            ret[i] = nl();\n        }\n        return ret;\n    }\n\n    double nd() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n\nclass UnionFind17 {\n\n    int[] id;\n\n    public UnionFind17(int size) {\n        id = new int[size];\n        for (int i = 0; i < size; i++) {\n            id[i] = i;\n        }\n    }\n\n    public int find(int p) {\n        int root = p;\n        while (root != id[root]) {\n            root = id[root];\n        }\n        while (p != root) {\n            int next = id[p];\n            id[p] = root;\n            p = next;\n        }\n        return root;\n    }\n\n    public void union(int p, int q) {\n        int a = find(p), b = find(q);\n        if (a == b) {\n            return;\n        }\n        id[b] = a;\n    }\n}\n", "complexity": "nlogn", "problem": "1029_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class D911 {\n\n\tpublic static long total = 0;\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tArrayList<Integer> temp = new ArrayList<>();\n\t\tint[] ar = new int[n];\n\t\tint[] memo = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = in.nextInt();\n\t\t\tint index = -1*Collections.binarySearch(temp, t)-1;\n\t\t\ttemp.add(index, t);\n\t\t\tar[i] = t;\n\t\t\tmemo[i] = i - index;\n\t\t\ttotal += memo[i];\n\t\t}\n\t\tint m = in.nextInt();\n\t\tfor (int i = 0; i < m; i++) {\n//\t\t\tint a = in.nextInt() - 1, b = in.nextInt() - 1;\n//\t\t\tquery(ar, memo, in.nextInt() - 1, in.nextInt() - 1);\n\t\t\ttotal += (-1*(in.nextInt() - 1 - in.nextInt() + 1) + 1) / 2;\n\t\t\tSystem.out.println(total%2 == 0 ? \"even\" : \"odd\");\n\t\t}\n\t}\n\t\n\tpublic static void query(int[] ar, int[] memo, int a, int b) {\n\t\tif (a >= b) {\n\t\t\treturn;\n\t\t}\n\t\tif (ar[a] < ar[b]) {\n\t\t\tmemo[a]++;\n\t\t\ttotal++;\n\t\t} else {\n\t\t\tmemo[b]--;\n\t\t\ttotal--;\n\t\t}\n\t\tint t = ar[a];\n\t\tar[b] = ar[a];\n\t\tar[b] = t;\n\t\tt = memo[a];\n\t\tmemo[b] = memo[a];\n\t\tmemo[b] = t;\n\t\tquery(ar, memo, a + 1, b - 1);\n\t}\n\t\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;\n\npublic class a {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tdouble w = in.nextDouble();\n\t\tint tot = 2;\n\t\tInterval[] houses = new Interval[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tdouble center = in.nextDouble();\n\t\t\tdouble wid = in.nextDouble();\n\t\t\thouses[i] = new Interval(center-wid/2,center+wid/2);\n\t\t}\n\t\tArrays.sort(houses);\n\t\tfor(int i=1; i<n; i++) {\n\t\t\tdouble dist = houses[i].s - houses[i-1].e;\n\t\t\tif(dist+1e-6 >= w) {\n\t\t\t\ttot+=2;\n\t\t\t\tif(Math.abs(w-dist) < 1e-6)\n\t\t\t\t\ttot--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(tot);\n\t}\n}\nclass Interval implements Comparable<Interval> {\n\tdouble s, e;\n\tInterval(double a, double b) {\n\t\ts=a;\n\t\te=b;\n\t}\n\tpublic int compareTo(Interval i) {\n\t\treturn (int)Math.signum(s-i.s);\n\t}\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "/**\n * JUDGE_ID : 104262PN\n * User     : \u0414\u0435\u043d\u0438\u0441\n * Date     : 09.05.11\n * Time     : 22:48\n * ICQ      : 785625\n * Email    : popokus@gmail.com\n */\n\nimport java.io.*;\n\npublic class s11_d {\n    public static void main(String[] args) throws IOException {\n        new s11_d().run();\n    }\n\n    int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    String nextString() throws IOException {\n        in.nextToken();\n        return (String) in.sval;\n    }\n\n    StreamTokenizer in;\n    Writer writer;\n    Reader reader;\n\n    void run() throws IOException {\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        reader = oj ? new InputStreamReader(System.in, \"ISO-8859-1\") : new FileReader(\"input/is11_d.txt\");\n        writer = new OutputStreamWriter(System.out, \"ISO-8859-1\");\n        in = new StreamTokenizer(new BufferedReader(reader));\n        PrintWriter out = new PrintWriter(writer);\n        int n = nextInt();\n        int e = nextInt();\n        boolean[][] is = new boolean[n + 1][n + 1];\n        for (int i = 0; i < e;i++) {\n            int a = nextInt() - 1;\n            int b = nextInt() - 1;\n            is[a][b] = true;\n            is[b][a] = true;\n        }\n        // calculating dp\n        long[] am = new long[n + 1];\n                long[][] ways = new long[1 << (n - 1)][n];\n                for (int start = 0; start < n; ++start) {\n                    for (int mask = 0; mask < (1 << (n - start - 1)); ++mask)\n                        for (int last = start; last < n; ++last) {\n                            ways[mask][last - start] = 0;\n                        }\n                    ways[1 >> 1][0] = 1;\n                    for (int mask = 1; mask < (1 << (n - start)); mask += 2) {\n                        int cnt = 0;\n                        int tmp = mask;\n                        while (tmp > 0) {\n                            ++cnt;\n                            tmp = tmp & (tmp - 1);\n                        }\n                        for (int last = start; last < n; ++last)\n                            if (ways[mask >> 1][last - start] > 0) {\n                                long amm = ways[mask >> 1][last - start];\n                                for (int i = start; i < n; ++i)\n                                    if ((mask & (1 << (i - start))) == 0 && is[last][i]) {\n                                        ways[(mask | (1 << (i - start))) >> 1][i - start] += amm;\n                                    }\n                                if (is[last][start])\n                                    am[cnt] += ways[mask >> 1][last - start];\n                            }\n                    }\n                }\n                long res = 0;\n                for (int cnt = 3; cnt <= n; ++cnt) {\n                    if (am[cnt] % (2) != 0)\n                        throw new RuntimeException();\n                    res += am[cnt] / (2);\n                }\n        out.println(res);\n        out.flush();\n        out.close();\n    }\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.*;\n\nimport java.awt.geom.Point2D;\nimport java.text.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\n\tfinal String filename = \"\";\n\n\tpublic int nextPerm(int[] a, int k) {\n\t\tif (a[0] == k)\n\t\t\treturn -1;\n\t\tint last = 0;\n\t\tfor (int i = a.length - 1; i >= 0; i--)\n\t\t\tif (a[i] != 0) {\n\t\t\t\tlast = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tint mem=a[last];\n\t\ta[last-1]++;\n\t\ta[last]=0;\n\t\ta[a.length-1]=mem-1;\n\t\treturn 0;\n\t}\n\t\n\tpublic double poss(int A,int[][] sen,int[] rasp){\n\t\tint n=sen.length;\n\t\tdouble[] possluck=new double[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpossluck[i]=Math.min(100, sen[i][1]+rasp[i]*10)/100.0;\n\t\tdouble poss=0;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tint kol=0;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tif((i%(1<<(j+1)))/(1<<(j))==1)\n\t\t\t\t\tkol++;\n\t\t\tdouble thisposs=1;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tif((i%(1<<(j+1)))/(1<<(j))==1)\n\t\t\t\t\tthisposs*=possluck[j];\n\t\t\t\telse\n\t\t\t\t\tthisposs*=(1-possluck[j]);\n\t\t\tif(kol>n/2)\n\t\t\t\tposs+=thisposs;\n\t\t\telse{\n\t\t\t\tdouble lvl=0;\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tif((i%(1<<(j+1)))/(1<<(j))==0)\n\t\t\t\t\t\tlvl+=sen[j][0];\n\t\t\t\tposs+=thisposs*(A/(A+lvl));\n\t\t\t}\n\t\t}\n\t\treturn poss;\n\t}\n\n\tpublic void solve() throws Exception {\n\t\tint n = iread(), k = iread(), A = iread();\n\t\tint[][] sen = new int[n][2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsen[i][0] = iread();\n\t\t\tsen[i][1] = iread();\n\t\t}\n\t\tdouble maxposs=0;\n\t\tint[] rasp=new int[n];\n\t\trasp[n-1]=k;\n\t\tmaxposs=Math.max(maxposs, poss(A,sen,rasp));\n\t\twhile(nextPerm(rasp,k)==0)\n\t\t\tmaxposs=Math.max(maxposs, poss(A,sen,rasp));\n\t\tout.write(maxposs+\"\\n\");\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t\t// in = new BufferedReader(new FileReader(filename+\".in\"));\n\t\t\t// out = new BufferedWriter(new FileWriter(filename+\".out\"));\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tpublic int iread() throws Exception {\n\t\treturn Integer.parseInt(readword());\n\t}\n\n\tpublic double dread() throws Exception {\n\t\treturn Double.parseDouble(readword());\n\t}\n\n\tpublic long lread() throws Exception {\n\t\treturn Long.parseLong(readword());\n\t}\n\n\tBufferedReader in;\n\n\tBufferedWriter out;\n\n\tpublic String readword() throws IOException {\n\t\tStringBuilder b = new StringBuilder();\n\t\tint c;\n\t\tc = in.read();\n\t\twhile (c >= 0 && c <= ' ')\n\t\t\tc = in.read();\n\t\tif (c < 0)\n\t\t\treturn \"\";\n\t\twhile (c > ' ') {\n\t\t\tb.append((char) c);\n\t\t\tc = in.read();\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.US);\n\t\t} catch (Exception e) {\n\n\t\t}\n\t\t// new Thread(new Main()).start();\n\t\tnew Thread(null, new Main(), \"1\", 1 << 25).start();\n\t}\n}", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import javax.naming.PartialResultException;\nimport java.util.*;\n\nimport static java.util.Arrays.binarySearch;\n\npublic class codechef {\n    private static Scanner sc = new Scanner(System.in);\n    private static int hit = 0;\n    private static int[] f = new int[10000002];\n\n    public static void main(String[] args) {\n        int i;\n        f[0] = 0;\n        f[1] = 1;\n        for (i = 2; i < f.length; i++)\n            f[i] = f[i - 1] + f[i - 2];\n//        int t = 0;\n//        if (sc.hasNext())\n//            t = sc.nextInt();\n//        for (int i = 1; i <= t; i++) {\n        solve();\n//        }\n    }\n\n    public static void solve() {\n        int n = sc.nextInt();\n        if (n==0){\n            System.out.println(\"0 0 0\");\n            return;\n        }\n        if (n==1){\n            System.out.println(\"0 0 1\");\n            return;\n        }\n        int index = -1;\n        for (int j = 0; j < f.length; j++) {\n            if (f[j] == n) {\n                index = j;\n                break;\n            }\n        }\n        System.out.println(\"0 \" + f[index - 1] + \" \" + f[index - 2]);\n    }\n}", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\n/*\n * Raudel Ravelo Suarez\n * Problem: \n */\n\npublic class C \n{\n\tScanner sc;\n\tBufferedReader in;\n\tPrintStream out;\n\tStringTokenizer tok;\n\t\n\tpublic C() throws NumberFormatException, IOException\n\t{\n\t\t//sc = new Scanner(System.in);\n\t\t//sc = new Scanner(new FileReader(\"in.txt\"));\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t//in = new BufferedReader(new FileReader(\"in.txt\"));\n\t\tout = System.out;\n\t\trun();\n\t}\n\tvoid run() throws NumberFormatException, IOException\n\t{\n\t\t//Add your code here\n\t\tint[] array;\n\t\tint n = nextInt();\n\t\tarray = new int[n];\n\t\tint max = 0;\n\t\tint pos = 0;\n\t\tfor(int i = 0; i <n; i++)\n\t\t{\n\t\t\tint l = nextInt();\n\t\t\tif(l > max)\n\t\t\t{\n\t\t\t\tpos = i;\n\t\t\t\tmax = l;\n\t\t\t}\n\t\t\tarray[i] = l;\n\t\t}\n\t\tif(max == 1)array[pos] = 2;\n\t\telse array [pos] = 1;\n\t\tArrays.sort(array);\n\t\tout.print(array[0]);\n\t\tfor(int i = 1; i < n; i++)\n\t\t\tout.print(\" \" + array[i]);\n\t\tout.println();\n\t}\n\tpublic static void main(String[] args) throws NumberFormatException, IOException \n\t{\n\t\tnew C();\n\t}\n\tString nextToken() throws IOException\n\t{\n\t\tif(tok ==null || !tok.hasMoreTokens()) tok = new StringTokenizer(in.readLine());\n\t\treturn tok.nextToken();\n\t}\n\tint nextInt() throws NumberFormatException, IOException\n\t{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tlong nextLong() throws NumberFormatException, IOException\n\t{\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tdouble nextDouble() throws NumberFormatException, IOException\n\t{\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Contest {\n\n\tstatic final Random random = new Random();\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long[] p;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt(), q = sc.nextInt();\n\n\t\tlong[] a = new long[n];\n\t\tp = new long[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextLong();\n\t\t\tp[i] = a[i];\n\t\t\tif (i != 0)\n\t\t\t\tp[i] += p[i - 1];\n\t\t}\n\t\tint l = 0, r = n - 1;\n\t\tlong arrows_left = 0;\n\t\tint soldiers = n;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tlong ki = sc.nextLong() + arrows_left;\n\t\t\tint bs = bs(l, r, ki);\n\n\t\t\tif (bs == n - 1) {\n\t\t\t\tout.println(n);\n\t\t\t\tsoldiers = n;\n\t\t\t\tarrows_left = 0;\n\t\t\t\tl = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (bs == -1) {\n\t\t\t\tout.println(soldiers);\n\t\t\t\tarrows_left = ki;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlong sub = 0;\n\n\t\t\tif (l != 0)\n\t\t\t\tsub = p[l - 1];\n\n\t\t\tarrows_left = (ki - (p[bs] - sub));\n\n\t\t\tl = bs + 1;\n\n\t\t\tsoldiers = n - (bs + 1);\n\t\t\tout.println(n - (bs + 1));\n\t\t}\n\n\t\tout.flush();\n\t}\n\n\tstatic int bs(int l, int r, long x) {\n\t\tint ans = -1;\n\t\tint L = l;\n\t\twhile (l <= r) {\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\tlong cmp = p[mid];\n\t\t\tif (L != 0)\n\t\t\t\tcmp -= p[L - 1];\n\t\t\tif (cmp <= x) {\n\t\t\t\tans = mid;\n\t\t\t\tl = mid + 1;\n\t\t\t} else\n\t\t\t\tr = mid - 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic void Arrayssort(int[] a) {\n\t\tint n = a.length;// shuffle, then sort\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint oi = random.nextInt(n);\n\t\t\tint temp = a[oi];\n\t\t\ta[oi] = a[i];\n\t\t\ta[i] = temp;\n\t\t}\n\t\tjava.util.Arrays.sort(a);\n\t}\n\n\tprivate static class Scanner {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer st;\n\n\t\tpublic Scanner(InputStream file) throws FileNotFoundException {\n\t\t\treader = new BufferedReader(new InputStreamReader(file));\n\t\t\tst = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString line = reader.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow (new RuntimeException());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn reader.readLine();\n\t\t}\n\t}\n\n}", "complexity": "nlogn", "problem": "0975_C", "from": "CODEFORCES", "tags": "binary search"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer st;\n\n    int[] x;\n    int[] y;\n    int n;\n    int X, Y;\n\n    int[] d;\n    int[][] dist;\n\n    int sqr(int a) {\n        return a * a;\n    }\n\n    int dist(int X, int Y, int i) {\n        return sqr(X - x[i]) + sqr(Y - y[i]);\n    }\n\n    int[] dp;\n    byte[][] pred;\n\n    int rec(int mask) {\n        if (dp[mask] == -1) {\n            int res = 1 << 29;\n            boolean ok = false;\n            for (int i = 0; i < n; ++i)\n                if ((mask & (1 << i)) > 0) {\n                    ok = true;\n                    int mm = mask & ~(1 << i);\n                    for (int j = i; j < n; j++)\n                        if ((mask & (1 << j)) > 0) {\n                            int nmask = mm & ~(1 << j);\n                            int a = rec(nmask) + d[i] + d[j] + dist[i][j];\n                            if (a < res) {\n                                res = a;\n                                pred[0][mask] = (byte) (i);\n                                pred[1][mask] = (byte) (j);\n                            }\n                        }\n                    break;\n                }\n            if (!ok)\n                res = 0;\n            dp[mask] = res;\n        }\n        return dp[mask];\n    }\n\n    void solve() throws IOException {\n        X = ni();\n        Y = ni();\n        n = ni();\n        // if (n > 5)\n        // return;\n        x = new int[n];\n        y = new int[n];\n        for (int i = 0; i < n; i++) {\n            x[i] = ni();\n            y[i] = ni();\n        }\n        d = new int[n];\n        dist = new int[n][n];\n        for (int i = 0; i < n; ++i)\n            d[i] = dist(X, Y, i);\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = dist(x[i], y[i], j);\n            }\n        pred = new byte[2][1 << n];\n        dp = new int[1 << n];\n        Arrays.fill(dp, -1);\n        out.println(rec((1 << n) - 1));\n        int a = (1 << n) - 1;\n        while (a > 0) {\n            if (pred[0][a] != pred[1][a])\n                out.print(0 + \" \" + (pred[0][a] + 1) + \" \" + (pred[1][a] + 1)\n                        + \" \");\n            else\n                out.print(0 + \" \" + (pred[0][a] + 1) + \" \");\n            int na = a & ~(1 << pred[0][a]);\n            na &= ~(1 << pred[1][a]);\n            a = na;\n        }\n        out.println(0);\n    }\n\n    public Solution() throws IOException {\n        Locale.setDefault(Locale.US);\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        in.close();\n        out.close();\n    }\n\n    String ns() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.valueOf(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.valueOf(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.valueOf(ns());\n    }\n\n    public static void main(String[] args) throws IOException,\n            InterruptedException {\n        Thread th = new Thread(null, new Solution(), \"\", 536870912);\n        th.start();\n        th.join();\n    }\n\n    @Override\n    public void run() {\n        try {\n            Locale.setDefault(Locale.US);\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n            solve();\n            in.close();\n            out.close();\n        } catch (Exception e) {\n            // TODO: handle exception\n        }\n    }\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.util.Scanner;\n\npublic class Codeforces_978B {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int t = 0;\n        String fileName = in.next().toLowerCase();\n        for (int i = 0; i < n; i++) {\n            if (i + 2 <= n - 1) {\n                if(fileName.charAt(i) == 'x' && fileName.charAt(i + 1) == 'x' && fileName.charAt(i + 2) == 'x') t++;\n            }\n        }\n        System.out.println(t);\n    }\n}\n", "complexity": "linear", "problem": "0978_B", "from": "CODEFORCES", "tags": "greedy,strings"}
{"src": "//stan hu tao\n//join nct ridin by first year culture reps\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class x1209E\n{\n    public static void main(String hi[]) throws Exception\n    {\n        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(infile.readLine());\n        int T = Integer.parseInt(st.nextToken());\n        StringBuilder sb = new StringBuilder();\n        while(T-->0)\n        {\n            st = new StringTokenizer(infile.readLine());\n            int N = Integer.parseInt(st.nextToken());\n            int M = Integer.parseInt(st.nextToken());\n            int[][] grid = new int[N][M];\n            for(int r=0; r < N; r++)\n                grid[r] = readArr(M, infile, st);\n            ArrayList<Integer> ls = new ArrayList<Integer>();\n            for(int i=0; i < M; i++)\n                ls.add(i);\n            Collections.sort(ls, (x,y) -> {\n                int m1 = grid[0][x];\n                int m2 = grid[0][y];\n                for(int r=1; r < N; r++)\n                {\n                    m1 = max(m1, grid[r][x]);\n                    m2 = max(m2, grid[r][y]);\n                }\n                return m2-m1;\n            });\n            int[][] newgrid = new int[N][M];\n            for(int r=0; r < N; r++)\n                for(int c=0; c < M; c++)\n                    newgrid[r][c] = grid[r][ls.get(c)];\n            M = min(M, N);\n            int[][] sums = new int[M][1<<N];\n            for(int i=1; i < M; i++)\n                for(int mask=0; mask < 1<<N; mask++)\n                {\n                    //try all shifts\n                    for(int head=0; head < N; head++)\n                    {\n                        int temp = 0;\n                        for(int b=0; b < N; b++)\n                        {\n                            int nb = b+head;\n                            if(nb >= N)\n                                nb -= N;\n                            if((mask&(1<<nb)) > 0)\n                                temp += newgrid[b][i];\n                        }\n                        sums[i][mask] = max(sums[i][mask], temp);\n                    }\n                }\n            int[][] dp = new int[M][1<<N];\n            for(int mask=0; mask < 1<<N; mask++)\n                for(int b=0; b < N; b++)\n                    if((mask&(1<<b)) > 0)\n                        dp[0][mask] += newgrid[b][0];\n            for(int i=1; i < M; i++)\n                for(int mask=0; mask < 1<<N; mask++)\n                    for(int pmask=mask; pmask >= 0; pmask=(pmask-1)&mask)\n                    {\n                        dp[i][mask] = max(dp[i][mask], dp[i-1][pmask]+sums[i][mask-pmask]);\n                        if(pmask == 0)\n                            break;\n                    }\n            sb.append(dp[M-1][(1<<N)-1]+\"\\n\");\n        }\n        System.out.print(sb);\n    }\n    public static int[] readArr(int N, BufferedReader infile, StringTokenizer st) throws Exception\n    {\n        int[] arr = new int[N];\n        st = new StringTokenizer(infile.readLine());\n        for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n        return arr;\n    }\n}", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.util.*;\n\nimport java.io.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\n\tlong mod1 = (long) 1e9 + 7;\n\tint mod2 = 998244353;\n\tint subtree[];\n\tArrayList<ArrayList<Integer>> a;\n\t\n\n\tpublic void solve() throws Exception {\n\t\tint n=sc.nextInt();\n\t\tprint(n);\n\t\tprint1(n);\n\t\t\n\t\t\n\n\t}\n\tpublic void print(int n) {\n\t\tif(n<6) { out.println(-1); return; }\n\t\tout.println(1+\" \"+2);\n\t\tout.println(1+\" \"+3);\n\t\tout.println(1+\" \"+4);\n\t\tfor(int i=5;i<=n;i++) {\n\t\t\tout.println(4+\" \"+i);\n\t\t}\n\t}\n\tpublic void print1(int n) {\n\t\tfor(int i=n;i>1;i--) {\n\t\t\tout.println(i+\" \"+(i-1));\n\t\t}\n\t}\n\t\tstatic long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n\t}\n\n\tstatic long ncr(int n, int r, long p) {\n\t\tif (r > n)\n\t\t\treturn 0l;\n\t\tif (r > n - r)\n\t\t\tr = n - r;\n\n\t\tlong C[] = new long[r + 1];\n\n\t\tC[0] = 1;\n\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\tfor (int j = Math.min(i, r); j > 0; j--)\n\t\t\t\tC[j] = (C[j] + C[j - 1]) % p;\n\t\t}\n\t\treturn C[r] % p;\n\t}\n\n\tvoid sieveOfEratosthenes(boolean prime[], int size) {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tprime[i] = true;\n\n\t\tfor (int p = 2; p * p < size; p++) {\n\t\t\tif (prime[p] == true) {\n\t\t\t\tfor (int i = p * p; i < size; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int LowerBound(int a[], int x) { // smallest index having value >= x\n\t\tint l = -1, r = a.length;\n\t\twhile (l + 1 < r) {\n\t\t\tint m = (l + r) >>> 1;\n\t\t\tif (a[m] >= x)\n\t\t\t\tr = m;\n\t\t\telse\n\t\t\t\tl = m;\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int UpperBound(int a[], int x) {// biggest index having value <= x\n\t\tint l = -1, r = a.length;\n\t\twhile (l + 1 < r) {\n\t\t\tint m = (l + r) >>> 1;\n\t\t\tif (a[m] <= x)\n\t\t\t\tl = m;\n\t\t\telse\n\t\t\t\tr = m;\n\t\t}\n\t\treturn l + 1;\n\t}\n\n\tpublic long power(long x, long y, long p) {\n\t\tlong res = 1;\n\t\t// out.println(x+\" \"+y);\n\t\tx = x % p;\n\t\tif (x == 0)\n\t\t\treturn 0;\n\n\t\twhile (y > 0) {\n\t\t\tif ((y & 1) == 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\ty = y >> 1;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic Throwable uncaught;\n\n\tBufferedReader in;\n\tFastScanner sc;\n\tPrintWriter out;\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsc = new FastScanner(in);\n\t\t\tsolve();\n\t\t} catch (Throwable uncaught) {\n\t\t\tSolution.uncaught = uncaught;\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Throwable {\n\t\tThread thread = new Thread(null, new Solution(), \"\", (1 << 26));\n\t\tthread.start();\n\t\tthread.join();\n\t\tif (Solution.uncaught != null) {\n\t\t\tthrow Solution.uncaught;\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\n\tpublic FastScanner(BufferedReader in) {\n\t\tthis.in = in;\n\t}\n\n\tpublic String nextToken() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic int[] readArray(int n) throws Exception {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n}", "complexity": "linear", "problem": "0959_C", "from": "CODEFORCES", "tags": "constructive algorithms,trees"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Vaibhav Pulastya\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BSportMafia solver = new BSportMafia();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BSportMafia {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long n = in.nextInt();\n            long k = in.nextInt();\n            long d = 9 + 4 * (2 * n + 2 * k);\n            double smh = Math.sqrt(d);\n            double ans = (-3 + smh) / 2;\n            out.println(n - (int) ans);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "//    A Computer is Like a mischievous genie.\n//    It will give you exactly what you ask for,\n//    but not always what you want\n//    A code by Rahul Verma\n\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.Spliterator.OfPrimitive;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n\npublic class Main {\n\n\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n    static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String[] nextSArray() {\n            String sr[] = null;\n            try {\n                sr = br.readLine().trim().split(\" \");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return sr;\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            return str;\n        }\n    }\n\n\n    static long powmodulo(long a, long p) {\n        if (p == 0) {\n            return 1 % mod;\n        }\n        if (p == 1) {\n            return a % mod;\n        }\n        long ans = 1;\n        while (p > 0) {\n            if ((p & 1) > 0) {\n                ans = (ans * a) % mod;\n            }\n            a = (a * a) % mod;\n            p = p >> 1;\n        }\n        return ans % mod;\n    }\n\n\n    static long mod = 1000000007;\n\n    static long gcd(long a, long b) {\n        if (a == 0) {\n            return b;\n        }\n        return gcd(b % a, a);\n    }\n\n    static long fast_powerNumbers(long a, long n) {\n        if (n == 1) {\n            return a;\n        }\n        long ans = fast_powerNumbers(a, n / 2);\n        if (n % 2 == 0) {\n            return (ans * ans);\n        } else {\n            return ((ans * ans) * (a));\n        }\n    }\n\n\n    static void dfs_helper(int[][] arr, int i, int j, int team, int n, int m) {\n        arr[i][j] = team;\n        if (i - 1 >= 0 && arr[i - 1][j] == 1) {\n            dfs(arr, i - 1, j, team, n, m);\n        }\n        if (j - 1 >= 0 && arr[i][j - 1] == 1) {\n            dfs(arr, i, j - 1, team, n, m);\n        }\n        if (i + 1 < n && arr[i + 1][j] == 1) {\n            dfs(arr, i + 1, j, team, n, m);\n        }\n        if (j + 1 < m && arr[i][j + 1] == 1) {\n            dfs(arr, i, j + 1, team, n, m);\n        }\n\n    }\n\n    static void dfs(int[][] arr, int i, int j, int team, int n, int m) {\n        dfs_helper(arr, i, j, team, n, m);\n\n    }\n\n    static int parent[];\n    static int rank[];\n\n    static int find(int i) {\n        if (parent[i] == -1) {\n            parent[i] = i;\n            return i;\n        }\n\n        if (parent[i] == i) {\n            return i;\n        } else {\n            parent[i] = find(parent[i]);\n        }\n        return parent[i];\n\n    }\n\n    static void unite(int s1, int s2) {\n\n        if (rank[s1] > rank[s2]) {\n            parent[s2] = s1;\n            rank[s1] += rank[s2];\n        } else {\n            parent[s1] = s2;\n            rank[s2] += rank[s1];\n        }\n    }\n\n\n    static int arr[];\n\n    static void seive(int n) {\n        arr = new int[n + 1];\n        arr[0] = arr[1] = 1;\n        for (int i = 4; i <= n; i = i + 2) {\n            arr[i] = 1;\n        }\n        for (int i = 3; i * i <= n; i = i + 2) {\n            if (arr[i] == 0) {\n                for (int j = i * i; j <= n; j = j + i) {\n                    arr[j] = 1;\n                }\n\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        FastReader sc = new FastReader();\n\n//        int t = sc.nextInt();\n//        for (int t1 = 0; t1 < t; t1++) {\n//\n//        }\n//        out.close();\n\n        int n=sc.nextInt();\n        long m=sc.nextLong();\n        long arr[]=new long[n];\n        long max=0;\n        long sum=0;\n        for (int i = 0; i <n ; i++) {\n            arr[i]=sc.nextLong();\n            max=Math.max(arr[i],max);\n\n        }\n        Arrays.sort(arr);\n        long h=0;\n        long rem=0;\n        for (int i = 0; i <n-1; i++) {\n\n            if(arr[i]>=h+1)\n            {\n                ++h;\n            }\n            rem+=arr[i]-1;\n\n        }\n        rem+=arr[n-1]-Math.max(1,arr[n-1]-h);\n        System.out.println(rem);\n\n    }\n}\n\n\nclass Pair {\n\n    int a;\n    int b;\n\n    Pair(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n}\n\n\nclass Graph {\n\n    HashMap<Integer, ArrayList<Integer>> hm;\n\n    Graph() {\n        hm = new HashMap<>();\n    }\n\n    Graph(int n) {\n\n        hm = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            hm.put(i, new ArrayList<Integer>());\n        }\n    }\n\n    // function for adding an edge.................................................\n    public void addEdge(int a, int b, boolean isDir) {\n        if (isDir) {\n            if (hm.containsKey(a)) {\n                hm.get(a).add(b);\n            } else {\n                hm.put(a, new ArrayList<>(Arrays.asList(b)));\n            }\n        } else {\n            if (hm.containsKey(a)) {\n                hm.get(a).add(b);\n            } else if (!hm.containsKey(a)) {\n                hm.put(a, new ArrayList<>(Arrays.asList(b)));\n            }\n\n            if (hm.containsKey(b)) {\n                hm.get(b).add(a);\n            } else if (!hm.containsKey(b)) {\n                hm.put(b, new ArrayList<>(Arrays.asList(a)));\n            }\n        }\n    }\n\n\n}\n\n// out.println(al.toString().replaceAll(\"[\\\\[|\\\\]|,]\",\"\"));\n\n", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author Andrew Porokhin, andrew.porokhin@gmail.com\n */\npublic class Problem111A implements Runnable {\n    void solve() throws NumberFormatException, IOException {\n        // TODO: Write your code here ...\n        final int n = nextInt();\n        final int[] a = new int[n];\n        \n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            final int nextInt = nextInt();\n            sum += nextInt;\n            a[i] = nextInt;\n        }\n\n        Arrays.sort(a);\n        int currSum = 0;\n        int maxCoins = 0;\n        for (int j = a.length - 1; j >= 0; j--) {\n            currSum += a[j];\n            maxCoins++;\n            if (sum - currSum < currSum) {\n                break;\n            }\n        }\n        System.out.println(maxCoins);\n    }\n\n    StringTokenizer st;\n    BufferedReader in;\n    PrintWriter out;\n\n    public static void main(String[] args) {\n        // Introduce thread in order to increase stack size\n        new Problem111A().run();\n    }\n\n    public void run() {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n            solve();\n        } catch (Exception e) {\n            System.exit(9000);\n        } finally {\n            out.flush();\n            out.close();\n        }\n    }\n\n    String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws NumberFormatException, IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(nextToken());\n    }\n}\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.util.Scanner;\n\n\npublic class A_IQTest {\n\n    static int n;\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        n = s.nextInt();\n        \n        int[] nums = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            nums[i] = s.nextInt();\n        }\n        \n        \n        int ei = -1;\n        int oi = -1;\n        int ecnt = 0;\n        int ocnt = 0;\n        for (int i = 0; i < n; i++) {\n            if(nums[i] % 2 == 0){\n                ei = i;\n                ecnt++;\n            }else{\n                oi = i;\n                ocnt++;\n            }\n        }\n        if(ecnt == 1){\n            System.out.println(ei+1);\n        }else{\n            System.out.println(oi+1);\n        }\n    }\n\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n    protected static final double EPS = 1e-11;\n    private static StreamTokenizer in;\n    private static Scanner ins;\n    private static PrintWriter out;\n    protected static final Double[] BAD = new Double[]{null, null};\n    private boolean[][] layouts;\n    private int c;\n    private int b;\n    private int a;\n    private String word;\n\n    public static void main(String[] args) {\n\n        try {\n            in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n            ins = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n            out = new PrintWriter(System.out);\n            try {\n                if (System.getProperty(\"xDx\") != null) {\n                    in = new StreamTokenizer(new BufferedReader(new FileReader(\"input.txt\")));\n                    ins = new Scanner(new FileReader(\"input.txt\"));\n                    out = new PrintWriter(new FileWriter(\"output.txt\"));\n                }\n            } catch (Exception e) {\n                in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n                ins = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n                out = new PrintWriter(System.out);\n            }\n            new Main().run();\n        } catch (Throwable e) {\n//            e.printStackTrace();\n            throw new RuntimeException(e);\n        } finally {\n            out.close();\n        }\n    }\n\n    private int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    private long nextLong() throws IOException {\n        in.nextToken();\n        return (long) in.nval;\n    }\n\n    private double nextDouble() throws IOException {\n        in.nextToken();\n        return in.nval;\n    }\n\n    private String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    private char nextChar() throws IOException {\n        in.nextToken();\n        return (char) in.ttype;\n    }\n\n    private void run() throws Exception {\n        /*int t = nextInt();\n        for (int i = 0; i < t; i++) {\n            out.printf(Locale.US, \"Case #%d: %d\\n\", i + 1, solve());\n        }*/\n        solve();\n    }\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n\n        Map<Long, Integer> map = new HashMap<>();\n\n        BigInteger res = BigInteger.ZERO;\n        long sum = 0;\n        long amount = 0;\n\n        for (int i = n - 1; i >= 0; i--) {\n            long cur = a[i];\n            Pair same = getZeroAmount(cur, map);\n\n            res = res.add(BigInteger.valueOf((sum - same.sum) - cur * (amount - same.amount)));\n            amount++;\n            sum += cur;\n            map.put(cur, map.getOrDefault(cur, 0) + 1);\n        }\n\n        out.println(res);\n    }\n\n    class Pair {\n        long amount;\n        long sum;\n\n        public Pair(long amount, long sum) {\n            this.amount = amount;\n            this.sum = sum;\n        }\n    }\n\n    private Pair getZeroAmount(long cur, Map<Long, Integer> map) {\n        long amount = 0;\n        long sum = 0;\n        for (long i = cur - 1; i <= cur + 1; i++) {\n            long amountI = map.getOrDefault(i, 0);\n            amount += amountI;\n            sum += amountI * i;\n        }\n        return new Pair(amount, sum);\n    }\n\n    private List<Integer> iterate(List<Integer> a) {\n        ArrayList<Integer> b = new ArrayList<>();\n        int prev = -1;\n        for (int x : a) {\n            if (x == prev) {\n                b.add(x);\n            } else {\n                prev = x;\n            }\n        }\n        return b;\n    }\n\n    private long gcd(long a, long b) {\n        while (a > 0 && b > 0) {\n            long k = a % b;\n            a = b;\n            b = k;\n        }\n\n        return a | b;\n    }\n\n}", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class B {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    \n    public static void sort(int arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(int arr[],int l1,int r1,int l2,int r2) {\n        int tmp[]=new int[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void sort(long arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(long arr[],int l1,int r1,int l2,int r2) {\n        long tmp[]=new long[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        StringBuilder ans=new StringBuilder(\"\");\n        int test=input.scanInt();\n//        boolean sq[]=new boolean[1000000005];\n//        for(int i=1;i*i<sq.length;i++) {\n//            sq[i*i]=true;\n//        }\n        for(int tt=1;tt<=test;tt++) {\n            int n=input.scanInt();\n            if(n%2==1) {\n                ans.append(\"NO\\n\");\n                continue;\n            }\n            n/=2;\n            double sq=Math.sqrt(n);\n            if(Math.floor(sq)==Math.ceil(sq)) {\n                ans.append(\"YES\\n\");\n                continue;\n            }\n            if(n%2==1) {\n                ans.append(\"NO\\n\");\n                continue;\n            }\n            n/=2;\n            sq=Math.sqrt(n);\n            if(Math.floor(sq)==Math.ceil(sq)) {\n                ans.append(\"YES\\n\");\n                continue;\n            }\n            ans.append(\"NO\\n\");\n        }\n        System.out.println(ans);\n    }\n}\n", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Washoum\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        inputClass in = new inputClass(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        G1PlaylistForPolycarpEasyVersion solver = new G1PlaylistForPolycarpEasyVersion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class G1PlaylistForPolycarpEasyVersion {\n        static final int mod = (int) 1e9 + 7;\n\n        public void solve(int testNumber, inputClass sc, PrintWriter out) {\n            int n = sc.nextInt();\n            int t = sc.nextInt();\n            G1PlaylistForPolycarpEasyVersion.Song[] songs = new G1PlaylistForPolycarpEasyVersion.Song[n];\n            for (int i = 0; i < n; i++) {\n                songs[i] = new G1PlaylistForPolycarpEasyVersion.Song(sc.nextInt(), sc.nextInt());\n            }\n            long ans = 0;\n            for (int mask = 1; mask < (1 << n); mask++) {\n                int nb = 0;\n                int tot = 0;\n                int type1 = 0;\n                int type2 = 0;\n                int type3 = 0;\n                for (int j = 0; j < n; j++) {\n                    if (((1 << j) & mask) > 0) {\n                        nb++;\n                        tot += songs[j].l;\n                        if (songs[j].type == 1) {\n                            type1++;\n                        } else if (songs[j].type == 2) {\n                            type2++;\n                        } else {\n                            type3++;\n                        }\n                    }\n                }\n\n                if (tot == t) {\n                    long[][][][][] dp = new long[nb + 1][3][type1 + 1][type2 + 1][type3 + 1];\n                    boolean[][][][][] go = new boolean[nb + 1][3][type1 + 1][type2 + 1][type3 + 1];\n                    if (type1 > 0) {\n                        go[1][0][type1 - 1][type2][type3] = true;\n                        dp[1][0][type1 - 1][type2][type3] = type1;\n                    }\n                    if (type2 > 0) {\n                        go[1][1][type1][type2 - 1][type3] = true;\n                        dp[1][1][type1][type2 - 1][type3] = type2;\n                    }\n                    if (type3 > 0) {\n                        go[1][2][type1][type2][type3 - 1] = true;\n                        dp[1][2][type1][type2][type3 - 1] = type3;\n                    }\n                    for (int i = 0; i < nb; i++) {\n                        for (int m = 0; m < 3; m++) {\n                            for (int j = 0; j <= type1; j++) {\n                                for (int k = 0; k <= type2; k++) {\n                                    for (int l = 0; l <= type3; l++) {\n                                        if (go[i][m][j][k][l]) {\n                                            if (m == 0) {\n                                                if (k > 0) {\n                                                    dp[i + 1][1][j][k - 1][l] += dp[i][m][j][k][l] * k;\n                                                    dp[i + 1][1][j][k - 1][l] %= mod;\n                                                    go[i + 1][1][j][k - 1][l] = true;\n                                                }\n                                                if (l > 0) {\n                                                    dp[i + 1][2][j][k][l - 1] += dp[i][m][j][k][l] * l;\n                                                    dp[i + 1][2][j][k][l - 1] %= mod;\n                                                    go[i + 1][2][j][k][l - 1] = true;\n                                                }\n                                            } else if (m == 1) {\n                                                if (j > 0) {\n                                                    dp[i + 1][0][j - 1][k][l] += dp[i][m][j][k][l] * j;\n                                                    dp[i + 1][0][j - 1][k][l] %= mod;\n                                                    go[i + 1][0][j - 1][k][l] = true;\n                                                }\n                                                if (l > 0) {\n                                                    dp[i + 1][2][j][k][l - 1] += dp[i][m][j][k][l] * l;\n                                                    dp[i + 1][2][j][k][l - 1] %= mod;\n                                                    go[i + 1][2][j][k][l - 1] = true;\n                                                }\n                                            } else {\n                                                if (j > 0) {\n                                                    dp[i + 1][0][j - 1][k][l] += dp[i][m][j][k][l] * j;\n                                                    dp[i + 1][0][j - 1][k][l] %= mod;\n                                                    go[i + 1][0][j - 1][k][l] = true;\n                                                }\n                                                if (k > 0) {\n                                                    dp[i + 1][1][j][k - 1][l] += dp[i][m][j][k][l] * k;\n                                                    dp[i + 1][1][j][k - 1][l] %= mod;\n                                                    go[i + 1][1][j][k - 1][l] = true;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    long toadd = 0;\n                    for (int i = 0; i < 3; i++) {\n                        toadd += dp[nb][i][0][0][0];\n                    }\n                    ans += toadd;\n                    ans %= (int) 1e9 + 7;\n                }\n            }\n            out.println(ans);\n        }\n\n        static class Song {\n            int l;\n            int type;\n\n            public Song(int x, int y) {\n                l = x;\n                type = y;\n            }\n\n        }\n\n    }\n\n    static class inputClass {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public inputClass(InputStream in) {\n\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.util.Scanner;\n\npublic class R495A {\n\tpublic static void main(String[] args) {\n\t\tScanner scan=new Scanner(System.in);\n\t\tint n=scan.nextInt(), k=scan.nextInt();\n\t\tint[] a=new int[n];\n\t\tfor(int i=0;i<n;i++) a[i]=scan.nextInt();\n\t\tint res=2;\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tif(a[i+1]-a[i]>2*k) res+=2;\n\t\t\telse if(a[i+1]-a[i]==2*k) res++;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n}", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\npublic class A23 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.next();\n\t\tMap<String, Boolean> map = new HashMap<String, Boolean>();\n\t\tfor (int i = s.length(); i >= 1; i--) {\n\t\t\tmap.clear();\n\t\t\tfor (int j = 0; j < s.length()-i+1; j++) {\n\t\t\t\tString temp = s.substring(j, j+i);\n\t\t\t\tif (map.containsKey(temp)) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmap.put(temp, true);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(0);\n\t}\n\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    \n    static final double EPS = 1E-6;\n    double a, v, l, d, w, u;\n    \n    public void run() {\n        a = cin.nextDouble();\n        v = cin.nextDouble();\n        l = cin.nextDouble();\n        d = cin.nextDouble();\n        w = cin.nextDouble();\n        w = Math.min(w, v);\n        double s1 = v * v / (2 * a);\n        double s2 = w * w / (2 * a);\n        double s3 = s1 - s2;\n        \n        double cost = 0;\n        if (d < s2) {\n            cost += Math.sqrt(2 * d / a);\n            w = cost * a;\n        } else if (d < s1 + s3) {\n            u = Math.sqrt(d / a + w * w / (2 * a * a)) * a;\n            cost = u / a + (u - w) / a;\n        } else {\n            cost += v / a;\n            cost += (v - w) / a;\n            cost += (d - s3 - s1) / v;\n        }\n        d = l - d;\n        s3 = (v * v - w * w) / (2 * a);\n        if (d < s3) {\n            cost += (-w + Math.sqrt(w * w + 2 * a * d)) / a;\n        } else {\n            cost += (v - w) / a;\n            cost += (d - s3) / v;\n        }\n        out.println(cost);\n    }\n\n    public static void main(String[] args) throws IOException {\n        Main sloved = new Main();\n        sloved.run();\n        sloved.out.close();\n    }\n\n    Scanner cin = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n}\n", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport static java.lang.Math.*;\nimport java.util.*;\nimport java.util.function.*;\nimport java.lang.*;\n\npublic class Main {\n    final static boolean debug = false;\n    final static String fileName = \"\";\n    final static boolean useFiles = false;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        long start;\n        if (debug)\n            start = System.nanoTime();\n        InputStream inputStream;\n        OutputStream outputStream;\n        if (useFiles) {\n            inputStream = new FileInputStream(fileName + \".in\");\n            outputStream = new FileOutputStream(fileName + \".out\");\n        } else {\n            inputStream = System.in;\n            outputStream = System.out;\n        }\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task(in, out);\n        solver.solve();\n        if(debug)\n            out.println((System.nanoTime() - start) / 1e+9);\n        out.close();\n    }\n}\nclass Task {\n    int[][] dist, pre;\n    int[] x, y, d, prev;\n    String[] leafDescription;\n    String[] linerDescription;\n    String[][] allDescriptions;\n    int xs, ys, n;\n\n    int dist(int i, int j) {\n        return (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n    }\n\n    void go(int[] prev, String[] leafDescription, int[] d, int len, int add, String description){\n        for (int mask = 0; mask < d.length; mask++) {\n            if ((mask & add) != add)\n                continue;\n            int newValue = d[mask & (~add)] + len;\n            if (d[mask] > newValue){\n                d[mask] = newValue;\n                leafDescription[mask] = description;\n                prev[mask] = mask & (~add);\n            }\n        }\n    }\n\n    int rec(int mask) {\n        if (d[mask] != -1)\n            return d[mask];\n        int lowest = 0;\n        for (; ((1 << lowest) & mask) == 0; lowest++) ;\n\n        int newMask = mask & (~(1 << lowest));\n        d[mask] = rec(newMask) + dist[lowest][n];\n        prev[mask] = newMask;\n        leafDescription[mask] = linerDescription[lowest];\n\n        for (int bit = lowest + 1; bit < n; bit++) {\n            if (((1 << bit) & mask) > 0) {\n                newMask = mask & (~(1 << bit)) & (~(1 << lowest));\n                int newValue = rec(newMask) + pre[bit][lowest];\n                if (newValue < d[mask]) {\n                    d[mask] = newValue;\n                    prev[mask] = newMask;\n                    leafDescription[mask] = allDescriptions[lowest][bit];\n                }\n            }\n        }\n        return d[mask];\n    }\n\n    public void solve() {\n        final int inf = (int) 1e+9;\n        xs = in.nextInt();\n        ys = in.nextInt();\n\n        n = in.nextInt();\n        x = new int[n + 1];\n        y = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            x[i] = in.nextInt();\n            y[i] = in.nextInt();\n        }\n        x[n] = xs;\n        y[n] = ys;\n\n        allDescriptions = new String[n][n];\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < n; j++){\n                allDescriptions[i][j] = (i + 1) + \" \" + (j + 1) + \" \";\n            }\n        }\n\n        linerDescription = new String[n];\n        for (int i = 0; i < n; i++){\n            linerDescription[i] = (i + 1) + \" \";\n        }\n\n        dist = new int[n + 1][n + 1];\n        pre = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= n; j++) {\n                dist[i][j] = 2 * dist(i, j);\n                pre[i][j] = dist(i, n) + dist(i, j) + dist(j, n);\n            }\n        }\n\n        d = new int[1 << n];\n        Arrays.fill(d, -1);\n        d[0] = 0;\n        prev = new int[1 << n];\n        leafDescription = new String[1 << n];\n//        Arrays.fill(d, inf);\n//        prev[0] = 0;\n//        d[0] = 0;\n//        for (int i = 0; i < n; i++) {\n//            int add = 1 << i;\n//            int len = 2 * dist[n][i];\n//            String description = (i + 1) + \" \";\n//\n//            go(prev, leafDescription, d, len, add, description);\n//        }\n//        for (int i = 0; i < n; i++) {\n//            for (int j = i + 1; j < n; j++) {\n//                int add = (1 << i) | (1 << j);\n//                int len = dist[n][i] + dist[i][j] + dist[n][j];\n//                String description = (i + 1) + \" \" + (j + 1) + \" \";\n//\n//                go(prev, leafDescription, d, len, add, description);\n//            }\n//        }\n//        Debug.printObjects(out, d);\n//        Debug.printObjects(out, prev);\n//        Debug.printObjects(out, leafDescription);\n        int result = rec((1 << n) - 1);\n        String answer = \"\";\n        for (int curr = d.length - 1; prev[curr] != curr; curr = prev[curr] ){\n            answer += \"0 \" + leafDescription[curr];\n        }\n        answer += \"0\";\n        out.println(result);\n        out.println(answer);\n    }\n\n    private InputReader in;\n    private PrintWriter out;\n\n    Task(InputReader in, PrintWriter out) {\n        this.in = in;\n        this.out = out;\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public double nextDouble(){\n        return Double.parseDouble(next());\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong(){\n        return Long.parseLong(next());\n    }\n\n    public byte nextByte(){\n        return Byte.parseByte(next());\n    }\n}", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static Reader in = null;\n    static PrintWriter out = null;\n\n    static long sum(long s, long e) {\n        return (e * (e-1) / 2) - (s * (s-1) / 2) + s;\n    }\n\n    static void solve() throws IOException {\n        long n = in.nextLong();\n        long k = in.nextLong();\n        if(n == 1) {\n            out.println(0);\n            return;\n        }\n        long ans = 0;\n        while(n != 0) {\n            long l = Math.min(n, k);\n            long s = 2, e = l, x = -1;\n            while(s <= e) {\n                long m = (s+e)/2;\n                long t = sum(m, l);\n                if(t <= n) {\n                    x = m;\n                    e = m-1;\n                }\n                else s = m+1;\n            }\n            if(x == 2 && sum(x, l) != n) break;\n            n = n - sum(x, l);\n            ans = ans + (l - x + 1);\n            if(n == 1) {\n                ans++;\n                n--;\n            }\n        }\n        if(n == 0) out.println(ans);\n        else out.println(-1);\n    }\n\n    public static void main(String[] args) {\n        try {\n            OutputStreamWriter osw = new OutputStreamWriter(System.out);\n            BufferedWriter bw = new BufferedWriter(osw);\n            in = new Reader();\n            out = new PrintWriter(bw);\n\n            solve();\n\n            out.close();\n            bw.close();\n            osw.close();\n            in.close();\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class Reader {\n        InputStreamReader isr = new InputStreamReader(System.in);\n        BufferedReader br = new BufferedReader(isr);\n        StringTokenizer tk = new StringTokenizer(\"\");\n        String s = null;\n\n        String nextLine() throws IOException {\n            while((s = br.readLine()) != null && s.length() == 0);\n            return s;\n        }\n        String next() throws IOException {\n            if(!tk.hasMoreTokens()) tk = new StringTokenizer(nextLine());\n            return tk.nextToken();\n        }\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n        void close() throws  IOException {\n            br.close();\n            isr.close();\n        }\n    }\n}\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class pre426\n{\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    public static void main(String args[])\n    {\n        FastReader obj = new FastReader();\n        long a = obj.nextLong(),b = obj.nextLong();\n        String as = Long.toBinaryString(a),bs = Long.toBinaryString(b);\n        while(as.length()<bs.length()) as = '0'+as;\n        while(bs.length()<as.length()) bs = '0'+bs;\n        String s = \"0\";\n        boolean flag = false;\n        for(int i=0;i<as.length();i++)\n        {\n            if(flag) s = s+'1';\n            else if(as.charAt(i)!=bs.charAt(i) && !flag)\n            {\n                s = s+'1';\n                flag = true;\n            }\n        }\n        long l = Long.parseLong(s,2);\n        System.out.println(l);\n    }\n}\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.util.*;\n\n\npublic class Main {\n    static int n=5;\n    static int[] arr=new int[5];\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n        int arr[]=new int[n];\n        for (int i=0;i<n;i++)\n        {\n            arr[i]=sc.nextInt();\n        }\n        for (int i=0;i<n;i++)\n        {\n            if (arr[i]>=0)\n            {\n                arr[i]=-arr[i]-1;\n            }\n        }\n        if (n%2!=0)\n        {\n            int min=0;\n            for (int i=1;i<n;i++)\n            {\n                if (arr[i]<arr[min])\n                    min=i;\n            }\n            arr[min]=-arr[min]-1;\n        }\n        for (int x:arr)\n        {\n            System.out.print(x + \" \");\n        }\n\n    }\n}", "complexity": "linear", "problem": "1180_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.Stack;\n\n\n\n\npublic class Main{\n\tpublic static class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer root;\n\t\t\n \n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n \n\t\tString next() {\n\t\t\twhile (root == null || !root.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\troot = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception r) {\n\t\t\t\t\tr.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn root.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (Exception r) {\n\t\t\t\tr.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\t\n\tpublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\tstatic int mod = (int) (1e9+7);\n\tstatic long cf = 998244353;\n    static final long MAX = (long) 1e9;\n    public static List<Integer>[] edges;\n    public static int[][] parent;\n    public static int col = 32;\n    public static int[] Bit;\n    public static long[] dp;\n    public static long[] fac,inv;\n\tpublic static void main(String[] args) {\n\t\n\tFastReader sc = new FastReader();\n\t\n\tlong n = sc.nextLong();\n\tlong s = sc.nextLong();\n\tint d = 9 * 18;\n\tlong ans;\n\tif (n >= s + d) {\n\t\tans = n - s - d;\n\t\tfor (long x = s; x <= s + d; x++)\n\t\t\tif (check(x, s))\n\t\t\t\tans++;\n\t} else {\n\t\tans = 0;\n\t\tfor (long x = s; x <= n; x++)\n\t\t\tif (check(x, s))\n\t\t\t\tans++;\n\t}\n\tout.println(ans);\n\tout.close();\n\n\t}\n\tprivate static boolean check(long x, long s) {\n\t\tlong n = x;\n\t\tlong sum = 0;\n\t\twhile(n>0) {\n\t\t\tsum+=n%10;\n\t\t\tn/=10;\n\t\t}\n\t\treturn x-sum>=s;\n\t}\n\t\n\t\n}\n\t\t \t   \t\t\t\t     \t    \t \t\t\t \t\t\t\t", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class C {\n    public static void main(String[] args) throws IOException {\n\tBufferedReader in =\n\t    new BufferedReader(new InputStreamReader(System.in));\n\tint n = Integer.parseInt(in.readLine());\n\tchar[] ps = in.readLine().toCharArray();\n\tHashMap<Character, TreeSet<Integer>> locs =\n\t    new HashMap<Character, TreeSet<Integer>>();\n\tHashSet<Character> poks = new HashSet<Character>();\n\tint lastNew = n;\n\tfor (int i = 0; i < n; i++) {\n\t    if (!poks.contains(ps[i])) {\n\t\tpoks.add(ps[i]);\n\t\tlocs.put(ps[i], new TreeSet<Integer>());\n\t\tlastNew = i;\n\t    }\n\t    locs.get(ps[i]).add(i);\n\t}\n\tint max = lastNew;\n\tint minRange = max+1;\n\tfor (int min = 0; min < n; min++) {\n\t    char pAtMin = ps[min];\n\t    Integer nextInd = locs.get(pAtMin).higher(min);\n\t    if (nextInd == null) break;\n\t    max = Math.max(max, nextInd);\n\t    minRange = Math.min(minRange, max-min);\n\t}\n\tSystem.out.println(minRange);\n    }\n}\n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.*;\n  \npublic class c726b\n{\n    //By shwetank_verma\n\tpublic static void main(String[] args)\n    {\n        FastReader sc=new FastReader();\n        try{\n           \n                int t=1;\n               // t=sc.nextInt();\n                while(t-->0){\n                long n=sc.nextLong();\n                long k=sc.nextLong();\n                long l=0,r=n+1;\n                while(l+1<r) {\n                \tlong m=l+(r-l)/2;\n                \tlong temp=m;\n                \tlong s=0;\n                \twhile(temp!=0) {\n                \t\ts+=temp%10;\n                \t\ttemp=temp/10;\n                \t}\n                \tif(m-s>=k)\n                \t\tr=m;\n                \telse\n                \t\tl=m;\n                \t\n                }\n                System.out.println(n-r+1);\n                }\n           \n            \n        }catch(Exception e){\n            return;\n        }\n    }\n\nstatic void ruffleSort(long[] a) {\n\t\tint n=a.length;\n\t\tRandom r=new Random();\n\t\tfor (int i=0; i<a.length; i++) {\n\t\t\tlong oi=r.nextInt(n), temp=a[i];\n\t\t\ta[i]=a[(int)oi];\n\t\t\ta[(int)oi]=temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\nstatic void ruffleSort(int[] a) {\n\t\tint n=a.length;\n\t\tRandom r=new Random();\n\t\tfor (int i=0; i<a.length; i++) {\n\t\t\tint oi=r.nextInt(n), temp=a[i];\n\t\t\ta[i]=a[oi];\n\t\t\ta[oi]=temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n  \n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n  \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n  \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n  \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n  \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n  \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static int mod=1000000007;\n    static boolean primes[]=new boolean[1000007];\n    static ArrayList<Integer> b=new ArrayList<>();\n    static boolean seive(int n){\n        Arrays.fill(primes,true);\n        primes[0]=primes[1]=false;\n        for(int i=2;i*i<=n;i++){\n            if(primes[i]==true){\n                for(int p=i*i;p<=n;p+=i){\n                    primes[p]=false;\n                }\n            }\n        }\n        if(n<1000007){\n        \tfor(int i=2;i<=n;i++) {\n        \t\tif(primes[i])\n        \t\t\tb.add(i);\n        \t}\n            return primes[n];\n        }\n        return false;\n        \n    }\n    static int gcd(int a,int b){\n        if(b==0)\n        return a;\n        return gcd(b,a%b);\n    }\n    static long GCD(long a,long b){\n        if(b==0)\n        return a;\n        return GCD(b,a%b);\n    }\n    static ArrayList<Integer> segseive(int l,int r){\n    \t\n    \tArrayList<Integer> isprime=new ArrayList<Integer>();\n    \tboolean p[]=new boolean[r-l+1];\n    \tArrays.fill(p, true);\n        \n    \tfor(int i=0;b.get(i)*b.get(i)<=r;i++) {\n    \t\tint currprime=b.get(i);\n    \t\tint base=(l/currprime)*currprime;\n    \t\tif(base<l) {\n    \t\t\tbase+=currprime;\n    \t\t}\n    \t\tfor(int j=base;j<=r;j+=currprime) {\n    \t\t\tp[j-l]=false;\n    \t\t}\n    \t\t\n    \t\t\n    \t\tif(base==currprime) {\n    \t\t\tp[base-l]=true;\n    \t\t}\n    \t\t\n    \t}\n    \tfor(int i=0;i<=r-l;i++) {\n    \t\tif(p[i])\n    \t\t\tisprime.add(i+l);\n    \t}\n    \treturn isprime;\n    }\n      static int LowerBound(int a[], int x) { // x is the target value or key\n  int l=-1,r=a.length;\n  while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a[m]>=x) r=m;\n    else l=m;\n  }\n  return r;\n}\nstatic int UpperBound(int a[], int x) {// x is the key or target value\n    int l=-1,r=a.length;\n    while(l+1<r) {\n       int m=(l+r)>>>1;\n       if(a[m]<=x) l=m;\n       else r=m;\n    }\n    return l+1;\n }\n\n  \n     \n}\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\n    PrintWriter out;\n    Scanner in;\n\n    public static void main(String[] args) throws IOException {\n        new Thread(new Main()).start();\n    }\n\n    public void run() {\n        try {\n            out = new PrintWriter(new BufferedOutputStream(System.out));\n            in = new Scanner(System.in);\n            solve();\n            out.close();\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public void solve() throws IOException {\n        int n = in.nextInt();\n        if (n >= 0) {\n            out.println(n);\n        } else {\n            String s = String.valueOf(n);\n            int l = s.length();\n            String s1 = s.substring(0, l - 2);\n            if (s.charAt(l - 1) > s.charAt(l - 2)) {\n                s1 += s.charAt(l - 2);\n            } else {\n                s1 += s.charAt(l - 1);\n            }\n            out.println(Integer.parseInt(s1));\n        }\n    }\n}", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class A {\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(new InputStreamReader(System.in));\n        int n = s.nextInt();\n        if (n == 1) {\n            System.out.println(\"NO\");\n            System.exit(0);\n        }\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = s.nextInt();\n        }\n        Arrays.sort(nums);\n        int x = 1;\n        while (x < n && nums[x] == nums[x - 1])\n            x++;\n        if (x == n) {\n            System.out.println(\"NO\");\n            System.exit(0);\n        } else {\n            System.out.println(nums[x]);\n            System.exit(0);\n        }\n\n    }\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.*;\n\npublic class B {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tReader scan = new Reader();\n\t\tint t = scan.nextInt();\n\t\tfor(int tt = 0;tt<t;tt++) {\n\t\t\t\n\t\t\tint n = scan.nextInt();\n\t\t\tint arr[] = new int[n];\n\t\t\tfor(int i = 0;i<n;i++) arr[i] = scan.nextInt();\n\t\t\t\n\t\t\tList<Integer> list = new ArrayList<>();\n\t\t\tint j = -1;\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\tfor(int i = 0;i<n;i++) {\n\t\t\t\tif(list.isEmpty() || arr[i]==1) { //add\n\t\t\t\t\tlist.add(arr[i]);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(arr[i] == list.get(j)+1) { //replace\n\t\t\t\t\tlist.set(j, arr[i]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int k = j;k>=0;k--) {\n\t\t\t\t\t\tif(arr[i] == list.get(k)+1) {//replace\n\t\t\t\t\t\t\tlist.set(k, arr[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {//delete\n\t\t\t\t\t\t\tlist.remove(k);\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.delete(0, s.length());\n\t\t\t\tfor(Integer p:list) {\n\t\t\t\t\ts.append(p+\".\");\n\t\t\t\t}\n\t\t\t\ts.deleteCharAt(s.length()-1);\n\t\t\t\tSystem.out.println(s.toString());\n\t\t\t}\n\t\t}\n\n\t\tscan.close();\n\t\t\n\t}\n\t\n\tstatic class Reader \n\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\n\t\tpublic Reader(String file_name) throws IOException \n\t\t{ \n\t\t\tdin = new DataInputStream(new FileInputStream(file_name)); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\n\t\tpublic String readLine() throws IOException \n\t\t{ \n\t\t\tbyte[] buf = new byte[64]; // line length \n\t\t\tint cnt = 0, c; \n\t\t\twhile ((c = read()) != -1) \n\t\t\t{ \n\t\t\t\tif (c == '\\n') \n\t\t\t\t\tbreak; \n\t\t\t\tbuf[cnt++] = (byte) c; \n\t\t\t} \n\t\t\treturn new String(buf, 0, cnt); \n\t\t} \n\n\t\tpublic int nextInt() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t}  while ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic long nextLong() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic double nextDouble() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n\n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n\n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n\t\t} \n\t}\n\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.*;\nimport java.util.*;\n\n\n/*\n\n\n\n*/\n\n\n\npublic class C {\n\tstatic FastReader sc=null;\n\t\n\t\t\t\n\tpublic static void main(String[] args) {\n\t\tsc=new FastReader();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n=sc.nextInt();\n\t\t\tint a[]=sc.readArray(n);\n\t\t\tStack<Integer> s=new Stack<>();\n\t\t\tfor(int e:a) {\n\t\t\t\tif(e==1) {\n\t\t\t\t\ts.add(e);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twhile(!s.isEmpty()) {\n\t\t\t\t\t\tint q=s.pop();\n\t\t\t\t\t\tif(q==e-1) {\n\t\t\t\t\t\t\ts.add(e);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint k=0;\n\t\t\t\tfor(int i:s) {\n\t\t\t\t\tk++;\n\t\t\t\t\tif(k<s.size())out.print(i+\".\");\n\t\t\t\t\telse out.print(i);\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tout.close();\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic int hash(ArrayList<Integer> values) {\n\t\tint c=0;\n\t\tfor(int e:values)c+=e;\n\t\treturn c;\n\t}\n\t\n\t\n\tstatic int[] ruffleSort(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al);\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\t\n\tstatic class FastReader{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch(IOException e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++)a[i]=sc.nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}\n\n\n\n\n\n\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class A {\n\tstatic void solve(InputReader in, PrintWriter out) {\n\t\tlong n = in.nextLong();\n\t\tout.print(25);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\n\t\tsolve(in, out);\n\n\t\tout.close();\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic long nextDouble() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t}\n}\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\npublic class B{\n    public static void main(String[] args) throws Exception{\n        new B().run();\n    }\n\n    double ans = 0;\n    int n, candy, A, half;\n\n    void run() throws Exception{\n        Scanner sc = new Scanner(System.in);\n        //BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));\n        // only sc.readLine() is available\n        n = sc.nextInt();\n        candy = sc.nextInt();\n        A = sc.nextInt();\n        half = n/2;\n        //int[] level = new int[n];\n        //int[] loyal = new int[n];\n        S[] ss = new S[n];\n        for(int i = 0; i < n; i++){\n            ss[i] = new S(sc.nextInt(), sc.nextInt());\n        }\n        Arrays.sort(ss);\n        int need = 0;\n        for(int i = n-1; i >= n-half-1; i--)\n            need += (100-ss[i].loyal)/10;\n        if(need <= candy){\n            System.out.println(1.0);\n            return;\n        }\n        tra(ss, 0, candy);\n        /*\n        while(candy > 0){\n            int ind = 0;\n            for(int i = 1; i < n; i++)\n                if(ss[i].loyal < 100 && ss[ind].level < ss[i].level)\n                    ind = i;\n            ss[ind].loyal += 10;\n            ss[ind].loyal = min(100, ss[ind].loyal);\n            candy--;\n        }\n        */\n        System.out.printf(\"%.10f\\n\", ans);\n    }\n\n    void tra(S[] ss, int pos, int rest){\n        if(pos == n){\n            double sum = 0;\n            int lim = 1<<n;\n            for(int m = 0; m < lim; m++){\n                int app = Integer.bitCount(m);\n                double p = 1;\n                int B = 0;\n                for(int i = 0; i < n; i++){\n                    if(((m>>i) & 1) == 1){\n                        p = p * ss[i].loyal / 100;\n                    }else{\n                        p = p * (100 - ss[i].loyal) / 100;\n                        B += ss[i].level;\n                    }\n                }\n                if(app > half)sum += p;\n                else{\n                    sum += p * A / (A+B);\n                }\n            }\n            ans = max(ans, sum);\n            return;\n        }\n        for(int i = 0; i <= rest; i++){\n            int old = ss[pos].loyal;\n            int nl = ss[pos].loyal + i * 10;\n            if(nl > 100)break;\n            ss[pos].loyal = nl;\n            tra(ss, pos+1, rest-i);\n            ss[pos].loyal = old;\n        }\n    }\n}\n\nclass S implements Comparable<S>{\n    int level, loyal;\n    S(int a, int b){\n        level = a;\n        loyal = b;\n    }\n    public int compareTo(S s){\n        return this.loyal - s.loyal;\n    }\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "/*\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2877\u28ef\u28bf\u28ff\u28f7\u28fb\u28af\u28ff\u287d\u28fb\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u2838\u28ff\u28ff\u28c6\u2839\u28ff\u28ff\u28be\u28df\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fb\u28fd\u287f\u28ff\u28ce\u2819\u28ff\u28de\u28f7\u284c\u28bb\u28df\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2839\u28ff\u28ff\u2846\u283b\u28ff\u28df\u28ef\u287f\u28fd\u287f\u28ff\u28ff\u28ff\u28ff\u28fd\u2877\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u28f7\u28ff\u28ff\u28ff\u2840\u2839\u28df\u28fe\u28df\u28c6\u2839\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28a0\u2858\u28ff\u28ff\u2844\u2809\u28bf\u28ff\u28fd\u2877\u28ff\u28fb\u28ff\u28ff\u28ff\u28ff\u285d\u28f7\u28ef\u28bf\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ef\u28bf\u28fe\u28bf\u28ff\u2844\u2884\u2818\u28bf\u28de\u287f\u28e7\u2848\u28b7\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b8\u28e7\u2818\u28ff\u28f7\u2808\u28e6\u2819\u28bf\u28fd\u28f7\u28fb\u28fd\u28ff\u28ff\u28ff\u28ff\u28cc\u28bf\u28ef\u28bf\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u28ef\u28ff\u28bf\u28ff\u2846\u28b8\u2877\u2848\u28bb\u287d\u28f7\u2877\u2844\u283b\u28fd\u28ff\u28ff\u287f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ff\u28ff\u28ff\u28ff\u28cf\u28b0\u28ef\u28b7\u2808\u28ff\u2846\u28b9\u28b7\u284c\u283b\u287e\u288b\u28f1\u28ef\u28ff\u28ff\u28ff\u28ff\u2846\u28bb\u287f\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u284e\u28ff\u28be\u287f\u28ff\u2846\u28b8\u28fd\u28bb\u28c4\u2839\u28f7\u28df\u28ff\u28c4\u2839\u28df\u28ff\u28ff\u28df\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28ff\u28ff\u28ff\u2847\u28b8\u28ef\u28df\u28e7\u2818\u28f7\u2808\u286f\u281b\u2880\u2850\u28be\u28df\u28f7\u28fb\u28ff\u28ff\u28ff\u287f\u284c\u28bf\u28fb\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u28b8\u287f\u28df\u28ff\u2847\u28b8\u28ef\u28df\u28ee\u28a7\u2848\u28bf\u28de\u287f\u28e6\u2818\u280f\u28f9\u28ff\u28fd\u28bf\u28ff\u28ff\u28ff\u28ff\u28ef\u28ff\u28ff\u28ff\u2847\u28b8\u28ff\u28ff\u28fe\u2846\u2839\u2880\u28e0\u28fe\u28df\u28f7\u2848\u28bf\u28de\u28ef\u28bf\u28ff\u28ff\u28ff\u28b7\u2818\u28ef\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2848\u28ff\u28bf\u28fd\u2847\u2818\u281b\u281b\u281b\u2813\u2813\u2808\u281b\u281b\u281f\u2807\u2880\u28bf\u28fb\u28ff\u28ef\u28bf\u28ff\u28ff\u28ff\u28f7\u28bf\u28ff\u28ff\u2801\u28fe\u28ff\u28ff\u28ff\u28e7\u2844\u2807\u28f9\u28ff\u28fe\u28ef\u28ff\u2844\u283b\u28fd\u28ef\u28bf\u28fb\u28ff\u28ff\u2847\u28b9\u28fe\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b9\u28ff\u287d\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28de\u28c6\u2830\u28f6\u28f6\u2844\u2880\u28bb\u287f\u28ef\u28ff\u287d\u28ff\u28ff\u28ff\u28af\u28df\u287f\u2880\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2810\u28f8\u28ff\u28ff\u28f7\u28ff\u28ff\u28c6\u2839\u28ef\u28ff\u28fb\u28ff\u28ff\u28ff\u2880\u28ff\u28bf\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2818\u28ef\u287f\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2848\u28bf\u28f3\u2818\u2844\u283b\u28ff\u28be\u28fd\u28df\u287f\u28ff\u28af\u28ff\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2840\u28be\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c6\u2839\u28fe\u28f7\u28fb\u28ff\u287f\u2847\u28b8\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b9\u28ff\u2807\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u283b\u2847\u28b9\u28c6\u2839\u28df\u28fe\u28fd\u28fb\u28df\u28ff\u28fd\u2801\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u28ff\u28ff\u283f\u281b\u281b\u2809\u2819\u280b\u2880\u2801\u2898\u28ef\u28ff\u28ff\u28e7\u2818\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2848\u28ff\u2843\u28bc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2859\u280c\u28ff\u28c6\u2818\u28ff\u28de\u287f\u28de\u287f\u285e\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u281b\u2809\u2801\u2880\u28c0\u28e0\u28e4\u28e4\u28f6\u28f6\u28f6\u2846\u28bb\u28fd\u28de\u287f\u28f7\u2808\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2818\u2801\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2819\u281b\u281b\u28bf\u28c4\u28bb\u28ff\u28e7\u2818\u28af\u28df\u287f\u28fd\u2801\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u2843\u2880\u2880\u2818\u281b\u283f\u28bf\u28fb\u28df\u28ef\u28fd\u28fb\u28f5\u2840\u28bf\u28ef\u28df\u28ff\u2880\u28ff\n\u28ff\u28ff\u28ff\u28df\u28ff\u28ff\u28ff\u28ff\u28f6\u28f6\u2846\u2880\u28ff\u28fe\u28ff\u28fe\u28f7\u28ff\u28f6\u283f\u281a\u2809\u2880\u2880\u28e4\u28ff\u28f7\u28ff\u28ff\u28f7\u2848\u28bf\u28fb\u2883\u28fc\u28ff\u28ff\u28ff\u28ff\u28fb\u28ff\u28ff\u28ff\u2876\u28e6\u28e4\u28c4\u28c0\u2840\u2809\u281b\u281b\u2837\u28ef\u28f3\u2808\u28fe\u287d\u28fe\u2880\u28ff\n\u28ff\u28bf\u28ff\u28ff\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2810\u28ff\u28ff\u28ff\u28ff\u283f\u280b\u2801\u2880\u2880\u28e4\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28cc\u28e5\u28fe\u287f\u28ff\u28ff\u28f7\u28ff\u28ff\u28bf\u28f7\u28ff\u28ff\u28df\u28fe\u28fd\u28f3\u28af\u28df\u28f6\u28e6\u28e4\u287e\u28df\u28e6\u2818\u28ff\u28be\u2841\u28ba\n\u28ff\u28fb\u28ff\u28ff\u2877\u28ff\u28ff\u28ff\u28ff\u28ff\u2857\u28e6\u2838\u287f\u280b\u2801\u2880\u2880\u28e0\u28f4\u28bf\u28ff\u28fd\u28fb\u28bd\u28fe\u28df\u28f7\u28ff\u28df\u28ff\u28ff\u28ff\u28f3\u283f\u28f5\u28e7\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28f3\u28ef\u28ff\u28ff\u28ff\u28fd\u2880\u28b7\u28fb\u2804\u2818\n\u28ff\u28b7\u28fb\u28ff\u28ff\u28f7\u28fb\u28ff\u28ff\u28ff\u2877\u281b\u28c1\u2880\u28c0\u28e4\u28f6\u28ff\u28db\u287f\u28ff\u28ee\u28fd\u287b\u28ff\u28ee\u28fd\u28fb\u28af\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ef\u2880\u28b8\u28ff\u2880\u2846\n\u2838\u28df\u28ef\u28ff\u28ff\u28f7\u28bf\u28fd\u28ff\u28ff\u28f7\u28ff\u28f7\u28c6\u2839\u28ff\u28f6\u28ef\u283f\u28ff\u28f6\u28df\u28fb\u28bf\u28f7\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2880\u28ef\u28df\u2880\u2847\n\u28c7\u2839\u28df\u28fe\u28fb\u28ff\u28ff\u28be\u287d\u28ff\u28ff\u28ff\u28ff\u28ff\u28c6\u28b9\u28f6\u28ff\u28fb\u28f7\u28ef\u28df\u28ff\u28ff\u28fd\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2880\u287f\u2847\u28b8\u2847\n\u28ff\u28c6\u2839\u28f7\u287b\u28fd\u28ff\u28ef\u28bf\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28c6\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2807\u28b8\u28ff\u2807\u28fc\u2847\n\u2859\u283e\u28c6\u2839\u28ff\u28e6\u281b\u28ff\u28af\u28f7\u28bf\u287d\u28ff\u28ff\u28ff\u28ff\u28c6\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2803\u280e\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u280f\u2880\u28ff\u28fe\u28e3\u287f\u2847\n\u28ff\u28f7\u284c\u28a6\u2819\u28ff\u28ff\u28cc\u283b\u28fd\u28af\u28ff\u28fd\u28fb\u28ff\u28ff\u28ff\u28e7\u2829\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u284f\u28b0\u28a3\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2880\u2880\u28bf\u28de\u28f7\u28bf\u2847\n\u28ff\u28fd\u28c6\u2839\u28e7\u2818\u28ff\u28ff\u2877\u28cc\u2819\u28b7\u28ef\u2877\u28df\u28ff\u28ff\u28ff\u28f7\u2840\u2879\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c8\u2803\u28f8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u2880\u28f4\u2867\u2880\u2838\u28ff\u287d\u28ff\u2880\n\u28bb\u28fd\u28ff\u2844\u28bb\u28f7\u2848\u28bf\u28ff\u28ff\u28a7\u2880\u2819\u28bf\u28fb\u287e\u28fd\u28fb\u28ff\u28ff\u28c4\u280c\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u2881\u28f0\u28fe\u28df\u287f\u2880\u2844\u28bf\u28df\u28ff\u2880\n\u2844\u28bf\u28ff\u28f7\u2880\u2839\u28df\u28c6\u283b\u28ff\u28ff\u28c6\u2880\u28c0\u2809\u283b\u28ff\u287d\u28ef\u28ff\u28ff\u28f7\u28c8\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2880\u28e0\u2818\u28ef\u28f7\u28ff\u285f\u2880\u2886\u2838\u28ff\u285f\u28b8\n\u28f7\u2848\u28bf\u28ff\u28c7\u28b1\u2858\u28bf\u28f7\u28ec\u28d9\u283f\u28e7\u2818\u28c6\u2880\u2808\u283b\u28f7\u28df\u28fe\u28bf\u28ff\u28c6\u2839\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28e0\u285e\u28a1\u28ff\u2880\u28ff\u28ff\u28ff\u2807\u2844\u28b8\u2844\u28bb\u2847\u28fc\n\u28ff\u28f7\u2848\u28bf\u28ff\u2846\u28a3\u2840\u2819\u28be\u28df\u28ff\u28ff\u28f7\u2848\u2802\u2818\u28e6\u2848\u283f\u28ef\u28ff\u28be\u28ff\u28c6\u2819\u283b\u283f\u283f\u283f\u283f\u287f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u283f\u281b\u288b\u28e0\u28fe\u285f\u28a0\u28ff\u28ff\u2880\u28ff\u28ff\u285f\u28a0\u28ff\u2888\u28e7\u2818\u28a0\u28ff\n\u28ff\u28ff\u28ff\u28c4\u283b\u28ff\u2844\u28b3\u2844\u2886\u2859\u283e\u28fd\u28ff\u28ff\u28c6\u2840\u28b9\u2877\u28c4\u2819\u28bf\u28ff\u287e\u28ff\u28c6\u2880\u2840\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u28c0\u28e0\u28f4\u287f\u28ef\u280f\u28e0\u28ff\u28ff\u284f\u28b8\u28ff\u287f\u2881\u28ff\u28ff\u2880\u28ff\u2806\u28b8\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28e6\u2859\u28ff\u28c6\u28bb\u284c\u28bf\u28f6\u28a4\u28c9\u28d9\u28ff\u28f7\u2840\u2819\u283d\u2837\u2804\u2839\u28ff\u28df\u28ff\u28c6\u2899\u28cb\u28e4\u28e4\u28e4\u28c4\u28c0\u2880\u2880\u2880\u2880\u28fe\u28ff\u28df\u2877\u28ef\u287f\u2883\u28fc\u28ff\u28ff\u28ff\u2807\u28fc\u285f\u28e1\u28ff\u28ff\u28ff\u2880\u287f\u28a0\u2808\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ee\u28ff\u28ff\u28ff\u284c\u2801\u28a4\u28e4\u28e4\u28e4\u28ec\u28ed\u28f4\u28f6\u28f6\u28f6\u28c6\u2808\u28bb\u28ff\u28ff\u28c6\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28e4\u28cc\u28c9\u2858\u281b\u283b\u2836\u28ff\u28ff\u28ff\u28ff\u285f\u28f0\u28eb\u28f4\u28ff\u28ff\u28ff\u28ff\u2804\u28f7\u28ff\u28ff\u28ff\n*/\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class k{\n\t\n\tpublic static void main(String[] args) throws Exception \n\t{ \n\t\tScanner s=new Scanner(System.in);\n\n\t\tPriorityQueue<pair> q=new PriorityQueue<>(new comp());\n\t\t\n\t\tint n=s.nextInt();\n\t\tint m=s.nextInt();\n\t\t\n\t\tlong[] arr=new long[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tarr[i]=s.nextLong();\n\t\t}\n\t\t\n\t\tArrayList<Integer>[] brr=new ArrayList[m];\n\t\t\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tbrr[i]=new ArrayList<>();\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tbrr[(int)arr[i]%m].add(i);\n\t\t}\n\t\t\n\t\tint k=n/m;\n\t\tint end=-1;\n\t\tfor(int i=m-1;i>=0;i--) {\n\t\t\tif(brr[i].size()>k) {\n\t\t\t\tend=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(end==-1) {\n\t\t\tSystem.out.println(0);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tSystem.out.print(arr[i]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}else {\n\t\t\tlong ans=0;\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tif(brr[i].size()<k) {\n\t\t\t\t\tlong req=k-brr[i].size();\n\t\t\t\t\twhile(req>0) {\n\t\t\t\t\t\tlong a=Integer.MAX_VALUE;\n\t\t\t\t\t\tlong b=Integer.MAX_VALUE;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!q.isEmpty()) {\n\t\t\t\t\t\t\ta=i-q.peek().rem;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(end>i) {\n\t\t\t\t\t\t\tb=(i+1)+(m-1-end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(a<=b) {\n\t\t\t\t\t\t\tans=ans+a;\n\t\t\t\t\t\t\tpair ob=q.poll();\n\t\t\t\t\t\t\tarr[ob.in]=arr[ob.in]+a;\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tans=ans+b;\n\t\t\t\t\t\t\tarr[brr[end].get(brr[end].size()-1)]=arr[brr[end].get(brr[end].size()-1)]+b;\n\t\t\t\t\t\t\tbrr[end].remove(brr[end].size()-1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\twhile(end>-1 && brr[end].size()<=k) {\n\t\t\t\t\t\t\t\tend--;\n\t\t\t\t\t\t\t\tif(end==-1) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\treq--;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}else {\n\t\t\t\t\tfor(int j=0;j<brr[i].size()-k;j++) {\n\t\t\t\t\t\tq.add(new pair(i,brr[i].get(j)));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tSystem.out.print(arr[i]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n}\nclass pair{\n\tint rem;\n\tint in;\n\tpublic pair(int rem,int in) {\n\t\tthis.rem=rem;\n\t\tthis.in=in;\n\t}\n}\nclass comp implements Comparator<pair>{\n\tpublic int compare(pair h,pair k) {\n\t\treturn h.rem-k.rem;\n\t}\n}\n", "complexity": "linear", "problem": "0999_D", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package newpackage;\nimport java.util.*;\n/**\n *\n * @author parpaorsa\n */\npublic class NewClass {\n    static Scanner in=new Scanner(System.in);\n    public static void main(String[] args) {\n        int n = in.nextInt(),ans=Integer.MAX_VALUE,t=0;\n        String x = in.next();\n        for (int i = 0; i < n; i++) {\n            if(x.charAt(i)=='-')t--;\n            else t++;\n            ans=Math.min(ans,t);\n        }\n           if(ans <= 0) \n               System.out.println(Math.abs(ans)+t);\n           else \n               System.out.println(t);\n    }\n \n}\n", "complexity": "linear", "problem": "1159_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\n\npublic class CF_1523_C{\n    //SOLUTION BEGIN\n    void pre() throws Exception{}\n    void solve(int TC) throws Exception{\n        int N = ni();\n        int[] A = new int[N];\n        for(int i = 0; i< N; i++)A[i] = ni();\n\n//        Stack<Integer> stack = new Stack<>();\n        int[] stack = new int[2*N];\n        int sz = 0;\n        for(int i = 0; i< N; i++){\n            if(A[i] == 1)stack[sz++] = 1;\n            else{\n                while (sz > 0 && stack[sz-1]+1 != A[i])sz--;//!stack.isEmpty() && stack.peek()+1 != A[i])stack.pop();\n                hold(sz != 0);\n                stack[sz-1]++;\n                hold(stack[sz-1] == A[i]);\n            }\n            hold(sz != 0);\n            StringBuilder st = new StringBuilder();\n            for(int s = 0; s< sz; s++){\n                st.append(stack[s]);\n                if(s+1 < sz)st.append(\".\");\n            }\n            pn(st.toString());\n        }\n    }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(\"Hold right there, Sparky!\");}\n    void exit(boolean b){if(!b)System.exit(0);}\n    static void dbg(Object... o){System.err.println(Arrays.deepToString(o));}\n    final long IINF = (long)1e17;\n    final int INF = (int)1e9+2;\n    DecimalFormat df = new DecimalFormat(\"0.00000000000\");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-8;\n    static boolean multipleTC = true, memory = true, fileIO = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        long ct = System.currentTimeMillis();\n        if (fileIO) {\n            in = new FastReader(\"\");\n            out = new PrintWriter(\"\");\n        } else {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n        }\n        //Solution Credits: Taranpreet Singh\n        int T = multipleTC? ni():1;\n        pre();\n        for (int t = 1; t <= T; t++) solve(t);\n        out.flush();\n        out.close();\n        System.err.println(System.currentTimeMillis() - ct);\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new CF_1523_C().run();}catch(Exception e){e.printStackTrace();System.exit(1);}}}, \"1\", 1 << 28).start();\n        else new CF_1523_C().run();\n    }\n    int[][] make(int n, int e, int[] from, int[] to, boolean f){\n        int[][] g = new int[n][];int[]cnt = new int[n];\n        for(int i = 0; i< e; i++){\n            cnt[from[i]]++;\n            if(f)cnt[to[i]]++;\n        }\n        for(int i = 0; i< n; i++)g[i] = new int[cnt[i]];\n        for(int i = 0; i< e; i++){\n            g[from[i]][--cnt[from[i]]] = to[i];\n            if(f)g[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return g;\n    }\n    int[][][] makeS(int n, int e, int[] from, int[] to, boolean f){\n        int[][][] g = new int[n][][];int[]cnt = new int[n];\n        for(int i = 0; i< e; i++){\n            cnt[from[i]]++;\n            if(f)cnt[to[i]]++;\n        }\n        for(int i = 0; i< n; i++)g[i] = new int[cnt[i]][];\n        for(int i = 0; i< e; i++){\n            g[from[i]][--cnt[from[i]]] = new int[]{to[i], i, 0};\n            if(f)g[to[i]][--cnt[to[i]]] = new int[]{from[i], i, 1};\n        }\n        return g;\n    }\n    int find(int[] set, int u){return set[u] = (set[u] == u?u:find(set, set[u]));}\n    int digit(long s){int ans = 0;while(s>0){s/=10;ans++;}return ans;}\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object... o){for(Object oo:o)out.print(oo+\" \");}\n    void pn(Object... o){for(int i = 0; i< o.length; i++)out.print(o[i]+(i+1 < o.length?\" \":\"\\n\"));}\n    void pni(Object... o){for(Object oo:o)out.print(oo+\" \");out.println();out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() throws Exception{\n            String str;\n            try{\n                str = br.readLine();\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }\n            return str;\n        }\n    }\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\tstatic void solve() throws IOException {\n\t\tlong a = nextLong(), b = nextLong();\n\t\tlong answer = get(a, b);\n\t\tout.println(answer);\n\t}\n\n\tprivate static long get(long p, long q) {\n\t\tif (p == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (q == 1) {\n\t\t\treturn p;\n\t\t}\n\t\tif (p == 1) {\n\t\t\treturn q;\n\t\t}\n\t\tif (p >= q) {\n\t\t\treturn p / q + get(p % q, q);\n\t\t}\n\t\treturn q / p + get(p, q % p);\n\t}\n\n\tstatic BufferedReader br;\n\tstatic StringTokenizer st;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream input = System.in;\n\t\tPrintStream output = System.out;\n\t\tFile file = new File(\"a.in\");\n\t\tif (file.exists() && file.canRead()) {\n\t\t\tinput = new FileInputStream(file);\n\t\t}\n\t\tbr = new BufferedReader(new InputStreamReader(input));\n\t\tout = new PrintWriter(output);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tstatic String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class practice {\n\tpublic static void main(String[] args) throws Exception {\n\t\t//Scanner in = new Scanner(new File(\"practice.in\"));\n\t\tScanner in = new Scanner(System.in);\n\n\t\tString str = in.nextLine();\n\t\tlong n = Long.parseLong(str.substring(0, str.indexOf(\" \")));\n\t\tlong m = Long.parseLong(str.substring(str.indexOf(\" \") + 1));\n\t\tif(m - n < 2) {\n\t\t\tSystem.out.println(\"-1\");\n\t\t} else {\n\t\t\tif(m - n == 2 && m % 2 == 1) {\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println((n + n % 2) + \" \" + (n + 1 + n % 2) + \" \" + (n + 2 + n % 2));\n\t\t\t}\n\t\t}\n\t}\n}", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "//package round518;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class C {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] dr = { 1, 0, -1, 0 };\n\t\tint[] dc = { 0, 1, 0, -1 };\n\t\tfor(int d = 0;;d++){\n\t\t\tif(d == 0){\n\t\t\t\tout.println(0 + \" \" + 0);\n\t\t\t\tif(--n == 0)return;\n\t\t\t}else{\n\t\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\t\tout.println(d*dr[k] + \" \" + d*dc[k]);\n\t\t\t\t\tif(--n == 0)return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new C().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "linear", "problem": "1067_C", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main{\n    public static void main(String[] args) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> fibs = new ArrayList<Integer>();\n        int fib0 = 0;\n        int fib1 = 1;\n        int fibN = fib0+fib1;\n        fibs.add(fib0);\n        fibs.add(fib1);\n        while(fibN < 1000000000){\n            fibs.add(fibN);\n            fib0 = fib1;\n            fib1 = fibN;\n            fibN = fib0+fib1;\n        }\n        int n = Integer.parseInt(br.readLine());\n        \n        if(n == 0){System.out.println(0+\" \"+0+\" \"+0);}\n        else{\n            if(n == 1){System.out.println(0+\" \"+0+\" \"+1);}\n            else{\n                if(n == 2){System.out.println(0+\" \"+1+\" \"+1);}\n                else{\n        int i = fibs.indexOf(n);\n        System.out.println(fibs.get(i-4)+\" \"+fibs.get(i-3)+\" \"+fibs.get(i-1));\n    }}\n        }\n}\n}", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\n\npublic class Task235A {\n\n\tpublic static void main(String... args) throws NumberFormatException,\n\t\t\tIOException {\n\t\tSolution.main(System.in, System.out);\n\t}\n\n\tstatic class Scanner {\n\n\t\tprivate final BufferedReader br;\n\t\tprivate String[] cache;\n\t\tprivate int cacheIndex;\n\n\t\tScanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tcache = new String[0];\n\t\t\tcacheIndex = 0;\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tif (cacheIndex >= cache.length) {\n\t\t\t\tcache = br.readLine().split(\" \");\n\t\t\t\tcacheIndex = 0;\n\t\t\t}\n\t\t\treturn Integer.parseInt(cache[cacheIndex++]);\n\t\t}\n\n\t\tlong nextLong() throws IOException {\n\t\t\tif (cacheIndex >= cache.length) {\n\t\t\t\tcache = br.readLine().split(\" \");\n\t\t\t\tcacheIndex = 0;\n\t\t\t}\n\t\t\treturn Long.parseLong(cache[cacheIndex++]);\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\tif (cacheIndex >= cache.length) {\n\t\t\t\tcache = br.readLine().split(\" \");\n\t\t\t\tcacheIndex = 0;\n\t\t\t}\n\t\t\treturn cache[cacheIndex++];\n\t\t}\n\n\t\tvoid close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\n\t}\n\n\tstatic class Solution {\n\n\t\tpublic static void main(InputStream is, OutputStream os)\n\t\t\t\tthrows NumberFormatException, IOException {\n\t\t\tPrintWriter pw = new PrintWriter(os);\n\t\t\tScanner sc = new Scanner(is);\n\n\t\t\tlong n = sc.nextInt();\n\n\t\t\tif (n < 3) {\n\t\t\t\tpw.println(n);\n\t\t\t} else {\n\t\t\t\tif (n % 2 != 0) {\n\t\t\t\t\tpw.println(n * (n - 1) * (n - 2));\n\t\t\t\t} else {\n\t\t\t\t\tif (n % 3 != 0) {\n\t\t\t\t\t\tpw.println(n * (n - 1) * (n - 3));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlong cand1 = n * (n - 1) * (n - 2) / 2;\n\t\t\t\t\t\tlong cand2 = (n - 1) * (n - 2) * (n - 3);\n\t\t\t\t\t\tpw.println(Math.max(cand1, cand2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.flush();\n\t\t\tsc.close();\n\t\t}\n\t}\n\n}", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class CF817C {\n    public static void main(String[] args) throws IOException {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n        pw.println(countBigNums(sc.nextLong(), sc.nextLong()));\n        pw.flush();\n    }\n\n    static long countBigNums(long n, long s) {\n        long lo = 1, hi = (long) 1e18;\n        while (lo <= hi) {\n            long mid = (lo + hi) / 2;\n            long v = mid - sumDigits(mid);\n            if (v >= s)\n                hi = mid - 1;\n            else\n                lo = mid + 1;\n        }\n        return Math.max(0, n - lo + 1);\n    }\n\n    static int sumDigits(long v) {\n        return String.valueOf(v).chars().map(Character::getNumericValue).sum();\n    }\n\n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n\n        public FastScanner() {\n            this.in = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n\n        public void close() throws IOException {\n            in.close();\n        }\n    }\n}\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.util.Scanner;\n\n/**\n * Created by ZeRoGerc on 25.02.15.\n */\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n\n        int n = scan.nextInt();\n\n        if (n % 2 == 0) {\n            System.out.println(4 + \" \" + (n - 4));\n        }\n        else {\n            System.out.println(9 + \" \" + (n - 9));\n        }\n    }\n}\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n\n    static long gcd(long a,long b){ if(b==0)return a;return gcd(b,a%b); }\n    static long modPow(long a,long p,long m){ if(a==1)return 1;long ans=1;while (p>0){ if(p%2==1)ans=(ans*a)%m;a=(a*a)%m;p>>=1; }return ans; }\n    static long modInv(long a,long m){return modPow(a,m-2,m);}\n    static long sol_x,sol_y,gcd_a_b;\n    static void extendedEuclid(long a,long b){ if(b==0){gcd_a_b=a;sol_x=1;sol_y=0; } else{ extendedEuclid(b,a%b);long temp = sol_x;sol_x=sol_y;sol_y = temp - (a/b)*sol_y; } }\n    static class Bhavansort{ Random random;Bhavansort(int a[]){ randomArray(a); sort(a);}Bhavansort(long a[]){ randomArray(a); sort(a);}static int[] sort(int a[]){ Arrays.sort(a);return a;}static long[] sort(long a[]){ Arrays.sort(a);return a; }void randomArray(long a[]){ int n=a.length;for(int i=0;i<n;i++){ int p=random.nextInt(n)%n;long tm=a[i];a[i]=a[p];a[p]=tm; } }void randomArray(int a[]){ int n=a.length;for(int i=0;i<n;i++){ int p=random.nextInt(n)%n;int tm=a[i];a[i]=a[p];a[p]=tm; } }}\n\n\n\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        int a[][]=new int[n][m];\n        for (int i = 0; i <n ; i++) {\n            for (int j = 0; j <m ; j++) {\n                a[i][j]=sc.nextInt();\n            }\n        }\n\n        int cost[][]=new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <n ; j++) {\n                cost[i][j]=Integer.MAX_VALUE;\n                for (int k = 0; k <m ; k++) {\n                    cost[i][j]=Math.min(cost[i][j],Math.abs(a[i][k]-a[j][k]));\n                }\n            }\n        }\n\n        int costRight[][]=new int[n][n];\n        for (int i = 0; i <n ; i++) {\n            for (int j = 0; j <n ; j++) {\n                costRight[i][j]=Integer.MAX_VALUE;\n                for (int k = 0; k <m-1 ; k++) {\n                    costRight[i][j]=Math.min(Math.abs(a[i][k+1]-a[j][k]),costRight[i][j]);\n                }\n            }\n        }\n\n        /*for (int i = 0; i <n ; i++) {\n            for (int j = 0; j <n ; j++) {\n                out.print(cost[i][j]+\" \");\n            }\n            out.println();\n        }\n        out.println();\n\n        for (int i = 0; i <n ; i++) {\n            for (int j = 0; j <n ; j++) {\n                out.print(costRight[i][j]+\" \");\n            }\n            out.println();\n        }*/\n\n        if(n==1){\n            int ans=Integer.MAX_VALUE;\n            for (int i = 0; i <m-1 ; i++) {\n                ans=Math.min(ans,Math.abs(a[0][i]-a[0][i+1]));\n            }\n            out.println(ans);\n            out.close();\n            return;\n        }\n\n        Long dp[][][]=new Long[n+1][n+1][1<<n];\n        long max=0;\n        for (int i = 0; i <n ; i++) {\n           // out.println(f(i,i,1<<i,dp,n,cost,costRight));\n            max=Math.max(max,f(i,i,1<<i,dp,n,cost,costRight));\n        }\n\n        out.println(max);\n        out.close();\n    }\n\n    long f(int start,int end,int mask,Long dp[][][],int n,int cost[][],int costRight[][]){\n        if(dp[start][end][mask]!=null)return dp[start][end][mask];\n        long ans=Integer.MIN_VALUE;\n        for (int i = 0; i <n ; i++) {\n            if((mask&(1<<i))==0){\n                int newMask=mask|(1<<i);\n                if((1<<n)-1!=(mask|(1<<i))){\n                    ans = Math.max(ans, Math.min(cost[end][i], f(start, i, newMask, dp, n, cost, costRight)));\n                }\n                else{\n                    ans=Math.max(ans,Math.min(cost[end][i],costRight[start][i]));\n                }\n            }\n        }\n        return dp[start][end][mask]=ans;\n    }\n\n}", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "/*\n * PDPM IIITDM Jabalpur\n * Asutosh Rana\n */\n\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n\tlong MOD = 1000000007;\n\tInputReader in;\n\tBufferedReader br;\n\tPrintWriter out;\n\n\tpublic static void main(String[] args) throws java.lang.Exception {\n\t\tMain solver = new Main();\n\t\tsolver.in = new InputReader(System.in);\n\t\tsolver.br = new BufferedReader(new InputStreamReader(System.in));\n\t\tsolver.out = new PrintWriter(System.out);\n\t\tsolver.solve();\n\t\tsolver.out.flush();\n\t\tsolver.out.close();\n\t}\n\n\tint[] A;\n\tint N;\n\t\n\tpublic void solve() {\n\n\t\tint tc = 1;//in.readInt();\n\n\t\tfor (int cas = 1; cas <= tc; cas++) {\n\t\t\tN = in.readInt();\n\t\t\tA = new int[N];\n\n\t\t\tfor(int i =0;i<A.length;i++){\n\t\t\t\tString str = in.readString();\n\t\t\t\tif(str.equals(\"f\"))\n\t\t\t\t\tA[i] = 1;\n\t\t\t}\n\t\t\t\n\t\t\tlong[][] dp = new long[N+1][N+1];\n\t\t\t\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tdp[i][0] = 1;\n\t\t\t\t}\n\t\t\t\telse if(A[i-1]!=1){\n\t\t\t\t\tdp[i][N] = dp[i-1][N];\n\t\t\t\t\tfor(int j=N-1;j>=0;j--){\n\t\t\t\t\t\t/* sum of all positions from */\n\t\t\t\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j+1])%MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j-1]%MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong res = 0;\n\t\t\tfor(int i=0;i<=N;i++){\n\t\t\t\tres = (res + dp[N-1][i])%MOD;\n\t\t\t}\n\t\t\tout.println(res);\n\t\t}\n\n\t}\n\n}\n\nclass InputReader {\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic void readInt(int[] A) {\n\t\tfor (int i = 0; i < A.length; i++)\n\t\t\tA[i] = readInt();\n\t}\n\n\tpublic long readLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic void readLong(long[] A) {\n\t\tfor (int i = 0; i < A.length; i++)\n\t\t\tA[i] = readLong();\n\t}\n\n\tpublic double readDouble() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tdouble res = 0;\n\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t}\n\t\tif (c == '.') {\n\t\t\tc = read();\n\t\t\tdouble m = 1;\n\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tm /= 10;\n\t\t\t\tres += (c - '0') * m;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t}\n\t\treturn res * sgn;\n\t}\n\n\tpublic char[] readCharA() {\n\t\treturn readString().toCharArray();\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic String next() {\n\t\treturn readString();\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n\n}", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.Scanner;\n\npublic class codeforces3rd4 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tint i,j;\n\t\tfor(i=0; i<t; i++) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint arr[] = new int[n];\n\t\t\tfor(j=0; j<n; j++) {\n\t\t\t\tarr[j] = sc.nextInt();\n\t\t\t}\n\t\t\tString[] str = makeList(arr);\n\t\t\tfor(j=0; j<n; j++) {\n\t\t\t\tSystem.out.println(str[j]);\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\tstatic String[] makeList(int[] arr) {\n\t\tint n = arr.length;\n\t\tint i,j,m,lastIdx;\n\t\tString str[] = new String[n];\n\t\tstr[0] = \"\" + arr[0];\n\t\tfor(i=1; i<n; i++) {\n\t\t\tm = str[i-1].length();\n\t\t\tj=m-1;\n\t\t\tlastIdx=m;\n\t\t\tstr[i] = \"\";\n\t\t\tif(arr[i] == 1) {\n\t\t\t\tstr[i] = str[i-1] + \".1\";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(j >=0) {\n\t\t\t\twhile(j>=0 && str[i-1].charAt(j) != '.')\n\t\t\t\t\tj--;\n\t\t\t\tif(arr[i] - Integer.parseInt(str[i-1].substring(j+1, lastIdx)) == 1) {\n\t\t\t\t\tstr[i] = str[i-1].substring(0,j+1) + arr[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlastIdx = j;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn str;\n\t}\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1102f {\n\n    public static void main(String[] args) throws IOException {\n        int n = rni(), m = ni(), a[][] = new int[n][];\n        for (int i = 0; i < n; ++i) {\n            a[i] = ria(m);\n        }\n        int delta[][] = new int[n][n], end_delta[][] = new int[n][n], dp[][][] = new int[n][1 << n][n];\n        for (int i = 0; i < n; ++i) {\n            fill(delta[i], IBIG);\n            fill(end_delta[i], IBIG);\n            delta[i][i] = 0;\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                for (int k = 0; k < m; ++k) {\n                    delta[i][j] = delta[j][i] = min(delta[i][j], abs(a[i][k] - a[j][k]));\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = 1; k < m; ++k) {\n                    end_delta[i][j] = min(end_delta[i][j], abs(a[j][k] - a[i][k - 1]));\n                }\n            }\n        }\n        for (int[][] layer : dp) {\n            for (int[] row : layer) {\n                fill(row, IBIG);\n            }\n        }\n        for (int i = 1; i < 1 << n; ++i) {\n            boolean one_bit = Integer.bitCount(i) == 1;\n            for (int j = 0; j < n; ++j) {\n                if ((i & (1 << j)) > 0) {\n                    for (int l = 0; l < n; ++l) {\n                        if ((i & (1 << l)) == 0) {\n                            int max = 0;\n                            for (int k = 0; k < n; ++k) {\n                                if ((one_bit || j != k) && (i & (1 << k)) > 0) {\n                                    max = max(max, min(dp[j][i][k], delta[k][l]));\n                                }\n                            }\n                            // pr(j + \" \");\n                            // pr(Integer.toBinaryString(i) + \" \");\n                            // prln(l, max);\n                            dp[j][i | (1 << l)][l] = max;\n                        }\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i != j) {\n                    // prln(i, j, dp[i][(1 << n) - 1][j]);\n                    ans = max(ans, min(dp[i][(1 << n) - 1][j], end_delta[j][i]));\n                }\n            }\n        }\n        if (n == 1) {\n            ans = maxof(end_delta[0]);\n        }\n        prln(ans);\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(\"yes\");}\n    static void pry() {prln(\"Yes\");}\n    static void prY() {prln(\"YES\");}\n    static void prno() {prln(\"no\");}\n    static void prn() {prln(\"No\");}\n    static void prN() {prln(\"NO\");}\n    static boolean pryesno(boolean b) {prln(b ? \"yes\" : \"no\"); return b;};\n    static boolean pryn(boolean b) {prln(b ? \"Yes\" : \"No\"); return b;}\n    static boolean prYN(boolean b) {prln(b ? \"YES\" : \"NO\"); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(\"hlfd\"); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author cunbidun\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BSportMafia solver = new BSportMafia();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BSportMafia {\n        private InputReader in;\n        private OutputWriter out;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            this.in = in;\n            this.out = out;\n            long n = in.nextInt();\n            long k = in.nextInt();\n            for (long i = 1; i * (i + 1) / 2 + i <= n + k; i++) {\n                if (i * (i + 1) / 2 + i == n + k) {\n                    out.println(n - i);\n                    return;\n                }\n            }\n        }\n\n    }\n\n    static class InputReader extends InputStream {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 16];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter out;\n\n        public OutputWriter(OutputStream outputStream) {\n            out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.out = new PrintWriter(writer);\n        }\n\n        public void close() {\n            out.close();\n        }\n\n        public void println(long i) {\n            out.println(i);\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.util.Scanner;\n\npublic class Subtractions {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numberOfTests = scanner.nextInt();\n        while (numberOfTests-- > 0) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int[] res = new int[1];\n            compute(a, b, res);\n            System.out.println(res[0]);\n        }\n    }\n\n    private static void compute(int x, int y, int[] res) {\n        if (x == 0 || y == 0) {\n            return;\n        }\n        int tmp;\n        if (x < y) {\n            tmp = x;\n            x = y;\n            y = tmp;\n        }\n        res[0] += x / y;\n        tmp = x % y;\n        if (tmp == 0) {\n            return;\n        }\n        x = y;\n        y = tmp;\n        compute(x, y, res);\n    }\n}\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "//package Dp_bitmasking;\nimport java.util.*;\npublic class Fish {\n\tstatic double[][] prob;\n\tstatic double[] dp=new double[1<<19];\n\tstatic double pmove(int mask,int fish_to_kill,int n) {\n\t\tint count=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif((mask&(1<<i))!=0) {\n\t\t\t\t++count;\n\t\t\t}\n\t\t}\n\t\tlong totalPairs=(count*(count-1))/2;\n\t\tdouble prob_die=0;\n\t\tfor(int fish=0;fish<n;fish++) {\n\t\t\tif((mask&(1<<fish))!=0) {\n\t\t\t\tprob_die+=prob[fish][fish_to_kill];\n\t\t\t}\n\t\t}\n\t\treturn prob_die/totalPairs;\n\t}\n\t\n\tstatic double solve(int mask,int n) {\n\t\tif(mask==((1<<n)-1)) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(dp[mask]>-0.9) {\n\t\t\treturn dp[mask];\n\t\t}\n\t\tdouble ans=0;\n\t\tfor(int fish=0;fish<n;fish++) {\n\t\t\tif((mask&(1<<fish))==0) {\n\t\t\t\tint prev_mask=mask|(1<<fish);\n\t\t\t\tans+=pmove(prev_mask,fish,n)*solve(prev_mask,n);\n\t\t\t}\n\t\t}\n\t\tdp[mask]=ans;\n\t\treturn dp[mask];\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tprob=new double[n][n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tprob[i][j]=sc.nextDouble();\n\t\t\t}\n\t\t}\n\t\tArrays.fill(dp, -1);\n\t\tfor(int i=0;i<n;i++) {\n\n\t\t\tSystem.out.print(String.format(\"%.06f\", solve(1<<i,n))+\" \");\n\t\t}\n\t\t\n\t}\n\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class P911d {\n\n  private static void solve() {\n    int n = nextInt();\n\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++) {\n      a[i] = nextInt();\n    }\n\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if (a[i] > a[j]) {\n          cnt++;\n        }\n      }\n    }\n\n    cnt %= 2;\n\n    int m = nextInt();\n    for (int i = 0; i < m; i++) {\n      int l = nextInt();\n      int r = nextInt();\n\n      int size = r - l + 1;\n      int sum = (size * (size - 1)) / 2;\n\n      sum %= 2;\n\n      cnt += sum;\n      cnt %= 2;\n\n      out.println(cnt == 0 ? \"even\" : \"odd\");\n    }\n  }\n\n  private static void run() {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    out = new PrintWriter(System.out);\n\n    solve();\n\n    out.close();\n  }\n\n  private static StringTokenizer st;\n  private static BufferedReader br;\n  private static PrintWriter out;\n\n  private static String next() {\n    while (st == null || !st.hasMoreElements()) {\n      String s;\n      try {\n        s = br.readLine();\n      } catch (IOException e) {\n        return null;\n      }\n      st = new StringTokenizer(s);\n    }\n    return st.nextToken();\n  }\n\n  private static int nextInt() {\n    return Integer.parseInt(next());\n  }\n\n  private static long nextLong() {\n    return Long.parseLong(next());\n  }\n\n  public static void main(String[] args) {\n    run();\n  }\n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.HashSet;\n\npublic class E17 {\n\n\tstatic StreamTokenizer in;\n\tstatic PrintWriter out;\n\t\n\tstatic int nextInt() throws IOException {\n\t\tin.nextToken();\n\t\treturn (int)in.nval;\n\t}\n\t\n\tstatic String nextString() throws IOException {\n\t\tin.nextToken();\n\t\treturn in.sval;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tint n = nextInt(), k = nextInt();\n\t\tint MAX = n, nprimes = 0;\n\t\tint[] primes = new int[MAX];\n\t\tboolean[] isPrime = new boolean[MAX+1];\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = false;\n\t\tisPrime[1] = false;\n\t\tfor (int i = 2; i <= MAX; i++) if (isPrime[i]) {\n\t\t\tprimes[nprimes++] = i;\n\t\t\tfor (int j = i + i; j <= MAX; j += i) isPrime[j] = false;\n\t\t}\n\t\tprimes[nprimes] = Integer.MAX_VALUE;\n\t\t\n\t\tHashSet<Integer> h = new HashSet<Integer>();\n\t\tfor (int i = 1; i < nprimes; i++) {\n\t\t\tint x = primes[i-1] + primes[i] + 1;\n\t\t\tif (x > n) break;\n\t\t\tif (isPrime[x]) h.add(x);\n\t\t}\n\t\t\n\t\tout.println(h.size() >= k ? \"YES\" : \"NO\");\n\t\t\n\t\tout.flush();\n\t}\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "//package codeforces.B;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Pipeline {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(bufferedReader.readLine(), \" \");\n        long n = Long.parseLong(tokenizer.nextToken());\n        long k = Long.parseLong(tokenizer.nextToken());\n        if (n == 1) {\n            System.out.println(0);\n        } else if (k >= n) {\n            System.out.println(1);\n        } else {\n            n -= 1;\n            k -= 1;\n\n            if (sum(k) < n) {\n                System.out.println(-1);\n            } else {\n                System.out.println(sumOfPipes(n, k));\n            }\n        }\n\n\n    }\n\n    private static long sum(long k) {\n        return k * (k + 1) / 2;\n    }\n\n    private static long sum(long left, long right) {\n        long s = 0;\n        if (left <= right) {\n            s = sum(right) - sum(left - 1);\n        }\n        return s;\n    }\n\n    private static long sumOfPipes(long n, long k) {\n\n        long left = 1;\n        long right = k;\n\n        while (left < right) {\n            long mid = (left + right) / 2;\n            long s = sum(mid, k);\n            if (s == n) {\n                return k - mid + 1;\n            } else if (s > n) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n\n        return k - left + 2;\n    }\n}\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class CF125D2A {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"0 0 \" + sc.nextInt());\n    }\n}", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\npublic class C {\n\tstatic class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static FastReader s = new FastReader();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    private static int[] rai(int n) {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextInt();\n        }\n        return arr;\n    }\n\n    private static int[][] rai(int n, int m) {\n        int[][] arr = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                arr[i][j] = s.nextInt();\n            }\n        }\n        return arr;\n    }\n\n    private static long[] ral(int n) {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextLong();\n        }\n        return arr;\n    }\n\n    private static long[][] ral(int n, int m) {\n        long[][] arr = new long[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                arr[i][j] = s.nextLong();\n            }\n        }\n        return arr;\n    }\n\n    private static int ri() {\n        return s.nextInt();\n    }\n\n    private static long rl() {\n        return s.nextLong();\n    }\n\n    private static String rs() {\n        return s.next();\n    }\n    static int n;\n    static long dp[][];\n    static List<Integer> adj[];\n    static int cost[][];\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tFastReader sc=new FastReader();\n\t\tint t,m=0,i=0,j=0,k=0,c=0,fg=0,p=0,q=0,tm=0,a=0,b=0,x=0,y=0,z=0,max=-1,min=Integer.MAX_VALUE;\n\t\tString str;\n\t\tlong sum=0,ans=0;\n\t\tBigInteger f=BigInteger.valueOf(0);\n\t\tt=sc.nextInt();\n\t\twhile(t-->0)\n\t\t{\n\t\t\tn=sc.nextInt();\n\t\t\tList<Integer> pre=new ArrayList();\n\t\t\twhile(n-->0)\n\t\t\t{\n\t\t\t\ta=sc.nextInt();\n\t\t\t\tList<Integer> l=new ArrayList();\n\t\t\t\tif(a==1)\n\t\t\t\t{\n\t\t\t\t\tfor(i=0;i<pre.size();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.print(pre.get(i)+\".\");\n\t\t\t\t\t\tl.add(pre.get(i));\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(a);\n\t\t\t\t\tl.add(a);\n\t\t\t\t\tpre=new ArrayList(l);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(i=pre.size()-1;i>=0;i--)\n\t\t\t\t\t\tif(a-pre.get(i)==1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tfor(j=0;j<i;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.print(pre.get(j)+\".\");\n\t\t\t\t\t\tl.add(pre.get(j));\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(a);\n\t\t\t\t\tl.add(a);\n\t\t\t\t\tpre=new ArrayList(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "//package ;\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n\tstatic int dp(int i,int start,int msk)\n\t{\n\t\tif(Integer.bitCount(msk)==n)\n\t\t\treturn s_e[i][start];\n\n\t\tif(dp[i][start][msk]!=-1)\n\t\t\treturn dp[i][start][msk];\n\t\t\n\t\tint max=0;\n\t\tfor(int k=0;k<n;k++)\n\t\t{\t\n\t\t\tint min=Integer.MAX_VALUE;\n\t\t\tif((msk & (1<<k)) == 0 )\n\t\t\t{\n\t\t\t\tmin=diff[i][k];\n\t\t\t\tmin=Math.min(min, dp(k,start,msk | (1<<k)));\n\t\t\t\tmax=Math.max(max, min);\n\t\t\t}\n\t\t}\n\t\treturn dp[i][start][msk]=max;\n\t}\n\tstatic int n,m,a[][],dp[][][],diff[][],s_e[][];\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tn=sc.nextInt();\n\t\tm=sc.nextInt();\n\t\ta=new int[n][m];\n\t\tdiff=new int[n][n];\n\t\ts_e=new int[n][n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t\ta[i][j]=sc.nextInt();\n\t\t\n\t\tdp=new int[n][n][70000];\n\t\tint ans=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\t\n\t\t\t\tArrays.fill(dp[i][j], -1);\n\t\t\t\tdiff[i][j]=Integer.MAX_VALUE;\n\t\t\t\ts_e[i][j]=Integer.MAX_VALUE;\n\t\t\t\tfor(int k=0;k<m-1;k++)\n\t\t\t\t{\t\n\t\t\t\t\tdiff[i][j]=Math.min(Math.abs(a[i][k]-a[j][k]), diff[i][j]);\n\t\t\t\t\ts_e[i][j]=Math.min(Math.abs(a[i][k]-a[j][k+1]), s_e[i][j]);\n\t\t\t\t}\n\t\t\t\tdiff[i][j]=Math.min(Math.abs(a[i][m-1]-a[j][m-1]), diff[i][j]);\n\t\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tans=Math.max(ans, dp(i,i,1<<i));\n\t\t\n\t\tpw.print(ans);\n\t\tpw.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tboolean hasnext() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n}\n", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            HashMap<String, Integer> map = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                String next = in.next();\n                map.put(next, map.getOrDefault(next, 0) + 1);\n            }\n            int ct = 0;\n            for (int i = 0; i < n; i++) {\n                String next = in.next();\n                if (map.containsKey(next)) {\n                    map.put(next, map.get(next) - 1);\n                    if (map.get(next) <= 0) {\n                        map.remove(next);\n                    }\n                }\n            }\n            for (Map.Entry<String, Integer> entry : map.entrySet()) {\n                ct += entry.getValue();\n            }\n            out.println(ct);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public int nextInt() {\n            return readInt();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        F2SameSumBlocksHard solver = new F2SameSumBlocksHard();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class F2SameSumBlocksHard {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n\n            long[] a = in.nextLongArray(n);\n\n            long[] p = in.calculatePrefixSum(a);\n\n            Map<Long, Integer> map = new HashMap<>();\n\n            for (int i = 0; i < n; i++) {\n                long sum = 0;\n                for (int j = i; j < n; j++) {\n                    sum += a[j];\n                    map.merge(sum, 1, (x, y) -> x + y);\n                }\n            }\n\n\n            List<sum> sums = new ArrayList<>();\n            for (long sum : map.keySet()) {\n                sums.add(new sum(sum, map.get(sum)));\n            }\n\n            sums.sort((x, y) -> y.c - x.c);\n\n            int ans = -1;\n\n            int[] fca = null;\n            long mxsum = -1;\n            for (int i = 0; i < sums.size(); i++) {\n                sum cs = sums.get(i);\n                long sum = cs.sum;\n                long c = cs.c;\n\n                if (c < ans) {\n                    continue;\n                }\n\n                Map<Long, Integer> lm = new HashMap<>();\n\n                int[] ca = new int[n];\n                lm.put(0l, -1);\n                for (int j = 0; j < n; j++) {\n                    long val = p[j];\n\n                    if (j > 0) {\n                        ca[j] = ca[j - 1];\n                    }\n                    long req = val - sum;\n\n                    if (lm.containsKey(req)) {\n                        int li = lm.get(req);\n                        if (li == -1)\n                            ca[j] = Math.max(1, ca[j]);\n                        else\n                            ca[j] = Math.max(1 + ca[li], ca[j]);\n                    }\n\n                    lm.put(val, j);\n                }\n\n                if (ca[n - 1] > ans) {\n                    ans = ca[n - 1];\n                    mxsum = sum;\n                    fca = ca;\n                }\n            }\n\n            List<Integer> al = new ArrayList<>();\n\n            long sum = 0;\n            for (int i = n - 1; i >= 0; i--) {\n                if (i > 0 && fca[i] != fca[i - 1]) {\n                    sum = 0;\n                    al.add(i + 1);\n                    do {\n                        sum += a[i];\n                        i--;\n                    } while (i >= 0 && sum != mxsum);\n                    i++;\n                    al.add(i + 1);\n                } else if (i == 0) {\n                    if (a[i] == mxsum) {\n                        al.add(i + 1);\n                        al.add(i + 1);\n                    }\n                }\n            }\n\n            out.println(al.size() / 2);\n\n            for (int i = al.size() - 1; i >= 0; i -= 2) {\n                out.println(al.get(i) + \" \" + al.get(i - 1));\n            }\n        }\n\n        class sum {\n            long sum;\n            int c;\n\n            public sum(long sum, int c) {\n                this.sum = sum;\n                this.c = c;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] array = new long[n];\n            for (int i = 0; i < n; ++i) array[i] = nextLong();\n            return array;\n        }\n\n        public long[] calculatePrefixSum(long[] a) {\n            int n = a.length;\n\n            long[] prefixSum = new long[n];\n\n            prefixSum[0] = a[0];\n\n            for (int i = 1; i < n; i++) {\n                prefixSum[i] = prefixSum[i - 1] + a[i];\n            }\n\n            return prefixSum;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "\n\nimport java.io.BufferedReader;\n\nimport java.io.InputStreamReader;\n\n\n\n/*\n\n * To change this template, choose Tools | Templates\n\n * and open the template in the editor.\n\n */\n\n/**\n\n *\n\n * @author pttrung\n\n */\n\npublic class D {\n\n\n\n    static long[][][][][] dp;\n\n    static String l, r;\n\n\n\n    public static void main(String[] args) {\n\n        try {\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n            String[] temp = in.readLine().split(\" \");\n\n            long L = Long.parseLong(temp[0]);\n\n            long R = Long.parseLong(temp[1]);\n\n\n\n            if (L == R) {\n\n                System.out.println(0);\n\n            } else {\n\n                dp = new long[64][2][2][2][2];\n\n                l = convert(L);\n\n                r = convert(R);\n\n                if (r.length() > l.length()) {\n\n                    while (r.length() > l.length()) {\n\n                        l = '0' + l;\n\n                    }\n\n                }\n\n                for (int i = 0; i < dp.length; i++) {\n\n                    for (int j = 0; j < dp[0].length; j++) {\n\n                        for (int k = 0; k < dp[0][0].length; k++) {\n\n                            for (int m = 0; m < dp[0][0][0].length; m++) {\n\n                                for (int n = 0; n < dp[0][0][0][0].length; n++) {\n\n                                    dp[i][j][k][m][n] = -1;\n\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n                long result = cal(0, 0, 0, 0, 0);\n\n                System.out.println(result);\n\n            }\n\n            // System.out.println(l + \" \" + r);\n\n\n\n        } catch (Exception ex) {\n\n            ex.printStackTrace();\n\n        }\n\n    }\n\n\n\n    public static long cal(int p, int AcL, int AcR, int BcL, int BcR) {\n\n        if (p == l.length()) {\n\n            return 0;\n\n        }\n\n        if (dp[p][AcL][AcR][BcL][BcR] != -1) {\n\n            return dp[p][AcL][AcR][BcL][BcR];\n\n        }\n\n        int min1 = 0, max1 = 1;\n\n        if (AcL == 0 && l.charAt(p) == '1') {\n\n            min1 = 1;\n\n        }\n\n        if (AcR == 0 && r.charAt(p) == '0') {\n\n            max1 = 0;\n\n        }\n\n        int min2 = 0, max2 = 1;\n\n        if (BcL == 0 && l.charAt(p) == '1') {\n\n            min2 = 1;\n\n        }\n\n        if (BcR == 0 && r.charAt(p) == '0') {\n\n            max2 = 0;\n\n        }\n\n        long result = 0;\n\n        for (int i = min1; i <= max1; i++) {\n\n            for (int j = min2; j <= max2; j++) {\n\n                long v = i ^ j;\n\n                if (v == 1) {\n\n                    //reverse , as this p is the position from left to right\n\n                    v = 1L << (r.length() - p - 1);\n\n                }\n\n                // System.out.println(val);\n\n                int acL = AcL, acR = AcR, bcL = BcL, bcR = BcR;\n\n                if (i == 1 && l.charAt(p) == '0') {\n\n                    acL = 1;\n\n                }\n\n                if (i == 0 && r.charAt(p) == '1') {\n\n                    acR = 1;\n\n                }\n\n                if (j == 1 && l.charAt(p) == '0') {\n\n                    bcL = 1;\n\n                }\n\n                if (j == 0 && r.charAt(p) == '1') {\n\n                    bcR = 1;\n\n                }\n\n                long total = v + cal(p + 1, acL, acR, bcL, bcR);\n\n                result = Math.max(total, result);\n\n            }\n\n        }\n\n        dp[p][AcL][AcR][BcL][BcR] = result;\n\n        return result;\n\n    }\n\n\n\n    public static String convert(long val) {\n\n        StringBuilder builder = new StringBuilder();\n\n        while (val > 0) {\n\n            if ((val & 1) == 1) {\n\n                builder.insert(0, '1');\n\n            } else {\n\n                builder.insert(0, '0');\n\n            }\n\n            val >>= 1;\n\n        }\n\n        return builder.toString();\n\n    }\n\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CF_Chores {\n\n    \n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        \n        int n = s.nextInt();\n        int a = s.nextInt();\n        int b = s.nextInt();\n        \n        long ar[] = new long[n];\n        for (int i = 0; i < n; i++) {\n            ar[i]=s.nextLong();\n        }\n        Arrays.sort(ar);\n        \n        long ret = 0;\n//      System.out.println(Arrays.toString(ar));\n        if(ar[b]==ar[b-1])\n            System.out.println(\"0\");\n        else {\n            ret = ar[b]-ar[b-1];\n            System.out.println(ret);\n        }\n        \n    }\n\n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "/**\n * Problem: \n * Source: \n * Link: \n * \n * @author Alexei Ostrovski\n */\n\nimport java.io.*;\nimport java.util.*;\n\n\npublic class SpidersSolver {\n\n\tpublic static final boolean DEBUG = false;\n\t\n\tpublic static void main(String[] args) {\n\t\t//redirect input and output\n\t\tif (DEBUG)\n\t\t{\n\t\t\ttry {\n\t\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n\t\t\t\t//System.setOut(new PrintStream(\"input.txt\"));\n\t\t\t} catch (IOException e) {\n\t\t\t\t//nothing\n\t\t\t}\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t//read data\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\t\n\t\t//solve\n\t\tif (n < m) {\n\t\t\tint tmp = n;\n\t\t\tn = m;\n\t\t\tm = tmp;\n\t\t}\n\t\t// Now (n >= m) && (m <= 6)\n\t\tint pow = 1;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tpow *= 2;\n\n\t\tint[] count = new int[pow];\n\t\tfor (int cur = 0; cur < pow; cur++)\n\t\t{\n\t\t\tint x = cur;\n\t\t\twhile (x > 0)\n\t\t\t{\n\t\t\t\tcount[cur] += (x % 2);\n\t\t\t\tx /= 2;\n\t\t\t}\n\t\t\tcount[cur] = m - count[cur];\n\t\t}\n\t\t//System.out.println(Arrays.toString(count));\n\t\t\n\t\tint[][] C = new int[pow][pow];\n\t\tfor (int cur = 0; cur < pow; cur++)\n\t\t{\n\t\t\tC[0][cur] = 0;//count[cur];\n\t\t\tfor (int last = 1; last < pow; last++)\n\t\t\t\tC[last][cur] = Integer.MIN_VALUE;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint[][] newC = new int[pow][pow];\n\t\t\t\n\t\t\tfor (int cur = 0; cur < pow; cur++)\n\t\t\t\tfor (int next = 0; next < pow; next++)\n\t\t\t\t{\n\t\t\t\t\tint mask = cur | (cur << 1) | (cur >> 1) | next;\n\t\t\t\t\tmask %= pow;\n\t\t\t\t\t\n\t\t\t\t\tint max = 0;\n\t\t\t\t\tfor (int last = 0; last < pow; last++)\n\t\t\t\t\t\tif (((last | mask) == pow - 1) && (max < count[cur] + C[last][cur]))\n\t\t\t\t\t\t\tmax = count[cur] + C[last][cur];\n\t\t\t\t\t\n\t\t\t\t\tnewC[cur][next] = max;\n\t\t\t\t}\n\t\t\tC = newC;\n\t\t}\n\t\t\n\t\tint result = 0;\n\t\tfor (int cur = 0; cur < pow; cur++)\n\t\t\tresult = Math.max(result, C[cur][0]);\n\t\t\t\n\t\t//output\n\t\tSystem.out.println(result);\n\t}\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Template {\n\n\tstatic int mod = 1000000007;\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint yo = sc.nextInt();\n\t\twhile (yo-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] a = sc.readInts(n);\n\t\t\t\n\t\t\tStack<Integer> stack = new Stack<>();\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tadd(stack,a[i]);\n\t\t\t\tprintStack(stack,out);\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\n\n\t\n\tprivate static void add(Stack<Integer> stack, int num) {\n\t\tif(stack.isEmpty()) {\n\t\t\tstack.add(num);\n\t\t\treturn;\n\t\t}\n\t\tif(num == 1) {\n\t\t\tstack.add(num);\n\t\t\treturn;\n\t\t}\n\t\twhile(!stack.isEmpty()) {\n\t\t\tint curr = stack.pop();\n\t\t\tif(curr + 1 == num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstack.add(num);\n\t}\n\n\n\tpublic static void printStack(Stack<Integer> stack, PrintWriter out) {\n\t\tStack<Integer> stack2 = new Stack<>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!stack.isEmpty()) {\n\t\t\tstack2.add(stack.pop());\n\t\t}\n\t\twhile(!stack2.isEmpty()) {\n\t\t\tint num = stack2.pop();\n\t\t\tif(stack2.isEmpty()) {\n\t\t\t\tsb.append(num+\"\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(num + \".\");\n\t\t\t}\n\t\t\tstack.add(num);\n\t\t}\n\t\tout.println(sb.toString());\n\t}\n\t\n\tpublic static class Pair {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tpublic static void sort(int[] arr) {\n\t\tArrayList<Integer> ls = new ArrayList<Integer>();\n\t\tfor (int x : arr)\n\t\t\tls.add(x);\n\t\tCollections.sort(ls);\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tarr[i] = ls.get(i);\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\n\n\tstatic boolean[] sieve(int N) {\n\t\tboolean[] sieve = new boolean[N + 1];\n\t\tfor (int i = 2; i <= N; i++)\n\t\t\tsieve[i] = true;\n\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tif (sieve[i]) {\n\t\t\t\tfor (int j = 2 * i; j <= N; j += i) {\n\t\t\t\t\tsieve[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sieve;\n\t}\n\n\tpublic static long power(long x, long y, long p) {\n\t\tlong res = 1L;\n\t\tx = x % p;\n\t\twhile (y > 0) {\n\t\t\tif ((y & 1) == 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\ty >>= 1;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void print(int[] arr) {\n\t\t//for debugging only\n\t\tfor (int x : arr)\n\t\t\tout.print(x + \" \");\n\t\tout.println();\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate int BS = 1 << 16;\n\t\tprivate char NC = (char) 0;\n\t\tprivate byte[] buf = new byte[BS];\n\t\tprivate int bId = 0, size = 0;\n\t\tprivate char c = NC;\n\t\tprivate double cnt = 1;\n\t\tprivate BufferedInputStream in;\n\n\t\tpublic FastScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t\t} catch (Exception e) {\n\t\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t\t}\n\t\t}\n\n\t\tprivate char getChar() {\n\t\t\twhile (bId == size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}\n\t\t\t\tif (size == -1)\n\t\t\t\t\treturn NC;\n\t\t\t\tbId = 0;\n\t\t\t}\n\t\t\treturn (char) buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int) nextLong();\n\t\t}\n\n\t\tpublic int[] readInts(int N) {\n\t\t\tint[] res = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = (int) nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] readLongs(int N) {\n\t\t\tlong[] res = new long[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tcnt = 1;\n\t\t\tboolean neg = false;\n\t\t\tif (c == NC)\n\t\t\t\tc = getChar();\n\t\t\tfor (; (c < '0' || c > '9'); c = getChar()) {\n\t\t\t\tif (c == '-')\n\t\t\t\t\tneg = true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor (; c >= '0' && c <= '9'; c = getChar()) {\n\t\t\t\tres = (res << 3) + (res << 1) + c - '0';\n\t\t\t\tcnt *= 10;\n\t\t\t}\n\t\t\treturn neg ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c != '.' ? cur : cur + nextLong() / cnt;\n\t\t}\n\n\t\tpublic double[] readDoubles(int N) {\n\t\t\tdouble[] res = new double[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile (c <= 32)\n\t\t\t\tc = getChar();\n\t\t\twhile (c > 32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc = getChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile (c <= 32)\n\t\t\t\tc = getChar();\n\t\t\twhile (c != '\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc = getChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif (c > 32)\n\t\t\t\treturn true;\n\t\t\twhile (true) {\n\t\t\t\tc = getChar();\n\t\t\t\tif (c == NC)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (c > 32)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\t//\tFor Input.txt and Output.txt\t\n\t//\tFileInputStream in = new FileInputStream(\"input.txt\");\n\t//\tFileOutputStream out = new FileOutputStream(\"output.txt\");\n\t//\tPrintWriter pw = new PrintWriter(out);\n\t//\tScanner sc = new Scanner(in);\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "//package round85;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class C2 {\n\tScanner in;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint m = ni();\n\t\tboolean[][] f = new boolean[99][99];\n\t\tcache = new HashSet<Long>();\n\t\tout.println(n*m-rec(f, n, m, 0, 0, 0));\n\t}\n\t\n\tSet<Long> cache;\n\t\n\tlong hash(boolean[][] f, int n, int m, int r, int c, int cur)\n\t{\n\t\tlong x = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tif(f[i][j])x |= 1L<<i*m+j;\n\t\t\t}\n\t\t}\n\t\tx = x * n + r;\n\t\tx = x * m + c;\n\t\tx = x * 41 + cur;\n\t\treturn x;\n\t}\n\t\n\tint rec(boolean[][] f, int n, int m, int r, int c, int cur)\n\t{\n\t\tif(r == n)return cur;\n\t\tif(c >= m)return rec(f, n, m, r+1, 0, cur);\n\t\tlong h = hash(f, n, m, r, c, cur);\n\t\tif(cache.contains(h))return 99999;\n\t\tcache.add(h);\n\t\tint min = f[r][c] ? rec(f, n, m, r, c+1, cur) : 99999;\n\t\t{\n\t\t\tboolean[] memo = new boolean[]{f[r][c], f[r+1][c], f[r][c+1]};\n\t\t\tf[r][c] = true;\n\t\t\tf[r+1][c] = true;\n\t\t\tf[r][c+1] = true;\n\t\t\tmin = Math.min(min, rec(f, n, m, r, c+2, cur+1));\n\t\t\tf[r][c] = memo[0];\n\t\t\tf[r+1][c] = memo[1];\n\t\t\tf[r][c+1] = memo[2];\n\t\t}\n\t\t{\n\t\t\tboolean[] memo = new boolean[]{f[r][c], f[r+1][c], f[r+2][c], f[r+1][c+1], c-1>=0 ? f[r+1][c-1] : false};\n\t\t\tf[r][c] = true;\n\t\t\tf[r+1][c] = true;\n\t\t\tf[r+2][c] = true;\n\t\t\tf[r+1][c+1] = true;\n\t\t\tif(c-1 >= 0)f[r+1][c-1] = true;\n\t\t\tmin = Math.min(min, rec(f, n, m, r, c+1, cur+1));\n\t\t\tf[r][c] = memo[0];\n\t\t\tf[r+1][c] = memo[1];\n\t\t\tf[r+2][c] = memo[2];\n\t\t\tf[r+1][c+1] = memo[3];\n\t\t\tif(c-1 >= 0)f[r+1][c-1] = memo[4];\n\t\t}\n\t\t{\n\t\t\tboolean[] memo = new boolean[]{f[r][c], f[r][c+1], f[r][c+2], f[r+1][c+1]};\n\t\t\tf[r][c] = true;\n\t\t\tf[r][c+1] = true;\n\t\t\tf[r][c+2] = true;\n\t\t\tf[r+1][c+1] = true;\n\t\t\tmin = Math.min(min, rec(f, n, m, r, c+3, cur+1));\n\t\t\tf[r][c] = memo[0];\n\t\t\tf[r][c+1] = memo[1];\n\t\t\tf[r][c+2] = memo[2];\n\t\t\tf[r+1][c+1] = memo[3];\n\t\t}\n\t\treturn min;\n\t}\n\n\tint count(int n, int m, int p, int step)\n\t{\n\t\tint[] dr = {1, 0, -1, 0, 0};\n\t\tint[] dc = {0, 1, 0, -1, 0};\n\t\t\n\t\t// (0,i)\n\t\tint ct = 0;\n\t\tboolean[][] f = new boolean[n][m];\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\tif(k % 5 == p){\n\t\t\t\t\tct++;\n\t\t\t\t\tfor(int l = 0;l < 5;l++){\n\t\t\t\t\t\tint nr = j+dr[l];\n\t\t\t\t\t\tint nc = k+dc[l];\n\t\t\t\t\t\tif(nr >= 0 && nr < n && nc >= 0 && nc < m){\n\t\t\t\t\t\t\tf[nr][nc] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = (p+step)%5;\n\t\t}\n\t\t\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\tif(!f[j][k]){\n\t\t\t\t\tct++;\n\t\t\t\t\tfor(int l = 0;l < 5;l++){\n\t\t\t\t\t\tint nr = j+dr[l];\n\t\t\t\t\t\tint nc = k+dc[l];\n\t\t\t\t\t\tif(nr >= 0 && nr < n && nc >= 0 && nc < m){\n\t\t\t\t\t\t\tf[nr][nc] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ct;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tin = oj ? new Scanner(System.in) : new Scanner(INPUT);\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew C2().run();\n\t}\n\t\n\tint ni() { return Integer.parseInt(in.next()); }\n\tlong nl() { return Long.parseLong(in.next()); }\n\tdouble nd() { return Double.parseDouble(in.next()); }\n\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tvoid tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "np", "problem": "0111_C", "from": "CODEFORCES", "tags": "bitmasks,dp,dsu"}
{"src": "import java.util.Scanner;\n \npublic class pillar {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint a[]=new int[200005];\n\t\tfor (int i=1;i<=n;i++) \n\t\ta[i]=sc.nextInt();\n\t\tfor (int i=2;i<n;i++) \n\t\tif (a[i-1]>a[i]&&a[i]<a[i+1]) {\n\t\t\tSystem.out.println(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t}\n}\n\n", "complexity": "linear", "problem": "1197_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.util.Scanner;\n\n\npublic class prob1 {\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint n = input.nextInt();\n\t\tif(n == 1)\n\t\t{\n//\t\t\tthrow new RuntimeException();\n\t\t\tint m = input.nextInt();\n\t\t\tSystem.out.println(\"NO\");\n//\t\t\tSystem.out.println(input.next());\n\t\t\treturn;\n\t\t}\n\t\tint[] num = new int[n];\n\t\tboolean flag  = false;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnum[i] = input.nextInt();\n\t\t\tif(num[i] != num[0])\n\t\t\t\tflag = true;\n\t\t}\n\t\tif(!flag)\n\t\t{\n\t\t\tSystem.out.println(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(num[i] < min)\n\t\t\t\tmin = num[i];\n\t\tint min2 = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(num[i] <= min2 && num[i] > min)\n\t\t\t\tmin2 = num[i];\n\t\tSystem.out.println(min2);\n\t\t\n\t}\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.Scanner;\n\npublic class LCM {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        long n = scan.nextLong();\n\n        if (n <= 2)\n            System.out.println(n);\n        else if (n % 2 == 1)\n            System.out.println(n * (n - 1) * (n - 2));\n        else if (n % 3 == 0)\n            System.out.println((n - 1) * (n - 2) * (n - 3));\n        else\n            System.out.println(n * (n - 1) * (n - 3));\n    }\n}\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.util.concurrent.*;\n\npublic final class py_indent\n{\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\tstatic FastScanner sc=new FastScanner(br);\n    static PrintWriter out=new PrintWriter(System.out);\n\tstatic Random rnd=new Random();\n\tstatic int maxn=(int)(5e3+5);\n\tstatic long mod=(long)(1e9+7);\n\t\n\tstatic int add(long a,long b)\n\t{\n\t\tlong ret=(a+b);\n\t\t\n\t\tif(ret>=mod)\n\t\t{\n\t\t\tret%=mod;\n\t\t}\n\t\t\n\t\treturn (int)ret;\n\t}\n\t\n    public static void main(String args[]) throws Exception\n    {\n\t\tint n=sc.nextInt();char[] a=new char[n+1];a[0]='s';\n\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\ta[i]=sc.next().charAt(0);\n\t\t}\n\t\t\n\t\tint[][] dp=new int[n+1][maxn],sum=new int[n+1][maxn];dp[0][0]=1;\n\t\t\n\t\tsum[0][0]=1;\n\t\t\n\t\tfor(int i=1;i<maxn;i++)\n\t\t{\n\t\t\tsum[0][i]=add(sum[0][i],sum[0][i-1]);\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]=='f')\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint curr=0,idx=0;\n\t\t\t\n\t\t\tfor(int j=i-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(a[j]=='s')\n\t\t\t\t{\n\t\t\t\t\tidx=j;break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurr++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=0;j<maxn;j++)\n\t\t\t{\n\t\t\t\tint up=Math.max(0,j-curr);\n\t\t\t\t\t\n\t\t\t\tlong now=(sum[idx][maxn-1]-(up==0?0:sum[idx][up-1]));\n\t\t\t\t\t\t\t  \n\t\t\t\tnow=add(now,mod);\n\t\t\t\t\t\n\t\t\t\tdp[i][j]=add(dp[i][j],now);\n\t\t\t}\n\t\t\t\n\t\t\tsum[i][0]=dp[i][0];\n\t\t\t\n\t\t\tfor(int j=1;j<maxn;j++)\n\t\t\t{\n\t\t\t\tsum[i][j]=add(dp[i][j],sum[i][j-1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//out.println(dp[2][0]+\" \"+dp[2][1]+\" \"+dp[2][2]);\n\t\t\n\t\tout.println(dp[n][0]);out.close();\n    }\n}\nclass FastScanner\n{\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n\t\n    public String nextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\t\n\tpublic String next() throws Exception {\n\t\treturn nextToken().toString();\n\t}\n\t\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    StreamTokenizer in;\n    PrintWriter out;\n\n    public static void main(String[] args) throws Exception {\n        new Main().run();\n    }\n\n    public void run() throws Exception {\n        in = new StreamTokenizer (new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n        solve();\n        out.flush();\n    }\n    \n    int nextInt() throws Exception {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n\n    public void solve() throws Exception {\n        int n=nextInt();\n        long ans=0;\n        for (int i=0;i<n;i+=2)\n            ans+=3;\n        out.println(ans);\n    }\n}", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n/**\n *\n * @Har_Har_Mahadev\n */\n\n/**\n * Main , Solution , Remove Public\n */\npublic class C {\n\n\tprivate static ArrayList<String> ans;\n\tprivate static ArrayList<Integer> lis;\n\tprivate static ArrayList<Integer>[] adj;\n\tprivate static int n;\n\n\tpublic static void process() throws IOException {\n\n\t\tn = sc.nextInt();\n\t\tlis = new ArrayList<Integer>();\n\t\tfor(int i = 0; i<n; i++)lis.add(sc.nextInt());\n\t\tDeque<Integer> q = new LinkedList<Integer>();\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tif(i == 0) {\n\t\t\t\tq.add(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint val = lis.get(i);\n\t\t\t\tif(val == 1)q.add(1);\n\t\t\t\telse {\n\t\t\t\t\twhile(q.peekLast() != val-1)q.pollLast();\n\t\t\t\t\tq.pollLast();\n\t\t\t\t\tq.add(val);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint size = q.size();\n\t\t\tfor(int e : q) {\n\t\t\t\tif(size == 1)System.out.print(e);\n\t\t\t\telse System.out.print(e+\".\");\n\t\t\t\tsize--;\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t}\n\n\t\n\n\t\n\n\n\t//=============================================================================\n\t//--------------------------The End---------------------------------\n\t//=============================================================================\n\tprivate static long INF = 2000000000000000000L, M = 1000000007, MM = 998244353;\n\tprivate static int N = 0;\n\n\tprivate static void google(int tt) {\n\t\tSystem.out.print(\"Case #\" + (tt) + \": \");\n\t}\n\n\tstatic FastScanner sc;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tboolean oj = true;\n\t\tif (oj) {\n\t\t\tsc = new FastScanner();\n\t\t\tout = new PrintWriter(System.out);\n\t\t} else {\n\t\t\tsc = new FastScanner(100);\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t}\n\t\tint t = 1;\n\t\tt = sc.nextInt();\n\t\tint TTT = 1;\n\t\twhile (t-- > 0) {\n\t\t\t//\t\t\tgoogle(TTT++);\n\t\t\tprocess();\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint x, y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn Integer.compare(this.x, o.x);\n\t\t}\n\n\t\t//\t\t @Override\n\t\t//\t\t    public boolean equals(Object o) {\n\t\t//\t\t        if (this == o) return true;\n\t\t//\t\t        if (!(o instanceof Pair)) return false;\n\t\t//\t\t        Pair key = (Pair) o;\n\t\t//\t\t        return x == key.x && y == key.y;\n\t\t//\t\t    }\n\t\t//\t\t \n\t\t//\t\t    @Override\n\t\t//\t\t    public int hashCode() {\n\t\t//\t\t        int result = x;\n\t\t//\t\t        result = 31 * result + y;\n\t\t//\t\t        return result;\n\t\t//\t\t    }\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\tstatic void println(Object o) {\n\t\tout.println(o);\n\t}\n\n\tstatic void println() {\n\t\tout.println();\n\t}\n\n\tstatic void print(Object o) {\n\t\tout.print(o);\n\t}\n\n\tstatic void pflush(Object o) {\n\t\tout.println(o);\n\t\tout.flush();\n\t}\n\n\tstatic int ceil(int x, int y) {\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\n\t}\n\n\tstatic long ceil(long x, long y) {\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int abs(int x) {\n\t\treturn Math.abs(x);\n\t}\n\n\tstatic long abs(long x) {\n\t\treturn Math.abs(x);\n\t}\n\n\tstatic long sqrt(long z) {\n\t\tlong sqz = (long) Math.sqrt(z);\n\t\twhile (sqz * 1L * sqz < z) {\n\t\t\tsqz++;\n\t\t}\n\t\twhile (sqz * 1L * sqz > z) {\n\t\t\tsqz--;\n\t\t}\n\t\treturn sqz;\n\t}\n\n\tstatic int log2(int N) {\n\t\tint result = (int) (Math.log(N) / Math.log(2));\n\t\treturn result;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tBigInteger b1 = BigInteger.valueOf(a);\n\t\tBigInteger b2 = BigInteger.valueOf(b);\n\t\tBigInteger gcd = b1.gcd(b2);\n\t\treturn gcd.intValue();\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tBigInteger b1 = BigInteger.valueOf(a);\n\t\tBigInteger b2 = BigInteger.valueOf(b);\n\t\tBigInteger gcd = b1.gcd(b2);\n\t\treturn gcd.longValue();\n\t}\n\n\tpublic static long lcm(long a, long b) {\n\t\treturn (a * b) / gcd(a, b);\n\t}\n\n\tpublic static int lcm(int a, int b) {\n\t\treturn (a * b) / gcd(a, b);\n\t}\n\n\tpublic static int lower_bound(int[] arr, int x) {\n\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\twhile (low < high) {\n\t\t\tmid = (low + high) / 2;\n\n\t\t\tif (arr[mid] >= x)\n\t\t\t\thigh = mid;\n\t\t\telse\n\t\t\t\tlow = mid + 1;\n\t\t}\n\n\t\treturn low;\n\t}\n\n\tpublic static int upper_bound(int[] arr, int x) {\n\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\twhile (low < high) {\n\t\t\tmid = (low + high) / 2;\n\n\t\t\tif (arr[mid] > x)\n\t\t\t\thigh = mid;\n\t\t\telse\n\t\t\t\tlow = mid + 1;\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner() throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tFastScanner(int a) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tint[] readArray(int n) throws IOException {\n\t\t\tint[] A = new int[n];\n\t\t\tfor (int i = 0; i != n; i++) {\n\t\t\t\tA[i] = sc.nextInt();\n\t\t\t}\n\t\t\treturn A;\n\t\t}\n\n\t\tlong[] readArrayLong(int n) throws IOException {\n\t\t\tlong[] A = new long[n];\n\t\t\tfor (int i = 0; i != n; i++) {\n\t\t\t\tA[i] = sc.nextLong();\n\t\t\t}\n\t\t\treturn A;\n\t\t}\n\t}\n\n\tstatic void ruffleSort(int[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\n\tstatic void ruffleSort(long[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tlong temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.util.*;\n\npublic class B {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner qwe = new Scanner(System.in);\n\t\t\n\t\tint n = qwe.nextInt();\n\t\t\n\t\t//! x11 y11 x12 y12 x21 y21 x22 y22\" \n\t\t\n\t\t\n\t\t\n\t\tint x11 = bins(true,1,2,n,qwe,true);\n\t\tint y11 = bins(true,1,2,n,qwe,false);\n\t\tint x12 = bins(false,0,1,n,qwe,true);\n\t\tint y12 = bins(false,0,1,n,qwe,false);\n\t\tint x21 = bins(true,0,1,n,qwe,true);\n\t\tint y21 = bins(true,0,1,n,qwe,false);\n\t\tint x22 = bins(false,1,2,n,qwe,true);\n\t\tint y22 = bins(false,1,2,n,qwe,false);\n\t\t\n\t\tint[] xsl = {x11,x21};\n\t\tint[] xsr = {x12,x22};\n\t\tint[] ysl = {y11,y21};\n\t\tint[] ysr = {y12,y22};\n\t\t\n\t\t\n\t\tint[] ans = new int[8];\n\t\t\n\t\tfor(int xpl = 0; xpl < 2; xpl++){\n\t\t\tfor(int xpr = 0; xpr < 2; xpr++)\n\t\t\t\tfor(int ypl = 0; ypl < 2; ypl++){\n\t\t\t\t\tfor(int ypr = 0; ypr < 2; ypr++){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(xsl[xpl] <= xsr[xpr] && xsl[1-xpl] <= xsr[1-xpr] && ysl[ypl] <= ysr[ypr] && ysl[1-ypl] <= ysr[1-ypr]){\n\t\t\t\t\t\t\tSystem.out.printf(\"? %d %d %d %d\",xsl[xpl],ysl[ypl],xsr[xpr],ysr[ypr]);\n\t\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t\tSystem.out.flush();\n\t\t\t\t\t\t\tint response1 = qwe.nextInt();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tSystem.out.printf(\"? %d %d %d %d\",xsl[1-xpl],ysl[1-ypl],xsr[1-xpr],ysr[1-ypr]);\n\t\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t\tSystem.out.flush();\n\t\t\t\t\t\t\tint response2 = qwe.nextInt();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(response1 == 1 && response2 == 1){\n\t\t\t\t\t\t\t\tans = new int[]{xsl[xpl],ysl[ypl],xsr[xpr],ysr[ypr],xsl[1-xpl],ysl[1-ypl],xsr[1-xpr],ysr[1-ypr]};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.printf(\"! %d %d %d %d %d %d %d %d\",ans[0],ans[1],ans[2],ans[3],ans[4],ans[5],ans[6],ans[7]);\n\t\tSystem.out.println();\n\t\tSystem.out.flush();\n\t\t\n\t\tqwe.close();\n\t}\n\t\n\tstatic int bins(boolean leftbound, int small, int big, int n, Scanner qwe, boolean isx){\n\t\t\n\t\tint min = 0;\n\t\tint max = n;\n\t\t\n\t\tif(leftbound){\n\t\t\tmin++;\n\t\t\tmax++;\n\t\t}\n\t\t\n\t\tint y1 = 1;\n\t\tint y2 = n;\n\t\tint x1 = 1;\n\t\tint x2 = n;\n\t\t//\"? x1 y1 x2 y2\"\n\t\twhile(min+1 < max){\n\t\t\t\n\t\t\tint med = (min+max)/2;\n\t\t\tif(isx){\n\t\t\t\tif(!leftbound) x2 = med;\n\t\t\t\telse x1 = med;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(!leftbound) y2 = med;\n\t\t\t\telse y1 = med;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"? %d %d %d %d\",x1,y1,x2,y2);\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.flush();\n\t\t\t\n\t\t\tint response = qwe.nextInt();\n\t\t\tif(leftbound){\n\t\t\t\tif(response >= big) min = med;\n\t\t\t\telse max= med;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(response < big){\n\t\t\t\t\tmin = med;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmax = med;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(leftbound) max--;\n\t\t\n\t\treturn max;\n\t\t\n\t}\n\n}", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class A {\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out, false);\n        int n = scanner.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++) {\n            arr[i] = scanner.nextInt();\n        }\n        \n        Arrays.sort(arr);\n        int[] cols = new int[n];\n        Arrays.fill(cols, -1);\n        int ans = 0;\n        for(int i = 0; i < n; i++) {\n            if (cols[i] == -1) {\n                cols[i] = ans++;\n                for(int j = i + 1; j < n; j++) {\n                    if (arr[j] % arr[i] == 0) cols[j] = cols[i];\n                }\n            }\n        }\n        out.println(ans);\n        out.flush();\n    }\n    \n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n public class CF{\n\n   // static int MOD=1e9+7;\n     public static void main (String[] args) \n    {\n \n            FastReader scan = new FastReader();\n            PrintWriter out = new PrintWriter(System.out);\n            Task solver = new Task();\n         //   int testcase = scan.nextInt();\n                \n           int testcase = 1;\n            for(int tt = 1; tt <= testcase ; tt++) solver.solve(tt, scan, out);\n            out.close();\n        \n    }\n\n\n        \n    // main code in task \n    \n      static class Task {\n     \n        public void solve(int testNumber, FastReader scan, PrintWriter out) {\n\n            int n = scan.nextInt();\n\n            int q1 = scan.nextInt();\n            int q2 = scan.nextInt();\n\n            int k1 = scan.nextInt();\n            int k2 = scan.nextInt();\n\n\n            int r  = scan.nextInt();\n            int c = scan.nextInt();\n\n           // boolean ans = false;\n\n            if(q1 > k1 && q2 > k2 && q1 > r && q2 > c ){\n                  out.println(\"YES\");\n              \n            }else if(q1 < k1 && q2 < k2 && q1 < r && q2 < c){\n\n             \n                    out.println(\"YES\");\n              \n\n            }else if(q1>k1 && q2<k2 && q1 > r && q2 < c ){\n\n                \n                  out.println(\"YES\");\n               \n                \n            }else if(q1<k1 && q2 > k2 && q1<r && q2 > c){\n\n               \n                 out.println(\"YES\");\n               \n\n            }else{\n                out.println(\"NO\");\n               \n\n            }\n\n\n           \n     \n\n        }\n \n    }\n        \n \n static class FastReader {\n            BufferedReader br;\n            StringTokenizer st;\n     \n            public FastReader() {\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n     \n            public FastReader(String s) throws FileNotFoundException {\n                br = new BufferedReader(new FileReader(new File(s)));\n            }\n     \n            String next() {\n                while (st == null || !st.hasMoreElements()) {\n                    try {\n                        st = new StringTokenizer(br.readLine());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                return st.nextToken();\n            }\n     \n            int nextInt() {\n                return Integer.parseInt(next());\n            }\n     \n            long nextLong() {\n                return Long.parseLong(next());\n            }\n     \n            double nextDouble() {\n                return Double.parseDouble(next());\n            }\n     \n            String nextLine() {\n                String str = \"\";\n                try {\n                    str = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return str;\n            }\n            \n       \n\n \n \n        }\n\n\n }       ", "complexity": "constant", "problem": "1033_A", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class GeorgeAndInterestingGraph {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        \n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        \n        int[] edgeFrom = new int[M];\n        int[] edgeTo = new int[M];\n        for (int i = 0; i < M; i++) {\n        \tedgeFrom[i] = sc.nextInt();\n        \tedgeTo[i] = sc.nextInt();\n        }\n        \n        int best = Integer.MAX_VALUE;\n        for (int i = 0; i < N; i++) {\n        \tboolean[][] mat = makeAdjMat(N, edgeFrom, edgeTo);\n        \tbest = Math.min(best, count(mat, i, M));\n        }\n        \n        System.out.println(best);\n    }\n    \n    public static int count(boolean[][] mat, int center, int M) {\n//    \tint N = mat.length;\n//    \tint M = mat[0].length;\n//\n//    \tint centerConnect = (mat[center][center]) ? 0 : 1;\n//    \tfor (int i = 0; i < N; i++) {\n//\t\t\tif (i != center) {\n//\t\t\t\tif (!mat[i][center]) {\n//\t\t\t\t\tcenterConnect++;\n//\t\t\t\t}\n//\t\t\t\tif (!mat[center][i]) {\n//\t\t\t\t\tcenterConnect++;\n//\t\t\t\t}\n//\t\t\t}\n//\t    \tmat[i][center] = false;\n//\t    \tmat[center][i] = false;\n//\t\t}\n//    \t\n//    \tint[][] adjMat = new int[2 * N + 2][2 * N + 2];\n//    \tfor (int i = 0; i < N; i++) {\n//    \t\tfor (int j = 0; j < N; j++) {\n//    \t\t\tint idx = N + j;\n//    \t\t\tadjMat[i][idx] = (mat[i][j]) ? 1 : 0;\n//    \t\t}\n//    \t}\n//    \tint s = 2 * N;\n//    \tint t = 2 * N + 1;\n//    \tfor (int i = 0; i < N; i++) {\n//    \t\tadjMat[s][i] = 1;\n//    \t}\n//    \tfor (int i = N; i < 2 * N; i++) {\n//    \t\tadjMat[i][t] = 1;\n//    \t}\n//    \t\n//    \tint matches = fordFulkerson(adjMat, s, t);\n//    \t\n//    \treturn centerConnect + matches;\n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tint N = mat.length;\n//    \tint M = mat[0].length;\n    \t\n    \tint cntWithI = (mat[center][center]) ? 1 : 0;\n    \tfor (int i = 0; i < N; i++) {\n    \t\tif (i != center) {\n    \t\t\tif (mat[i][center]) {\n    \t\t\t\tcntWithI++;\n    \t\t\t}\n    \t\t\tif (mat[center][i]) {\n    \t\t\t\tcntWithI++;\n    \t\t\t}\n    \t\t}\n        \tmat[i][center] = false;\n        \tmat[center][i] = false;\n    \t}\n    \t\n    \tint other = M - cntWithI;\n    \t\n//    \tint centerConnect = (mat[center][center]) ? 0 : 1;\n//    \t\n//    \tfor (int i = 0; i < N; i++) {\n//    \t\tif (i != center) {\n//    \t\t\tif (!mat[i][center]) {\n//    \t\t\t\tcenterConnect++;\n//    \t\t\t}\n//    \t\t\tif (!mat[center][i]) {\n//    \t\t\t\tcenterConnect++;\n//    \t\t\t}\n//    \t\t}\n//        \tmat[i][center] = false;\n//        \tmat[center][i] = false;\n//    \t}\n    \t\n    \tint matches = bipartiteMatching(mat);\n    \t\n    \treturn (2 * N - 1 - cntWithI + other - matches + N - 1 - matches);\n//    \treturn (centerConnect + N - 1 - matches);\n    }\n    \n    public static boolean[][] makeAdjMat(int N, int[] edgeFrom, int[] edgeTo) {\n    \tboolean[][] mat = new boolean[N][N];\n    \tfor (int i = 0; i < edgeFrom.length; i++) {\n    \t\tint from = edgeFrom[i] - 1;\n    \t\tint to = edgeTo[i] - 1;\n    \t\tmat[from][to] = true;\n    \t}\n    \treturn mat;\n    }\n    \n    /**\n     * Returns true if there is a path from the source 's' to the sink 't' in the residual graph.\n     * Also fills parent[] to store the path.\n     * See here for more info:  http://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/\n     */\n    public static boolean fordFulkersonHelper(int[][] resid, int s, int t, int[] parent) {\n    \tint V = resid.length;\n    \tboolean[] visited = new boolean[V];\n    \tLinkedList<Integer> q = new LinkedList<Integer>();\n    \tq.push(s);\n    \tvisited[s] = true;\n    \tparent[s] = -1;\n    \t\n    \twhile (!q.isEmpty()) {\n    \t\tint u = q.pop();\n    \t\tfor (int v = 0; v < V; v++) {\n    \t\t\tif (!visited[v] && resid[u][v] > 0) {\n    \t\t\t\tq.push(v);\n    \t\t\t\tparent[v] = u;\n    \t\t\t\tvisited[v] = true;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    \treturn visited[t];\n    }\n    \n    /**\n     * Returns the maximum flow from 's' to 't' in the given graph.\n     * See here for more info:  http://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/\n     */\n    public static int fordFulkerson(int[][] graph, int s, int t) {\n    \tint V = graph.length;\n    \tint[][] resid = new int[V][V];\n    \tint[] parent = new int[V];\n    \tint maxFlow = 0;\n    \t\n    \tfor (int u = 0; u < V; u++) {\n    \t\tfor (int v = 0; v < V; v++) {\n    \t\t\tresid[u][v] = graph[u][v];\n    \t\t}\n    \t}\n    \t\n    \twhile (fordFulkersonHelper(resid, s, t, parent)) {\n    \t\tint pathFlow = Integer.MAX_VALUE;\n    \t\tfor (int v = t; v != s; v = parent[v]) {\n    \t\t\tint u = parent[v];\n    \t\t\tpathFlow = Math.min(pathFlow,  resid[u][v]);\n    \t\t}\n    \t\tfor (int v = t; v != s; v = parent[v]) {\n    \t\t\tint u = parent[v];\n    \t\t\tresid[u][v] -= pathFlow;\n    \t\t\tresid[v][u] += pathFlow;\n    \t\t}\n    \t\tmaxFlow += pathFlow;\n    \t}\n    \t\n    \treturn maxFlow;\n    }\n    \n    /**\n     * Returns true if a matching for vertex 'u' is possible.\n     * See here for more info:  http://www.geeksforgeeks.org/maximum-bipartite-matching/\n     */\n    public static boolean bipartiteMatchingHelper(boolean[][] bpGraph, int u, boolean[] seen, int[] matchR) {\n    \tint N = bpGraph[0].length;\n    \tfor (int v = 0; v < N; v++) {\n    \t\tif (bpGraph[u][v] && !seen[v]) {\n    \t\t\tseen[v] = true;\n    \t\t\tif (matchR[v] < 0 || bipartiteMatchingHelper(bpGraph, matchR[v], seen, matchR)) {\n    \t\t\t\tmatchR[v] = u;\n    \t\t\t\treturn true;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn false;\n    }\n    \n    /**\n     * Returns the maximum bipartite matching from an an adjacency matrix.\n     * Note:  bpGraph[i][j] = true if there is an edge from i to j.\n     * Note:  matchIJ (array of length M) is an output variable containing the matchings, such that matchIJ[i] = j means that there is a match from i to j.\n     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.\n     * See here for more info:  http://www.geeksforgeeks.org/maximum-bipartite-matching/\n     */\n    public static int bipartiteMatching(boolean[][] bpGraph, int[] matchIJ, int[] matchJI) {\n    \tint ans = bipartiteMatching(bpGraph, matchJI);\n    \t\n    \tfor (int i = 0; i < matchJI.length; i++) {\n    \t\tmatchIJ[i] = -1;\n    \t}\n    \t\n    \tfor (int j = 0; j < matchJI.length; j++) {\n    \t\tint i = matchJI[j];\n    \t\tif (i >= 0) {\n    \t\t\tmatchIJ[i] = j;\n    \t\t}\n    \t}\n    \t\n    \treturn ans;\n    }\n    \n    /**\n     * Returns the maximum bipartite matching from an an adjacency matrix.\n     * Note:  bpGraph[i][j] = true if there is an edge from i to j.\n     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.\n     * See here for more info:  http://www.geeksforgeeks.org/maximum-bipartite-matching/\n     */\n    public static int bipartiteMatching(boolean[][] bpGraph, int[] matchJI) {\n    \tint M = bpGraph.length;\n    \tint N = bpGraph[0].length;\n    \t\n    \tfor (int i = 0; i < N; i++) {\n    \t\tmatchJI[i] = -1;\n    \t}\n    \t\n    \tint ans = 0;\n    \tfor (int u = 0; u < M; u++) {\n    \t\tboolean[] seen = new boolean[N];\n    \t\tif (bipartiteMatchingHelper(bpGraph, u, seen, matchJI)) {\n    \t\t\tans++;\n    \t\t}\n    \t}\n    \t\n    \treturn ans;\n    }\n    \n    /**\n     * Returns the maximum bipartite matching from an an adjacency matrix.\n     * Overload of the bipartiteMatching function without output parameters.\n     * See here for more info:  http://www.geeksforgeeks.org/maximum-bipartite-matching/\n     */\n    public static int bipartiteMatching(boolean[][] bpGraph) {\n    \tint N = bpGraph[0].length;\n    \tint[] matchJI = new int[N];\n    \treturn bipartiteMatching(bpGraph, matchJI);\n    }\n    \n    /**\n     * Overload of the bipartiteMatching function taking an adjacency matrix of int[][] instead of boolean[][].\n     */\n    public static int bipartiteMatching(int[][] intGraph) {\n    \tboolean[][] bpGraph = intToBooleanAdjMat(intGraph);\n    \treturn bipartiteMatching(bpGraph);\n    }\n\n    /**\n     * Overload of the bipartiteMatching function taking an adjacency matrix of int[][] instead of boolean[][].\n     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.\n     */\n    public static int bipartiteMatching(int[][] intGraph, int[] matchJI) {\n    \tboolean[][] bpGraph = intToBooleanAdjMat(intGraph);\n    \treturn bipartiteMatching(bpGraph, matchJI);\n    }\n\n    /**\n     * Overload of the bipartiteMatching function taking an adjacency matrix of int[][] instead of boolean[][].\n     * Note:  matchIJ (array of length M) is an output variable containing the matchings, such that matchIJ[i] = j means that there is a match from i to j.\n     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.\n     */\n    public static int bipartiteMatching(int[][] intGraph, int[] matchIJ, int[] matchJI) {\n    \tboolean[][] bpGraph = intToBooleanAdjMat(intGraph);\n    \treturn bipartiteMatching(bpGraph, matchIJ, matchJI);\n    }\n    \n    /**\n     * Converts an integer adjacency matrix of 1's and 0's to a boolean adjacency matrix.\n     * Useful with bipartiteMatching, which takes adjancency matrix of boolean[][] as input (instead of int[][]).\n     */\n    public static boolean[][] intToBooleanAdjMat(int[][] mat) {\n    \tint M = mat.length;\n    \tint N = mat[0].length;\n    \tboolean[][] bMat = new boolean[M][N];\n    \tfor (int i = 0; i < M; i++) {\n    \t\tfor (int j = 0; j < N; j++) {\n    \t\t\tbMat[i][j] = (mat[i][j] != 0);\n    \t\t}\n    \t}\n    \treturn bMat;\n    }\n\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try { str = br.readLine(); }\n            catch (IOException e) { e.printStackTrace(); }\n            return str;\n        }\n    }\n}", "complexity": "cubic", "problem": "0387_D", "from": "CODEFORCES", "tags": "graph matchings"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class a {\npublic static void main(String[] args) throws IOException\n{\n    input.init(System.in);\n    int n = input.nextInt(), k = input.nextInt();\n    TreeSet<Integer> ts = new TreeSet<Integer>();\n    int[] data = new int[n];\n    for(int i = 0; i<n; i++)\n    {\n        data[i] = input.nextInt();\n    }\n    Arrays.sort(data);\n    if(n>1 && k==1.*data[n-1]/data[0])\n        System.out.println(n-1);\n    else\n    {\n    for(int i = 0; i<n; i++)\n    {\n        if(data[i]%k != 0)\n            ts.add(data[i]);\n        else\n        {\n            if(!ts.contains(data[i]/k))\n                ts.add(data[i]);\n        }\n    }\n    System.out.println(ts.size());\n    }\n}\npublic static class input {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    /** call this method to initialize reader for InputStream */\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    /** get next word */\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n    \n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong( next() );\n    }\n}\n}\n", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class _817C {\n\tpublic static long value(long temp) {\n\t\tlong sum = 0;\n\t\tlong temp2 = temp;\n\t\twhile(temp2!=0) {\n\t\t\tsum+=temp2%10;\n\t\t\ttemp2/=10;\n\t\t}\n\t\t\n\t\treturn temp-sum;\n\t}\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong num = sc.nextLong();\n\t\tlong limiter = sc.nextLong();\n\t\tlong counter = 0;\n\t\tlong lower = 1; long higher = num;long middle = 0;\n\t\twhile(lower<=higher) {\n\t\t\tmiddle = (higher+lower)/2;\n\t\t\tif(value(middle)<limiter) {\n\t\t\t\tlower = middle+1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\thigher = middle-1;\n\t\t\t\tcounter = num - middle +1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(counter);\n\t}\n\n}\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DExplorerSpace solver = new DExplorerSpace();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DExplorerSpace {\n        int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int k = in.nextInt();\n//        edges = new HashMap<>(n*m*2);\n            int[][][] edge = new int[n + 1][m + 1][5];\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j < m; j++) {\n                    int v = in.nextInt();\n                    edge[i][j][1] = v;\n                    edge[i][j + 1][3] = v;\n//                build(i,j,i,j+1,v);\n//                build(i,j+1,i,j,v);\n                }\n            }\n            for (int i = 1; i < n; i++) {\n                for (int j = 1; j <= m; j++) {\n                    int v = in.nextInt();\n                    edge[i][j][0] = v;\n                    edge[i + 1][j][2] = v;\n//                build(i,j,i+1,j,v);\n//                build(i+1,j,i,j,v);\n                }\n            }\n\n            if (k % 2 == 1) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < m; j++) {\n                        out.print(\"-1 \");\n                    }\n                    out.println();\n                }\n                return;\n            }\n\n            int[][][] dp = new int[k + 1][n + 1][m + 1];\n            for (int i = 2; i <= k; i += 2) {\n                for (int j = 1; j <= n; j++) {\n                    for (int l = 1; l <= m; l++) {\n                        dp[i][j][l] = Integer.MAX_VALUE;\n                        for (int o = 0; o < 4; o++) {\n                            int ni = j + dir[o][0];\n                            int nj = l + dir[o][1];\n                            if (ni < 1 || ni > n || nj < 1 || nj > m) continue;\n//                        dp[i][j][l] = Math.min(dp[i][j][l],dp[i-2][ni][nj] + 2*get(j,l,ni,nj));\n                            dp[i][j][l] = Math.min(dp[i][j][l], dp[i - 2][ni][nj] + 2 * edge[j][l][o]);\n                        }\n                    }\n                }\n            }\n\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= m; j++) {\n                    out.print(dp[k][i][j] + \" \");\n                }\n                out.println();\n            }\n\n\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String next() {\n            while (st == null || (!st.hasMoreElements())) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.*;\npublic class A630 {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong n = scan.nextLong();\n\t\tSystem.out.println(25);\n\t}\n}\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A\n{\n    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok;\n\n    public void go() throws IOException\n    {\n        ntok();\n        int n = ipar();\n        ArrayList<Integer> list = new ArrayList<>();\n        ntok();\n        for (int i = 0; i < n; i++)\n        {\n            list.add(ipar());\n        }\n        Collections.sort(list);\n        HashSet<Integer> set = new HashSet<>();\n        for (int x : list)\n        {\n            boolean add = true;\n            for (int y : set)\n            {\n                if (x % y == 0)\n                {\n                    add = false;\n                    break;\n                }\n            }\n            if (add)\n            {\n                set.add(x);\n            }\n        }\n        out.println(set.size());\n\n        out.flush();\n        in.close();\n    }\n\n    public void ntok() throws IOException\n    {\n        tok = new StringTokenizer(in.readLine());\n    }\n\n    public int ipar()\n    {\n        return Integer.parseInt(tok.nextToken());\n    }\n\n    public int[] iapar(int n)\n    {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            arr[i] = ipar();\n        }\n        return arr;\n    }\n\n    public long lpar()\n    {\n        return Long.parseLong(tok.nextToken());\n    }\n\n    public long[] lapar(int n)\n    {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++)\n        {\n            arr[i] = lpar();\n        }\n        return arr;\n    }\n\n    public double dpar()\n    {\n        return Double.parseDouble(tok.nextToken());\n    }\n\n    public String spar()\n    {\n        return tok.nextToken();\n    }\n\n    public static void main(String[] args) throws IOException\n    {\n        new A().go();\n    }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "//package timus;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.StreamTokenizer;\nimport java.io.Writer;\nimport java.util.Arrays;\n\npublic class Abra {\n    public static void main(String[] args) throws IOException {\n        new Abra().run();\n    }\n\n    StreamTokenizer in;\n    PrintWriter out;\n    boolean oj;\n\n    void init() throws IOException {\n        oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        Reader reader = oj ? new InputStreamReader(System.in) : new FileReader(\n                \"input.txt\");\n        Writer writer = oj ? new OutputStreamWriter(System.out)\n                : new FileWriter(\"output.txt\");\n        // Writer writer = new OutputStreamWriter(System.out);\n        in = new StreamTokenizer(new BufferedReader(reader));\n        out = new PrintWriter(writer);\n    }\n\n    void run() throws IOException {\n        long beginTime = System.currentTimeMillis();\n        init();\n        solve();\n        out.flush();\n    }\n\n    void printMem() {\n        if (!oj) {\n            System.out.println(\"Memory used = \"\n                    + (Runtime.getRuntime().totalMemory() - Runtime\n                            .getRuntime().freeMemory()));\n        }\n    }\n\n    int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    long nextLong() throws IOException {\n        in.nextToken();\n        return (long) in.nval;\n    }\n\n    String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    double nextDouble() throws IOException {\n        in.nextToken();\n        return in.nval;\n    }\n\n    long deg(long x, long y) {\n        long a = x;\n        for (long i = 2; i <= y; i++) {\n            a *= x;\n        }\n        return a;\n    }\n\n    long fact(long x) {\n        long a = 1;\n        for (long i = 2; i <= x; i++) {\n            a *= i;\n        }\n        return a;\n    }\n\n    long digitSum(String x) {\n        long a = 0;\n        for (int i = 0; i < x.length(); i++) {\n            a += x.codePointAt(i) - 48;\n        }\n        return a;\n    }\n\n    long digitSum(long x) {\n        long a = 0;\n        while (x > 0) {\n            a += x % 10;\n            x /= 10;\n        }\n        return a;\n    }\n\n    long digitMul(long x) {\n        long a = 1;\n        while (x > 0) {\n            a *= x % 10;\n            x /= 10;\n        }\n        return a;\n    }\n\n    double pif(double ax, double ay, double bx, double by) {\n        return Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by));\n    }\n\n    double getPosPart(double x) {\n        if (x <= 0)\n            return 0;\n        else\n            return x;\n    }\n\n    double max(double x, double y) {\n        if (x > y)\n            return x;\n        else\n            return y;\n    }\n\n    long gcd(long a, long b) {\n        if (a < b) {\n            long c = b;\n            b = a;\n            a = c;\n        }\n        while (a % b != 0) {\n            a = a % b;\n            if (a < b) {\n                long c = b;\n                b = a;\n                a = c;\n            }\n        }\n        return b;\n    }\n\n    int gcd(int a, int b) {\n        if (a < b) {\n            int c = b;\n            b = a;\n            a = c;\n        }\n        while (a % b != 0) {\n            a = a % b;\n            if (a < b) {\n                int c = b;\n                b = a;\n                a = c;\n            }\n        }\n        return b;\n    }\n\n    long lcm(long a, long b) throws IOException {\n        return a * b / gcd(a, b);\n    }\n\n    int lcm(int a, int b) throws IOException {\n        return a * b / gcd(a, b);\n    }\n\n    int countOccurences(String x, String y) {\n        int a = 0, i = 0;\n        while (true) {\n            i = y.indexOf(x);\n            if (i == -1)\n                break;\n            a++;\n            y = y.substring(i + 1);\n        }\n        return a;\n    }\n\n    int[] primes;\n\n    int findPrimes(int x) {\n        boolean[] forErato = new boolean[x];\n        primes = new int[x];\n        int l = 0, j = 0;\n        for (int i = 2; i < x; i++) {\n            if (forErato[i])\n                continue;\n            l++;\n            primes[l] = i;\n            j = i * 2;\n            while (j < x) {\n                forErato[j] = true;\n                j += i;\n            }\n        }\n        return l;\n    }\n\n    int rev(int x) {\n        int a = 0;\n        while (x > 0) {\n            a = a * 10 + x % 10;\n            x /= 10;\n        }\n        return a;\n    }\n\n    class myDate {\n        int d, m, y;\n\n        public myDate(int da, int ma, int ya) {\n            d = da;\n            m = ma;\n            y = ya;\n        }\n\n        int[] ml = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\n        void inc() {\n            if ((d == 31) && (m == 12)) {\n                y++;\n                d = 1;\n                m = 1;\n            } else {\n                if (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)) {\n                    ml[1] = 29;\n                }\n                if (d == ml[m - 1]) {\n                    m++;\n                    d = 1;\n                } else\n                    d++;\n            }\n        }\n    }\n\n    int partition(int n, int l, int m) {// n - sum, l - length, m - every part\n        // <= m\n        if (n < l)\n            return 0;\n        if (n < l + 2)\n            return 1;\n        if (l == 1)\n            return 1;\n        int c = 0;\n        for (int i = Math.min(n - l + 1, m); i >= (n + l - 1) / l; i--) {\n            c += partition(n - i, l - 1, i);\n        }\n        return c;\n    }\n\n    void solve() throws IOException {\n        int n = nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        Arrays.sort(a);\n        int min = a[0];\n        for (int i = 1; i < n; i++) {\n            if (a[i] != min) {\n                out.print(a[i]);\n                return;\n            }\n        }\n        out.print(\"NO\");\n    }\n}", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class A {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint k = scan.nextInt()-1;\n\t\tPrimeGen p = new PrimeGen(n);\n\t\tList<Integer> prims = new ArrayList<Integer>();\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tif(p.isPrime(i)>0){\n\t\t\t\tprims.add(i);\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < prims.size() - 1; i++){\n\t\t\tint c = prims.get(i) + prims.get(i+1) + 1;\n\t\t\tif(c <= n && p.isPrime(c)>0){\n\t\t\t\tsum ++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum>=k?\"YES\":\"NO\");\n\t}\n\n\tstatic int sum(List<Integer> is) {\n\t\tint c = 0;\n\t\tfor (int i : is)\n\t\t\tc += i;\n\t\treturn c;\n\t}\n\t\n\tstatic class PrimeGen {\n\t\tpublic PrimeGen(int m) {\n\t\t\tm = (int) Math.sqrt(m);\n\t\t\tdouble max = 0;\n\t\t\tint r = 1;\n\t\t\tfor (int i = 0; i < 4;) {\n\t\t\t\tmax += r * m / Math.pow(Math.log1p(m), ++i);\n\t\t\t\tr *= i;\n\t\t\t}\n\t\t\tp = new int[(int) max];\n\t\t\tfor (int i = 0, e = 2; i < p.length; i++) {\n\t\t\t\tfor (; isPrime(e) < 1; e++)\n\t\t\t\t\t;\n\t\t\t\tp[i] = e++;\n\t\t\t}\n\t\t\tthis.m = p[p.length - 1];\n\t\t\tthis.m = this.m * this.m;\n\t\t}\n\n\t\tint isPrime(int n) {\n\t\t\tfor (int e : p)\n\t\t\t\tif (e < 1)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (n != e && n % e < 1)\n\t\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tint max() {\n\t\t\treturn m;\n\t\t}\n\n\t\tint[] p;\n\t\tint m;\n\t}\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.util.*;\n\npublic class codea{\n\tpublic static void main(String args[])\n\t{\n\t  Scanner in = new Scanner(System.in);\n\t  int n = in.nextInt();\n\t  int arr[] = new int[n];\n\t  for(int i =0;i<n;i++)\n\t   arr[i]= in.nextInt();\n\t  Arrays.sort(arr);\n\t  int max =0;\n\t  boolean check[]= new boolean [n];\n\t  int count=0;\n\t  for(int i =0;i<n;i++)\n\t  {\n\t   \n\t   if(!check[i])\n\t   {\n\t   \tcount++;\n\t   \n\t   for(int j=i;j<n;j++)\n\t   {\n\t   \n\t    if(arr[j]%arr[i]==0)\n\t     check[j]=true;\n\t   }\n\t   \n\t   }\t\n\t  }\n\t  System.out.println(count);\t\n\t}\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;\nimport java.io.IOException;import java.io.PrintStream;import java.io.PrintWriter;\nimport java.security.AccessControlException;import java.util.Arrays;import java.util.Collection;\nimport java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Objects;\nimport java.util.Scanner;import java.util.TreeMap;import java.util.function.Function;\nimport java.util.stream.Collectors;import java.util.stream.IntStream;import java.util.stream.LongStream;\nimport java.util.stream.Stream;public class _p001033A {static public void main(final String[] args) \nthrows IOException{p001033A._main(args);}\nstatic private class p001033A extends Solver{public p001033A(){nameIn=\"in/1000/p001033A.in\";\nsingleTest=true;}@Override public void solve()throws IOException{int n=sc.nextInt();\nsc.nextLine();int ax=sc.nextInt();int ay=sc.nextInt();sc.nextLine();int bx=sc.nextInt();\nint by=sc.nextInt();sc.nextLine();int cx=sc.nextInt();int cy=sc.nextInt();sc.nextLine();\nboolean res=(bx>ax && cx>ax || bx<ax && cx<ax)&&(by>ay && cy>ay || by<ay && cy<ay);\npw.println(res?\"YES\":\"NO\");}static public void _main(String[]args)throws IOException\n{new p001033A().run();}}static private class Pair<K,V>{private K k;private V v;public \nPair(final K t,final V u){this.k=t;this.v=u;}public K getKey(){return k;}public \nV getValue(){return v;}}static private abstract class Solver{protected String nameIn\n=null;protected String nameOut=null;protected boolean singleTest=false;protected \nboolean preprocessDebug=false;protected boolean doNotPreprocess=false;protected \nPrintStream debugPrintStream=null;protected Scanner sc=null;protected PrintWriter \npw=null;final static String SPACE=\" \";final static String SPACES=\"\\\\s+\";private \nvoid process()throws IOException{if(!singleTest){int t=lineToIntArray()[0];while(t--\n>0){solve();}}else{solve();}}abstract protected void solve()throws IOException;protected \nString[]lineToArray()throws IOException{return sc.nextLine().trim().split(SPACES);\n}protected int[]lineToIntArray()throws IOException{return Arrays.stream(lineToArray()).mapToInt(Integer::valueOf).toArray();\n}protected long[]lineToLongArray()throws IOException{return Arrays.stream(lineToArray()).mapToLong(Long::valueOf).toArray();\n}protected void run()throws IOException{boolean done=false;try{if(nameIn!=null && \nnew File(nameIn).exists()){try(FileInputStream fis=new FileInputStream(nameIn);PrintWriter \npw0=select_output();){done=true;sc=new Scanner(fis);pw=pw0;process();}}}catch(IOException \nex){}catch(AccessControlException ex){}if(!done){try(PrintWriter pw0=select_output();\n){sc=new Scanner(System.in);pw=pw0;process();}}}private PrintWriter select_output()\nthrows FileNotFoundException{if(nameOut!=null){return new PrintWriter(nameOut);}\nreturn new PrintWriter(System.out);}public static Map<Integer,List<Integer>>mapi(final \nint[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<Integer,List<Integer>>(),\n(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static Map<Long,List<Integer>>\nmapi(final long[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<Long,\nList<Integer>>(),(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final T[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<T,List<Integer>>(),\n(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));\n}else{res.get(a[i]).add(i);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final T[]a,Comparator<T>cmp){return IntStream.range(0,a.length).collect(()->\nnew TreeMap<T,List<Integer>>(cmp),(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],\nStream.of(i).collect(Collectors.toList()));}else{res.get(a[i]).add(i);}},Map::putAll\n);}public static Map<Integer,List<Integer>>mapi(final IntStream a){int[]i=new int[]{0};\nreturn a.collect(()->new TreeMap<Integer,List<Integer>>(),(res,v)->{if(!res.containsKey(v))\n{res.put(v,Stream.of(i[0]).collect(Collectors.toList()));}else{res.get(v).add(i[0]);\n}i[0]++;},Map::putAll);}public static Map<Long,List<Integer>>mapi(final LongStream \na){int[]i=new int[]{0};return a.collect(()->new TreeMap<Long,List<Integer>>(),(res,\nv)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}i[0]++;},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final Stream<T>a,Comparator<T>cmp){int[]i=new int[]{0};return a.collect(()->\nnew TreeMap<T,List<Integer>>(cmp),(res,v)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}},Map::putAll);}public static<T>Map<T,List<Integer>>\nmapi(final Stream<T>a){int[]i=new int[]{0};return a.collect(()->new TreeMap<T,List<Integer>>(),\n(res,v)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));\n}else{res.get(v).add(i[0]);}},Map::putAll);}public static List<int[]>listi(final \nint[]a){return IntStream.range(0,a.length).mapToObj(i->new int[]{a[i],i}).collect(Collectors.toList());\n}public static List<long[]>listi(final long[]a){return IntStream.range(0,a.length).mapToObj(i\n->new long[]{a[i],i}).collect(Collectors.toList());}public static<T>List<Pair<T,\nInteger>>listi(final T[]a){return IntStream.range(0,a.length).mapToObj(i->new Pair<T,\nInteger>(a[i],i)).collect(Collectors.toList());}public static List<int[]>listi(final \nIntStream a){int[]i=new int[]{0};return a.mapToObj(v->new int[]{v,i[0]++}).collect(Collectors.toList());\n}public static List<long[]>listi(final LongStream a){int[]i=new int[]{0};return \na.mapToObj(v->new long[]{v,i[0]++}).collect(Collectors.toList());}public static<T>\nList<Pair<T,Integer>>listi(final Stream<T>a){int[]i=new int[]{0};return a.map(v->\nnew Pair<T,Integer>(v,i[0]++)).collect(Collectors.toList());}public static String \njoin(final int[]a){return Arrays.stream(a).mapToObj(Integer::toString).collect(Collectors.joining(SPACE));\n}public static String join(final long[]a){return Arrays.stream(a).mapToObj(Long::toString).collect(Collectors.joining(SPACE));\n}public static<T>String join(final T[]a){return Arrays.stream(a).map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final T[]a,final Function<T,String>toString){return \nArrays.stream(a).map(v->toString.apply(v)).collect(Collectors.joining(SPACE));}public \nstatic<T>String join(final Collection<T>a){return a.stream().map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Collection<T>a,final Function<T,String>toString)\n{return a.stream().map(v->toString.apply(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Stream<T>a){return a.map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));\n}public static<T>String join(final Stream<T>a,final Function<T,String>toString){\nreturn a.map(v->toString.apply(v)).collect(Collectors.joining(SPACE));}public static\n<T>String join(final IntStream a){return a.mapToObj(Integer::toString).collect(Collectors.joining(SPACE));\n}public static<T>String join(final LongStream a){return a.mapToObj(Long::toString).collect(Collectors.joining(SPACE));\n}public static List<Integer>list(final int[]a){return Arrays.stream(a).mapToObj(Integer::valueOf).collect(Collectors.toList());\n}public static List<Integer>list(final IntStream a){return a.mapToObj(Integer::valueOf).collect(Collectors.toList());\n}public static List<Long>list(final long[]a){return Arrays.stream(a).mapToObj(Long::valueOf).collect(Collectors.toList());\n}public static List<Long>list(final LongStream a){return a.mapToObj(Long::valueOf).collect(Collectors.toList());\n}public static<T>List<T>list(final Stream<T>a){return a.collect(Collectors.toList());\n}public static<T>List<T>list(final T[]a){return Arrays.stream(a).collect(Collectors.toList());\n}}}\n", "complexity": "constant", "problem": "1033_A", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.BufferedWriter;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.io.OutputStreamWriter;\n\nimport java.io.PrintWriter;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class D {\n\n    private static BufferedReader in;\n\n    private static StringTokenizer st;\n\n    private static PrintWriter out;\n\n    \n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n\n        in = new BufferedReader(new InputStreamReader(System.in));\n\n        st = new StringTokenizer(\"\");\n\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n        long l = nextLong();\n\n        long r = nextLong();\n\n        String s1 = Long.toBinaryString(l);\n\n        String s2 = Long.toBinaryString(r);\n\n        for (int i = s2.length()-s1.length(); i > 0; i--) {\n\n            s1 = '0'+s1;\n\n        }\n\n        int pow = s2.length();\n\n        for (int i = 0; i < s2.length(); i++) {\n\n            if(s1.codePointAt(i)!=s2.codePointAt(i))\n\n                break;\n\n            else\n\n                pow--;\n\n        }\n\n        System.out.println((long) Math.pow(2, pow)-1);\n\n        \n\n        \n\n    }\n\n    \n\n\n\n    static String next() throws IOException{\n\n        while(!st.hasMoreTokens()){\n\n            st = new StringTokenizer(in.readLine());\n\n        }\n\n        return st.nextToken();\n\n    }\n\n    static int nextInt() throws NumberFormatException, IOException{\n\n        return Integer.parseInt(next());\n\n    }\n\n    static long nextLong() throws NumberFormatException, IOException{\n\n        return Long.parseLong(next());\n\n    }\n\n    \n\n    static double nextDouble() throws NumberFormatException, IOException{\n\n        return Double.parseDouble(next());\n\n    }\n\n\n\n}\n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jenish\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CReallyBigNumbers solver = new CReallyBigNumbers();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CReallyBigNumbers {\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            long n = in.scanLong();\n            long sum = in.scanLong();\n            long low = 1;\n            long high = n;\n            long index = -1;\n            while (low <= high) {\n                long mid = (low + high) / 2;\n                if (mid - getsum(mid) >= sum) {\n                    index = mid;\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n            if (index == -1) {\n                out.println(0);\n            } else {\n                out.println(n - index + 1);\n            }\n        }\n\n        long getsum(long n) {\n            long s = 0;\n            while (n > 0) {\n                s += n % 10;\n                n /= 10;\n            }\n            return s;\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int INDEX;\n        private BufferedInputStream in;\n        private int TOTAL;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (INDEX >= TOTAL) {\n                INDEX = 0;\n                try {\n                    TOTAL = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (TOTAL <= 0) return -1;\n            }\n            return buf[INDEX++];\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n        public long scanLong() {\n            long I = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    I *= 10;\n                    I += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * I;\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.*;\nimport java.security.SecureRandom;\nimport java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n    \n    \n    \n    \n    public void solve() throws Exception {\n        \n        int n = sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        long h[] = new long[n];\n        \n        for (int i = 0;i < n; ++ i) {\n            h[i] = sc.nextLong();\n        }\n        Arrays.sort(h);\n        long l = h[n - a];\n        long r = h[n - a - 1];\n        out.println(l - r);\n    }\n    \n    \n    \n    \n    /*--------------------------------------------------------------*/\n    \n    static String filename = \"\";\n    static boolean fromFile = false;\n    \n    BufferedReader in;\n    PrintWriter out;\n    FastScanner sc;\n    \n    public static void main(String[] args) {\n        new Thread(null, new Solution(), \"\", 1 << 25).start();\n    }\n   \n    public void run() {\n        try {\n            init();\n            solve();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            out.close();\n        }\n    }\n    \n    void init() throws Exception {\n        if (fromFile) {\n            in = new BufferedReader(new FileReader(filename+\".in\"));\n            out = new PrintWriter(new FileWriter(filename+\".out\"));\n        } else {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n        sc = new FastScanner(in);\n    }\n}\n\nclass FastScanner {\n    \n    BufferedReader reader;\n    StringTokenizer strTok;\n    \n    public FastScanner(BufferedReader reader) {\n        this.reader = reader;\n    }\n    \n    public String nextToken() throws IOException {\n        while (strTok == null || !strTok.hasMoreTokens()) {\n            strTok = new StringTokenizer(reader.readLine());\n        }\n        \n        return strTok.nextToken();\n    }\n    \n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    \n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    \n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    \n    public BigInteger nextBigInteger() throws IOException {\n        return new BigInteger(nextToken());\n    }\n    \n    public BigDecimal nextBigDecimal() throws IOException {\n        return new BigDecimal(nextToken());\n    }\n}", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1515E extends PrintWriter {\n\tCF1515E() { super(System.out, true); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1515E o = new CF1515E(); o.main(); o.flush();\n\t}\n\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint md = sc.nextInt();\n\t\tint k = (n + 1) / 2;\n\t\tint[][] dp = new int[k + 1][n + 1]; dp[0][0] = 1;\n\t\tfor (int h = 1; h <= k; h++)\n\t\t\tfor (int l = h; l <= n - h + 1; l++)\n\t\t\t\tdp[h][l] = (int) ((dp[h][l - 1] * 2L + dp[h - 1][l - 1]) * h % md);\n\t\tint ans = 0;\n\t\tfor (int h = 1; h <= k; h++)\n\t\t\tans = (ans + dp[h][n - h + 1]) % md;\n\t\tprintln(ans);\n\t}\n}\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class kosyaDetka {\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n\n        int t = scan.nextInt();\n\n        ArrayList<Integer> arr = new ArrayList<>();\n\n        for(int i = 0; i < t; i++){\n            arr.add( scan.nextInt());\n        }\n\n        int count = 0;\n\n        while (arr.size() != 0){\n\n            int min = Integer.MAX_VALUE;\n\n            for(int i = 0; i < arr.size(); i++){\n                int temp = arr.get(i);\n                if( temp < min){\n                    min = temp;\n                }\n            }\n\n\n            for(int i = 0; i < arr.size(); i++){\n                int temp = arr.get(i);\n                if( temp % min == 0){\n                    arr.remove(i);\n                    i--;\n                }\n            }\n\n            count++;\n        }\n\n        System.out.println(count);\n    }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "//Template with FastScanner\n\n// jzzhao\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n       \n        //int tc = sc.ni();\n        int tc = 1;\n        for (int rep = 0; rep < tc; rep++) {\n            solve(sc,pw);\n            //pw.println(solve(sc,pw));\n           \n        }\n        \n        \n        pw.close();\n    }\n    /*\n\n    FS Methods:\n\n    - next(): next element in string\n    - nextLine(): nextline in string\n    - ni(): next Integer\n    - nd(): next Double\n    - nl(): next Long\n    - intArray(n): \n    - longArray(n): \n    - to2di(m,n):\n    - to2dl(m,n):\n\n\n\n    */\n\n          \n    public static void solve(FastScanner sc, PrintWriter pw) {\n\n        int n = sc.ni();\n        int m = sc.ni();\n        int k = sc.ni();\n\n        int[][] arr = sc.to2di(n,m-1); \n        int[][] arr2 = sc.to2di(n-1,m); \n        \n        if(k%2==1){\n            String s =\"\";\n            for(int j = 0;j<m;j++){\n                s+=\"-1\";\n                if(j!=m-1){\n                    s+=\" \";\n                }\n            }\n            for(int i = 0;i<n;i++){\n                pw.println(s);\n            }\n            return;\n        }\n\n        \n        Integer[][][] dp = new Integer[n][m][k+1];\n\n        // edge info\n        // for(int i= 0;i<n;i++){\n        //     for(int j = 0;j<m-1;j++){\n                \n        //         int l = i*1000+j;\n        //         int r = i*1000+j+1;\n        //         String cur = l+\" \"+r;\n        //         String cur2 = r+\" \"+l;\n        //         map.put(cur,arr[i][j]);\n        //         map.put(cur2,arr[i][j]);\n                \n        //     }\n        // }\n\n        // for(int i= 0;i<n-1;i++){\n        //     for(int j = 0;j<m;j++){\n                \n        //         int l = i*1000+j;\n        //         int r = (i+1)*1000+j;\n        //         String cur = l+\" \"+r;\n        //         String cur2 = r+\" \"+l;\n        //         map.put(cur,arr2[i][j]);\n        //         map.put(cur2,arr2[i][j]);\n                \n        //     }\n        // }\n\n        //dp fill\n\n        for(int i= 0;i<n;i++){\n            for(int j = 0;j<m;j++){\n                \n                fill(dp,i,j,k,n,m,arr,arr2);\n                \n            }\n        }\n\n        for(int i= 0;i<n;i++){\n            String s = \"\";\n            for(int j = 0;j<m;j++){\n                \n                s+=dp[i][j][k];\n                if(j!=m-1){\n                    s+=\" \";\n                }\n                \n            }\n            pw.println(s);\n        }\n\n        \n\n\n\n    }\n\n    public static int fill(Integer[][][] dp, int x, int y, int k, int n,int m,int[][] arr, int[][] arr2){\n        \n        \n\n        if(dp[x][y][k]!=null){\n            return dp[x][y][k];\n        }\n\n        if(k==0){\n            dp[x][y][k]= 0;\n            return 0;\n        }\n\n        int min = Integer.MAX_VALUE;\n\n        \n\n        if(x>0){\n            \n\n            int curVal = 2*arr2[x-1][y]+fill(dp,x-1,y,k-2,n,m,arr,arr2);\n            min = Math.min(min,curVal);\n        }\n\n        if(y>0){\n            \n            int curVal = 2*arr[x][y-1]+fill(dp,x,y-1,k-2,n,m,arr,arr2);\n            min = Math.min(min,curVal);\n        }\n\n        if(x<n-1){\n            \n            int curVal = 2*arr2[x][y]+fill(dp,x+1,y,k-2,n,m,arr,arr2);\n            min = Math.min(min,curVal);\n        }\n\n        if(y<m-1){\n            \n            int curVal = 2*arr[x][y]+fill(dp,x,y+1,k-2,n,m,arr,arr2);\n            min = Math.min(min,curVal);\n        }\n\n        dp[x][y][k]=min;\n        return min;\n\n\n    }\n\n    \n\n    /*\n        - The following are helping method so pls do not do anything to them.\n    \n    */\n\n    // public static int[][] to2d(Scanner scanner, int m, int n){\n    //     int[][] ans = new int[m][n];\n    //     for(int i = 0;i<m;i++){\n    //         String[] r = scanner.nextLine().split(\"[ ]\");\n    //         for(int j = 0;j<n;j++){\n    //             ans[i][j] = stoi(r[j]);\n    //         }\n    //     }\n    //     return ans;\n    // }\n\n    // public static int[] toArray(Scanner scanner, int m){\n    //     int[] ans = new int[m];\n    //     String[] r = scanner.nextLine().split(\"[ ]\");\n    //     for(int i = 0;i<m;i++){\n    //         ans[i] = stoi(r[i]);\n    //     }\n        \n    //     return ans;\n    // }\n\n    public static void printArr(PrintWriter pw,int[] a){\n        for(int i = 0;i<a.length;i++){\n            pw.print(a[i]);\n            if(i!=a.length-1){\n                pw.print(\" \");\n            }\n        }\n        pw.println();\n    }\n\n    public static void print2d(PrintWriter pw,int[][] a){\n        for(int j=0;j<a.length;j++){\n            for(int i = 0;i<a[j].length;i++){\n                pw.print(a[j][i]);\n                if(i!=a[j].length-1){\n                    pw.print(\" \");\n                }\n            }\n            pw.println(\" \");\n        }\n        pw.println();\n    }\n\n    public static int stoi(String s){\n        return Integer.parseInt(s);\n    }\n}\n\nclass FastScanner {\n    BufferedReader br;\n    StringTokenizer st;\n \n    public FastScanner() {\n        br = new BufferedReader(new InputStreamReader(System.in), 32768);\n        st = null;\n    }\n \n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n                \n            }\n        }\n        return st.nextToken();\n    }\n \n    int ni() {\n        return Integer.parseInt(next());\n    }\n \n    int[] intArray(int N) {\n        int[] ret = new int[N];\n        for (int i = 0; i < N; i++)\n            ret[i] = ni();\n        return ret;\n    }\n\n    int[][] to2di(int m, int n){\n        int[][] ans = new int[m][n];\n        for(int i = 0;i<m;i++){\n            String[] r = nextLine().split(\"[ ]\");\n            for(int j = 0;j<n;j++){\n                ans[i][j] = Integer.parseInt(r[j]);\n            }\n        }\n        return ans;\n    }\n\n    long[][] to2dl(int m, int n){\n        long[][] ans = new long[m][n];\n        for(int i = 0;i<m;i++){\n            String[] r = nextLine().split(\"[ ]\");\n            for(int j = 0;j<n;j++){\n                ans[i][j] = Long.parseLong(r[j]);\n            }\n        }\n        return ans;\n    }\n \n    long nl() {\n        return Long.parseLong(next());\n    }\n \n    long[] longArray(int N) {\n        long[] ret = new long[N];\n        for (int i = 0; i < N; i++)\n            ret[i] = nl();\n        return ret;\n    }\n \n    double nd() {\n        return Double.parseDouble(next());\n    }\n \n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n    static class Team implements Comparable<Team> {\n        int pr;\n        int time;\n        int id;\n\n        public Team(int P, int T, int I) {\n            pr = P;\n            time = T;\n            id = I;\n        }\n\n        @Override\n        public int compareTo(Team t) {\n            return pr != t.pr ? t.pr - pr : time != t.time ? time - t.time : id - t.id;\n        }\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        StringTokenizer st = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(st.nextToken());\n\n        int k = Integer.parseInt(st.nextToken());\n\n        Team[] a = new Team[n];\n        int[] c = new int[n + 1];\n\n        for (int i = 0; i < n; i++) {\n            st = new StringTokenizer(in.readLine());\n            int p = Integer.parseInt(st.nextToken());\n            int t = Integer.parseInt(st.nextToken());\n\n            a[i] = new Team(p, t, i);\n        }\n\n        Arrays.sort(a);\n        int prev = 1;\n        c[1]++;\n\n        for (int i = 1; i < n; i++) {\n            if (a[i].pr == a[i - 1].pr && a[i].time == a[i - 1].time)\n                for (int j = i + 1; j >= prev; j--)\n                    c[j] = i + 2 - prev;\n            else {\n                prev = i + 1;\n                c[prev] = 1;\n            }\n        }\n\n        out.println(c[k]);\n        out.close();\n    }\n}\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "//package round371;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class BT {\n\tScanner in;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\t\n\tint q(int r1, int c1, int r2, int c2)\n\t{\n\t\tout.printf(\"? %d %d %d %d\\n\", r1+1, c1+1, r2+1, c2+1);\n\t\tout.flush();\n\t\treturn ni();\n\t}\n\t\n\tvoid e(int r1, int c1, int r2, int c2, int r3, int c3, int r4, int c4)\n\t{\n\t\tout.printf(\"! %d %d %d %d %d %d %d %d\\n\", \n\t\t\t\tr1+1, c1+1, r2+1, c2+1,\n\t\t\t\tr3+1, c3+1, r4+1, c4+1\n\t\t\t\t);\n\t\tout.flush();\n\t}\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint cu = -1, cv = -1;\n\t\t{\n\t\t\tint low = -1, high = n-1;\n\t\t\twhile(high - low > 1){\n\t\t\t\tint h = high+low>>1;\n\t\t\t\tif(q(0, 0, n-1, h) >= 2){\n\t\t\t\t\thigh = h;\n\t\t\t\t}else{\n\t\t\t\t\tlow = h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcu = high;\n\t\t}\n\t\t{\n\t\t\tint low = -1, high = n-1;\n\t\t\twhile(high - low > 1){\n\t\t\t\tint h = high+low>>1;\n\t\t\t\tif(q(0, 0, n-1, h) >= 1){\n\t\t\t\t\thigh = h;\n\t\t\t\t}else{\n\t\t\t\t\tlow = h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcv = high;\n\t\t}\n\t\t\n\t\tint du = -1, dv = -1;\n\t\t{\n\t\t\tint low = 0, high = n;\n\t\t\twhile(high - low > 1){\n\t\t\t\tint h = high+low>>1;\n\t\t\t\tif(q(0, h, n-1, n-1) >= 2){\n\t\t\t\t\tlow = h;\n\t\t\t\t}else{\n\t\t\t\t\thigh = h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdu = low;\n\t\t}\n\t\t{\n\t\t\tint low = 0, high = n;\n\t\t\twhile(high - low > 1){\n\t\t\t\tint h = high+low>>1;\n\t\t\t\tif(q(0, h, n-1, n-1) >= 1){\n\t\t\t\t\tlow = h;\n\t\t\t\t}else{\n\t\t\t\t\thigh = h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdv= low;\n\t\t}\n\t\t\n\t\tint eu = -1, ev = -1;\n\t\t{\n\t\t\tint low = -1, high = n-1;\n\t\t\twhile(high - low > 1){\n\t\t\t\tint h = high+low>>1;\n\t\t\t\tif(q(0, 0, h, n-1) >= 2){\n\t\t\t\t\thigh = h;\n\t\t\t\t}else{\n\t\t\t\t\tlow = h;\n\t\t\t\t}\n\t\t\t}\n\t\t\teu = high;\n\t\t}\n\t\t{\n\t\t\tint low = -1, high = n-1;\n\t\t\twhile(high - low > 1){\n\t\t\t\tint h = high+low>>1;\n\t\t\t\tif(q(0, 0, h, n-1) >= 1){\n\t\t\t\t\thigh = h;\n\t\t\t\t}else{\n\t\t\t\t\tlow = h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tev = high;\n\t\t}\n\t\t\n\t\tint fu = -1, fv = -1;\n\t\t{\n\t\t\tint low = 0, high = n;\n\t\t\twhile(high - low > 1){\n\t\t\t\tint h = high+low>>1;\n\t\t\t\tif(q(h, 0, n-1, n-1) >= 2){\n\t\t\t\t\tlow = h;\n\t\t\t\t}else{\n\t\t\t\t\thigh = h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfu = low;\n\t\t}\n\t\t{\n\t\t\tint low = 0, high = n;\n\t\t\twhile(high - low > 1){\n\t\t\t\tint h = high+low>>1;\n\t\t\t\tif(q(h, 0, n-1, n-1) >= 1){\n\t\t\t\t\tlow = h;\n\t\t\t\t}else{\n\t\t\t\t\thigh = h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfv= low;\n\t\t}\n\t\t\n\t\t// cv <= cu\n\t\t// du <= dv\n\t\tint[][][] canc = {\n\t\t\t\t{{du, cu}, {dv, cv}},\n\t\t\t\t{{du, cv}, {dv, cu}}\n\t\t};\n\t\tint[][][] canr = {\n\t\t\t\t{{fu, eu}, {fv, ev}},\n\t\t\t\t{{fu, ev}, {fv, eu}}\n\t\t};\n\t\tfor(int[][] cr : canr){\n\t\t\tif(cr[0][0] > cr[0][1])continue;\n\t\t\tif(cr[1][0] > cr[1][1])continue;\n\t\t\tfor(int[][] cc : canc){\n\t\t\t\tif(cc[0][0] > cc[0][1])continue;\n\t\t\t\tif(cc[1][0] > cc[1][1])continue;\n\t\t\t\tfor(int z = 0;z < 2;z++){\n\t\t\t\t\tif(\n\t\t\t\t\t\t\tq(cr[0][0], cc[0^z][0], cr[0][1], cc[0^z][1]) == 1 &&\n\t\t\t\t\t\t\tq(cr[1][0], cc[1^z][0], cr[1][1], cc[1^z][1]) == 1){\n\t\t\t\t\t\te(cr[0][0], cc[0^z][0], cr[0][1], cc[0^z][1], cr[1][0], cc[1^z][0], cr[1][1], cc[1^z][1]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new RuntimeException();\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tin = oj ? new Scanner(System.in) : new Scanner(INPUT);\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew BT().run();\n\t}\n\t\n\tint ni() { return Integer.parseInt(in.next()); }\n\tlong nl() { return Long.parseLong(in.next()); }\n\tdouble nd() { return Double.parseDouble(in.next()); }\n\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tvoid tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Div2_489C {\n\n\tstatic final long MOD = 1_000_000_007;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tStringTokenizer inputData = new StringTokenizer(reader.readLine());\n\t\tlong st = Long.parseLong(inputData.nextToken());\n\t\tif(st == 0) {\n\t\t\tprinter.println(0);\n\t\t\tprinter.close();\n\t\t\treturn;\n\t\t}\n\t\tst %= MOD;\n\t\tlong years = Long.parseLong(inputData.nextToken());\n\t\tlong[][] res = exp(years);\n\t\tlong ans = (res[0][0] * st % MOD * 2 % MOD + res[0][1] * (-1 + MOD) % MOD) % MOD;\n\t\tprinter.println(ans);\n\t\tprinter.close();\n\t}\n\n\tstatic long[][] exp(long pow) {\n\t\tlong[][] cBase = base;\n\t\tlong[][] res = { { 1, 0 }, { 0, 1 } };\n\n\t\twhile (pow != 0) {\n\t\t\tif ((pow & 1) != 0) {\n\t\t\t\tres = mult(res, cBase);\n\t\t\t}\n\t\t\tcBase = mult(cBase, cBase);\n\t\t\tpow >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long[][] base = { { 2, 1 }, { 0, 1 } };\n\n\tstatic long[][] mult(long[][] a, long[][] b) {\n\t\tlong[][] res = new long[2][2];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tres[i][j] = (a[i][0] * b[0][j] % MOD + a[i][1] * b[1][j] % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n}\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class HexadecimalsTheorem {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int num = in.nextInt();\n        LinkedList<Integer> result = new LinkedList<Integer>();\n        int temp0 = 1;\n        int temp1 = 1;\n        int temp2 = 0;\n        result.add(0);\n        result.add(0);\n        result.add(0);\n        result.add(temp0);\n        result.add(temp1);\n        if (num == 2) {\n            System.out.println(0 + \" \" + 1 + \" \" + 1);\n        } else if (num == 0) {\n            System.out.println(0 + \" \" + 0 + \" \" + 0);\n        } else {\n            while (temp2 < num) {\n                temp2 = temp1 + temp0;\n                result.add(temp2);\n                temp0 = temp1;\n                temp1 = temp2;\n            }\n            int length = result.size();\n            System.out.println(result.get(length - 5) + \" \"\n                    + result.get(length - 4) + \" \" + result.get(length - 2));\n        }\n    }\n\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "/**\n * @author Finn Lidbetter\n */\nimport java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\n\npublic class TaskA {\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringBuilder sb = new StringBuilder();\n\n    int n = Integer.parseInt(br.readLine());\n    String[] s = br.readLine().split(\" \");\n    int[] arr = new int[n];\n    for (int i=0; i<n; i++) {\n      arr[i] = Integer.parseInt(s[i]);\n    }\n    Arrays.sort(arr);\n    boolean[] vis = new boolean[n];\n    int nColours = 0;\n    int nVis = 0;\n    int index = 0;\n    while (nVis<n) {\n      while (index<n && nVis<n) {\n        if (vis[index]) {\n          index++;\n          continue;\n        }\n        int val = arr[index];\n        nColours++;\n        while (index<n && nVis<n) {\n          if (vis[index]) {\n            index++;\n            continue;\n          }\n          if (arr[index]%val==0) {\n            vis[index] = true;\n            nVis++;\n          }\n          index++;\n        }\n        index = 0;\n      }\n    }\n    System.out.println(nColours);\n\n  }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif (n % 2 == 0) {\n\t\t\tSystem.out.println(4 + \" \" + (n - 4));\n\t\t} else {\n\t\t\tSystem.out.println(9 + \" \" + (n - 9));\n\t\t}\n\t}\n}", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.Scanner;\n\npublic class Solution {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString s = sc.next();\n\n\t\tStringBuilder ans = new StringBuilder();\n\t\tint count = 0;\n\t\tint open = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tans.append(\"(\");\n\t\t\t\tcount++;\n\t\t\t\topen++;\n\t\t\t} else {\n\t\t\t\tans.append(\")\");\n\t\t\t\topen--;\n\t\t\t}\n\t\t\tif (count == k / 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile (open > 0) {\n\t\t\tans.append(\")\");\n\t\t\topen--;\n\t\t}\n\t\tSystem.out.println(ans.toString());\n\t}\n}", "complexity": "linear", "problem": "1023_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class ATestingRound5 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint T = in.nextInt();\n\t\twhile(T --> 0) {\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tint[] arr = {a, b};\n\t\t\tArrays.sort(arr);\n\t\t\twhile(arr[0] != 0) {\n\t\t\t\tcount += arr[1] / arr[0];\n\t\t\t\tarr[1] = arr[1] % arr[0];\n\t\t\t\t\n\t\t\t\tArrays.sort(arr);\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\tin.close();\n\t}\n\n}\n/*\n2\n4 17\n7 987654321\noutputCopy\n8\n141093479\n*/", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\n\npublic class LittleElephant {\n\tpublic static void main(String[] args){\n\t\tScanner input = new Scanner(System.in);\n\t\tint n = input.nextInt(); \n\t\tint temp;\n\t\tArrayList<Integer> a2 = new ArrayList<Integer>();\n\t\tArrayList<Integer> a1 = new ArrayList<Integer>();\n\t\tint count = 0;\n\t\tint temp1,temp2;\n\t\t\n\t\tfor(int i= 0; i < n ; i++){\n\t\t\ttemp = input.nextInt();\n\t\t\ta2.add(temp);\n\t\t\ta1.add(temp);\n\t\t}\n\t\tCollections.sort(a2);\n\t\tinput.close();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ttemp1 = a2.get(i);\n\t\t\ttemp2 = a1.get(i);\n\t\t\tif(temp1 != temp2){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(count==2 || count==0){\n\t\t\tSystem.out.println(\"YES\");\n\t\t}else{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}\n", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class D {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    \n    public static void sort(int arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(int arr[],int l1,int r1,int l2,int r2) {\n        int tmp[]=new int[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void sort(long arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(long arr[],int l1,int r1,int l2,int r2) {\n        long tmp[]=new long[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    static int n,m,k,uu[][],rr[][],dd[][],ll[][],dp[][][];\n    \n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        StringBuilder ans=new StringBuilder(\"\");\n        \n        n=input.scanInt();\n        m=input.scanInt();\n        k=input.scanInt();\n        \n        dp=new int[n][m][k];\n        for(int i=0;i<n;i++) {\n            for(int j=0;j<m;j++) {\n                for(int kk=0;kk<k;kk++) {\n                    dp[i][j][kk]=-1;\n                }\n            }\n        }\n        \n        uu=new int[n][m];\n        rr=new int[n][m];\n        dd=new int[n][m];\n        ll=new int[n][m];\n        \n        for(int i=0;i<n;i++) {\n            for(int j=0;j<m-1;j++) {\n                int tmp=input.scanInt();\n                rr[i][j]=tmp;\n                ll[i][j+1]=tmp;\n            }\n        }\n        \n        for(int i=0;i<n-1;i++) {\n            for(int j=0;j<m;j++) {\n                int tmp=input.scanInt();\n                dd[i][j]=tmp;\n                uu[i+1][j]=tmp;\n            }\n        }\n        \n        for(int i=0;i<n;i++) {\n            for(int j=0;j<m;j++) {\n                if(k%2!=0) {\n                    ans.append(-1+\" \");\n                    continue;\n                }\n                ans.append((2*solve(i,j,k/2))+\" \");\n            }\n            ans.append(\"\\n\");\n        }\n        \n        System.out.println(ans);\n    }\n    \n    public static int solve(int x,int y,int rem) {\n        if(rem==0) {\n            return 0;\n        }\n        \n        if(dp[x][y][rem]!=-1) {\n            return dp[x][y][rem];\n        }\n        \n        int ans=Integer.MAX_VALUE/10;\n        if(uu[x][y]!=0) {\n            ans=Math.min(ans,uu[x][y]+solve(x-1,y,rem-1));\n        }\n        if(rr[x][y]!=0) {\n            ans=Math.min(ans,rr[x][y]+solve(x,y+1,rem-1));\n        }\n        if(dd[x][y]!=0) {\n            ans=Math.min(ans,dd[x][y]+solve(x+1,y,rem-1));\n        }\n        if(ll[x][y]!=0) {\n            ans=Math.min(ans,ll[x][y]+solve(x,y-1,rem-1));\n        }\n        \n        dp[x][y][rem]=ans;\n        \n        return ans;\n    }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class ProblemA {\n    InputReader in; PrintWriter out;\n\n    long power(long a, long b, long mod) {\n        long ret = 1;\n        long mul = a;\n        while (b > 0) {\n            if (b % 2 == 1) {\n                ret = (ret * mul % mod);                \n            }\n            mul = (mul * mul) % mod;\n            b = b / 2;\n        }\n        return ret;\n    }\n    \n    void solve() {\n        long n = in.nextLong();\n        long m = in.nextLong();\n        long k = in.nextLong();\n        long mod = 1000000009;\n        long x = m - (n - n / k);\n        if (x <= 0) {\n            out.println(m);\n        }\n        else {\n            long score = 1;\n            score = power(2, x + 1, mod);\n            score = (score + mod - 2) % mod;\n//          out.println(score);\n            long ans = ((score * k) + m - x * k + mod) % mod;\n            out.println(ans);\n        }\n    }\n    \n    ProblemA(){\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        try {\n            if (oj) {\n                in = new InputReader(System.in);\n                out = new PrintWriter(System.out);\n            }\n            else {\n                Writer w = new FileWriter(\"output.txt\");\n                in = new InputReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(w);\n            }\n        } catch(Exception e) {\n            throw new RuntimeException(e);\n        }\n        solve();\n        out.close();\n    }\n    public static void main(String[] args){\n        new ProblemA();\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n    \n    public InputReader(FileReader fr) {\n        reader = new BufferedReader(fr);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n}", "complexity": "logn", "problem": "0338_A", "from": "CODEFORCES", "tags": "greedy,math,number theory"}
{"src": "import java.io.*;\npublic class again_25 {\n\tpublic static void main(String ar[])throws IOException\n\t{\n\t\tlong n;\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tn=Long.parseLong(br.readLine());\n\t\tSystem.out.println(\"25\");\n\t}\n}\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n    \n    private static int[] T;\n    \n    public static void main(String[] args){\n        \n        Scanner in = new Scanner(System.in);\n        char[] input =  in.nextLine().toCharArray();\n        int length = input.length;\n        int max = 0;\n        for(int i=0; i<length; i++){\n            char[] subString = Arrays.copyOfRange(input, 1, input.length);\n            int temp = solve(input, subString);\n            if(temp > max) max = temp;\n            input = Arrays.copyOfRange(input, 1, input.length);\n        }\n        System.out.println(max);\n        \n    }\n\n    private static int solve(char[] P, char[] S) {\n        \n        T = new int[P.length+1];\n        \n        preKmp(P, P.length, T);\n        int max = 0;\n\n        int i = 0, j = 0;\n        while (j < S.length) {\n            while (i > -1 && (P[i] != S[j]))\n                i = T[i];\n            i++;\n            j++;\n            if ( i > max) max = i;\n            if (i >= P.length) {\n                i = T[i];\n            }\n        }\n        \n        return max;\n        \n        \n    }\n\n    private static void preKmp(char[] x, int m, int[] kmpNext) {\n           int i = 0, j = kmpNext[0] = -1;\n           \n           while (i < m-1) {\n              while (j > -1 && x[i] != x[j])\n                 j = kmpNext[j];\n              i++;\n              j++;\n              if (x[i] == x[j])\n                 kmpNext[i] = kmpNext[j];\n              else\n                 kmpNext[i] = j;\n           }\n\n        \n    }\n} ", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\npublic static void main(String args[]) throws Exception\n    {\n     \n     BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n     int n=Integer.parseInt(br.readLine());\n     System.out.println(\"0 0 \"+n);}\n\n}\n\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import com.sun.source.tree.Tree;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class TaxiDriversAndLyft {\n    PrintWriter out;\n    StringTokenizer st;\n    BufferedReader br;\n    final int imax = Integer.MAX_VALUE, imin = Integer.MIN_VALUE;\n    final int mod = 1000000007;\n\n    void solve() throws Exception {\n        int t = 1;\n//        t = ni();\n        for (int ii = 0; ii < t; ii++) {\n            int n=ni(), m= ni();\n            int[] arr= new int[n+m];\n            for (int i = 0; i < n+m; i++) arr[i]=ni();\n\n            int[] val= new int[n+m];\n            for(int i=0;i<n+m;i++) val[i]= ni();\n\n            int[] l= new int[n+m];\n            int[] r= new int[n+m];\n            stack_l(val, l);\n            stack_r(val, r);\n\n            int[] ans= new int[n+m];\n            for(int i=0;i<n+m;i++) {\n                if(val[i]== 1) continue;\n\n                int dist_l= arr[i]- (l[i]!= -1? arr[l[i]]: (int)-1e9);\n                int dist_r= (r[i]!= imax? arr[r[i]]: imax)- arr[i];\n\n                if(dist_r< dist_l) ans[r[i]]++;\n                else ans[l[i]]++;\n            }\n\n            for(int i=0;i<n+m;i++) if(val[i]== 1) out.print(ans[i]+\" \");\n            out.println();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new TaxiDriversAndLyft().run();\n    }\n\n    void run() throws Exception {\n        if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n            File file = new File(\"C:\\\\college\\\\CodeForces\\\\inputf.txt\");\n            br = new BufferedReader(new FileReader(file));\n            out = new PrintWriter(\"C:\\\\college\\\\CodeForces\\\\outputf.txt\");\n        } else {\n            out = new PrintWriter(System.out);\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        st = new StringTokenizer(\"\");\n        while (true) {\n            solve();\n            String s = br.readLine();\n            if (s == null) break;\n            else st = new StringTokenizer(s);\n        }\n        out.flush();\n    }\n\n    void read() throws Exception {\n        st = new StringTokenizer(br.readLine());\n    }\n\n    int ni() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return Integer.parseInt(st.nextToken());\n    }\n\n    char nc() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return st.nextToken().charAt(0);\n    }\n\n    long nl() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return Long.parseLong(st.nextToken());\n    }\n\n    double nd() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return Double.parseDouble(st.nextToken());\n    }\n\n    String ns() throws Exception {\n        String s = br.readLine();\n        return s.length() == 0 ? br.readLine() : s;\n    }\n\n    void print(int[] arr) {\n        for (int i : arr) out.print(i + \" \");\n        out.println();\n    }\n\n    void print(long[] arr) {\n        for (long i : arr) out.print(i + \" \");\n        out.println();\n    }\n\n    void print(int[][] arr) {\n        for (int[] i : arr) {\n            for (int j : i) out.print(j + \" \");\n            out.println();\n        }\n    }\n\n    void print(long[][] arr) {\n        for (long[] i : arr) {\n            for (long j : i) out.print(j + \" \");\n            out.println();\n        }\n    }\n\n    long add(long a, long b) {\n        if (a + b >= mod) return (a + b) - mod;\n        else return a + b >= 0 ? a + b : a + b + mod;\n    }\n\n    long mul(long a, long b) {\n        return (a * b) % mod;\n    }\n\n    void print(boolean b) {\n        if (b) out.println(\"YES\");\n        else out.println(\"NO\");\n    }\n\n    long binExp(long base, long power) {\n        long res = 1l;\n        while (power != 0) {\n            if ((power & 1) == 1) res = mul(res, base);\n            base = mul(base, base);\n            power >>= 1;\n        }\n        return res;\n    }\n\n    long gcd(long a, long b) {\n        if (b == 0) return a;\n        else return gcd(b, a % b);\n    }\n\n    // strictly smaller on left\n    void stack_l(int[] arr, int[] left) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < arr.length; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] <= arr[i]) stack.pop();\n            if (stack.isEmpty()) left[i] = -1;\n            else left[i] = stack.peek();\n            stack.push(i);\n        }\n    }\n\n    // strictly smaller on right\n    void stack_r(int[] arr, int[] right) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = arr.length - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] <= arr[i]) stack.pop();\n            if (stack.isEmpty()) right[i] = imax;\n            else right[i] = stack.peek();\n            stack.push(i);\n        }\n    }\n\n    private void sort(int[] arr) {\n        List<Integer> list = new ArrayList<>();\n        for (int i : arr) list.add(i);\n        Collections.sort(list);\n        for (int i = 0; i < arr.length; i++) arr[i] = list.get(i);\n    }\n}", "complexity": "linear", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.Scanner;\n\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tnew A().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.next();\n\t\tsc.close();\n\t\t\n\t\tint res = 0;\n\t\tfor (int i = 0; i < s.length(); i++)\n\t\t\tfor (int j = i + 1; j <= s.length(); j++) {\n\t\t\t\tString sub = s.substring(i, j);\n\t\t\t\tint c = count(s, sub);\n\t\t\t\tif (c >= 2)\n\t\t\t\t\tres = Math.max(res, sub.length());\n\t\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tprivate int count(String s, String sub) {\n\t\tint res = 0;\n\t\twhile (s.length() > 0) {\n\t\t\tif (s.startsWith(sub))\n\t\t\t\tres++;\n\t\t\ts = s.substring(1);\n\t\t}\n\t\treturn res;\n\t}\n\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.Scanner;\n\n\npublic class ProblemC {\n\n    public static void main(String[] args) {\n        ProblemC problem = new ProblemC();\n        problem.solve();\n    }\n\n    private void solve() {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        String s = sc.next();\n        int ret = n;\n        int toth = 0;\n        int tott = 0;\n        for (int j = 0; j < n; j++) {\n            if (s.charAt(j) == 'H') {\n                toth++;\n            } else {\n                tott++;\n            }\n        }\n        for (int j = 0; j < n; j++) {\n            int cnth = 0;\n            for (int k = 0; k < toth; k++) {\n                int pos = (j + k) % n;\n                if (s.charAt(pos) == 'H') {\n                    cnth++;\n                }\n            }\n            int makeh = toth - cnth;\n            ret = Math.min(ret, makeh);\n        }\n        System.out.println(ret);\n    }\n\n}\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "//david alexander\nimport java.util.*;\n\npublic class Subtract {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint a,b;\n\t\tString answer = \"\";\n\t\twhile(n!=0){\n\t\t\ta = sc.nextInt();\n\t\t\tb = sc.nextInt();\n\t\t\tanswer += solve(a,b) + \"\\n\";\n\t\t\tn--;\n\t\t}\n\t\tSystem.out.println(answer);\n\t}\n\t\n\tpublic static int solve(int a, int b){\n\t\tint count = 0;\n\t\tint div;\n\t\tint mod;\n\t\twhile(true){\n\t\t\tif(a >= b){\n\t\t\t\tdiv = a/b;\n\t\t\t\tmod = a%b;\n\t\t\t\tcount += div;\n\t\t\t\tif(mod==0){\n\t\t\t\t\treturn count;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ta = mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdiv = b/a;\n\t\t\t\tmod = b%a;\n\t\t\t\tcount += div;\n\t\t\t\tif(mod==0){\n\t\t\t\t\treturn count;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tb = mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n/*\n * @author Tnascimento \n */\n\npublic class MaeDosDragoes {\n\tpublic static PrintWriter saida = new PrintWriter(System.out, false);\n\tpublic static class Escanear {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\t\tpublic Escanear() {\n            this(new InputStreamReader(System.in));\n        }\n\t\tpublic Escanear(Reader in) {\n            reader = new BufferedReader(in);\n        }\n        String proximo() {\n            if (tokenizer == null || !tokenizer.hasMoreElements()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        int proximoNum() {\n            return Integer.parseInt(proximo());\n        }\n    }\n\n\n\n    public static void main(String[] args) {\n\t\tEscanear escanear = new Escanear();\n        int proximoInt = escanear.proximoNum();\n        double proximoDouble = escanear.proximoNum();\n        long[] aux = new long[proximoInt];\n        for(Integer i = 0; i < proximoInt; i++) {\n            for(Integer j =0; j < proximoInt; j++) {\n                Integer val = escanear.proximoNum();\n                if (val.equals(1) || i.equals(j)) {\n\t\t\t\t aux[i] |= 1L << j;\n\t\t\t\t}\n            }\n        }\n\n        int esquerda = proximoInt/2;\n        int direita = proximoInt - esquerda;\n\n        int[] depois = new int[1 << esquerda];\n        int maiorMascara = 1 << esquerda;\n\n        for(int mascara = 1; mascara <maiorMascara; mascara++) {\n            int mascaraAtual = mascara;\n\n            for(int j = 0; j < esquerda; j++) {\n                if (((1 << j) & mascara) > 0) {\n                    mascaraAtual &= aux[j + direita] >> direita;\n                    depois[mascara] = Math.max(depois[mascara], depois[mascara ^ (1 << j)]);\n                }\n            }\n            if (mascara == mascaraAtual) {\n                depois[mascara] = Math.max(depois[mascara],Integer.bitCount(mascara));\n            }\n        }\n        int auxiliar = 0;\n        int mascaraMaxima = 1 << direita;\n        for(int mascara = 0; mascara < mascaraMaxima; mascara++) {\n            int mascaraCorrente = mascara;\n            int mascaraValor = maiorMascara -1;\n            for(int j = 0; j < direita; j++) {\n                if (((1 << j) & mascara) > 0) {\n                    mascaraCorrente &= (aux[j] & (mascaraMaxima-1));\n                    mascaraValor &= aux[j] >> direita;\n                }\n            }\n            if (mascaraCorrente != mascara) continue;\n            auxiliar = Math.max(auxiliar, Integer.bitCount(mascara) + depois[mascaraValor]);\n        }\n        proximoDouble/=auxiliar;\n        saida.println(proximoDouble * proximoDouble * (auxiliar * (auxiliar-1))/2);\n        saida.flush();\n    }\n}\n", "complexity": "np", "problem": "0839_E", "from": "CODEFORCES", "tags": "brute force,graphs,math,meet-in-the-middle"}
{"src": "import java.util.*;\n\nimport java.io.*;\n\n\n\npublic class Main implements Runnable {\n\n\t\t\n\n\tpublic void solve() throws IOException {\n\n\t\tint N = nextInt();\n\n                int M = nextInt();\n\n                \n\n                int B = nextInt();\n\n                int[][] burn = new int[B][2];\n\n                for(int i = 0; i < B; i++){\n\n                        burn[i][0] = nextInt();\n\n                        burn[i][1] = nextInt();\n\n                }\n\n                \n\n                int ansx = -1;\n\n                int ansy = -1;\n\n                int ans = -1;\n\n                \n\n                for(int i = 1; i <= N; i++){\n\n                        for(int j = 1; j <= M; j++){\n\n                                int burnAt = Integer.MAX_VALUE;\n\n                                for(int k = 0; k < B; k++){\n\n                                        int now = distance(i, j, burn[k][0], burn[k][1]);\n\n                                        burnAt = Math.min(burnAt, now);\n\n                                }\n\n                                //System.out.println(burnAt + \" \" + i + \" \" + j);\n\n                                if(burnAt >= ans){\n\n                                        \n\n                                        ans = burnAt;\n\n                                        ansx = i;\n\n                                        ansy = j;\n\n                                        \n\n                                }\n\n                        }\n\n                }\n\n                \n\n                \n\n                out.println(ansx + \" \" + ansy);\n\n\t}\n\n        \n\n        private int distance(int x, int y, int xx, int yy){\n\n                //withour sqrt\n\n                return Math.abs(xx - x) + Math.abs(yy - y);\n\n        }\n\n\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t//-----------------------------------------------------------\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\n\t}\n\n\n\n\tpublic void run() {\n\n\t\ttry {\n\n\t\t\t//in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t\tin = new BufferedReader(new FileReader(new File(\"input.txt\")));\n\n                        out = new PrintWriter(new FileWriter(new File(\"output.txt\")));\n\n                        tok = null;\n\n\t\t\tsolve();\n\n\t\t\tin.close();\n\n                        out.close();\n\n\t\t} catch (IOException e) {\n\n\t\t\tSystem.exit(0);\n\n\t\t}\n\n\t}\n\n\n\n\tpublic String nextToken() throws IOException {\n\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\n\t\t\ttok = new StringTokenizer(in.readLine());\n\n\t\t}\n\n\t\treturn tok.nextToken();\n\n\t}\n\n\n\n\tpublic int nextInt() throws IOException {\n\n\t\treturn Integer.parseInt(nextToken());\n\n\t}\n\n\n\n\tpublic long nextLong() throws IOException {\n\n\t\treturn Long.parseLong(nextToken());\n\n\t}\n\n\n\n\tpublic double nextDouble() throws IOException {\n\n\t\treturn Double.parseDouble(nextToken());\n\n\t}\n\n\n\n        PrintWriter out;\n\n\tBufferedReader in;\n\n\tStringTokenizer tok;\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class A implements Runnable {\n    private void solve() throws IOException {\n        String str = nextToken();\n        for (int i=str.length()-1; i>=0; --i)\n            for (int j=0; j+i<=str.length(); ++j)\n                if (str.substring(j+1).contains(str.substring(j, j+i))) {\n                    writer.println(i);\n                    return;\n                }\n        writer.println(0);\n    }\n\n    public static void main(String[] args) {\n        new Thread(new A()).start();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.util.*;\n\n\npublic class CFContest {\n    public static void main(String[] args) throws Exception {\n        boolean local = System.getProperty(\"ONLINE_JUDGE\") == null;\n        boolean async = true;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"dalt\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        long lInf = (long) 1e18;\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        public void solve() {\n            int n = io.readInt();\n            int[] data = new int[n];\n            for (int i = 0; i < n; i++) {\n                data[i] = io.readInt();\n            }\n            Arrays.sort(data);\n            boolean[] paint = new boolean[n];\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if (paint[i]) {\n                    continue;\n                }\n                cnt++;\n                for (int j = i; j < n; j++) {\n                    if (data[j] % data[i] == 0) {\n                        paint[j] = true;\n                    }\n                }\n            }\n\n            io.cache.append(cnt);\n        }\n\n    }\n\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder(20 << 20);\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\npublic class Lucky {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint n = in.nextInt();\n\n\t\tif(n%4==0 || n%7==0 || n%47==0 || n%74==0 || n%474==0 || n%447==0 || n%774==0 || n%747==0 || n%477==0 || n%744==0)System.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t}\n\n}\n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import java.util.*;\npublic class TestClass\n{\n   public static void main(String args[])\n   {\n   \tScanner in = new Scanner(System.in);\n   \tint n = in.nextInt();\n   \tint m = in.nextInt();\n   \tint k = in.nextInt();\n   \tint arr[] = new int[n+1];\n   \tfor(int i =0;i<n;i++)\n   \t arr[i+1]= in.nextInt();\n   \t\n   \tlong sum[] = new long [n+1];\n   \t\n   \tfor(int i=1;i<=n;i++)\n   \t sum[i]=sum[i-1]+arr[i];\n   \t\n    long dp[] = new long[n+1];\n\n    for(int i =1;i<=n;i++)\n    {\n      for(int j=i;j>i-m&&j>=1;j--)\n      {\n        long val = sum[i]-sum[j-1]+dp[j-1]-k;\n        dp[i]= Math.max(dp[i],val);\n      }\t\n    }\n    long max =0;\n    for(int i =1;i<=n;i++)\n     max=Math.max(max,dp[i]);\n    \n    System.out.println(max);\n     \n   }\t\n}", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "import java.util.Scanner;\n\n\npublic class Main {\n\n    public static void main(String[] args) {\nScanner input = new Scanner(System.in);\nlong x = input.nextLong();\n\nif(x==1||x==2){System.out.println(x);\n    \n}\nelse if(x%2==0&&x>2&&x%3!=0){\n    System.out.println((x)*(x-1)*(x-3));\n    \n}else if(x%2==0&&x%3==0){\n    System.out.println((x-1)*(x-2)*(x-3));\n}\n\nelse {System.out.println(x*(x-1)*(x-2));}\n    }\n}\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*; \n public class A{\n\nstatic FastReader scan=new FastReader();\n public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n  static LinkedList<Edge>edges[];\n  static boolean stdin = true;\n    static String filein = \"input\";\n    static String fileout = \"output\";\nstatic int dx[] = { -1, 0, 1, 0 };\nstatic int dy[] = { 0, 1, 0, -1 };\nint dx_8[]={1,1,1,0,0,-1,-1,-1};\nint dy_8[]={-1,0,1,-1,1,-1,0,1};\nstatic char sts[]={'U','R','D','L'};\nstatic boolean prime[];\nstatic long LCM(long a,long b){\n    return (Math.abs(a*b))/gcd(a,b);\n   }\n   static long gcd(long a, long b) {\n    if(a!=0&&b!=0)\n        while((a%=b)!=0&&(b%=a)!=0);\n    return a^b;\n}\nstatic int countSetBits(int n) \n    { \n        int count = 0; \n        while (n > 0) { \n            count += n & 1; \n            n >>= 1; \n        } \n        return count; \n    } \n static void sieve(long n) \n    { \n        \n        prime = new boolean[(int)n+1]; \n        for(int i=0;i<n;i++) \n            prime[i] = true; \n          \n        for(int p = 2; p*p <=n; p++) \n        { \n           \n            if(prime[p] == true) \n            { \n                \n                for(int i = p*p; i <= n; i += p) \n                    prime[i] = false; \n            } \n        } \n    }  \n  \n \n \n           static boolean isprime(long x)\n           {\n            for(long i=2;i*i<=x;i++)\n                if(x%i==0)\n                    return false;\n                return true;\n           }\n           static int perm=0,FOR=0;\n           \n     \n\nstatic boolean flag=false;\nstatic int len=100000000;\n\nstatic ArrayList<Pair>inters=new ArrayList<Pair>();\n\n\n\n\n\nstatic StringBuilder sb;\nstatic void swap(int i,int j,StringBuilder st)\n{\n    char tmp=st.charAt(i);\n    st.setCharAt(i,st.charAt(j));\n    st.setCharAt(j,tmp);\n}\n\n\n private static int next(int[] arr, int target)  \n    {  \n        int start = 0, end = arr.length - 1;  \n    \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;  \n    \n            // Move to right side if target is  \n            // greater.  \n            if(arr[mid]==target)\n                return mid;\n            if (arr[mid] <target) {  \n                start = mid + 1;  \n            }  \n    \n            // Move left side.  \n            else {  \n                ans = mid;  \n                end = mid - 1;  \n            }  \n        }  \n        return ans;  \n    }  \n//static boolean vis[][];\n    static long solve(int h,long n,int cur)\n    {\n        if(h==0)\n            return 0;\n        long half=1L<<(h-1);\n        if(n<=half)\n        {\n            if((cur^1)==0)\n                return 1+solve(h-1,n,0);\n            else \n                return 2*half+solve(h-1,n,0);\n        }\n        else \n        {\n              if((cur^1)==0)\n             return 2*half+solve(h-1,n-half,1);\n            else \n                return 1+solve(h-1,n-half,1);\n        }\n    }\nstatic int dist[][];\npublic static String removeLeadingZeroes(String str) {\n      String strPattern = \"^0+(?!$)\";\n      str = str.replaceAll(strPattern, \"\");\n      return str;\n   }\n\n    static String gcd(String str1, String str2)\n    {\n        // If str1 length is less than\n        // that of str2 then recur\n        // with gcd(str2, str1)\n        if (str1.length() < str2.length()) {\n            return gcd(str2, str1);\n        }\n \n        // If str1 is not the\n        // concatenation of str2\n        else if (!str1.startsWith(str2)) {\n            return \"\";\n        }\n \n        else if (str2.isEmpty()) {\n \n            // GCD string is found\n            return str1;\n        }\n        else {\n \n            // Cut off the common prefix\n            // part of str1 & then recur\n            return gcd(str1.substring(str2.length()),\n                       str2);\n        }\n    }\n   static ArrayList<Long>luckies=new ArrayList<Long>();\nstatic void d(long x)\n{\n    if(x>=(long)1e10)\n        return;\n    luckies.add(x);\n    d(x*10+4);\n    d(x*10+7);\n}\nstatic boolean isSubSequence(String str1,  \n                    String str2, int m, int n) \n    { \n        int j = 0; \n          \n        // Traverse str2 and str1, and compare  \n        // current character of str2 with first \n        // unmatched char of str1, if matched  \n        // then move ahead in str1 \n        for (int i = 0; i < n && j < m; i++) \n            if (str1.charAt(j) == str2.charAt(i)) \n                j++; \n  \n        // If all characters of str1 were found \n        // in str2 \n        return (j == m);  \n    }\n    \n  \nstatic long find(int x,int y)\n{\n    if(x>y)\n        return 1;\n    long l=find(x+1,y);\n    out.println(l);\n     //ans=pow(arr[x],l);\n    return 0;\n}\nstatic int sum(int x)\n{\n    int res=0;\n    while(x>0)\n    {\n        res+=(x%10);\n        x/=10;\n    }\n    return res;\n}\n\n\nstatic boolean vis[]=new boolean[101];\nstatic int n,m;\nstatic ArrayList<Pair>res=new ArrayList<Pair>();\nstatic String arr[];\nstatic void swap(int i,int j)\n{\n    String tmp=arr[i];\n    arr[i]=arr[j];\n    arr[j]=tmp;\n}\nstatic void sort()\n{\n    int n = arr.length; \n        for (int i = 0; i < n-1; i++) \n            for (int j = 0; j < n-i-1; j++) \n                if (arr[j].length() >arr[j+1].length()) \n                {  \n                    swap(j+1,j);\n                } \n\n}\npublic static class comp1 implements Comparator<Pair>{  \npublic int compare(Pair o1,Pair o2){  \nreturn (o2.x-o2.y)-(o1.x-o1.y);  \n}  }\n\npublic static void main(String[] args)  throws Exception \n{\n//SUCK IT UP AND DO IT ALRIGHT\n//scan=new FastReader(\"input.txt\");\n//out = new PrintWriter (\"output.txt\");\n   // System.out.println(pow((long)1e9,(long)1e9));\n    int arr[]=new int[14];\n    \n  for(int i=0;i<14;i++)\n    arr[i]=scan.nextInt();\nlong max=0;\nfor(int i=0;i<14;i++)\n{\n    int tmp[]=new int[14];\n   \n    for(int j=0;j<14;j++)\n        tmp[j]=arr[j];\n    int ok=tmp[i];\n    tmp[i]=0;\n    for(int l=0;l<14;l++)\n        tmp[l]+=(ok/14);\n    ok%=14; \n    int k=i+1;\n    while(ok-->0)\n    { \n        if(k==14)\n            k=0;\n            \n            tmp[k++]++;\n    }\n    long cur=0;\n    for(int l=0;l<14;l++)\n    {\n        if(tmp[l]%2==0)\n            cur+=tmp[l];\n    }\n    max=Math.max(cur,max);\n}\n\nout.println(max);\nout.close();\n\n//SEE UP \n\n}\nstatic long binexp(long a,long n)\n{\n    if(n==0)\n        return 1;\n    long res=binexp(a,n/2);\n    if(n%2==1)\n        return res*res*a;\n    else \n        return res*res;\n}\nstatic long powMod(long base, long exp, long mod) {\n       if (base == 0 || base == 1) return base;\n       if (exp == 0) return 1;\n       if (exp == 1) return base % mod;\n       long R = powMod(base, exp/2, mod) % mod;\n       R *= R;\n       R %= mod;\n       if ((exp & 1) == 1) {\n           return base * R % mod;\n       }\n       else return R % mod;\n   }\nstatic double dis(double x1,double y1,double x2,double y2)\n{\n    return Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\nstatic long mod(long x,long y)\n    {\n        if(x<0)\n            x=x+(-x/y+1)*y;\n        return x%y;\n    }\n public static  long pow(long b, long e) {\n            long r = 1;\n            while (e > 0) {\n                if (e % 2 == 1) r = r * b ;\n                b = b * b;\n                e >>= 1;\n            }\n            return r;\n        }\nprivate static void sort(long[] arr) {\n        List<Long> list = new ArrayList<>();\n        for (long object : arr) list.add(object);\n        Collections.sort(list);\n        for (int i = 0; i < list.size(); ++i) arr[i] = list.get(i);\n    }\n public static class FastReader {\n        BufferedReader br;\n        StringTokenizer root;\n        \n \n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        FastReader(String filename)throws Exception\n        {\n\n            br=new BufferedReader(new FileReader(filename));\n        }\n\n        boolean hasNext(){\n            String line;\n            while(root.hasMoreTokens())\n                return true;\n            return false;\n        }\n \n        String next() {\n            while (root == null || !root.hasMoreTokens()) {\n                try {\n                    root = new StringTokenizer(br.readLine());\n                } catch (Exception addd) {\n                    addd.printStackTrace();\n                }\n            }\n            return root.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (Exception addd) {\n                addd.printStackTrace();\n            }\n            return str;\n        }\n         public int[] nextIntArray(int arraySize) {\n            int array[] = new int[arraySize];\n \n            for (int i = 0; i < arraySize; i++) {\n                array[i] = nextInt();\n            }\n \n            return array;\n        }\n}\n static class Pair implements Comparable<Pair>{\n        public int x, y;\n        public Pair(int x1, int y1) {\n            x=x1;\n            y=y1;\n        }\n        @Override\n        public int hashCode() {\n            return (int)(x + 31 * y);\n        }\n        public String toString() {\n            return x + \" \" + y;\n        }\n        @Override\n        public boolean equals(Object o){\n            if (o == this) return true;\n            if (o.getClass() != getClass()) return false;\n            Pair t = (Pair)o;\n            return t.x == x && t.y == y;\n        }\npublic int compareTo(Pair o)\n{\n    return (x-o.x);\n\n    }\n\nstatic class pair{\n    int i;\n    int j;\npair(int i,int j){\n    this.i=i;\n    this.j=j;\n}}}\n static class tuple{\n        int x,y,z;\n        tuple(int a,int b,int c){\n            x=a;\n            y=b;\n            z=c;\n        }\n    }\n    static class Edge{\n        int d,w;\n        Edge(int d,int w)\n        {\n            this.d=d;\n            this.w=w;\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n", "complexity": "constant", "problem": "0975_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "import java.util.Scanner;\n\n\n\npublic class Ivan{\n\n\n\n  public static boolean check(long s,long n){\n\n    long big = 0;\n\n    long u = s;\n\n    while (s != 0){\n\n      long amari = s % 10;\n\n      big = big + s % 10;\n\n      s = (s - amari) / 10;\n\n    }\n\n    if (u - big >= n){\n\n      return true;\n\n    }else return false;\n\n  }\n\n  public static void main(String args[]){\n\n      Scanner scan = new Scanner(System.in);\n\n      long s = scan.nextLong();\n\n      long n = scan.nextLong();\n\n      long r =0;\n\n        if ( s > n){\n\n          for (long i = n;i<s+1;i++){\n\n          if (check(i,n)){\n\n            r=i;\n\n            break;\n\n          }else r = s+1;\n\n          }\n\n        System.out.print(s-r+1);\n\n      }else System.out.print(\"0\");\n\n  }\n\n}\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.math.*;\n \n     public class Sample implements Runnable\n    { \n          \n          public  static void solve()\n          {   \n              int n=i(); \n              int[] a=new int[n];\n              for(int i=0;i<n;i++)a[i]=i();\n              int temp=0;\n              for(int i=0;i<n;i++)\n              {\n                for(int j=i+1;j<n;j++)\n                {\n                  if(a[j]<a[i])temp++;\n                }\n              }\n              boolean even=(temp%2==0)?true:false;\n              int m=i();\n              while(m-->0)\n              {\n               int l=i(); int r=i();\n               long tt=(long)(Math.floor(r-l+1)/2);\n               if(tt%2==1)\n               {\n                if(even)\n                {\n                  out.println(\"odd\");\n                  even=false;\n                }\n                else\n                {\n                  out.println(\"even\");\n                  even=true;\n                }\n               }else\n               {\n                if(even)\n                {\n                  out.println(\"even\");\n                  \n                }\n                else\n                {\n                  out.println(\"odd\");\n                   \n                }\n               }\n              }\n             \n          }\n           \n           \n          public void run()\n          {   \n              solve();\n              out.close();\n          }\n \n          public static void main(String[] args) throws IOException\n          { \n                new Thread(null, new Sample(), \"whatever\", 1<<26).start();\n          }\n         abstract static class Pair implements Comparable<Pair>\n         {\n            long a;\n            int b;\n            \n            Pair(){}\n            Pair(long a,int b)\n            {\n                       this.a=a;\n                       this.b=b;\n            }\n   \n            public int compareTo(Pair x)\n           {\n                return Long.compare(x.a,this.a);\n           }\n        }\n        \n       \n         \n    ////////////////////////////////////////////////////// Merge Sort ////////////////////////////////////////////////////////////////////////\n     \n   static class Merge \n   {\n \n        public static void sort(long inputArr[]) \n        {\n            int length = inputArr.length;\n            doMergeSort(inputArr,0, length - 1);\n        }\n \n        private static void doMergeSort(long[] arr,int lowerIndex, int higherIndex) \n        {        \n            if (lowerIndex < higherIndex) {\n                int middle = lowerIndex + (higherIndex - lowerIndex) / 2;\n                doMergeSort(arr,lowerIndex, middle);\n                doMergeSort(arr,middle + 1, higherIndex);\n                mergeParts(arr,lowerIndex, middle, higherIndex);\n            }\n        }\n \n        private static void mergeParts(long[]array,int lowerIndex, int middle, int higherIndex) \n        {\n            long[] temp=new long[higherIndex-lowerIndex+1];\n            for (int i = lowerIndex; i <= higherIndex; i++) \n            {\n                temp[i-lowerIndex] = array[i];\n            }\n            int i = lowerIndex;\n            int j = middle + 1;\n            int k = lowerIndex;\n            while (i <= middle && j <= higherIndex) \n            {\n                if (temp[i-lowerIndex] < temp[j-lowerIndex]) \n                {\n                    array[k] = temp[i-lowerIndex];\n                    i++;\n                } else {\n                    array[k] = temp[j-lowerIndex];\n                    j++;\n                }\n                k++;\n            }\n            while (i <= middle) \n            {\n                array[k] = temp[i-lowerIndex];\n                k++;\n                i++;\n            }\n            while(j<=higherIndex)\n            {\n                array[k]=temp[j-lowerIndex];\n                k++;\n                j++;\n            }\n        }\n \n    }\n        \n      \n    /////////////////////////////////////////////////////////// Methods ////////////////////////////////////////////////////////////////////////\n \n \n     static boolean isPal(String s)\n     {\n        for(int i=0, j=s.length()-1;i<=j;i++,j--)\n        {\n                if(s.charAt(i)!=s.charAt(j)) return false;\n        }\n        return true;\n     }\n     static String rev(String s)\n     {\n                StringBuilder sb=new StringBuilder(s);\n                sb.reverse();\n                return sb.toString();\n     }\n     static int gcd(int a,int b){return (a==0)?b:gcd(b%a,a);}\n     static long gcdExtended(long a,long b,long[] x)\n     {\n \n        if(a==0){\n            x[0]=0;\n            x[1]=1;\n            return b;\n        }\n        long[] y=new long[2];\n        long gcd=gcdExtended(b%a, a, y);\n \n        x[0]=y[1]-(b/a)*y[0];\n        x[1]=y[0];\n \n        return gcd;\n    }\n \n     boolean findSum(int set[], int n, long sum)\n    {\n      if (sum == 0)\n         return true;\n      if (n == 0 && sum != 0)\n         return false;\n      if (set[n-1] > sum)\n         return findSum(set, n-1, sum);\n      return findSum(set, n-1, sum) ||findSum(set, n-1, sum-set[n-1]);\n    }\n   \n      public static long modPow(long base, long exp, long mod)\n     {\n        base = base % mod;\n        long result = 1;\n        while (exp > 0)\n       {\n            if (exp % 2 == 1) \n            {\n                result = (result * base) % mod;\n            }\n            base = (base * base) % mod;\n            exp = exp >> 1;\n       }\n        return result;\n    }\n \n    static long[] fac;\n    static long[] inv;\n    static long mod=(long)1e9+7;\n    public static void cal() \n    {\n        fac = new long[1000005];\n        inv = new long[1000005];\n        fac[0] = 1;\n        inv[0] = 1;\n        for (int i = 1; i <= 1000000; i++)\n        {\n            fac[i] = (fac[i - 1] * i) % mod;\n            inv[i] = (inv[i - 1] * modPow(i, mod - 2, mod)) % mod;\n        }\n    }\n \n    public static long ncr(int n, int r) \n    {\n        return (((fac[n] * inv[r]) % mod) * inv[n - r]) % mod;\n    }\n \n \n////////////////////////////////////////// Input Reader ////////////////////////////////////////////////////////////////////////////////////////////////////\n     \n    static InputReader sc = new InputReader(System.in);\n    static PrintWriter out= new PrintWriter(System.out);   \n    \n    static class InputReader {\n \n          private final InputStream stream;\n          private final byte[] buf = new byte[8192];\n          private int curChar, snumChars;\n          private SpaceCharFilter filter;\n \n          public InputReader(InputStream stream) {\n                  this.stream = stream;\n          }\n \n          public int snext()\n         {\n                  if (snumChars == -1)\n                          throw new InputMismatchException();\n                  if (curChar >= snumChars) {\n                          curChar = 0;\n                          try {\n                                  snumChars = stream.read(buf);\n                          } catch (IOException e) {\n                                  throw new InputMismatchException();\n                          }\n                          if (snumChars <= 0)\n                                  return -1;\n                  }\n                  return buf[curChar++];\n          }\n \n          public int nextInt()\n         {\n                  int c = snext();\n                  while (isSpaceChar(c)) \n                  {\n                          c = snext();\n                  }\n                  int sgn = 1;\n                  if (c == '-')\n                  {\n                          sgn = -1;\n                          c = snext();\n                  }\n                  int res = 0;\n                  do {\n                          if (c < '0' || c > '9')\n                                  throw new InputMismatchException();\n                          res *= 10;\n                          res += c - '0';\n                          c = snext();\n                  } while (!isSpaceChar(c));\n                  return res * sgn;\n          }\n \n          public long nextLong() \n          {\n                  int c = snext();\n                  while (isSpaceChar(c)) \n                  {\n                          c = snext();\n                  }\n                  int sgn = 1;\n                  if (c == '-') \n                  {\n                          sgn = -1;\n                          c = snext();\n                  }\n                  long res = 0;\n                  do {\n                          if (c < '0' || c > '9')\n                                  throw new InputMismatchException();\n                          res *= 10;\n                          res += c - '0';\n                          c = snext();\n                  } while (!isSpaceChar(c));\n                  return res * sgn;\n          }\n \n          public int[] nextIntArray(int n)\n          {\n                  int a[] = new int[n];\n                  for (int i = 0; i < n; i++) \n                  {\n                          a[i] = nextInt();\n                  }\n                  return a;\n          }\n \n          public long[] nextLongArray(int n)\n          {\n                  long a[] = new long[n];\n                  for (int i = 0; i < n; i++) \n                  {\n                          a[i] = nextLong();\n                  }\n                  return a;\n          }\n \n          \n          public String nextLine()\n         {\n                  int c = snext();\n                  while (isSpaceChar(c))\n                          c = snext();\n                  StringBuilder res = new StringBuilder();\n                  do {\n                          res.appendCodePoint(c);\n                          c = snext();\n                  } while (!isEndOfLine(c));\n                  return res.toString();\n          }\n \n          public boolean isSpaceChar(int c) \n          {\n                  if (filter != null)\n                          return filter.isSpaceChar(c);\n                  return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n          }\n \n          private boolean isEndOfLine(int c) \n          {\n                  return c == '\\n' || c == '\\r' || c == -1;\n          }\n \n          public interface SpaceCharFilter \n          {\n                  public boolean isSpaceChar(int ch);\n          }\n \n    }\n \n    static int i()\n    {\n        return sc.nextInt();\n    }\n    static long l(){\n        return sc.nextLong();\n    }\n    static int[] iarr(int n)\n    {\n        return sc.nextIntArray(n);\n    }\n    static long[] larr(int n)\n    {\n        return sc.nextLongArray(n);\n    }\n    static String s(){\n        return sc.nextLine();\n    }\n  \n \n }  ", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n    static int n;\n     static long TotalTime;\n    static Problem[] problems;\n    static StringBuilder sb;\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        sb = new StringBuilder();\n        n = sc.nextInt();\n        TotalTime = sc.nextLong();\n        problems = new Problem[n];\n        for (int i = 0; i < n; i++) {\n            problems[i] = new Problem (sc.nextInt(), sc.nextLong(), i);\n        }\n        Arrays.sort(problems);\n        long num = -1;\n        long high = n;\n        long low = 0;\n        int iter = 0;\n        while (high - low > 1) {\n            num = (high + low) / 2;\n            if (test(num, false)) {\n                low = num;\n            }\n            else {\n                high = num;\n            }\n        }\n        if (test(high, false))\n            num = high;\n        else\n            num = low;\n        test(num, true);\n        System.out.print(sb);\n    }\n\n    public static boolean test (long num, boolean print) {\n        int count = 0;\n        long sum = 0L;\n        if (print) sb.append(num + \"\\n\" + num + \"\\n\");\n        for (int i = 0; i < n && count < num; i++) {\n            if (problems[i].a >= num) {\n                count++;\n                sum += problems[i].t;\n                if (print) sb.append((problems[i].index + 1) + \" \");\n            }\n        }\n        return (count == num) && (sum <= TotalTime);\n    }\n\n    public static class Problem implements Comparable<Problem>  {\n        int a;\n        long t;\n        int index;\n        \n        public int compareTo(Problem o) {\n          return Long.compare(t, o.t);\n        }\n        public Problem (int a, long t, int index) {\n            this.a = a;\n            this.t = t;\n            this.index = index;\n        }\n    }\n\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n\n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextLong();\n            }\n            return a;\n        }\n    }\n}", "complexity": "nlogn", "problem": "0913_D", "from": "CODEFORCES", "tags": "binary search,brute force,data structures,greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class ProblemB {\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        String[] line = s.readLine().split(\" \");\n        long n = Long.valueOf(line[0]);\n        long y = Long.valueOf(line[1]);\n        long x = Long.valueOf(line[2]);\n        long c = Long.valueOf(line[3]);\n        \n        long min = 0;\n        long max = n*2L+20;\n        for (int cnt = 0 ; cnt < 300 ; cnt++) {\n            long med = (min+max) / 2L;\n            long ct = isok(med, n, x, y, c); \n            if (ct >= c) {\n                max = med;\n            } else {\n                min = med+1;\n            }\n        }\n        \n        long lst = max;\n        for (long d = -2 ; d <= 2 ; d++) {\n            if (max+d >= 0 && isok(max+d, n, x, y, c) >= c) {\n                lst = Math.min(lst, max+d);\n            }\n        }\n        \n        out.println(lst);\n        out.flush();\n    }\n    \n\n    private static long isok(long time, long n, long x, long y, long c) {\n        long total = time * 2 * (time + 1) + 1;\n        long top = y - time;\n        if (top <= 0) {\n            long dy = Math.abs(top)+1;\n            total -= dy*dy;\n            long over = dy - x;\n            if (over >= 1) {\n                total += (1L + over) * over / 2; \n            }\n            over = dy - ((n + 1) - x);\n            if (over >= 1) {\n                total += (1L + over) * over / 2; \n            }\n        }\n        \n        long bottom = y + time;\n        if (bottom > n) {\n            long dy = Math.abs(bottom-n);\n            total -= dy*dy;\n            long over = dy - x;\n            if (over >= 1) {\n                total += (1L + over) * over / 2; \n            }\n            over = dy - ((n + 1) - x);\n            if (over >= 1) {\n                total += (1L + over) * over / 2; \n            }\n        }\n        \n        long left = x - time;\n        if (left <= 0) {\n            long dy = Math.abs(left)+1;\n            total -= dy*dy;\n        }\n\n        long right = x + time;\n        if (right > n) {\n            long dy = Math.abs(right-n);\n            total -= dy*dy;\n        }\n        return total;\n    }\n\n    public static void debug(Object... os){\n        System.err.println(Arrays.deepToString(os));\n    }\n}", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "// Don't place your source in a package\nimport javax.swing.*;\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.stream.Stream;\n\n\n// Please name your class Main\npublic class Main {\n    static FastScanner fs=new FastScanner();\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int Int() {\n            return Integer.parseInt(next());\n        }\n\n        long Long() {\n            return Long.parseLong(next());\n        }\n\n        String Str(){\n            return next();\n        }\n    }\n\n\n    public static void main (String[] args) throws java.lang.Exception {\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n        int T=1;\n        for(int t=0;t<T;t++){\n            int n=Int();\n            int k=Int();\n            int A[][]=new int[n][2];\n            int a=0,b=0,c=0;\n            for(int i=0;i<A.length;i++){\n                A[i][0]=Int();\n                A[i][1]=Int()-1;\n\n                if(A[i][1]==0)a++;\n                else if(A[i][1]==1)b++;\n                else c++;\n            }\n\n            Arrays.sort(A,(x,y)->{\n                return x[0]-y[0];\n            });\n\n\n            Solution sol=new Solution(out);\n            sol.solution(A,k,a,b,c);\n        }\n        out.close();\n\n    }\n\n\n    public static int Int(){\n        return fs.Int();\n    }\n    public static long Long(){\n        return fs.Long();\n    }\n    public static String Str(){\n        return fs.Str();\n    }\n\n}\n\n\n\n\n\n\nclass Solution{\n    PrintWriter out;\n    public Solution(PrintWriter out){\n        this.out=out;\n    }\n\n\n\n    int mod=1000000007;\n    long dp3[][][][];\n    public void solution(int A[][],int T,int x,int y,int z){\n        long res=0;\n        int n=A.length;\n        long dp1[][]=new long[x+2][T+1];//a\n        long dp2[][][]=new long[y+2][z+2][T+2];//bc\n        dp3=new long[x+2][y+2][z+2][3];\n\n\n        //init\n        long f[]=new long[n+10];\n        f[0]=f[1]=1;\n        for(int i=2;i<f.length;i++){\n            f[i]=f[i-1]*i;\n            f[i]%=mod;\n        }\n        for(int i=0;i<dp3.length;i++){\n            for(int j=0;j<dp3[0].length;j++){\n                for(int k=0;k<dp3[0][0].length;k++){\n                    Arrays.fill(dp3[i][j][k],-1);\n                }\n            }\n        }\n\n\n        dp1[0][0]=1;\n        for(int i=0;i<A.length;i++){//a\n            int p=A[i][0],type=A[i][1];\n            if(type==0){\n                long newdp[][]=new long[dp1.length][dp1[0].length];\n                for(int cnt=1;cnt<=x;cnt++){\n                    for(int j=1;j<dp1[0].length;j++){\n                        if(j>=p){\n                            newdp[cnt][j]+=dp1[cnt-1][j-p];\n                            newdp[cnt][j]%=mod;\n                        }\n                    }\n                }\n\n                for(int cnt=0;cnt<=x;cnt++){\n                    for(int j=0;j<dp1[0].length;j++){\n                        newdp[cnt][j]+=dp1[cnt][j];\n                        newdp[cnt][j]%=mod;\n                    }\n                }\n                dp1=newdp;\n            }\n        }\n\n\n\n\n\n        dp2[0][0][0]=1;\n        for(int i=0;i<A.length;i++){//b c\n            int p=A[i][0],type=A[i][1];\n            if(type!=0){\n                long newdp[][][]=new long[dp2.length][dp2[0].length][dp2[0][0].length];\n                for(int a=0;a<dp2.length;a++){\n                    for(int b=0;b<dp2[0].length;b++){\n                        for(int j=0;j<dp2[0][0].length;j++){\n                            if(j>=p){\n                                if(type==1){\n                                    if(a-1>=0){\n                                        newdp[a][b][j]+=dp2[a-1][b][j-p];\n                                    }\n                                }\n                                else{\n                                    if(b-1>=0) {\n                                        newdp[a][b][j]+=dp2[a][b-1][j-p];\n                                    }\n                                }\n                            }\n                            newdp[a][b][j]%=mod;\n                        }\n                    }\n                }\n\n                for(int a=0;a<dp2.length;a++){\n                    for(int b=0;b<dp2[0].length;b++){\n                        for(int j=0;j<dp2[0][0].length;j++){\n                            newdp[a][b][j]+=dp2[a][b][j];\n                            newdp[a][b][j]%=mod;\n                        }\n                    }\n                }\n                dp2=newdp;\n            }\n        }\n\n\n        dp3[1][0][0][0]=1;\n        dp3[0][1][0][1]=1;\n        dp3[0][0][1][2]=1;\n        for(int i=0;i<dp3.length;i++){\n            for(int j=0;j<dp3[0].length;j++){\n                for(int k=0;k<dp3[0][0].length;k++){\n                    for(x=0;x<dp3[0][0][0].length;x++){\n                        if(dp3[i][j][k][x]==-1){\n                            dfs(i,j,k,x);\n                        }\n                    }\n                }\n            }\n        }\n\n\n\n\n\n\n\n        for(int i=0;i<dp3.length;i++){\n            for(int j=0;j<dp3[0].length;j++){\n                for(int k=0;k<dp3[0][0].length;k++){\n                    for(int cur=0;cur<3;cur++){\n                        for(int t=0;t<=T;t++){//price\n                            int aprice=t;\n                            int bcprice=T-t;\n                            long cnt1=dp1[i][aprice];\n                            long cnt2=dp2[j][k][bcprice];\n                            long combination=dp3[i][j][k][cur];\n                            ///if(combination==-1)combination=0;\n                            long p1=(cnt1*f[i])%mod;\n                            long p2=(((f[j]*f[k])%mod)*cnt2)%mod;\n                            long p3=(p1*p2)%mod;\n                            res+=(p3*combination)%mod;\n                            res%=mod;\n\n                        }\n                    }\n                }\n            }\n        }\n\n        //System.out.println(dp2[1][0][2]+\"   \"+dp3[1][1][0][0]);\n\n       // for(long p[]:dp1){\n           // System.out.println(Arrays.toString(p));\n        //}\n\n\n\n        out.println(res);\n\n    }\n\n    public long dfs(int a,int b,int c,int cur){\n        if(a<0||b<0||c<0){\n            return 0;\n        }\n        if(a==0&&b==0&&c==0){\n            return 0;\n        }\n\n        if(dp3[a][b][c][cur]!=-1)return dp3[a][b][c][cur];\n\n        long res=0;\n        if(cur==0){\n            res+=dfs(a-1,b,c,1);\n            res%=mod;\n            res+=dfs(a-1,b,c,2);\n            res%=mod;\n\n        }\n        else if(cur==1){\n            res+=dfs(a,b-1,c,0);\n            res%=mod;\n            res+=dfs(a,b-1,c,2);\n            res%=mod;\n        }\n        else{\n            res+=dfs(a,b,c-1,0);\n            res%=mod;\n            res+=dfs(a,b,c-1,1);\n            res%=mod;\n        }\n        res%=mod;\n        dp3[a][b][c][cur]=res;\n        return res;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n                             ;\\\n                            |' \\\n         _                  ; : ;\n        / `-.              /: : |\n       |  ,-.`-.          ,': : |\n       \\  :  `. `.       ,'-. : |\n        \\ ;    ;  `-.__,'    `-.|\n         \\ ;   ;  :::  ,::'`:.  `.\n          \\ `-. :  `    :.    `.  \\\n           \\   \\    ,   ;   ,:    (\\\n            \\   :., :.    ,'o)): ` `-.\n           ,/,' ;' ,::\"'`.`---'   `.  `-._\n         ,/  :  ; '\"      `;'          ,--`.\n        ;/   :; ;             ,:'     (   ,:)\n          ,.,:.    ; ,:.,  ,-._ `.     \\\"\"'/\n          '::'     `:'`  ,'(  \\`._____.-'\"'\n             ;,   ;  `.  `. `._`-.  \\\\\n             ;:.  ;:       `-._`-.\\  \\`.\n              '`:. :        |' `. `\\  ) \\\n      -hrr-      ` ;:       |    `--\\__,'\n                   '`      ,'\n                        ,-'\n\n\n                      free bug dog\n*/\n\n\n/*\n5 3\n1 1\n2 1\n2 1\n2 1\n2 2\n */", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n    public static void main (String[] args) throws java.lang.Exception\n    {\n     int n,a,b;\n     Scanner obj=new Scanner(System.in);\n    \n     n=obj.nextInt();\n    \n     if(n%4==0){a=n/2;b=n/2;System.out.println(a+\" \"+b);}\n     else if(n%2==0 && n%4!=0)\n     {a=n/2-1;b=n/2+1;System.out.println(a+\" \"+b);}\n     \n     else if(n%2!=0)\n     {  a=4;b=0;\n       while(b!=1)\n       { b=n-a;\n         if(b%3==0){ System.out.println(a+\" \"+b);break; }\n         else{a=a+2;}\n       }\n     }\n    }\n}", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main implements Runnable {\n\n    // ////////////////////////////////////////////////////////////////////\n    // Solution\n\n    private int n;\n    private int nn;\n    private int[][] D;\n    private int[] dp;\n    private int[] prev;\n\n    private void solve() throws Throwable {\n        int xs = nextInt(), ys = nextInt();\n        n = nextInt();\n        int[][] pts = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            pts[i][0] = nextInt();\n            pts[i][1] = nextInt();\n        }\n        D = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    D[i][i] = 2 * (sqr(pts[i][0] - xs) + sqr(pts[i][1] - ys));\n                } else {\n                    D[i][j] = sqr(pts[i][0] - xs) + sqr(pts[i][1] - ys)\n                            + sqr(pts[i][0] - pts[j][0])\n                            + sqr(pts[i][1] - pts[j][1]) + sqr(pts[j][0] - xs)\n                            + sqr(pts[j][1] - ys);\n                }\n            }\n        }\n        nn = 1 << n;\n        dp = new int[nn];\n        prev = new int[nn];\n        Arrays.fill(dp, -1);\n        Arrays.fill(prev, -1);\n        dp[0] = 0;\n        Dp(nn - 1);\n        pw.println(dp[nn - 1]);\n        pw.print(0);\n        for (int p = nn - 1; p != -1 && prev[p] != -1; p = prev[p]) {\n            int vv = p ^ prev[p];\n            for (int j = 0; j < n; j++) {\n                int jj = 1 << j;\n                if ((vv & jj) == 0) continue;\n                pw.print(' ');\n                pw.print(j + 1);\n            }\n            pw.print(\" 0\");\n        }\n        pw.println();\n    }\n\n    private int Dp(int i) {\n        if (dp[i] != -1) return dp[i];\n        int ans = 107374182, p = -1;\n        int j1 = 1, pos1 = 0;\n        for (; pos1 < n && j1 < nn; j1 *= 2, pos1++) {\n            if ((i & j1) == 0) continue;\n            int a = D[pos1][pos1] + Dp(i ^ j1);\n            if (a < ans) {\n                ans = a;\n                p = i ^ j1;\n            }\n            int j2 = j1 * 2, pos2 = pos1 + 1;\n            for (; pos2 < n && j2 < nn; j2 *= 2, pos2++) {\n                if ((i & j2) == 0) continue;\n                a = D[pos1][pos2] + Dp(i ^ (j1 | j2));\n                if (a < ans) {\n                    ans = a;\n                    p = i ^ (j1 | j2);\n                }\n            }\n            break;\n        }       \n        dp[i] = ans;\n        prev[i] = p;\n        return ans;\n    }\n\n    private int sqr(int i) {\n        return i * i;\n    }\n\n    // ////////////////////////////////////////////////////////////////////\n    // Utility functions\n\n    PrintWriter pw;\n    BufferedReader in;\n    StringTokenizer st;\n\n    void initStreams() throws FileNotFoundException {\n        //System.setIn(new FileInputStream(\"1\"));\n        in = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n    }\n\n    String nextString() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(nextString());\n    }\n\n    long nextLong() throws NumberFormatException, IOException {\n        return Long.parseLong(nextString());\n    }\n\n    double nextDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(nextString());\n    }\n\n    static Throwable sError;\n\n    public static void main(String[] args) throws Throwable {\n//      Thread t = new Thread(null, new Main(), \"1\", 1 << 27);\n//      t.start();\n//      t.join();\n        new Main().run();\n        if (sError instanceof OutOfMemoryError) {\n            throw sError;\n        }\n//      if (sError != null) {\n//          throw sError;\n//      }\n    }\n\n    public void run() {\n        try {\n            initStreams();\n            solve();\n        } catch (Throwable e) {\n            sError = e;\n        } finally {\n            if (pw != null)\n                pw.close();\n        }\n    }\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Double.parseDouble;\nimport static java.lang.String.*;\n    \npublic class Main {\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                                            //(new FileReader(\"input.in\"));\n        StringBuilder out = new StringBuilder();\n        StringTokenizer tk;\n        \n        \n        long n = parseLong(in.readLine());\n        \n        System.out.println(\"25\");\n    }\n    \n}\n ", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.stream.IntStream;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.TreeSet;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        SquareFreeDivisionHardVersion solver = new SquareFreeDivisionHardVersion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class SquareFreeDivisionHardVersion {\n        static final int MAX = 10000001;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int t = in.nextInt();\n            int[] d = PrimesAndDivisors.generateDivisors(MAX);\n            int[] reduced = new int[MAX];\n            for (int i = 1; i < MAX; i++) {\n                int val = i;\n                reduced[i] = 1;\n                while (val != 1) {\n                    int prime = d[val], exponent = 0;\n                    while (val % prime == 0) {\n                        val /= prime;\n                        exponent ^= 1;\n                    }\n                    if (exponent > 0) reduced[i] *= prime;\n                }\n            }\n            int counter = 0;\n            int[] seen = new int[MAX];\n            for (int jjjj = 0; jjjj < t; jjjj++) {\n                int n = in.nextInt(), k = in.nextInt();\n\n                int[] a = in.readIntArray(n);\n                for (int x : a) seen[reduced[x]] = -1;\n                int[][] dp = new int[n + 1][k + 1];\n                TreeSet<Integer> ts = new TreeSet<>();\n                int num = 0;\n                for (int i = 0; i < n; i++) {\n                    int R = reduced[a[i]];\n                    if (seen[R] != -1) {\n                        ts.add(-seen[R]);\n                        if (ts.size() > k + 1) ts.remove(ts.last());\n                        num++;\n                    }\n                    Arrays.fill(dp[i], n + 1);\n                    for (int j = num; j <= k; j++) dp[i][j] = 1;\n                    seen[R] = i;\n                    int u = 0;\n                    for (int r : ts) {\n                        for (int j = u; j <= k; j++) dp[i][j] = Integer.min(dp[i][j], dp[-r][j - u] + 1);\n                        u++;\n                    }\n//                System.out.println(i + \" \"  + Arrays.toString(dp[i]));\n//                System.out.println(\"Treeset : \" + ts);\n                }\n                out.println(dp[n - 1][k]);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class PrimesAndDivisors {\n        public static int[] generateDivisors(int n) {\n            int[] divisors = IntStream.range(0, n + 1).toArray();\n            for (int i = 2; i * i <= n; i++)\n                if (divisors[i] == i)\n                    for (int j = i * i; j <= n; j += i) divisors[j] = i;\n            return divisors;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void println(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n            writer.print('\\n');\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Created by IntelliJ IDEA.\n * User: Mirza\n * Date: 25.03.12\n * Time: 18:51\n * To change this template use File | Settings | File Templates.\n */\npublic class main {\n        static Scanner in; static int next() throws Exception {return in.nextInt();};\n    //static StreamTokenizer in; static int next() throws Exception {in.nextToken(); return (int) in.nval;}\n    //  static BufferedReader in;\n    static PrintWriter out;\n\n    public static void main(String[] args) throws Exception {\n        in = new Scanner(System.in);\n//      in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n//      in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        int n = next();\n        int a = next();\n        int b = next();\n        int k = 0;\n        int i;\n        int[] ar = new int[n];\n        for(i=0;i<n;i++)\n            ar[i]=next();\n        Arrays.sort(ar);\n        k = ar[n-a]-ar[b-1];\n        if(k<0)\n            out.print(0);\n        else out.print(k);\n        out.close();\n\n    }\n}", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.util.*;\n\npublic class A {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        long n = sc.nextLong();\n        \n        List<Long> fi = new ArrayList<Long>(); \n        \n        fi.add((long) 0);\n        fi.add((long) 1);\n        \n        while (fi.get(fi.size()-1)<n) {\n            fi.add(fi.get(fi.size()-1)+fi.get(fi.size()-2));\n        }\n        \n        int last = fi.size()-1;\n\n        long z = last-1>=0 ? fi.get(last-1) : 0;\n        long y = last-3>=0 ? fi.get(last-3) : 0;\n        long x = last-4>=0 ? fi.get(last-4) : 0;\n\n        if (x+y+z<n)\n            x=1;\n        \n        System.out.println(x+\" \"+y+\" \"+z);\n    }\n    \n}", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner r = new Scanner(System.in);\n        int N = r.nextInt();\n        int K = r.nextInt() - 1;\n        \n        T[] a = new T[N];\n        for(int i = 0; i < N; i++)\n            a[i] = new T(r.nextInt(), r.nextInt());\n        \n        Arrays.sort(a, new Comparator<T>() {\n\n            @Override\n            public int compare(T x, T y) {\n                if(x.p > y.p)return -1;\n                else if(x.p == y.p){\n                    if(x.t < y.t)return -1;\n                    else if(x.t == y.t)return 0;\n                    else return 1;\n                }else return 1;\n            }\n        });\n        \n        int ret = 0;\n        for(int i = 0; i < N; i++)\n            if(a[i].p == a[K].p && a[i].t == a[K].t)ret++;\n        \n        System.out.println(ret);\n    }\n}\n\nclass T{\n    int p, t;\n    public T(int pi, int ti){\n        p = pi;\n        t = ti;\n    }\n}", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        long a = in.nextLong();\n        long b = in.nextLong();\n        long res = 0;\n        while (b > 0) {\n            res += a / b;\n            long t = a % b;\n            a = b;\n            b = t;\n        }\n        out.println(res);\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    }\n\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class ProblemC {\n\tpublic static void main(String[] args) {\n\t\tFastScanner input = new FastScanner();\n\t\tint n = input.nextInt();\n\t\tint radius = input.nextInt();\n\t\tArrayList<Integer> diskXToFall = new ArrayList<Integer>();\n\t\tfor (int a = 0; a < n; a++) {\n\t\t\tdiskXToFall.add(input.nextInt());\n\t\t}\n\t\tArrayList<P> stationaryDisks = new ArrayList<P>();\n\t\tfor (int a = 0; a < n; a++) {\n\t\t\tdouble highCollision = radius;\n\t\t\tfor (P i : stationaryDisks) {\n\t\t\t\tif (Math.abs(diskXToFall.get(a) - i.x) - 1e-8 <= 2 * radius) {\n\t\t\t\t\tdouble hypot = 2 * radius;\n\t\t\t\t\tdouble leg = Math.abs(diskXToFall.get(a) - i.x);\n\t\t\t\t\tdouble yOffset = Math.sqrt(Math.abs(hypot * hypot - leg * leg));\n\t\t\t\t\thighCollision = Math.max(highCollision, yOffset + i.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstationaryDisks.add(new P(diskXToFall.get(a), highCollision));\n\t\t}\n\t\tfor(int a = 0; a < n; a++) {\n\t\t\tSystem.out.print(stationaryDisks.get(a).y + \" \");\n\t\t}\n\t\t\n\n\t}\n\n\tstatic class P implements Comparable<P> {\n\t\tfinal double x, y;\n\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tP sub(P that) {\n\t\t\treturn new P(x - that.x, y - that.y);\n\t\t}\n\n\t\tP add(P that) {\n\t\t\treturn new P(x + that.x, y + that.y);\n\t\t}\n\n\t\tdouble dot(P that) {\n\t\t\treturn x * that.x + y * that.y;\n\t\t}\n\n\t\tP scale(double s) {\n\t\t\treturn new P(x * s, y * s);\n\t\t}\n\n\t\t// Use hypot() only if intermediate overflow must be avoided; very slow\n\t\tdouble length() {\n\t\t\treturn sqrt(x * x + y * y);\n\t\t}\n\n\t\tdouble length2() {\n\t\t\treturn x * x + y * y;\n\t\t}\n\n\t\tP leftNormal() {\n\t\t\treturn new P(-y, x);\n\t\t} // rotateCCW(90deg)\n\n\t\tP rightNormal() {\n\t\t\treturn new P(y, -x);\n\t\t} // rotateCW(90deg)\n\n\t\tP normalize() {\n\t\t\tdouble n = length();\n\t\t\treturn n > 0 ? new P(x / n, y / n) : origin();\n\t\t}\n\n\t\tP scaleToLength(double l) {\n\t\t\treturn normalize().scale(l);\n\t\t}\n\n\t\tP project(P a) {\n\t\t\treturn scale(a.dot(this) / length2());\n\t\t}\n\n\t\tP reflect(P a) {\n\t\t\treturn project(a).scale(2.0).sub(a);\n\t\t}\n\n\t\t// use if sin, cos are known\n\t\tP rotateCCW(double sinT, double cosT) {\n\t\t\treturn new P(x * cosT - y * sinT, x * sinT + y * cosT);\n\t\t}\n\n\t\tP rotateCW(double sinT, double cosT) {\n\t\t\treturn rotateCCW(-sinT, cosT);\n\t\t}\n\n\t\tP rotate(double theta) {\n\t\t\treturn rotateCCW(sin(theta), cos(theta));\n\t\t}\n\n\t\t// angle to horizontal (1, 0); result is in [-pi, pi] rad or (-180-180) deg\n\t\tdouble theta() {\n\t\t\treturn atan2(y, x);\n\t\t}\n\n\t\t// angle between two vectors, result is in [0, pi] rad (0-180 deg)\n\t\tdouble angleTo(P a) {\n\t\t\treturn acos(this.dot(a) / this.length() / a.length());\n\t\t}\n\n\t\tboolean isOrigin() {\n\t\t\treturn x == 0 && y == 0;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"(%f,%f)\", this.x, this.y);\n\t\t}\n\n\t\tstatic P read(Scanner s) {\n\t\t\treturn new P(s.nextDouble(), s.nextDouble());\n\t\t}\n\n\t\tstatic P origin() {\n\t\t\treturn new P(0, 0);\n\t\t}\n\n\t\tdouble det(P that) {\n\t\t\treturn this.x * that.y - this.y * that.x;\n\t\t}\n\n\t\tdouble crossproduct(P that) {\n\t\t\treturn this.det(that);\n\t\t}\n\n\t\tP half(P q) {\n\t\t\treturn normalize().add(q.normalize());\n\t\t}\n\n\t\tdouble dist(P to) {\n\t\t\treturn sub(to).length();\n\t\t}\n\n\t\tdouble signedParallelogramArea(P b, P c) {\n\t\t\treturn (b.sub(this).crossproduct(c.sub(this)));\n\t\t}\n\n\t\tboolean isCollinearWith(P b, P c) {\n\t\t\treturn abs(signedParallelogramArea(b, c)) <= EPS;\n\t\t}\n\n\t\t// is going from this to b to c a CCW turn? Do not use if points may be\n\t\t// collinear\n\t\tboolean isCCW(P b, P c) {\n\t\t\treturn signedParallelogramArea(b, c) > 0;\n\t\t}\n\n\t\tdouble signedTriangleArea(P b, P c) {\n\t\t\treturn signedParallelogramArea(b, c) / 2.0;\n\t\t}\n\n\t\t// memory-optimized version of this.sub(to).length2() that avoids an\n\t\t// intermediate object\n\t\tdouble dist2(P to) {\n\t\t\tdouble dx = this.x - to.x;\n\t\t\tdouble dy = this.y - to.y;\n\t\t\treturn dx * dx + dy * dy;\n\t\t}\n\n\t\t/**\n\t\t * Compute x for a * x + b = 0 and ||x|| = C where 'this' is a. Care must be\n\t\t * taken to handle the case where either a.x or a.y is near zero.\n\t\t */\n\t\tP[] solveDotProductConstrainedByNorm(double b, double C) {\n\t\t\tP a = this;\n\t\t\tif (a.isOrigin())\n\t\t\t\tthrow new Error(\"degenerate case\");\n\n\t\t\tboolean transpose = abs(a.x) > abs(a.y);\n\t\t\ta = transpose ? new P(a.y, a.x) : a;\n\n\t\t\tDouble[] x = solvequadratic(a.length2(), 2.0 * b * a.x, b * b - a.y * a.y * C * C);\n\t\t\tP[] p = new P[x.length];\n\t\t\tfor (int i = 0; i < x.length; i++) {\n\t\t\t\tdouble x1 = x[i];\n\t\t\t\tdouble x2 = ((-b - a.x * x1) / a.y);\n\t\t\t\tp[i] = transpose ? new P(x2, x1) : new P(x1, x2);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P that) {\n\t\t\tif (abs(this.x - that.x) > EPS)\n\t\t\t\treturn Double.compare(this.x, that.x);\n\t\t\treturn Double.compare(this.y, that.y);\n\t\t}\n\t}\n\n\tstatic class HP extends P { // Hashable Point\n\t\tHP(double x, double y) {\n\t\t\tsuper(x, y);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Double.hashCode(x + 32768 * y);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object _that) {\n\t\t\tHP that = (HP) _that;\n\t\t\treturn this.x == that.x && this.y == that.y;\n\t\t}\n\t}\n\n\t/**\n\t * Sort points by polar angle relative to center, using trig. This is a\n\t * counter-clockwise sort with zero at 3 o'clock.\n\t */\n\tstatic Comparator<P> makePolarAngleComparatorTrig(final P center) {\n\t\treturn new Comparator<P>() {\n\t\t\tpublic int compare(P a, P b) {\n\t\t\t\tdouble thetaa = a.sub(center).theta();\n\t\t\t\tdouble thetab = b.sub(center).theta();\n\t\t\t\tif (thetaa < 0)\n\t\t\t\t\tthetaa += 2 * PI;\n\t\t\t\tif (thetab < 0)\n\t\t\t\t\tthetab += 2 * PI;\n\t\t\t\tint c = Double.compare(thetaa, thetab);\n\t\t\t\tif (c != 0)\n\t\t\t\t\treturn c;\n\t\t\t\treturn Double.compare(b.x, a.x); // arbitrary tie-breaker\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Sort points by polar angle relative to center, w/o trig. This is a\n\t * counter-clockwise sort with zero at 3 o'clock.\n\t */\n\tstatic Comparator<P> makePolarAngleComparator(final P center) {\n\t\treturn new Comparator<P>() {\n\t\t\tpublic int compare(P a, P b) {\n\t\t\t\t// orientation() requires that a and b lie in the same half-plane\n\t\t\t\tif (a.y >= center.y && b.y < center.y)\n\t\t\t\t\treturn -1;\n\t\t\t\tif (b.y >= center.y && a.y < center.y)\n\t\t\t\t\treturn 1;\n\t\t\t\tint orientation = (int) Math.signum(center.signedParallelogramArea(b, a));\n\t\t\t\tif (orientation != 0)\n\t\t\t\t\treturn orientation;\n\t\t\t\treturn Double.compare(b.x, a.x); // arbitrary tie-breaker\n\t\t\t}\n\t\t};\n\t}\n\n\t/*\n\t * Solve a * x^2 + b * x + c == 0 Returns 0, 1, or 2 solutions. If 2 solutions\n\t * x1, x2, guarantees that x1 < x2\n\t */\n\tstatic Double[] solvequadratic(double a, double b, double c) {\n\t\tdouble D = b * b - 4 * a * c;\n\t\tif (D < -EPS)\n\t\t\treturn new Double[] {};\n\t\tD = max(D, 0);\n\t\tif (D == 0)\n\t\t\treturn new Double[] { -b / 2.0 / a };\n\t\tdouble d = sqrt(D);\n\t\t// Numerically more stable, see\n\t\t// https://en.wikipedia.org/wiki/Loss_of_significance#A_better_algorithm\n\t\tif (signum(b) == 0)\n\t\t\treturn new Double[] { d / 2.0 / a, -d / 2.0 / a };\n\t\tdouble x1 = (-b - signum(b) * d) / (2 * a);\n\t\tdouble x2 = c / (a * x1);\n\t\treturn new Double[] { Math.min(x1, x2), Math.max(x1, x2) };\n\t}\n\n\t/*\n\t * The Line/Circle classes provide a number of methods that require dealing with\n\t * floating point precision issues. Default EPS to a suitable value, such as\n\t * 1e-6, which should work for many problems in which the input coordinates are\n\t * in integers and subsequently inexact floating point values are being\n\t * computed.\n\t */\n\tstatic double EPS = 1e-6;\n\n\t/*\n\t * A line denoted by two points p and q. For internal computations, we use the\n\t * parametric representation of the line as p + t d where d = q - p. For\n\t * convenience, we compute and store d in the constructor. Most methods hide the\n\t * parametric representation of the line, but it is exposed via\n\t * getPointFromParameter and intersectionParameters for those problems that need\n\t * it.\n\t *\n\t * The line may be interpreted either as a line segment denoted by the two end\n\t * points, or as the infinite line determined by these two points. Intersection\n\t * methods are provided for both cases.\n\t */\n\tstatic class Line {\n\t\tP p, q, d;\n\n\t\tLine(P p, P q) {\n\t\t\tthis.p = p;\n\t\t\tthis.q = q;\n\t\t\td = q.sub(p);\n\t\t}\n\n\t\tP getPointFromParameter(double t) {\n\t\t\treturn p.add(d.scale(t));\n\t\t}\n\n\t\t// reflect vector across vector (as if line originated at (0, 0))\n\t\tP reflect(P d2) {\n\t\t\treturn d.reflect(d2);\n\t\t}\n\n\t\t// reflect point across (infinite) line\n\t\tP reflectPoint(P r) {\n\t\t\treturn reflect(r.sub(p)).add(p);\n\t\t}\n\n\t\t// project p onto this (infinite) line. Returns point on line\n\t\tP project(P a) {\n\t\t\treturn p.add(d.project(a.sub(p)));\n\t\t}\n\n\t\t// return distance of point P from this (infinite) line.\n\t\tdouble distance(P a) {\n\t\t\treturn project(a).dist(a);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"[%s => %s]\", p, q);\n\t\t}\n\n\t\t/*\n\t\t * Point of intersection of this line segment with another line segment. Returns\n\t\t * only points that lie inside both line segments, else null.\n\t\t *\n\t\t * Result may include points \"just outside\" the bounds, given EPS.\n\t\t */\n\t\tP intersectsInBounds(Line l) {\n\t\t\tdouble[] st = intersectionParameters(l);\n\t\t\tif (st == null)\n\t\t\t\treturn null;\n\n\t\t\t// check that point of intersection is in direction 'd'\n\t\t\t// and within segment bounds\n\t\t\tdouble s = st[0];\n\t\t\tdouble t = st[1];\n\t\t\tif (s >= -EPS && s <= 1 + EPS && -EPS <= t && t <= 1 + EPS)\n\t\t\t\treturn getPointFromParameter(s);\n\n\t\t\treturn null;\n\t\t}\n\n\t\t/*\n\t\t * Point of intersection of this (infinite) line with other (infinite) line.\n\t\t * Return null if collinear.\n\t\t */\n\t\tP intersects(Line l) {\n\t\t\tdouble[] st = intersectionParameters(l);\n\t\t\tif (st != null)\n\t\t\t\treturn getPointFromParameter(st[0]);\n\t\t\treturn null;\n\t\t}\n\n\t\t/*\n\t\t * Intersect this line with that line Solves: this.p + s * this.d == l.p + t l.d\n\t\t * Return null if lines are collinear Else returns [s, t].\n\t\t */\n\t\tdouble[] intersectionParameters(Line l) {\n\t\t\tP dneg = p.sub(q);\n\t\t\tdouble D = l.d.det(dneg);\n\t\t\t// Use Cramer's rule; see text\n\t\t\tif (D == 0.0)\n\t\t\t\treturn null;\n\n\t\t\tP rp = p.sub(l.p);\n\t\t\treturn new double[] { l.d.det(rp) / D, rp.det(dneg) / D };\n\t\t}\n\n\t\t/*\n\t\t * Compute points of intersection of this infinite line with a circle. Computes\n\t\t * projection 'x' of c.c onto line, then computes x +/- d.scaleToLength(h) where\n\t\t * h is computed via Pythagoras. Sorted by decreasing 't' (as would be used in\n\t\t * getPointFromParameter)\n\t\t *\n\t\t * May return two points even if line is a tangent.\n\t\t */\n\t\tP[] intersectsCircle(Circle c) {\n\t\t\tP x = project(c.c);\n\t\t\tdouble D = x.dist(c.c);\n\t\t\t// outside by more than EPS\n\t\t\tif (D > c.R + EPS)\n\t\t\t\treturn new P[0];\n\t\t\tdouble h = sqrt(max(0, c.R * c.R - D * D));\n\t\t\tif (h == 0)\n\t\t\t\treturn new P[] { x }; // EPS (!?)\n\t\t\treturn new P[] { x.add(d.scaleToLength(h)), x.add(d.scaleToLength(-h)) };\n\t\t}\n\n\t\t/*\n\t\t * Compute points of intersection of this infinite line with a circle.\n\t\t *\n\t\t * Solves a + t * b = c + r subject to ||r|| = R Returns zero, one, or two\n\t\t * points on the periphery, e.g. c + r[0,1], sorted by decreasing 't'.\n\t\t * Alternative version which requires solving quadratic equation.\n\t\t *\n\t\t * Careful: set EPS if you need to handle round-off error in discriminant.\n\t\t */\n\t\tP[] intersectsCircleAlternative(Circle c) {\n\t\t\tP ca = c.c.sub(p);\n\t\t\tP d = q.sub(p);\n\t\t\tDouble[] t = solvequadratic(d.length2(), -2 * d.dot(ca), ca.length2() - c.R * c.R);\n\t\t\tP[] r = new P[t.length];\n\t\t\tfor (int i = 0; i < t.length; i++)\n\t\t\t\tr[i] = p.add(d.scale(t[i]));\n\t\t\treturn r;\n\t\t}\n\n\t\t/**\n\t\t * Is r contained within the line segment spanned by p/q, including their\n\t\t * endpoints?\n\t\t */\n\t\tboolean isInBounds(P r) {\n\t\t\treturn abs(p.dist(q) - p.dist(r) - q.dist(r)) <= EPS;\n\t\t}\n\n\t\t/**\n\t\t * Is r on the infinite line?\n\t\t */\n\t\tboolean isOnLine(P r) {\n\t\t\treturn r.isCollinearWith(p, q);\n\t\t}\n\t}\n\n\t/**\n\t * Alternative line implementation using the \"general form\" equation.\n\t *\n\t * a * x + b * y + c = 0\n\t *\n\t * This is provided for problems in which a line may be given in general form in\n\t * the input. Compared to class Line, GLine: - is shorter, particularly when\n\t * only line/line and line/circle intersections are required. - does not support\n\t * those functions of Line that relate to LineSegment.\n\t */\n\tstatic class GLine {\n\t\t// we represent a, b as a vector to benefit from the available dot/det routines.\n\t\tP n; // n = new P(a, b) --- this is the (right) normal vector to the line\n\t\tdouble c;\n\n\t\tGLine(double a, double b, double c) {\n\t\t\tthis.n = new P(a, b);\n\t\t\tif (a == 0 && b == 0)\n\t\t\t\tthrow new Error(\"a and b cannot both be zero\");\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tGLine(P p, P q) {\n\t\t\tthis(p.y - q.y, q.x - p.x, p.det(q));\n\t\t}\n\n\t\tP intersects(GLine that) {\n\t\t\tdouble D = n.det(that.n);\n\t\t\tif (D == 0.0)\n\t\t\t\treturn null;\n\t\t\treturn new P((this.n.y * that.c - that.n.y * this.c) / D, (that.n.x * this.c - this.n.x * that.c) / D);\n\t\t}\n\n\t\tdouble signedDistance(P p) {\n\t\t\treturn (n.dot(p) + c) / n.length();\n\t\t}\n\n\t\tdouble distance(P p) {\n\t\t\treturn abs(signedDistance(p));\n\t\t}\n\n\t\t// checks if on (infinite) line.\n\t\tboolean isOnLine(P p) {\n\t\t\treturn signedDistance(p) <= EPS;\n\t\t}\n\n\t\t// checks if on the same side, no EPS\n\t\tboolean onSameSide(P p, P q) {\n\t\t\treturn signum(signedDistance(p)) == signum(signedDistance(q));\n\t\t}\n\n\t\t// angle of inclination to horizontal; result is in [0, pi] rad\n\t\t// XXX untested\n\t\tdouble theta() {\n\t\t\tdouble angle = atan2(n.x, -n.y);\n\t\t\treturn angle < 0 ? (angle + PI) : angle;\n\t\t}\n\n\t\t// XXX untested\n\t\tboolean parallelWith(GLine that) {\n\t\t\treturn n.det(that.n) <= EPS;\n\t\t}\n\n\t\t// XXX untested\n\t\tboolean perpendicularTo(GLine that) {\n\t\t\treturn n.dot(that.n) <= EPS;\n\t\t}\n\n\t\t// circle-line intersection, refactored from\n\t\t// https://e-maxx-eng.appspot.com/geometry/circle-line-intersection.html\n\t\tP[] intersectsCircle(Circle C) {\n\t\t\t// shift line to center, this is undone by adding C.c before returning.\n\t\t\tdouble c = n.dot(C.c) + this.c;\n\t\t\tdouble n2 = n.length2();\n\t\t\tdouble r = C.R;\n\n\t\t\tP p = n.scale(-c / n2).add(C.c); // undo shift to center\n\t\t\tif (c * c > r * r * n2 + EPS) {\n\t\t\t\treturn new P[] {};\n\t\t\t} else if (abs(c * c - r * r * n2) < EPS) {\n\t\t\t\treturn new P[] { p };\n\t\t\t} else {\n\t\t\t\tdouble d = r * r - c * c / n2;\n\t\t\t\tdouble m = sqrt(d / n2);\n\t\t\t\tP q = n.rightNormal().scale(m);\n\t\t\t\treturn new P[] { p.add(q), p.sub(q) };\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"Line:(n=%s C=%f)\", n, c);\n\t\t}\n\t}\n\n\tstatic class Circle {\n\t\tP c;\n\t\tdouble R;\n\n\t\tCircle(P c, double R) {\n\t\t\tthis.c = c;\n\t\t\tthis.R = R;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"{%s, %.03f}\", c, R);\n\t\t}\n\n\t\t/* Is this point inside the circle */\n\t\tboolean isInside(P p) {\n\t\t\treturn R > p.dist(c) - EPS;\n\t\t}\n\n\t\t/* Is this point on the circle's periphery */\n\t\tboolean isOnCircle(P p) {\n\t\t\treturn abs(p.dist(c) - R) <= EPS;\n\t\t}\n\n\t\t/*\n\t\t * a line segment is outside a circle if both end points are outside and if any\n\t\t * intersection points are outside the bounds of the line segment.\n\t\t */\n\t\tboolean isOutside(Line l) {\n\t\t\tif (isInside(l.p) || isInside(l.q))\n\t\t\t\treturn false;\n\t\t\tP[] _is = l.intersectsCircle(this);\n\t\t\tif (_is.length > 1)\n\t\t\t\tfor (P is : _is)\n\t\t\t\t\tif (l.isInBounds(is))\n\t\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/* Returns the tangent lines that the point p makes with this circle, if any. */\n\t\tLine[] tangentLines(P p) {\n\t\t\t// Let c +/- r be the tangent points. Then there's a 'd' such that\n\t\t\t// p + d - r = c\n\t\t\t// Since d r = 0, we multiply by r and get\n\t\t\t// (p - c) r - ||r|| = 0 subject to ||r|| = R\n\t\t\tP[] r = p.sub(c).solveDotProductConstrainedByNorm(-R * R, R);\n\t\t\tLine[] tangents = new Line[r.length];\n\t\t\tfor (int i = 0; i < tangents.length; i++)\n\t\t\t\ttangents[i] = new Line(p, c.add(r[i]));\n\t\t\treturn tangents;\n\t\t}\n\n\t\t/*\n\t\t * Compute points of intersection of this circle (c1, r1) with that circle (c2,\n\t\t * r2). Model as triangle equation m = c2 - c1 = r1 - r2 m = r1 - r2 -> m^2 =\n\t\t * r1^2 + r2^2 - 2 r1 r2 (squaring) -> r1 r2 = (r1^2 + r2^2 - m^2)/2 and by\n\t\t * multiplying by r1 we obtain m = r1 - r2 -> m r1 = r1^2 - r1 r2 -> m r1 = r1^2\n\t\t * - (r1^2 + r2^2 - m^2)/2 -> m r1 + (r2^2 - r1^2 - m^2)/2 = 0 and ready for\n\t\t * solveDotProductConstrainedByNorm\n\t\t *\n\t\t * Note that if the circles are (apprx) touching, this function may return 0, 1,\n\t\t * or 2 intersection points, depending on which side of 0 the discriminant\n\t\t * falls. You will not get NaN.\n\t\t *\n\t\t * If the circles coincidence (same center and radius) this will throw an\n\t\t * 'degenerate case' error in solveDotProductConstrainedByNorm !!!\n\t\t */\n\t\tP[] intersectsCircle(Circle that) {\n\t\t\tdouble r1 = this.R;\n\t\t\tdouble r2 = that.R;\n\t\t\tP m = that.c.sub(this.c);\n\t\t\tP[] r1sol = m.solveDotProductConstrainedByNorm((r2 * r2 - r1 * r1 - m.length2()) / 2, r1);\n\t\t\t// compute [c +/- r1] to obtain intersection points\n\t\t\tP[] is = new P[r1sol.length];\n\t\t\tfor (int i = 0; i < r1sol.length; i++)\n\t\t\t\tis[i] = this.c.add(r1sol[i]);\n\t\t\treturn is;\n\t\t}\n\n\t\t/*\n\t\t * Shorter version of intersectsCircle that solves quadratic equation inline.\n\t\t * Assumes there are 2 intersection points. The vector 'mid' is where the\n\t\t * altitude of the triangle formed by the centers and the intersection point\n\t\t * hits the line connecting the centers. Its length is e. midn is normal to it\n\t\t * and its length is f.\n\t\t */\n\t\tP[] intersectsCircleAlternative(Circle that) {\n\t\t\tP m = that.c.sub(this.c);\n\t\t\tdouble b = this.R * this.R;\n\t\t\t// div-by-zero if circles share center\n\t\t\tdouble e = (m.length2() + b - that.R * that.R) / 2 / m.length();\n\t\t\tdouble f = sqrt(b - e * e); // NaN if circles don't intersect\n\t\t\tP[] is = new P[2];\n\t\t\tP mid = this.c.add(m.scaleToLength(e));\n\t\t\tP midn = m.rightNormal();\n\t\t\tfor (int i = 0; i < is.length; i++) {\n\t\t\t\tis[i] = mid.add(midn.scaleToLength(f));\n\t\t\t\tf *= -1;\n\t\t\t}\n\t\t\treturn is;\n\t\t}\n\n\t\t// returns true if this circle is outside that circle\n\t\tboolean isOutside(Circle that) {\n\t\t\treturn this.c.dist(that.c) > (this.R + that.R);\n\t\t}\n\n\t\t// returns true if this circle is entirely contained inside that circle\n\t\tboolean isContainedIn(Circle that) {\n\t\t\t// extend line from that.c to this.c by radius R\n\t\t\tP m = this.c.sub(that.c);\n\t\t\treturn that.isInside(this.c.add(m.scaleToLength(this.R)));\n\t\t}\n\n\t\t/* Construct smallest circle that circumscribes 2 points a and b. */\n\t\tstatic Circle getCircumCircle(P a, P b) {\n\t\t\tP c = a.add(b).scale(.5);\n\t\t\treturn new Circle(c, c.dist(a));\n\t\t}\n\n\t\t/* Construct circle circumscribed by 3 points a, b, c */\n\t\tstatic Circle getCircumCircle(P a, P b, P c) {\n\t\t\tP B = b.sub(a);\n\t\t\tP C = c.sub(a);\n\t\t\tdouble d = 2 * B.crossproduct(C);\n\t\t\tif (abs(d) < EPS) // points are collinear\n\t\t\t\treturn getCircumCircle(new P(min(a.x, min(b.x, c.x)), min(a.y, min(b.y, c.y))),\n\t\t\t\t\t\tnew P(max(a.x, max(b.x, c.x)), max(a.y, max(b.y, c.y))));\n\n\t\t\tdouble z1 = B.length2();\n\t\t\tdouble z2 = C.length2();\n\t\t\tP cc = new P(C.y * z1 - B.y * z2, B.x * z2 - C.x * z1).scale(1.0 / d);\n\t\t\treturn new Circle(cc.add(a), cc.length());\n\t\t}\n\n\t\t/*\n\t\t * Find minimum enclosing circle for a set of points. Peter, we need a source\n\t\t * for this algorithm and its expected complexity.\n\t\t */\n\t\tstatic Circle minEnclosingCircle(P[] p) {\n\t\t\tif (p.length == 0)\n\t\t\t\treturn new Circle(new P(0, 0), 0);\n\t\t\tif (p.length == 1)\n\t\t\t\treturn new Circle(p[0], 0);\n\t\t\tCollections.shuffle(Arrays.asList(p));\n\t\t\tCircle circle = getCircumCircle(p[0], p[1]);\n\t\t\tfor (int i = 2; i < p.length; i++) {\n\t\t\t\tif (!circle.isInside(p[i])) {\n\t\t\t\t\tcircle = getCircumCircle(p[0], p[i]);\n\t\t\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\t\t\tif (!circle.isInside(p[j])) {\n\t\t\t\t\t\t\tcircle = getCircumCircle(p[j], p[i]);\n\t\t\t\t\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\t\t\t\t\tif (!circle.isInside(p[k])) {\n\t\t\t\t\t\t\t\t\tcircle = getCircumCircle(p[i], p[j], p[k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn circle;\n\t\t}\n\t}\n\n\t/**\n\t * Some basic operations on Polygons.\n\t */\n\tstatic class Polygon {\n\t\tP[] p; // open form, p[0] connects to p[n-1]\n\n\t\t// Constructors clone original array/collection\n\t\tPolygon(Collection<P> c) {\n\t\t\tthis.p = c.toArray(new P[c.size()]);\n\t\t}\n\n\t\tPolygon(P[] p) {\n\t\t\tthis.p = (P[]) p.clone();\n\t\t}\n\n\t\t/* Absolute of signed triangle areas */\n\t\tdouble signedArea() {\n\t\t\tdouble area = 0.0;\n\t\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\t\tarea += p[i].det(p[(i + 1) % p.length]);\n\t\t\t}\n\t\t\treturn area / 2.0;\n\t\t}\n\n\t\tdouble absoluteArea() {\n\t\t\treturn abs(signedArea());\n\t\t}\n\n\t\t/*\n\t\t * Returns an P[] array representing an open shape that is the convex hull of\n\t\t * the given array of points, or null if less than 2 points were given.\n\t\t */\n\t\tpublic Polygon convexHull() {\n\t\t\tif (p.length < 2)\n\t\t\t\treturn null;\n\n\t\t\t// (0) find the lowest point, breaking ties to the right\n\t\t\tfinal P min = Collections.min(Arrays.asList(p), new Comparator<P>() {\n\t\t\t\tpublic int compare(P p1, P p2) {\n\t\t\t\t\tint y = Double.valueOf(p1.y).compareTo(p2.y);\n\t\t\t\t\treturn y != 0 ? y : Double.valueOf(p1.x).compareTo(p2.x);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// (1) sort points by angle from pivot\n\t\t\tArrays.sort(p, new Comparator<P>() {\n\t\t\t\tpublic int compare(P p1, P p2) {\n\t\t\t\t\tdouble o = min.signedParallelogramArea(p1, p2); // crossproduct\n\t\t\t\t\tif (o != 0)\n\t\t\t\t\t\treturn -(int) Math.signum(o);\n\n\t\t\t\t\t// if collinear, use distance to break tie\n\t\t\t\t\treturn Double.valueOf(min.dist(p1)).compareTo(min.dist(p2));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// (3) create stack\n\t\t\tStack<P> hull = new Stack<P>();\n\t\t\tassert p[0] == min;\n\t\t\thull.push(p[0]);\n\t\t\thull.push(p[1]);\n\n\t\t\t// (4) select points that maintain left turns\n\t\t\tfor (int i = 2; i < p.length; i++) {\n\t\t\t\tP next = p[i];\n\t\t\t\twhile (hull.size() >= 2) {\n\t\t\t\t\tP snd = hull.get(hull.size() - 2);\n\t\t\t\t\tP top = hull.peek();\n\t\t\t\t\tif (snd.isCCW(top, next)) // keep\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\thull.pop(); // discard\n\t\t\t\t}\n\t\t\t\t// keep current point\n\t\t\t\thull.push(next);\n\t\t\t}\n\t\t\treturn new Polygon(hull);\n\t\t}\n\n\t\t/*\n\t\t * \"Point-in-Polygon\" PIP tests. Return true if point is contained in this\n\t\t * polygon\n\t\t *\n\t\t * All of these tests may return 0 or 1 for points on the boundary. A separate\n\t\t * test is required to determine if a point is on the boundary.\n\t\t */\n\t\tpublic boolean contains(P q) {\n\t\t\treturn contains_WN(q);\n\t\t}\n\n\t\t/*\n\t\t * Crossing-number based algorith due to Wm. Randolph Franklin. Works only for\n\t\t * simple polygons.\n\t\t */\n\t\tprivate boolean contains_CN(P q) {\n\t\t\tboolean c = false;\n\t\t\tfor (int i = 0, j = p.length - 1; i < p.length; j = i++) {\n\t\t\t\tif ((((p[i].y <= q.y) && (q.y < p[j].y)) || ((p[j].y <= q.y) && (q.y < p[i].y)))\n\t\t\t\t\t\t&& (q.x < (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y) + p[i].x))\n\t\t\t\t\tc = !c;\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\t/*\n\t\t * Winding numbers based algorithm, which also works for self-intersecting\n\t\t * polygons. http://geomalgorithms.com/a03-_inclusion.html describes this as the\n\t\t * always preferred algorithm.\n\t\t *\n\t\t * Return: wn = the winding number (=0 only when P is outside)\n\t\t */\n\t\tpublic boolean contains_WN(P q) {\n\t\t\tint wn = 0; // the winding number counter\n\n\t\t\t// loop through all edges of the polygon\n\t\t\tint n = p.length;\n\t\t\tfor (int i = 0; i < n; i++) { // edge from V[i] to V[i+1]\n\t\t\t\tP p = this.p[i], pn = this.p[(i + 1) % n];\n\t\t\t\tif (p.y <= q.y) { // start y <= P.y\n\t\t\t\t\tif (pn.y > q.y) // an upward crossing\n\t\t\t\t\t\tif (p.isCCW(pn, q)) // P left of edge\n\t\t\t\t\t\t\t++wn; // have a valid up intersect\n\t\t\t\t} else { // start y > P.y (no test needed)\n\t\t\t\t\tif (pn.y <= q.y) // a downward crossing\n\t\t\t\t\t\tif (!p.isCCW(pn, q)) // P right of edge\n\t\t\t\t\t\t\t--wn; // have a valid down intersect\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn wn != 0;\n\t\t}\n\n\t\t/**\n\t\t * Is q on the boundary of this polygon?\n\t\t */\n\t\tpublic boolean onBoundary(P q) {\n\t\t\tint n = p.length;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tP pi = this.p[i], pj = this.p[(i + 1) % n];\n\t\t\t\tif (new Line(pi, pj).isInBounds(q))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Arrays.toString(p);\n\t\t}\n\t}\n\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(Reader in) {\n\t\t\tbr = new BufferedReader(in);\n\t\t}\n\n\t\tpublic FastScanner() {\n\t\t\tthis(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString readNextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tint[] readIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int idx = 0; idx < n; idx++) {\n\t\t\t\ta[idx] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] readLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int idx = 0; idx < n; idx++) {\n\t\t\t\ta[idx] = nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\n\nimport static java.lang.Integer.MAX_VALUE;\nimport static java.lang.Integer.parseInt;\n\n/**\n * 8C\n *\n * @author artyom\n */\npublic class LookingForOrder {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String[] parsedString = parsedString = in.readLine().split(\" \");\n        int xStart = parseInt(parsedString[0]);\n        int yStart = parseInt(parsedString[1]);\n        int objectNum = parseInt(in.readLine());\n\n        int[] xLocs = new int[objectNum + 1];\n        int[] yLocs = new int[objectNum + 1];\n        int[] bitMasks = new int[1 << objectNum];\n        Arrays.fill(bitMasks, MAX_VALUE);\n        int[] previous = new int[1 << objectNum];\n\n        xLocs[objectNum] = xStart;\n        yLocs[objectNum] = yStart;\n        for (int i = 0; i < objectNum; i++) {\n            parsedString = in.readLine().split(\" \");\n            xLocs[i] = parseInt(parsedString[0]);\n            yLocs[i] = parseInt(parsedString[1]);\n        }\n\n        //go through all pairs and find time requirement for each pair of objects\n        //the entry at point [i][j] is equal to the time it takes to get from point i to point j\n        int[][] times = new int[objectNum + 1][objectNum + 1];\n        for (int i = 0; i <= objectNum; i++) {\n            for (int j = 0; j <= objectNum; j++) {\n                times[i][j] = times[j][i] = (xLocs[i] - xLocs[j]) * (xLocs[i] - xLocs[j]) + (yLocs[i] - yLocs[j]) * (yLocs[i] - yLocs[j]);\n            }\n        }\n\n        //each value in bitmasks represents the minimum time necessary to get\n        //the unmasked bits\n        //so bitmasks[5] (5=101) is the fastest time in which you can get\n        //items 1 and 3\n        bitMasks[0] = 0; //collecting zero objects takes 0 time\n        for (int i = 0; i < (1 << objectNum); i++) {\n            if (bitMasks[i] != MAX_VALUE) {\n                for (int j = 0; j < objectNum; j++) {\n                    if (((1 << j) & i) == 0) { //if our current j object hasn't been picked up yet\n                        int curState = (1 << j) | i; //ith state after picking up j object\n                        int curTime = bitMasks[i] + 2 * times[objectNum][j]; //time required to get object j from bag at state i\n\n                        if (curTime < bitMasks[curState]) {\n                            bitMasks[curState] = curTime; //put fastest time in for gettingto our current state\n                            previous[curState] = i;\n                        }\n\n                        //find another thing while you're out\n                        for (int k = 0; k < objectNum; k++) {\n                            if (((1 << k) & curState) == 0) { //if the kth position in our current state hasn't been picked up\n                                int kState = ((1 << k) | curState); //curstate after picking up the kth object\n                                //kTime is time it takes to go from bag, to j, to k and back\n                                int kTime = bitMasks[i] + times[objectNum][j] + times[j][k] + times[k][objectNum];\n\n                                if (kTime < bitMasks[kState]) {\n                                    bitMasks[kState] = kTime;  //put shortest time for getting to kState in\n                                    previous[kState] = i;\n                                }\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        int finalState = (1 << objectNum) - 1;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(bitMasks[finalState]).append('\\n');\n\n        Deque<Integer> outputQ = new ArrayDeque<>();\n        outputQ.add(0);\n        int curState = finalState;\n        while (curState > 0) {\n            //difference is the objects picked up in this state but not in previous state\n            int difference = curState ^ previous[curState];\n            int firstItem = -1;\n            int secondItem = -1;\n\n            for (int i = 0; i < objectNum; i++) {\n                if (((1 << i) & difference) > 0) { //if the ith object was picked up in this state\n                    secondItem = firstItem; //keep track of how many items are picked up\n                    firstItem = i;\n                }\n            }\n\n            if (secondItem != -1) {\n                //put in two items followed by a return to 0\n                outputQ.add(firstItem + 1);\n                outputQ.add(secondItem + 1);\n                outputQ.add(0);\n            } else {\n                outputQ.add(firstItem + 1);\n                outputQ.add(0);\n            }\n\n            curState = previous[curState];\n        }\n\n        sb.append(outputQ.removeLast());\n        while (!outputQ.isEmpty()) {\n            sb.append(' ').append(outputQ.removeLast());\n        }\n        System.out.print(sb);\n    }\n}", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class F \n{\n\tstatic Scanner in = new Scanner(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\t\n\tstatic int n,m,res=0;\n\tstatic int[][] a=new int[20][10005],Min=new int[20][20],Min1=new int[20][20];\n\tstatic int[][][] f=new int[1<<16][20][20];\n\t\n\tstatic int GetBit(int x,int k)\n\t{\n\t\treturn (x>>k)&1;\n\t}\n\t\n\tstatic int TurnBit(int x,int k)\n\t{\n\t\treturn x^(1<<k);\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tn=in.nextInt();\n\t\tm=in.nextInt();\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\ta[i][j]=in.nextInt();\n\t\tif(n==1)\n\t\t{\n\t\t\tres=(int)1e9;\n\t\t\tfor(int i=1;i<m;i++)\n\t\t\t\tres=Math.min(res,Math.abs(a[0][i]-a[0][i+1]));\n\t\t\tout.print(res);\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tMin[i][j]=Min1[i][j]=(int)1e9;\n\t\t\t\tfor(int t=1;t<=m;t++)\n\t\t\t\t\tMin[i][j]=Math.min(Min[i][j],Math.abs(a[i][t]-a[j][t]));\n\t\t\t\tfor(int t=1;t<m;t++)\n\t\t\t\t\tMin1[i][j]=Math.min(Min1[i][j],Math.abs(a[i][t]-a[j][t+1]));\n\t\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tf[1<<i][i][i]=(int)1e9;\n\t\tfor(int mask=0;mask<(1<<n);mask++)\n\t\t\tif(Integer.bitCount(mask)>1)\n\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\tif(GetBit(mask,i)==1)\n\t\t\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\t\t\tif(i!=j&&GetBit(mask,j)==1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor(int t=0;t<n;t++)\n\t\t\t\t\t\t\t\t\tif(j!=t&&GetBit(mask,t)==1)\n\t\t\t\t\t\t\t\t\t\tf[mask][i][j]=Math.max(f[mask][i][j],Math.min(f[TurnBit(mask,j)][i][t],Min[j][t]));\n\t\t\t\t\t\t\t\tif(mask==(1<<n)-1)\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tres=Math.max(res,Math.min(f[mask][i][j],Min1[j][i]));\n\t\t\t\t\t\t\t}\n\t\tout.print(res);\n\t\tout.close();\n\t}\n}", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "import java.util.*;\n\npublic class sol {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\n\t\tint firstSum=0;\n\t\t for(int i=0;i<4;i++) {\n\t\t\t firstSum+=sc.nextInt();\n\t\t }\n\t\t int count=0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint sum =0;\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t}\n\t\t\tif(sum>firstSum) count++;\n\t\t}\n\t\tSystem.out.println(count + 1);}\n    \n}\n\t\t", "complexity": "linear", "problem": "1017_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.*;\n\npublic class A {\n\n    int n;\n    int[] arr;\n    \n    void run(){\n        Scanner s = new Scanner(System.in);\n        n = s.nextInt();\n        arr = new int[n];\n        int even, odd;\n        even = 0;\n        odd = 0;\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextInt();\n            if(arr[i]%2==0)even++;\n            else odd++;\n        }\n        if(even>odd){\n        \n            \n            for (int i = 0; i < n; i++) {\n                if(arr[i]%2==1){\n                    System.out.println(i+1);\n                    System.exit(0);\n                }\n            }\n        }\n        \n        else{\n\n            for (int i = 0; i < n; i++) {\n                if(arr[i]%2==0){\n                    System.out.println(i+1);\n                    System.exit(0);\n                }\n            }\n\n        }\n        \n        \n    }\n    public static void main(String[] args) {\n        new A().run();\n    }\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.StringTokenizer;\n/**\n * 9:50 ~ \n *\n */\npublic class Main {\n\tpublic static int n, x, y;\n\tpublic static int[] a,b;\n\tpublic static int dp[], before[];\n\tpublic static int dx[];\n\tpublic static int d[][];\n\tpublic static final int INF = 24 * 201 * 201; \n\tpublic static void main(String[] argv) {\n\t\tFastScanner scan = new FastScanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tx = scan.nextInt();\n\t\ty = scan.nextInt();\n\t\t\n\t\tn = scan.nextInt();\n\t\t\n\t\ta = new int[n+1];\n\t\tb = new int[n+1];\n\t\tdx = new int[n+1];\n\t\td = new int[n+1][n+1];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\ta[i] = scan.nextInt();\n\t\t\tb[i] = scan.nextInt();\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tdx[i] = dist(i);\n\t\t}\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\td[i][j] = dist(i,j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp = new int[1 << n];\n\t\tbefore = new int[1 << n];\n\t\tArrays.fill(dp, INF);\n\t\tdp[0] = 0;\n\t\tfor(int state = 0; state < (1<<n); state++){\n\t\t\t//if(dp[state] == INF) continue;\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tint ii = (1 << i);\n\t\t\t\tif((state & ii) > 0){\n\t\t\t\t\tif(dp[state - ii] == INF) continue;\n\t\t\t\t\tint newdist = dp[state - ii] + dx[i] + dx[i];\n\t\t\t\t\tif(dp[state] > newdist){\n\t\t\t\t\t\tdp[state] = newdist;\n\t\t\t\t\t\tbefore[state] = state - ii;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else continue;\n\t\t\t\t\n\t\t\t\tfor(int j = i + 1; j < n; ++j){\n\t\t\t\t\tif(i == j) continue;\n\t\t\t\t\tint jj = (1 << j);\n\t\t\t\t\tif((state & jj) > 0){\n\t\t\t\t\t\tif(dp[state - ii - jj] == INF) continue;\n\t\t\t\t\t\tint newdist = dp[state - ii - jj] + dx[i] + d[i][j] + dx[j];\n\t\t\t\t\t\tif(dp[state] > newdist){\n\t\t\t\t\t\t\tdp[state] = newdist;\n\t\t\t\t\t\t\tbefore[state] = state - ii - jj;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(dp[(1<<n)-1]);\n\t\tint state = (1<<n) - 1;\n\t\tStringBuffer ret = new StringBuffer();\n\t\twhile(state > 0){\n\t\t\tint nstate = before[state];\n\t\t\tboolean find = false;\n\t\t\tString made = \"\";\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tif(((state & (1<<i)) > 0) && ((nstate & (1<<i)) == 0)){\n\t\t\t\t\tfind = true;\n\t\t\t\t\tmade = made + \" \" + (i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(find){\n\t\t\t\tmade = made + \" 0\";\n\t\t\t\tret.append(made, 0, made.length());\n\t\t\t}\n\t\t\tstate = nstate;\n\t\t}\n\t\tout.println(\"0\" + ret.toString());\n\t\tout.close();\n\t}\n\tpublic static int dist(int to){\n\t\treturn Math.abs(a[to] - x) * Math.abs(a[to] - x) + Math.abs(b[to] - y) * Math.abs(b[to] - y);\n\t}\n\tpublic static int dist(int from, int to){\n\t\treturn Math.abs(a[from]-a[to]) * Math.abs(a[from]-a[to]) + Math.abs(b[from]-b[to]) * Math.abs(b[from]-b[to]);\n\t}\n\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(InputStream is) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.valueOf(next());\n\t\t}\n\t}\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Ray S. Kan\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        AIfAtFirstYouDontSucceed solver = new AIfAtFirstYouDontSucceed();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class AIfAtFirstYouDontSucceed {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int c = in.nextInt();\n            int n = in.nextInt();\n            int res = n - ((a + b) - c);\n            if (n == 0 || c >= n) {\n                out.println(-1);\n            } else if (c > a || c > b) {\n                out.println(-1);\n            } else if (res >= 1) {\n                out.println(res);\n            } else {\n                out.println(-1);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.*;\npublic class Solve {\n\n    private Scanner o;\n    \n    private Solve(Scanner o) {\n        this.o = o;\n    }\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n        //System.out.println(\"\");\n\t\t\n\t\tSolve main = new Solve(new Scanner(System.in));\n        main.solve();\n\t\n\t}\n\t\n    private void solve() {\n        \n       int n=o.nextInt();int k=o.nextInt();\n       \n       int res=0;\n       \n       int cur =n*2;\n       res+=(cur+k-1)/k;\n       cur= n*5;\n       res+=(cur+k-1)/k;\n       cur=n*8;\n       res+=(cur+k-1)/k;\n       \n       System.out.println(res);\n       \n        \n     //end   \n    }\n  \n}\n", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B_Sonya_and_Exhibition{\n    \n    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception{\n        int[] nm = in.readA();\n        int n = nm[0], m = nm[1];\n        int[][] people = new int[m][2];\n        for(int i = 0; i < m; i++){\n            // if(i < m-1)   \n                people[i] = in.readA();\n            // else \n            //     people[i] = new int[]{1, n};\n            people[i][0]--;\n            people[i][1]--;\n        }\n        Arrays.sort(people, new Comparator<int[]>(){\n            @Override\n            public int compare(int[] a,int[] b){\n                return -((a[1]-a[0]) - (b[1]-b[0]));\n            }\n        });\n        char[] row = new char[n];\n        for(int i = 0; i < n; i++){\n            row[i] = (char)(i%2 + '0');\n        }\n        System.out.println(new String(row));\n    }\n\n    static Inputer in;\n    static {\n        in = new Inputer();\n    }\n\n    static class Inputer{\n        BufferedReader br;\n        Inputer(){\n            try{\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n            catch(Exception e){}\n        }\n        public int readInt() throws Exception{\n            return Integer.parseInt(readLine());\n        }\n        public long readLong() throws Exception{\n            return Long.parseLong(readLine());\n        }\n        public int[] readA(String delim) throws Exception{\n            String[] s = readLine().split(delim);\n            int[] A = new int[s.length];\n            for(int i = 0; i < s.length; i++)\n                A[i] = Integer.parseInt(s[i]);\n            return A;\n        }\n        public int[] readA() throws Exception{\n            String[] s = readLine().split(\"\\\\s+\");\n            int[] A = new int[s.length];\n            for(int i = 0; i < s.length; i++)\n                A[i] = Integer.parseInt(s[i]);\n            return A;\n        }\n        public long[] readLA() throws Exception{\n            String[] s = readLine().split(\"\\\\s+\");\n            long[] A = new long[s.length];\n            for(int i = 0; i < s.length; i++)\n                A[i] = Long.parseLong(s[i]);\n            return A;\n        }\n        public String readLine() throws Exception{\n            return br.readLine();\n        }\n        public int[] copyA(int[] A){\n            int[] B = new int[A.length];\n            for(int i= 0 ; i < A.length; i++)\n                B[i] = A[i];\n            return B;\n        }\n    }\n    static void shuffle(int[] A){\n        int n = A.length;\n        Random rand = new Random();\n        for(int t = 0; t < A.length; t++){\n            int i1 = rand.nextInt(n);\n            int i2 = rand.nextInt(n);\n            int tmp = A[i1];\n            A[i1] = A[i2];\n            A[i2] = tmp;\n        }\n    }\n}", "complexity": "linear", "problem": "1004_B", "from": "CODEFORCES", "tags": "constructive algorithms,greedy,implementation,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Bag implements Runnable {\n    private void solve() throws IOException {\n        int xs = nextInt();\n        int ys = nextInt();\n        int n = nextInt();\n        int[] x = new int[n];\n        int[] y = new int[n];\n        for (int i = 0; i < n; ++i) {\n            x[i] = nextInt();\n            y[i] = nextInt();\n        }\n        final int[][] pair = new int[n][n];\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                pair[i][j] = (x[i] - xs) * (x[i] - xs) + (y[i] - ys) * (y[i] - ys) + (x[j] - xs) * (x[j] - xs) + (y[j] - ys) * (y[j] - ys) + (x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]);\n        final int[] single = new int[n];\n        for (int i = 0; i < n; ++i) {\n            single[i] = 2 * ((x[i] - xs) * (x[i] - xs) + (y[i] - ys) * (y[i] - ys));\n        }\n        final int[] best = new int[1 << n];\n        final int[] prev = new int[1 << n];\n        for (int set = 1; set < (1 << n); ++set) {\n            int i;\n            for (i = 0; i < n; ++i)\n                if ((set & (1 << i)) != 0)\n                    break;\n            int bestC = best[set ^ (1 << i)] + single[i];\n            int prevC = 1 << i;\n            int nextSet = set ^ (1 << i);\n            int unoI = 1 << i;\n            for (int j = i + 1, unoJ = 1 << (i + 1); j < n; ++j, unoJ <<= 1)\n                if ((set & unoJ) != 0) {\n                    int cur = best[nextSet ^ unoJ] + pair[i][j];\n                    if (cur < bestC) {\n                        bestC = cur;\n                        prevC = unoI | unoJ;\n                    }\n                }\n            best[set] = bestC;\n            prev[set] = prevC;\n        }\n        writer.println(best[(1 << n) - 1]);\n        int now = (1 << n) - 1;\n        writer.print(\"0\");\n        while (now > 0) {\n        \tint differents = prev[now];\n        \tfor(int i = 0; i < n; i++)\n\t\t\t\tif((differents & (1 << i)) != 0)\n\t\t\t\t{\n\t\t\t\t\t writer.print(\" \");\n\t\t             writer.print(i + 1);\n\t\t             now ^= 1 << i;\n\t\t\t\t}\n            writer.print(\" \");\n            writer.print(\"0\");\n        }\n        writer.println();\n    }\n\n\n    public static void main(String[] args) {\n        new Bag().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n}", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\n/*\n4 3\n2 1\n1 3\n4 3\n\n \n */\npublic class A {\n\tstatic FastReader sc=null;\n\t\n\tpublic static void main(String[] args) {\n\t\tsc=new FastReader();\n\t\tint n=sc.nextInt();\n\t\tchar line[]=sc.next().toCharArray();\n\t\tint l=1,r=n,mid=0;\n\t\twhile(l+1<r) {\n\t\t\tmid=(l+r)/2;\n\t\t\tif(go(line,mid))r=mid;\n\t\t\telse l=mid;\n\t\t}\n\t\tif(mid>1 && go(line,mid-1))mid--;\n\t\tif(!(go(line,mid)))mid++;\n\t\tSystem.out.println(mid);\n\t\n\t}\n\tstatic boolean go(char line[],int k) {\n\t\tint n=line.length;\n\t\tMap<Character,Integer> map=new HashMap<>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(!map.containsKey(line[i]))map.put(line[i],0);\n\t\t}\n\t\t//for(int e:map.values())System.out.print(e+\" \");\n\t\t//System.out.println();\n\t\tfor(int i=0;i<k;i++) {\n\t\t\tint c=map.get(line[i]);\n\t\t\tmap.put(line[i],++c);\n\t\t}\n\t\tboolean done=true;\n\t\t//System.out.print(0+\" \"+k+\" :\");\n\t\tfor(int e:map.values()) {\n\t\t\t//System.out.print(e+\" \");\n\t\t\tif(e==0) {\n\t\t\t\tdone=false;\n\t\t\t}\n\t\t}\n\t\t//System.out.println();\n\t\tif(done)return true;\n\t\tfor(int i=k;i<n;i++) {\n\t\t\tdone=true;\n\t\t\tint c=map.get(line[i-k]);\n\t\t\tmap.put(line[i-k], --c);\n\t\t\tint c2=map.get(line[i]);\n\t\t\tmap.put(line[i], ++c2);\n\t\t\t//System.out.print(i+\" \"+(i+k)+\" :\");\n\t\t\tfor(int e:map.values()) {\n\t\t\t\t//System.out.print(e+\" \");\n\t\t\t\tif(e==0) {\n\t\t\t\t\tdone=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println();\n\t\t\tif(done)return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tstatic int[] reverse(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al,Collections.reverseOrder());\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\tstatic long gcd(long a,long b) {\n\t\tif(b==0)return a;\n\t\telse return gcd(b,a%b);\n\t}\n\t\n\tstatic void print(long a[]) {\n\t\tfor(long e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\t\n\t\n\t\n\tstatic void print(int a[]) {\n\t\tfor(int e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n        int[] readArray(int n) {\n    \t\tint a[]=new int [n];\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\ta[i]=sc.nextInt();\n    \t\t}\n    \t\treturn a;\n    \t}\n    } \n}\n\n\n\n\n\n\n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class TwoSets<V> {\n\n    private static int n;\n\n    private static int a;\n\n    private static int b;\n\n    private static List<Node<Integer>> nodes = new LinkedList<Node<Integer>>();\n\n    private static Map<Integer, Node<Integer>> datas = new HashMap<Integer, Node<Integer>>();\n\n    private static Node<Integer> first;\n\n    private static Node<Integer> second;\n\n    private static TwoSets<Integer> sets = new TwoSets<Integer>();\n\n    private static class Node<V> {\n\n\tV node;\n\n\tNode<V> parent;\n\n\tint rank;\n\n\tint color = -1;\n\n\tboolean inprogress;\n\n\tpublic Node() {\n\t    this.parent = this;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t    return String.format(\"{node: %s, parent: %s, rank: %s, color:%s}\",\n\t\t    node, parent.node, rank, color);\n\t}\n    }\n\n    public Node<V> makeSet(V x) {\n\n\tNode<V> node = new Node<V>();\n\n\tnode.node = x;\n\tnode.parent = node;\n\tnode.rank = 0;\n\n\treturn node;\n    }\n\n    public void link(Node<V> x, Node<V> y) {\n\n\tif (x.rank > y.rank) {\n\t    y.parent = x;\n\t} else {\n\t    x.parent = y;\n\t    if (x.rank == y.rank) {\n\t\ty.rank++;\n\t    }\n\t}\n    }\n\n    public Node<V> findSet(Node<V> x) {\n\n\tif (x.parent != x) {\n\t    x.parent = findSet(x.parent);\n\t}\n\n\treturn x.parent;\n    }\n\n    public void union(Node<V> x, Node<V> y) {\n\n\tNode<V> rtX = findSet(x);\n\tNode<V> rtY = findSet(y);\n\tif (rtX.parent != rtY.parent) {\n\t    link(rtX, rtY);\n\t}\n    }\n\n    public V getNode(Node<V> x) {\n\treturn x.node;\n    }\n\n    private int getColor(Node<V> node) {\n\n\tint color;\n\tNode<V> parent = findSet(node);\n\tcolor = parent.color;\n\n\treturn color;\n    }\n\n    private void setColor(Node<V> node, int color) {\n\tNode<V> parent = findSet(node);\n\tparent.color = color;\n    }\n\n    private static Node<Integer> getOrInitNode(Integer key) {\n\n\tNode<Integer> node = datas.get(key);\n\n\tif (node == null) {\n\t    node = sets.makeSet(key);\n\t    datas.put(key, node);\n\t}\n\n\treturn node;\n    }\n\n    private static void initNodes(Scanner scanner) {\n\n\tint key;\n\tNode<Integer> node;\n\tfor (int i = 0; i < n; i++) {\n\t    key = scanner.nextInt();\n\t    node = getOrInitNode(key);\n\t    nodes.add(node);\n\t}\n    }\n\n    private static void unionAll(Node<Integer> value) {\n\n\tint color = sets.getColor(value);\n\tif (color == 0) {\n\t    if (first == null) {\n\t\tfirst = value;\n\t    } else {\n\t\tsets.union(first, value);\n\t    }\n\t} else if (color == 1) {\n\t    if (second == null) {\n\t\tsecond = value;\n\t    } else {\n\t\tsets.union(second, value);\n\t    }\n\t}\n    }\n\n    private static int getKey(Node<Integer> value, int color) {\n\n\tint key = value.node;\n\n\tif (color == 0) {\n\t    key = a - key;\n\t} else {\n\t    key = b - key;\n\t}\n\n\treturn key;\n    }\n\n    private static boolean checkOpposite(Node<Integer> value, int color) {\n\n\tboolean valid;\n\n\tif (value.inprogress) {\n\t    valid = Boolean.TRUE;\n\t} else {\n\t    value.inprogress = Boolean.TRUE;\n\t    int opColor = 1 - color;\n\t    int key = getKey(value, opColor);\n\t    Node<Integer> node = datas.get(key);\n\t    valid = (value.node.equals(key)) || (node == null);\n\t    if (!valid) {\n\t\tkey = getKey(node, color);\n\t\tNode<Integer> child = datas.get(key);\n\t\tvalid = (child != null);\n\t\tif (valid) {\n\t\t    valid = checkOpposite(child, color);\n\t\t    if (valid) {\n\t\t\tsets.union(value, node);\n\t\t\tsets.union(value, child);\n\t\t\tvalue.inprogress = Boolean.FALSE;\n\t\t    }\n\t\t}\n\t    }\n\t    value.inprogress = Boolean.FALSE;\n\t}\n\n\treturn valid;\n    }\n\n    private static boolean checkNodes(Node<Integer> value, int color) {\n\n\tboolean valid;\n\n\tint key = getKey(value, color);\n\tint opColor = 1 - color;\n\tNode<Integer> node = datas.get(key);\n\tvalid = (value.node.equals(key)) || (node != null);\n\tif (valid) {\n\t    valid = checkOpposite(value, color);\n\t    if (valid) {\n\t\tsets.union(value, node);\n\t\tsets.setColor(value, color);\n\t    } else if (color == 0) {\n\t\tvalid = checkNodes(value, opColor);\n\t    }\n\t} else if (color == 0) {\n\t    valid = checkNodes(value, opColor);\n\t}\n\n\treturn valid;\n    }\n\n    private static void format(StringBuilder builder, int i) {\n\n\tif (i > 0) {\n\t    builder.append(' ');\n\t}\n    }\n\n    private static String printNodes() {\n\n\tString text;\n\n\tStringBuilder builder = new StringBuilder();\n\tIterator<Node<Integer>> iterator = nodes.iterator();\n\tint i = 0;\n\tNode<Integer> node;\n\twhile (iterator.hasNext()) {\n\t    format(builder, i);\n\t    node = iterator.next();\n\t    builder.append(sets.getColor(node));\n\t    i++;\n\t}\n\ttext = builder.toString().trim();\n\n\treturn text;\n    }\n\n    private static boolean checkNodes(int color) {\n\n\tboolean valid = Boolean.TRUE;\n\n\tfor (Node<Integer> value : nodes) {\n\t    if (sets.getColor(value) == -1) {\n\t\tvalid = checkNodes(value, color);\n\t\tif (valid) {\n\t\t    unionAll(value);\n\t\t} else {\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\treturn valid;\n    }\n\n    private static void calculate() {\n\n\tint color = 0;\n\tboolean valid = checkNodes(color);\n\tString message = \"NO\";\n\tif (valid) {\n\t    message = \"YES\";\n\t    String array = printNodes();\n\t    System.out.println(message);\n\t    System.out.println(array);\n\t} else {\n\t    System.out.println(message);\n\t}\n    }\n\n    public static void main(String[] args) {\n\n\tScanner scanner = new Scanner(System.in);\n\ttry {\n\t    n = scanner.nextInt();\n\t    a = scanner.nextInt();\n\t    b = scanner.nextInt();\n\t    initNodes(scanner);\n\t    calculate();\n\t} finally {\n\t    scanner.close();\n\t}\n    }\n}\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n\npublic class A {\t\n\tBufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter out;\n    \n\tpublic void solve() throws IOException {\t\t\t\t\n\t\tint N = nextInt();\n\t\tif( N >= 0) {\n\t\t\tout.println(N);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint ans = N/10;\n\t\tint ans2 = N/100*10 + N%10;\n\t\tout.println( Math.max(ans, ans2));\n\t\t\n\t}\n\t\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tnew A().run();\n\t}\n\t\n\tpublic void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            out = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n}\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.math.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    void solve(){\n        int n=ni();\n        int c1[]=new int[9];\n        int c2[]=new int[9];\n        for(int i=0;i<n;i++){\n            String s=ns();\n            if(s.equals(\"M\")) c1[0]++;\n            else if(s.equals(\"S\")) c1[1]++;\n            else if(s.equals(\"L\")) c1[2]++;\n            else if(s.equals(\"XS\")) c1[3]++;\n            else if(s.equals(\"XL\")) c1[4]++;\n            else if(s.equals(\"XXS\")) c1[5]++;\n            else if(s.equals(\"XXL\")) c1[6]++;\n            else if(s.equals(\"XXXS\")) c1[7]++;\n            else if(s.equals(\"XXXL\")) c1[8]++;\n        }\n        for(int i=0;i<n;i++){\n            String s=ns();\n            if(s.equals(\"M\")) c2[0]++;\n            else if(s.equals(\"S\")) c2[1]++;\n            else if(s.equals(\"L\")) c2[2]++;\n            else if(s.equals(\"XS\")) c2[3]++;\n            else if(s.equals(\"XL\")) c2[4]++;\n            else if(s.equals(\"XXS\")) c2[5]++;\n            else if(s.equals(\"XXL\")) c2[6]++;\n            else if(s.equals(\"XXXS\")) c2[7]++;\n            else if(s.equals(\"XXXL\")) c2[8]++;\n        }\n        int ans=0;\n        for(int i=0;i<9;i++){\n            if(c2[i]<c1[i]) ans+=c1[i]-c2[i];\n        }\n        pw.println(ans);\n\n\n    }\n    long M=(long)1e9+7;\n    InputStream is;\n    PrintWriter pw;\n    String INPUT = \"\";\n    void run() throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        pw = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        pw.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n\n    public static void main(String[] args) throws Exception { new Main().run(); }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n\n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n) {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n\n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n\n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n\n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private void tr(Object... o) { if(INPUT.length() > 0)System.out.println(Arrays.deepToString(o)); }\n}", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.util.*;\npublic class A122\n{\n    public static void main(String aa[])\n    {\n        Scanner ob=new Scanner(System.in);\n        int n;\n        \n        n=ob.nextInt();\n        if(n%4==0||n%7==0||n%44==0||n%47==0||n%444==0||n%447==0||n%474==0||n%477==0||n%744==0||n%747==0||n%774==0||n%777==0)\n        System.out.println(\"YES\");\n        else\n        System.out.println(\"NO\");\n    }\n}", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import javax.swing.plaf.synth.SynthLookAndFeel;\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\npublic class CP {\n    static Scanner sc = new Scanner(System.in);\n    static class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n\n\n\n\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    public static int lowerBound\n    (Integer[] array, int length, int value) {\n        int l = 0;\n        int r = length;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            if (value < array[mid]) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n    public static long gcd(long a, long b){\n        if (b == 0)\n            return a;\n        else return gcd(b, a % b);\n    }\n    public static void main(String [] args) {\n       // int T = sc.nextInt();while (T--!=0)\n        {\n            solve();\n        }\n    }\n   static long n,k;\n    static long sum(long x ){\n        return x*(x+1)/2;\n    }\n    static long sum(long s, long e){\n        if(s<=1) return sum(e);\n        return sum(e)-sum(s-1);\n    }\n    //static long mod;\n    static long split(long k,long n){\n        long st=1,en=k;\n        while(st<en) {\n            long   mod = (st+en)/2;\n            long s = sum(mod, k);\n\n            if(s==n)\n                return k-mod+1;\n            if(s>n) st=mod+1;\n            else en=mod;\n        }\n        return k - st+2;\n    }\n    public static void solve(){\n///////////////////////////////////////////////////////////////////////////////////////////\n             n=sc.nextLong();k=sc.nextLong();\n\n             if(n==1){\n                 System.out.println(0);\n                 return;\n             }\n             if(n<=k ) {\n                 System.out.println(1);\n                 return;\n             }\n        n--; k--;\n        if(sum(k)<n){\n            System.out.println(-1);\n\n        }\n        else {\n            System.out.println(split(k,n));\n        }\n////////////////////////////////////////////////////////////////////////////////////////////\n    }\n\n}", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Objects;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Solution{\n\t\n\t\n\tstatic int n;\n\tstatic Point[] pt;\n\tstatic boolean[] used;\n\t\n\t\n    public static void main(String[] args) throws IOException {\n    \t\n\t\t\n    \tFastScanner fs = new FastScanner();\n    \tPrintWriter out = new PrintWriter(System.out);\n    \t\t\n    \tint tt = 1;\n    \twhile(tt-->0) {\n    \t\t\n    \t\tn = fs.nextInt();\n    \t\t\n    \t\tpt = new Point[n];\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\tpt[i] = new Point(fs.nextLong(), fs.nextLong());\n    \t\t}\n    \t\tused = new boolean[n];\n    \t\t\n    \t\tif(n<=2) {\n    \t\t\tout.println(\"YES\");\n    \t\t\tout.flush();\n    \t\t\treturn;\n    \t\t}\n    \t\t\n    \t\tif(check(pt[0], pt[1]) || check(pt[0], pt[2]) || check(pt[1], pt[2])) {\n    \t\t\tout.println(\"YES\");\n    \t\t}\n    \t\telse {\n    \t\t\tout.println(\"NO\");\n    \t\t}\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t}\n    \t\n    \tout.close();\n    \t\t\n    }\n    \n    \n    static boolean check(Point p1, Point p2) {\n    \tArrays.fill(used, false);\n    \tfor(int i=0;i<n;i++) {\n    \t\tif(new Vector(p1.x-p2.x, p1.y-p2.y).cross(new Vector(p1.x-pt[i].x, p1.y-pt[i].y))==0) {\n    \t\t\tused[i] = true;\n    \t\t}\n    \t}\n    \treturn check2();\n    }\n    \n    \n    static boolean check2() {\n    \tPoint p1=null, p2 = null;\n    \tfor(int i=0;i<n;i++) {\n    \t\tif(used[i]) continue;\n    \t\tif(p1==null) p1 = pt[i];\n    \t\telse if(p2==null) p2 = pt[i];\n    \t}\n    \t\n    \tif(p2==null) return true;\n    \t\n    \tfor(int i=0;i<n;i++) {\n    \t\tif(used[i]) continue;\n    \t\tif(new Vector(p1.x-p2.x, p1.y-p2.y).cross(new Vector(p1.x-pt[i].x, p1.y-pt[i].y))!=0) return false;\n    \t}\n    \treturn true;\n    }\n    \n    \n    \n    static class Point{\n    \tlong x,y;\n    \t\n    \tPoint(long x,long y){\n    \t\tthis.x = x;\n    \t\tthis.y = y;\n    \t}\n    \t\n    }\n    \n    \n    static class Vector{\n    \tlong x,y;\n    \t\n    \tVector(long x,long y){\n    \t\tthis.x = x;\n    \t\tthis.y = y;\n    \t}\n    \t\n    \tlong cross(Vector v) {\n    \t\treturn this.x*v.y - this.y*v.x;\n    \t}\n    \t\n    }\n    \n    \n   \n   \n    \n    \n    \n    static final Random random=new Random();\n    \n    static <T> void shuffle(T[] arr) {\n    \tint n = arr.length;\n    \tfor(int i=0;i<n;i++\t) {\n    \t\tint k = random.nextInt(n);\n    \t\tT temp = arr[k]; arr[k] = arr[i]; arr[i] = temp;\n    \t}\n    }\n    \n    \t\n    static void ruffleSort(int[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); int temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n    \n    static void ruffleSort(long[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); long temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n   \n  \n    \n    static void reverse(int[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tint temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    static void reverse(long[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tlong temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    \n    static <T> void reverse(T[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++) {\n    \t\tT temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \t\n    \t\n    static class FastScanner{\n    \tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \tStringTokenizer st = new StringTokenizer(\"\");\n     \n    \tpublic String next(){\n    \t\twhile(!st.hasMoreElements()){\n    \t\t\ttry{\n    \t\t\t\tst = new StringTokenizer(br.readLine());\n    \t\t\t} catch(IOException e){\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t\treturn st.nextToken();\n    \t}\n    \t\t\n    \tpublic String nextLine() throws IOException {\n    \t\treturn br.readLine();\n    \t}\n    \t\t\n    \tpublic int nextInt(){\n    \t\treturn Integer.parseInt(next());\n    \t}\n     \n    \tpublic int[] readArray(int n){\n    \t\tint[] a = new int[n];\n    \t\tfor(int i=0;i<n;i++)\n    \t\t\ta[i] = nextInt();\n    \t\treturn a;\n    \t}\n    \t\t\n    \tpublic long nextLong() {\n    \t\treturn Long.parseLong(next());\n    \t}\n    \t\t\n    \tpublic char nextChar() {\n    \t\treturn next().toCharArray()[0];\n    \t}\n    }\n   \t\n}\n", "complexity": "nlogn", "problem": "0961_D", "from": "CODEFORCES", "tags": "geometry"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class practice {\n\tstatic class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    } \n\n\t\tpublic static void main(String[] args) throws IOException {\t\t\t\n\t\t\tReader scn=new Reader(\"input.txt\");\n\t\t\tPrintWriter out = new PrintWriter(new File(\"output.txt\"));\n\t\t int n=scn.nextInt(),m=scn.nextInt(),k=scn.nextInt();\n\t\t int[][] inf=new int[k][2];\n\t\t for(int i=0;i<k;i++){\n\t\t\t inf[i][0]=scn.nextInt();inf[i][1]=scn.nextInt();\n\t\t }\n\t\t int ans=0,x=1,y=1;\n\t\t for(int i=1;i<=n;i++){\n\t\t\t for(int j=1;j<=m;j++){\n\t\t\t\t int temp=Integer.MAX_VALUE;\n\t\t\t\t for(int l=0;l<k;l++){\n\t\t\t\t\ttemp=Math.min(temp, Math.abs(i-inf[l][0])+Math.abs(j-inf[l][1])); \n\t\t\t\t }\n\t\t\t\t if(temp>ans){\n\t\t\t\t\t ans=temp;x=i;y=j;\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t out.print(x + \" \" + y);\n\t   \t out.close();\n\t\t}\n\t}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import javafx.util.Pair;\n\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main implements Runnable\n{\n    boolean multiple = false;\n    long MOD;\n\n    @SuppressWarnings({\"Duplicates\", \"ConstantConditions\"})\n    void solve() throws Exception\n    {\n        int k = sc.nextInt();\n        long tar = 0;\n        long[][] arr = new long[k][];\n        long[] sum = new long[k];\n        HashMap<Long, Pair<Integer, Integer>> map = new HashMap<>();\n        for (int i = 0; i < k; i++)\n        {\n            int ni = sc.nextInt();\n            arr[i] = new long[ni];\n            for (int j = 0; j < ni; j++)\n            {\n                sum[i] += (arr[i][j] = sc.nextInt());\n                map.put(arr[i][j], new Pair<>(i, j));\n            }\n            tar += sum[i];\n        }\n        if (tar % k != 0) { System.out.println(\"No\"); return; }\n        tar /= k;\n        works = new HashMap<>();\n        for (int i = 0; i < k; i++)\n        {\n            outer: for (int j = 0; j < arr[i].length; j++)\n            {\n                long val = arr[i][j];\n                long want = tar - sum[i] + val;\n                if (!map.containsKey(want)) continue;\n//                ArrayList<pli> list = new ArrayList<>();\n                int key = 1 << i;\n                int next = map.get(want).getKey();\n//                int prev = i;\n                HashSet<Integer> seen = new HashSet<>();\n                seen.add(i);\n                while (true)\n                {\n                    if (seen.contains(next))\n                    {\n                        if (next == i && want == arr[i][j])\n                            works.put(key, (((long) i) << 32) + ((long) j));\n                        break;\n                    }\n//                    list.add(new pli(want, prev));\n                    val = arr[next][map.get(want).getValue()];\n                    want = tar - sum[next] + val;\n                    if (!map.containsKey(want)) continue outer;\n                    key |= 1 << next;\n//                    prev = next;\n                    seen.add(next);\n                    next = map.get(want).getKey();\n                }\n            }\n        }\n//        dp.put(0, new ArrayList<>());\n        dp = new long[1 << k];\n        done = new boolean[1 << k];\n        yes = new boolean[1 << k];\n        yes[0] = done[0] = true;\n        long ans = r((1 << k) - 1);\n        long[] val = new long[k];\n        int[] pos = new int[k];\n        if (!yes[(1 << k) - 1]) System.out.println(\"No\");\n        else\n        {\n//            System.out.println(ans);\n//            System.out.println(map);\n            System.out.println(\"Yes\");\n            while (ans >> 32 != 0)\n            {\n                long p = works.get((int)(ans >> 32));\n                int i = (int)(p >> 32), j = (int)(p & ((1L<<32)-1));\n                long VAL = arr[i][j];\n                long want = tar - sum[i] + VAL;\n                int key = 1 << i;\n                int next = map.get(want).getKey();\n                int prev = i;\n                while (true)\n                {\n                    if (next == i)\n                    {\n                        val[map.get(want).getKey()] = want;\n                        pos[map.get(want).getKey()] = prev + 1;\n                        if (want == arr[i][j])\n                            works.put(key, (((long)i)<<32) + ((long)j));\n                        break;\n                    }\n                    val[map.get(want).getKey()] = want;\n                    pos[map.get(want).getKey()] = prev + 1;\n                    VAL = arr[next][map.get(want).getValue()];\n                    want = tar - sum[next] + VAL;\n                    key |= 1 << next;\n                    prev = next;\n                    next = map.get(want).getKey();\n                }\n\n                ans = dp[(int)(ans & ((1L << 32)- 1))];\n            }\n            for (int i = 0; i < k; i++)\n                System.out.println(val[i] + \" \" + pos[i]);\n        }\n    }\n\n    HashMap<Integer, Long> works;\n    long[] dp;\n    boolean[] done, yes;\n\n    long r(int mask)\n    {\n        if (done[mask]) return dp[mask];\n        done[mask] = true;\n        for (int s = mask; s != 0; s = (s-1) & mask)\n            if (works.keySet().contains(s))\n            {\n                int tempMask = mask;\n                for (int i = 0; i < 16; i++)\n                    if ((s & (1 << i)) != 0)\n                        tempMask ^= 1 << i;\n                r(tempMask);\n                if (yes[tempMask])\n                {\n                    yes[mask] = true;\n                    return dp[mask] = (((long)s) << 32) + tempMask;\n                }\n            }\n        return 0;\n    }\n\n    class pii { int f, s; pii(int k, int v) { f = k; s = v; } }\n    class pli { long f; int s; pli(long k, int v) { f = k; s = v; } public String toString() { return \"(\" + f + \", \" + s + \")\"; } }\n    StringBuilder ANS = new StringBuilder();\n    void p(Object s) { ANS.append(s); } void p(double s) {ANS.append(s); } void p(long s) {ANS.append(s); } void p(char s) {ANS.append(s); }\n    void pl(Object s) { ANS.append(s); ANS.append('\\n'); } void pl(double s) { ANS.append(s); ANS.append('\\n'); } void pl(long s) { ANS.append(s); ANS.append('\\n'); } void pl(char s) { ANS.append(s); ANS.append('\\n'); } void pl() { ANS.append(('\\n')); }\n    /*I/O, and other boilerplate*/ @Override public void run() { try { in = new BufferedReader(new InputStreamReader(System.in));out = new PrintWriter(System.out);sc = new FastScanner(in);if (multiple) { int q = sc.nextInt();for (int i = 0; i < q; i++) solve(); } else solve(); System.out.print(ANS); } catch (Throwable uncaught) { Main.uncaught = uncaught; } finally { out.close(); }} public static void main(String[] args) throws Throwable{ Thread thread = new Thread(null, new Main(), \"\", (1 << 26));thread.start();thread.join();if (Main.uncaught != null) {throw Main.uncaught;} } static Throwable uncaught; BufferedReader in; FastScanner sc; PrintWriter out; } class FastScanner { BufferedReader in; StringTokenizer st; public FastScanner(BufferedReader in) {this.in = in;}public String nextToken() throws Exception { while (st == null || !st.hasMoreTokens()) { st = new StringTokenizer(in.readLine()); }return st.nextToken(); }public int nextInt() throws Exception { return Integer.parseInt(nextToken()); }public long nextLong() throws Exception { return Long.parseLong(nextToken()); }public double nextDouble() throws Exception { return Double.parseDouble(nextToken()); }\n}", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Main{\n     static int root[],lc[],rc[],sz[],tot=1;\n     public static void main(String []args) throws IOException{\n        BufferedReader sc=new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw=new PrintWriter(System.out);\n        String s[]=sc.readLine().trim().split(\" \");\n        int n=Integer.parseInt(s[0]);\n        int q=Integer.parseInt(s[1]);\n        root=new int[(int)(7e6)];\n        lc=new int[(int)(7e6)];\n        rc=new int[(int)(7e6)];\n        sz=new int[(int)(7e6)];\n        root[0]=0;\n        pre(0,1,n);\n        StringBuilder sb=new StringBuilder();\n        s=sc.readLine().trim().split(\" \");\n        for(int i=1;i<=n;i++){\n            int x=Integer.parseInt(s[i-1]);\n            root[i]=tot++;\n            //System.out.println(tot);\n            update(root[i],root[i-1],1,n,x);\n        }\n        \n        while(q-->0){\n            s=sc.readLine().trim().split(\" \");\n            int l=Integer.parseInt(s[0]);\n            int r=Integer.parseInt(s[1]);\n            int k=Integer.parseInt(s[2]);\n            int len=(r-l+1+k)/k;\n            sb.append(query(root[l-1],root[r],1,n,len)+\"\\n\");\n        }\n        pw.println(sb.toString());\n        pw.flush();\n        sc.close();\n        pw.close();\n     }\n     public static void update(int curr,int prev,int l,int r,int x){\n         sz[curr]=sz[prev]+1;\n         if(l>=r)return;\n         int val=tot;\n         int mid=(l+r)>>1;\n         if(x<=mid){\n             lc[curr]=tot++;\n             rc[curr]=rc[prev];\n             update(lc[curr],lc[prev],l,mid,x);\n         }else{ \n             rc[curr]=tot++;\n             lc[curr]=lc[prev];\n             update(rc[curr],rc[prev],mid+1,r,x);\n         }\n     }\n     public static int query(int ql,int qr,int l,int r,int len){\n         if(sz[qr]-sz[ql]<len)return -1;\n         if(l==r)return l;\n         int mid=(l+r)/2;\n         int x=query(lc[ql],lc[qr],l,mid,len);\n         if(x!=-1)return x;\n         return query(rc[ql],rc[qr],mid+1,r,len);\n     }\n     public static void pre(int curr,int l,int r){\n         if(l==r)return;\n         lc[curr]=tot++;\n         int val=tot;\n         int mid=(l+r)>>1;\n         pre(lc[curr],l,mid);\n         rc[curr]=tot++;\n         pre(rc[curr],mid+1,r);\n     }\n}", "complexity": "cubic", "problem": "0840_D", "from": "CODEFORCES", "tags": "data structures,probabilities"}
{"src": "import java.util.*;\npublic class A{\n       \n       public static int mod = 1000000007;\n       \n       public static void main(String args[]){\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              char s[] = new char[n];\n              for(int i = 0; i < n; i++)\n                     s[i] = sc.next().charAt(0);\n              int dp[][] = new int[5001][5001];\n              int sum[][] = new int[5001][5001];\n              dp[0][0] = 1;\n              sum[0][0] = 1;\n              for(int i = 1; i < n; i++){\n                     for(int j = n - 1; j >= 0; j--){\n                            if(s[i-1] == 'f' && j > 0){\n                                   dp[i][j] = dp[i-1][j-1] % mod;\n                            }else if(s[i-1] == 's'){\n                                   dp[i][j] = sum[i-1][j] % mod;\n                            }\n                            sum[i][j] = (sum[i][j+1] + dp[i][j]) % mod;\n                     }\n              }\n              System.out.println(sum[n-1][0]);\n       }\n}", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        new Solver().run(1);\n    }\n}\n\nclass Solver {\n\n    private BufferedReader reader = null;\n    private StringTokenizer st = null;\n\n    private static final long MOD = (long)1e9 + 7;\n    private long x, k;\n\n    public void run(int inputType) throws Exception {\n        if (inputType == 0)\n            reader = new BufferedReader(new FileReader(\"input.txt\"));\n        else\n            reader = new BufferedReader(new InputStreamReader(System.in));\n\n        st = new StringTokenizer(reader.readLine());\n        x = Long.parseLong(st.nextToken());\n        k = Long.parseLong(st.nextToken());\n\n        if (x == 0) {\n            System.out.println(0);\n            return;\n        }\n\n        long pow = binpow(2, k);\n        long m = (2 * x) % MOD;\n\n        m = (m - 1 < 0) ? MOD - 1 : m - 1;\n\n        m = (m * pow) % MOD;\n        m = (m + 1) % MOD;\n\n        System.out.println(m);\n\n        reader.close();\n    }\n\n    long binpow(long v, long p) {\n        long res = 1L;\n        while(p > 0) {\n\n            if ((p & 1) > 0)\n                res = (res * v) % MOD;\n\n            v = (v * v) % MOD;\n            p /= 2;\n        }\n\n        return res;\n    }\n}\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E solver = new E();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.ni(), K = in.ni();\n            long mod = 998244353;\n            long[][] dp = new long[n + 1][n + 1];\n            for (int lim = 1; lim <= n; lim++) {\n                long sum = 1;\n                dp[0][lim] = 1;\n                for (int i = 1; i <= n; i++) {\n                    dp[i][lim] = (dp[i][lim] + sum) % mod;\n                    sum = (sum + dp[i][lim]) % mod;\n                    if (i >= lim)\n                        sum = (sum - dp[i - lim][lim] + mod) % mod;\n                }\n            }\n            long ans = 0;\n            for (int k = 1; k < Math.min(K, n + 1); k++) {\n                long h = dp[n][k] - dp[n][k - 1];\n                int lim = K / k;\n                if (K % k == 0)\n                    lim--;\n                if (lim > n)\n                    lim = n;\n                ans += dp[n][lim] * h % mod;\n            }\n            out.println(2 * ans % mod);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1027_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main implements Runnable {\n\n    private int n;\n    private int nn;\n    private boolean[][] gr;\n    private long[][] D;\n\n\n    // ////////////////////////////////////////////////////////////////////\n    // Solution\n\n    private void solve() throws Throwable {\n        n = nextInt();\n        nn = 1 << n;\n        gr = new boolean[n][n];\n        int m = nextInt();\n        for (int i = 0; i < m; i++) {\n            int a = nextInt() - 1, b = nextInt() - 1;\n            gr[a][b] = gr[b][a] = true;\n        }\n        D = new long[n][nn];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(D[i], -1);\n        }\n        long count = 0;\n        for (int i = 0; i < n; i++) {\n            count += getD(i, i, 1, 1 << i);\n        }\n        pw.println(count / 2);\n    }\n\n\n    private long getD(int first, int last, int cnt, int mask) {\n        if (D[last][mask] != -1) return D[last][mask];\n        long ans = 0;\n        if (cnt >= 3 && gr[first][last])\n            ans++;\n        for (int i = first + 1; i < n; i++) {\n            if (gr[last][i] && (mask & (1 << i)) == 0) {\n                ans += getD(first, i, cnt + 1, mask | (1 << i));\n            }\n        }\n        D[last][mask] = ans;\n        return ans;\n    }\n\n\n    // ////////////////////////////////////////////////////////////////////\n    // Utility functions\n\n    PrintWriter pw;\n    BufferedReader in;\n    StringTokenizer st;\n\n    void initStreams() throws FileNotFoundException {\n        //System.setIn(new FileInputStream(\"2\"));\n        in = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n    }\n\n    String nextString() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(nextString());\n    }\n\n    long nextLong() throws NumberFormatException, IOException {\n        return Long.parseLong(nextString());\n    }\n\n    double nextDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(nextString());\n    }\n\n    static Throwable sError;\n\n    public static void main(String[] args) throws Throwable {\n        Thread t = new Thread(new Main());\n        t.start();\n        t.join();\n        if (sError != null) {\n            throw sError;\n        }\n    }\n\n    public void run() {\n        try {\n            initStreams();\n            solve();\n        } catch (Throwable e) {\n            sError = e;\n        } finally {\n            if (pw != null)\n                pw.close();\n        }\n    }\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.util.*;\n\npublic class B {\n\n\tpublic B () {\n\t\tint N = sc.nextInt();\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tint [] P = sc.nextInts();\n\n\t\tTreeSet<Integer> S = new TreeSet<>();\n\t\tSet<Integer> A = new HashSet<>();\n\t\tSet<Integer> B = new HashSet<>();\n\n\t\tfor (int p : P) S.add(p);\n\t\twhile (!S.isEmpty()) {\n\t\t\tint q = S.first();\n\t\t\tint x = a - q, y = b - q;\n\t\t\tif (S.contains(x) && S.contains(y)) {\n\t\t\t\tif (x > y) {\n\t\t\t\t\tS.remove(q); S.remove(x);\n\t\t\t\t\tA.add(q); A.add(x);\n\t\t\t\t} else {\n\t\t\t\t\tS.remove(q); S.remove(y);\n\t\t\t\t\tB.add(q); B.add(y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (S.contains(x)) {\n\t\t\t\tS.remove(q); S.remove(x);\n\t\t\t\tA.add(q); A.add(x);\n\t\t\t}\n\t\t\telse if (S.contains(y)) {\n\t\t\t\tS.remove(q); S.remove(y);\n\t\t\t\tB.add(q); B.add(y);\n\t\t\t}\n\t\t\telse\n\t\t\t\texit(\"NO\");\n\t\t}\n\n\t\tint [] res = new int[N];\n\t\tfor (int i : rep(N))\n\t\t\tif (B.contains(P[i]))\n\t\t\t\tres[i] = 1;\n\n\t\tprint(\"YES\");\n\t\texit(res);\n\t}\n\n\tprivate static int [] rep(int N) { return rep(0, N); }\n\tprivate static int [] rep(int S, int T) { if (T <= S) return new int [0]; int [] res = new int [T-S]; for (int i = S; i < T; ++i) res[i-S] = i; return res; }\n\t////////////////////////////////////////////////////////////////////////////////////\n\tprivate final static IOUtils.MyScanner sc = new IOUtils.MyScanner();\n\tprivate static void print (Object o, Object ... A) { IOUtils.print(o, A); }\n\tprivate static void exit (Object o, Object ... A) { IOUtils.print(o, A); IOUtils.exit(); }\n\tprivate static class IOUtils {\n\t\tpublic static class MyScanner {\n\t\t\tpublic String next() { newLine(); return line[index++]; }\n\t\t\tpublic int nextInt() { return Integer.parseInt(next()); }\n\t\t\tpublic String nextLine() { line = null; return readLine(); }\n\t\t\tpublic String [] nextStrings() { return split(nextLine()); }\n\t\t\tpublic int [] nextInts() {\n\t\t\t\tString [] L = nextStrings();\n\t\t\t\tint [] res = new int [L.length];\n\t\t\t\tfor (int i = 0; i < L.length; ++i)\n\t\t\t\t\tres[i] = Integer.parseInt(L[i]);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t//////////////////////////////////////////////\n\t\t\tprivate boolean eol() { return index == line.length; }\n\t\t\tprivate String readLine() {\n\t\t\t\ttry {\n\t\t\t\t\treturn r.readLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new Error (e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate final java.io.BufferedReader r;\n\t\t\tprivate MyScanner () { this(new java.io.BufferedReader(new java.io.InputStreamReader(System.in))); }\n\t\t\tprivate MyScanner (java.io.BufferedReader r) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.r = r;\n\t\t\t\t\twhile (!r.ready())\n\t\t\t\t\t\tThread.sleep(1);\n\t\t\t\t\tstart();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new Error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate String [] line;\n\t\t\tprivate int index;\n\t\t\tprivate void newLine() {\n\t\t\t\tif (line == null || eol()) {\n\t\t\t\t\tline = split(readLine());\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate String [] split(String s) { return s.length() > 0 ? s.split(\" \") : new String [0]; }\n\t\t}\n\t\tprivate static String build(Object o, Object ... A) { return buildDelim(\" \", o, A); }\n\t\tprivate static String buildDelim(String delim, Object o, Object ... A) {\n\t\t\tStringBuilder b = new StringBuilder();\n\t\t\tappend(b, o, delim);\n\t\t\tfor (Object p : A)\n\t\t\t\tappend(b, p, delim);\n\t\t\treturn b.substring(delim.length());\n\t\t}\n\t\t//////////////////////////////////////////////////////////////////////////////////\n\t\tprivate static void start() { if (t == 0) t = millis(); }\n\t\tprivate static void append(StringBuilder b, Object o, String delim) {\n\t\t\tif (o.getClass().isArray()) {\n\t\t\t\tint len = java.lang.reflect.Array.getLength(o);\n\t\t\t\tfor (int i = 0; i < len; ++i)\n\t\t\t\t\tappend(b, java.lang.reflect.Array.get(o, i), delim);\n\t\t\t} else if (o instanceof Iterable<?>)\n\t\t\t\tfor (Object p : (Iterable<?>) o)\n\t\t\t\t\tappend(b, p, delim);\n\t\t\telse {\n\t\t\t\tif (o instanceof Double)\n\t\t\t\t\to = new java.text.DecimalFormat(\"#.############\").format(o);\n\t\t\t\tb.append(delim).append(o);\n\t\t\t}\n\t\t}\n\t\tprivate static java.io.PrintWriter pw = new java.io.PrintWriter(System.out);\n\t\tprivate static void print(Object o, Object ... A) { pw.println(build(o, A)); }\n\t\tprivate static void err(Object o, Object ... A) { System.err.println(build(o, A)); }\n\t\tprivate static void exit() {\n\t\t\tIOUtils.pw.close();\n\t\t\tSystem.out.flush();\n\t\t\terr(\"------------------\");\n\t\t\terr(IOUtils.time());\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tprivate static long t;\n\t\tprivate static long millis() { return System.currentTimeMillis(); }\n\t\tprivate static String time() { return \"Time: \" + (millis() - t) / 1000.0; }\n\t}\n\tpublic static void main (String[] args) { new B(); IOUtils.exit(); }\n}\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class A {\n\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\n\tvoid solve() throws IOException {\n\t\tint n = readInt();\n\t\tint m = readInt();\n\t\tint k = readInt();\n\t\tint[] a = readArr(n);\n\t\tArrays.sort(a);\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tint curR = k;\n\t\t\tfor(int j = n-1; j >= n-i; j--){\n\t\t\t\tcurR += a[j];\n\t\t\t}\n\t\t\tcurR -= i;\n\t\t\tif(curR >= m){\n\t\t\t\tout.println(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(-1);\n\t}\n\n\tvoid init() throws FileNotFoundException {\n\t\tif (ONLINE_JUDGE) {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t} else {\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t}\n\t}\n\n\tString readString() throws IOException {\n\t\twhile (!tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tint readInt() throws IOException {\n\t\treturn Integer.parseInt(readString());\n\t}\n\n\tlong readLong() throws IOException {\n\t\treturn Long.parseLong(readString());\n\t}\n\n\tdouble readDouble() throws IOException {\n\t\treturn Double.parseDouble(readString());\n\t}\n\n\tint[] readArr(int n) throws IOException {\n\t\tint[] res = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres[i] = readInt();\n\t\t}\n\t\treturn res;\n\t}\n\n\tlong[] readArrL(int n) throws IOException {\n\t\tlong[] res = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres[i] = readLong();\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tlong t1 = System.currentTimeMillis();\n\t\t\tinit();\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t\tlong t2 = System.currentTimeMillis();\n\t\t\tSystem.err.println(\"Time = \" + (t2 - t1));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n}", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\n\tpublic void _main() throws IOException {\n\t\tint n = nextInt();\n\t\tint even = 0, odd = 0, atEven = -1, atOdd = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (nextInt() % 2 == 0) {\n\t\t\t\tatEven = i;\n\t\t\t\t++even;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tatOdd = i;\n\t\t\t\t++odd;\n\t\t\t}\n\t\t}\n\t\tif (odd == 1)\n\t\t\tout.print(atOdd + 1);\n\t\telse\n\t\t\tout.print(atEven + 1);\n\t}\n\n\tprivate BufferedReader in;\n\tprivate PrintWriter out;\n\tprivate StringTokenizer st;\n\n\tprivate String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString rl = in.readLine();\n\t\t\tif (rl == null)\n\t\t\t\treturn null;\n\t\t\tst = new StringTokenizer(rl);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new Main()).start();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\t_main();\n\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(202);\n\t\t}\n\t}\n\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.FileReader;\n\nimport java.io.FileWriter;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.util.Arrays;\n\nimport java.util.Queue;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\n\n\npublic class ProblemC {\n\n\t\n\n\tstatic int[] dx = {1, 0, 0, -1};\n\n\tstatic int[] dy = {0, 1, -1, 0};\n\n\t\n\n\t\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader s = new BufferedReader(new FileReader(\"input.txt\"));\n\n\t\tPrintWriter out = new PrintWriter(new FileWriter(\"output.txt\"));\n\n//\t\tBufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n\n//\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\t\n\n\t\tString[] nm = s.readLine().split(\" \");\n\n\t\tint n = Integer.valueOf(nm[0]);\n\n\t\tint m = Integer.valueOf(nm[1]);\n\n\t\tint k = Integer.valueOf(s.readLine());\n\n\t\t\n\n\t\tint[][] dp = new int[n][m];\n\n\t\tfor (int i = 0 ; i < n ; i++) {\n\n\t\t\tArrays.fill(dp[i], Integer.MAX_VALUE);\n\n\t\t}\n\n\t\tString[] st = s.readLine().split(\" \");\n\n\t\tint[][] trees = new int[k][2];\n\n\t\tfor (int l = 0 ; l < k ; l++) {\n\n\t\t\ttrees[l][0] = Integer.valueOf(st[l*2])-1;\n\n\t\t\ttrees[l][1] = Integer.valueOf(st[l*2+1])-1;\n\n\t\t}\n\n\t\t\n\n\t\tint maxtime = -1;\n\n\t\tint max_x = -1;\n\n\t\tint max_y = -1;\n\n\t\tfor (int i = 0 ; i < n ; i++) {\n\n\t\t\tfor (int j = 0 ; j < m ; j++) {\n\n\t\t\t\tint minDist = n+m;\n\n\t\t\t\tfor (int l = 0 ; l < k ; l++) {\n\n\t\t\t\t\tminDist = Math.min(minDist, Math.abs(i - trees[l][0]) + Math.abs(j - trees[l][1]));\n\n\t\t\t\t}\n\n\t\t\t\tif (maxtime < minDist) {\n\n\t\t\t\t\tmaxtime = minDist;\n\n\t\t\t\t\tmax_x = i+1;\n\n\t\t\t\t\tmax_y = j+1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\t\n\n\t\t\n\n\t\tout.println(max_x + \" \" + max_y);\n\n\t\tout.flush();\n\n\t}\n\n\n\n\n\n\tpublic static void debug(Object... os){\n\n\t\tSystem.err.println(Arrays.deepToString(os));\n\n\t}\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "//stan hu tao\n//join nct ridin by first year culture reps\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class x1209E\n{\n    public static void main(String hi[]) throws Exception\n    {\n        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(infile.readLine());\n        int T = Integer.parseInt(st.nextToken());\n        StringBuilder sb = new StringBuilder();\n        while(T-->0)\n        {\n            st = new StringTokenizer(infile.readLine());\n            int N = Integer.parseInt(st.nextToken());\n            int M = Integer.parseInt(st.nextToken());\n            int[][] grid = new int[N][M];\n            for(int r=0; r < N; r++)\n                grid[r] = readArr(M, infile, st);\n            ArrayList<Integer> ls = new ArrayList<Integer>();\n            for(int i=0; i < M; i++)\n                ls.add(i);\n            Collections.sort(ls, (x,y) -> {\n                int m1 = grid[0][x];\n                int m2 = grid[0][y];\n                for(int r=1; r < N; r++)\n                {\n                    m1 = max(m1, grid[r][x]);\n                    m2 = max(m2, grid[r][y]);\n                }\n                return m2-m1;\n            });\n            int[][] newgrid = new int[N][M];\n            for(int r=0; r < N; r++)\n                for(int c=0; c < M; c++)\n                    newgrid[r][c] = grid[r][ls.get(c)];\n            M = min(M, N);\n            int[][] sums = new int[M][1<<N];\n            for(int i=1; i < M; i++)\n                for(int mask=0; mask < 1<<N; mask++)\n                {\n                    //try all shifts\n                    for(int head=0; head < N; head++)\n                    {\n                        int temp = 0;\n                        for(int b=0; b < N; b++)\n                        {\n                            int nb = b+head;\n                            if(nb >= N)\n                                nb -= N;\n                            if((mask&(1<<nb)) > 0)\n                                temp += newgrid[b][i];\n                        }\n                        sums[i][mask] = max(sums[i][mask], temp);\n                    }\n                }\n            int[][] dp = new int[M][1<<N];\n            for(int mask=0; mask < 1<<N; mask++)\n                for(int b=0; b < N; b++)\n                    if((mask&(1<<b)) > 0)\n                        dp[0][mask] += newgrid[b][0];\n            for(int i=1; i < M; i++)\n                for(int mask=0; mask < 1<<N; mask++)\n                    for(int pmask=mask; pmask >= 0; pmask=(pmask-1)&mask)\n                    {\n                        dp[i][mask] = max(dp[i][mask], dp[i-1][pmask]+sums[i][mask-pmask]);\n                        if(pmask == 0)\n                            break;\n                    }\n            sb.append(dp[M-1][(1<<N)-1]+\"\\n\");\n        }\n        System.out.print(sb);\n    }\n    public static int[] readArr(int N, BufferedReader infile, StringTokenizer st) throws Exception\n    {\n        int[] arr = new int[N];\n        st = new StringTokenizer(infile.readLine());\n        for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n        return arr;\n    }\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class SolutionE extends Thread {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                                            InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    private static final FastReader scanner = new FastReader();\n    private static final PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        new Thread(null, new SolutionE(), \"Main\", 1 << 26).start();\n    }\n\n    static final int[] primeFactors = getSmallestPrimeFactorInIntervalInclusive(10_000_000);\n\n    public void run() {\n        int t = scanner.nextInt();\n        for (int i = 0; i < t; i++) {\n            solve();\n        }\n        out.close();\n    }\n\n    //runs in roughly O(maxN * lg^2(maxN)))\n    public static int[] getSmallestPrimeFactorInIntervalInclusive(int maxN) {\n        int[] result = new int[maxN + 1];\n\n        result[1] = 1;\n        for (int i = 2; i <= maxN; i++) {\n            if (result[i] == 0) {\n                for (int j = i; j <= maxN; j += i) {\n                    result[j] = (result[j / i] % i == 0) ? (result[j/i]/i) : (result[j/i]*i);\n                }\n            }\n        }\n        return result;\n    }\n\n\n    private static void solve() {\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = primeFactors[scanner.nextInt()];\n        }\n\n        Map<Integer, Integer> lastSeenIndex = new HashMap<>();\n        int[] revertPointers = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lastSeenIndex.get(a[i]) != null) {\n                revertPointers[i] = lastSeenIndex.get(a[i]);\n            } else {\n                revertPointers[i] = -1;\n            }\n            lastSeenIndex.put(a[i], i);\n        }\n\n        int[][] maxSegment = new int[n][k+1];\n        for (int j = 0; j <= k; j++) {\n            int pointerLeft = 0;\n            int pointerRight = 0;\n            boolean[] changed = new boolean[n];\n            int amountChanged = 0;\n            while (pointerLeft < n) {\n                if (pointerRight < n && revertPointers[pointerRight] < pointerLeft) {\n                    pointerRight++;\n                } else if (pointerRight < n && revertPointers[pointerRight] >= pointerLeft && amountChanged < j) {\n                    changed[revertPointers[pointerRight]] = true;\n                    pointerRight++;\n                    amountChanged++;\n                } else {\n                    if (changed[pointerLeft]) {\n                        amountChanged--;\n                    }\n                    maxSegment[pointerLeft][j] = pointerRight;\n                    pointerLeft++;\n                }\n            }\n        }\n\n        int[][] dp = new int[n+1][k+1];\n\n        for (int j = 0; j <= k; j++) {\n            dp[n][j] = 0;\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 0; j <= k; j++) {\n                dp[i][j] = n + 1;\n                for (int x = 0; x <= j; x++) {\n                    int nextJumpTo = maxSegment[i][x];\n                    dp[i][j] = Math.min(dp[i][j], dp[nextJumpTo][j - x] + 1);\n                }\n            }\n        }\n\n        out.println(dp[0][k]);\n    }\n\n    //REMINDERS:\n    //- CHECK FOR INTEGER-OVERFLOW BEFORE SUBMITTING\n\n    //- CAN U BRUTEFORCE OVER SOMETHING, TO MAKE IT EASIER TO CALCULATE THE SOLUTION\n}", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author Andy Phan\n */\npublic class p1096f {\n    static long MOD = 998244353;\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        BIT invert = new BIT(n+5);\n        BIT neg = new BIT(n+5);\n        long res = 0;\n        int[] arr = new int[n];\n        boolean[] has = new boolean[n+1];\n        long num1 = 0;\n        for(int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n            if(arr[i] != -1) {\n                res += invert.read(n+5)-invert.read(arr[i]);\n                res %= MOD;\n                invert.update(arr[i], 1);\n                has[arr[i]] = true;\n            } else num1++;\n        }\n        if(num1 == 0) {\n            System.out.println(res);\n            return;\n        }\n        for(int i = 1; i <= n; i++) if(!has[i]) neg.update(i, 1);\n        long invertNum1 = modInv(num1, MOD);\n        res += ((num1*(num1-1))%MOD)*modInv(4, MOD);\n        res %= MOD;\n        long cnt = 0;\n        for(int i = 0; i < n; i++) {\n            if(arr[i] == -1) {\n                cnt++;\n                continue;\n            }\n            res += (((neg.read(n+5)-neg.read(arr[i]))*cnt)%MOD)*invertNum1;\n            res %= MOD;\n        }\n        cnt = 0;\n        for(int i = n-1; i >= 0; i--) {\n            if(arr[i] == -1) {\n                cnt++;\n                continue;\n            }\n            res += (((neg.read(arr[i]))*cnt)%MOD)*invertNum1;\n            res %= MOD;\n        }\n        System.out.println(res);\n    }\n    \n    //@\n    static class BIT {\n            int n;\n            int[] tree;\n            public BIT(int n) {\n                    this.n = n;\n                    tree = new int[n + 1];\n            }\n\n            int read(int i) {\n                    int sum = 0;\n                    while (i > 0) {\n                            sum += tree[i];\n                            i -= i & -i;\n                    }\n                    return sum;\n            }\n\n            void update(int i, int val) {\n                    while (i <= n) {\n                            tree[i] += val;\n                            i += i & -i;\n                    }\n            }\n            //$\n    }\n\n    \n    //@\n    // Computes the modular inverse of x\n    // Returns 0 if the GCD of x and mod is not 1\n    // O(log n)  :  Can be converted to use BigIntegers\n    static long modInv(long x, long mod) {\n        return (BigInteger.valueOf(x).modInverse(BigInteger.valueOf(mod))).longValue();\n    }\n\n    static long modInv(long a, long b, long y0, long y1, long q0, long q1) {\n            long y2 = y0 - y1*q0;\n            return b == 0 ? y2 : modInv(b, a % b, y1, y2, q1, a / b);\n    }\n    \n    //@\n    static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }\n    static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n\n}\n", "complexity": "nlogn", "problem": "1096_F", "from": "CODEFORCES", "tags": "dp,math,probabilities"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Fish\n{\n    public static void main(String[] args) throws Exception { new Fish(); }\n   \n    public Fish() throws Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        double[][] P = new double[N][N];\n        for(int i = 0; i < N; i++)\n            for(int j = 0; j < N; j++)\n                P[i][j] = sc.nextDouble();\n\n        \n        double[] best = new double[1 << N];\n        best[(1 << N)-1] = 1;\n        for(int mask = (1 << N)-1; mask > 0; mask--)\n        {\n            int C = Integer.bitCount(mask);\n            if(C == 1) continue;\n            for(int i = 0; i < N; i++) if (on(mask, i))\n                for(int j = i+1; j < N; j++) if(on(mask, j))\n                {\n                    int nmask = mask & ~(1 << j);\n                    best[nmask] += P[i][j] * best[mask] * 2.0 / (C*(C-1.0));\n                    nmask = mask & ~(1 << i);\n                    \n                    best[nmask] += P[j][i] * best[mask] * 2.0/ (C*(C-1.0));\n                }\n        }\n\n        for(int i = 0; i < N; i++)\n            System.out.printf(\"%.7f \", best[1 << i] + 1e-9);\n        System.out.println();\n    }\n\n    boolean on(int mask, int pos) { return (mask & (1 << pos)) > 0; }\n\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "//package educational35;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class ProblemD {\n\t\n\tpublic static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static StringTokenizer tok = null;\n\n\tpublic static void main(String args[]) throws IOException {\n\t\ttok = new StringTokenizer(in.readLine());\n\t\tint n = Integer.parseInt(tok.nextToken());\n\t\t\n\t\tint tab[] = new int[n]; \n\t\ttok = new StringTokenizer(in.readLine());\n\t\tfor (int i=0; i<n; i++)\n\t\t\ttab[i] = Integer.parseInt(tok.nextToken());\n\t\t\n\t\tint inversions = countInversions(tab);\n\t\tboolean isOdd = inversions % 2 == 1;\n\t\t\n\t\ttok = new StringTokenizer(in.readLine());\n\t\tint k = Integer.parseInt(tok.nextToken());\n\t\t\n\t\tint start, end, len;\n\t\t\n\t\tfor (int i=0; i<k; i++)\t{\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t\tstart = Integer.parseInt(tok.nextToken());\n\t\t\tend = Integer.parseInt(tok.nextToken());\n\t\t\t\n\t\t\tlen = (end - start + 1) % 4;\n\t\t\tif (len == 2 || len ==3)\n\t\t\t\tisOdd = !isOdd;\n\t\t\t\n\t\t\tout.println(isOdd ? \"odd\" : \"even\");\n\t\t}\n\t\t\n\t\tout.close();\n\t\t\n\t}\n\t\n\tprivate static int countInversions(int tab[]) {\n\t\tint n = tab.length;\n\t\tint auxTab[] = new int[n+1];\n\t\treturn _countInversions(tab, 0, n, auxTab);\n\t};\n\t\n\tprivate static int _countInversions(int tab[], int start, int end, int auxTab[]) {\n\t\t//indices from start to end; but values from start+1 to end+1 !!\n\t\tif (start+1 >= end)\n\t\t\treturn 0;\n\t\t\n\t\tint mid = (start + end) / 2;\n\t\tint lowerFound = 0;\n\t\tint higherFound = 0;\n\t\t\n\t\tint count = 0;\n\t\t\n\t\tfor (int i=start; i<end; i++){\n\t\t\tif (tab[i] < mid+1){\n\t\t\t\tcount += higherFound;\n\t\t\t\tauxTab[start+lowerFound] = tab[i];\n\t\t\t\tlowerFound++;\n\t\t\t} else {\n\t\t\t\tauxTab[mid + higherFound] = tab[i];\n\t\t\t\thigherFound++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=start; i<end; i++)\n\t\t\ttab[i] = auxTab[i];\n\t\t\n\t\tcount += _countInversions(tab, start, mid, auxTab);\n\t\tcount += _countInversions(tab, mid, end, auxTab);\n\t\t\n\t\treturn count;\n\t}\n\t\n\t\n\t\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1141f2_2 {\n\n    public static void main(String[] args) throws IOException {\n        int n = ri(), a[] = ria(n), pre[] = new int[n + 1];\n        for (int i = 0; i < n; ++i) {\n            pre[i + 1] = pre[i] + a[i];\n        }\n        Map<Integer, List<p>> sums = new HashMap<>();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= i; ++j) {\n                sums.computeIfAbsent(pre[i + 1] - pre[j], k -> new ArrayList<>()).add(new p(j, i));\n            }\n        }\n        int k = 0;\n        List<p> ans = new ArrayList<>();\n        for (int key : sums.keySet()) {\n            List<p> segs = sums.get(key);\n            segs.sort((x, y) -> x.b == y.b ? x.a - y.a : x.b - y.b);\n            int last = -1, cnt = 0;\n            for (int i = 0, end = segs.size(); i < end; ++i) {\n                if (segs.get(i).a > last) {\n                    ++cnt;\n                    last = segs.get(i).b;\n                }\n            }\n            if (cnt > k) {\n                k = cnt;\n                ans = segs;\n            }\n        }\n        prln(k);\n        int last = -1;\n        for (int i = 0, end = ans.size(); i < end; ++i) {\n            if (ans.get(i).a > last) {\n                prln(ans.get(i).a + 1, ans.get(i).b + 1);\n                last = ans.get(i).b;\n            }\n        }\n        close();\n    }\n\n    static class p {\n        int a, b;\n\n        p(int a_, int b_) {\n            a = a_;\n            b = b_;\n        }\n\n        @Override\n        public String toString() {\n            return \"Pair{\" + \"a = \" + a + \", b = \" + b + '}';\n        }\n\n\n        public boolean asymmetricEquals(Object o) {\n            p p = (p) o;\n            return a == p.a && b == p.b;\n        }\n\n        public boolean symmetricEquals(Object o) {\n            p p = (p) o;\n            return a == p.a && b == p.b || a == p.b && b == p.a;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return asymmetricEquals(o);\n        }\n\n        public int asymmetricHashCode() {\n            return Objects.hash(a, b);\n        }\n\n        public int symmetricHashCode() {\n            return Objects.hash(a, b) + Objects.hash(b, a);\n        }\n\n        @Override\n        public int hashCode() {\n            return asymmetricHashCode();\n        }\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // graph util\n    static List<List<Integer>> g(int n) {List<List<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new ArrayList<>()); return g;}\n    static List<Set<Integer>> sg(int n) {List<Set<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new HashSet<>()); return g;}\n    static void c(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v); g.get(v).add(u);}\n    static void cto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v);}\n    static void dc(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v); g.get(v).remove(u);}\n    static void dcto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    static List<List<Integer>> rg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<List<Integer>> rdg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rdsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(\"yes\");}\n    static void pry() {prln(\"Yes\");}\n    static void prY() {prln(\"YES\");}\n    static void prno() {prln(\"no\");}\n    static void prn() {prln(\"No\");}\n    static void prN() {prln(\"NO\");}\n    static void pryesno(boolean b) {prln(b ? \"yes\" : \"no\");};\n    static void pryn(boolean b) {prln(b ? \"Yes\" : \"No\");}\n    static void prYN(boolean b) {prln(b ? \"YES\" : \"NO\");}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(\"hlfd\"); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static PrintWriter pw;\n    static _Scanner sc;\n\n    public static void main(String[] args) throws Exception {\n        sc = new _Scanner(System.in);\n        pw = new PrintWriter(System.out);\n        //long startTime = System.currentTimeMillis();\n        //int t = sc.nextInt();\n        int t = 1;\n        while (t-- > 0) {\n            solve();\n        }\n        pw.flush();\n        //System.out.println(\"time: \" + (System.currentTimeMillis() - startTime));\n    }\n\n    private static void solve() throws Exception {\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n\n        int[][] h = new int[n][m - 1];\n        int[][] v = new int[n - 1][m];\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m - 1; ++j) {\n                h[i][j] = sc.nextInt();\n            }\n        }\n\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = 0; j < m; ++j) {\n                v[i][j] = sc.nextInt();\n            }\n        }\n\n        if (k % 2 == 1) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    if (j > 0) {\n                        pw.print(\" \");\n                    }\n                    pw.print(-1);\n                }\n                pw.println();\n            }\n            return;\n        }\n\n        k = k / 2;\n\n        long[][] d = new long[n][m];\n        for (int ki = 0; ki < k; ++ki) {\n            long[][] dk = new long[n][m];\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    long val = Integer.MAX_VALUE;\n\n                    if (j < m - 1) {\n                        val = Math.min(val, d[i][j + 1] + h[i][j]);\n                    }\n\n                    if (i < n - 1) {\n                        val = Math.min(val, d[i + 1][j] + v[i][j]);\n                    }\n\n                    if (j > 0) {\n                        val = Math.min(val, d[i][j - 1] + h[i][j - 1]);\n                    }\n\n                    if (i > 0) {\n                        val = Math.min(val, d[i - 1][j] + v[i - 1][j]);\n                    }\n\n                    dk[i][j] = val;\n                }\n            }\n            d = dk;\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (j > 0) {\n                    pw.print(\" \");\n                }\n                pw.print(d[i][j] * 2);\n            }\n            pw.println();\n        }\n    }\n\n    static class Shuffle {\n        static void run(int[] in) {\n            for (int i = 0; i < in.length; i++) {\n                int idx = (int) (Math.random() * in.length);\n                int tmp = in[i];\n                in[i] = in[idx];\n                in[idx] = tmp;\n            }\n        }\n\n        static void run(long[] in) {\n            for (int i = 0; i < in.length; i++) {\n                int idx = (int) (Math.random() * in.length);\n                long tmp = in[i];\n                in[i] = in[idx];\n                in[idx] = tmp;\n            }\n        }\n\n        static <T> void run(List<T> in) {\n            for (int i = 0; i < in.size(); i++) {\n                int idx = (int) (Math.random() * in.size());\n                T tmp = in.get(i);\n                in.set(i, in.get(idx));\n                in.set(idx, tmp);\n            }\n        }\n    }\n\n    static class _Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        _Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n        _Scanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n\n        String nextToken() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int[] intArr(int n) throws IOException {\n            int[] in = new int[n];\n            for (int i = 0; i < n; i++) in[i] = nextInt();\n            return in;\n        }\n\n        long[] longArr(int n) throws IOException {\n            long[] in = new long[n];\n            for (int i = 0; i < n; i++) in[i] = nextLong();\n            return in;\n        }\n\n        int[] intArrSorted(int n) throws IOException {\n            int[] in = new int[n];\n            for (int i = 0; i < n; i++) in[i] = nextInt();\n            Shuffle.run(in);\n            Arrays.sort(in);\n            return in;\n        }\n\n        long[] longArrSorted(int n) throws IOException {\n            long[] in = new long[n];\n            for (int i = 0; i < n; i++) in[i] = nextLong();\n            Shuffle.run(in);\n            Arrays.sort(in);\n            return in;\n        }\n\n        Integer[] IntegerArr(int n) throws IOException {\n            Integer[] in = new Integer[n];\n            for (int i = 0; i < n; i++) in[i] = nextInt();\n            return in;\n        }\n\n        Long[] LongArr(int n) throws IOException {\n            Long[] in = new Long[n];\n            for (int i = 0; i < n; i++) in[i] = nextLong();\n            return in;\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(nextToken());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(nextToken());\n        }\n\n        char nextChar() throws IOException {\n            return nextToken().charAt(0);\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(nextToken());\n        }\n\n        boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n    @author KhanhNguyenn\n */\n \npublic class C{\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(in, out);\n        out.close();\n    }\n    // main solver\n    // sub-problem: 2 orders to merge together x1,x2,..,xn and y1,y2,..,ym\n    // D\u1ef1a v\u00e0o b\u00e0i to\u00e1n chia k\u1eb9p Euler, ta ch\u1ee9ng minh dc s\u1ed1 c\u00e1ch merge l\u00e0\n    // (m+n)C(m-1)=(m+n)C(n+1)\n    static class Task{\n        int M;\n        public void solve(InputReader in, PrintWriter out) {\n            int n= in.nextInt(); M= in.nextInt();\n            if(n<=1){\n                out.println(n);\n                return;\n            }\n\n            // calculate nCk\n            // nCk= (n-1)C(k-1)+ (n-1)Ck\n            int[][] Ckn= new int[n+1][n+1];\n            for(int i=0;i<=n;i++){\n                Ckn[i][i]=1; Ckn[0][i]=1;\n                for(int j=i-1;j>=1;j--){\n                    Ckn[j][i]= add(Ckn[j-1][i-1],Ckn[j][i-1]);\n                }\n            }\n\n            int ans=0;\n            int[][] dp= new int[n+1][n+1];\n            dp[1][1]=1;\n            //dp[i][j]: number of ways to turn on first i , using j manually\n            for(int i=2;i<=n;i++){\n                dp[i][i]= mul(2,dp[i-1][i-1]);\n                for(int j=1;j<=i-1;j++){\n                    for(int k=1;k<=j;k++){\n                            dp[i][j]= add(dp[i][j],mul(mul(dp[k][k],dp[i-k-1][j-k]),Ckn[k][j])); \n                    }\n                }\n            }\n            for(int i=0;i<=n;i++) ans= add(ans,dp[n][i]);\n            out.println(ans);\n        }\n\n        public int add(int a, int b){\n            a+=b;\n            if(a>=M) a-=M;\n            return a;\n        }\n\n        public int mul(int a, int b){\n            long res= (long)a*(long)b;\n            res %=M;\n            return (int)res;\n        }\n        \n\n    }\n    static class Pair {\n        public String x;\n        public int y;\n        public Pair(String x, int y){\n            this.x = x;\n            this.y=y;\n        }\n \n        // @Override\n        // public int compareTo(Pair o) {\n        //     if (this.x > o.x){\n        //         return 1;\n        //     }\n        //     else if (this.x < o.x){\n        //         return -1;\n        //     }\n        //     else{\n        //         return Integer.compare(this.y, o.y);\n        //     }\n        // }\n    }\n    // fast input reader class;\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream));\n        }\n \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (line == null) {\n                    return null;\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(nextToken());\n        }\n        public long nextLong(){\n            return Long.parseLong(nextToken());\n        }\n    }\n}", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\n\n\npublic class cf35c {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tScanner in = new Scanner(new File(\"input.txt\"));\n\n\t\tPrintWriter out = new PrintWriter(new File(\"output.txt\"));\n\n\t\tint[] dx = {0,0,1,-1};\n\n\t\tint[] dy = {1,-1,0,0};\n\n\t\tint n = in.nextInt();\n\n\t\tint m = in.nextInt();\n\n\t\tint[][] seen = new int[n][m];\n\n\t\tfor(int i=0; i<n; i++)\n\n\t\t\tArrays.fill(seen[i], -1);\n\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\n\t\tint k = in.nextInt();\n\n\t\tfor(int i=0; i<k; i++) {\n\n\t\t\tint x = in.nextInt()-1;\n\n\t\t\tint y = in.nextInt()-1;\n\n\t\t\tq.add(x);\n\n\t\t\tq.add(y);\n\n\t\t\tq.add(0);\n\n\t\t\tseen[x][y] = 0;\n\n\t\t}\n\n\t\twhile(!q.isEmpty()) {\n\n\t\t\tint x = q.poll();\n\n\t\t\tint y = q.poll();\n\n\t\t\tint t = q.poll();\n\n\t\t\tfor(int i=0; i<dx.length; i++) {\n\n\t\t\t\tint nx = x + dx[i];\n\n\t\t\t\tint ny = y + dy[i];\n\n\t\t\t\tif(nx < 0 || nx >= n || ny < 0 || ny >= m)\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(seen[nx][ny] != -1) continue;\n\n\t\t\t\tseen[nx][ny] = t+1;\n\n\t\t\t\tq.add(nx);\n\n\t\t\t\tq.add(ny);\n\n\t\t\t\tq.add(t+1);\n\n\t\t\t}\n\n\t\t}\n\n\t\tint best=-1,x=0,y=0;\n\n\t\tfor(int i=0; i<n; i++)\n\n\t\t\tfor(int j=0; j<m; j++)\n\n\t\t\t\tif(seen[i][j] > best) {\n\n\t\t\t\t\tbest = seen[i][j];\n\n\t\t\t\t\tx = i+1;\n\n\t\t\t\t\ty = j+1;\n\n\t\t\t\t}\n\n\t\tout.println(x + \" \" +y);\n\n\t\tout.close();\n\n\t}\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "// Author : RegalBeast\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n  static final FastReader FR = new FastReader();\n  static final PrintWriter PW = new PrintWriter(new OutputStreamWriter(System.out));\n\n  public static void main(String[] args) {\n    StringBuilder solution = new StringBuilder();\n    int rows = FR.nextInt();\n    int cols = FR.nextInt();\n    int moves = FR.nextInt();\n\n    List<List<Integer>> horizontalEdgeWeights = new ArrayList<List<Integer>>(rows);\n    for (int r = 0; r < rows; r++) {\n      horizontalEdgeWeights.add(new ArrayList<Integer>(cols-1));\n\n      for (int c = 0; c < cols - 1; c++) {\n        horizontalEdgeWeights.get(r).add(FR.nextInt());\n      }\n    }\n\n    List<List<Integer>> verticalEdgeWeights = new ArrayList<List<Integer>>(rows-1);\n    for (int r = 0; r < rows - 1; r++) {\n      verticalEdgeWeights.add(new ArrayList<Integer>(cols));\n\n      for (int c = 0; c < cols; c++) {\n        verticalEdgeWeights.get(r).add(FR.nextInt());\n      }\n    }\n    \n    List<List<Integer>> result = getResult(rows, cols, moves, horizontalEdgeWeights, verticalEdgeWeights);\n    for (int r = 0; r < rows; r++) {\n      for (int c = 0; c < cols; c++) {\n        int value = (result != null ? result.get(r).get(c) : -1);\n        solution.append(value + \" \");\n      }\n      solution.append(\"\\n\");\n    }\n\n\t\tPW.print(solution.toString());\n    PW.close();\n  }\n\n  static List<List<Integer>> getResult(int rows, int cols, int moves, List<List<Integer>> horizontalEdgeWeights, List<List<Integer>> verticalEdgeWeights) {\n    if ((moves & 1) == 1) {\n      return null;\n    }\n\n    int mid = moves >> 1;\n    List<List<List<Integer>>> minForDistance = new ArrayList<List<List<Integer>>>(rows);\n    for (int r = 0; r < rows; r++) {\n      minForDistance.add(new ArrayList<List<Integer>>(cols));\n\n      for (int c = 0; c < cols; c++) {\n        minForDistance.get(r).add(new ArrayList<Integer>(Collections.nCopies(mid+1, Integer.MAX_VALUE)));\n        minForDistance.get(r).get(c).set(0, 0);\n      }\n    }\n\n    for (int m = 1; m <= mid; m++) {\n      for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n          int minBoredom = minForDistance.get(r).get(c).get(m);\n\n          if (r > 0) {\n            if (minForDistance.get(r-1).get(c).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r-1).get(c).get(m-1) + verticalEdgeWeights.get(r-1).get(c);\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n\n          if (c > 0) {\n            if (minForDistance.get(r).get(c-1).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r).get(c-1).get(m-1) + horizontalEdgeWeights.get(r).get(c-1);\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n          \n          if (r + 1 < rows) {\n            if (minForDistance.get(r+1).get(c).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r+1).get(c).get(m-1) + verticalEdgeWeights.get(r).get(c);\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n   \n          if (c + 1 < cols) {\n            if (minForDistance.get(r).get(c+1).get(m-1) < Integer.MAX_VALUE) {\n              int candidateBoredom = minForDistance.get(r).get(c+1).get(m-1) + horizontalEdgeWeights.get(r).get(c);\n              minBoredom = Math.min(minBoredom, candidateBoredom);\n            }\n          }\n\n          minForDistance.get(r).get(c).set(m, minBoredom);\n        }\n      }\n    }\n\n    List<List<Integer>> result = new ArrayList<List<Integer>>(rows);\n    for (int r = 0; r < rows; r++) {\n      result.add(new ArrayList<Integer>(cols));\n\n      for (int c = 0; c < cols; c++) {\n        result.get(r).add(minForDistance.get(r).get(c).get(mid) << 1);\n      }\n    }\n\n    return result;\n  }\n\n  static class FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n      br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n      while (st == null || !st.hasMoreElements()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        } catch (IOException  e) {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n      String str = \"\";\n      try {\n        str = br.readLine();\n      } catch (IOException e)  {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\nimport java.lang.reflect.*;\nimport java.util.*;\n\npublic class B {\n\n\tfinal int MOD = (int)1e9 + 7;\n\tfinal double eps = 1e-12;\n\tfinal int INF = (int)1e9;\n\t\n\tpublic B () {\n\t\tlong N = sc.nextInt();\n\t\tlong X = sc.nextInt() - 1;\n\t\tlong Y = sc.nextInt() - 1;\n\t\tlong C = sc.nextInt();\n\n\t\tlong [] A1 = new long [] { X, Y };\n\t\tlong [] A2 = new long [] { X, Y };\n\t\tlong [] B1 = new long [] { X, Y };\n\t\tlong [] B2 = new long [] { X, Y };\n\t\tlong [] C1 = new long [] { X, Y };\n\t\tlong [] C2 = new long [] { X, Y };\n\t\tlong [] D1 = new long [] { X, Y };\n\t\tlong [] D2 = new long [] { X, Y };\n\t\t\n\t\tlong cnt = 1, T = 0;\n\t\t\n\t\twhile (cnt < C) {\n\t\t\tif (A1[0] > 0) --A1[0]; else --A1[1];\n\t\t\tif (A2[0] > 0) --A2[0]; else ++A2[1];\n\t\t\t\n\t\t\tif (B1[1] > 0) --B1[1]; else --B1[0];\n\t\t\tif (B2[1] > 0) --B2[1]; else ++B2[0];\n\t\t\t\n\t\t\tif (C1[0] < N-1) ++C1[0]; else --C1[1];\n\t\t\tif (C2[0] < N-1) ++C2[0]; else ++C2[1];\n\t\t\t\n\t\t\tif (D1[1] < N-1) ++D1[1]; else --D1[0];\n\t\t\tif (D2[1] < N-1) ++D2[1]; else ++D2[0];\n\t\t\t\t\t\t\n\t\t\tlong [] Z = { B1[0] - A1[0],\n\t\t\t\t\t\t  C1[0] - B2[0],\n\t\t\t\t\t\t  C2[0] - D2[0],\n\t\t\t\t\t\t  D1[0] - A2[0] };\n\t\t\t\n\t\t\tfor (long z : Z)\n\t\t\t\tif (z >= 0)\n\t\t\t\t\tcnt += (z+1);\n\t\t\t\n\t\t\tif (Arrays.equals(A1, A2)) --cnt;\n\t\t\tif (Arrays.equals(B1, B2)) --cnt;\n\t\t\tif (Arrays.equals(C1, C2)) --cnt;\n\t\t\tif (Arrays.equals(D1, D2)) --cnt;\n\t\t\t\n\t\t\t++T;\n\t\t}\n\t\t\n\t\texit(T);\n\t}\n\n\t////////////////////////////////////////////////////////////////////////////////////\n\t\n\tstatic MyScanner sc;\n\t\n\tstatic class MyScanner {\n\t\tpublic String next() {\n\t\t\tnewLine();\n\t\t\treturn line[index++];\n\t\t}\n\t\t\n\t\tpublic char nextChar() {\n\t\t\treturn next().charAt(0);\n\t\t}\n\t\t\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic String nextLine() {\n\t\t\tline = null;\n\t\t\treturn readLine();\n\t\t}\n\t\t\n\t\tpublic String [] nextStrings() {\n\t\t\tline = null;\n\t\t\treturn readLine().split(\" \");\n\t\t}\n\t\t\n\t\tpublic char [] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic Integer [] nextInts() {\n\t\t\tString [] L = nextStrings();\n\t\t\tInteger [] res = new Integer [L.length];\n\t\t\tfor (int i = 0; i < L.length; ++i)\n\t\t\t\tres[i] = Integer.parseInt(L[i]);\n\t\t\treturn res;\n\t\t}\t\n\t\t\n\t\tpublic Long [] nextLongs() {\n\t\t\tString [] L = nextStrings();\n\t\t\tLong [] res = new Long [L.length];\n\t\t\tfor (int i = 0; i < L.length; ++i)\n\t\t\t\tres[i] = Long.parseLong(L[i]);\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic Double [] nextDoubles() {\n\t\t\tString [] L = nextStrings();\n\t\t\tDouble [] res = new Double [L.length];\n\t\t\tfor (int i = 0; i < L.length; ++i)\n\t\t\t\tres[i] = Double.parseDouble(L[i]);\n\t\t\treturn res;\n\t\t}\n\n\t\t//////////////////////////////////////////////\n\t\t\n\t\tprivate boolean eol() {\n\t\t\treturn index == line.length;\n\t\t}\n\n\t\tprivate String readLine() {\n\t\t\ttry {\n\t\t\t\treturn r.readLine();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\n\t\tprivate final BufferedReader r;\n\n\t\tMyScanner () {\n\t\t\tthis(new BufferedReader(new InputStreamReader(System.in)));\n\t\t}\n\t\t\n\t\tMyScanner(BufferedReader r) {\n\t\t\ttry {\n\t\t\t\tthis.r = r;\n\t\t\t\twhile (!r.ready())\n\t\t\t\t\tThread.sleep(1);\n\t\t\t\tstart();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate String [] line;\n\t\tprivate int index;\n\n\t\tprivate void newLine() {\n\t\t\tif (line == null || eol()) {\n\t\t\t\tline = readLine().split(\" \");\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\tstatic void print (Object o, Object... a) {\n\t\tpw.println(build(o, a));\n\t}\n\n\tstatic void exit (Object o, Object... a) {\n\t\tprint(o, a);\n\t\texit();\n\t}\n\n\tstatic void exit () {\n\t\tpw.close();\n\t\tSystem.out.flush();\n\t\tSystem.err.println(\"------------------\");\n\t\tSystem.err.println(\"Time: \" + ((millis() - t) / 1000.0));\n\t\tSystem.exit(0);\n\t}\n\t\n\tvoid NO() {\n\t\tthrow new Error(\"NO!\");\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////////\n\t\n\tstatic String build(Object... a) {\n\t\tStringBuilder b = new StringBuilder();\n\t\tfor (Object o : a)\n\t\t\tappend(b, o);\n\t\treturn b.toString().trim();\t\t\n\t}\n\t\n\tstatic void append(StringBuilder b, Object o) {\n\t\tif (o.getClass().isArray()) {\n\t\t\tint L = Array.getLength(o);\n\t\t\tfor (int i = 0; i < L; ++i)\n\t\t\t\tappend(b, Array.get(o, i));\n\t\t} else if (o instanceof Iterable<?>) {\n\t\t\tfor (Object p : (Iterable<?>)o)\n\t\t\t\tappend(b, p);\n\t\t} else\n\t\t\tb.append(\" \").append(o);\t\t\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////////\n\t\n\tpublic static void main(String[] args) {\n\t\tsc = new MyScanner ();\n\t\tnew B();\n\t\texit();\n\t}\n\n\tstatic void start() {\n\t\tt = millis();\n\t}\n\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n\t\n\tstatic long t;\n\t\n\tstatic long millis() {\n\t\treturn System.currentTimeMillis();\n\t}\t\n}\n", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "///package round_global_14;\n\n\nimport java.io.*;\nimport java.util.*;\n\npublic class B {\n    static class InputReader {\n        BufferedReader buffreader;\n        StringTokenizer strtokenizer;\n        public InputReader(InputStream inputstr) {\n            buffreader = new BufferedReader(new InputStreamReader(inputstr), 1000000);strtokenizer = null; }\n        //////////////////////////////////////////////////////////////////////////////////////////\n        String next() {\n            while (strtokenizer == null || !strtokenizer.hasMoreTokens()) {\n                try { strtokenizer = new StringTokenizer(buffreader.readLine()); }\n                catch (IOException e) { throw new RuntimeException(e); }\n            }\n            return strtokenizer.nextToken(); }\n        ///////////////////////////////////////////////////////////////////////////////////////////\n        public int nextInt() { return Integer.parseInt(next()); }\n        public long nextLong() { return Long.parseLong(next()); }\n        public double nextDouble() { return Double.parseDouble(next()); }\n        public int[] nextIntArr(int n){\n            int[] arr=new int[n];\n            for (int i=0;i<n;i++){arr[i]=nextInt();}\n            return arr;}\n        public long[] nextLongArr(int n){\n            long[] arr=new long[n];\n            for (int i=0;i<n;i++){arr[i]=nextLong();}\n            return arr;}\n        public String[] nextStringArr(int n){\n            String[] arr=new String[n];\n            for (int i=0;i<n;i++){arr[i]=next();}\n            return arr;}\n    }\n    static InputReader r = new InputReader(System.in);\n    static PrintWriter pw = new PrintWriter(System.out);\n    public static void main(String[] args){\n        int t=r.nextInt();\n        for (int v=0;v<t;v++){\n            int n=r.nextInt();\n            if (n%2==1){\n                pw.println(\"NO\");\n            }\n            else{\n                int x=n/2;\n                boolean check=false;\n                for (int i=1;i<=(int)Math.sqrt(x)+1;i++){\n                    if (i*i*2==x||i*i==x){\n                        pw.println(\"YES\");check=true;break;\n                    }\n                }\n                if (!check){\n                    pw.println(\"NO\");\n                }\n            }\n\n\n        }\n        pw.close();\n\n\n    }\n}\n", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n\tstatic boolean visited[] ; \n\tstatic boolean ends[] ;\n\tstatic long mod = 1000000007 ;\n\tstatic int lens[] ; \n\tstatic int seeds[] ; \n\tstatic int a[] ;\n\tstatic double total ; \n\tpublic static ArrayList adj[] ; \n\tpublic static long x,y ;\n\tpublic static ArrayList<Long> xx ;\t\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tScanner sc =  new Scanner(System.in) ;\n\n\t\tlong x = sc.nextLong() ; \n\t\tlong k = sc.nextLong() ; \n\t\tif(x==0)\n\t\t{System.out.println(0); return ;}\n\t\tif(k==0)\n\t\t{System.out.println((2l*x)%mod);return ;}\t\n\n\n\t\tlong m=pow(2,k);\n\n\n\t\tlong a = 2l*(x%mod)*(m%mod);\n\n\n\t\ta = a-m+1 ;\n\n\t\ta=a%mod ; \n\t\tif(a<0)a=(a%mod + mod) % mod;\n\n\t\tSystem.out.println(a);\n\n\n\n\n\n\t}\n\n\t// method to print the divisors\n\tstatic ArrayList<Long> divisors(long n)\n\t{\n\t\tArrayList<Long> arr =  new ArrayList<Long>() ; \n\t\t// Note that this loop runs till square root\n\t\tfor (int i=1; i<=Math.sqrt(n); i++)\n\t\t{\n\t\t\tif (n%i==0)\n\n\t\t\t\t// If divisors are equal, print only one\n\t\t\t\tif (n/i == i)\n\t\t\t\t{arr.add(1l*i);arr.add(1l*i);}\n\n\t\t\t\telse // Otherwise print both\n\t\t\t\t{arr.add(1l*i); arr.add(1l*n/i);}\n\n\t\t}\t\n\n\t\treturn arr ;\n\n\t}\n\n\tpublic static void generate(long current)\n\t{\n\t\tif(current>10000000000l)\n\t\t\treturn ; \n\n\t\txx.add(current) ; \n\t\tgenerate((10*current) +4); \n\t\tgenerate((10*current) +7);\n\n\n\t}\n\n\tpublic static int neededFromLeft(String x)\n\t{\n\t\tStack<Character> st = new Stack<Character>() ; \n\t\tint c=0;\n\n\t\tfor (int i = 0; i < x.length(); i++)\n\t\t{\n\t\t\tchar cur = x.charAt(i); \n\t\t\tif(cur==')' && st.isEmpty())\n\t\t\t\tc ++; \n\t\t\telse if(cur==')' && !st.isEmpty())\n\t\t\t\tst.pop();\n\t\t\telse if(cur=='(')\n\t\t\t\tst.push(cur);\n\t\t}\n\t\treturn c;\n\t}\n\n\tpublic static int neededFromRight(String x)\n\t{\n\t\tStack<Character> st = new Stack<Character>() ; \n\t\tint c=0;\n\t\tboolean f=true; \n\t\tfor (int i = 0; i < x.length(); i++)\n\t\t{\n\t\t\tchar cur = x.charAt(i); \n\t\t\tif(cur==')' && st.isEmpty())\n\t\t\t\tf=false;  \n\t\t\telse if(cur==')' && !st.isEmpty())\n\t\t\t\tst.pop();\n\t\t\telse if(cur=='(')\n\t\t\t\tst.push(cur);\n\t\t}\n\t\treturn st.size(); \n\t}\n\n\tpublic static boolean fromBoth(String x)\n\t{\n\t\tStack<Character> st = new Stack<Character>() ;\n\t\tboolean f1=true ,f2=true ; \n\n\t\tfor (int i = 0; i < x.length(); i++)\n\t\t{\n\t\t\tchar cur = x.charAt(i); \n\t\t\tif(cur==')' && st.isEmpty())\n\t\t\t\tf1 =false ; \n\t\t\telse if(cur==')' && !st.isEmpty())\n\t\t\t\tst.pop();\n\t\t\telse if(cur=='(')\n\t\t\t\tst.push(cur);\n\t\t}\n\t\tif(st.size()>0)f2 = false ;\n\n\t\tif(f1==false && f2==false)\n\t\t\treturn true ; \n\t\telse \n\t\t\treturn false;\n\t}\n\n\tpublic static boolean isRegular(String x)\n\t{\n\t\tStack<Character> st = new Stack<Character>() ; \n\t\tfor (int i = 0; i < x.length(); i++)\n\t\t{\n\t\t\tchar cur = x.charAt(i); \n\t\t\tif(cur==')' && st.isEmpty())\n\t\t\t\treturn false ; \n\t\t\telse if(cur==')' && !st.isEmpty())\n\t\t\t\tst.pop();\n\t\t\telse if(cur=='(')\n\t\t\t\tst.push(cur);\n\t\t}\n\t\tif(st.size()>0)return false ; else return true ;\n\t}\n\n\n\tpublic static int gcdExtended(int a, int b)\n\t{\n\t\t// Base Case\n\t\tif (a == 0)\n\t\t{\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn b;\n\t\t}\n\n\t\t//int x1=1, y1=1; // To store results of recursive call\n\t\tint gcd = gcdExtended(b%a, a);\n\n\t\t// Update x and y using results of recursive\n\t\t// call\n\t\tlong x1 = y - (b/a) * x;\n\t\tlong y1 = x;\n\t\tx = x1 ; \n\t\ty = y1 ;\n\n\t\treturn gcd;\n\t}\n\n\n\n\n\n\n\n\n\n\tstatic int even(String x , int b )\n\t{\n\t\tfor (int j = b; j>=0; j--)\n\t\t{\n\t\t\tint current = x.charAt(j)-48 ; \n\t\t\tif(current%2==0)\n\t\t\t\treturn current ; \n\t\t}\n\t\treturn -1;\n\t}\n\tstatic int odd(String x , int b )\n\t{\n\t\tfor (int j = b; j>=0; j--)\n\t\t{\n\t\t\tint current = x.charAt(j)-48 ; \n\t\t\tif(current%2!=0)\n\t\t\t\treturn current ; \n\t\t}\n\t\treturn -1;\n\t}\n\tstatic long pow(long base, long k) {\n\t\tlong res = 1;\n\t\twhile(k > 0) {\n\t\t\tif(k % 2 == 1) {\n\t\t\t\tres = (res * base) % mod;\n\t\t\t}\n\n\t\t\tbase = (base * base) % mod;\n\t\t\tk /= 2;\n\t\t}\n\n\t\treturn res;\n\t}\n\tpublic static long solve(int k1, long k2)\n\t{\n\t\tlong x   = 1l*k2*(pow(2, k1)-1) ;\n\t\treturn x%(1000000007) ; \n\t}\n\n\n\tpublic static long getN(long x)\n\t{\n\t\tlong n = (long) Math.sqrt(x*2) ; \n\t\tlong y = n*(n+1)/2; \n\t\tif(y==x)\n\t\t\treturn n ; \n\t\telse if(y>x)\n\t\t\treturn n ; \n\t\telse\n\t\t\tfor (long i = n; ; i++)\n\t\t\t{\n\t\t\t\ty = i*(i+1)/2 ; \n\t\t\t\tif(y>=x)\n\t\t\t\t\treturn i ; \n\n\n\t\t\t}\t}\n\n\n\n\n\n\n\n\n\tpublic static void dfss(int root , int len)\n\t{\n\t\tvisited[root]=true ; \n\t\tif(ends[root] && root!=0) lens[root] = len ; \n\n\t\tfor (int i = 0; i < adj[root].size(); i++)\n\t\t{\n\t\t\tint c= (int) adj[root].get(i) ; \n\t\t\tif(visited[c]==false)\n\t\t\t\tdfss(c, len+1);\n\t\t}\n\t}\n\n\tpublic static void pr(int root ,  int seed){\n\t\tvisited[root] = true ;\n\t\tint dv = adj[root].size()-1 ; \n\t\tif(root==0) dv++ ;\n\n\t\tfor (int i = 0; i < adj[root].size(); i++)\n\t\t{\n\t\t\tint c = (int)adj[root].get(i) ; \n\t\t\tseeds[c]=dv*seed ;\n\t\t}\n\n\t\tfor (int i = 0; i < adj[root].size() ; i++)\n\t\t{\n\t\t\tint c = (int)adj[root].get(i) ; \n\t\t\tif(visited[c]==false)\n\t\t\t\tpr(c , seeds[c]);\n\n\t\t}\n\n\t}\n\n\n\tpublic static String concatinate(String s ,int n)\n\t{\n\t\tif(s.length()==n)\n\t\t\treturn s ; \n\t\telse return concatinate(\"0\"+s, n) ;\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n\n\tpublic static long getGCD(long n1, long n2) {\n\t\tif (n2 == 0) {\n\t\t\treturn n1;\n\t\t}\n\t\treturn getGCD(n2, n1 % n2);\n\t}\n\n\tpublic static int cnt1(int mat[][])  //how many swaps to be a 1 matrix\n\t{\n\t\tint m = mat.length ; \n\t\tint c=0 ; \n\t\tfor (int i = 0; i < mat.length; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < mat.length; j++)\n\t\t\t{\n\t\t\t\tint x =  (i*m) +j ;\n\t\t\t\tif(x%2==0 && mat[i][j]==0)\n\t\t\t\t\tc++; \n\t\t\t\tif(x%2!=0 && mat[i][j]==1)\n\t\t\t\t\tc++; \n\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tpublic static int cnt0(int mat[][])\n\t{\n\t\tint m = mat.length ; \n\t\tint c=0 ; \n\t\tfor (int i = 0; i < mat.length; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < mat.length; j++)\n\t\t\t{\n\t\t\t\tint x =  (i*m) +j ; \n\t\t\t\tif(x%2!=0 && mat[i][j]==0)\n\t\t\t\t\tc++; \n\t\t\t\tif(x%2==0 && mat[i][j]==1)\n\t\t\t\t\tc++; \n\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\n\tpublic static boolean canFit2(int x1, int y1 , int x2 , int y2 , int x3 , int y3){\n\t\tif(x1==x2)\n\t\t\tif(x1==x3)\n\t\t\t\treturn true ; \n\t\t\telse\n\t\t\t\treturn false ;\n\t\telse\n\t\t\tif(x1==x3)\n\t\t\t\treturn false ; \n\t\t\telse\n\t\t\t{\n\t\t\t\tlong a = 1l*(y2-y1)*(x3-x2) ; \n\t\t\t\tlong b = 1l*(y3-y2)*(x2-x1) ; \n\n\t\t\t\tif(a==b)\n\t\t\t\t\treturn true;\n\t\t\t\telse \n\t\t\t\t\treturn false ;\n\n\t\t\t}\n\n\t}\n\tpublic static void shuffle(pair[] ss){\n\t\tif(ss.length==1)\n\t\t\treturn ; \n\t\tfor (int i = 0; i < ss.length; i++)\n\t\t{\n\t\t\tRandom rand = new Random();\n\n\t\t\tint  n = rand.nextInt(ss.length-1) + 0;\n\n\t\t\tpair temp = ss[i] ; \n\t\t\tss[i] = ss[n] ; \n\t\t\tss[n] = temp ;\n\t\t}\n\t}\n\tpublic static int binary(ArrayList<pair> arr, int l, int r, long x)   /// begin by 0 and n-1\n\t{\n\t\tif (r>=l)\n\t\t{\n\t\t\tint mid = l + (r - l)/2;\n\t\t\tif (arr.get(mid).x== x)\n\t\t\t\treturn mid;\n\t\t\tif (arr.get(mid).x> x)\n\t\t\t\treturn binary(arr, l, mid-1, x);\n\t\t\treturn binary(arr, mid+1, r, x);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/// searching for the index of first elment greater than x\n\tpublic static int binary1(int[]arr , int x) {\n\t\tint low = 0, high = arr.length; // numElems is the size of the array i.e arr.size() \n\t\twhile (low != high) {\n\t\t\tint mid = (low + high) / 2; // Or a fancy way to avoid int overflow\n\t\t\tif (arr[mid] <= x) {\n\t\t\t\t/* This index, and everything below it, must not be the first element\n\t\t\t\t * greater than what we're looking for because this element is no greater\n\t\t\t\t * than the element.\n\t\t\t\t */\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* This element is at least as large as the element, so anything after it can't\n\t\t\t\t * be the first element that's at least as large.\n\t\t\t\t */\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\t\treturn low ; // return high ; \n\t}\n\n\n\t////// searching for last element less than X \n\tpublic static int binary2(pair[]arr , int x) {\n\t\tint low = 0, high = arr.length; // numElems is the size of the array i.e arr.size() \n\t\twhile (low != high) {\n\t\t\tint mid = (low + high) / 2; // Or a fancy way to avoid int overflow\n\t\t\tif (arr[mid].x >= x) {\n\t\t\t\t/* This index, and everything below it, must not be the first element\n\t\t\t\t * greater than what we're looking for because this element is no greater\n\t\t\t\t * than the element.\n\t\t\t\t */\n\t\t\t\thigh=mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* This element is at least as large as the element, so anything after it can't\n\t\t\t\t * be the first element that's at least as large.\n\t\t\t\t */\n\t\t\t\tlow = mid+1 ; \n\t\t\t}\n\t\t}\n\t\treturn low ; // return high ; \n\t}\n\n\n\tprivate static boolean triangle(int a, int b , int c){\n\t\tif(a+b>c && a+c>b && b+c>a)\n\t\t\treturn true ; \n\t\telse \n\t\t\treturn false ;\n\t}\n\tprivate static boolean segment(int a, int b , int c){\n\t\tif(a+b==c || a+c==b && b+c==a)\n\t\t\treturn true ; \n\t\telse \n\t\t\treturn false ;\n\t}\n\tprivate static int gcdThing(long a, long b) {\n\t\tBigInteger b1 = BigInteger.valueOf(a);\n\t\tBigInteger b2 = BigInteger.valueOf(b);\n\t\tBigInteger gcd = b1.gcd(b2);\n\t\treturn gcd.intValue();\n\t}\n\n\tpublic static boolean is(int i){\n\t\tif(Math.log(i)/ Math.log(2) ==(int) (Math.log(i)/ Math.log(2)))\n\t\t\treturn true ; \n\t\tif(Math.log(i)/ Math.log(3) ==(int) (Math.log(i)/ Math.log(3)) )\n\t\t\treturn true ; \n\t\tif(Math.log(i)/ Math.log(6) ==(int) (Math.log(i)/ Math.log(6)) )\n\t\t\treturn true ; \n\n\t\treturn false;\n\n\t}\n\tpublic static boolean contains(int b[] , int x)\n\t{\n\t\tfor (int i = 0; i < b.length; i++)\n\t\t{\n\t\t\tif(b[i]==x)\n\t\t\t\treturn true ;\n\t\t}\n\t\treturn false ;\n\t}\n\tpublic static int binary(long []arr , long target , int low , long shift) {\n\t\tint high = arr.length; \n\t\twhile (low != high) {\n\t\t\tint mid = (low + high) / 2; \n\t\t\tif (arr[mid]-shift <= target) {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\t\treturn low ; // return high ; \n\t}\n\tpublic static boolean isLetter(char x){\n\t\tif(x+0 <=122 && x+0 >=97 )\n\t\t\treturn true ;\n\t\telse if (x+0 <=90 && x+0 >=65 )\n\t\t\treturn true ; \n\t\telse return false; \n\t}\n\tpublic static long getPrimes(long x ){\n\t\tif(x==2 || x==3 || x==1)\n\t\t\treturn 2 ;\n\t\tif(isPrime(x))\n\t\t\treturn 5 ;\n\t\tfor (int i = 2; i*i<=x; i++)\n\t\t{\n\t\t\tif(x%i==0 && isPrime(i))\n\t\t\t\treturn getPrimes(x/i) ;\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static String solve11(String x){\n\n\t\tint n = x.length() ; \n\t\tString y = \"\" ;\n\t\tfor (int i = 0; i < n-2; i+=2)\n\t\t{\n\t\t\tif(ifPalindrome(x.substring(i, i+2)))\n\t\t\t\ty+= x.substring(i, i+2) ;\n\t\t\telse \n\t\t\t\tbreak ;\n\t\t}\n\t\treturn y+ solve11(x.substring(y.length(),x.length())) ;\n\n\t}\n\tpublic static String solve1(String x){\n\t\tString y = x.substring(0 , x.length()/2) ; \n\t\treturn \"\" ;\n\n\t}\n\tpublic static String reverse(String x){\n\t\tString y =\"\" ;\n\t\tfor (int i = 0; i < x.length(); i++)\n\t\t{\n\t\t\ty  = x.charAt(i) + y ;\n\t\t}\n\t\treturn y ;\n\t}\n\n\tpublic static boolean ifPalindrome(String x){\n\t\tint numbers[] = new int[10] ; \n\t\tfor (int i = 0; i < x.length(); i++)\n\t\t{\n\t\t\tint z = Integer.parseInt(x.charAt(i)+\"\") ; \n\t\t\tnumbers[z] ++ ;\n\t\t}\n\t\tfor (int i = 0; i < numbers.length; i++)\n\t\t{\n\t\t\tif(numbers[i]%2!=0)\n\t\t\t\treturn false; \n\t\t}\n\t\treturn true ;\t\n\t}\n\n\tpublic static int get(int n){\n\t\treturn n*(n+1)/2 ; \n\t}\n\t//\t\tpublic static long getSmallestDivisor( long y){\n\t//\t\t\tif(isPrime(y))\n\t//\t\t\t\treturn -1;\n\t//\n\t//\t\t\tfor (long i = 2; i*i <= y; i++)\n\t//\t\t\t{\n\t//\t\t\t\tif(y%i ==0)\n\t//\t\t\t\t{\n\t//\t\t\t\t\treturn i;\n\t//\t\t\t\t}\n\t//\t\t\t}\n\t//\t\t\treturn -1;\n\t//\t\t}\n\tpublic static int lis( int[]a , int n){\n\t\tint lis[] = new int[n] ; \n\t\tArrays.fill(lis,1) ; \n\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(int j=0 ; j<i; j++)\n\t\t\t\tif (a[i]>a[j] &&  lis[i] < lis[j]+1)   \n\t\t\t\t\tlis[i] = lis[j] + 1;           \n\n\t\tint max = lis[0];\n\n\t\tfor(int i=1; i<n ; i++)\n\t\t\tif (max < lis[i])\n\t\t\t\tmax = lis[i] ;\n\t\treturn (max);\n\n\t\t//\t\t\tArrayList<Integer> s = new ArrayList<Integer>() ;\n\t\t//\t\t\tfor (int i = n-1; i >=0; i--)\n\t\t//\t\t\t{\n\t\t//\t\t\t\tif(lis[i]==max)\n\t\t//\t\t\t\t{\n\t\t//\t\t\t\t\ts.add(a[i].z);\n\t\t//\t\t\t\t\tmax --; \n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\n\t\t//\t\t\tfor (int i = s.size()-1 ; i>=0 ;  i--)\n\t\t//\t\t\t{\n\t\t//\t\t\t\tSystem.out.print(s.get(i)+\" \");\n\t\t//\t\t\t}\n\t\t//\n\t}\n\tpublic static int calcDepth(Vertix node){\n\t\tif(node.depth>0) return node.depth; \n\t\t// meaning it has been updated before;\n\t\tif(node.parent != null)\n\t\t\treturn 1+ calcDepth(node.parent);\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tpublic static boolean isPrime (long num){\n\t\tif (num < 2) return false;\n\t\tif (num == 2) return true;\n\t\tif (num % 2 == 0) return false;\n\t\tfor (int i = 3; i * i <= num; i += 2)\n\t\t\tif (num % i == 0) return false;\n\t\treturn true;\n\t}\n\n\n\tpublic static ArrayList<Long> getDiv(Long n)\n\t{\n\t\tArrayList<Long>  f = new ArrayList<Long>() ; \n\n\t\twhile (n%2==0)\n\t\t{\n\t\t\tif(!f.contains(2))f.add((long) 2) ;\n\t\t\tn /= 2;\n\t\t}\n\n\t\t// n must be odd at this point.  So we can\n\t\t// skip one element (Note i = i +2)\n\t\tfor (long i = 3; i <= Math.sqrt(n); i+= 2)\n\t\t{\n\t\t\t// While i divides n, print i and divide n\n\t\t\twhile (n%i == 0)\n\t\t\t{\n\t\t\t\tif(!f.contains(i))f.add(i);\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t}\n\n\t\t// This condition is to handle the case whien\n\t\t// n is a prime number greater than 2\n\t\tif (n > 2)\n\t\t\tif(!f.contains(n))f.add(n);\n\n\n\t\treturn f ;\n\n\n\n\t}\n\n\t//\t\tpublic static boolean dfs(Vertix v , int target){\n\t//\t\t\ttry{\n\t//\t\t\t\tvisited[v.i]= true ;\n\t//\t\t\t} catch (NullPointerException e)\n\t//\t\t\t{\n\t//\t\t\t\tSystem.out.println(v.i);\n\t//\t\t\t}\n\t//\t\t\tif(v.i == target)\n\t//\n\t//\t\t\t\treturn true ;\n\t//\t\t\tfor (int i =0 ; i< v.neighbours.size() ; i++)\n\t//\t\t\t{ \n\t//\n\t//\t\t\t\tVertix child = v.neighbours.get(i) ;\n\t//\t\t\t\tif(child.i == target){\n\t//\t\t\t\t\tfound = true  ; \n\t//\t\t\t\t}\n\t//\t\t\t\tif(visited[child.i]==false){\n\t//\t\t\t\t\tfound |= dfs(child, target) ;\n\t//\t\t\t\t}\n\t//\t\t\t}\n\t//\t\t\treturn found; \n\t//\t\t}\n\n\n\n\n\n\n\n\n\n\tpublic static class Vertix{\n\t\tlong i ; \n\t\tint depth ;\n\t\tArrayList<Vertix> neighbours ; \n\t\tVertix parent ; \n\t\tVertix child ; \n\n\n\t\tpublic Vertix(long i){\n\t\t\tthis.i = i ;\n\t\t\tthis.neighbours = new ArrayList<Vertix> () ;\n\t\t\tthis.parent = null ;\n\t\t\tdepth =-1;\n\t\t\tthis.child = null ;\n\t\t}\n\t}\n\n\tpublic static class pair implements Comparable<pair> {\n\t\tint x ;\n\t\tint y ;\n\t\tint i;\n\n\n\n\n\t\tpublic pair(int x, int y, int i ){\n\n\t\t\tthis.x=x ; \n\t\t\tthis.y =y ;\n\t\t\tthis.i =i ;\n\n\n\t\t}\n\n\n\t\t@Override\n\t\tpublic int compareTo(pair p) {\n\t\t\tif(this.x > p.x)\n\t\t\t\treturn 1 ; \n\t\t\telse if (this.x == p.x) \n\t\t\t\treturn 0 ; \n\t\t\telse \n\t\t\t\treturn -1 ;\n\t\t}\n\n\n\n\n\t}\n\n\tpublic static class pair2 implements Comparable<pair2>{\n\t\tint i ; \n\t\tint j ;\n\t\tint plus ;\n\n\t\tpublic pair2(int i , int j , int plus){\n\t\t\tthis.i =i ;\n\t\t\tthis.j = j ; \n\t\t\tthis.plus = plus ;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair2 p) {\n\t\t\tif(this.j > p.j)\n\t\t\t\treturn 1 ; \n\t\t\telse if (this.j == p.j) return 0 ;\n\t\t\telse \n\t\t\t\treturn -1 ;\n\t\t}\n\n\n\t}\n\tpublic static class point implements  Comparable<point>\n\t{\n\t\tint x, y ; \n\t\tpublic point(int x,int y){\n\t\t\tthis.x=x ; this.y=y;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\n\t\t\t// If the object is compared with itself then return true  \n\t\t\tif (o == this) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/* Check if o is an instance of Complex or not\n\t          \"null instanceof [type]\" also returns false */\n\t\t\tif (!(o instanceof point)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// typecast o to Complex so that we can compare data members \n\t\t\tpoint c = (point) o;\n\n\t\t\t// Compare the data members and return accordingly \n\t\t\treturn Integer.compare(x, c.x) == 0\n\t\t\t\t\t&& Integer.compare(y, c.y) == 0;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(point p) {\n\t\t\tif(this.x == p.x && this.y ==p.y)\n\t\t\t\treturn 0 ; \n\t\t\telse\n\t\t\t\treturn -1 ; \n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode()\n\t\t{\n\t\t\treturn 15+x+(y%2) ;\n\t\t}\n\n\n\n\t}\n\n\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\n\npublic class Alpha_Round {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        String[] in = reader.readLine().split(\" \");\n        long n = Long.parseLong(in[0]);\n        long k = Long.parseLong(in[1]);\n        long D = 9 + 8*k + 8*n;\n        long m = (long) ((-3 + Math.sqrt(D))/2);\n        writer.write((n - m) + \"\");\n        writer.close();\n    }\n}", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import javax.swing.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\n\npublic class D {\n\tpublic static boolean check(long l,long r,long low,long high){\n\t\tif(l<=low && low<=r)return true;\n\t\tif(l<=high && high<=r)return true;\n\t\tif(low<=l && high>=r)return true;\n\t\treturn false;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tlong a = sc.nextLong();\n\t\tlong b = sc.nextLong();\n\t\tlong res = 0;\n\t\tint i=0;\n\t\tfor( i=62;i>=0;i--){\n\t\t\t//System.out.println((b&(1l<<i)) + \" \" +(a&(1l<<i)));\n\t\t\tif((b&(1l<<i)) !=(a&(1l<<i))){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(;i>=0;i--){\n\t\t\tres*=2l;\n\t\t\tres+=1l;\n\t\t}\n\t\tpw.println(res);\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(FileReader r) {\n\t\t\tbr = new BufferedReader(r);\n\t\t}\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\tdouble res = 0, f = 1;\n\tboolean dec = false, neg = false;\n\tint start = 0;\n\tif (x.charAt(0) == '-') {\n\t\tneg = true;\n\t\tstart++;\n\t}\n\tfor (int i = start; i < x.length(); i++)\n\t\tif (x.charAt(i) == '.') {\n\t\t\tres = Long.parseLong(sb.toString());\n\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\tdec = true;\n\t\t\t} else {\n\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\tif (dec)\n\t\t\t\t\tf *= 10;\n\t\t\t}\n\t\tres += Long.parseLong(sb.toString()) / f;\n\t\treturn res * (neg ? -1 : 1);\n\t}\n\n\tpublic boolean ready() throws IOException {\n\t\treturn br.ready();\n\n\t}\n\t}\n}", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.util.Scanner;\n\npublic class C {\n\n    private static final int MOD = (int) 1e9 + 7;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n\n        int[][] DP = new int[n][n + 1];\n        DP[0][0] = 1;\n\n        for (int i = 0; i < n - 1; i++) {\n            if (in.next().charAt(0) == 'f') {\n                for (int j = 1; j < n; j++)\n                    DP[i+1][j] = DP[i][j-1];\n            } else {\n                for (int j = n - 1; j >= 0; j--)\n                    DP[i+1][j] = (DP[i][j] + DP[i+1][j+1]) % MOD;\n            }\n        }\n\n        int answer = 0;\n        for (int i = 0; i < n; i++)\n            answer = (answer + DP[n-1][i]) % MOD;\n        System.out.println(answer);\n    }\n\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n\n\n\npublic class Codeforces {\n\t\n\tstatic int mod=998244353 ;\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t    FastScanner fs=new FastScanner();\n\t    int t=fs.nextInt();\n\t    \n\t    outer:while(t-->0) {\n\t    \tint n=fs.nextInt();\n\t    \tint arr[]=fs.readArray(n);\n\t    \tList<Integer> list=new ArrayList<>(n);\n\t    \tfor(int i=0;i<n;i++) list.add(0);\n\t    \tlist.set(0,1);\n\t    \tout.println(1);\n\t    \tint size=1;\n\t    \tfor(int i=1;i<n;i++) {\n\t    \t\tint x=arr[i];\n\t    \t\tif(x==1) {\n\t    \t\t\tlist.set(size,1);\n\t    \t\t\tsize++;\n\t    \t\t}\n\t    \t\telse {\n\t\t    \t\twhile(size>0&&list.get(size-1)!=x-1) {\n\t\t    \t\t\tsize--;\n\t\t    \t\t}\n\t\t    \t\tlist.set(size-1, x);\n\t\t    \t\t\n\t    \t\t}\n\t    \t\tfor(int j=0;j<size-1;j++) out.print(list.get(j)+\".\");\n\t    \t\tout.println(list.get(size-1));\n\t    \t}\n\t    \t\n\t    \t\n\t    }\n\t    out.close();\n    }\n\t\n\tstatic int gcd(int a,int b) {\n\t\tif(b==0) return a;\n\t\treturn gcd(b,a%b);\n\t}\n    static void sort(int[] a) {\n\t\t//suffle\n\t\tint n=a.length;\n\t\tRandom r=new Random();\n\t\tfor (int i=0; i<a.length; i++) {\n\t\t\tint oi=r.nextInt(n);\n\t\t\tint temp=a[i];\n\t\t\ta[i]=a[oi];\n\t\t\ta[oi]=temp;\n\t\t}\n\t\t\n\t\t//then sort\n\t\tArrays.sort(a);\n\t}\n\t// Use this to input code since it is faster than a Scanner\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n \n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\npublic class TemplateBuf implements Runnable{\n    \n    private void solve() throws Exception {\n        long n = nextUnsignedLong();\n        \n        out.println(n+n/2);\n    }\n\n    /////////////////////////////////////////////////\n    \n    BufferedReader in;\n    PrintWriter out;\n    \n    @Override\n    public void run() {\n        try{\n            in = new BufferedReader(new InputStreamReader(System.in), INPUT_BUF_SIZE);\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            solve();\n            out.flush();\n        }catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n    \n    final int INPUT_BUF_SIZE = 1024 * 8;\n    final int BUF_SIZE = INPUT_BUF_SIZE;\n    char[] buf = new char[BUF_SIZE];\n    int ch=-1;\n    int charRead=-1;\n    int charPos=-1;\n    \n    public char nextChar() throws IOException{\n        if (charPos<0 || charPos>=charRead){\n            charRead = in.read(buf);\n            charPos=0;\n        }\n        return buf[charPos++];\n    }\n    \n    public long nextUnsignedLong() throws IOException{      \n        while ((ch=nextChar())<'0' || ch>'9');\n        long num = ch-'0';\n        while ((ch=nextChar())>='0' && ch<='9'){\n            num*=10;\n            num+=ch-'0';\n        }\n        return num;\n    }\n    \n    public int nextUnsignedInt() throws IOException{\n        return (int)nextUnsignedLong();\n    }\n    \n    public double nextDouble() throws IOException{\n        while (((ch=nextChar())<'0' || ch>'9') && ch!='.' && ch!='-');\n        char[] tmp = new char[255];\n        int itmp = 0;\n        tmp[itmp++]=(char)ch;\n        while (((ch=nextChar())>='0' && ch<='9') || ch=='.' || ch=='-'){\n            tmp[itmp++]=(char)ch;\n        }\n        return Double.parseDouble(new String(tmp,0,itmp));\n    }\n    \n    public static void main(String[] args) {\n        new TemplateBuf().run();\n    }\n    \n}\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class a {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.next();\n\t\t\n\t\tint len = s.length();\n\t\tfor(int i=len-1; i>=1; --i) {\n\t\t\tfor(int j=0; j<=len - i; ++j) {\n\t\t\t\tString ss = s.substring(j, j+i);\n\n\t\t\t\tif(s.substring(j+1).indexOf(ss)!=-1) {\n\t\t\t\t\tSystem.out.println(ss.length());\n\t\t\t\t\treturn;\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\tSystem.out.println(0);\n\t}\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "//package round17;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\n\npublic class A {\n\n\tstatic StreamTokenizer in =\n\t\tnew StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\n\tstatic int nextInt() throws IOException{\n\t\tin.nextToken();\n\t\treturn (int)in.nval;\n\t}\n\t\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\t\n\tstatic boolean prime(int n){\n\t\tint j = 2;\n\t\twhile (j*j <= n)\n\t\t\tif (n%j == 0) return false;\n\t\t\telse j++;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tint n = nextInt(),\n\t\t\tk = nextInt(),\n\t\t\ta[] = new int[n];\n\n\t\tint s = 0;\n\t\tfor (int i=2; i<=n; i++)\n\t\t\tif (prime(i))\n\t\t\t\ta[s++] = i;\n\t\t\n\t\tint m = 0;\n\t\tfor (int i=2; i<s; i++)\n\t\t\tfor (int j=i-1; j>0; j--)\n\t\t\t\tif (a[i] == a[j]+a[j-1]+1){\n\t\t\t\t\tm++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\n\t\tif (m >= k) out.println(\"YES\");\n\t\telse out.println(\"NO\");\n\t\tout.flush();\n\t}\n\n}\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTask solver = new Task();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class Task {\n\t\tint n = 0;\n\t\tint query(int p, InputReader in) {\n\t\t\tp %= n;\n\t\t\tif (p <= 0) p += n;\n\t\t\tSystem.out.println(\"? \" + p);\n\t\t\tSystem.out.flush();\n\t\t\tint x = in.nextInt();\n\t\t\treturn x;\n\t\t}\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\t\tn = in.nextInt();\n\t\t\tif (n % 4 != 0) {\n\t\t\t\tout.println(\"! -1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint p = query(0, in);\n\t\t\tint q = query(n / 2, in);\n\t\t\tint l = 0;\n\t\t\tint r = n / 2;\n\t\t\tif (p == q) {\n\t\t\t\tout.println(\"! \" + (n / 2));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (l + 1 < r) {\n\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\tint u = query(mid, in);\n\t\t\t\tint v = query(mid + n / 2, in);\n\t\t\t\tif (u == v) {\n\t\t\t\t\tout.println(\"! \" + (mid + n / 2));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ((p < q) == (u < v)) {\n\t\t\t\t\tl = mid;\n\t\t\t\t} else {\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t}\n}", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "/**\n * @author derrick20\n */\nimport java.io.*;\nimport java.util.*;\n\npublic class SameSumBlocks {\n    public static void main(String[] args) throws Exception {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int N = sc.nextInt();\n        int[] pre = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            pre[i] = pre[i - 1] + sc.nextInt();\n        }\n//        var sumMap = new HashMap<Integer, ArrayList<Pair>>();\n        var sums = new ArrayList<Pair>();\n        for (int i = 1; i <= N; i++) {\n            for (int j = i; j <= N; j++) {\n                int sum = pre[j] - pre[i - 1];\n//                sumMap.computeIfAbsent(sum, val -> new ArrayList<>()).add(new Pair(i, j, sum));\n                sums.add(new Pair(i, j, sum));\n            }\n        }\n        Collections.sort(sums, (p1, p2) -> p1.sum - p2.sum != 0 ? p1.sum - p2.sum : p1.r - p2.r);\n        var ans = new ArrayList<Pair>();\n        int i = 0;\n        while (i < sums.size()) {\n            int j = i;\n            var group = new ArrayList(List.of(sums.get(i)));\n            int last = sums.get(i).r;\n            while (j + 1 < sums.size() && sums.get(j + 1).sum == sums.get(j).sum) {\n                if (sums.get(j + 1).l > last) {\n                    group.add(sums.get(j + 1));\n                    last = sums.get(j + 1).r;\n                }\n                j++;\n            }\n//            System.out.println(group);\n            if (group.size() > ans.size()) {\n                ans = group;\n            }\n            i = j + 1;\n        }\n        out.println(ans.size());\n        for (Pair p : ans) {\n            out.println(p);\n        }\n        out.close();\n    }\n\n    static class Pair {\n        int l, r, sum;\n        public Pair(int ll, int rr, int ss) {\n            l = ll; r = rr; sum = ss;\n        }\n        public String toString() {\n            return l + \" \" + r;\n        }\n    }\n\n    static class FastScanner {\n        private int BS = 1<<16;\n        private char NC = (char)0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n\n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n\n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            }\n            catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n\n        private char getChar(){\n            while(bId==size) {\n                try {\n                    size = in.read(buf);\n                }catch(Exception e) {\n                    return NC;\n                }\n                if(size==-1)return NC;\n                bId=0;\n            }\n            return (char)buf[bId++];\n        }\n\n        public int nextInt() {\n            return (int)nextLong();\n        }\n\n        public int[] nextInts(int N) {\n            int[] res = new int[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = (int) nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongs(int N) {\n            long[] res = new long[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long nextLong() {\n            cnt=1;\n            boolean neg = false;\n            if(c==NC)c=getChar();\n            for(;(c<'0' || c>'9'); c = getChar()) {\n                if(c=='-')neg=true;\n            }\n            long res = 0;\n            for(; c>='0' && c <='9'; c=getChar()) {\n                res = (res<<3)+(res<<1)+c-'0';\n                cnt*=10;\n            }\n            return neg?-res:res;\n        }\n\n        public double nextDouble() {\n            double cur = nextLong();\n            return c!='.' ? cur:cur+nextLong()/cnt;\n        }\n\n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while(c<=32)c=getChar();\n            while(c>32) {\n                res.append(c);\n                c=getChar();\n            }\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while(c<=32)c=getChar();\n            while(c!='\\n') {\n                res.append(c);\n                c=getChar();\n            }\n            return res.toString();\n        }\n\n        public boolean hasNext() {\n            if(c>32)return true;\n            while(true) {\n                c=getChar();\n                if(c==NC)return false;\n                else if(c>32)return true;\n            }\n        }\n    }\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class C {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        // Scanner scan = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(bf.readLine());\n        int counter = 0;\n        for(int i=0; i<2*n/3; i++) System.out.println(\"0 \" + i);\n        for(int i=0; i<n-2*n/3; i++) System.out.println(\"3 \" + (2*i+1));\n\n    }\n}\n", "complexity": "linear", "problem": "1067_C", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n\tstatic int n, m, a[][];\n\tstatic int[][] memo;\n\tstatic Integer[] indices;\n\n\tstatic int[] getCol(int col, int shift) {\n\t\tint[] ans = new int[n];\n\t\tfor (int i = 0, j = shift; i < n; i++, j = (j + 1) % n) {\n\t\t\tans[i] = a[j][col];\n\t\t}\n\t\treturn ans;\n\n\t}\n\n\tstatic int dp(int col, int msk) {\n\t\tif (col == n||col==m)\n\t\t\treturn 0;\n\t\tif (memo[msk][col] != -1)\n\t\t\treturn memo[msk][col];\n\t\tint ans = 0;\n\t\tfor (int shift = 0; shift < n; shift++) {\n\t\t\tint[] currCol = getCol(indices[col], shift);\n\t\t\tfor (int nxtMsk = 0; nxtMsk < 1 << n; nxtMsk++) {\n\t\t\t\tif ((nxtMsk & msk) != msk)\n\t\t\t\t\tcontinue;\n\t\t\t\tint curr = 0;\n\t\t\t\tint diff = msk ^ nxtMsk;\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif ((diff & 1 << i) != 0)\n\t\t\t\t\t\tcurr += currCol[i];\n\t\t\t\tans = Math.max(ans, dp(col + 1, nxtMsk) + curr);\n\t\t\t}\n\t\t}\n\t\treturn memo[msk][col] = ans;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint tc = sc.nextInt();\n\t\twhile (tc-- > 0) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tindices = new Integer[m];\n\n\t\t\tmemo = new int[1 << n][m];\n\t\t\tfor (int[] x : memo)\n\t\t\t\tArrays.fill(x, -1);\n\t\t\ta = new int[n][m];\n\t\t\tint[] max = new int[m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\t\tmax[j] = Math.max(max[j], a[i][j]);\n\t\t\t\t}\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tindices[j] = j;\n\t\t\t}\n\t\t\tArrays.sort(indices, Comparator.comparingInt(i -> -max[i]));\n\t\t\tout.println(dp(0, 0));\n\t\t}\n\t\tout.close();\n\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tboolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tshuffle(a);\n\t\tArrays.sort(a);\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tRandom rand = new Random();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint tmpIdx = rand.nextInt(n);\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[tmpIdx];\n\t\t\ta[tmpIdx] = tmp;\n\t\t}\n\t}\n\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "// package com.company;\nimport java.util.*;\nimport java.io.*;\nimport java.lang.*;\npublic class Main{\n\n    public static void main(String args[]){\n        InputReader in=new InputReader(System.in);\n        TASK solver = new TASK();\n        int t=1;\n        t = in.nextInt();\n        for(int i=1;i<=t;i++)\n        {\n            solver.solve(in,i);\n        }\n    }\n    static class TASK {\n        static int mod = 1000000007;\n        void solve(InputReader in, int testNumber) {\n            int n = in.nextInt();\n\n            System.out.println(1);\n            int x = in.nextInt();\n            n--;\n            Stack<Integer> stack = new Stack<>();\n            stack.push(1);\n\n            int pre=1;\n            while (n-->0)\n            {\n                x = in.nextInt();\n                if(x==1)\n                {\n                    stack.push(1);\n                }\n                else\n                {\n                    while (true)\n                    {\n                        if(stack.peek()==x-1) {\n                            stack.pop();\n                            break;\n\n                        }\n                        stack.pop();\n                    }\n                    stack.push(x);\n                }\n                StringBuilder sb = new StringBuilder();\n                int c=0;\n                for(Integer i:stack)\n                {\n                    sb.append(i);\n                    if(c!=stack.size()-1) {\n                        sb.append('.');\n                    }\n                    c++;\n                }\n                System.out.println(sb);\n            }\n\n\n\n\n\n\n\n\n\n        }\n    }\n\n    static class pair{\n        int x ;\n        int y;\n        pair(int x,int y)\n        {\n            this.x=x;\n            this.y=y;\n        }\n    }\n\n    static class Maths {\n        static long gcd(long a, long b) {\n            if (a == 0)\n                return b;\n            return gcd(b % a, a);\n        }\n        public static long lcm(long a, long b) {\n            return (a * b) / gcd(a, b);\n        }\n        public static long factorial(int n) {\n            long fact = 1;\n            for (int i = 1; i <= n; i++) {\n                fact *= i;\n            }\n            return fact;\n        }\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n        public String nextLine() {\n            BufferedReader br = new BufferedReader(new\n                    InputStreamReader(System.in));\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res.toString();\n        }\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c\n                    == -1;\n        }\n        public String next() {\n            return readString();\n        }\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.UncheckedIOException;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.Objects;\n\npublic class Main {\n    public void exec() {\n        int t = stdin.nextInt();\n        while (t-- > 0) {\n            int n = stdin.nextInt();\n            int[] a = stdin.nextIntArray(n);\n            sort(a);\n            int x1 = a[n-2]-1;\n            int x2 = n-2;\n            int x = Math.max(0, Math.min(x1, x2));\n            stdout.println(x);\n        }\n    }\n\n    public void sort(int[] a) {\n        int len = a.length;\n        if (len < 2) {\n            return ;\n        }\n\n        int[] a1 = Arrays.copyOfRange(a, 0, len/2);\n        int[] a2 = Arrays.copyOfRange(a, len/2, len);\n        sort(a1);\n        sort(a2);\n\n        int p1 = 0;\n        int p2 = 0;\n        for (int i = 0; i < a.length; i++) {\n            if (p2==a2.length || (p1<a1.length && a1[p1]<=a2[p2])) {\n                a[i] = a1[p1++];\n            } else {\n                a[i] = a2[p2++];\n            }\n        }\n    }\n\n    private static final Stdin stdin = new Stdin(System.in);\n    private static final Stdout stdout = new Stdout(System.out);\n    private static final Stderr stderr = new Stderr(System.err, false);\n\n    public static void main(String[] args) {\n        try {\n            new Main().exec();\n        } finally {\n            stdout.flush();\n        }\n    }\n\n    // ASCII ONLY\n    public static class Stdin {\n        private InputStream in;\n        private byte[] buf;\n        private int ptr;\n        private int len;\n\n        public Stdin(InputStream in) {\n            this.in = in;\n            this.buf = new byte[1024];\n            this.ptr = 0;\n            this.len = 0;\n        }\n\n        public String nextString() {\n            StringBuilder sb = new StringBuilder();\n            byte b;\n            while ((b = read()) != -1) {\n                sb.appendCodePoint(b);\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            return (int)nextLong();\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextString());\n        }\n\n        public long nextLong() {\n            boolean negative = false;\n            int x = 0;\n\n            byte b = read();\n            if (b == '-') {\n                negative = true;\n            } else {\n                x += b-'0';\n            }\n\n            while ((b=read()) != -1) {\n                x *= 10;\n                x += b-'0';\n            }\n\n            return negative ? -x : x;\n        }\n\n        private byte read() {\n            byte b = readByte();\n            if (b == '\\r') {\n                readByte(); // LF\u3092\u8aad\u307f\u98db\u3070\u3059\n                return -1;\n            } else if (b == '\\n' || b == ' ') {\n                return -1;\n            } else {\n                return b;\n            }\n        }\n\n        private byte readByte(){\n            if (len == ptr) {\n                try {\n                    ptr = 0;\n                    len = in.read(buf);\n                    if (len == -1) return -1;\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public String[] nextStringArray(int n) {\n            String[] a = new String[n];\n            for (int i = 0; i < n; i++) a[i] = nextString();\n            return a;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++) a[i] = nextDouble();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    public static class Stdout {\n        private PrintWriter stdout;\n\n        public Stdout(PrintStream stdout) {\n            this.stdout =  new PrintWriter(stdout, false);\n        }\n\n        public void println(Object ... objs) {\n            for (int i = 0, len = objs.length; i < len; i++) {\n                stdout.print(objs[i]);\n                if (i != len-1) stdout.print(' ');\n            }\n            stdout.println();\n        }\n\n        public void flush() {\n            stdout.flush();\n        }\n    }\n\n    public static class Stderr {\n        private PrintWriter stderr;\n        private boolean debug;\n\n        public Stderr(PrintStream stderr, boolean debug) {\n            this.stderr =  new PrintWriter(stderr, false);\n            this.debug = debug;\n        }\n\n        public void println(Object ... objs) {\n            if (!debug) return ;\n\n            stderr.print(\"DEBUG: \");\n            for (int i = 0, len = objs.length; i < len; i++) {\n                stderr.print(deepToString(objs[i]));\n                if (i != len-1) stderr.print(' ');\n            }\n            stderr.println();\n            stderr.flush();\n        }\n\n        private String deepToString(Object o) {\n            if (o == null) {\n                return \"null\";\n            }\n\n            // \u914d\u5217\u306e\u5834\u5408\n            if (o.getClass().isArray()) {\n                int len = Array.getLength(o);\n                String[] tokens = new String[len];\n                for (int i = 0; i < len; i++) {\n                    tokens[i] = deepToString(Array.get(o, i));\n                }\n                return \"{\" + String.join(\", \", tokens) + \"}\";\n            }\n\n            return Objects.toString(o);\n        }\n    }\n}", "complexity": "linear", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        D903 solver = new D903();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D903 {\n        int N;\n        long ripple;\n        BigInteger tot;\n        long[] nums;\n        BigInteger[] cs;\n\n        public void solve(int testNumber, FastScanner s, PrintWriter out) {\n            N = s.nextInt();\n            nums = s.nextLongArray(N);\n            tot = new BigInteger(\"0\");\n            cs = new BigInteger[N + 1];\n            cs[0] = new BigInteger(\"0\");\n            ripple = 0;\n            for (int i = 1; i <= N; i++)\n                cs[i] = cs[i - 1].add(new BigInteger(\"\" + nums[i - 1]));\n\n            for (int i = 1; i <= N; i++) {\n                long cur = nums[i - 1];\n//            out.printf(\"%d: cs %d, minus %d%n\", i, (cs[N] - cs[i]), cur * (N - i));\n                tot = tot.add(cs[N].subtract(cs[i])).subtract(new BigInteger(\"\" + (cur * (N - i))));\n            }\n\n            HashMap<Long, Integer> seen = new HashMap<>();\n            for (long i : nums) {\n                Integer lo = seen.get(i - 1);\n                Integer hi = seen.get(i + 1);\n                if (lo != null)\n                    tot = tot.subtract(new BigInteger(\"\" + lo));\n                if (hi != null)\n                    tot = tot.add(new BigInteger(\"\" + hi));\n\n                if (!seen.containsKey(i))\n                    seen.put(i, 0);\n                seen.put(i, seen.get(i) + 1);\n            }\n\n            out.println(tot);\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public long[] nextLongArray(int N) {\n            long[] ret = new long[N];\n            for (int i = 0; i < N; i++)\n                ret[i] = this.nextLong();\n            return ret;\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class C\n{\n\tString line;\n\tStringTokenizer inputParser;\n\tBufferedReader is;\n\tFileInputStream fstream;\n\tDataInputStream in;\n\t\n\tvoid openInput(String file)\n\t{\n\n\t\tif(file==null)is = new BufferedReader(new InputStreamReader(System.in));//stdin\n\t\telse\n\t\t{\n\t\t\ttry{\n\t\t\n\t\t\t\t\n\t\t\tfstream = new FileInputStream(file);\n\t\t\tin = new DataInputStream(fstream);\n\t\t\tis = new BufferedReader(new InputStreamReader(in));\n\t\t\t}catch(Exception e)\n\t\t\t{\n\t\t\t\tSystem.err.println(e);\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\tvoid readNextLine()\n\t{\n\t\ttry {\n\t\t\tline = is.readLine();\n\t\t\tinputParser = new StringTokenizer(line, \" \");\n\t\t\t//System.err.println(\"Input: \" + line);\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Unexpected IO ERROR: \" + e);\n\t\t}\t\n\t\t\n\t}\n\t\n\tint NextInt()\n\t{\n\t\tString n = inputParser.nextToken();\n\t\tint val = Integer.parseInt(n);\n\t\t\n\t\t//System.out.println(\"I read this number: \" + val);\n\t\treturn val;\n\t}\n\t\n\tString NextString()\n\t{\n\t\tString n = inputParser.nextToken();\n\t\treturn n;\n\t}\n\t\n\tvoid closeInput()\n\t{\n\t\ttry {\n\t\t\tis.close();\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Unexpected IO ERROR: \" + e);\n\t\t}\n\t\t\t\n\t}\n\t\n\t\n\tpublic static void main(String [] argv)\n\t{\n\t\tString filePath=null;\n\t\tif(argv.length>0)filePath=argv[0];\n\t\tC c = new C(filePath);\n\t}\n\t\n\tpublic C(String inputFile)\n\t{\n        openInput(inputFile);\n        \n\t\treadNextLine();\n\t\tint N=NextInt();\n\t\tboolean [] p = new boolean[N];\n\t\treadNextLine();\n\t\tint h=0;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tp[i]=line.charAt(i)=='H';\n\t\t\tif(p[i])h++;\n\t\t}\n\t\t\n\t\t\n\t\tint ret=N;\n\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint m=0;\n\t\t\tfor(int j=i; j<i+h; j++)\n\t\t\t{\n\t\t\t\tint n=j%N;\n\t\t\t\tif(!p[n])m++;\n\t\t\t}\n\t\t\tret=Math.min(ret, m);\n\t\t}\n\t\t\n\t\tSystem.out.println(ret);\n\t\tcloseInput();\n\t}\n\n\t\n\t\n}\n\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st = new StringTokenizer(\"\");\n\n\tprivate void run() throws IOException {\n\t\tif (new File(\"input.txt\").exists())\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\telse\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tif (new File(\"output.txt\").exists())\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\telse\n\t\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tvoid solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tl += l % 2;\n\t\tif (l + 2 > r)\n\t\t\tout.println(\"-1\");\n\t\telse {\n\t\t\tout.println(l + \" \" + (l + 1) + \" \" + (l + 2));\n\t\t}\n\t}\n\n\tString nextLine() throws IOException {\n\t\tst = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tboolean EOF() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString str = in.readLine();\n\t\t\tif (str == null)\n\t\t\t\treturn true;\n\t\t\tst = new StringTokenizer(str);\n\t\t}\n\t\treturn false;\n\t}\n\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int r = in.nextInt();\n            ArrayList<PointDouble> centers = new ArrayList<>();\n            ArrayList<Integer> xs = new ArrayList<>();\n            for (int i = 0; i < n; ++i) {\n                int x = in.nextInt();\n                double y = r;\n                for (int j = 0; j < centers.size(); j++) {\n                    int ox = xs.get(j);\n                    if (Math.abs(ox - x) > 2 * r) continue;\n                    PointDouble c = centers.get(j);\n                    double t = Math.abs(ox - x);\n                    double h = Math.sqrt(Math.abs(4.0 * r * r - t * t));\n                    double val = c.y + h;\n                    if (y < val) y = val;\n                }\n                out.print(String.format(\"%.20f \", y));\n                centers.add(new PointDouble(x, y));\n                xs.add(x);\n            }\n            out.printLine();\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buffer = new byte[10000];\n        private int cur;\n        private int count;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isSpace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (count == -1) {\n                throw new InputMismatchException();\n            }\n            try {\n                if (cur >= count) {\n                    cur = 0;\n                    count = stream.read(buffer);\n                    if (count <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            return buffer[cur++];\n        }\n\n        public int readSkipSpace() {\n            int c;\n            do {\n                c = read();\n            } while (isSpace(c));\n            return c;\n        }\n\n        public int nextInt() {\n            int sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n    }\n\n    static class PointDouble {\n        public double x;\n        public double y;\n\n        public PointDouble(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public PointDouble() {\n            x = 0;\n            y = 0;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.*;\nimport java.security.SecureRandom;\n\npublic class WCS {\n\t\n\tpublic static class Vector implements Comparable <Vector>  {\n\t\tlong x, y;\n\t\tint position;\n\t\tVector first, second;\n\t\tboolean toReverse;\n\t\t\n\t\tpublic Vector(long xx, long yy, int p) {\n\t\t\tx = xx;\n\t\t\ty = yy;\n\t\t\tposition = p;\n\t\t\tfirst = null;\n\t\t\tsecond = null;\n\t\t\ttoReverse = false;\n\t\t}\n\t\t\n\t\tpublic Vector negate() {\n\t\t\tVector vv = new Vector(-x, -y, position);\n\t\t\tvv.first = first;\n\t\t\tvv.second = second;\n\t\t\tvv.toReverse = !toReverse;\n\t\t\treturn vv;\n\t\t}\n\t\t\n\t\tpublic Vector add(Vector v) {\n\t\t\tVector sum = new Vector(this.x + v.x, this.y + v.y, position);\n\t\t\tsum.first = this;\n\t\t\tsum.second = v;\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tpublic Vector subtract(Vector v) {\n\t\t\treturn this.add(v.negate());\n\t\t}\n\t\t\n\t\tpublic double euclideanNorm() {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Vector v) {\n\t\t\tdouble thisa = Math.atan2(this.y, this.x);\n\t\t\tdouble va = Math.atan2(v.y, v.x);\n\t\t\tif(thisa < 0)\n\t\t\t\tthisa += 2 * Math.PI;\n\t\t\tif(va < 0)\n\t\t\t\tva += 2 * Math.PI;\n\t\t\tif(thisa < va)\n\t\t\t\treturn -1;\n\t\t\tif(thisa > va)\n\t\t\t\treturn 1;\n\t\t\treturn Integer.compare(this.position, v.position);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y;\n\t\t}\n\t}\n\t\n\tpublic static void dfs(Vector curr, int[] ans) {\n\t\tif(curr.first == null) {\n\t\t\tans[curr.position] = curr.toReverse ? -1 : 1;\n\t\t\treturn;\n\t\t}\n\t\tcurr.first.toReverse ^= curr.toReverse;\n\t\tcurr.second.toReverse ^= curr.toReverse;\n\t\tdfs(curr.first, ans);\n\t\tdfs(curr.second, ans);\n\t}\n\t\n\tpublic static boolean ok(Vector v1, Vector v2) {\n\t\treturn v1.add(v2).euclideanNorm() <= Math.max(v1.euclideanNorm(), v2.euclideanNorm());\n\t}\n\t\n\tpublic static void stop(long k) {\n\t\tlong time = System.currentTimeMillis();\n\t\twhile(System.currentTimeMillis() - time < k);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = in.nextInt();\n\t\tTreeSet <Vector> vectors = new TreeSet <> ();\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\tVector v = new Vector(in.nextLong(), in.nextLong(), i);\n\t\t\tvectors.add(v);\n\t\t}\n\t\twhile(vectors.size() > 2) {\n\t\t\t//System.out.println(vectors);\n\t\t\t//stop(500);\n\t\t\t\n\t\t\tTreeSet <Vector> support = new TreeSet <> ();\n\t\t\t\n\t\t\twhile(vectors.size() > 0) {\n\t\t\t\tVector curr = vectors.pollFirst();\n\t\t\t\tVector next1 = vectors.higher(curr);\n\t\t\t\tVector next2 = vectors.lower(curr.negate());\n\t\t\t\tVector next3 = vectors.higher(curr.negate());\n\t\t\t\tVector next4 = vectors.lower(curr);\n\t\t\t\t\n\t\t\t\t//System.out.println(\"CURR: \" + curr + \"\\n\" + next1 + \"\\n\" + next2);\n\t\t\t\t\n\t\t\t\tif(next1 != null) {\n\t\t\t\t\tif(ok(curr, next1)) {\n\t\t\t\t\t\tsupport.add(curr.add(next1));\n\t\t\t\t\t\tvectors.remove(next1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next1 != null) {\n\t\t\t\t\tif(ok(curr, next1.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next1));\n\t\t\t\t\t\tvectors.remove(next1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next2 != null) {\n\t\t\t\t\tif(ok(curr, next2)) {\n\t\t\t\t\t\tsupport.add(curr.add(next2));\n\t\t\t\t\t\tvectors.remove(next2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next2 != null) {\n\t\t\t\t\tif(ok(curr, next2.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next2));\n\t\t\t\t\t\tvectors.remove(next2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next3 != null) {\n\t\t\t\t\tif(ok(curr, next3)) {\n\t\t\t\t\t\tsupport.add(curr.add(next3));\n\t\t\t\t\t\tvectors.remove(next3);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next3 != null) {\n\t\t\t\t\tif(ok(curr, next3.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next3));\n\t\t\t\t\t\tvectors.remove(next3);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next4 != null) {\n\t\t\t\t\tif(ok(curr, next4)) {\n\t\t\t\t\t\tsupport.add(curr.add(next4));\n\t\t\t\t\t\tvectors.remove(next4);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next4 != null) {\n\t\t\t\t\tif(ok(curr, next4.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next4));\n\t\t\t\t\t\tvectors.remove(next4);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsupport.add(curr);\n\t\t\t}\n\t\t\t\n\t\t\tvectors = support;\n\t\t}\n\t\t\n\t\tif(vectors.size() == 2) {\n\t\t\tVector curr = vectors.pollFirst();\n\t\t\tVector next = vectors.pollFirst();\n\t\t\tVector add = curr.add(next);\n\t\t\tVector sub = curr.subtract(next);\n\t\t\tif(sub.euclideanNorm() <= add.euclideanNorm())\n\t\t\t\tvectors.add(sub);\n\t\t\telse\n\t\t\t\tvectors.add(add);\n\t\t}\n\t\t\n\t\t//System.out.println(vectors.first().euclideanNorm());\n\t\t\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint[] ans = new int[n];\n\t\tdfs(vectors.pollFirst(), ans);\n\t\tfor(int i = 0; i < n; i ++)\n\t\t\tbuffer.append(ans[i] + \" \");\n\t\tSystem.out.println(buffer);\n\t}\n    \n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        BigInteger nextBigInteger() {\n        \treturn new BigInteger(in.next());\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        char nextChar() {\n            return in.next().charAt(0);\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    static FastReader in = new FastReader();\n    static OutputStream out = new BufferedOutputStream(System.out);\n    \n    public static byte[] toByte(Object o) {\n        return String.valueOf(o).getBytes();\n    }\n    \n    public static void sop(Object o) {\n        System.out.print(o);\n    }\n}", "complexity": "nlogn", "problem": "0995_C", "from": "CODEFORCES", "tags": "brute force,data structures,geometry,greedy,math,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Vadim Semenov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static final class TaskC {\n        private static final int MODULO = 1_000_000_000 + 7;\n\n        public void solve(int __, InputReader in, PrintWriter out) {\n            long qty = in.nextLong();\n            long months = in.nextLong();\n            if (qty == 0) {\n                out.println(0);\n                return;\n            }\n            qty %= MODULO;\n            long pow = pow(2, months + 1);\n            qty = (qty * pow) % MODULO;\n            long sub = (pow - 2 + MODULO) % MODULO * pow(2, MODULO - 2) % MODULO;\n            qty = (qty - sub + MODULO) % MODULO;\n            out.println(qty);\n        }\n\n        private long pow(long base, long power) {\n            long result = 1;\n            while (power > 0) {\n                if ((power & 1) != 0) {\n                    result = (result * base) % MODULO;\n                }\n                base = (base * base) % MODULO;\n                power >>>= 1;\n            }\n            return result;\n        }\n\n    }\n\n    static class InputReader {\n        private final BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String readLine() {\n            String line;\n            try {\n                line = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return line;\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "/*\nKeep solving problems.\n*/\n\nimport java.util.*;\nimport java.io.*;\n\npublic class CFA {\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    private static long MOD = 1000L * 1000L * 1000L + 7;\n    private static final int[] dx = {0, -1, 0, 1};\n    private static final int[] dy = {1, 0, -1, 0};\n    private static final String yes = \"Yes\";\n    private static final String no = \"No\";\n\n    int n;\n    int m;\n    char[][] mat;\n    long base = 397;\n    void solve() throws IOException {\n        n = nextInt();\n        m = nextInt();\n        mat = new char[n][m];\n        for (int i = 0; i < n; i++) {\n            mat[i] = nextString().toCharArray();\n        }\n\n        int alpha = 26;\n        long[] pow = new long[alpha];\n        pow[0] = 1;\n        for (int i = 1; i < alpha; i++) {\n            pow[i] = pow[i - 1] * base % MOD;\n        }\n\n        long res = 0;\n        for (int l = 0; l < m; l++) {\n            //[l, r]\n            long[] hash = new long[n];\n            long[] mask = new long[n];\n            for (int r = l; r < m; r++) {\n                for (int i = 0; i < n; i++) {\n                    hash[i] += pow[mat[i][r] - 'a'];\n                    hash[i] %= MOD;\n                    mask[i] = mask[i] ^ (1L << (mat[i][r] - 'a'));\n                }\n\n                int start = 0;\n                while (start < n) {\n                    if ((mask[start] & (mask[start] - 1)) != 0) {\n                        start++;\n                        continue;\n                    }\n\n                    int end = start;\n                    List<Long> l1 = new ArrayList<>();\n                    while (end < n && (mask[end] & (mask[end] - 1)) == 0) {\n                        l1.add(hash[end]);\n                        end++;\n                    }\n\n                    start = end;\n                    res += manacher(l1);\n                }\n            }\n        }\n\n        outln(res);\n    }\n\n    long manacher(List<Long> arr) {\n        int len = arr.size();\n        long[] t = new long[len * 2 + 3];\n        t[0] = -1;\n        t[len * 2 + 2] = -2;\n        for (int i = 0; i < len; i++) {\n            t[2 * i + 1] = -3;\n            t[2 * i + 2] = arr.get(i);\n        }\n\n        t[len * 2 + 1] = -3;\n        int[] p = new int[t.length];\n        int center = 0, right = 0;\n        for (int i = 1; i < t.length - 1; i++) {\n            int mirror = 2 * center - i;\n            if (right > i) {\n                p[i] = Math.min(right - i, p[mirror]);\n            }\n\n            // attempt to expand palindrome centered at i\n            while (t[i + (1 + p[i])] == t[i - (1 + p[i])]) {\n                p[i]++;\n            }\n\n            // if palindrome centered at i expands past right,\n            // adjust center based on expanded palindrome.\n            if (i + p[i] > right) {\n                center = i;\n                right = i + p[i];\n            }\n        }\n\n        long res = 0;\n        for (int i = 0; i < 2 * len; i++) {\n            int parLength = p[i + 2];\n            if (i % 2 == 0) {\n                res += (parLength + 1) / 2;\n            }\n            else {\n                res += parLength / 2;\n            }\n        }\n\n        return res;\n    }\n\n    void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n    long gcd(long a, long b) {\n        while(a != 0 && b != 0) {\n            long c = b;\n            b = a % b;\n            a = c;\n        }\n        return a + b;\n    }\n    private void outln(Object o) {\n        out.println(o);\n    }\n    private void out(Object o) {\n        out.print(o);\n    }\n    private void formatPrint(double val) {\n        outln(String.format(\"%.9f%n\", val));\n    }\n    public CFA() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFA();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}", "complexity": "nlogn", "problem": "1080_E", "from": "CODEFORCES", "tags": "strings"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main { \n    public static StreamTokenizer in;\n    public static PrintStream out;\n    public static BufferedReader br;\n\n    public static String readString() throws IOException {\n        in.nextToken();\n        return  in.sval;\n        }\n\n    public static double readDouble() throws IOException {\n        in.nextToken();\n        return in.nval;\n        }\n\n    public static int readInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n    \n    public static String readLine() throws IOException {\n    return br.readLine();\n    }\n    \n    public static int genans(String ss) {\n    \t\n    \tint n = ss.length();\n    \tchar[] s = ss.toCharArray();\n    \tint res = 0;\n    \twhile (true) {\n    \t\tint firstT = -1;\n    \t\tfor (int i=0; i<n; i++)\n    \t\t\tif (s[i]=='T') { firstT = i; break; }\n    \t\t\n    \t\tint lastH = -1;\n    \t\tfor (int i=n-1; i>=0; i--)\n    \t\t\tif (s[i]=='H') { lastH=i; break; }\n    \t\t\n    \t\tif (firstT<lastH) {\n    \t\t\tres++;\n    \t\t\ts[firstT] = 'H';\n    \t\t\ts[lastH] = 'T';\n    \t\t} else break;\n    \t\t\n    \t}\t\n    \treturn res;\n    }\n    \n    public static void main(String[] args) throws IOException {\n\n        in = new StreamTokenizer(new InputStreamReader (System.in) );\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintStream(System.out);\n\n        readLine();\n        String s = readLine();\n        int n = s.length();\n        String kk = s;\n        int ans = n*100;\n        for (int tr=0; tr<n+2; tr++) {\n        \tString kk2 = \"\";\n        \tfor (int i=1; i<n; i++) kk2 = kk2 +kk.charAt(i);\n        \tkk2 = kk2 + kk.charAt(0);\n        \tkk = kk2;\n        \n        int cur = genans(kk);\n        //out.println(kk+\" \"+cur);\n        if (cur<ans) ans = cur;\n        }\n        \n        out.println(ans);\n\n    }\n    \n\n}\n\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.util.InputMismatchException;\nimport java.io.*;\nimport java.util.HashMap;\n\n/**\n * Generated by Contest helper plug-in\n * Actual solution is at the bottom\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new StreamInputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        run(in, out);\n    }\n\n    public static void run(InputReader in, PrintWriter out) {\n        Solver solver = new SimpleCycles();\n        solver.solve(1, in, out);\n        Exit.exit(in, out);\n    }\n}\n\nclass StreamInputReader extends InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar, numChars;\n\n    public StreamInputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    @Override\n    public void close() {\n        try {\n            stream.close();\n        } catch (IOException ignored) {\n        }\n    }\n}\n\nabstract class InputReader {\n    private boolean finished = false;\n\n    public abstract int read();\n\n    public int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n\n    public String nextToken() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n    private boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public void setFinished(boolean finished) {\n        this.finished = finished;\n    }\n\n    public abstract void close();\n}\n\ninterface Solver {\n    public void solve(int testNumber, InputReader in, PrintWriter out);\n}\n\nclass Exit {\n    private Exit() {\n    }\n\n    public static void exit(InputReader in, PrintWriter out) {\n        in.setFinished(true);\n        in.close();\n        out.close();\n    }\n}\n\nclass SimpleCycles implements Solver {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        boolean[][] g = new boolean[n][n];\n        for (int i = 0; i < m; ++i) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            --u;\n            --v;\n            g[u][v] = g[v][u] = true;\n        }\n        HashMap<Integer, Integer> pointer = new HashMap<Integer, Integer> () ;\n        for (int i =0 ; i < n; ++i) {\n            pointer.put(1 << i, i);\n        }\n        long[][] dm = new long[1 << n][n];\n        for (int i = 0; i < n; ++i) {\n            dm[1 << i][i] = 1;\n        }\n        for (int i = 0; i < (1 << n); ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (dm[i][j] == 0) continue;\n                int k = pointer.get(i - (i & (i - 1)));\n                for (int u = k + 1; u < n; ++u) {\n                    if (g[j][u] && (i & (1 << u)) == 0) {\n                        dm[i | (1 << u)][u] += dm[i][j];\n                    }\n                }\n            }\n        }\n        long res = 0;\n        for (int i = 0; i < (1 << n); ++i) {\n            for (int j = 0; j < n; ++j)\n                if (Integer.bitCount(i) >= 3) {\n\n                    int c = pointer.get(i - (i & (i - 1)));\n                    if (g[c][j]) res += (long) dm[i][j];\n                }\n        }\n        out.print(res / 2);\n    }\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Solution{\n\t\n\tstatic final int N = (int)5e5+10;\n\tstatic int[] cnt;\n\tstatic ArrayList<Integer>[] seg;\n\tstatic int[] last;\n\t\n\t\n    public static void main(String[] args) throws IOException {\n    \t\n\t\t\n    \tFastScanner fs = new FastScanner();\n    \tPrintWriter out = new PrintWriter(System.out);\n    \t\n    \t\n    \t\t\n    \tint tt = 1;\n    \twhile(tt-->0) {\n    \t\t\n    \t\tint n = fs.nextInt(), c = fs.nextInt();\n    \t\t\n    \t\tcnt = new int[N];\n    \t\t\n    \t\tseg = new ArrayList[N];\n    \t\tfor(int i=0;i<N;i++) seg[i] = new ArrayList<Integer>();\n    \t\t\n    \t\tlast = new int[N]; Arrays.fill(last, -1);\n    \t\t\n    \t\tint[] a = new int[n];\n    \t\t\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\ta[i] = fs.nextInt();\n    \t\t\tcnt[i+1] = cnt[i] + ((a[i]==c)?1:0);\n    \t\t}\n    \t\t\n    \t\t\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\tseg[a[i]].add(-getCnt(last[a[i]]+1, i-1));\n    \t\t\tlast[a[i]] = i;\n    \t\t\tseg[a[i]].add(1);\n    \t\t}\n    \t\t\n    \t\t\n    \t\tint ans = 0;\n    \t\t\n    \t\tfor(int i=0;i<N;i++) {\n    \t\t\tif(i==c) continue;\n    \t\t\tif(seg[i].isEmpty()) continue;\n    \t\t\tans = Math.max(ans, maxSeg(seg[i]));\n    \t\t}\n    \t\t\n    \t\tout.println(getCnt(0, n-1) + ans);\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t}\n    \t\n    \tout.close();\n    \t\t\n    }\n    \n\n    static int getCnt(int l, int r) {\n    \treturn cnt[r+1]-cnt[l];\n    }\n    \n    \n    static int maxSeg(ArrayList<Integer> l) {\n    \tint max = 0;\n    \tint cur = 0;\n    \tfor(int a: l) {\n    \t\tcur = Math.max(0, cur + a);\n    \t\tmax = Math.max(max, cur);\n    \t}\n    \treturn max;\n    }\n    \n    \n    \n    static final Random random=new Random();\n    \n    static <T> void shuffle(T[] arr) {\n    \tint n = arr.length;\n    \tfor(int i=0;i<n;i++\t) {\n    \t\tint k = random.nextInt(n);\n    \t\tT temp = arr[k]; arr[k] = arr[i]; arr[i] = temp;\n    \t}\n    }\n    \n    \t\n    static void ruffleSort(int[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); int temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n    \n    static void ruffleSort(long[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); long temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n   \n  \n    \n    static void reverse(int[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tint temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    static void reverse(long[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tlong temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    \n    static <T> void reverse(T[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++) {\n    \t\tT temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \t\n    \t\n    static class FastScanner{\n    \tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \tStringTokenizer st = new StringTokenizer(\"\");\n     \n    \tpublic String next(){\n    \t\twhile(!st.hasMoreElements()){\n    \t\t\ttry{\n    \t\t\t\tst = new StringTokenizer(br.readLine());\n    \t\t\t} catch(IOException e){\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t\treturn st.nextToken();\n    \t}\n    \t\t\n    \tpublic String nextLine() throws IOException {\n    \t\treturn br.readLine();\n    \t}\n    \t\t\n    \tpublic int nextInt(){\n    \t\treturn Integer.parseInt(next());\n    \t}\n     \n    \tpublic int[] readArray(int n){\n    \t\tint[] a = new int[n];\n    \t\tfor(int i=0;i<n;i++)\n    \t\t\ta[i] = nextInt();\n    \t\treturn a;\n    \t}\n    \t\t\n    \tpublic long nextLong() {\n    \t\treturn Long.parseLong(next());\n    \t}\n    \t\t\n    \tpublic char nextChar() {\n    \t\treturn next().toCharArray()[0];\n    \t}\n    }\n   \t\n}\n", "complexity": "linear", "problem": "1082_E", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\n\npublic class Solution {\n    public static void main(String[] args)throws IOException {\n        FastReader in=new FastReader(System.in);\n        int t=in.nextInt();\n        StringBuilder sb=new StringBuilder();\n        int i,j,tc=0;\n        while(tc++<t) {\n            int n=in.nextInt();\n            int arr[]=new int[n];\n            for(i=0;i<n;i++)\n                arr[i]=in.nextInt();\n            int ans[]=new int[n+4];\n            ans[0]=1;\n            int pos=0;\n            sb.append(\"1\\n\");\n            for(i=1;i<n;i++){\n                if(arr[i]==arr[i-1]+1){\n                    ans[pos]=ans[pos]+1;\n                }\n                else if(arr[i]==1){\n                    pos++;\n                    ans[pos]=1;\n                }\n                else{\n                    while(ans[pos]!=arr[i]-1)\n                        pos--;\n                    ans[pos]=ans[pos]+1;\n                }\n                for(j=0;j<=pos;j++){\n                    if(j<pos)\n                        sb.append(ans[j]).append(\".\");\n                    else\n                        sb.append(ans[j]).append(\"\\n\");\n                }\n\n            }\n        }\n        System.out.println(sb);\n    }\n}\n\nclass Node {\n    int setroot, dist;\n    public Node(int setroot, int dist){\n        this.setroot = setroot;\n        this.dist = dist;\n    }\n    @Override\n    public String toString() {\n        return String.format(setroot + \", \" + dist);\n    }\n}\n\nclass FastReader {\n\n    byte[] buf = new byte[2048];\n    int index, total;\n    InputStream in;\n\n    FastReader(InputStream is) {\n        in = is;\n    }\n\n    int scan() throws IOException {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) {\n                return -1;\n            }\n        }\n        return buf[index++];\n    }\n\n    String next() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan()) ;\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    int nextInt() throws IOException {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan()) ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n\n    long nextLong() throws IOException {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan()) ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tSystem.out.println(input.nextInt() / 2 + 1);\n\t}\n}", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "\nimport java.awt.Point;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt() - 1;\n        Point[] A = new Point[n];\n        for (int i = 0; i < n; i++)\n            A[i] = new Point(in.nextInt(), in.nextInt());\n        Arrays.sort(A, new Comparator<Point>() {\n            public int compare(Point o1, Point o2) {\n                if (o1.x != o2.x)\n                    return o2.x - o1.x;\n                if (o1.y != o2.y)\n                    return o1.y - o2.y;\n                return 0;\n            }\n        });\n        int i = k;\n        int j = k;\n        while (i >= 0 && A[i].x == A[k].x && A[i].y == A[k].y)\n            i--;\n        while (j < n && A[j].x == A[k].x && A[j].y == A[k].y)\n            j++;\n        System.out.println(j - i - 1);\n    }\n}\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n\npublic class a{ \n     static int[] count,count1,count2;\n     static Node[] nodes;\n     static long[] arr;\n     static int[] dp,arrInt,darrInt;\n     static char[] ch,ch1;\n     static long[] darr,farr;\n     static char[][] mat,mat1;\n     static int[][] space;\n     static boolean[][] vis;\n     static long x,h;\n     static long maxl;\n     static double dec;\n     static long mx = (long)1e10;\n     static String s,s1,s2,s3,s4;\n     static long minl;\n     static int start_row;\n     static int start_col;     \n     static int end_row;     \n     static int end_col;     \n     static long mod = 998244353;\n     // static int minl = -1;\n     // static long n;\n     static int n,n1,n2,q,r1,c1,r2,c2;\n     static long a;\n     static long b;\n     static long c;\n     static long d;\n     static long y,z;\n     static int m;\n     static long k;\n     static FastScanner sc;\n     static String[] str,str1;\n     static Set<Integer> set,set1,set2;\n     static SortedSet<Long> ss;\n     static List<Long> list,list1,list2,list3;\n     static PriorityQueue<Integer> pq,pq1;\n     static LinkedList<Node> ll;\n     static Map<Integer,List<Integer>> map1;\n     static Map<Long,Integer> map;\n     static StringBuilder sb,sb1,sb2;\n     static int index;\n     static long[] sum;\n     static int[] dx = {0,-1,0,1,-1,1,-1,1};\n     static int[] dy = {-1,0,1,0,-1,-1,1,1};\n\n     // public static void solve(){\n\n     //    FastScanner sc = new FastScanner();\n     //    // int t = sc.nextInt();\n     //    int t = 1;\n     //    for(int tt = 0 ; tt < t ; tt++){\n\n     //        // s = sc.next();\n     //        // s1 = sc.next();\n\n     //        n = sc.nextInt();\n     //        // m = sc.nextInt();\n     //        // sb = new StringBuilder();\n     //        // map = new HashMap<>();\n     //        // q = sc.nextInt();\n     //        k = sc.nextLong();\n     //        // ch = sc.next().toCharArray();\n     //        // boolean ans = false;\n     //        // int charge = n;\n     //        // int prev = 0;\n\n     //        // count = new int[8];\n           \n     //        m = sc.nextInt();\n     //        long ans = 0;\n     //        long added = 0;\n     //        for(int j = 0 ; j < m ; j++){\n\n     //            int l = sc.nextInt();\n     //            int r = sc.nextInt();\n     //            long a = sc.nextLong();\n     //            added += (r-l+1);\n     //            ans += (r-l+1)*(a*a);\n\n     //        }\n\n     //        ans += (n-added)*(k*k);\n     //        System.out.println(ans);\n     //    }\n        \n     // }\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n  \n     public static void solve(){\n\n        long stones =0 ;\n        for(int i = 0 ;  i < n ; i++){\n            if(ch[i] == '+'){\n                stones += 1;\n            }\n            else{\n                stones -= 1;\n            }\n            if(stones < 0)\n                stones = 0;\n        }\n\n        System.out.println(stones);\n\n     }\n        \n     public static void main(String[] args) {\n\n            sc = new FastScanner();\n            // Scanner sc = new Scanner(System.in);\n            // int t = sc.nextInt();\n            int t = 1;\n            // int l = 1;\n            while(t > 0){\n                \n                // n = sc.nextInt();\n                // n = sc.nextLong();\n                // k = sc.nextLong();\n                // a = sc.nextLong();\n                // b = sc.nextLong();\n                // c = sc.nextLong();\n                // d = sc.nextLong();\n\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                \n                // n = sc.nextLong();\n                n = sc.nextInt();\n                // n = 3;\n                // n1 = sc.nextInt();\n\n                // m = sc.nextInt();\n                // q = sc.nextInt();\n\n                // k = sc.nextLong();\n                // s = sc.next();\n\n                ch = sc.next().toCharArray();\n                // ch1 = sc.next().toCharArray();\n\n                // arr = new long[n];\n                // for(int i = 0 ; i < n ; i++){\n                //     arr[i] = sc.nextLong();\n                // }\n\n                // arrInt = new int[n];\n                // for(int i = 0 ; i < n ; i++){\n                //     arrInt[i] = sc.nextInt();\n                // }\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // ch = sc.next().toCharArray();\n                // m = n;\n                // darr = new long[m];\n                // for(int i = 0 ; i < m ; i++){\n                //     darr[i] = sc.nextLong();\n                // }\n\n                // m = n;\n                // darrInt = new int[m];\n                // for(int i = 0 ; i < m ; i++){\n                //     darrInt[i] = sc.nextInt();\n                // }\n\n                // farr = new int[n];\n                // for(int i = 0; i < n ; i++){\n                //     farr[i] = sc.nextInt();\n                // }\n\n                // mat = new int[n][n];\n                // for(int i = 0 ; i < n ; i++){\n                //     for(int j = 0 ;  j < n ; j++){\n                //         mat[i][j] = sc.nextInt();\n                //     }\n                // }\n\n                // m = n;\n                // mat = new char[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     String s = sc.next();\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat[i][j] = s.charAt(j);\n                //     }\n                // }\n\n                // m = n;\n                // mat1 = new char[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     String s = sc.next();\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat1[i][j] = s.charAt(j);\n                //     }\n                // }\n\n                // str = new String[n];\n                // for(int i = 0 ; i < n ; i++)\n                //     str[i] = sc.next();\n\n                // nodes = new Node[n];\n                // for(int i = 0 ; i < n ;i++)\n                //     nodes[i] = new Node(sc.nextInt(),(i));\n\n                // System.out.println(solve()?\"YES\":\"NO\");\n                 solve();       \n                 // System.out.println(solve());\n                 t -= 1;\n            }\n\n     }\n\n     // public static dfs(int i){\n\n     //    if(count[i] == 1)\n     //        return;\n     //    list = map.get(i);\n     //    for(Integer j : list){\n     //        if(j == i)\n     //            continue;\n     //        dfs(j);\n     //    }\n     // }\n\n    public static int log(long n,long base){\n\n         if(n == 0 || n == 1)\n             return 0;\n\n         if(n == base)\n             return 1;\n\n         double num = Math.log(n);\n         double den = Math.log(base);\n\n         if(den == 0)\n             return 0;\n\n         return (int)(num/den);\n     }\n\n    public static boolean isPrime(long n) { \n    // Corner cases \n        if (n <= 1)  \n            return false; \n\n        if (n <= 3)  \n            return true; \n      \n        // This is checked so that we can skip  \n        // middle five numbers in below loop \n        if (n%2 == 0 || n%3 == 0) \n            return false; \n      \n        for (int i=5; i*i<=n; i=i+6) \n            if (n%i == 0 || n%(i+2) == 0) \n               return false; \n      \n        return true; \n    } \n\n     public static long gcd(long a,long b){\n\n        if(b%a == 0){\n            return a;\n        }\n        return gcd(b%a,a);\n\n     }\n\n     public static void swap(int i,int j){\n         long temp = arr[j];\n         arr[j] = arr[i];\n         arr[i] = temp;\n     } \n\n    static final Random random=new Random();\n\n    static void ruffleSortLong(long[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            long temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSortInt(int[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            int temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n    \n    static void ruffleSortChar(char[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            char temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class Node{\n        Integer first;\n        Integer second;\n        Node(Integer f,Integer s){\n            this.first = f;\n            this.second = s;\n        }\n    }\n\n     static class FastScanner {\n\n                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n                StringTokenizer st=new StringTokenizer(\"\");\n                String next() {\n                        while (!st.hasMoreTokens())\n                                try {\n                                        st=new StringTokenizer(br.readLine());\n                                } catch (IOException e) {\n                                        e.printStackTrace();\n                                }\n                        return st.nextToken();\n                }\n                \n                int nextInt() {\n                        return Integer.parseInt(next());\n                }\n                int[] readArray(int n) {\n                        int[] a=new int[n];\n                        for (int i=0; i<n; i++) a[i]=nextInt();\n                        return a;\n                }\n                long nextLong() {\n                        return Long.parseLong(next());\n                }\n        }\n\n}", "complexity": "linear", "problem": "1159_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\n    StreamTokenizer in;\n    PrintWriter out;\n    public static void main(String[] args) throws IOException\n    {\n        new Main().run();\n    }\n    public void run() throws IOException\n    {\n    //\tin =new StreamTokenizer(new BufferedReader(new FileReader(\"input.txt\")));\n    //  out = new PrintWriter(new FileWriter(\"output.txt\"));\n\n        in =new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t   out = new PrintWriter(new OutputStreamWriter(System.out));\n             solve();\n        out.flush();\n        \n    }\n    public int nextInt() throws IOException\n    {\n        in.nextToken();\n        return (int) in.nval;\n    }\n    boolean pr(int i)\n    {\n    \tif(i<4) return true;\n    \tfor(int j=2;j<Math.sqrt(i)+1;j++)\n    \t\tif(i%j==0)\n    \t\t\treturn false;\n    \treturn true;\n    }\n    public void solve() throws IOException\n    {\n    \tint n=nextInt(),k=nextInt();\n    \tint prost[]=new int[1000];\n    \tboolean now[]=new boolean[10000];\n    \tint a=0;\n    \tfor(int i=2;i!=1000;i++)\n    \t\tif(pr(i))\n    \t\t\tprost[a++]=i;\n    \tfor(int i=0;i!=a-1;i++)\n    \t{\n    \t\tif(pr(prost[i]+prost[i+1]+1))\n    \t\t\tnow[prost[i]+prost[i+1]+1]=true;\n    \t}\n    \tint answ=0;\n    \tfor(int i=0;i!=n+1;i++)\n    \t\tif(now[i])\n    \t\t\tansw++;\n    \tif(answ>=k)\n    \t\tout.print(\"YES\");\n    \telse\n    \t\tout.print(\"NO\");\n    }\n\n}", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE2 solver = new TaskE2();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE2 {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int numTests = in.nextInt();\n            for (int test = 0; test < numTests; test++) {\n                int n = in.nextInt();\n                int m = in.nextInt();\n                int[][] a = new int[n][m];\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < m; j++) {\n                        a[i][j] = in.nextInt();\n                    }\n                }\n\n                int[] maxInColumn = new int[m];\n                for (int j = 0; j < m; j++) {\n                    for (int i = 0; i < n; i++) {\n                        maxInColumn[j] = Math.max(maxInColumn[j], a[i][j]);\n                    }\n                }\n                Integer[] cols = new Integer[m];\n                for (int i = 0; i < m; i++) {\n                    cols[i] = i;\n                }\n                Arrays.sort(cols, (u, v) -> -(maxInColumn[u] - maxInColumn[v]));\n                if (m > n) {\n                    int[][] na = new int[n][n];\n                    for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < n; j++) {\n                            na[i][j] = a[i][cols[j]];\n                        }\n                    }\n                    m = n;\n                    a = na;\n                }\n\n                int[] buf = new int[n];\n                int[][] sums = new int[m][1 << n];\n                int[] sumsCur = new int[1 << n];\n                for (int j = 0; j < m; j++) {\n                    for (int shift = 0; shift < n; shift++) {\n                        for (int i = 0; i < n; i++) {\n                            buf[i] = a[(i + shift) % n][j];\n                        }\n                        for (int mask = 0; mask < 1 << n; mask++) {\n                            if (mask > 0) {\n                                int k = Integer.numberOfTrailingZeros(mask);\n                                sumsCur[mask] = sumsCur[mask ^ (1 << k)] + buf[k];\n                                sums[j][mask] = Math.max(sums[j][mask], sumsCur[mask]);\n                            }\n                        }\n                    }\n                }\n\n                int[] d = new int[1 << n];\n                int[] nd = new int[1 << n];\n                for (int j = 0; j < m; j++) {\n                    System.arraycopy(d, 0, nd, 0, d.length);\n                    for (int mask = 0; mask < 1 << n; mask++) {\n                        for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n                            nd[mask] = Math.max(nd[mask], d[mask ^ submask] + sums[j][submask]);\n                        }\n                    }\n                    int[] t = d;\n                    d = nd;\n                    nd = t;\n                }\n                int ans = 0;\n                for (int x : d) {\n                    ans = Math.max(ans, x);\n                }\n                out.println(ans);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tstatic int mod=998244353;\n\tstatic long fastpow(long n,long ti) {\n\t\t if (ti == 0) \n\t\t        return 1l;\n\t\tif(ti%2==0) {\n\t\t\tlong y=fastpow(n, ti/2);\n\t\t\tlong k=y*y;\n\t\t\tk%=mod;\n\t\t\treturn k;\n\t\t}\n\t\telse {\n\t\t\tlong y=fastpow(n, ti/2);\n\t\t\tlong k=((n*y)%mod)*y;\n\t\t\tk%=mod;\n\t\t\treturn k;\n\t\t}\n\t}\n\tstatic long modInverse(long x) {\n    \treturn fastpow(x, mod-2);\n    }\n\tstatic void main() throws Exception{\n\t\tint n=sc.nextInt();\n\t\tint[]in=sc.intArr(n);\n\t\tif(n==1) {\n\t\t\tpw.println(in[0]);\n\t\t\treturn;\n\t\t}\n\t\tlong inv2=modInverse(2);\n\t\tlong invpow2=1;\n\t\tlong es=0,as=0;\n\t\tlong ans=-1;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tas=(in[i]*invpow2+as)%mod;\n\t\t\tans=as+es;\n\t\t\tes=(es*inv2)%mod;\n\t\t\tes=(es+inv2*ans)%mod;\n\t\t\tinvpow2=(invpow2*inv2)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tans=(ans*2)%mod;\n\t\t}\n\t\tpw.println(ans);\n    }\n    public static void main(String[] args) throws Exception{\n    \tsc=new MScanner(System.in);\n    \tpw = new PrintWriter(System.out);\n        int tc=1;\n//        tc=sc.nextInt();\n        for(int i=1;i<=tc;i++) {\n//            pw.printf(\"Case #%d: \", i);\n            main();\n        }\n        pw.flush();\n    }\n    static PrintWriter pw;\n    static MScanner sc;\n    static class MScanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public MScanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n     \n        public MScanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n     \n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        public int[] intArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public long[] longArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public int[] intSortedArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public long[] longSortedArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public Integer[] IntegerArr(int n) throws IOException {\n            Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public Long[] LongArr(int n) throws IOException {\n            Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n     \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n     \n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n     \n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n     \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n     \n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n     \n        public void waitForInput() throws InterruptedException {\n            Thread.sleep(3000);\n        }\n        \n    }\n    static void sort(int[]in) {\n    \tshuffle(in);\n        Arrays.sort(in);\n    }\n    static void sort(long[]in) {\n    \tshuffle(in);\n        Arrays.sort(in);\n    }\n    static void shuffle(int[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            int tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n    static void shuffle(long[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            long tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n}", "complexity": "linear", "problem": "1009_E", "from": "CODEFORCES", "tags": "combinatorics,math,probabilities"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author caoash\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BObtainingTheString solver = new BObtainingTheString();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BObtainingTheString {\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            String s = br.nextString();\n            String t = br.nextString();\n            char[] sarr = new char[n];\n            char[] tarr = new char[n];\n            int[] sAppear = new int[26];\n            int[] tAppear = new int[26];\n            for (int i = 0; i < s.length(); i++) {\n                sarr[i] = s.charAt(i);\n                tarr[i] = t.charAt(i);\n                sAppear[s.charAt(i) - 'a']++;\n                tAppear[t.charAt(i) - 'a']++;\n            }\n            for (int i = 0; i < 26; i++) {\n                if (sAppear[i] != tAppear[i]) {\n                    pw.println(-1);\n                    pw.close();\n                }\n            }\n            ArrayList<Integer> ans = new ArrayList<Integer>();\n            for (int i = 0; i < n; i++) {\n                char curr = tarr[i];\n                for (int j = i + 1; j < n; j++) {\n                    if (sarr[j] == curr) {\n                        for (int k = j; k > i; k--) {\n                            ans.add(k);\n                            char temp = sarr[k - 1];\n                            sarr[k - 1] = sarr[k];\n                            sarr[k] = temp;\n                        }\n                        break;\n                    }\n                }\n            }\n            pw.println(ans.size());\n            for (int e : ans) {\n                pw.print(e + \" \");\n            }\n            pw.close();\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1015_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\n import java.util.*;\n public class realfast implements Runnable \n  {\n    private static final int INF = (int) 1e9;\n    long in= (long)Math.pow(10,9)+7;\n    long fac[]= new long[3000];\n    public  void solve() throws IOException \n    {\n       long a = readLong();\n       long b = readLong();\n       int val =0;\n      // int count=-1;\n       int arr[]= new int[70];\n       int arr1[]= new int[70];\n       int top=-1;\n       while(a!=0)\n       {\n        top++;\n        arr[top]=(int)(a%2);\n        a=a/2;\n       }\n       int top1=-1;\n       while(b!=0)\n       {\n         top1++;\n         arr1[top1]=(int)(b%2);\n         b=b/2;\n       }\n\n       int count =-1;\n       for(int i=arr1.length-1;i>=0;i--)\n       {\n        if(arr[i]!=arr1[i])\n        {\n             count =i;\n             break;\n        }\n       }\n\n       if(count==-1)\n        out.println(0);\n       else\n       {\n        long valo = (long)Math.pow(2,count+1)-1;\n        out.println(valo);\n       }\n    }\n    \n    public long pow(long n , long p,long m)\n    {\n         if(p==0)\n            return 1;\n        long val = pow(n,p/2,m);;\n        val= (val*val)%m;\n        if(p%2==0)\n            return val;\n        else\n            return (val*n)%m;\n    }\n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    public static void main(String[] args) {\n        new Thread(null, new realfast(), \"\", 128 * (1L << 20)).start();\n    }\n \n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private PrintWriter out;\n \n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(\"input.txt\").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            solve();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n \n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n \n    @SuppressWarnings(\"unused\")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n}\nclass edge implements Comparable<edge>{\n    int u ;\n    int v ;\n    int val;\n    edge(int u1, int v1 , int val1)\n    {\n       this.u=u1;\n       this.v=v1;\n       this.val=val1;\n    }\n    public int compareTo(edge e)\n    {\n        return this.val-e.val;\n    }\n}\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.BufferedWriter;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.TreeSet;\n\n/**\n * Actual solution is at the top, in class Solver\n */\npublic class Main implements Runnable {\n\tprivate static String[] args;\n\n\tpublic static void main(String[] args) {\n\t\tMain.args = args;\n\t\tnew Thread(null, new Main(), \"MyRunThread\", 1 << 26).start();\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tlong time_beg = -1;\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tif (args.length > 0 && args[0].equals(\"outside\")) {\n\t\t\ttime_beg = System.currentTimeMillis();\n\t\t\ttry {\n\t\t\t\tinputStream = new FileInputStream(\"IO/in.txt\");\n//\t\t\t\toutputStream = new FileOutputStream(\"IO/out.txt\");\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.err.println(e);\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n//\t\t\t\tinputStream = new FileInputStream(\"file_name\");\n//\t\t\t\toutputStream = new FileOutputStream(\"file_name\");\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.err.println(e);\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t}\n\n\t\tSolver s = new Solver();\n\t\ts.in = new InputReader(inputStream);\n\t\ts.out = new OutputWriter(outputStream);\n\t\tif (args.length > 0 && args[0].equals(\"outside\")) {\n\t\t\ts.debug = new DebugWriter(s.out);\n\t\t}\n\n\t\ts.solve();\n\t\ts.out.close();\n\n\t\tif (args.length > 0 && args[0].equals(\"outside\")) {\n\t\t\ts.debug.close();\n\t\t\tSystem.err.printf(\"*** Total time: %.3f ***\\n\", (System.currentTimeMillis() - time_beg) / 1000.0);\n\t\t}\n\t}\n}\n\nfinal class Solver {\n\tInputReader in;\n\tOutputWriter out;\n\tDebugWriter debug;\n\n\tpublic void solve() {\n\t\tint n = in.readInt();\n\t\tint[] mas = new int[n];\n\t\tint[] sorted = new int[n];\n\t\t\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tsorted[i] = mas[i] = in.readInt();\n\n\t\tRandom rnd = new Random(System.nanoTime());\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tint j = rnd.nextInt(i);\n\t\t\tint tmp = sorted[j];\n\t\t\tsorted[j] = sorted[i];\n\t\t\tsorted[i] = tmp;\n\t\t}\n\n\t\tArrays.sort(sorted);\n\n\t\tint id1 = -1;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (mas[i] != sorted[i]) {\n\t\t\t\tid1 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tint id2 = -1;\n\n\t\tfor (int i = n - 1; i >= 0; --i)\n\t\t\tif (mas[i] != sorted[i]) {\n\t\t\t\tid2 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (id1 != -1 && id2 != -1 && id1 != id2) {\n\t\t\tint tmp = mas[id1];\n\t\t\tmas[id1] = mas[id2];\n\t\t\tmas[id2] = tmp;\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (mas[i] != sorted[i]) {\n\t\t\t\tout.printLine(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\tout.printLine(\"YES\");\n\t}\n}\nclass InputReader {\n\tprivate boolean finished = false;\n\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tprivate int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int peek() {\n\t\tif (numChars == -1)\n\t\t\treturn -1;\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic long readLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic static boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tprivate String readLine0() {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint c = read();\n\t\twhile (c != '\\n' && c != -1) {\n\t\t\tif (c != '\\r')\n\t\t\t\tbuf.appendCodePoint(c);\n\t\t\tc = read();\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tpublic String readLine() {\n\t\tString s = readLine0();\n\t\twhile (s.trim().length() == 0)\n\t\t\ts = readLine0();\n\t\treturn s;\n\t}\n\n\tpublic String readLine(boolean ignoreEmptyLines) {\n\t\tif (ignoreEmptyLines)\n\t\t\treturn readLine();\n\t\telse\n\t\t\treturn readLine0();\n\t}\n\n\tpublic BigInteger readBigInteger() {\n\t\ttry {\n\t\t\treturn new BigInteger(readString());\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t}\n\n\tpublic char readCharacter() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\treturn (char) c;\n\t}\n\n\tpublic double readDouble() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tdouble res = 0;\n\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t}\n\t\tif (c == '.') {\n\t\t\tc = read();\n\t\t\tdouble m = 1;\n\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tm /= 10;\n\t\t\t\tres += (c - '0') * m;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t}\n\t\treturn res * sgn;\n\t}\n\n\tpublic boolean isExhausted() {\n\t\tint value;\n\t\twhile (isSpaceChar(value = peek()) && value != -1)\n\t\t\tread();\n\t\treturn value == -1;\n\t}\n}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n\tpublic OutputWriter(Writer writer) {\n\t\tthis.writer = new PrintWriter(writer);\n\t}\n\n\tpublic void print(Object... objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine(Object... objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void printFormat(String format, Object... objects) {\n\t\twriter.printf(format, objects);\n\t}\n\n\n\tpublic void print(char[] objects) {\n\t\twriter.print(objects);\n\t}\n\n\tpublic void printLine(char[] objects) {\n\t\twriter.println(objects);\n\t}\n\n\tpublic void printLine(char[][] objects) {\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t}\n\n\n\tpublic void print(int[] objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine(int[] objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void printLine(int[][] objects) {\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t}\n\n\n\tpublic void print(long[] objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine(long[] objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void printLine(long[][] objects) {\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t}\n\n\n\tpublic void print(double[] objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine(double[] objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void printLine(double[][] objects) {\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t}\n\n\n\tpublic void print(byte[] objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine(byte[] objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void printLine(byte[][] objects) {\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t}\n\n\n\tpublic void print(boolean[] objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine(boolean[] objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void printLine(boolean[][] objects) {\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t}\n\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n\n\tpublic void flush() {\n\t\twriter.flush();\n\t}\n}\n\nclass DebugWriter {\n\tprivate final OutputWriter writer;\n\n\tpublic DebugWriter(OutputWriter writer) {\n\t\tthis.writer = writer;\n\t}\n\n\tprivate void printDebugMessage() {\n\t\twriter.print(\"debug:\\t\");\n\t}\n\n\n\tpublic void printLine(Object... objects) {\n\t\tflush();\n\t\tprintDebugMessage();\n\t\twriter.printLine(objects);\n\t\tflush();\n\t}\n\n\tpublic void printFormat(String format, Object... objects) {\n\t\tflush();\n\t\tprintDebugMessage();\n\t\twriter.printFormat(format, objects);\n\t\tflush();\n\t}\n\n\n\tpublic void printLine(char[] objects) {\n\t\tflush();\n\t\tprintDebugMessage();\n\t\twriter.printLine(objects);\n\t\tflush();\n\t}\n\n\tpublic void printLine(char[][] objects) {\n\t\tflush();\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t\tflush();\n\t}\n\n\n\tpublic void printLine(double[] objects) {\n\t\tflush();\n\t\tprintDebugMessage();\n\t\twriter.printLine(objects);\n\t\tflush();\n\t}\n\n\tpublic void printLine(double[][] objects) {\n\t\tflush();\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t\tflush();\n\t}\n\n\n\tpublic void printLine(int[] objects) {\n\t\tflush();\n\t\tprintDebugMessage();\n\t\twriter.printLine(objects);\n\t\tflush();\n\t}\n\n\tpublic void printLine(int[][] objects) {\n\t\tflush();\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t\tflush();\n\t}\n\n\n\tpublic void printLine(long[] objects) {\n\t\tflush();\n\t\tprintDebugMessage();\n\t\twriter.printLine(objects);\n\t\tflush();\n\t}\n\n\tpublic void printLine(long[][] objects) {\n\t\tflush();\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t\tflush();\n\t}\n\n\n\tpublic void printLine(byte[] objects) {\n\t\tflush();\n\t\tprintDebugMessage();\n\t\twriter.printLine(objects);\n\t\tflush();\n\t}\n\n\tpublic void printLine(byte[][] objects) {\n\t\tflush();\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t\tflush();\n\t}\n\n\n\tpublic void printLine(boolean[] objects) {\n\t\tflush();\n\t\tprintDebugMessage();\n\t\twriter.printLine(objects);\n\t\tflush();\n\t}\n\n\tpublic void printLine(boolean[][] objects) {\n\t\tflush();\n\t\tfor (int i = 0; i < objects.length; ++i)\n\t\t\tprintLine(objects[i]);\n\t\tflush();\n\t}\n\n\n\tpublic void flush() {\n\t\twriter.flush();\n\t}\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n}\n", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        int stage;\n        int n;\n        OutputWriter out;\n        InputReader in;\n\n        void query(int end) {\n            switch (stage) {\n            case 0:\n                out.printLine('?', 1, 1, end, n);\n                break;\n            case 1:\n                out.printLine('?', 1, 1, n, end);\n                break;\n            case 2:\n                out.printLine('?', n + 1 - end, 1, n, n);\n                break;\n            case 3:\n                out.printLine('?', 1, n + 1 - end, n, n);\n                break;\n            }\n            out.flush();\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            this.out = out = new OutputWriter(System.out);\n            this.in = in = new InputReader(System.in);\n            n = in.readInt();\n            int[] endx = new int[2];\n            int[] endy = new int[2];\n            int[] stx = new int[2];\n            int[] sty = new int[2];\n            find(endx);\n            stage++;\n            find(endy);\n            stage++;\n            find(stx);\n            for (int i = 0; i < 2; i++) {\n                stx[i] = n + 1 - stx[i];\n            }\n            stage++;\n            find(sty);\n            for (int i = 0; i < 2; i++) {\n                sty[i] = n + 1 - sty[i];\n            }\n            for (int i = 0; i < 8; i++) {\n                if (stx[i & 1] > endx[i >> 2 & 1] || sty[i >> 1 & 1] > endy[0]) {\n                    continue;\n                }\n                if (stx[1 - (i & 1)] > endx[1 - (i >> 2 & 1)] || sty[1 - (i >> 1 & 1)] > endy[1]) {\n                    continue;\n                }\n                out.printLine('?', stx[i & 1], sty[i >> 1 & 1], endx[i >> 2 & 1], endy[0]);\n                out.flush();\n                if (in.readInt() == 0) {\n                    continue;\n                }\n                out.printLine('?', stx[1 - (i & 1)], sty[1 - (i >> 1 & 1)], endx[1 - (i >> 2 & 1)], endy[1]);\n                out.flush();\n                if (in.readInt() != 0) {\n                    out.printLine(\"!\", stx[i & 1], sty[i >> 1 & 1], endx[i >> 2 & 1], endy[0], stx[1 - (i & 1)],\n                            sty[1 - (i >> 1 & 1)], endx[1 - (i >> 2 & 1)], endy[1]);\n                    out.flush();\n                    return;\n                }\n            }\n        }\n\n        private void find(int[] endx) {\n            int left = 1;\n            int right = n;\n            while (left < right) {\n                int middle = (left + right) >> 1;\n                query(middle);\n                if (in.readInt() == 2) {\n                    right = middle;\n                } else {\n                    left = middle + 1;\n                }\n            }\n            endx[0] = left;\n            left = 0;\n            right--;\n            while (left < right) {\n                int middle = (left + right + 1) >> 1;\n                query(middle);\n                if (in.readInt() == 0) {\n                    left = middle;\n                } else {\n                    right = middle - 1;\n                }\n            }\n            endx[1] = left + 1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "import java.math.*;\nimport java.text.*;\nimport java.util.*;\npublic class Main {\n\n    public static void main(String args[]) {\n        Scanner sca = new Scanner(System.in);\n        long k,n;\n        long ans;\n        long[] pw = new long[33];\n        pw[1]=4;\n        pw[0]=1;\n        for(int i=2;i<=31;i++)\n            pw[i]=pw[i-1]<<2;\n        int t;\n        t = sca.nextInt();\n        for(int cas=1;cas<=t;cas++) {\n            n = sca.nextLong();\n            k = sca.nextLong();\n            ans = n;\n            long last, path = 1;\n            for (int i = 0; ; i++) {\n                if ((pw[i + 1] - 1) / 3 > k) {\n                    ans -= i;\n                    last = k - (pw[i] - 1) / 3;\n                    break;\n                }\n                path *= 2;\n            }\n            long sp = path * 2 - 1;\n            if (ans < 0 || (ans == 0 && last > 0)) {\n                System.out.println(\"NO\");\n                continue;\n            }\n            BigInteger sq = BigInteger.valueOf(path).multiply(BigInteger.valueOf(path)).subtract(BigInteger.valueOf(sp));\n            if (ans == 1 && sq.compareTo(BigInteger.valueOf(last))==-1 && last < sp) {\n                System.out.println(\"NO\");\n                continue;\n            } else if (ans == 1 && last >= sp) {\n                ans--;\n            }\n            System.out.println(\"YES \"+ans);\n        }\n\n    }\n}", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import java.util.Scanner;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author AndrewShmig\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        String n = in.nextLine();\n\n        int a = Integer.parseInt(n);\n        int b = Integer.parseInt(n.substring(0, n.length() - 1));\n        int c = Integer.parseInt(n.substring(0, n.length() - 2) + n.charAt(n.length() - 1));\n\n        out.println(Math.max(a, Math.max(b, c)));\n    }\n}\n\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class DivRound584ProblemA {\n\tstatic FastReader sc=new FastReader();\n\t\n\tpublic static void main(String args[]) throws IOException {\n\t\tint n = sc.nextInt();\n\t\t\n\t\tint a[]=new int[n];\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=sc.nextInt();\n\t\t\n\t\tArrays.sort(a);\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(a[i]<0) continue;\n\t\t\tc=c-1;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif(a[j]<0) continue;\n\t\t\t\tif(a[j]%a[i]==0) {\n\t\t\t\t\t//System.out.println(a[i]+\" : \"+a[j]);\n\t\t\t\t\ta[j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(c);\n\t\t}\n\t\tSystem.out.println(Math.abs(c));\n\t}\n\t\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\n\npublic class C {\n\n    private static Solver solver = new Solver();\n\n    private static long m = 1000000000L + 7L;\n\n    public static void main(String[] args) throws IOException {\n        solver.withProcedure(() -> {\n            String[] input = solver.readString().split(\" \");\n            BigInteger x = new BigInteger(input[0]);\n            BigInteger k = new BigInteger(input[1]);\n\n            if (x.compareTo(BigInteger.ZERO) == 0) {\n                solver.println(\"\" + 0);\n                return;\n            }\n\n            BigInteger two = BigInteger.valueOf(2);\n\n            BigInteger mm = BigInteger.valueOf(m);\n            BigInteger binpowedK = two.modPow(k, mm);\n            BigInteger binpowedKPlusOne = two.modPow(k.add(BigInteger.ONE), mm);\n\n            BigInteger res = binpowedKPlusOne.multiply(x).subtract(binpowedK.subtract(BigInteger.ONE)).mod(mm);\n\n            if (res.compareTo(BigInteger.ZERO) < 0) {\n                res = BigInteger.ZERO;\n            }\n\n            solver.println(\"\" + res);\n        }).solve();\n    }\n\n    private static long binpow(long a, long n) {\n        a = a % m;\n\n        long res = 1L;\n        while (n > 0) {\n            if ((n & 1L) != 0)\n                res = (res * a) % m;\n\n            a = (a * a) % m;\n            n >>= 1L;\n        }\n\n        return res;\n    }\n\n\n    @FunctionalInterface\n    private interface Procedure {\n        void run() throws IOException;\n    }\n\n    private static class Solver {\n        private Procedure procedure;\n\n        private StreamTokenizer in;\n        private PrintWriter out;\n        private BufferedReader bufferedReader;\n\n        Solver() {\n            try {\n                boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n                Reader reader = oj ? new InputStreamReader(System.in) : new FileReader(\"input.txt\");\n                Writer writer = oj ? new OutputStreamWriter(System.out) : new FileWriter(\"output.txt\");\n\n                bufferedReader = new BufferedReader(reader);\n                in = new StreamTokenizer(bufferedReader);\n                out = new PrintWriter(writer);\n            } catch (Exception e) {\n                throw new RuntimeException(\"Initialization has failed\");\n            }\n        }\n\n        void solve() throws IOException {\n            procedure.run();\n        }\n\n        int readInt() throws IOException {\n            in.nextToken();\n            return (int) in.nval;\n        }\n\n        long readLong() throws IOException {\n            in.nextToken();\n            return (long) in.nval;\n        }\n\n        String readString() throws IOException {\n            return bufferedReader.readLine();\n        }\n\n        char readChar() throws IOException {\n            in.nextToken();\n            return in.sval.charAt(0);\n        }\n\n        void println(String str) {\n            out.println(str);\n            out.flush();\n        }\n\n        void print(String str) {\n            out.print(str);\n            out.flush();\n        }\n\n        Solver withProcedure(Procedure procedure) {\n            this.procedure = procedure;\n\n            return this;\n        }\n    }\n\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.*;\n\npublic class cf573 {\n    public static void main(String[] args){\n        Scanner scan=new Scanner(System.in);\n        int n=0;\n        if(scan.hasNext())\n            n=scan.nextInt();\n        TreeSet<Integer> set=new TreeSet<>();\n        for(int i=0;i<n;i++){\n            if(scan.hasNext())\n                set.add(scan.nextInt());\n        }\n        int[] arr=new int[set.size()];\n        Iterator<Integer> it=set.iterator();\n        int j=0;\n        while(it.hasNext()){\n            arr[j++]=it.next();\n        }\n        int tot=1,flag;\n        for(int i=1;i<arr.length;i++){\n            flag=0;\n            for(int k=0;k<i;k++){\n                if(arr[i]%arr[k]==0){\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0){\n                tot++;\n            }\n        }\n        System.out.println(tot);\n    }\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static final int primeCount = 452;\n    static final int[] prime = new int[primeCount];\n\n    static void build_prime() {\n        boolean[] notPrime = new boolean[3200];\n        for (int i = 2; i < 3200; i++) {\n            if (notPrime[i]) continue;\n            for (int j = i * i; j < 3200; j += i) {\n                notPrime[j] = true;\n            }\n        }\n\n        int count = 0;\n        for (int i = 2; i < 3200; i++) {\n            if (notPrime[i]) continue;\n\n            prime[count++] = i;\n        }\n    }\n\n    private static void run(Reader in, PrintWriter out) throws IOException {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = getReal(in.nextInt());\n        }\n\n        int[] pre = new int[n];\n        for (int i = 0; i < n; i++) pre[i] = -1;\n\n        TreeMap<Integer, Integer> exist = new TreeMap<>();\n        for (int i = 0; i < n; i++) {\n            Integer result = exist.get(a[i]);\n            if (result != null) {\n                pre[i] = result;\n            }\n            exist.put(a[i], i);\n        }\n\n        int[][] left = new int[m + 1][n];\n        for (int i = 0; i <= m; i++) {\n            int start = 0;\n            PriorityQueue<Integer> inSame = new PriorityQueue<>();\n            for (int j = 0; j < n; j++) {\n                if (pre[j] >= start) {\n                    inSame.add(pre[j]);\n\n                    if (inSame.size() > i) {\n                        start = inSame.poll() + 1;\n                    }\n                }\n                left[i][j] = start;\n            }\n        }\n\n        int[][] dp = new int[n][m + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= m; j++) {\n                if (j == 0) dp[i][0] = Integer.MAX_VALUE;\n                else dp[i][j] = dp[i][j - 1];\n\n                for (int k = 0; k <= j; k++) {\n                    if (left[k][i] == 0) {\n                        dp[i][j] = 1;\n                    } else {\n                        dp[i][j] = Math.min(dp[i][j], dp[left[k][i] - 1][j - k] + 1);\n                    }\n                }\n            }\n        }\n\n        out.println(dp[n - 1][m]);\n    }\n\n    static int getReal(int x) {\n        int result = 1;\n        for (int i = 0; i < primeCount; i++) {\n            if (x % prime[i] == 0) {\n                int count = 0;\n                while (x % prime[i] == 0) {\n                    count++;\n                    x /= prime[i];\n                }\n                if (count % 2 == 1) {\n                    result *= prime[i];\n                }\n            }\n        }\n        result *= x;\n        return result;\n    }\n\n    public static void main(String[] args) throws IOException {\n        Reader in = new Reader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        build_prime();\n        int t = in.nextInt();\n        for (int i = 0; i < t; i++) {\n            run(in, out);\n        }\n\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    static class Reader {\n        BufferedReader reader;\n        StringTokenizer st;\n\n        Reader(InputStreamReader stream) {\n            reader = new BufferedReader(stream, 32768);\n            st = null;\n        }\n\n        void close() throws IOException {\n            reader.close();\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        String nextLine() throws IOException {\n            return reader.readLine();\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n}", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class main{\n\n\tstatic int max = 5000+1;\n\tstatic FastReader in = new FastReader();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic int N = 18;\n\tstatic int[][] mn1 = new int[N][N]; \n\tstatic int[][] mn2 = new int[N][N];\n\tstatic int[][] dp = new int[1<<N][N];\n\tstatic int n,m;\n\t\n\tstatic void solve(){\n\t\tn = in.nextInt(); m = in.nextInt();\n\t\tint[][] a = new int[n][m];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++)a[i][j] = in.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tArrays.fill(mn1[i],Integer.MAX_VALUE);\n\t\t\tArrays.fill(mn2[i],Integer.MAX_VALUE);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\tmn1[i][j] = Math.min(mn1[i][j],Math.abs(a[i][k]-a[j][k]));\n\t\t\t\t\tif(k<=m-2)\n\t\t\t\t\t\tmn2[i][j] = Math.min(mn2[i][j],Math.abs(a[i][k]-a[j][k+1]));\n\t\t\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int x=0;x<1<<n;x++)Arrays.fill(dp[x],-1);\n\t\t\tfor(int j=0;j<n;j++)dp[1<<j][j] = 0;\n\t\t\tdp[1<<i][i] = Integer.MAX_VALUE;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tans = Math.max(ans,Math.min(mn2[j][i],calc((1 << n) - 1, j)));\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tstatic int calc(int mask, int v){\n\t\tif (dp[mask][v] != -1)\n\t\t\treturn dp[mask][v];\n\t\tdp[mask][v] = 0;\n\t\tfor(int u=0;u<n;u++) if (v != u && (((mask >> u) & 1)>0))\n\t\t\tdp[mask][v] = Math.max(dp[mask][v], Math.min(mn1[u][v], calc(mask ^ (1 << v), u)));\n\t\treturn dp[mask][v];\n\t}\n\n\n\tpublic static void main(String[] args){\n\t\tsolve();\n\t\tout.close();\n\t}\t\n\n\tstatic class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next(){\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try{   \n                str = br.readLine();\n            }catch (IOException e){\n                e.printStackTrace();\n            }  \n            return str;\n        }\n        int nextInt(){return Integer.parseInt(in.next());}\n    \tlong nextLong(){return Long.parseLong(in.next());}\n    \tdouble nextDouble(){return Double.parseDouble(in.next());}\n    }\n}\n\n\n\n\n// |xvcxv|vcv[cvcvc|cxv||]vcvx:v|c|vxc|[|cvx:cxvx||||]", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class ProblemF_2 {\n\n    public static InputStream inputStream = System.in;\n\n    public static OutputStream outputStream = System.out;\n\n    public static void main(String[] args) {\n        MyScanner scanner = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        int n = scanner.nextInt();\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(scanner.nextInt());\n        }\n\n        Map<Integer, List<Pair<Integer, Integer>>> map = new HashMap<>();\n        for (int i = n - 1; i >= 0; i--) {\n            int x = 0;\n            for (int j = i; j >= 0; j--) {\n                x = x + list.get(j);\n                if (!map.containsKey(x)) {\n                    map.put(x, new ArrayList<>());\n                }\n                map.get(x).add(new Pair<>(j + 1, i + 1));\n            }\n        }\n\n        List<Pair<Integer, Integer>> ans = new ArrayList<>();\n        for (Map.Entry<Integer, List<Pair<Integer, Integer>>> entry : map.entrySet()) {\n            List<Pair<Integer, Integer>> segments = entry.getValue();\n            Collections.reverse(segments);\n            List<Pair<Integer, Integer>> result = new ArrayList<>();\n            result.add(segments.get(0));\n            for (int i = 1; i < segments.size(); i++) {\n                if (segments.get(i).first > result.get(result.size() - 1).second) {\n                    result.add(segments.get(i));\n                }\n            }\n            if (result.size() > ans.size()) {\n                ans = result;\n            }\n        }\n\n        out.println(ans.size());\n        for (Pair<Integer, Integer> pair : ans) {\n            out.println(pair.first + \" \" + pair.second);\n        }\n\n\n\n        out.flush();\n    }\n\n    private static class MyScanner {\n        private BufferedReader bufferedReader;\n        private StringTokenizer stringTokenizer;\n\n        private MyScanner(InputStream inputStream) {\n            bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        private String next() {\n            while (stringTokenizer == null || !stringTokenizer.hasMoreElements()) {\n                try {\n                    stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return stringTokenizer.nextToken();\n        }\n\n        private int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        private long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        private double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        private String nextLine() {\n            String str = \"\";\n            try {\n                str = bufferedReader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    private static class Pair<F, S> {\n\n        private F first;\n\n        private S second;\n\n        public Pair() {}\n\n        public Pair(F first, S second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.io.*;\n\n\npublic class First {\n    StreamTokenizer in;\n    PrintWriter out;\n\n    int nextInt() throws IOException {\n        in.nextToken();\n        return (int)in.nval;\n    }\n\n    long nextLong() throws IOException {\n        in.nextToken();\n        return (long) in.nval;\n    }\n\n    String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n\n\n    void run() throws IOException {\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    void solve() throws IOException {\n        int n = nextInt(), k = nextInt(), sum = 0, count = 0;\n        String str = nextString();\n        char[] arr = str.toCharArray();\n        boolean[] bool = new boolean[26];\n        for(char ch: arr){\n            bool[((int)ch)-97] = true;\n        }\n        for(int i = 0; i < 26; i++){\n            if(bool[i]){\n                sum += i+1;\n                count++;\n                i += 1;\n            }\n            if(count == k) break;\n        }\n        if(count == k) out.println(sum);\n        else out.println(-1);\n    }\n\n    public static void main(String[] args) throws IOException {\n        new First().run();\n    }\n}", "complexity": "linear", "problem": "1011_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.*;\nimport java.math.*;\npublic class Main {\n    public void dfs(ArrayList<Integer>[] graph,int[] visited,int source) {\n        \n    }\n    public static void main(String[] args) throws Exception{\n        Reader.init(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        Main mm =new Main();\n        int n=Reader.nextInt();\n        int m=Reader.nextInt();\n        String s=Reader.next();\n        int[][] count=new int[m][m];\n        for(int i=1;i<n;i++) {\n            count[s.charAt(i)-'a'][s.charAt(i-1)-'a']++;\n            count[s.charAt(i-1)-'a'][s.charAt(i)-'a']++;\n        }\n        int[] dp=new int[1<<m];\n        Arrays.fill(dp, Integer.MAX_VALUE/10);\n        for(int i=0;i<m;i++) {\n            dp[1<<i]=0;\n        }\n        for(int i=0;i<(1<<m);i++) {\n            int extra=0;\n            for(int j=0;j<m;j++) {\n                if((i&(1<<j))>0) {\n                for(int k=0;k<m;k++) {\n                    if(j!=k &&  (i&(1<<k))==0) {\n                        extra+=count[j][k];\n                    }\n                }\n               }\n            }\n            for(int j=0;j<m;j++) {\n                if((i&(1<<j))==0) {\n                    dp[i|(1<<j)]=Math.min(dp[i|(1<<j)], dp[i]+extra);\n                }\n            }\n        }\n        out.println(dp[(1<<m)-1]);\n        out.close();\n}\n}\nclass Reader {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n    /** call this method to initialize reader for InputStream */\n    static void init() throws IOException {\n         reader = new BufferedReader(\n                 new FileReader(\"input.txt\"));\n    tokenizer = new StringTokenizer(\"\");\n    }\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n    /** get next word */\n    static String nextLine() throws IOException{\n        return reader.readLine();\n    }\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong( next() );\n    }\n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n}", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport static java.lang.Math.*;\n\n// Solution is at the bottom of code\n\npublic class A implements Runnable{\n\t\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tBufferedReader in;\n\tOutputWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\t\n\tpublic static void main(String[] args){\n\t\tnew Thread(null, new A(), \"\", 128 * (1L << 20)).start();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid init() throws FileNotFoundException{\n\t\tLocale.setDefault(Locale.US);\n\t\t\n\t\tif (ONLINE_JUDGE){\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new OutputWriter(System.out);\n\t\t}else{\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new OutputWriter(\"output.txt\");\n\t\t}\n\t}\n\t\n\t////////////////////////////////////////////////////////////////\n\t\n\tlong timeBegin, timeEnd;\n\n\tvoid time(){\n\t\ttimeEnd = System.currentTimeMillis();\n\t\tSystem.err.println(\"Time = \" + (timeEnd - timeBegin));\n\t}\n\t\n\tvoid debug(Object... objects){\n\t\tif (ONLINE_JUDGE){\n\t\t\tfor (Object o: objects){\n\t\t\t\tSystem.err.println(o.toString());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tpublic void run(){\n\t\ttry{\n\t\t\ttimeBegin = System.currentTimeMillis();\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\t\n\t\t\tinit();\n\t\t\tsolve();\n\t\t\t\n\t\t\tout.close();\n\t\t\ttime();\n\t\t}catch (Exception e){\n\t\t\te.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tString delim = \" \";\n\t\n\tString readString() throws IOException{\n\t\twhile(!tok.hasMoreTokens()){\n\t\t\ttry{\n\t\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t\t}catch (Exception e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn tok.nextToken(delim);\n\t}\n\t\n\tString readLine() throws IOException{\n\t\treturn in.readLine();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tfinal char NOT_A_SYMBOL = '\\0';\n\t\n\tchar readChar() throws IOException{\n\t\tint intValue = in.read();\n\t\t\n\t\tif (intValue == -1){\n\t\t\treturn NOT_A_SYMBOL;\n\t\t}\n\t\t\n\t\treturn (char) intValue;\n\t}\n\t\n\tchar[] readCharArray() throws IOException{\n\t\treturn readLine().toCharArray();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tint readInt() throws IOException {\n\t\treturn Integer.parseInt(readString());\n\t}\n\t\n\tint[] readIntArray(int size) throws IOException {\n\t\tint[] array = new int[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readInt();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\tint[] readSortedIntArray(int size) throws IOException {\n\t\tInteger[] array = new Integer[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = readInt();\n\t\t}\n\t\tArrays.sort(array);\n\t\t\n\t\tint[] sortedArray = new int[size];\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tsortedArray[index] = array[index];\n\t\t}\n\t\t\n\t\treturn sortedArray;\n\t}\n\t\n\tint[] readIntArrayWithDecrease(int size) throws IOException {\n\t\tint[] array = readIntArray(size);\n\t\t\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tarray[i]--;\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tint[][] readIntMatrix(int rowsCount, int columnsCount) throws IOException {\n\t\tint[][] matrix = new int[rowsCount][];\n\t\t\n\t\tfor (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n\t\t\tmatrix[rowIndex] = readIntArray(columnsCount);\n\t\t}\n\t\t\n\t\treturn matrix;\n\t}\n\t\n\tint[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) throws IOException {\n\t\tint[][] matrix = new int[rowsCount][];\n\t\t\n\t\tfor (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n\t\t\tmatrix[rowIndex] = readIntArrayWithDecrease(columnsCount);\n\t\t}\n\t\t\n\t\treturn matrix;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tlong readLong() throws IOException{\n\t\treturn Long.parseLong(readString());\n\t}\n\t\n\tlong[] readLongArray(int size) throws IOException{\n\t\tlong[] array = new long[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readLong();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\n\tdouble readDouble() throws IOException{\n\t\treturn Double.parseDouble(readString());\n\t}\n\t\n\tdouble[] readDoubleArray(int size) throws IOException{\n\t\tdouble[] array = new double[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readDouble();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\t\n\tBigInteger readBigInteger() throws IOException {\n\t\treturn new BigInteger(readString());\n\t}\n\t\n\tBigDecimal readBigDecimal() throws IOException {\n\t\treturn new BigDecimal(readString());\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tPoint readPoint() throws IOException{\n\t\tint x = readInt();\n\t\tint y = readInt();\n\t\treturn new Point(x, y);\n\t}\n\t\n\tPoint[] readPointArray(int size) throws IOException{\n\t\tPoint[] array = new Point[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readPoint();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tList<Integer>[] readGraph(int vertexNumber, int edgeNumber)\n\tthrows IOException{\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<Integer>[] graph = new List[vertexNumber];\n\t\t\n\t\tfor (int index = 0; index < vertexNumber; ++index){\n\t\t\tgraph[index] = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\twhile (edgeNumber-- > 0){\n\t\t\tint from = readInt() - 1;\n\t\t\tint to = readInt() - 1;\n\t\t\t\n\t\t\tgraph[from].add(to);\n\t\t\tgraph[to].add(from);\n\t\t}\n\t\t\n\t\treturn graph;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class IntIndexPair {\n\t\t\n\t\tstatic Comparator<IntIndexPair> increaseComparator = new Comparator<A.IntIndexPair>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {\n\t\t\t\tint value1 = indexPair1.value;\n\t\t\t\tint value2 = indexPair2.value;\n\t\t\t\t\n\t\t\t\tif (value1 != value2) return value1 - value2;\n\t\t\t\t\n\t\t\t\tint index1 = indexPair1.index;\n\t\t\t\tint index2 = indexPair2.index;\n\t\t\t\t\n\t\t\t\treturn index1 - index2;\n\t\t\t}\n\t\t};\n\t\t\n\t\tstatic Comparator<IntIndexPair> decreaseComparator = new Comparator<A.IntIndexPair>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {\n\t\t\t\tint value1 = indexPair1.value;\n\t\t\t\tint value2 = indexPair2.value;\n\t\t\t\t\n\t\t\t\tif (value1 != value2) return -(value1 - value2);\n\t\t\t\t\n\t\t\t\tint index1 = indexPair1.index;\n\t\t\t\tint index2 = indexPair2.index;\n\t\t\t\t\n\t\t\t\treturn index1 - index2;\n\t\t\t}\n\t\t};\n\t\t\n\t\tint value, index;\n\n\t\tpublic IntIndexPair(int value, int index) {\n\t\t\tsuper();\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\t\t\n\t\t\n\t\tpublic int getRealIndex() {\n\t\t\treturn index + 1;\n\t\t}\n\t}\n\t\n\tIntIndexPair[] readIntIndexArray(int size) throws IOException {\n\t\tIntIndexPair[] array = new IntIndexPair[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = new IntIndexPair(readInt(), index);\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class OutputWriter extends PrintWriter {\n\n\t\tfinal int DEFAULT_PRECISION = 12;\n\t\t\n\t\tprotected int precision;\n\t\tprotected String format, formatWithSpace;\n\t\t\n\t\t{\n\t\t\tprecision = DEFAULT_PRECISION;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tpublic OutputWriter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\n\t\tpublic OutputWriter(String fileName) throws FileNotFoundException {\n\t\t\tsuper(fileName);\n\t\t}\n\t\t\n\t\tpublic int getPrecision() {\n\t\t\treturn precision;\n\t\t}\n\n\t\tpublic void setPrecision(int precision) {\n\t\t\tprecision = max(0, precision);\n\t\t\tthis.precision = precision;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tprivate String createFormat(int precision){\n\t\t\treturn \"%.\" + precision + \"f\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void print(double d){\n\t\t\tprintf(format, d);\n\t\t}\n\t\t\n\t\tpublic void printWithSpace(double d){\n\t\t\tprintf(formatWithSpace, d);\n\t\t}\n\n\t\tpublic void printAll(double...d){\n\t\t\tfor (int i = 0; i < d.length - 1; ++i){\n\t\t\t\tprintWithSpace(d[i]);\n\t\t\t}\n\t\t\t\n\t\t\tprint(d[d.length - 1]);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void println(double d){\n\t\t\tprintlnAll(d);\n\t\t}\n\t\t\n\t\tpublic void printlnAll(double... d){\n\t\t\tprintAll(d);\n\t\t\tprintln();\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; \n\tstatic final int[][] steps8 = {\n\t\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1},\n\t\t\t{-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n\t};\n\t\n\tstatic final boolean check(int index, int lim){\n\t\treturn (0 <= index && index < lim);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final boolean checkBit(int mask, int bit){\n\t\treturn (mask & (1 << bit)) != 0;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final long getSum(int[] array) {\n\t\tlong sum = 0;\n\t\tfor (int value: array) {\n\t\t\tsum += value;\n\t\t}\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tstatic final Point getMinMax(int[] array) {\n\t\tint min = array[0];\n\t\tint max = array[0];\n\t\t\n\t\tfor (int index = 0, size = array.length; index < size; ++index, ++index) {\n\t\t\tint value = array[index];\n\t\t\t\n\t\t\tif (index == size - 1) {\n\t\t\t\tmin = min(min, value);\n\t\t\t\tmax = max(max, value);\n\t\t\t} else {\n\t\t\t\tint otherValue = array[index + 1];\n\t\t\t\t\n\t\t\t\tif (value <= otherValue) {\n\t\t\t\t\tmin = min(min, value);\n\t\t\t\t\tmax = max(max, otherValue);\n\t\t\t\t} else {\n\t\t\t\t\tmin = min(min, otherValue);\n\t\t\t\t\tmax = max(max, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new Point(min, max);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid solve() throws IOException {\n\t\tint w = readInt();\n\t\tint h = readInt();\n\t\t\n\t\tTreeSet<Integer> xCuts = new TreeSet<Integer>();\n\t\txCuts.add(0);\n\t\txCuts.add(w);\n\t\t\n\t\tTreeSet<Integer> yCuts = new TreeSet<Integer>();\n\t\tyCuts.add(0);\n\t\tyCuts.add(h);\n\t\t\n\t\tTreeMap<Integer, Integer> wMultiSet = new TreeMap<Integer, Integer>();\n\t\tTreeMap<Integer, Integer> hMultiSet = new TreeMap<Integer, Integer>();\n\t\t\n\t\tinc(wMultiSet, w);\n\t\tinc(hMultiSet, h);\n\t\t\n\t\tint n = readInt();\n\t\twhile (n --> 0) {\n\t\t\tString type = readString();\n\t\t\tint coordinate = readInt();\n\t\t\t\n\t\t\tif (type.equals(\"H\")) {\n\t\t\t\tint y = coordinate;\n\t\t\t\t\n\t\t\t\tint leftY = yCuts.floor(y);\n\t\t\t\tint rightY = yCuts.ceiling(y);\n\t\t\t\t\n\t\t\t\tint delta = rightY - leftY;\n\t\t\t\tdec(hMultiSet, delta);\n\t\t\t\t\n\t\t\t\tyCuts.add(y);\n\t\t\t\tinc(hMultiSet, y - leftY);\n\t\t\t\tinc(hMultiSet, rightY - y);\n\t\t\t} else {\n\t\t\t\tint x = coordinate;\n\t\t\t\t\n\t\t\t\tint leftX = xCuts.floor(x);\n\t\t\t\tint rightX = xCuts.ceiling(x);\n\t\t\t\t\n\t\t\t\tint delta = rightX - leftX;\n\t\t\t\tdec(wMultiSet, delta);\n\t\t\t\t\n\t\t\t\txCuts.add(x);\n\t\t\t\tinc(wMultiSet, x - leftX);\n\t\t\t\tinc(wMultiSet, rightX - x);\n\t\t\t}\n\t\t\t\n\t\t\tlong maxWDelta = wMultiSet.lastKey();\n\t\t\tlong maxHDelta = hMultiSet.lastKey();\n\t\t\t\n\t\t\tout.println(maxWDelta * maxHDelta);\n\t\t}\n\t}\n\t\n\tvoid inc(Map<Integer, Integer> multiSet, int value) {\n\t\tInteger count = multiSet.get(value);\n\t\tif (count == null) {\n\t\t\tmultiSet.put(value, 1);\n\t\t} else {\n\t\t\tmultiSet.put(value, count + 1);\n\t\t}\n\t}\n\t\n\tvoid dec(Map<Integer, Integer> multiSet, int value) {\n\t\tInteger count = multiSet.get(value);\n\t\tif (count == 1) {\n\t\t\tmultiSet.remove(value);\n\t\t} else {\n\t\t\tmultiSet.put(value, count - 1);\n\t\t}\n\t}\n}\n\n", "complexity": "nlogn", "problem": "0528_A", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "import java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));\n    String line = stdin.readLine();\n    int n = Integer.parseInt(line);\n    \n    if (n >= 0) {\n      System.out.println(n);\n    } else if (n > -10) {\n      System.out.println(0);\n    } else {\n      String sa = line.substring(0, line.length() - 1);\n      int a = Integer.parseInt(sa);\n      String sb = line.substring(0, line.length() - 2) + line.charAt(line.length() - 1);\n      int b = Integer.parseInt(sb);\n      System.out.println(Math.max(a, b));\n    }\n  }\n}\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "\nimport java.util.Scanner;\n\npublic class CF489_C {\n\tstatic long mod = 1000000007;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tlong x = s.nextLong(), k = s.nextLong();\n\t\tif (x == 0) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tlong max = x % mod;\n\t\tlong temp = power(2, k, mod);\n\t\ttemp %= mod;\n\t\tmax = (max % mod) * (temp % mod);\n\t\tmax %= mod;\n\t\tlong min = max % mod;\n\t\tmin = mod(min - (temp - 1));\n\t\tmin %= mod;\n\t\tlong num = mod(max - min + 1);\n\t\tlong n = num % mod;\n\t\tn = (n % mod) * (min % mod + max % mod);\n\t\tn = n % mod;\n\t\tn %= mod;\n\t\tlong ans = n % mod * modInverse(num, mod);\n\t\tSystem.out.println(ans % mod);\n\n\t}\n\n\tstatic long modInverse(long a, long m) {\n\t\tlong m0 = m;\n\t\tlong y = 0, x = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\twhile (a > 1) {\n\t\t\t// q is quotient\n\t\t\tlong q = a / m;\n\t\t\tlong t = m;\n\n\t\t\t// m is remainder now, process same as\n\t\t\t// Euclid's algo\n\t\t\tm = a % m;\n\t\t\ta = t;\n\t\t\tt = y;\n\n\t\t\t// Update y and x\n\t\t\ty = x - q * y;\n\t\t\tx = t;\n\t\t}\n\n\t\t// Make x positive\n\t\tif (x < 0)\n\t\t\tx += m0;\n\n\t\treturn x;\n\t}\n\n\tstatic long mod(long val) {\n\t\tval %= mod;\n\t\tif (val < 0)\n\t\t\tval += mod;\n\t\treturn val;\n\t}\n\n\tstatic long power(long x, long y, long p) {\n\t\t// Initialize result\n\t\tlong res = 1;\n\n\t\t// Update x if it is more\n\t\t// than or equal to p\n\t\tx = x % p;\n\n\t\twhile (y > 0) {\n\t\t\t// If y is odd, multiply x\n\t\t\t// with result\n\t\t\tif ((y & 1) == 1)\n\t\t\t\tres = (res * x) % p;\n\n\t\t\t// y must be even now\n\t\t\t// y = y / 2\n\t\t\ty = y >> 1;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\n\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import javax.print.DocFlavor;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Round584_a {\n        public static void main(String[] args) throws Exception {\n                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n                StringTokenizer st;\n\n                int n = Integer.parseInt(br.readLine());\n                st = new StringTokenizer(br.readLine());\n                int a[] = new int[n];\n                for(int i=0 ; i<n ; i++) {\n                        a[i] = Integer.parseInt(st.nextToken());\n                }\n\n                Arrays.sort(a);\n\n                boolean vis[] = new boolean[n];\n                int count = 0;\n                for(int i=0 ; i<n ; i++) {\n                        if(!vis[i]) {\n                                for(int j=i ; j<n ; j++) {\n                                        if(!vis[j]) {\n                                                if(a[j]%a[i] == 0) {\n                                                        vis[j] = true;\n                                                }\n                                        }\n                                }\n                                count++;\n                        }\n                }\n\n                System.out.println(count);\n        }\n}\n\n/*import java.io.BufferedReader;\n        import java.io.InputStreamReader;\n        import java.util.StringTokenizer;\n\npublic class Round584_a {\n        public static void main(String[] args) throws Exception {\n                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n                StringTokenizer st;\n        }\n}*/\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.awt.*;\nimport java.math.BigInteger;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.io.*;\npublic class Main3 {\n    static PrintWriter pr;\n    static Scanner scan;\n    static BufferedReader br;\n    static StringTokenizer st;\n    public static void main(String args[]) throws Exception {\n        pr = new PrintWriter(System.out);\n        scan = new Scanner(System.in);\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int n = inputInt();\n        //char[] c = br.readLine().toCharArray();\n        int[] a = new int[n];\n        int[] b = new int[n];\n        st = new StringTokenizer(br.readLine());\n        for(int i=0;i<n;i++){\n\n            a[i]=Integer.parseInt(st.nextToken());\n            //b[i]=Integer.parseInt(st.nextToken());\n        }\n        Arrays.sort(a);\n        int ans=0;\n        for(int i=0;i<n;i++){\n            if(b[i]!=1){\n                ans++;\n                for(int j=i;j<n;j++){\n                    if(a[j]%a[i]==0){\n                        b[j]=1;\n                    }\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n\n\n    public static int inputInt() throws IOException{\n        return Integer.parseInt(br.readLine());\n    }\n\n    public static long inputLong() throws IOException{\n        return Long.parseLong(br.readLine());\n    }\n\n    public static String inputString() throws IOException{\n        return br.readLine();\n    }\n\n    public static  int[] intArray(int n) throws IOException{\n        int a[] = new int[n];\n        st = new StringTokenizer(br.readLine());\n        for(int i=0;i<n;i++){\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n        return a;\n    }\n\n    public static  long[] longArray(int n) throws IOException{\n        long a[] = new long[n];\n        st = new StringTokenizer(br.readLine());\n        for(int i=0;i<n;i++){\n            a[i] = Long.parseLong(st.nextToken());\n        }\n        return a;\n    }\n\n    public static String[] stringArray(int n) throws IOException{\n        String a[] = new String[n];\n        st = new StringTokenizer(br.readLine());\n        for(int i=0;i<n;i++){\n            a[i] = st.nextToken();\n        }\n        return a;\n    }\n\n    public static long gcd(long a,long b){\n        if(b==0){\n            return a;\n        }\n        else{\n            return gcd(b,a%b);\n        }\n    }\n\n    public long max(long a,long b,long c){\n        return Math.max(a,Math.max(b,c));\n    }\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\npublic class p1523C {\n    public static void main(String[] args) {\n        Scanner scn=new Scanner(System.in);\n        int t=scn.nextInt();\n        for(int i1=0;i1<t;i1++){\n            int n=scn.nextInt();\n            int[] arr=new int[n];\n            for(int i=0;i<n;i++){\n                arr[i]=scn.nextInt();\n            }\n            \n            ArrayList<Integer> arr3=new ArrayList<Integer>();\n            arr3.add(1);\n            System.out.println(1);\n            for(int i=1;i<n;i++){\n                if(arr[i]==1){\n                    arr3.add(1);\n                }\n                else if(arr[i]==arr[i-1]+1){\n                    arr3.remove(arr3.size()-1);\n                    arr3.add(arr[i]);\n                }\n                else{\n                    while((arr3.get(arr3.size()-1)!=arr[i]-1)){\n                        arr3.remove(arr3.size()-1);\n                    }\n                    if(arr3.size()==0){\n                        arr3.add(arr[i]);\n                    }\n                    else{\n                            arr3.remove(arr3.size()-1);\n                            arr3.add(arr[i]);\n                    }\n                }\n                for(int j=0;j<arr3.size();j++){\n                    if(j==0){\n                        System.out.print(arr3.get(0));\n                    }\n                    else{\n                        System.out.print(\".\"+\"\"+arr3.get(j));\n                    }\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.BufferedReader;\n\nimport java.io.FileReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\nimport java.util.StringTokenizer;\n\n\n\npublic class ReallyBigNumbers {\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\t\n\n\t\tlong n = sc.nextLong(), s = sc.nextLong();\n\n\t\tlong low = 0, high = n, ans = -1;\n\n\t\twhile(low <= high) {\n\n\t\t\tlong mid = low + (high - low) / 2;\n\n\t\t\tif (mid - sum(mid) >= s) {\n\n\t\t\t\tans = mid;\n\n\t\t\t\thigh = mid-1;\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t\tlow = mid+1;\n\n\t\t}\n\n\t\t\n\n\t\tout.println(ans == -1 ? 0 : n - ans + 1);\n\n\t\t\n\n\t\tout.flush();\n\n\t\tout.close();\n\n\t}\n\n\t\n\n\tstatic int sum(long n) {\n\n\t\tint sum = 0;\n\n\t\twhile(n > 0) {\n\n\t\t\tsum += n % 10;\n\n\t\t\tn /= 10;\n\n\t\t}\n\n\t\t\n\n\t\treturn sum;\n\n\t}\n\n\t\n\n\tstatic class Scanner {\n\n\t\tBufferedReader br;\n\n\t\tStringTokenizer st;\n\n\t\t\n\n\t\tpublic Scanner(FileReader f) {\n\n\t\t\tbr = new BufferedReader(f);\n\n\t\t}\n\n\n\n\t\tpublic Scanner(InputStream in) {\n\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\n\t\t}\n\n\n\n\t\tpublic String next() throws IOException {\n\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\n\t\t}\n\n\n\n\t\tpublic String nextLine() throws IOException {\n\n\t\t\treturn br.readLine();\n\n\t\t}\n\n\n\n\t\tpublic int nextInt() throws IOException {\n\n\t\t\treturn Integer.parseInt(next());\n\n\t\t}\n\n\n\n\t\tpublic long nextLong() throws IOException {\n\n\t\t\treturn Long.parseLong(next());\n\n\t\t}\n\n\n\n\t\tpublic double nextDouble() throws IOException {\n\n\t\t\treturn Double.parseDouble(next());\n\n\t\t}\n\n\n\n\t\tpublic boolean Ready() throws IOException {\n\n\t\t\treturn br.ready();\n\n\t\t}\n\n\n\n\t\tpublic void waitForInput(long time) {\n\n\t\t\tlong ct = System.currentTimeMillis();\n\n\t\t\twhile(System.currentTimeMillis() - ct < time) {};\n\n\t\t}\n\n\n\n\t}\n\n\n\n}\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport static java.lang.Math.*;\n\n// Solution is at the bottom of code\n\npublic class B implements Runnable{\n\t\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tBufferedReader in;\n\tOutputWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\t\n\tpublic static void main(String[] args){\n\t\tnew Thread(null, new B(), \"\", 128 * (1L << 20)).start();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid init() throws FileNotFoundException{\n\t\tLocale.setDefault(Locale.US);\n\t\t\n\t\tif (ONLINE_JUDGE){\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new OutputWriter(System.out);\n\t\t}else{\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new OutputWriter(\"output.txt\");\n\t\t}\n\t}\n\t\n\t////////////////////////////////////////////////////////////////\n\t\n\tlong timeBegin, timeEnd;\n\n\tvoid time(){\n\t\ttimeEnd = System.currentTimeMillis();\n\t\tSystem.err.println(\"Time = \" + (timeEnd - timeBegin));\n\t}\n\t\n\tvoid debug(Object... objects){\n\t\tif (ONLINE_JUDGE){\n\t\t\tfor (Object o: objects){\n\t\t\t\tSystem.err.println(o.toString());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tpublic void run(){\n\t\ttry{\n\t\t\ttimeBegin = System.currentTimeMillis();\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\t\n\t\t\tinit();\n\t\t\tsolve();\n\t\t\t\n\t\t\tout.close();\n\t\t\ttime();\n\t\t}catch (Exception e){\n\t\t\te.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tString delim = \" \";\n\t\n\tString readString() throws IOException{\n\t\twhile(!tok.hasMoreTokens()){\n\t\t\ttry{\n\t\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t\t}catch (Exception e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn tok.nextToken(delim);\n\t}\n\t\n\tString readLine() throws IOException{\n\t\treturn in.readLine();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tfinal char NOT_A_SYMBOL = '\\0';\n\t\n\tchar readChar() throws IOException{\n\t\tint intValue = in.read();\n\t\t\n\t\tif (intValue == -1){\n\t\t\treturn NOT_A_SYMBOL;\n\t\t}\n\t\t\n\t\treturn (char) intValue;\n\t}\n\t\n\tchar[] readCharArray() throws IOException{\n\t\treturn readLine().toCharArray();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tint readInt() throws IOException {\n\t\treturn Integer.parseInt(readString());\n\t}\n\t\n\tint[] readIntArray(int size) throws IOException {\n\t\tint[] array = new int[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\ttry {\n\t\t\t\tarray[index] = readInt();\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.err.println(index);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\tint[] readSortedIntArray(int size) throws IOException {\n\t\tInteger[] array = new Integer[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = readInt();\n\t\t}\n\t\tArrays.sort(array);\n\t\t\n\t\tint[] sortedArray = new int[size];\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tsortedArray[index] = array[index];\n\t\t}\n\t\t\n\t\treturn sortedArray;\n\t}\n\t\n\tint[] readIntArrayWithDecrease(int size) throws IOException {\n\t\tint[] array = readIntArray(size);\n\t\t\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tarray[i]--;\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tint[][] readIntMatrix(int rowsCount, int columnsCount) throws IOException {\n\t\tint[][] matrix = new int[rowsCount][];\n\t\t\n\t\tfor (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n\t\t\tmatrix[rowIndex] = readIntArray(columnsCount);\n\t\t}\n\t\t\n\t\treturn matrix;\n\t}\n\t\n\tint[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) throws IOException {\n\t\tint[][] matrix = new int[rowsCount][];\n\t\t\n\t\tfor (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n\t\t\tmatrix[rowIndex] = readIntArrayWithDecrease(columnsCount);\n\t\t}\n\t\t\n\t\treturn matrix;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tlong readLong() throws IOException{\n\t\treturn Long.parseLong(readString());\n\t}\n\t\n\tlong[] readLongArray(int size) throws IOException{\n\t\tlong[] array = new long[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readLong();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\n\tdouble readDouble() throws IOException{\n\t\treturn Double.parseDouble(readString());\n\t}\n\t\n\tdouble[] readDoubleArray(int size) throws IOException{\n\t\tdouble[] array = new double[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readDouble();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\t\n\tBigInteger readBigInteger() throws IOException {\n\t\treturn new BigInteger(readString());\n\t}\n\t\n\tBigDecimal readBigDecimal() throws IOException {\n\t\treturn new BigDecimal(readString());\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tPoint readPoint() throws IOException{\n\t\tint x = readInt();\n\t\tint y = readInt();\n\t\treturn new Point(x, y);\n\t}\n\t\n\tPoint[] readPointArray(int size) throws IOException{\n\t\tPoint[] array = new Point[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readPoint();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tList<Integer>[] readGraph(int vertexNumber, int edgeNumber)\n\tthrows IOException{\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<Integer>[] graph = new List[vertexNumber];\n\t\t\n\t\tfor (int index = 0; index < vertexNumber; ++index){\n\t\t\tgraph[index] = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\twhile (edgeNumber-- > 0){\n\t\t\tint from = readInt() - 1;\n\t\t\tint to = readInt() - 1;\n\t\t\t\n\t\t\tgraph[from].add(to);\n\t\t\tgraph[to].add(from);\n\t\t}\n\t\t\n\t\treturn graph;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class IntIndexPair {\n\t\t\n\t\tstatic Comparator<IntIndexPair> increaseComparator = new Comparator<B.IntIndexPair>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {\n\t\t\t\tint value1 = indexPair1.value;\n\t\t\t\tint value2 = indexPair2.value;\n\t\t\t\t\n\t\t\t\tif (value1 != value2) return value1 - value2;\n\t\t\t\t\n\t\t\t\tint index1 = indexPair1.index;\n\t\t\t\tint index2 = indexPair2.index;\n\t\t\t\t\n\t\t\t\treturn index1 - index2;\n\t\t\t}\n\t\t};\n\t\t\n\t\tstatic Comparator<IntIndexPair> decreaseComparator = new Comparator<B.IntIndexPair>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {\n\t\t\t\tint value1 = indexPair1.value;\n\t\t\t\tint value2 = indexPair2.value;\n\t\t\t\t\n\t\t\t\tif (value1 != value2) return -(value1 - value2);\n\t\t\t\t\n\t\t\t\tint index1 = indexPair1.index;\n\t\t\t\tint index2 = indexPair2.index;\n\t\t\t\t\n\t\t\t\treturn index1 - index2;\n\t\t\t}\n\t\t};\n\t\t\n\t\tint value, index;\n\n\t\tpublic IntIndexPair(int value, int index) {\n\t\t\tsuper();\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\t\t\n\t\t\n\t\tpublic int getRealIndex() {\n\t\t\treturn index + 1;\n\t\t}\n\t}\n\t\n\tIntIndexPair[] readIntIndexArray(int size) throws IOException {\n\t\tIntIndexPair[] array = new IntIndexPair[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = new IntIndexPair(readInt(), index);\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class OutputWriter extends PrintWriter {\n\n\t\tfinal int DEFAULT_PRECISION = 12;\n\t\t\n\t\tprotected int precision;\n\t\tprotected String format, formatWithSpace;\n\t\t\n\t\t{\n\t\t\tprecision = DEFAULT_PRECISION;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tpublic OutputWriter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\n\t\tpublic OutputWriter(String fileName) throws FileNotFoundException {\n\t\t\tsuper(fileName);\n\t\t}\n\t\t\n\t\tpublic int getPrecision() {\n\t\t\treturn precision;\n\t\t}\n\n\t\tpublic void setPrecision(int precision) {\n\t\t\tprecision = max(0, precision);\n\t\t\tthis.precision = precision;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tprivate String createFormat(int precision){\n\t\t\treturn \"%.\" + precision + \"f\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void print(double d){\n\t\t\tprintf(format, d);\n\t\t}\n\t\t\n\t\tpublic void printWithSpace(double d){\n\t\t\tprintf(formatWithSpace, d);\n\t\t}\n\n\t\tpublic void printAll(double...d){\n\t\t\tfor (int i = 0; i < d.length - 1; ++i){\n\t\t\t\tprintWithSpace(d[i]);\n\t\t\t}\n\t\t\t\n\t\t\tprint(d[d.length - 1]);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void println(double d){\n\t\t\tprintlnAll(d);\n\t\t}\n\t\t\n\t\tpublic void printlnAll(double... d){\n\t\t\tprintAll(d);\n\t\t\tprintln();\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; \n\tstatic final int[][] steps8 = {\n\t\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1},\n\t\t\t{-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n\t};\n\t\n\tstatic final boolean check(int index, int lim){\n\t\treturn (0 <= index && index < lim);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final boolean checkBit(int mask, int bit){\n\t\treturn (mask & (1 << bit)) != 0;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final long getSum(int[] array) {\n\t\tlong sum = 0;\n\t\tfor (int value: array) {\n\t\t\tsum += value;\n\t\t}\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tstatic final Point getMinMax(int[] array) {\n\t\tint min = array[0];\n\t\tint max = array[0];\n\t\t\n\t\tfor (int index = 0, size = array.length; index < size; ++index, ++index) {\n\t\t\tint value = array[index];\n\t\t\t\n\t\t\tif (index == size - 1) {\n\t\t\t\tmin = min(min, value);\n\t\t\t\tmax = max(max, value);\n\t\t\t} else {\n\t\t\t\tint otherValue = array[index + 1];\n\t\t\t\t\n\t\t\t\tif (value <= otherValue) {\n\t\t\t\t\tmin = min(min, value);\n\t\t\t\t\tmax = max(max, otherValue);\n\t\t\t\t} else {\n\t\t\t\t\tmin = min(min, otherValue);\n\t\t\t\t\tmax = max(max, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new Point(min, max);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid solve() throws IOException {\n\t\tint n = readInt();\n\t\t\n\t\tint a = readInt();\n\t\tint b = readInt();\n\t\t\n\t\tMap<Integer, Integer> numbers = new HashMap<>();\n\t\tint[] p = readIntArray(n);\n\t\tfor (int index = 0; index < n; ++index) {\n\t\t\tnumbers.put(p[index], index);\n\t\t}\n\t\t\n\t\tSet<Integer> used = new HashSet<Integer>();\n\t\tDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\n\t\tint[] answers = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (used.contains(p[i])) continue;\n\t\t\t\n\t\t\tint leftSize = 0;\n\t\t\tfor (int number = p[i], cur = a, next = b;\n\t\t\t\t\tnumbers.containsKey(number) && !used.contains(number);\n\t\t\t\t\tnumber = cur - number, cur = (a ^ b ^ cur), next = (a ^ b ^ next)) {\n\t\t\t\tq.addFirst(number);\n\t\t\t\tused.add(number);\n\t\t\t\t\n\t\t\t\t++leftSize;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int number = b - p[i], cur = a, next = b;\n\t\t\t\t\tnumbers.containsKey(number) && !used.contains(number);\n\t\t\t\t\tnumber = cur - number, cur = (a ^ b ^ cur), next = (a ^ b ^ next)) {\n\t\t\t\tq.addLast(number);\n\t\t\t\tused.add(number);\n\t\t\t}\n\t\t\t\n\t\t\tint curColor = (leftSize & 1);\n\t\t\tif ((q.size() & 1) == 1) {\n\t\t\t\tint first = q.peekFirst();\n\t\t\t\t\n\t\t\t\t// 0 - a, 1 - b\n\t\t\t\tif (curColor == 0 && (first << 1) == b\n\t\t\t\t\t\t||\n\t\t\t\t\tcurColor == 1 && (first << 1) == a) {\n\t\t\t\t\tq.poll();\n\t\t\t\t\t\n\t\t\t\t\tcurColor ^= 1;\n\t\t\t\t\t\n\t\t\t\t\tint firstIndex = numbers.get(first);\n\t\t\t\t\tanswers[firstIndex] = curColor;\n\t\t\t\t} else {\n\t\t\t\t\tint last = q.peekLast();\n\t\t\t\t\t\n\t\t\t\t\t// 0 - b, 1 - a\n\t\t\t\t\tif (curColor == 0 && (last << 1) == a\n\t\t\t\t\t\t\t||\n\t\t\t\t\t\tcurColor == 1 && (first << 1) == b) {\n\t\t\t\t\t\tq.poll();\n\t\t\t\t\t\t\n\t\t\t\t\t\tint firstIndex = numbers.get(first);\n\t\t\t\t\t\tanswers[firstIndex] = curColor;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(\"NO\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (q.size() > 0) {\n\t\t\t\tint first = q.poll();\n\t\t\t\tint second = q.poll();\n\t\t\t\t\n\t\t\t\tint firstIndex = numbers.get(first);\n\t\t\t\tint secondIndex = numbers.get(second);\n\t\t\t\t\n\t\t\t\tanswers[firstIndex] = curColor;\n\t\t\t\tanswers[secondIndex] = curColor;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(\"YES\");\n\t\tfor (int answer : answers) {\n\t\t\tout.print(answer + \" \");\n\t\t}\n\t\tout.println();\n\t}\n}\n\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class d3prac implements Runnable \n{\n\tprivate boolean console=false;\n \n\tpublic void solve(int t) \n\t{\n\t\tint i; int n=in.ni(),k=in.ni(); char a[]=in.ns().toCharArray(); int ans=Integer.MAX_VALUE; int pref[]=new int[n+1]; char s[]= {'R','G','B'};\n\t\tfor(int st=0;st<3;st++)\n\t\t{\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tpref[i]+=pref[i-1];\n\t\t\t\tif(a[i-1]!=s[(i+st)%3]) pref[i]++;\n\t\t\t\tif(i>=k) ans=Math.min(ans, pref[i]-pref[i-k]);\n\t\t\t}\n\t\t\tpref=new int[n+1];\n\t\t}\n\t\tout.println(ans);\n\t}\n\t@Override\n\tpublic void run() {\n\t\ttry {  init();  } \n\t\tcatch (FileNotFoundException e) {  e.printStackTrace();   }\n\n\t\tint t= in.ni();\n\n\t\tfor(int i=1;i<=t;i++)\n\t\t{\n\t\t\tsolve(i);\n\t\t\tout.flush(); }\n\t}\n\tprivate FastInput in;    private PrintWriter out;\n\tpublic static void main(String[] args) throws Exception {\t new d3prac().run();\t }\n\n\tprivate void init() throws FileNotFoundException {\n\t\tInputStream inputStream = System.in; \t OutputStream outputStream = System.out;\n\t\ttry {  if (!console && System.getProperty(\"user.name\").equals(\"sachan\")) {\n\t\t\toutputStream = new FileOutputStream(\"/home/sachan/Desktop/output.txt\");\n\t\t\tinputStream = new FileInputStream(\"/home/sachan/Desktop/input.txt\");   \t}\n\t\t}\tcatch (Exception ignored) {\t}\n\t\tout = new PrintWriter(outputStream); \t in = new FastInput(inputStream);\n\t}\n\tstatic class FastInput { InputStream obj;\n\tpublic FastInput(InputStream obj) {\tthis.obj = obj;\t}\n\tbyte inbuffer[] = new byte[1024];  int lenbuffer = 0, ptrbuffer = 0;\n\tint readByte() { if (lenbuffer == -1) throw new InputMismatchException();\n\tif (ptrbuffer >= lenbuffer) { ptrbuffer = 0;\n\ttry { lenbuffer = obj.read(inbuffer);  }\n\tcatch (IOException e) { throw new InputMismatchException(); } }    \n\tif (lenbuffer <= 0) return -1;return inbuffer[ptrbuffer++]; }\n\n\tString ns() { int b = skip();StringBuilder sb = new StringBuilder();\n\twhile (!(isSpaceChar(b)))\t  { sb.appendCodePoint(b);b = readByte(); }return sb.toString();}\n\n\tint ni() { int num = 0, b;boolean minus = false;\n\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n\tif (b == '-') { minus = true;b = readByte(); }\n\twhile (true) { if (b >= '0' && b <= '9') { num = num * 10 + (b - '0'); } else {\n\t\treturn minus ? -num : num; }b = readByte(); }}\n\n\tlong nl() { long num = 0;int b;boolean minus = false;\n\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n\tif (b == '-') { minus = true;b = readByte(); }\n\twhile (true) { if (b >= '0' && b <= '9') { num = num * 10L + (b - '0'); } else {\n\t\treturn minus ? -num : num; }b = readByte(); } }\n\n\tboolean isSpaceChar(int c) { return (!(c >= 33 && c <= 126)); }\n\tint skip() { int b;while ((b = readByte()) != -1 && isSpaceChar(b)) ;return b; }\n\tfloat nf() {return Float.parseFloat(ns());}\n\tdouble nd() {return Double.parseDouble(ns());}\n\tchar nc() {return (char) skip();}\n\t}\n}", "complexity": "quadratic", "problem": "1196_D1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class P_220A {\n    static final FS sc = new FS();\n    static final PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int[] a = sc.nextArray(n);\n        int[] b = new int[n];\n        System.arraycopy(a,0,b,0,n);\n        Arrays.sort(b);\n        int count = 0;\n        for(int i=0; i<n; i++){\n            if(a[i]!=b[i]) count++;\n        }\n//        System.out.println(Arrays.toString(b));\n//        System.out.println(count);\n        if((count/2==0) || (count/2==1 && count%2==0)) System.out.println(\"YES\");\n        else System.out.println(\"NO\");\n    }\n\n    static class FS {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception ignored) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int[] nextArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static FastReader s = new FastReader();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    private static int[] rai(int n) {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextInt();\n        }\n        return arr;\n    }\n\n    private static int[][] rai(int n, int m) {\n        int[][] arr = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                arr[i][j] = s.nextInt();\n            }\n        }\n        return arr;\n    }\n\n    private static long[] ral(int n) {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextLong();\n        }\n        return arr;\n    }\n\n    private static long[][] ral(int n, int m) {\n        long[][] arr = new long[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                arr[i][j] = s.nextLong();\n            }\n        }\n        return arr;\n    }\n\n    private static int ri() {\n        return s.nextInt();\n    }\n\n    private static long rl() {\n        return s.nextLong();\n    }\n\n    private static String rs() {\n        return s.next();\n    }\n\n    static long gcd(long a,long b)\n    {\n        if(b==0)\n        {\n            return a;\n        }\n        return gcd(b,a%b);\n    }\n\n    static int gcd(int a,int b)\n    {\n        if(b==0)\n        {\n            return a;\n        }\n        return gcd(b,a%b);\n    }\n\n    static boolean isPrime(int n) {\n        //check if n is a multiple of 2\n        if (n % 2 == 0) return false;\n        //if not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n    static int MOD=1000000007;\n\n    static long mpow(long base,long pow)\n    {\n        long res=1;\n        while(pow>0)\n        {\n            if(pow%2==1)\n            {\n                res=(res*base)%MOD;\n            }\n            pow>>=1;\n            base=(base*base)%MOD;\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        StringBuilder ans = new StringBuilder();\n        int t = ri();\n//        int t = 1;\n        while (t-- > 0)\n        {\n            int n=ri();\n            int[] arr=rai(n);\n\n            List<Integer> list = new ArrayList<>();\n            for(int i:arr)\n            {\n                if(i==1)\n                {\n                    list.add(i);\n                }\n                else\n                {\n                    int ind = list.size()-1;\n                    while(list.size()>0 && list.get(ind)+1!=i )\n                    {\n                        list.remove(list.size()-1);\n                        ind=list.size()-1;\n                    }\n                    if(list.size()>0)\n                    {\n                        list.remove(list.size()-1);\n                    }\n                    list.add(i);\n                }\n\n                for(int j=0;j<list.size()-1;j++)\n                {\n                    ans.append(list.get(j)).append(\".\");\n                }\n                ans.append(list.get(list.size()-1)).append(\"\\n\");\n            }\n        }\n        out.print(ans.toString());\n        out.flush();\n    }\n\n\n\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\n/*\n\n */\npublic class C455 {\n\tstatic int N;\n\tstatic final int mod = 1_000_000_007;\n\tstatic int[][] memo;\n\tstatic int[] list;\n\tpublic static void main(String[] args) {\n\t\tFS scan = new FS(System.in);\n\t\t\n\t\tN = scan.nextInt();\n\t\tlist = new int[N];\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tlist[i] = scan.next().equals(\"s\")?0:1;\n\t\t}\n\t\tif(list[N-1] == 1) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tmemo = new int[N+1][N+2];\n\t\tArrays.fill(memo[N], 1);\n\t\tint[] sum = new int[N+2];\n\t\t\n\t\tfor(int i=N-1;i>=0;i--) {\n\t\t\tsum[0] = memo[i+1][0];\n\t\t\tfor(int j=1;j<sum.length;j++) {\n\t\t\t\tsum[j] = sum[j-1] + memo[i+1][j];\n\t\t\t\tsum[j] %= mod;\n\t\t\t}\n\t\t\tfor(int j=0;j<=N;j++) {\n\t\t\t\tif (list[i]==1 && (i==0 || list[i-1]==1))\n\t\t\t\t\tmemo[i][j] = memo[i+1][j+1];\n\t\t\t\telse if(i==0 || list[i-1] == 1)\n\t\t\t\t\tmemo[i][j] = memo[i+1][j];\n\t\t\t\telse if (list[i]==1){\n//\t\t\t\t\tfor(int k=0;k<=j;k++) {\n//\t\t\t\t\t\tmemo[i][j] += memo[i+1][k+1];\n//\t\t\t\t\t}\n\t\t\t\t\tmemo[i][j] = sum[j+1] - sum[0] + mod;\n\t\t\t\t\tmemo[i][j] %= mod;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (list[i]==0) {\n\t\t\t\t\tmemo[i][j] = sum[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tfor(int i=0;i<=N;i++) {\n//\t\t\tfor(int j=0;j<=N;j++) {\n//\t\t\t\tSystem.out.print(memo[i][j]+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n//\t\tSystem.out.println();\n\t\tSystem.out.println(memo[0][0]);\n\t}\n\t\n\tprivate static class FS {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FS(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tString next(){\n\t\t\twhile(st==null||!st.hasMoreElements()){\n\t\t\t\ttry{st = new StringTokenizer(br.readLine());}\n\t\t\t\tcatch(IOException e){e.printStackTrace();}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {return Integer.parseInt(next());}\n\t\tlong nextLong() {return Long.parseLong(next());}\n\t\tdouble nextDouble() { return Double.parseDouble(next());}\n\t}\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Cf270a {\n    public static void main(String[] args) throws IOException {\n        InputStreamReader fin = new InputStreamReader(System.in);\n        Scanner scr = new Scanner(fin);\n        int n = scr.nextInt();\n        int x = 0;\n        int y = 0;\n        if (n%2 == 0) {\n            x = 4;\n            y = n - x;\n        } else {\n            x = 9;\n            y = n - x;\n        }\n        PrintWriter fout = new PrintWriter(System.out);\n        fout.print(x+\" \"+y);\n        fout.flush();\n        fout.close();\n    }\n}", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class C {\n\n\tstatic int K;\n\tstatic int sz[];\n\tstatic long vs[][];\n\tstatic long curSum[];\n\tstatic HashMap<Long, Integer> valToBucket;\n\tstatic long sum;\n\tstatic int maskIfPick[][];\n\tstatic int dp[];\n\t\n\tstatic int pickId[];\n\tstatic int newBox[];\n\tpublic static void main(String[] args) {\n\t\tFS in = new FS();\n\t\tK = in.nextInt();\n\t\tsz = new int[K];\n\t\tvalToBucket = new HashMap<Long, Integer>();\n\t\tvs = new long[K][];\n\t\tcurSum = new long[K];\n\t\tsum = 0;\n\t\tfor(int i = 0; i < K; i++) {\n\t\t\tsz[i] = in.nextInt();\n\t\t\tvs[i] = new long[sz[i]];\n\t\t\tfor(int j = 0; j < sz[i]; j++) {\n\t\t\t\tlong v = in.nextLong();\n\t\t\t\tsum += v;\n\t\t\t\tcurSum[i] += v;\n\t\t\t\tvs[i][j] = v;\n\t\t\t\tvalToBucket.put(v, i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(sum % K != 0) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tsum /= K;\n\t\tmaskIfPick = new int[K][];\n\t\t//go through if i pick each node\n\t\tfor(int i = 0; i < K; i++) {\n\t\t\tmaskIfPick[i] = new int[sz[i]];\n\t\t\tfor(int j = 0; j < sz[i]; j++) {\n\t\t\t\t\n\t\t\t\tint mask = (1<<i);\n\t\t\t\tboolean works = false;\n\t\t\t\tlong curLookfor = (sum - (curSum[i]-vs[i][j]));\n\t\t\t\twhile(true) {\n\t\t\t\t\tif(!valToBucket.containsKey(curLookfor)) break;\n\t\t\t\t\tint nextBucket = valToBucket.get(curLookfor);\n\t\t\t\t\tif(nextBucket == i) {\n\t\t\t\t\t\tworks = curLookfor == vs[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if((mask & (1<<nextBucket)) > 0) break;\n\t\t\t\t\telse {\n\t\t\t\t\t\tmask |= (1<<nextBucket);\n\t\t\t\t\t\tcurLookfor = (sum - (curSum[nextBucket]-curLookfor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(works) maskIfPick[i][j] = mask;\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(\"S= \"+sum);\n\t\tdp = new int[1<<K];\n\t\tArrays.fill(dp, -1);\n\t\tint res = go(0);\n\t\tif(res == 0) {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\tpickId = new int[K];\n\t\t\tnewBox = new int[K];\n\t\t\tArrays.fill(pickId, -1);\n\t\t\tbuildback(0);\n\t\t\tfor(int i = 0; i < K; i++) {\n\t\t\t\tSystem.out.println(vs[i][pickId[i]]+\" \"+(newBox[i]+1));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstatic void pick(int i, int j) {\n//\t\tSystem.out.println(\" Pick \"+i+\" \"+j);\n\t\tif(pickId[i] != -1) return;\n\t\tpickId[i] = j;\n\t\t\n\t\tlong curLookfor = (sum - (curSum[i]-vs[i][j]));\n\t\tint nextBucket = valToBucket.get(curLookfor);\n\t\tnewBox[nextBucket] = i;\n\t\tfor(int k = 0; k < sz[nextBucket]; k++) {\n\t\t\tif(vs[nextBucket][k] == curLookfor) pick(nextBucket, k);\n\t\t}\n\t}\n\t\n\tstatic int go(int mask) {\n\t\tif(mask+1 == (1<<K)) return 1; //got to end\n\t\tif(dp[mask] != -1) return dp[mask];\n\t\t//get first bit that's off\n\t\tint bit = -1;\n\t\tfor(int i = 0; i < K; i++) {\n\t\t\tif((mask & (1<<i)) == 0) { bit = i; break;}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\t//loop through things to take for this bit\n\t\tfor(int take = 0; take < sz[bit]; take++) {\n\t\t\tint newMask = maskIfPick[bit][take];\n\t\t\tif(newMask == 0 || (mask & newMask) > 0) continue;\n\t\t\tres = (res | go(mask | newMask));\n\t\t}\n\t\t\n\t\treturn dp[mask] = res;\n\t}\n\t\n\tstatic void buildback(int mask) {\n\t\tif(mask+1 == (1<<K)) return; //got to end\n\t\t//get first bit that's off\n\t\tint bit = -1;\n\t\tfor(int i = 0; i < K; i++) {\n\t\t\tif((mask & (1<<i)) == 0) { bit = i; break;}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\t//loop through things to take for this bit\n\t\tfor(int take = 0; take < sz[bit]; take++) {\n\t\t\tint newMask = maskIfPick[bit][take];\n\t\t\tif(newMask == 0 || (mask & newMask) > 0) continue;\n\t\t\tres = (res | go(mask | newMask));\n\t\t\tif(res == 1) {\n\t\t\t\tpick(bit, take);\n\t\t\t\tbuildback(mask | newMask);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tstatic class FS{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FS() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {\n\t\t\twhile(st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\t\tcatch(Exception e) { throw null;}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() { return Integer.parseInt(next());}\n\t\tdouble nextDouble() { return Double.parseDouble(next());}\n\t\tlong nextLong() { return Long.parseLong(next());}\n\t}\n\t\n}\n", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  // main\n  public static void main(String [] args) throws IOException {\n    // makes the reader and writer\n    BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n    \n    // read in N\n    int N = Integer.parseInt(f.readLine());\n    \n    // write to out\n    if (N%2==0) out.println(\"4 \"+(N-4));\n    if (N%2==1) out.println(\"9 \"+(N-9));\n    \n    // cleanup\n    out.close();\n    System.exit(0);\n  }\n}", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\n\n\npublic class Main {\n\tstatic class MyReader{\n\t    private BufferedReader reader = null;\n\t    private StringTokenizer tokenizer = null;\n\t    MyReader(Reader r) throws IOException{\n\t        reader = new BufferedReader(r);\n\t    }\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(nextToken());\n\t    }\n\t    public String nextToken() throws IOException {\n\t        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t            tokenizer = new StringTokenizer(reader.readLine());\n\t        }\n\t        return tokenizer.nextToken();\n\t    }\n\t}\n\tpublic static void main(String []args) throws IOException{\n\t\tPrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out));\n\t\tMyReader reader = new MyReader(new InputStreamReader(System.in));\n\t\tint n = reader.nextInt();\n\t\tint k = reader.nextInt();\n\t\tint []a = new int[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\ta[i] = reader.nextInt();\n\t\tint j = 0;\n\t\tHashMap<Integer,Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tif (map.containsKey(a[i]))\n\t\t\t\tmap.put(a[i], map.get(a[i])+1);\n\t\t\telse{\n\t\t\t\tmap.put(a[i], 1);\n\t\t\t\tif (map.size()==k) { j = i+1; break; }\n\t\t\t}\n\t\t}\n\t\tif (map.size()<k){\n\t\t\tSystem.out.println(\"-1 -1\");\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tif (map.get(a[i])==1){\n\t\t\t\tSystem.out.println(i+1 + \" \" + j);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap.put(a[i], map.get(a[i])-1);\n\t\t}\n\t}\n\t\n}", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Collections;\nimport java.io.InputStream;\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        int INF = 1000 * 1000 * 1000;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int x0 = in.readInt();\n            int y0 = in.readInt();\n            int n = in.readInt();\n            int[] xs = new int[n + 1], ys = new int[n + 1];\n            xs[0] = x0;\n            ys[0] = y0;\n            for (int i = 1; i <= n; i++) {\n                xs[i] = in.readInt();\n                ys[i] = in.readInt();\n            }\n            int[] one = new int[n];\n            for (int i = 0; i < n; i++) one[i] = dist(0, i + 1, xs, ys) * 2;\n            int[][] two = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    two[i][j] = dist(0, i + 1, xs, ys) + dist(0, j + 1, xs, ys) + dist(i + 1, j + 1, xs, ys);\n                }\n            }\n            int[] dp = new int[(1 << n)];\n            Arrays.fill(dp, INF);\n            dp[0] = 0;\n            int[] prev = new int[(1 << n)];\n            for (int mask = 0; mask < (1 << n); mask++) {\n                for (int i = 0; i < n; i++) {\n                    if (((mask >> i) & 1) != 0) continue;\n                    ;\n                    int nmask = mask | (1 << i);\n                    int cost = one[i] + dp[mask];\n                    if (cost < dp[nmask]) {\n                        dp[nmask] = cost;\n                        prev[nmask] = i;\n                    }\n                    for (int j = i + 1; j < n; j++) {\n                        if (((mask >> j) & 1) != 0) continue;\n                        int nnmask = nmask | (1 << j);\n                        cost = two[i][j] + dp[mask];\n                        if (cost < dp[nnmask]) {\n                            dp[nnmask] = cost;\n                            prev[nnmask] = n + i * n + j;\n                        }\n                    }\n                    break;\n                }\n            }\n            int mask = (1 << n) - 1;\n            out.printLine(dp[mask]);\n            ArrayList<Integer> res = new ArrayList<>();\n            res.add(0);\n            while (mask > 0) {\n                if (prev[mask] < n) {\n                    res.add(prev[mask] + 1);\n                    mask &= ~(1 << prev[mask]);\n                } else {\n                    int ii = (prev[mask] - n) / n;\n                    int jj = (prev[mask] - n) % n;\n                    int i = Math.max(ii, jj);\n                    int j = Math.min(ii, jj);\n                    res.add(i + 1);\n                    res.add(j + 1);\n                    mask &= ~(1 << i);\n                    mask &= ~(1 << j);\n                }\n                res.add(0);\n            }\n            Collections.reverse(res);\n            for (int val : res) out.print(val + \" \");\n            out.printLine();\n        }\n\n        int dist(int i, int j, int[] xs, int[] ys) {\n            return (xs[i] - xs[j]) * (xs[i] - xs[j]) + (ys[i] - ys[j]) * (ys[i] - ys[j]);\n        }\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine() {\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n    }\n}\n\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic Scanner in;\n\tstatic PrintWriter out;\n//\tstatic StreamTokenizer in; static int next() throws Exception {in.nextToken(); return (int) in.nval;}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tin = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n//\t\tin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tint n = in.nextInt();\n\n\t\tdouble[][] p = new double[n][n];\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) p[i][j] = in.nextDouble();\n\n\t\tdouble[] q = new double[1 << n];\n\t\tq[(1 << n) - 1] = 1;\n\t\tfor (int mask = (1 << n) - 1; mask > 0; mask--) {\n\t\t\tint count = 0;\n\n\t\t\tfor (int t = 0; t < n; t++) if (((1 << t) & mask) != 0) count++;\n\t\t\tif (count <= 1) continue;\n\t\t\tcount = count*(count - 1)/2;\n\n\t\t\tfor (int t = 0; t < n; t++) if (((1 << t) & mask) != 0)\n\t\t\t\tfor (int s = 0; s < t; s++) if (((1 << s) & mask) != 0) {\n\t\t\t\t\tq[mask - (1 << t)] += q[mask] / count * p[s][t];\n\t\t\t\t\tq[mask - (1 << s)] += q[mask] / count * p[t][s];\n\t\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) out.print(q[1 << i] + \" \");\n\n\t\tout.close();\n\t}\n}", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class D5 implements Runnable {\n\n\tfinal double eps = 1e-9;\n\n\tprivate void Solution() throws IOException {\n\t\tdouble a = nextDouble(), v = nextDouble();\n\t\tdouble l = nextDouble(), d = nextDouble(), w = nextDouble();\n\t\tdouble t = 0;\n\t\tif (w + eps > v) {\n\t\t\tdouble s = v * v / (2 * a);\n\t\t\tif (s + eps > l)\n\t\t\t\tt = Math.sqrt(2 * l / a);\n\t\t\telse {\n\t\t\t\tdouble ta = v / a;\n\t\t\t\tdouble sa = a * ta * ta / 2;\n\t\t\t\tt = ta + (l - sa) / v;\n\t\t\t}\n\t\t} else {\n\t\t\tdouble sv = v * v / (2 * a);\n\t\t\tdouble sw = w * w / (2 * a);\n\t\t\tif (sw + eps > d) {\n\t\t\t\tif (sv + eps > l)\n\t\t\t\t\tt = Math.sqrt(2 * l / a);\n\t\t\t\telse {\n\t\t\t\t\tdouble ta = v / a;\n\t\t\t\t\tdouble sa = a * ta * ta / 2;\n\t\t\t\t\tt = ta + (l - sa) / v;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdouble sd = (w * w - v * v) / (-2 * a);\n\t\t\t\tif (sv + sd < eps + d)\n\t\t\t\t\tt = v / a + (d - sv - sd) / v + (v - w) / a;\n\t\t\t\telse {\n\t\t\t\t\tdouble f = Math.sqrt(d * a + w * w / 2);\n\t\t\t\t\tt = f / a + (f - w) / a;\n\t\t\t\t}\n\t\t\t\tif (sd + eps > l - d) {\n\t\t\t\t\tdouble lv = Math.sqrt((l - d) * 2 * a + w * w);\n\t\t\t\t\tt += (lv - w) / a;\n\t\t\t\t} else {\n\t\t\t\t\tt += (v - w) / a + (l - d - sd) / v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.printf(\"%.12f\", t);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew D5().run();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tokenizer;\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tSolution();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\n\tvoid print(Object... obj) {\n\t\tfor (int i = 0; i < obj.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\tout.print(\" \");\n\t\t\tout.print(obj[i]);\n\t\t}\n\t}\n\n\tvoid println(Object... obj) {\n\t\tprint(obj);\n\t\tprint(\"\\n\");\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() throws NumberFormatException, IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tString nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tString next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\ttokenizer = new StringTokenizer(nextLine());\n\t\treturn tokenizer.nextToken();\n\t}\n}\n", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        int a = input.nextInt();\n        int b = input.nextInt();\n        int x[] = new int[n];\n        for (int i=0; i<n; i++) x[i]=input.nextInt();\n        Arrays.sort(x);\n        int y[] = new int[n];\n        for (int i=0; i<n; i++) y[i]=x[n-i-1];\n        System.out.println(y[a-1]-y[a]);\n    }\n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "\nimport java.io.*;\nimport java.util.InputMismatchException;\n\npublic class CF278 {\n\n    static String filePath = \"/home/bishoy/IdeaProjects/Arabic competetive programming/src/a/test\";\n\n    public static void main(String args[]) {\n        InputReader inputReader = Helper.readInput(Helper.Input.STD, filePath);\n        OutputWriter out = new OutputWriter(System.out);\n        long n = inputReader.readLong();\n        long k = inputReader.readLong();\n\n        if (n == 1)\n            out.printLine(0);\n        else if (n <= k)\n            out.printLine(1);\n        else {\n            n--;\n            k--;\n            if (sum(k) < n)\n                out.printLine(-1);\n            else {\n                out.printLine(countSplitters(k, n));\n            }\n        }\n        out.flush();\n        out.close();\n    }\n\n    private static long countSplitters(long k, long n) {\n        long start = 1, end = k;\n        while (start < end) {\n            long mid = (start + end) / 2;\n\n            long sum = sum(mid, k);\n\n            if (sum == n)\n                return k - mid + 1;\n            if (sum > n) {\n                start = mid + 1;\n            } else {\n                end = mid;\n            }\n\n        }\n\n        return k - start + 2;\n\n    }\n\n    static long sum(long s) {\n        return s * (s + 1) / 2;\n    }\n\n    static long sum(long s, long e) {\n        if (s <= 1)\n            return sum(e);\n        else\n            return sum(e) - sum(s - 1);\n    }\n\n\n    static class Helper {\n        static InputReader inputReader = null;\n        static OutputWriter out = null;\n\n        public static enum Input {\n            FILE, STD\n        }\n\n        public static class Pair<K, V> {\n            public K key;\n            public V value;\n\n            public Pair(K key, V value) {\n                this.key = key;\n                this.value = value;\n            }\n\n\n            @Override\n            public String toString() {\n                return \"( \" + key + \" , \" + value + \")\";\n            }\n        }\n\n\n        public static InputReader readInput(Enum type, String filePath) {\n            if (type == Input.FILE) {\n                try {\n                    inputReader = new InputReader(new FileInputStream(new File(filePath)));\n                } catch (FileNotFoundException e) {\n                    e.printStackTrace();\n                }\n            } else\n                inputReader = new InputReader(System.in);\n\n\n            return inputReader;\n        }\n\n\n        public static boolean validIndices(int r, int c, int n, int m) {\n            if (r >= 0 && c >= 0 && r < n && c < m) return true;\n            else return false;\n        }\n    }\n\n    private static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public double readDouble() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E') {\n                    return res * Math.pow(10, readInt());\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E') {\n                        return res * Math.pow(10, readInt());\n                    }\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    private static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n            writer.flush();\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n            writer.flush();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n    }\n}", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "    //    A Computer is Like a mischievous genie.\n    //    It will give you exactly what you ask for,\n    //    but not always what you want\n    //    A code by Rahul Verma\n\n\n    import java.io.BufferedOutputStream;\n    import java.io.BufferedReader;\n    import java.io.IOException;\n    import java.io.InputStreamReader;\n    import java.io.PrintWriter;\n    import java.math.BigInteger;\n    import java.util.ArrayList;\n    import java.util.Arrays;\n    import java.util.Collections;\n    import java.util.Comparator;\n    import java.util.HashMap;\n    import java.util.HashSet;\n    import java.util.LinkedHashSet;\n    import java.util.LinkedList;\n    import java.util.List;\n    import java.util.PriorityQueue;\n    import java.util.Queue;\n    import java.util.Set;\n    import java.util.Stack;\n    import java.util.StringTokenizer;\n    import java.util.TreeMap;\n    import java.util.TreeSet;\n\n\n    public class Main {\n\n\n        static class Clock {\n\n            protected long start, stop;\n\n            public void start() {\n\n                start = System.currentTimeMillis();\n            }\n\n            public void stop() {\n                stop = System.currentTimeMillis();\n            }\n\n            public String getTime() {\n\n                return ((stop - start) + \" ms\");\n            }\n        }\n\n\n        public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        static class FastReader {\n\n            BufferedReader br;\n            StringTokenizer st;\n\n            public FastReader() {\n                br = new BufferedReader(new\n                    InputStreamReader(System.in));\n            }\n\n            String next() {\n                while (st == null || !st.hasMoreElements()) {\n                    try {\n                        st = new StringTokenizer(br.readLine());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                return st.nextToken();\n            }\n\n            int nextInt() {\n                return Integer.parseInt(next());\n            }\n\n            long nextLong() {\n                return Long.parseLong(next());\n            }\n\n            double nextDouble() {\n                return Double.parseDouble(next());\n            }\n\n            String[] nextSArray() {\n                String sr[] = null;\n                try {\n                    sr = br.readLine().trim().split(\" \");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return sr;\n            }\n\n            String nextLine() {\n                String str = \"\";\n                try {\n                    str = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n\n                return str;\n            }\n        }\n\n\n        static long powmodulo(long a, long p) {\n            if (p == 0) {\n                return 1 % mod;\n            }\n            if (p == 1) {\n                return a % mod;\n            }\n            long ans = 1;\n            while (p > 0) {\n                if ((p & 1) > 0) {\n                    ans = (ans * a) % mod;\n                }\n                a = (a * a) % mod;\n                p = p >> 1;\n            }\n            return ans % mod;\n        }\n\n\n        static long mod = 1000000007;\n\n        static long gcd(long a, long b) {\n            if (a == 0) {\n                return b;\n            }\n            return gcd(b % a, a);\n        }\n\n        static long fast_powerNumbers(long a, long n) {\n            if (n == 1) {\n                return a;\n            }\n            long ans = fast_powerNumbers(a, n / 2);\n            if (n % 2 == 0) {\n                return (ans * ans);\n            } else {\n                return ((ans * ans) * (a));\n            }\n        }\n\n\n        static void dfs_helper(int[][] arr, int i, int j, int team, int n, int m) {\n            arr[i][j] = team;\n            if (i - 1 >= 0 && arr[i - 1][j] == 1) {\n                dfs(arr, i - 1, j, team, n, m);\n            }\n            if (j - 1 >= 0 && arr[i][j - 1] == 1) {\n                dfs(arr, i, j - 1, team, n, m);\n            }\n            if (i + 1 < n && arr[i + 1][j] == 1) {\n                dfs(arr, i + 1, j, team, n, m);\n            }\n            if (j + 1 < m && arr[i][j + 1] == 1) {\n                dfs(arr, i, j + 1, team, n, m);\n            }\n\n        }\n\n        static void dfs(int[][] arr, int i, int j, int team, int n, int m) {\n            dfs_helper(arr, i, j, team, n, m);\n\n        }\n        public static int arr[];\n\n\n        static void seive(int n) {\n            // 1 is not prime\n            arr = new int[n + 1];\n            arr[0] = arr[1] = 1;\n            for (int i = 4; i <= n; i = i + 2) {\n                arr[i] = 1;\n            }\n            for (int i = 3; i * i <= n; i = i + 2) {\n                if (arr[i] == 0) {\n                    for (int j = i * i; j <= n; j = j + i) {\n                        arr[j] = 1;\n                    }\n\n                }\n            }\n        }\n\n\n        public static HashMap<Integer,Integer> primefac(int n)\n        {\n            HashMap<Integer,Integer>hm=new HashMap<>();\n            //int x = (int) Math.sqrt(n);\n            for (int i = 2; i <=n; i++) {\n                int x=0;\n                while(n%i==0)\n                {\n                    n=n/i;\n                    ++x;\n                }\n                if(x!=0)\n                {\n                    hm.put(i,x);\n                }\n            }\n            return hm;\n        }\n       static long fac(int p)\n       {\n           if(p==0||p==1)\n               return 1;\n           return p*fac(p-1);\n       }\n\n\n        public static void main(String[] args) throws Exception {\n            FastReader sc = new FastReader();\n\n            Clock clock = new Clock();\n\n            clock.start();\n          int n = sc.nextInt();\n          int a=sc.nextInt();\n          double arr[][] = new double[n][2];\n          int one=0;\n            for (int i = 0; i < n; i++) {\n                arr[i][0]=sc.nextDouble();\n                if(arr[i][0]==1)\n                    ++one;\n            }\n            for (int i = 0; i < n; i++) {\n                arr[i][1]=sc.nextDouble();\n                if(arr[i][1]==1)\n                    ++one;\n            }\n            if(one!=0)\n            {\n                System.out.println(-1);\n                return;\n            }\n\n            double ans=a;\n            ArrayList<Double>al=new ArrayList<>();\n            al.add(arr[0][0]);\n            int k=0;\n            for (int i = 1; i < n; i++) {\n               al.add(arr[i][1]);\n               al.add(arr[i][0]);\n            }\n\n            al.add(arr[0][1]);\n            Collections.reverse(al);\n            for (int i = 0; i < al.size(); i++) {\n                ans =  (ans + (ans/(al.get(i)-1)));\n            }\n//            System.out.println(al);\n//            System.out.println(al.size());\n            System.out.println(ans-a);\n\n\n    }}\n\n\n    class Pair{\n\n        int a,b;\n        Pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    class DSU\n    {\n        int parent[];\n        int rank[];\n\n        long sum[] ;\n        DSU(int n)\n        {\n            this.parent=new int[n];\n            this.rank=new int[n];\n            sum=new long[n];\n            Arrays.fill(parent,-1);\n            Arrays.fill(rank,1);\n\n        }\n\n        int find(int s1)\n        {\n            if(parent[s1]==-1)\n                return s1;\n            return parent[s1]=find(parent[s1]);\n        }\n\n        void unite(int s1,int s2)\n        {\n            int p1=this.find(s1);\n            int p2=this.find(s2);\n            if(p1==p2)\n                return;\n            if(rank[p1]>rank[p2])\n            {\n                parent[p2]=p1;\n                rank[p1]+=rank[p2];\n                // System.out.println(arr[p2]);\n\n                sum[p1]+=sum[p2];\n                //sum[p2]+=sum[p1];\n\n            }\n            else\n            {\n                parent[p1]=p2;\n                rank[p2]+=rank[p1];\n                //System.out.println(arr[p1]);\n                sum[p2]+=sum[p1];\n                //sum[p1]+=sum[p2];\n            }\n        }\n\n\n    }\n\n    class Gaph {\n\n        HashMap<Integer, ArrayList<Integer>> hm;\n\n        Gaph() {\n            hm = new HashMap<>();\n        }\n\n        Gaph(int n) {\n\n            hm = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                hm.put(i, new ArrayList<Integer>());\n            }\n        }\n\n        // function for adding an edge.................................................\n        public void addEdge(int a, int b, boolean isDir) {\n            if (isDir) {\n                if (hm.containsKey(a)) {\n                    hm.get(a).add(b);\n                } else {\n                    hm.put(a, new ArrayList<>(Arrays.asList(b)));\n                }\n            } else {\n                if (hm.containsKey(a)) {\n                    hm.get(a).add(b);\n                } else if (!hm.containsKey(a)) {\n                    hm.put(a, new ArrayList<>(Arrays.asList(b)));\n                }\n\n                if (hm.containsKey(b)) {\n                    hm.get(b).add(a);\n                } else if (!hm.containsKey(b)) {\n                    hm.put(b, new ArrayList<>(Arrays.asList(a)));\n                }\n            }\n        }\n\n\n    }\n\n    // out.println(al.toString().replaceAll(\"[\\\\[|\\\\]|,]\",\"\"));", "complexity": "linear", "problem": "1010_A", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ankur\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        String[] str;\n        long mod = (long) 1e9 + 7;\n        long[][] dp;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            str = new String[n];\n            dp = new long[n + 2][n + 2];\n            for (int i = 0; i < dp.length; i++) {\n                Arrays.fill(dp[i], -1);\n            }\n            for (int i = 0; i < n; i++) {\n                str[i] = in.readString();\n            }\n            if (str[0].charAt(0) == 'f') {\n                out.print(solve(1, 1));\n            } else {\n                out.print(solve(1, 0));\n            }\n        }\n\n        long solve(int n, int horiz) {\n            if (horiz < 0)\n                return 0;\n            if (n >= str.length - 1) {\n                return 1;\n            }\n            if (dp[n][horiz] != -1) {\n                return dp[n][horiz];\n            }\n            if (str[n].charAt(0) == 'f') {\n                return dp[n][horiz] = solve(n + 1, horiz + 1);\n            } else {\n                long ans1 = solve(n, horiz - 1);\n                //System.out.println(ans1+\" \"+n+\" egsvd\"+horiz);\n                ans1 += solve(n + 1, horiz);\n                //System.out.println(ans1+\" \"+n+\" \"+horiz);\n                ans1 = ans1 % mod;\n                return dp[n][horiz] = ans1;\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar;\n        private int snumChars;\n\n        public InputReader(InputStream st) {\n            this.stream = st;\n        }\n\n        public int read() {\n            //*-*------clare------\n\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid solve() {\n\t\tlong a = in.nextLong(), b = in.nextLong();\n\n\t\tlong ans = 0;\n\t\twhile (true) {\n\t\t\tlong div = a / b;\n\t\t\t\n\t\t\tans += div;\n\t\t\ta -= div * b;\n\t\t\t\n\t\t\tif (a == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tlong tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t}\n\t\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A().run();\n\t}\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author pttrung\n */\npublic class B {\n\n    static Senator[] data;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int A = in.nextInt();\n        data = new Senator[n];\n        for (int i = 0; i < n; i++) {\n            data[i] = new Senator(in.nextInt(), in.nextInt());\n        }\n        out.println(cal(0, new int[n], A, k));\n\n        out.close();\n    }\n\n    public static double cal(int index, int[] num, int A, int left) {\n        if (index == data.length - 1) {\n            int dif = (100 - data[index].loyal)/10;\n            dif = left >= dif? dif:left;\n            num[index] =  dif;\n           \n            double result = 0;\n            for (int k = 0; k < (1 << num.length); k++) {\n                double val = 1;\n                double total = 0;\n                for (int i = 0; i < num.length; i++) {\n                    if (((1 << i) & k) != 0) {\n                        val *= ((double)(data[i].loyal + 10*num[i])/100);\n                    } else {\n                        val *= ((double)(100 - (data[i].loyal + 10*num[i]))/100);\n                        total += data[i].level;\n                    }\n                }\n                if (countBit(k) > num.length / 2) {\n                    result += val;\n                } else {\n                    result += val * ((double) A / (A + total));\n                }\n            }\n//           // if(result >= 1){\n//                for(int i : num){\n//                    System.out.print(i + \" \");\n//                }\n//                System.out.println(\"\\n\" + result);\n//            //}\n            return result;\n        } else {\n            double result = 0;\n            for (int i = 0; i <= left; i++) {\n                if (i * 10 + data[index].loyal <= 100) {\n                    num[index] = i;\n                  //  double val = cal(index + 1 , num , A, left - i);\n                    \n                    result = Math.max(result, cal(index + 1, num, A, left - i));\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n\n    public static int countBit(int val) {\n        int result = 0;\n        while (val > 0) {\n            result += val % 2;\n            val >>= 1;\n        }\n        return result;\n    }\n\n    public static class Senator {\n\n        int level, loyal;\n\n        public Senator(int level, int loyal) {\n            this.level = level;\n            this.loyal = loyal;\n        }\n    }\n\n    public static boolean nextPer(int[] data) {\n        int i = data.length - 1;\n        while (i > 0 && data[i] < data[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return false;\n        }\n        int j = data.length - 1;\n        while (data[j] < data[i - 1]) {\n            j--;\n        }\n        int temp = data[i - 1];\n        data[i - 1] = data[j];\n        data[j] = temp;\n        Arrays.sort(data, i, data.length);\n        return true;\n    }\n\n    public static class Point {\n\n        int x, y, z;\n\n        public Point(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n    }\n\n    public double pow(double a, int b) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        double val = pow(a, b / 2);\n        if (b % 2 == 0) {\n            return val * val;\n        } else {\n            return val * val * a;\n        }\n    }\n\n    public static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\npublic class Solution {\n\n    public static void main(String[] args) throws Exception {\n        MyReader reader = new MyReader(System.in);\n//        MyReader reader = new MyReader(new FileInputStream(\"input.txt\"));\n        MyWriter writer = new MyWriter(System.out);\n        new Solution().run(reader, writer);\n        writer.close();\n    }\n\n    private void run(MyReader reader, MyWriter writer) throws Exception {\n        char[] c = reader.nextCharArray();\n        int n = c.length;\n        int[] x = new int[n];\n        for (int i = 0; i < n; i++) {\n            x[i] = c[i] - '0';\n        }\n        long mod = 1_000_000_007;\n        long[] p = new long[n + 1];\n        long[] s = new long[n + 1];\n        p[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            p[i] = p[i - 1] * 10 % mod;\n        }\n        s[n] = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            s[i] = (p[n - i - 1] * x[i] + s[i + 1]) % mod;\n        }\n        long[][][] d = new long[n + 1][n + 1][2];\n        long ans = 0;\n        for (int i = 1; i < 10; i++) {\n            for (long[][] q : d) {\n                for (long[] w : q) {\n                    Arrays.fill(w, 0);\n                }\n            }\n            for (int j = 0; j <= n; j++) {\n                d[j][0][0] = s[j];\n                d[j][0][1] = p[n - j];\n            }\n            for (int j = n - 1; j >= 0; j--) {\n                for (int k = 1; k <= n; k++) {\n                    for (int l = 1; l >= 0; l--) {\n                        int lim = l == 1 ? 10 : x[j] + 1;\n                        for (int m = 0; m < lim; m++) {\n                            d[j][k][l] += d[j + 1][k - (m >= i ? 1 : 0)][l == 1 || m < x[j] ? 1 : 0];\n                            d[j][k][l] %= mod;\n                        }\n                    }\n                    if (j == 0) {\n                        ans = (ans + p[k - 1] * d[0][k][0]) % mod;\n                    }\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n\n    static class MyReader {\n\n        final BufferedInputStream in;\n        final int bufSize = 1 << 16;\n        final byte buf[] = new byte[bufSize];\n        int i = bufSize;\n        int k = bufSize;\n        boolean end = false;\n        final StringBuilder str = new StringBuilder();\n\n        MyReader(InputStream in) {\n            this.in = new BufferedInputStream(in, bufSize);\n        }\n\n        int nextInt() throws IOException {\n            return (int) nextLong();\n        }\n\n        int[] nextIntArray(int n) throws IOException {\n            int[] m = new int[n];\n            for (int i = 0; i < n; i++) {\n                m[i] = nextInt();\n            }\n            return m;\n        }\n\n        int[][] nextIntMatrix(int n, int m) throws IOException {\n            int[][] a = new int[n][0];\n            for (int j = 0; j < n; j++) {\n                a[j] = nextIntArray(m);\n            }\n            return a;\n        }\n\n        long nextLong() throws IOException {\n            int c;\n            long x = 0;\n            boolean sign = true;\n            while ((c = nextChar()) <= 32) ;\n            if (c == '-') {\n                sign = false;\n                c = nextChar();\n            }\n            if (c == '+') {\n                c = nextChar();\n            }\n            while (c >= '0') {\n                x = x * 10 + (c - '0');\n                c = nextChar();\n            }\n            return sign ? x : -x;\n        }\n\n        long[] nextLongArray(int n) throws IOException {\n            long[] m = new long[n];\n            for (int i = 0; i < n; i++) {\n                m[i] = nextLong();\n            }\n            return m;\n        }\n\n        int nextChar() throws IOException {\n            if (i == k) {\n                k = in.read(buf, 0, bufSize);\n                i = 0;\n            }\n            return i >= k ? -1 : buf[i++];\n        }\n\n        String nextString() throws IOException {\n            if (end) {\n                return null;\n            }\n            str.setLength(0);\n            int c;\n            while ((c = nextChar()) <= 32 && c != -1) ;\n            if (c == -1) {\n                end = true;\n                return null;\n            }\n            while (c > 32) {\n                str.append((char) c);\n                c = nextChar();\n            }\n            return str.toString();\n        }\n\n        String nextLine() throws IOException {\n            if (end) {\n                return null;\n            }\n            str.setLength(0);\n            int c = nextChar();\n            while (c != '\\n' && c != '\\r' && c != -1) {\n                str.append((char) c);\n                c = nextChar();\n            }\n            if (c == -1) {\n                end = true;\n                if (str.length() == 0) {\n                    return null;\n                }\n            }\n            if (c == '\\r') {\n                nextChar();\n            }\n            return str.toString();\n        }\n\n        char[] nextCharArray() throws IOException {\n            return nextString().toCharArray();\n        }\n\n        char[][] nextCharMatrix(int n) throws IOException {\n            char[][] a = new char[n][0];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextCharArray();\n            }\n            return a;\n        }\n    }\n\n    static class MyWriter {\n\n        final BufferedOutputStream out;\n        final int bufSize = 1 << 16;\n        final byte buf[] = new byte[bufSize];\n        int i = 0;\n        final byte c[] = new byte[30];\n        static final String newLine = System.getProperty(\"line.separator\");\n\n        MyWriter(OutputStream out) {\n            this.out = new BufferedOutputStream(out, bufSize);\n        }\n\n        void print(long x) throws IOException {\n            int j = 0;\n            if (i + 30 >= bufSize) {\n                flush();\n            }\n            if (x < 0) {\n                buf[i++] = (byte) ('-');\n                x = -x;\n            }\n            while (j == 0 || x != 0) {\n                c[j++] = (byte) (x % 10 + '0');\n                x /= 10;\n            }\n            while (j-- > 0)\n                buf[i++] = c[j];\n        }\n\n        void print(int[] m) throws IOException {\n            for (int a : m) {\n                print(a);\n                print(' ');\n            }\n        }\n\n        void print(long[] m) throws IOException {\n            for (long a : m) {\n                print(a);\n                print(' ');\n            }\n        }\n\n        void print(String s) throws IOException {\n            for (int i = 0; i < s.length(); i++) {\n                print(s.charAt(i));\n            }\n        }\n\n        void print(char x) throws IOException {\n            if (i == bufSize) {\n                flush();\n            }\n            buf[i++] = (byte) x;\n        }\n\n        void print(char[] m) throws IOException {\n            for (char c : m) {\n                print(c);\n            }\n        }\n\n        void println(String s) throws IOException {\n            print(s);\n            println();\n        }\n\n        void println() throws IOException {\n            print(newLine);\n        }\n\n        void flush() throws IOException {\n            out.write(buf, 0, i);\n            out.flush();\n            i = 0;\n        }\n\n        void close() throws IOException {\n            flush();\n            out.close();\n        }\n    }\n}", "complexity": "quadratic", "problem": "0908_G", "from": "CODEFORCES", "tags": "dp,math"}
{"src": "//package codeforces;\nimport java.io.PrintWriter;\nimport java.util.*;\npublic class codeforces {\n\tpublic static void main(String[] args) {\n\t\tPrintWriter out=new PrintWriter(System.out);\n    \tScanner s=new Scanner(System.in);  \n    \tint t=s.nextInt();\n    \tfor(int tt=0;tt<t;tt++) {\n    \t\tlong n=s.nextInt();\n    \t\tlong x=(long)Math.sqrt(n/2);\n    \t\tlong y=(long)Math.sqrt(n/4);\n    \t\tif(x*x*2==n || y*y*4==n) {\n    \t\t\tout.println(\"YES\");\n    \t\t}else {\n    \t\t\tout.println(\"NO\");\n    \t\t}\n    \t}\n    \tout.close();\n\t    s.close();\n\t}\n\t\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n}\n \n\n", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CNastyaAndAWardrobe solver = new CNastyaAndAWardrobe();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CNastyaAndAWardrobe {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            long x = in.nextLong();\n            long k = in.nextLong();\n            if (x == 0) {\n                out.println(0);\n            } else {\n                long mod = (long) (1e9 + 7);\n                long ans = (((((2 * x - 1) % mod)) * power(2, k, mod)) % mod) + 1;\n                ans %= mod;\n                out.println(ans);\n            }\n\n        }\n\n        long power(long x, long y, long p) {\n            long res = 1;\n            x = x % p;\n            while (y > 0) {\n                if ((y & 1) > 0)\n                    res = (res * x) % p;\n                y = y >> 1;\n                x = (x * x) % p;\n            }\n            return res;\n        }\n\n    }\n\n    static class FastScanner {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\n\npublic class Main implements Runnable {\t\n\t\n\tint n;\n\tdouble[] prob;\n\tdouble[][] a;\n\t\n\tvoid solve() throws IOException {\n\t\tn = nextInt();\n\t\ta = new double[n][n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\ta[i][j] = nextDouble();\n\t\t\t}\n\t\t}\n\t\tprob = new double[1<<n];\n\t\tArrays.fill(prob, 0.0);\n\t\tprob[(1<<n)-1] = 1.0;\n\t\tfor (int i = (1<<n)-1; i > 1; --i) {\n\t\t\tint c = 0;\n\t\t\tfor (int bit = 0; bit < n; ++bit) {\n\t\t\t\tif (((1<<bit) & i) > 0) {\n\t\t\t\t\t++c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble k = c * (c - 1) / 2.0;\n\t\t\tfor (int f = 0; f < n; ++f) {\n\t\t\t\tif (((1<<f) & i) > 0) {\n\t\t\t\t\tfor (int s = f+1; s < n; ++s) {\n\t\t\t\t\t\tif (((1<<s) & i) > 0) {\n\t\t\t\t\t\t\tprob[i^(1<<f)] += prob[i] * a[s][f] / k;\n\t\t\t\t\t\t\tprob[i^(1<<s)] += prob[i] * a[f][s] / k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\twriter.printf(Locale.US, \"%.6f \", prob[1<<i]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\t new Thread(null, new Runnable() {\n            public void run() {\n                new Main().run();\n            }\n\t     }, \n\t     \"1\", \n\t     1 << 25).start();\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tboolean fromStandart = true;\n\t\t\treader = new BufferedReader(fromStandart ? new InputStreamReader(System.in) : new FileReader(INFILE));\n            writer = new PrintWriter(new BufferedWriter(fromStandart ? new OutputStreamWriter(System.out) : new FileWriter(OUTFILE)));\n\t\t\ttokenizer = null; \n\t\t\tsolve();\n\t\t\twriter.flush();\n\t\t} catch (Exception error) {\n\t\t\terror.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\tstatic final String INFILE = \"input.txt\";\n\tstatic final String OUTFILE = \"output.txt\";\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n    PrintWriter writer;\n\n\tint nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    \n    String nextString() throws IOException {\n    \treturn reader.readLine();\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    } \t\n\n}\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n    StreamTokenizer in;\n    PrintWriter out;\n    static public void main(String[] args) throws IOException {\n        new Main().run();\n    }\n    int ni() throws IOException {\n        in.nextToken(); return (int) in.nval;\n    }\n    void run() throws IOException {\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        int n = ni(), t = ni();\n        if(n == 0) {\n            out.println(0); out.flush(); return;\n        }\n        House[] h = new House[n];\n        for(int i = 0; i < n; i++) {\n            h[i] = new House();\n            h[i].x = ni(); h[i].a = ni();\n        }\n        Arrays.sort(h);\n        int ret = 2;\n        for(int i = 0; i < n - 1; i++) {\n            if(2*(h[i + 1].x - h[i].x) - h[i].a - h[i + 1].a > 2*t) ret+=2;\n            else if(2*(h[i + 1].x - h[i].x) - h[i].a - h[i + 1].a == 2*t) ret++;\n        }\n        out.println(ret);\n\n        out.flush();\n    }\n    void run1() throws IOException {\n            in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n\n            int t = ni();\n            long n = ni(), m = ni();\n            long x1 = ni(), y1 = ni(), x2 = ni(), y2 = ni();\n        long tx1 = Math.min(x1, x2), tx2 = x1 + x2 - tx1;\n        long ty1 = Math.min(y1, y2), ty2 = y1 + y2 - ty1;\n        long dx = tx2 - tx1;\n        long dy = ty2 - ty1;\n        \n    }\n\n    class House implements Comparable<House> {\n        int x, a;\n        public int compareTo(House h) {\n            return x < h.x ? -1 : 1;\n        }\n    }\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.*;\npublic class F {\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner();\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int[][] matrix = new int[N][M];\n        for(int i = 0; i < N; i++) {\n            for(int j = 0; j < M; j++) {\n                matrix[i][j] = scanner.nextInt();\n            }\n        }\n        int[][] maxDist = new int[N][N];\n        for(int i = 0; i < N; i++) {\n            Arrays.fill(maxDist[i], Integer.MAX_VALUE);\n        }\n        for(int i = 0; i < M; i++) {\n            for(int  j = 0; j < N; j++) {\n                for(int k = j+1; k < N; k++) {\n                    maxDist[j][k] = Math.min(maxDist[j][k], Math.abs(matrix[k][i] - matrix[j][i]));\n                    maxDist[k][j] = maxDist[j][k];\n                }\n            }\n        }\n        int[][] distTop = new int[N][N];\n        for(int i = 0; i < N; i++) {\n            Arrays.fill(distTop[i], Integer.MAX_VALUE);\n        }\n        for(int i = 0; i < M-1; i++) {\n            for(int j = 0; j < N; j++) {\n                for(int k = 0; k < N; k++) {\n                    distTop[j][k] = Math.min(distTop[j][k], Math.abs(matrix[j][i] - matrix[k][i+1]));\n                }\n            }\n        }\n        if (N == 1) {\n            System.out.println(distTop[0][0]);\n            System.exit(0);\n        }\n        int[] bitLoc = new int[1<<N];\n        for(int i = 0; i < N; i++) {\n            bitLoc[1 << i] = i;\n        }\n        int[][][] dp = new int[1<<N][N][N];\n        //iterate over every row\n        for(int mask = 1; mask < (1 << N); mask++) {\n            for(int smask = mask; smask > 0; smask &= (smask-1)) {\n                int i = bitLoc[Integer.lowestOneBit(smask)];\n                for (int ss = mask ^ 1 << i; ss > 0; ss &= ss - 1) {\n                    int j = bitLoc[Integer.lowestOneBit(ss)];\n                    if (mask == (1 << i ^ 1 << j))\n                        dp[mask][i][j] = maxDist[i][j];\n                    else {\n                        int x = 0;\n                        for (int sss = mask ^ 1 << i ^ 1 << j; sss > 0; sss &= sss - 1) {\n                            int k = bitLoc[sss & -sss];\n                            x = Math.max(x, Math.min(dp[mask ^ 1 << j][i][k], maxDist[k][j]));\n                        }\n                        dp[mask][i][j] = x;\n                    }\n                }\n            }\n        }\n        int mxMsk = (1 << N) -1;\n        int max = 0;\n        for(int i = 0; i < N; i++) {\n            for(int j = 0; j < N; j++) {\n                if (i==j) continue;\n                max = Math.max(max, Math.min(dp[mxMsk][i][j], distTop[i][j]));\n            }\n        }\n        System.out.println(max);\n    }\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n}\n", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class A {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint []a = new int [n];\n\t\tboolean []used = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < used.length; i++) {\n\t\t\tif (!used[i]){\n\t\t\t\tans++;\n\t\t\t  for (int j = i; j < used.length; j++) {\n\t\t\t\tif (a[j]%a[i] == 0){\n\t\t\t\t\tused[j] = true;\n\t\t\t\t}\n\t\t\t  }\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(ans);\n\t}\n\n}\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\n\tFastReader in = new FastReader();\n\tPrintWriter out = new PrintWriter(System.out);\n\tvoid run(){\n\t\tint q=in.nextInt();\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tout.println(work());\n\t\t}\n\t\tout.flush();\n\t}\n\tlong mod=1000000007;\n\tlong gcd(long a,long b) {\n\t\treturn b==0?a:gcd(b,a%b);\n\t}\n\tint id[];\n\tlong work() {\n\t\tint n=in.nextInt();\n\t\tint m=in.nextInt();\n\t\tlong ret=0;\n\t\tPriorityQueue<int[]> pq=new PriorityQueue<>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] arr1,int[] arr2) {\n\t\t\t\treturn arr1[2]-arr2[2];\n\t\t\t}\n\t\t});\n\t\tlong sum=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tint v=in.nextInt();\n\t\t\t\tpq.add(new int[] {i,j,v});\n\t\t\t\tsum+=v;\n\t\t\t\tif(pq.size()>6)pq.poll();\n\t\t\t}\n\t\t}\n\t\tif(m==1)return sum;\n\t\tif(n<=3) {\n\t\t\twhile(pq.size()>0) {\n\t\t\t\tint[] p=pq.poll();\n\t\t\t\tif(pq.size()<n) {\n\t\t\t\t\tret+=p[2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tint[][] A=new int[6][];\n\t\tfor(int i=0;pq.size()>0;i++) {\n\t\t\tA[i]=pq.poll();\n\t\t}\n\t\t\n\t\tfor(int i=0;i<6;i++) {\n\t\t\tfor(int j=i+1;j<6;j++) {\n\t\t\t\tfor(int k=j+1;k<6;k++) {\n\t\t\t\t\tout:\n\t\t\t\t\tfor(int p=k+1;p<6;p++) {\n\t\t\t\t\t\tint s=A[i][2]+A[j][2]+A[k][2]+A[p][2];\n\t\t\t\t\t\tHashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\n\t\t\t\t\t\tif(map.get(A[i][1])==null) {\n\t\t\t\t\t\t\tmap.put(A[i][1],new ArrayList<>());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map.get(A[j][1])==null) {\n\t\t\t\t\t\t\tmap.put(A[j][1],new ArrayList<>());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map.get(A[k][1])==null) {\n\t\t\t\t\t\t\tmap.put(A[k][1],new ArrayList<>());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map.get(A[p][1])==null) {\n\t\t\t\t\t\t\tmap.put(A[p][1],new ArrayList<>());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmap.get(A[i][1]).add(A[i][0]);\n\t\t\t\t\t\tmap.get(A[j][1]).add(A[j][0]);\n\t\t\t\t\t\tmap.get(A[k][1]).add(A[k][0]);\n\t\t\t\t\t\tmap.get(A[p][1]).add(A[p][0]);\n\t\t\t\t\t\tif(map.size()!=2) {\n\t\t\t\t\t\t\tret=Math.max(ret, s);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tInteger l1=null,l2=null,r1=null,r2=null;\n\t\t\t\t\t\tfor(int key:map.keySet()) {\n\t\t\t\t\t\t\tArrayList<Integer> list=map.get(key);\n\t\t\t\t\t\t\tif(map.get(key).size()!=2) {\n\t\t\t\t\t\t\t\tret=Math.max(ret, s);\n\t\t\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l1==null) {\n\t\t\t\t\t\t\t\tl1=list.get(0);\n\t\t\t\t\t\t\t\tl2=list.get(1);\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tr1=list.get(0);\n\t\t\t\t\t\t\t\tr2=list.get(1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((Math.abs(l1-l2)==2&&Math.abs(r1-r2)==2)||(Math.abs(l1-l2)!=2&&Math.abs(r1-r2)!=2)) {\n\t\t\t\t\t\t\tret=Math.max(ret, s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}\n\n\n\nclass FastReader\n{\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic FastReader()\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tpublic String next() \n\t{\n\t\tif(st==null || !st.hasMoreElements())\n\t\t{\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() \n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong()\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            TaskD.Pair[] p = new TaskD.Pair[n];\n            for (int i = 0; i < n; ++i) {\n                p[i] = new TaskD.Pair(in.nextLong(), in.nextLong());\n            }\n            Arrays.sort(p);\n            int last = 0;\n            int ans = 1;\n            for (int i = 1; i < n; ++i) {\n                if (p[i].x - p[i].w >= p[last].x + p[last].w) {\n                    last = i;\n                    ++ans;\n                }\n            }\n            out.println(ans);\n        }\n\n        static class Pair implements Comparable<TaskD.Pair> {\n            long x;\n            long w;\n\n            public Pair(long x, long w) {\n                this.x = x;\n                this.w = w;\n            }\n\n            public int compareTo(TaskD.Pair o) {\n                return Long.compare(x + w, o.x + o.w);\n            }\n\n            public String toString() {\n                return x + \" \" + w;\n            }\n\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "problem": "0528_B", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main\n{\n\t\n\tpublic static void main(String args[]) throws IOException\n\t{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString x[]=br.readLine().split(\" \");\n\t\tlong l=Long.parseLong(x[0]);\n\t\tlong r=Long.parseLong(x[1]);\n\t\tif(l%2!=0)\n\t\t{\n\t\t\tl++;\n\t\t}\n\t\tif(l+2>r)\n\t\t{\n\t\t\tSystem.out.println(\"-1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.println(l+\" \"+(l+1)+\" \"+(l+2));\n\t\t}\n\t}\n} ", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class temp2 {\n\tstatic int mini;\n\tstatic int miniv;\n\tstatic long time = 0, mp = Integer.MAX_VALUE, k = 0, cnt = 0, edge = 0, no = 0;\n\n\tstatic int[] goal;\n\tstatic int[] init;\n\tstatic int[] col;\n\tstatic char[][] g;\n\tstatic String sb = \"\";\n\tstatic ArrayList<Integer>[] a;\n\n\tstatic ArrayList<Integer> p = new ArrayList<>();\n\n\tstatic int mod = (int) (1e9 + 7);\n\tstatic int ans[] = new int[100001];\n\tstatic boolean colorvisit[];\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tReader scn = new Reader();\n\t\tlong l=scn.nextLong();\n\t\tlong r=scn.nextLong();\n\t\tString s1=Long.toBinaryString(l);\n\t\tString s2=Long.toBinaryString(r);\n\t\tif(s1.length()==s2.length()){\n\t\tint i=0;\n\t\tint j=0;\n\t\twhile(i<s1.length() && j<s2.length() && s1.charAt(i)==s2.charAt(j)){\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\tint pow=s1.length()-i;\n\t\tlong a=(long) (Math.pow(2, pow));\n\t\tSystem.out.println(a-1);\n\t\t}\n\t\telse{\n\t\tint pow=(int) (Math.log(r)/Math.log(2));\n\t\tlong a=(long) (Math.pow(2, pow));\n\t\tlong xor=(a-1)^a;\n\t\t System.out.println(xor);\n\t\t}\n\n\t}\n\n\tpublic static class pair implements Comparable<pair> {\n\t\tint val;\n\t\tint idx;\n\t\t// int cnt;\n\n\t\tpair(int a, int b) {\n\t\t\tval = a;\n\t\t\tidx = b;\n\t\t\t// cnt = x;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\n\t\t\treturn this.val - o.val;\n\n\t\t}\n\t}\n\n\t// -----------PrintWriter for faster output---------------------------------\n\tpublic static PrintWriter out;\n\n\tpublic static class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[100000 + 1]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic int[][] nextInt2DArray(int m, int n) throws IOException {\n\t\t\tint[][] arr = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tarr[i][j] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t}\n}\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class First {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        //int a = 1;\n        int t;\n        //t = in.nextInt();\n        t = 1;\n        while (t > 0) {\n            //out.print(\"Case #\"+(a++)+\": \");\n            solver.call(in,out);\n            t--;\n        }\n        out.close();\n\n    }\n\n    static class TaskA {\n        public void call(InputReader in, PrintWriter out) {\n            int n, q;\n            n = in.nextInt();\n            q = in.nextInt();\n\n            ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();\n            Map<Integer, answer> map = new HashMap<>();\n\n            int a, b, c = 0, max = Integer.MIN_VALUE;\n\n            for (int i = 0; i < n; i++) {\n                a = in.nextInt();\n                arrayDeque.add(a);\n                max = Math.max(max, a);\n            }\n\n            for (int i = 0; i < n; i++) {\n                if(arrayDeque.getFirst() == max){\n                    break;\n                }\n\n                a = arrayDeque.removeFirst();\n                b = arrayDeque.removeFirst();\n\n                map.put(i+1,new answer(a,b));\n                c = i+1;\n\n                if(a>b){\n                    arrayDeque.addFirst(a);\n                    arrayDeque.addLast(b);\n                }\n                else{\n                    arrayDeque.addFirst(b);\n                    arrayDeque.addLast(a);\n                }\n\n            }\n\n            int[] arr = new int[n];\n\n            for (int i = 0; i < n; i++) {\n                arr[i] = arrayDeque.removeFirst();\n            }\n\n            long m;\n            for (int i = 0; i < q; i++) {\n                m = in.nextLong();\n\n                if(m<=c){\n                    out.println(map.get((int)m).a +\" \"+map.get((int)m).b);\n                }\n                else{\n                    m-=c;\n                    m = m%(n-1);\n                    if(m==0){\n                        m = n-1;\n                    }\n                    out.println(max+\" \"+arr[(int)m]);\n                }\n\n\n            }\n\n        }\n    }\n\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    static int lcm(int a, int b)\n    {\n        return (a / gcd(a, b)) * b;\n    }\n\n    static class answer implements Comparable<answer>{\n        int a;\n        int b;\n\n        public answer(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(answer o) {\n            return this.a - o.a;\n        }\n    }\n\n    static class answer1 implements Comparable<answer1>{\n        int a, b, c;\n\n        public answer1(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n\n        }\n\n        @Override\n        public int compareTo(answer1 o) {\n            return this.a - o.a;\n        }\n    }\n\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    static void sort(long[] a) {\n        ArrayList<Long> l=new ArrayList<>();\n        for (long i:a) l.add(i);\n        Collections.sort(l);\n        for (int i=0; i<a.length; i++) a[i]=l.get(i);\n    }\n\n    static final Random random=new Random();\n\n    static void shuffleSort(int[] a) {\n        int n=a.length;\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n), temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n}", "complexity": "linear", "problem": "1180_C", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static final int primeCount = 452;\n    static final int[] prime = new int[primeCount];\n\n    static void build_prime() {\n        boolean[] notPrime = new boolean[3200];\n        for (int i = 2; i < 3200; i++) {\n            if (notPrime[i]) continue;\n            for (int j = i * i; j < 3200; j += i) {\n                notPrime[j] = true;\n            }\n        }\n\n        int count = 0;\n        for (int i = 2; i < 3200; i++) {\n            if (notPrime[i]) continue;\n\n            prime[count++] = i;\n        }\n    }\n\n    private static void run(Reader in, PrintWriter out) throws IOException {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = getReal(in.nextInt());\n        }\n\n        int[] pre = new int[n];\n        for (int i = 0; i < n; i++) pre[i] = -1;\n\n        TreeMap<Integer, Integer> exist = new TreeMap<>();\n        for (int i = 0; i < n; i++) {\n            Integer result = exist.get(a[i]);\n            if (result != null) {\n                pre[i] = result;\n            }\n            exist.put(a[i], i);\n        }\n\n        int[][] left = new int[m + 1][n];\n        for (int i = 0; i <= m; i++) {\n            int start = 0;\n            PriorityQueue<Integer> inSame = new PriorityQueue<>();\n            for (int j = 0; j < n; j++) {\n                if (pre[j] >= start) {\n                    inSame.add(pre[j]);\n\n                    if (inSame.size() > i) {\n                        start = inSame.poll() + 1;\n                    }\n                }\n                left[i][j] = start;\n            }\n        }\n\n        int[][] dp = new int[n][m + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= m; j++) {\n                dp[i][j] = Integer.MAX_VALUE;\n            }\n            for (int j = 0; j <= m; j++) {\n                for (int k = 0; k <= j; k++) {\n                    if (left[k][i] == 0) {\n                        dp[i][j] = 1;\n                    } else {\n                        dp[i][j] = Math.min(dp[i][j], dp[left[k][i] - 1][j - k] + 1);\n                    }\n                }\n            }\n        }\n\n        out.println(dp[n - 1][m]);\n    }\n\n    static int getReal(int x) {\n        int result = 1;\n        for (int i = 0; i < primeCount; i++) {\n            if (x % prime[i] == 0) {\n                int count = 0;\n                while (x % prime[i] == 0) {\n                    count++;\n                    x /= prime[i];\n                }\n                if (count % 2 == 1) {\n                    result *= prime[i];\n                }\n            }\n        }\n        result *= x;\n        return result;\n    }\n\n    public static void main(String[] args) throws IOException {\n        Reader in = new Reader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        build_prime();\n        int t = in.nextInt();\n        for (int i = 0; i < t; i++) {\n            run(in, out);\n        }\n\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    static class Reader {\n        BufferedReader reader;\n        StringTokenizer st;\n\n        Reader(InputStreamReader stream) {\n            reader = new BufferedReader(stream, 32768);\n            st = null;\n        }\n\n        void close() throws IOException {\n            reader.close();\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        String nextLine() throws IOException {\n            return reader.readLine();\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n}", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import java.util.Scanner;\n\npublic class Main {\n    private static final Scanner scanner = new Scanner(System.in);\n    private static int OO = (int) 9e6 + 9;\n    private static int[] dx = {0, 1, -1, 1};\n    private static int[] dy = {1, 0, -1, 1};\n\n    public static void main(String[] args) {\n        int n = scanner.nextInt(), s = scanner.nextInt(), r;\n        int[][] arr = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            arr[i][0] = scanner.nextInt();\n            arr[i][1] = scanner.nextInt();\n        }\n        r = s - arr[n - 1][0];\n        if (r < arr[n - 1][1]) {\n            r += (arr[n - 1][1] - r);\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            r += arr[i + 1][0] - arr[i][0];\n            if ((arr[i][1]) > r) {\n                r += (arr[i][1] - r);\n            }\n        }\n        System.out.println(r + arr[0][0]);\n    }\n\n}\n", "complexity": "linear", "problem": "0608_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.io.BufferedWriter;\nimport java.io.DataInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\n\npublic class E {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tFastScanner sc = new FastScanner(System.in);\n\t\tFastPrinter out = new FastPrinter(System.out);\n\t\tE runner = new E();\n\t\trunner.run(sc, out);\n\t\tout.close();\n\t}\n\n\tint N, L;\n\tlong[][] mat;\n\tlong[] dp;\n\n\tpublic void run(FastScanner sc, FastPrinter out) throws Exception {\n\t\tL = sc.nextInt();\n\t\tN = sc.nextInt();\n\t\tmat = new long[N][N];\n\t\tchar[] arr = sc.next().toCharArray();\n\t\tfor (int i = 0; i < L - 1; i++) {\n\t\t\tint cur = arr[i] - 'a';\n\t\t\tint next = arr[i + 1] - 'a';\n\t\t\tif (cur != next) {\n\t\t\t\tmat[cur][next]++;\n\t\t\t\tmat[next][cur]++;\n\t\t\t}\n\t\t}\n\t\tdp = new long[1 << N];\n\t\tArrays.fill(dp, -1);\n\t\tdp[(1 << N) - 1] = 0;\n\t\tlong ans = solve(0);\n\t\tout.println(ans);\n\t}\n\n\tprivate long solve(int mask) {\n\t\tif (dp[mask] == -1) {\n\t\t\tlong value = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif ((mask & (1 << i)) == 0) {\n\t\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\t\tif ((mask & (1 << j)) != 0) {\n\t\t\t\t\t\t\tvalue += mat[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = Long.MAX_VALUE;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif ((mask & (1 << i)) == 0) {\n\t\t\t\t\tlong temp = solve(mask | 1 << i);\n\t\t\t\t\tif (temp < ans) {\n\t\t\t\t\t\tans = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += value;\n\t\t\tdp[mask] = ans;\n\t\t}\n\t\treturn dp[mask];\n\t}\n\n\tpublic void shuffle(int[] arr) {\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tint r = (int) (Math.random() * arr.length);\n\t\t\tif (i != r) {\n\t\t\t\tarr[i] ^= arr[r];\n\t\t\t\tarr[r] ^= arr[i];\n\t\t\t\tarr[i] ^= arr[r];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tfinal private int BUFFER_SIZE = 1 << 10;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic FastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tdin = new DataInputStream(stream);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic FastScanner(String fileName) throws IOException {\n\t\t\tPath p = Paths.get(fileName);\n\t\t\tbuffer = Files.readAllBytes(p);\n\t\t\tbytesRead = buffer.length;\n\t\t}\n\n\t\tint[] nextIntArray(int N) throws IOException {\n\t\t\tint[] arr = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (c != -1 && isEndline(c))\n\t\t\t\tc = read();\n\t\t\tif (c == -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tif (c >= 0) {\n\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t}\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\tint c = readOutSpaces();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg) c = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg) return -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg) c = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg) return -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg) c = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg) return -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tif (din == null) {\n\t\t\t\tbufferPointer = 0;\n\t\t\t\tbytesRead = -1;\n\t\t\t} else {\n\t\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\t}\n\t\t\tif (bytesRead == -1) buffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead) fillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tprivate int readOutSpaces() throws IOException {\n\t\t\twhile (true) {\n\t\t\t\tif (bufferPointer == bytesRead) fillBuffer();\n\t\t\t\tint c = buffer[bufferPointer++];\n\t\t\t\tif (!isSpaceChar(c)) {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null) return;\n\t\t\tdin.close();\n\t\t}\n\n\t\tpublic int[][] readGraph(int N, int M, boolean zeroIndexed, boolean bidirectional) throws Exception {\n\t\t\tint[][] adj = new int[N][];\n\t\t\tint[] numNodes = new int[N];\n\t\t\tint[][] input = new int[M][2];\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = nextInt();\n\t\t\t\tint b = nextInt();\n\t\t\t\tif (zeroIndexed) {\n\t\t\t\t\ta--;\n\t\t\t\t\tb--;\n\t\t\t\t}\n\t\t\t\tinput[i][0] = a;\n\t\t\t\tinput[i][1] = b;\n\t\t\t\tnumNodes[a]++;\n\t\t\t\tif (bidirectional) numNodes[b]++;\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tadj[i] = new int[numNodes[i]];\n\t\t\t\tnumNodes[i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = input[i][0];\n\t\t\t\tint b = input[i][1];\n\t\t\t\tadj[a][numNodes[a]++] = b;\n\t\t\t\tif (bidirectional) adj[b][numNodes[b]++] = a;\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\n\t\tpublic int[][][] readWeightedGraph(int N, int M, boolean zeroIndexed, boolean bidirectional) throws Exception {\n\t\t\tint[][][] adj = new int[N][][];\n\t\t\tint[] numNodes = new int[N];\n\t\t\tint[][] input = new int[M][3];\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = nextInt();\n\t\t\t\tint b = nextInt();\n\t\t\t\tif (zeroIndexed) {\n\t\t\t\t\ta--;\n\t\t\t\t\tb--;\n\t\t\t\t}\n\t\t\t\tint d = nextInt();\n\t\t\t\tinput[i][0] = a;\n\t\t\t\tinput[i][1] = b;\n\t\t\t\tinput[i][2] = d;\n\t\t\t\tnumNodes[a]++;\n\t\t\t\tif (bidirectional) numNodes[b]++;\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tadj[i] = new int[numNodes[i]][2];\n\t\t\t\tnumNodes[i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = input[i][0];\n\t\t\t\tint b = input[i][1];\n\t\t\t\tint d = input[i][2];\n\t\t\t\tadj[a][numNodes[a]][0] = b;\n\t\t\t\tadj[a][numNodes[a]][1] = d;\n\t\t\t\tnumNodes[a]++;\n\t\t\t\tif (bidirectional) {\n\t\t\t\t\tadj[b][numNodes[b]][0] = a;\n\t\t\t\t\tadj[b][numNodes[b]][1] = d;\n\t\t\t\t\tnumNodes[b]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\t}\n\n\tstatic class FastPrinter {\n\t\tstatic final char ENDL = '\\n';\n\t\tStringBuilder buf;\n\t\tPrintWriter pw;\n\n\t\tpublic FastPrinter(OutputStream stream) {\n\t\t\tbuf = new StringBuilder();\n\t\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(stream)));\n\t\t}\n\n\t\tpublic FastPrinter(String fileName) throws Exception {\n\t\t\tbuf = new StringBuilder();\n\t\t\tpw = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));\n\t\t}\n\n\t\tpublic FastPrinter(StringBuilder buf) {\n\t\t\tthis.buf = buf;\n\t\t}\n\n\t\tpublic void print(int a) {\n\t\t\tbuf.append(a);\n\t\t}\n\n\t\tpublic void print(long a) {\n\t\t\tbuf.append(a);\n\t\t}\n\n\t\tpublic void print(char a) {\n\t\t\tbuf.append(a);\n\t\t}\n\n\t\tpublic void print(char[] a) {\n\t\t\tbuf.append(a);\n\t\t}\n\n\t\tpublic void print(double a) {\n\t\t\tbuf.append(a);\n\t\t}\n\n\t\tpublic void print(String a) {\n\t\t\tbuf.append(a);\n\t\t}\n\n\t\tpublic void print(Object a) {\n\t\t\tbuf.append(a.toString());\n\t\t}\n\n\t\tpublic void println() {\n\t\t\tbuf.append(ENDL);\n\t\t}\n\n\t\tpublic void println(int a) {\n\t\t\tbuf.append(a);\n\t\t\tbuf.append(ENDL);\n\t\t}\n\n\t\tpublic void println(long a) {\n\t\t\tbuf.append(a);\n\t\t\tbuf.append(ENDL);\n\t\t}\n\n\t\tpublic void println(char a) {\n\t\t\tbuf.append(a);\n\t\t\tbuf.append(ENDL);\n\t\t}\n\n\t\tpublic void println(char[] a) {\n\t\t\tbuf.append(a);\n\t\t\tbuf.append(ENDL);\n\t\t}\n\n\t\tpublic void println(double a) {\n\t\t\tbuf.append(a);\n\t\t\tbuf.append(ENDL);\n\t\t}\n\n\t\tpublic void println(String a) {\n\t\t\tbuf.append(a);\n\t\t\tbuf.append(ENDL);\n\t\t}\n\n\t\tpublic void println(Object a) {\n\t\t\tbuf.append(a.toString());\n\t\t\tbuf.append(ENDL);\n\t\t}\n\n\t\tpublic void printf(String format, Object... args) {\n\t\t\tbuf.append(String.format(format, args));\n\t\t}\n\n\t\tpublic void close() {\n\t\t\tpw.print(buf);\n\t\t\tpw.close();\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\tpw.print(buf);\n\t\t\tpw.flush();\n\t\t\tbuf.setLength(0);\n\t\t}\n\n\t}\n\n}", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class SolutionD extends Thread {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                                            InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    private static final FastReader scanner = new FastReader();\n    private static final PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        solve();\n        out.close();\n    }\n\n    static int n;\n\n    static class Query implements Comparable<Query> {\n        int l;\n        int r;\n        int k;\n        int index;\n        int bucket;\n        long result = 0;\n\n        public Query(int index, int l, int r, int k) {\n            this.index = index;\n            this.l = l;\n            this.r = r;\n            this.k = k;\n            bucket = l / (int) Math.sqrt(n);\n        }\n\n        @Override\n        public int compareTo(Query o) {\n            if (this.bucket == o.bucket) {\n                return this.r - o.r;\n            }\n            return this.bucket - o.bucket;\n        }\n    }\n\n    private static void solve() {\n        n = scanner.nextInt();\n        int q = scanner.nextInt();\n\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n\n        Query[] queries = new Query[q];\n\n        for (int i = 0; i < q; i++) {\n            int l = scanner.nextInt() - 1;\n            int r = scanner.nextInt();\n            int k = scanner.nextInt();\n            queries[i] = new Query(i, l, r, k);\n\n            if (n == 1) {\n                out.println(1);\n            }\n        }\n        if (n == 1) {\n            return;\n        }\n\n        Arrays.sort(queries);\n\n        int leftPointer = 0;\n        int rightPointer = 0;\n        int[] distr = new int[n+1];\n\n        for (Query query: queries) {\n            while (leftPointer > query.l) {\n                leftPointer--;\n                distr[a[leftPointer]]++;\n            }\n\n            while (rightPointer < query.r) {\n                distr[a[rightPointer]]++;\n                rightPointer++;\n            }\n\n            while (rightPointer > query.r) {\n                rightPointer--;\n                distr[a[rightPointer]]--;\n            }\n\n            while (leftPointer < query.l) {\n                distr[a[leftPointer]]--;\n                leftPointer++;\n            }\n\n            long min = Long.MAX_VALUE;\n            query.result = 1;\n            for (int it = 0; it <= 70; it++) {\n                int randomIndex = (int) (Math.random() * (rightPointer - leftPointer)) + leftPointer;\n                int amount = distr[a[randomIndex]];\n\n                if (amount > (rightPointer - leftPointer) / query.k) {\n                    min = Math.min(min, a[randomIndex]);\n                }\n            }\n\n            if (min == Long.MAX_VALUE) {\n                query.result = -1;\n            } else {\n                query.result = min;\n            }\n        }\n\n        Arrays.sort(queries, Comparator.comparingLong(o -> o.index));\n        Arrays.stream(queries).forEach(query -> out.println(query.result));\n    }\n}", "complexity": "cubic", "problem": "0840_D", "from": "CODEFORCES", "tags": "data structures,probabilities"}
{"src": "import java.util.Scanner;\n\npublic class A {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tlong l = in.nextLong();\n\t\tlong r = in.nextLong();\n\t\tlong a = 0;\n\t\tlong b = 0;\n\t\tlong c = 0;\n\t\tif (r - l < 2)\n\t\t\tSystem.out.println(-1);\n\t\telse if (r - l < 3 && l % 2 == 1)\n\t\t\tSystem.out.println(-1);\n\t\telse {\n\t\t\tif (l % 2 == 0) {\n\t\t\t\ta = l;\n\t\t\t\tb = l + 1;\n\t\t\t\tc = l + 2;\n\t\t\t} else {\n\t\t\t\tif (l == 1) {\n\t\t\t\t\ta = 2;\n\t\t\t\t\tb = 3;\n\t\t\t\t\tc = 4;\n\t\t\t\t} else {\n\t\t\t\t\ta = l + 1;\n\t\t\t\t\tb = l + 2;\n\t\t\t\t\tc = l + 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(a + \" \" + b + \" \" + c);\n\t\t}\n\t\t\n\t}\n}\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int[] ar = new int[n];\n        for (int i = 0; i < n; i++) {\n            ar[i] = sc.nextInt();\n        }\n        Arrays.sort(ar);\n        if (ar[b-1] == ar[b ]) {\n            System.out.println(0);\n        } else {\n            System.out.println(ar[b ] - ar[b-1]);\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\n\n/**\n * @author Egor Kulikov (egor@egork.net)\n *         Created on 14.03.2010\n */\npublic class TaskA implements Runnable {\n\tprivate InputReader in;\n\tprivate PrintWriter out;\n\n\tpublic static void main(String[] args) {\n//\t\tnew Thread(new Template()).start();\n\t\tnew TaskA().run();\n\t}\n\n\tpublic TaskA() {\n//\t\tString id = getClass().getName().toLowerCase();\n//\t\ttry {\n//\t\t\tSystem.setIn(new FileInputStream(id + \".in\"));\n//\t\t\tSystem.setOut(new PrintStream(new FileOutputStream(id + \".out\")));\n//\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n//\t\t\tSystem.setOut(new PrintStream(new FileOutputStream(\"output.txt\")));\n//\t\t} catch (FileNotFoundException e) {\n//\t\t\tthrow new RuntimeException();\n//\t\t}\n\t\tin = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t}\n\n\tpublic void run() {\n//        int numTests = in.readInt();\n//        for (int testNumber = 0; testNumber < numTests; testNumber++) {\n//\t\t\tout.print(\"Case \" + (testNumber + 1) + \": \");\n//        }\n\t\tint n = in.readInt();\n\t\tint min = 101;\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmin = Math.min(min, a[i] = in.readInt());\n\t\tint ans = 101;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] > min)\n\t\t\t\tans = Math.min(ans, a[i]);\n\t\t}\n\t\tif (ans == 101)\n\t\t\tout.println(\"NO\");\n\t\telse\n\t\t\tout.println(ans);\n\t\tout.close();\n\t}\n\n\tprivate static class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1000];\n\t\tprivate int curChar, numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int readInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long readLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuffer res = new StringBuffer();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate String readLine0() {\n\t\t\tStringBuffer buf = new StringBuffer();\n\t\t\tint c = read();\n\t\t\twhile (c != '\\n' && c != -1) {\n\t\t\t\tbuf.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\treturn buf.toString();\n\t\t}\n\n\t\tpublic String readLine() {\n\t\t\tString s = readLine0();\n\t\t\twhile (s.trim().length() == 0)\n\t\t\t\ts = readLine0();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic String readLine(boolean ignoreEmptyLines) {\n\t\t\tif (ignoreEmptyLines)\n\t\t\t\treturn readLine();\n\t\t\telse\n\t\t\t\treturn readLine0();\n\t\t}\n\n\t\tpublic BigInteger readBigInteger() {\n\t\t\ttry {\n\t\t\t\treturn new BigInteger(readString());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tpublic char readCharacter() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\treturn (char) c;\n\t\t}\n\n\t\tpublic double readDouble() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') {\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t}\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * @author grozhd\n */\npublic class P3 {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n\n        String s = \"\";\n        while (s.length() == 0) {\n            s = sc.nextLine();\n        }\n        char[] pokemons = s.toCharArray();\n\n        Set<Character> pokemonTypes = new HashSet<>();\n        for (int i = 0; i < n; i++) {\n            pokemonTypes.add(pokemons[i]);\n        }\n\n        int types = pokemonTypes.size();\n\n        int l = 0;\n        int r = 0;\n        int min = n;\n        Map<Character, Integer> currentPokemons = new HashMap<>();\n\n\n        while (r < n) {\n            while (currentPokemons.size() < types && r < n) {\n                char pokemon = pokemons[r++];\n                currentPokemons.merge(pokemon, 1, (a, b) -> a + b);\n            }\n            min = Math.min(r - l, min);\n\n            while (currentPokemons.size() == types) {\n                char pokemon = pokemons[l++];\n                if (currentPokemons.get(pokemon) == 1) {\n                    currentPokemons.remove(pokemon);\n                } else {\n                    min = Math.min(r - l, min);\n                    currentPokemons.put(pokemon, currentPokemons.get(pokemon) - 1);\n                }\n            }\n        }\n\n        min = Math.min(min, r - l + 1);\n        min = Math.max(min, types);\n\n        System.out.println(min);\n\n    }\n}", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.util.ArrayList;\n\nimport java.util.Collections;\n\nimport java.util.List;\n\nimport java.util.Scanner;\n\n\n\npublic class Main {\n\n    private static class Node<V extends Comparable<V>> {\n\n        public Node parent;\n\n        private final V data;\n\n\n\n        public Node(V data) {\n\n            this.data = data;\n\n            this.parent = null;\n\n        }\n\n\n\n    }\n\n\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        long n = sc.nextLong(), s = sc.nextLong();\n\n        long first = -1l;\n\n        for (long i = s; i < s + 1000l; i = i + 1l) {\n\n            if (i - summa(i) >= s) {\n\n                first = i;\n\n                break;\n\n            }\n\n        }\n\n        long res = n - first + 1l;\n\n        if(res<0) res = 0;\n\n        System.out.println(res);\n\n\n\n    }\n\n\n\n    static long summa(long n) {\n\n        long sum = 0l;\n\n        if (n % 10l == n) return n;\n\n        sum += n % 10l + summa(n / 10l);\n\n        return sum;\n\n    }\n\n}\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] poks = in.next().toCharArray();\n            boolean[] was = new boolean[52];\n            for (int i = 0; i < n; i++) {\n                if (Character.isLowerCase(poks[i])) {\n                    was[poks[i] - 'a'] = true;\n                } else {\n                    was[poks[i] - 'A' + 26] = true;\n                }\n            }\n            int count = 0;\n            for (int i = 0; i < 52; i++) {\n                count += was[i] ? 1 : 0;\n            }\n            int[] vis = new int[52];\n            int pre = 0;\n            int chr = 0;\n            int ans = Integer.MAX_VALUE;\n            for (int i = 0; i < n; i++) {\n                int pos = poks[i] - 'a';\n                if (Character.isUpperCase(poks[i])) {\n                    pos = poks[i] - 'A' + 26;\n                }\n\n                if (vis[pos] == 0) {\n                    chr++;\n                }\n                vis[pos]++;\n                while (chr == count) {\n                    ans = Math.min(ans, i - pre + 1);\n                    pos = poks[pre] - 'a';\n                    if (Character.isUpperCase(poks[pre])) {\n                        pos = poks[pre] - 'A' + 26;\n                    }\n                    vis[pos]--;\n                    if (vis[pos] == 0) chr--;\n                    pre++;\n                }\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint l = 1000, r = 0, u = 1000, b = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++ ) {\n\t\t\tString str = in.next();\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tif(str.charAt(j) == 'B') {\n\t\t\t\t\tl = Math.min(j+1, l);\n\t\t\t\t\tr = Math.max(j+1, r);\n\t\t\t\t\tu = Math.min(i+1, u);\n\t\t\t\t\tb = Math.max(i+1, b);\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println((u+b)/2 + \" \" + (l+r)/2);\n\t\t\n\t\tin.close();\n\t}\n}\n\n\n\n", "complexity": "quadratic", "problem": "1028_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\nimport java.math.*;\n\npublic class Main {\n    \n    void run() throws IOException {\n        String s = token();\n        HashSet <String> h;\n        int n = s.length();\n        int r = 0;\n        loop: for (int i = 1; i <= n; i++) {\n            h = new HashSet();\n            for (int j = 0; j < n - i + 1; j++) {\n                String t = s.substring(j, j + i);\n                if (h.contains(t)) {\n                    r = i;\n                    continue loop;\n                } else {\n                    h.add(t);\n                }\n            }\n        }\n        System.out.println(r);\n    }\n\n    public static void main(String[] args) throws IOException {\n        Locale.setDefault(Locale.US);\n        //final String FILENAME = \"dvd\";\n        //in = new BufferedReader(new FileReader(new File(FILENAME + \".in\")));\n        //out = new PrintWriter(new File(FILENAME + \".out\"));\n        in = new BufferedReader(new InputStreamReader(System.in));\n        //in = new Scanner(System.in);\n        out = new PrintWriter(System.out);\n        st = new StringTokenizer(\" \");\n        new Main().run();\n        out.close();\n    }\n\n    static BufferedReader in;\n    //static Scanner in;\n    static PrintWriter out;\n    static StringTokenizer st;\n\n    String token() throws IOException {\n        while (!st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nint() throws IOException {\n        return Integer.parseInt(token());\n    }\n\n    long nlong() throws IOException {\n        return Long.parseLong(token());\n    }\n\n    double ndouble() throws IOException {\n        return Double.parseDouble(token());\n    }\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class TemnayaAssambleya implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new TemnayaAssambleya()).run();\n\t}\n\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer in;\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tpublic String nextToken() throws IOException {\n\t\twhile (in == null || !in.hasMoreTokens()) {\n\t\t\tin = new StringTokenizer(br.readLine());\n\t\t}\n\n\t\treturn in.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tint[] l;\n\tint[] ln;\n\tint[] pw;\n\tint[] p;\n\tint A;\n\tdouble max = 0;\n\n\tpublic void gen(int n, int k) {\n\t\tif (n == 0) {\n\t\t\tn = p.length;\n\t\t\tp[0] = k;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tln[i] = l[i] + p[i] * 10;\n\t\t\t\tif (ln[i] > 100)\n\t\t\t\t\tln[i] = 100;\n\t\t\t}\n\n\t\t\tdouble ans = 0;\n\t\t\tfor (int mask = 0; mask < 1 << n; mask++) {\n\t\t\t\tint z = 0;\n\t\t\t\tdouble pos = 1;\n\t\t\t\tint power = 0;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif ((mask & (1 << i)) > 0) {\n\t\t\t\t\t\tz++;\n\t\t\t\t\t\tpos *= ln[i] * 1. / 100;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos *= (100 - ln[i]) * 1. / 100;\n\t\t\t\t\t\tpower += pw[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (z > n / 2) {\n\t\t\t\t\tans += pos;\n\t\t\t\t} else {\n\t\t\t\t\tans += pos * A / (A + power);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmax = Math.max(ans, max);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 0; i <= Math.min(k, 10 - l[n] / 10); i++) {\n\t\t\tp[n] = i;\n\t\t\tgen(n - 1, k - i);\n\t\t}\n\t}\n\n\tpublic void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tA = nextInt();\n\n\t\tp = new int[n];\n\t\tpw = new int[n];\n\t\tl = new int[n];\n\t\tln = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpw[i] = nextInt();\n\t\t\tl[i] = nextInt();\n\t\t}\n\n\t\tgen(n - 1, k);\n\t\tout.println(max);\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.util.Scanner;\n\npublic class code0 {\n\npublic static void main(String[] args){\n\tScanner scr= new Scanner(System.in);\nint c=0,e=0,d=0;\nint a=scr.nextInt();\nd=a/2;\nif(a>=11 && a%2==1){\nc=9;\ne=a-9;\n}\nelse{\nc=a-4;e=4;\n}\n\nSystem.out.print(c+\" \"+e);\n}\n\n}\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\npublic final class CF {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        ArrayList<String> a = new ArrayList<>();\n        for(int i = 0; i<n; i++)\n            a.add(sc.next());\n        int count = 0;\n        for(int i = 0; i<n; i++) {\n            String b = sc.next();\n            int idx = a.indexOf(b);\n            if(idx!=-1)\n                a.remove(idx);\n            else\n                count++;\n        }\n        System.out.println(count);\n    }\n}", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class givenstring {\n\tpublic static void main(String[] args){\n\t\tScanner reader = new Scanner(System.in);\n\t\tString in = reader.next();\n\t\t\n\t\tint max = 0;\n\t\t\n\t\tfor(int i = 0; i < in.length(); i++){\n\t\t\tfor(int j = i+1; j < in.length(); j++){\n\t\t\t\t//take this substring\n\t\t\t\tString consider = in.substring(i, j);\n\t\t\t\tfor(int k = i+1; k < in.length(); k++){\n\t\t\t\t\tif(k + consider.length() > in.length())\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse if(in.substring(k, k+consider.length()).equals(consider))\n\t\t\t\t\t\tmax = Math.max(max, consider.length());\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(max);\n\t}\t\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n    public static void main(String[] args){\n        Scanner cin = new Scanner(System.in);\n        int a[] = new int[105];\n        int vis[] = new int[105];\n        Arrays.fill(vis, 0);\n        int n = cin.nextInt();\n        for(int i = 0; i < n; i++)\n            a[i] = cin.nextInt();\n        Arrays.sort(a, 0, n);\n        int ans = 0;\n\n        for(int i = 0; i < n; i++){\n            int x = a[i];\n            if(vis[x] == 0){\n                ans++;\n                for(int j = x; j < 105; j += x)\n                    vis[j] = 1;\n            }\n        }\n        System.out.println(ans);\n    }\n}\n\t\t   \t\t\t\t\t \t\t\t\t   \t \t\t", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class q1 {\n    public static MyScanner in = new MyScanner();\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out), true);\n    public static MyViewer view = new MyViewer();\n    public static BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));\n    public static Random rand = new Random(System.currentTimeMillis());\n\n    public static class Pair<A, B> {\n        private final A first;\n        private final B second;\n\n        public Pair(A first, B second) {\n            super();\n            this.first = first;\n            this.second = second;\n        }\n\n        public int hashCode() {\n            int hashFirst = first != null ? first.hashCode() : 0;\n            int hashSecond = second != null ? second.hashCode() : 0;\n\n            return (hashFirst + hashSecond) * hashSecond + hashFirst;\n        }\n\n        public boolean equals(Object other) {\n            if (other instanceof Pair) {\n                Pair otherPair = (Pair) other;\n                return\n                        ((this.first == otherPair.first ||\n                                (this.first != null && otherPair.first != null &&\n                                        this.first.equals(otherPair.first))) &&\n                                (this.second == otherPair.second ||\n                                        (this.second != null && otherPair.second != null &&\n                                                this.second.equals(otherPair.second))));\n            }\n\n            return false;\n        }\n\n        public String toString() {\n            return \"(\" + first + \", \" + second + \")\";\n        }\n\n        public A getFirst() {\n            return first;\n        }\n\n        public B getSecond() {\n            return second;\n        }\n    }\n\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        private boolean randomInput = false;\n        private Random rand;\n\n        void randomInput(boolean r) {\n            randomInput = r;\n            rand = new Random(System.currentTimeMillis());\n            //rand = new Random(42);\n        }\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public MyScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int nextInt(int val) {\n            return randomInput ? val : Integer.parseInt(next());\n        }\n\n        public int nextInt(int low, int high) {\n            if (randomInput) {\n                return rand.nextInt(high - low + 1) + low;\n            } else {\n                return Integer.parseInt(next());\n            }\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        long nextLong(long val) {\n            return randomInput ? val : Long.parseLong(next());\n        }\n\n        long nextLong(long low, long high) {\n            if (randomInput) {\n                return low + ((long) (rand.nextDouble() * (high - low + 1)));\n            } else {\n                return Long.parseLong(next());\n            }\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int[] arrayInt(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        int[] arrayInt(int n, int low, int high) {\n            int[] a = new int[n];\n            if (randomInput) {\n                for (int i = 0; i < n; i++) {\n                    a[i] = rand.nextInt(high - low + 1) + low;\n                }\n            } else {\n                for (int i = 0; i < n; i++) {\n                    a[i] = nextInt();\n                }\n            }\n            return a;\n        }\n\n        ArrayList<Integer> list(int n) {\n            ArrayList<Integer> a = new ArrayList<Integer>(n);\n            for (int i = 0; i < n; i++) {\n                a.add(nextInt());\n            }\n            return a;\n        }\n\n        ArrayList<Integer> list(int n, int low, int high) {\n            ArrayList<Integer> a = new ArrayList<Integer>(n);\n            if (randomInput) {\n                for (int i = 0; i < n; i++) {\n                    a.add(rand.nextInt(high - low + 1) + low);\n                }\n            } else {\n                for (int i = 0; i < n; i++) {\n                    a.add(nextInt());\n                }\n            }\n            return a;\n        }\n\n        long[] arrayLong(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        long[] arrayLong(int n, long low, long high) {\n            long[] a = new long[n];\n            if (randomInput) {\n                for (int i = 0; i < n; i++) {\n                    double r = rand.nextDouble();\n                    a[i] = (long) (r * (double) (high - low + 1)) + low;\n                    if (a[i] == 0) {\n                        out.println(\"Ouch : \" + r);\n                    }\n                }\n            } else {\n                for (int i = 0; i < n; i++) {\n                    a[i] = nextLong();\n                }\n            }\n            return a;\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        ArrayList<ArrayList<Integer>> randomTree(int n) {\n            ArrayList<ArrayList<Integer>> edges = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                edges.add(new ArrayList<>());\n            }\n\n            for (int i = 1; i < n; i++) {\n                int par = rand.nextInt(i);\n                edges.get(par).add(i);\n            }\n            return edges;\n        }\n    }\n\n    static class MyViewer {\n        private static boolean print = true;\n\n        public void on() {\n            print = true;\n        }\n\n        public void off() {\n            print = false;\n        }\n\n        public <T extends List> void list(T a) {\n            if (!print) return;\n            if (a == null) {\n                out.println(\"List: NULL\");\n                return;\n            }\n            if (a.size() == 0) {\n                out.println(\"List: []\");\n                return;\n            }\n            out.print(\"List: [\" + a.get(0));\n            for (int i = 1; i < a.size(); i++) {\n                out.print(\", \" + a.get(i));\n            }\n            out.println(\"] Len: \" + a.size());\n        }\n\n        public <T> void array(T[] a) {\n            if (!print) return;\n            if (a == null) {\n                out.println(\"Array: NULL\");\n                return;\n            }\n            if (a.length == 0) {\n                out.println(\"Array: []\");\n                return;\n            }\n            out.print(\"Array: [\" + a[0]);\n            for (int i = 1; i < a.length; i++) {\n                out.print(\", \" + a[i]);\n            }\n            out.println(\"] Len: \" + a.length);\n        }\n\n        public void array(boolean[] a) {\n            if (!print) return;\n            if (a == null) {\n                out.println(\"boolean[]: NULL\");\n                return;\n            }\n            if (a.length == 0) {\n                out.println(\"boolean[]: Len: 0\");\n                return;\n            }\n            out.print(\"boolean[] Len: \" + a.length + \" [\");\n            for (boolean x : a) {\n                out.print(x + \", \");\n            }\n            out.println(\"\\b\\b]\");\n        }\n\n        public void array(int[] a) {\n            if (!print) return;\n\n            if (a == null) {\n                out.println(\"Array: NULL\");\n                return;\n            }\n            if (a.length == 0) {\n                out.println(\"Array: []\");\n                return;\n            }\n            out.print(\"int[] Len: \" + a.length + \" [\");\n            for (int x : a) {\n                out.print(x + \", \");\n            }\n            out.println(\"\\b\\b]\");\n        }\n\n        public void array(long[] a) {\n            if (!print) return;\n            if (a == null) {\n                out.println(\"Array: NULL\");\n                return;\n            }\n            if (a.length == 0) {\n                out.println(\"Array: []\");\n                return;\n            }\n            out.print(\"long Array: [\");\n            for (long x : a) {\n                out.print(x + \", \");\n            }\n            out.println(\"\\b\\b] Len: \" + a.length);\n        }\n\n        public void matrix(int[][] a, int cutoff) {\n            if (cutoff == 0)\n                cutoff = Integer.MAX_VALUE;\n            if (a == null) {\n                out.println(\"Matrix: NULL\");\n                return;\n            }\n            for (int i = 0; i < a.length; i++) {\n                if (i < cutoff) {\n                    printMatrixRow(a[i], cutoff);\n                } else {\n                    out.println(\"     ...\");\n                    printMatrixRow(a[a.length - 1], cutoff);\n                    break;\n                }\n            }\n        }\n\n        public void matrix(long[][] a, long cutoff) {\n            if (cutoff == 0)\n                cutoff = Long.MAX_VALUE;\n            if (a == null) {\n                out.println(\"Matrix: NULL\");\n                return;\n            }\n            for (int i = 0; i < a.length; i++) {\n                if (i < cutoff) {\n                    printMatrixRow(a[i], cutoff);\n                } else {\n                    out.println(\"     ...\");\n                    printMatrixRow(a[a.length - 1], cutoff);\n                    break;\n                }\n            }\n        }\n\n        public void matrix(boolean[][] a, int cutoff) {\n            if (cutoff == 0)\n                cutoff = Integer.MAX_VALUE;\n            if (a == null) {\n                out.println(\"Matrix: NULL\");\n                return;\n            }\n            for (int i = 0; i < a.length; i++) {\n                if (i < cutoff) {\n                    printMatrixRow(a[i], cutoff);\n                } else {\n                    out.println(\"     ...\");\n                    printMatrixRow(a[a.length - 1], cutoff);\n                    break;\n                }\n            }\n        }\n\n        private void printMatrixRow(int[] a, int cutoff) {\n            for (int j = 0; j < a.length; j++) {\n                if (j < cutoff) {\n                    out.printf(\"%6d  \", a[j]);\n                } else {\n                    out.printf(\" ... %6d\", a[a.length - 1]);\n                    break;\n                }\n            }\n            out.println();\n        }\n\n        private void printMatrixRow(long[] a, long cutoff) {\n            for (int j = 0; j < a.length; j++) {\n                if (j < cutoff) {\n                    out.printf(\"%6d  \", a[j]);\n                } else {\n                    out.printf(\" ... %6d\", a[a.length - 1]);\n                    break;\n                }\n            }\n            out.println();\n        }\n\n        private void printMatrixRow(boolean[] a, int cutoff) {\n            for (int j = 0; j < a.length; j++) {\n                if (j < cutoff) {\n                    out.print(a[j] ? \"T \" : \"F \");\n                } else {\n                    out.print(\" ... \" + (a[a.length - 1] ? \"T\" : \"F\"));\n                    break;\n                }\n            }\n            out.println();\n        }\n\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = in.nextInt();\n        int d = in.nextInt();\n\n        int[] a = in.arrayInt(n);\n\n        int count = 2;\n\n        for(int i = 0 ;i < n-1; i++) {\n            if( a[i+1] - a[i] == 2 * d )\n                count += 1;\n            if( a[i+1] - a[i] > 2 * d)\n                count += 2;\n        }\n\n        out.println(count);\n\n\n\n        log.flush();\n        in.close();\n    }\n}\n", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\n\n/**\n * @author khokharnikunj8\n */\n\npublic class Main {\n    public static void main(String[] args) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                new Main().solve();\n            }\n        }, \"1\", 1 << 26).start();\n    }\n\n    void solve() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BSportMafia solver = new BSportMafia();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BSportMafia {\n        public long findsqrt(long a) {\n            long b = (long) Math.sqrt(a);\n            for (long tt = Math.max(0, b - 10); tt <= b + 10; tt++) if (tt * tt == a) return tt;\n            return -1;\n        }\n\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            long n = in.scanInt();\n            long k = in.scanInt();\n            out.println(n - (-3 + findsqrt(9 + 8 * (k + n))) / 2);\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int index;\n        private BufferedInputStream in;\n        private int total;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (index >= total) {\n                index = 0;\n                try {\n                    total = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (total <= 0) return -1;\n            }\n            return buf[index++];\n        }\n\n        public int scanInt() {\n            int integer = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    integer *= 10;\n                    integer += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * integer;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.*;\n\npublic class C {\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n\n    int n = sc.nextInt();\n    long r = sc.nextInt();\n    double d = 2 * r;\n    long[] xs = sc.readLongArray(n);\n    P[] points = new P[n];\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < n; i++) {\n      if (i > 0) sb.append(' ');\n      double y = r;\n      for (int j = 0; j < i; j++) {\n        long diff = Math.abs(xs[i] - points[j].x);\n        if (diff <= 2 * r) {\n          double dy = Math.sqrt(d * d - diff * diff);\n          double testY = points[j].y + dy;\n          y = Math.max(y, testY);\n        }\n      }\n\n      sb.append(y);\n      points[i] = new P(xs[i], y);\n    }\n    System.out.println(sb);\n  }\n\n  static class P {\n    final long x;\n    final double y;\n\n    public P(long x, double y) {\n      this.x = x;\n      this.y = y;\n    }\n  }\n\n  static void shuffle(int[] arr) {\n    Random rng = new Random();\n    int length = arr.length;\n    for (int idx = 0; idx < arr.length; idx++) {\n      int toSwap = idx + rng.nextInt(length - idx);\n      int tmp = arr[idx];\n      arr[idx] = arr[toSwap];\n      arr[toSwap] = tmp;\n    }\n  }\n\n  public static class FastScanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastScanner(Reader in) {\n      br = new BufferedReader(in);\n    }\n\n    public FastScanner() {\n      this(new InputStreamReader(System.in));\n    }\n\n    String next() {\n      while (st == null || !st.hasMoreElements()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    String readNextLine() {\n      String str = \"\";\n      try {\n        str = br.readLine();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      return str;\n    }\n\n    int[] readIntArray(int n) {\n      int[] a = new int[n];\n      for (int idx = 0; idx < n; idx++) {\n        a[idx] = nextInt();\n      }\n      return a;\n    }\n\n    long[] readLongArray(int n) {\n      long[] a = new long[n];\n      for (int idx = 0; idx < n; idx++) {\n        a[idx] = nextLong();\n      }\n      return a;\n    }\n  }\n}\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class B {\n\n    public void solve() throws IOException {\n        long n = nextInt(), k = nextInt();\n        long c = 2 * (n + k);\n        long l = -1, r = 200000;\n        while (r - l > 1) {\n            long m = l + (r - l) / 2;\n            if (m * m + 3 * m >= c) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        out.print(n - r);\n    }\n\n    public void run() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    BufferedReader br;\n    StringTokenizer in;\n    PrintWriter out;\n\n    public String nextToken() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n        return in.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public int[] nextArr(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nextInt();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        Locale.setDefault(Locale.US);\n        new B().run();\n    }\n}", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.PrintWriter;\nimport java.util.Locale;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        try (BufferedInputStream in = new BufferedInputStream(System.in);\n             PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out))) {\n\n            Scanner sc = new Scanner(in).useLocale(Locale.US);\n//            int T = sc.nextInt();\n//            for (int t = 0; t < T; t++) {\n//        }\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int k = sc.nextInt();\n\n            int[][] w1 = new int[n][m - 1];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m - 1; j++) {\n                    w1[i][j] = sc.nextInt();\n                }\n            }\n            int[][] w2 = new int[n - 1][m];\n            for (int i = 0; i < n - 1; i++) {\n                for (int j = 0; j < m; j++) {\n                    w2[i][j] = sc.nextInt();\n                }\n            }\n\n            if (k % 2 != 0) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < m; j++) {\n                        out.print(-1 + \" \");\n                    }\n                    out.println();\n                }\n                return;\n            }\n\n            int[][] neis = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n\n            int[][] minDist = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    minDist[i][j] = Integer.MAX_VALUE;\n                    for (int[] nei : neis) {\n                        int i1 = i + nei[0];\n                        int j1 = j + nei[1];\n                        if (0 <= i1 && i1 < n && 0 <= j1 && j1 < m) {\n                            minDist[i][j] = Math.min(minDist[i][j], dist(i, j, i1, j1, w1, w2));\n                        }\n                    }\n                }\n            }\n\n            int[][][] dp = new int[n][m][k + 1];\n            for (int l = 2; l <= k; l += 2) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < m; j++) {\n                        dp[i][j][l] = dp[i][j][l - 2] + 2 * minDist[i][j];\n                        for (int[] nei : neis) {\n                            int i1 = i + nei[0];\n                            int j1 = j + nei[1];\n                            if (0 <= i1 && i1 < n && 0 <= j1 && j1 < m) {\n                                dp[i][j][l] = Math.min(dp[i][j][l],\n                                                       2 * dist(i, j, i1, j1, w1, w2) + dp[i1][j1][l - 2]);\n                            }\n                        }\n                    }\n                }\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    out.print(dp[i][j][k] + \" \");\n                }\n                out.println();\n            }\n        }\n    }\n\n    private static int dist(int i, int j, int i1, int j1, int[][] w1, int[][] w2) {\n        if (i == i1) {\n            return w1[i][Math.min(j, j1)];\n        } else {\n            return w2[Math.min(i, i1)][j];\n        }\n    }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Edu_23C {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer inputData = new StringTokenizer(reader.readLine());\n\t\tlong bound = Long.parseLong(inputData.nextToken());\n\t\tlong s = Long.parseLong(inputData.nextToken());\n\t\tif(bound < s){\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\n\t\tlong cur = s;\n\t\twhile (cur <= bound && s + digitSum(cur) > cur) {\n\t\t\tcur++;\n\t\t}\n\t\tSystem.out.println(bound - cur + 1);\n\t}\n\n\tstatic int digitSum(long inp) {\n\t\tint sum = 0;\n\t\twhile (inp != 0) {\n\t\t\tsum += inp % 10;\n\t\t\tinp /= 10;\n\t\t}\n\t\treturn sum;\n\t}\n\n}\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "//package test_1177a;\n\nimport java.util.Scanner;\n\n\nimport java.util.Scanner;\n\n    public class test1177b{\n        public  static  void main(String[] args){\n            Scanner sc = new Scanner(System.in);\n            long k =  sc.nextLong();\n            long k1 =0,k2 = 0;\n            long p = 1;\n            String str=\"\";\n            for (int i=1; i<=12;i++){\n                if (k>= k1 && k <= k1 + p * 9 *i){\n                    // \u041d\u0430\u0448\u043b\u0438 \u043f\u043e\u0440\u044f\u0434\u043e\u043a\n                    long kk = ((k - k1) % i);\n\n                    k2 = p  + (k - k1) / i -1;\n                    if (kk != 0) k2 ++;\n                    str =\"\"+ k2;\n                    if(str.length() > i) {\n                        k2--;\n                        str =\"\"+ k2;\n                        kk =0;\n                    }\n                    if(kk > 0){\n                        System.out.println(str.charAt((int)kk-1));\n                    }else{\n                        System.out.println(str.charAt(i-1));\n                    }\n                    break;\n                }else {\n                    k1 += p * 9 *i;\n                    p = p * 10;\n                }\n            }\n\n        }\n    }\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class A0023 {\n\n    public static void main(String args[]) throws Exception {\n        new A0023();\n    }\n\n    A0023() throws Exception {\n        PandaScanner sc = null;\n        PrintWriter out = null;\n        try {\n            sc = new PandaScanner(System.in);\n            out = new PrintWriter(System.out);\n        } catch (Exception ignored) {\n        }\n\n        String s = sc.next();\n        int i = s.length() - 1;\n        Test: for (; i > 0; i--) {\n            HashSet<String> set = new HashSet<String>();\n            for (int j = 0; j + i <= s.length(); j++) {\n                String ss = s.substring(j, j + i);\n                if (set.contains(ss)) {\n                    break Test;\n                }\n                set.add(ss);\n            }\n        }\n        out.println(i);\n\n        out.close();\n        System.exit(0);\n    }\n\n\n    //The PandaScanner class, for Panda fast scanning!\n    public class PandaScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        InputStream in;\n\n        PandaScanner(InputStream in) throws Exception {\n            br = new BufferedReader(new InputStreamReader(this.in = in));\n        }\n\n        public String next() throws Exception {\n            if (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine().trim());\n                return next();\n            }\n            return st.nextToken();\n        }\n\n        public boolean hasNext() throws Exception {\n            return (st != null && st.hasMoreTokens()) || in.available() > 0;\n        }\n\n        public long nextLong() throws Exception {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() throws Exception {\n            return Integer.parseInt(next());\n        }\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.Scanner;\n\npublic class A{\n\tpublic static void main(String[] args){\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\n\t\tint prev2=0;\n\t\tint prev1=1;\n\t\tint prev=1;\n\t\tint curr = 2;\n\t\tif(n == 0) {System.out.println(\"0 0 0\"); return;}\n\t\telse if(n == 1) {System.out.println(\"0 0 1\");return;}\n\t\twhile(true){\n\t\t\tif(curr == n) break;\n\t\t\tprev2 = prev1;\n\t\t\tprev1 = prev;\n\t\t\tint temp = prev + curr;\n\t\t\tprev = curr;\n\t\t\tcurr = temp;\n\t\t}\n\t\tSystem.out.println(prev2 + \" \" + prev1 + \" \" + prev1);\n\t}\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "//package round35;\n\nimport java.io.File;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class C {\n\tScanner in;\n\tPrintWriter out;\n//\tString INPUT = \"3 3 1 1 1\";\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint m = ni();\n\t\tint k = ni();\n\t\tint[] x = new int[k];\n\t\tint[] y = new int[k];\n\t\tfor(int i = 0;i < k;i++){\n\t\t\tx[i] = ni() - 1;\n\t\t\ty[i] = ni() - 1;\n\t\t}\n\t\tint max = -1;\n\t\tint maxi = -1;\n\t\tint maxj = -1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\tfor(int l = 0;l < k;l++){\n\t\t\t\t\tmin = Math.min(min, Math.abs(x[l] - i) + Math.abs(y[l] - j));\n\t\t\t\t}\n\t\t\t\tif(min > max){\n\t\t\t\t\tmax = min;\n\t\t\t\t\tmaxi = i;\n\t\t\t\t\tmaxj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println((maxi+1) + \" \" + (maxj+1));\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tin = INPUT.isEmpty() ? new Scanner(new File(\"input.txt\")) : new Scanner(INPUT);\n\t\tout = INPUT.isEmpty() ? new PrintWriter(\"output.txt\") : new PrintWriter(System.out);\n\n\t\tsolve();\n\t\tout.flush();\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew C().run();\n\t}\n\t\n\tint ni() { return Integer.parseInt(in.next()); }\n\tvoid tr(Object... o) { if(INPUT.length() != 0)System.out.println(o.length > 1 || o[0].getClass().isArray() ? Arrays.deepToString(o) : o[0]); }\n\tstatic String join(int[] a, int d){StringBuilder sb = new StringBuilder();for(int v : a){sb.append(v + d + \" \");}return sb.toString();}\n}\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static final long MOD = 1000000007L;\n    \n    public static void main(String[] args) throws Exception {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int k = scan.nextInt();\n        int res = -1;\n        int[] arr = new int[n];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = scan.nextInt();\n        }\n        BitSet bits = new BitSet();\n        int count = 0;\n        int end = -1;\n        for (int i = 0; i < arr.length; i++) {\n            if (!bits.get(arr[i])) {\n                bits.set(arr[i]);\n                count++;\n                if (count == k) {\n                    end = i;\n                    break;\n                }\n            }\n        }\n        if (end == -1) {\n            System.out.print(\"-1 -1\");\n            return;\n        }\n        bits = new BitSet();\n        count = 0;\n        int start = end;\n        while (start >= 0) {\n            if (!bits.get(arr[start])) {\n                bits.set(arr[start]);\n                count++;\n                if (count == k) {\n                    break;\n                }\n            }\n            start--;\n        }\n        System.out.println((start + 1) + \" \" + (end + 1));\n    }\n}", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.Stack;\n\n\nimport java.util.StringTokenizer;\n\n\n public class Test\n {\n    \n     static PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args)throws Exception\n    {\n        Reader.init(System.in);\n        int n = Reader.nextInt();\n        int p = Reader.nextInt();\n        int L = Reader.nextInt();\n        int R = Reader.nextInt();\n        int a = 1;\n        int b = n;\n        int res = 0;\n        \n        if(a == L && b == R)\n        {\n            res = 0;\n        }\n        else if(L != a && R != b && p >= L && p <= R)\n        {\n            res = Math.min(p-L, R-p);\n            res += R- L + 2;\n        }\n        else if(L != a && R != b && p < L )\n        {\n            res += L-p + 1;\n            res += R - L +1;\n        }\n        else if(L != a && R != b && p > R)\n        {\n            res += p-R + 1;\n            res += R - L +1;\n        }\n        else if(a == L && p >=L && p<=R)\n        {\n            res += R - p + 1;\n        }\n        else if(R == b && p>=L && p<=R)\n        {\n            res += p - L + 1;\n        }\n        else if(a == L && p > R)\n        {\n            res += p - R + 1;\n        }\n        else if(R == b && p<L)\n        {\n            res += L - p + 1;\n        }\n            \n            \n        pw.print(res);\n        pw.close();\n \n    }\n        \n}\n\nclass Reader {\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    public static int pars(String x) {\n        int num = 0;\n        int i = 0;\n        if (x.charAt(0) == '-') {\n            i = 1;\n        }\n        for (; i < x.length(); i++) {\n            num = num * 10 + (x.charAt(i) - '0');\n        }\n\n        if (x.charAt(0) == '-') {\n            return -num;\n        }\n\n        return num;\n    }\n\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                new InputStreamReader(input));\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    static void init(FileReader input) {\n        reader = new BufferedReader(input);\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(\n                    reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return pars(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n}", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int a = in.ni();\n            int b = in.ni();\n            int c = in.ni();\n            int n = in.ni();\n            if (c > a || a >= n) out.print(\"-1\");\n            else if (c > b || b >= n) out.print(\"-1\");\n            else if (n - (a + b - c) <= 0) out.print(\"-1\");\n            else out.print(n - (a + b - c));\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "/*\n * PDPM IIITDM Jabalpur\n * Asutosh Rana\n */\n\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main\n{\n    long MOD = 1000000007;\n    InputReader in;BufferedReader br;PrintWriter out;\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Main solver = new Main();\n        solver.in = new InputReader(System.in);\n        solver.br = new BufferedReader(new InputStreamReader(System.in));\n        solver.out = new PrintWriter(System.out);\n        solver.solve();\n        solver.out.flush();\n        solver.out.close();\n    }\n\n    public void solve(){\n        \n        int tc = 1;//in.readInt();\n        \n        for(int cas=1;cas<=tc;cas++){\n            int N = in.readInt();\n            int[] A = new int[N];\n            in.readInt(A);\n            \n            HashMap<Integer, Integer> H = new HashMap<>();\n            long sum = A[0], count = 1;\n            BigInteger B = BigInteger.ZERO;\n            H.put(A[0], 1);\n            for(int i=1;i<N;i++){\n                // res = res + (count*A[i] - sum);\n                B = B.add(BigInteger.valueOf(count*A[i]-sum));\n                if(!H.containsKey(A[i]))\n                    H.put(A[i], 0);\n                H.put(A[i], H.get(A[i])+1);\n\n                if(H.containsKey(A[i]-1)){\n                    int k = H.get(A[i]-1);\n                    // res = res + (k*(A[i]-1) - k*A[i]);\n                    B = B.add(BigInteger.valueOf((k*(A[i]-1) - k*A[i])));\n                }\n                if(H.containsKey(A[i]+1)){\n                    int k = H.get(A[i]+1);\n                    B = B.add(BigInteger.valueOf((k*(A[i]+1) - k*A[i])));\n                    // res = res + (k*(A[i]+1) - k*A[i]);\n                }\n                // out.println(res);\n                sum+=A[i];count++;\n            }\n            // out.println(\"-1\");\n            out.println(B);\n\n\n        }\n\n    }\n    \n}\n \nclass InputReader{\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream){this.stream = stream;}\n    public int read(){\n        if (numChars==-1) throw new InputMismatchException();\n        if (curChar >= numChars){\n            curChar = 0;\n            try {numChars = stream.read(buf);}\n            catch (IOException e){throw new InputMismatchException();}\n            if(numChars <= 0) return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt(){\n        int c = read();\n        while(isSpaceChar(c)) c = read();\n        int sgn = 1;\n        if (c == '-') {sgn = -1;c = read();}\n        int res = 0;\n        do {\n            if(c<'0'||c>'9') throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        }\n        while (!isSpaceChar(c)); return res * sgn;\n    }\n\n    public void readInt(int[] A){\n        for(int i=0;i<A.length;i++)\n            A[i] = readInt();\n    }\n\n    public long readLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        }\n        while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public void readLong(long[] A){\n        for(int i=0;i<A.length;i++)\n            A[i] = readLong();\n    }\n\n    public double readDouble() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        double res = 0;\n        while (!isSpaceChar(c) && c != '.') {\n            if (c == 'e' || c == 'E')\n                return res * Math.pow(10, readInt());\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        }\n        if (c == '.') {\n            c = read();\n            double m = 1;\n            while (!isSpaceChar(c)) {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, readInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                m /= 10;\n                res += (c - '0') * m;\n                c = read();\n            }\n        }\n        return res * sgn;\n    }\n\n    public char[] readCharA(){\n        return readString().toCharArray();\n    }\n\n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public String next() {\n        return readString();\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n\n}", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.io.OutputStream;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.PrintWriter;\n\nimport java.util.InputMismatchException;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\n\n\n/**\n\n * Built using CHelper plug-in\n\n * Actual solution is at the top\n\n */\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        InputStream inputStream = System.in;\n\n        OutputStream outputStream = System.out;\n\n        InputReader in = new InputReader(inputStream);\n\n        PrintWriter out = new PrintWriter(outputStream);\n\n        atskb solver = new atskb();\n\n        solver.solve(1, in, out);\n\n        out.close();\n\n    }\n\n\n\n    static class atskb {\n\n        long s;\n\n\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n\n            long n = in.nextLong();\n\n            s = in.nextLong();\n\n            long ans = binarysearch(0, (long) Math.pow(10, 18) + 20 * 9);\n\n            if (ans > n) {\n\n                out.print(0);\n\n            } else {\n\n                out.print(n - ans + 1);\n\n            }\n\n\n\n        }\n\n\n\n        public long binarysearch(long l, long r) {\n\n            if (l == r) {\n\n                if (check(l))\n\n                    return l;\n\n                return -1;\n\n\n\n            }\n\n            if (l - r == -1) {\n\n                if (check(l))\n\n                    return l;\n\n                if (check(r)) {\n\n                    return r;\n\n                }\n\n\n\n                //return -1;\n\n            }\n\n            long mid = l + (r - l) / 2;\n\n            if (check(mid))\n\n                return binarysearch(l, mid);\n\n            return binarysearch(mid + 1, r);\n\n        }\n\n\n\n        public boolean check(long m) {\n\n            String str = m + \"\";\n\n            long sum = 0;\n\n            for (int i = 0; i < str.length(); i++) {\n\n                sum += str.charAt(i) - '0';\n\n            }\n\n            if (sum + s <= m)\n\n                return true;\n\n            return false;\n\n        }\n\n\n\n    }\n\n\n\n    static class InputReader {\n\n        private final InputStream stream;\n\n        private final byte[] buf = new byte[8192];\n\n        private int curChar;\n\n        private int snumChars;\n\n\n\n        public InputReader(InputStream st) {\n\n            this.stream = st;\n\n        }\n\n\n\n        public int read() {\n\n            if (snumChars == -1)\n\n                throw new InputMismatchException();\n\n            if (curChar >= snumChars) {\n\n                curChar = 0;\n\n                try {\n\n                    snumChars = stream.read(buf);\n\n                } catch (IOException e) {\n\n                    throw new InputMismatchException();\n\n                }\n\n                if (snumChars <= 0)\n\n                    return -1;\n\n            }\n\n            return buf[curChar++];\n\n        }\n\n\n\n        public long nextLong() {\n\n            int c = read();\n\n            while (isSpaceChar(c)) {\n\n                c = read();\n\n            }\n\n            int sgn = 1;\n\n            if (c == '-') {\n\n                sgn = -1;\n\n                c = read();\n\n            }\n\n            long res = 0;\n\n            do {\n\n                res *= 10;\n\n                res += c - '0';\n\n                c = read();\n\n            } while (!isSpaceChar(c));\n\n            return res * sgn;\n\n        }\n\n\n\n        public boolean isSpaceChar(int c) {\n\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\n        }\n\n\n\n    }\n\n}\n\n\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        int n;\n        int[] bitCount;\n        long neededSum;\n        long[] sums;\n        Map<Long, Integer> where;\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            n = in.nextInt();\n            int[][] a = new int[n][];\n            neededSum = 0;\n            sums = new long[n];\n            for (int i = 0; i < n; i++) {\n                int k = in.nextInt();\n                a[i] = new int[k];\n                for (int j = 0; j < k; j++) {\n                    a[i][j] = in.nextInt();\n                    neededSum += a[i][j];\n                    sums[i] += a[i][j];\n                }\n            }\n\n            if (neededSum % n != 0) {\n                out.println(\"No\");\n                return;\n            }\n            neededSum /= n;\n\n            where = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < a[i].length; j++) {\n                    where.put((long) a[i][j], i);\n                }\n            }\n            bitCount = new int[1 << n];\n            for (int i = 0; i < bitCount.length; i++) {\n                bitCount[i] = Integer.bitCount(i);\n            }\n\n            Entry[][] cycleSol = new Entry[1 << n][];\n\n            List<Entry> sol = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                for (int x : a[i]) {\n                    search(i, i, x, x, 0, 0, sol, cycleSol);\n                }\n            }\n\n            boolean[] can = new boolean[1 << n];\n            int[] via = new int[1 << n];\n            can[0] = true;\n            for (int mask = 0; mask < 1 << n; mask++) {\n                for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n                    if (cycleSol[submask] != null && can[mask ^ submask]) {\n                        can[mask] = true;\n                        via[mask] = submask;\n                    }\n                }\n            }\n\n            if (!can[(1 << n) - 1]) {\n                out.println(\"No\");\n                return;\n            }\n\n            int[][] ans = new int[n][2];\n            for (int mask = (1 << n) - 1; mask > 0; ) {\n                int sm = via[mask];\n                mask ^= sm;\n\n                for (Entry e : cycleSol[sm]) {\n                    ans[e.from][0] = e.what;\n                    ans[e.from][1] = e.to + 1;\n                }\n            }\n\n            out.println(\"Yes\");\n            for (int i = 0; i < n; i++) {\n                out.println(ans[i][0] + \" \" + ans[i][1]);\n            }\n        }\n\n        private void search(int start, int cur, long fromStart, long fromCur, int hasIn, int hasOut, List<Entry> sol, Entry[][] cycleSol) {\n            for (int i = 0; i < n; i++) {\n                if ((hasIn & (1 << i)) > 0) {\n                    continue;\n                }\n                if ((hasOut & (1 << cur)) > 0) {\n                    continue;\n                }\n                long fromI = sums[i] + fromCur - neededSum;\n                Integer w = where.get(fromI);\n                if (w == null || w != i) {\n                    continue;\n                }\n                sol.add(new Entry(cur, i, (int) fromCur));\n                int nHasIn = hasIn | (1 << i);\n                int nHasOut = hasOut | (1 << cur);\n                if (i == start && fromI == fromStart) {\n                    cycleSol[nHasOut] = sol.toArray(new Entry[0]);\n                }\n                search(start, i, fromStart, fromI, nHasIn, nHasOut, sol, cycleSol);\n                sol.remove(sol.size() - 1);\n            }\n        }\n\n        class Entry {\n            int from;\n            int to;\n            int what;\n\n            Entry(int from, int to, int what) {\n                this.from = from;\n                this.to = to;\n                this.what = what;\n            }\n\n            public String toString() {\n                return from + \" \" + to + \" \" + what;\n            }\n\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "//package round718;\n\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class D2 {\n\tInputStream is;\n\tFastWriter out;\n\tString INPUT = \"\";//2 5 9 9 9 9 9 8 8 8 8 5 6 7 8 9\";\n\n\tvoid solve()\n\t{\n\t\tint n = ni(), m = ni(), K = ni();\n\t\tint[][] a = new int[2*n+1][2*m+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint[] u = na(m-1);\n\t\t\tfor(int j = 0;j < m-1;j++){\n\t\t\t\ta[2*i][2*j+1] = u[j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tint[] u = na(m);\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\ta[2*i+1][2*j] = u[j];\n\t\t\t}\n\t\t}\n\t\tif(K % 2 == 1){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\t\tout.print(-1 + \" \");\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tint[][][] dp = new int[K/2+1][n][m];\n\t\tint[] dr = {1, 0, -1, 0};\n\t\tint[] dc = {0, 1, 0, -1};\n\t\tfor(int i = 1;i <= K/2;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\t\tdp[i][j][k] = Integer.MAX_VALUE;\n\t\t\t\t\tfor(int l = 0;l < 4;l++){\n\t\t\t\t\t\tint jj = j + dr[l], kk = k + dc[l];\n\t\t\t\t\t\tif(jj >= 0 && jj < n && kk >= 0 && kk < m){\n\t\t\t\t\t\t\tdp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][jj][kk] + a[j+jj][k+kk]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tout.print(dp[K/2][i][j] * 2 + \" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n//\t\tint n = 500, m = 500;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tsb.append(n + \" \");\n//\t\tsb.append(20 + \" \");\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tfor(int j = 0;j < m-1;j++) {\n//\t\t\t\tsb.append(gen.nextInt(200000) + \" \");\n//\t\t\t}\n//\t\t}\n//\t\tfor (int i = 0; i < n-1; i++) {\n//\t\t\tfor(int j = 0;j < m;j++) {\n//\t\t\t\tsb.append(gen.nextInt(200000) + \" \");\n//\t\t\t}\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new FastWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new D2().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic static class FastWriter\n\t{\n\t\tprivate static final int BUF_SIZE = 1<<13;\n\t\tprivate final byte[] buf = new byte[BUF_SIZE];\n\t\tprivate final OutputStream out;\n\t\tprivate int ptr = 0;\n\n\t\tprivate FastWriter(){out = null;}\n\n\t\tpublic FastWriter(OutputStream os)\n\t\t{\n\t\t\tthis.out = os;\n\t\t}\n\n\t\tpublic FastWriter(String path)\n\t\t{\n\t\t\ttry {\n\t\t\t\tthis.out = new FileOutputStream(path);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"FastWriter\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter write(byte b)\n\t\t{\n\t\t\tbuf[ptr++] = b;\n\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(char c)\n\t\t{\n\t\t\treturn write((byte)c);\n\t\t}\n\n\t\tpublic FastWriter write(char[] s)\n\t\t{\n\t\t\tfor(char c : s){\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(String s)\n\t\t{\n\t\t\ts.chars().forEach(c -> {\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(int l) {\n\t\t\tif (l >= 1000000000) return 10;\n\t\t\tif (l >= 100000000) return 9;\n\t\t\tif (l >= 10000000) return 8;\n\t\t\tif (l >= 1000000) return 7;\n\t\t\tif (l >= 100000) return 6;\n\t\t\tif (l >= 10000) return 5;\n\t\t\tif (l >= 1000) return 4;\n\t\t\tif (l >= 100) return 3;\n\t\t\tif (l >= 10) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(int x)\n\t\t{\n\t\t\tif(x == Integer.MIN_VALUE){\n\t\t\t\treturn write((long)x);\n\t\t\t}\n\t\t\tif(ptr + 12 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(long l) {\n\t\t\tif (l >= 1000000000000000000L) return 19;\n\t\t\tif (l >= 100000000000000000L) return 18;\n\t\t\tif (l >= 10000000000000000L) return 17;\n\t\t\tif (l >= 1000000000000000L) return 16;\n\t\t\tif (l >= 100000000000000L) return 15;\n\t\t\tif (l >= 10000000000000L) return 14;\n\t\t\tif (l >= 1000000000000L) return 13;\n\t\t\tif (l >= 100000000000L) return 12;\n\t\t\tif (l >= 10000000000L) return 11;\n\t\t\tif (l >= 1000000000L) return 10;\n\t\t\tif (l >= 100000000L) return 9;\n\t\t\tif (l >= 10000000L) return 8;\n\t\t\tif (l >= 1000000L) return 7;\n\t\t\tif (l >= 100000L) return 6;\n\t\t\tif (l >= 10000L) return 5;\n\t\t\tif (l >= 1000L) return 4;\n\t\t\tif (l >= 100L) return 3;\n\t\t\tif (l >= 10L) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(long x)\n\t\t{\n\t\t\tif(x == Long.MIN_VALUE){\n\t\t\t\treturn write(\"\" + x);\n\t\t\t}\n\t\t\tif(ptr + 21 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(double x, int precision)\n\t\t{\n\t\t\tif(x < 0){\n\t\t\t\twrite('-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tx += Math.pow(10, -precision)/2;\n\t\t\t//\t\tif(x < 0){ x = 0; }\n\t\t\twrite((long)x).write(\".\");\n\t\t\tx -= (long)x;\n\t\t\tfor(int i = 0;i < precision;i++){\n\t\t\t\tx *= 10;\n\t\t\t\twrite((char)('0'+(int)x));\n\t\t\t\tx -= (int)x;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(char c){\n\t\t\treturn write(c).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(int x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(double x, int precision){\n\t\t\treturn write(x, precision).writeln();\n\t\t}\n\n\t\tpublic FastWriter write(int... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(int x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(long... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(long x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln()\n\t\t{\n\t\t\treturn write((byte)'\\n');\n\t\t}\n\n\t\tpublic FastWriter writeln(int... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[] line)\n\t\t{\n\t\t\treturn write(line).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[]... map)\n\t\t{\n\t\t\tfor(char[] line : map)write(line).writeln();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(String s)\n\t\t{\n\t\t\treturn write(s).writeln();\n\t\t}\n\n\t\tprivate void innerflush()\n\t\t{\n\t\t\ttry {\n\t\t\t\tout.write(buf, 0, ptr);\n\t\t\t\tptr = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"innerflush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic void flush()\n\t\t{\n\t\t\tinnerflush();\n\t\t\ttry {\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"flush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter print(byte b) { return write(b); }\n\t\tpublic FastWriter print(char c) { return write(c); }\n\t\tpublic FastWriter print(char[] s) { return write(s); }\n\t\tpublic FastWriter print(String s) { return write(s); }\n\t\tpublic FastWriter print(int x) { return write(x); }\n\t\tpublic FastWriter print(long x) { return write(x); }\n\t\tpublic FastWriter print(double x, int precision) { return write(x, precision); }\n\t\tpublic FastWriter println(char c){ return writeln(c); }\n\t\tpublic FastWriter println(int x){ return writeln(x); }\n\t\tpublic FastWriter println(long x){ return writeln(x); }\n\t\tpublic FastWriter println(double x, int precision){ return writeln(x, precision); }\n\t\tpublic FastWriter print(int... xs) { return write(xs); }\n\t\tpublic FastWriter print(long... xs) { return write(xs); }\n\t\tpublic FastWriter println(int... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(long... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(char[] line) { return writeln(line); }\n\t\tpublic FastWriter println(char[]... map) { return writeln(map); }\n\t\tpublic FastWriter println(String s) { return writeln(s); }\n\t\tpublic FastWriter println() { return writeln(); }\n\t}\n\n\tpublic void trnz(int... o)\n\t{\n\t\tfor(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+\":\"+o[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n\t// print ids which are 1\n\tpublic void trt(long... o)\n\t{\n\t\tQueue<Integer> stands = new ArrayDeque<>();\n\t\tfor(int i = 0;i < o.length;i++){\n\t\t\tfor(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n\t\t}\n\t\tSystem.out.println(stands);\n\t}\n\n\tpublic void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(long[]... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long[] r : b) {\n\t\t\t\tfor (long x : r) {\n\t\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic void tf(long... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long x : b) {\n\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "//package global14;\n\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class E2 {\n\tInputStream is;\n\tFastWriter out;\n\tString INPUT = \"\";\n\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][]{f, invf};\n\t}\n\n\tpublic static long[] enumPows(int a, int n, int mod)\n\t{\n\t\ta %= mod;\n\t\tlong[] pows = new long[n+1];\n\t\tpows[0] = 1;\n\t\tfor(int i = 1;i <= n;i++)pows[i] = pows[i-1] * a % mod;\n\t\treturn pows;\n\t}\n\n\n\tvoid solve()\n\t{\n\t\tint N = ni();\n\t\tfinal int mod = ni();\n\n\t\tlong[] p2 = enumPows(2, 1000, mod);\n\t\tint[][] fif = enumFIF(1000, mod);\n\n\t\tlong[][] dp = new long[N+2][N+1];\n\t\tdp[0][0] = 1;\n\t\tfor(int i = 0;i <= N+1;i++){\n\t\t\tfor(int j = 0;j <= N;j++){\n\t\t\t\t// 11110\n\t\t\t\tfor(int k = 1;i+k+1 <= N+1 && j+k <= N;k++){\n\t\t\t\t\tdp[i+k+1][j+k] += dp[i][j] * fif[1][k] % mod * p2[k-1];\n\t\t\t\t\tdp[i+k+1][j+k] %= mod;\n\t\t\t\t}\n\t\t\t}\n//\t\t\ttr(dp[i]);\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor(int i = 1;i <= N;i++){\n\t\t\tans += dp[N+1][i] * fif[0][i];\n\t\t\tans %= mod;\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new FastWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new E2().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic static class FastWriter\n\t{\n\t\tprivate static final int BUF_SIZE = 1<<13;\n\t\tprivate final byte[] buf = new byte[BUF_SIZE];\n\t\tprivate final OutputStream out;\n\t\tprivate int ptr = 0;\n\n\t\tprivate FastWriter(){out = null;}\n\n\t\tpublic FastWriter(OutputStream os)\n\t\t{\n\t\t\tthis.out = os;\n\t\t}\n\n\t\tpublic FastWriter(String path)\n\t\t{\n\t\t\ttry {\n\t\t\t\tthis.out = new FileOutputStream(path);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"FastWriter\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter write(byte b)\n\t\t{\n\t\t\tbuf[ptr++] = b;\n\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(char c)\n\t\t{\n\t\t\treturn write((byte)c);\n\t\t}\n\n\t\tpublic FastWriter write(char[] s)\n\t\t{\n\t\t\tfor(char c : s){\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(String s)\n\t\t{\n\t\t\ts.chars().forEach(c -> {\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(int l) {\n\t\t\tif (l >= 1000000000) return 10;\n\t\t\tif (l >= 100000000) return 9;\n\t\t\tif (l >= 10000000) return 8;\n\t\t\tif (l >= 1000000) return 7;\n\t\t\tif (l >= 100000) return 6;\n\t\t\tif (l >= 10000) return 5;\n\t\t\tif (l >= 1000) return 4;\n\t\t\tif (l >= 100) return 3;\n\t\t\tif (l >= 10) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(int x)\n\t\t{\n\t\t\tif(x == Integer.MIN_VALUE){\n\t\t\t\treturn write((long)x);\n\t\t\t}\n\t\t\tif(ptr + 12 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(long l) {\n\t\t\tif (l >= 1000000000000000000L) return 19;\n\t\t\tif (l >= 100000000000000000L) return 18;\n\t\t\tif (l >= 10000000000000000L) return 17;\n\t\t\tif (l >= 1000000000000000L) return 16;\n\t\t\tif (l >= 100000000000000L) return 15;\n\t\t\tif (l >= 10000000000000L) return 14;\n\t\t\tif (l >= 1000000000000L) return 13;\n\t\t\tif (l >= 100000000000L) return 12;\n\t\t\tif (l >= 10000000000L) return 11;\n\t\t\tif (l >= 1000000000L) return 10;\n\t\t\tif (l >= 100000000L) return 9;\n\t\t\tif (l >= 10000000L) return 8;\n\t\t\tif (l >= 1000000L) return 7;\n\t\t\tif (l >= 100000L) return 6;\n\t\t\tif (l >= 10000L) return 5;\n\t\t\tif (l >= 1000L) return 4;\n\t\t\tif (l >= 100L) return 3;\n\t\t\tif (l >= 10L) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(long x)\n\t\t{\n\t\t\tif(x == Long.MIN_VALUE){\n\t\t\t\treturn write(\"\" + x);\n\t\t\t}\n\t\t\tif(ptr + 21 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(double x, int precision)\n\t\t{\n\t\t\tif(x < 0){\n\t\t\t\twrite('-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tx += Math.pow(10, -precision)/2;\n\t\t\t//\t\tif(x < 0){ x = 0; }\n\t\t\twrite((long)x).write(\".\");\n\t\t\tx -= (long)x;\n\t\t\tfor(int i = 0;i < precision;i++){\n\t\t\t\tx *= 10;\n\t\t\t\twrite((char)('0'+(int)x));\n\t\t\t\tx -= (int)x;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(char c){\n\t\t\treturn write(c).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(int x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(double x, int precision){\n\t\t\treturn write(x, precision).writeln();\n\t\t}\n\n\t\tpublic FastWriter write(int... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(int x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(long... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(long x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln()\n\t\t{\n\t\t\treturn write((byte)'\\n');\n\t\t}\n\n\t\tpublic FastWriter writeln(int... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[] line)\n\t\t{\n\t\t\treturn write(line).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[]... map)\n\t\t{\n\t\t\tfor(char[] line : map)write(line).writeln();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(String s)\n\t\t{\n\t\t\treturn write(s).writeln();\n\t\t}\n\n\t\tprivate void innerflush()\n\t\t{\n\t\t\ttry {\n\t\t\t\tout.write(buf, 0, ptr);\n\t\t\t\tptr = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"innerflush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic void flush()\n\t\t{\n\t\t\tinnerflush();\n\t\t\ttry {\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"flush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter print(byte b) { return write(b); }\n\t\tpublic FastWriter print(char c) { return write(c); }\n\t\tpublic FastWriter print(char[] s) { return write(s); }\n\t\tpublic FastWriter print(String s) { return write(s); }\n\t\tpublic FastWriter print(int x) { return write(x); }\n\t\tpublic FastWriter print(long x) { return write(x); }\n\t\tpublic FastWriter print(double x, int precision) { return write(x, precision); }\n\t\tpublic FastWriter println(char c){ return writeln(c); }\n\t\tpublic FastWriter println(int x){ return writeln(x); }\n\t\tpublic FastWriter println(long x){ return writeln(x); }\n\t\tpublic FastWriter println(double x, int precision){ return writeln(x, precision); }\n\t\tpublic FastWriter print(int... xs) { return write(xs); }\n\t\tpublic FastWriter print(long... xs) { return write(xs); }\n\t\tpublic FastWriter println(int... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(long... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(char[] line) { return writeln(line); }\n\t\tpublic FastWriter println(char[]... map) { return writeln(map); }\n\t\tpublic FastWriter println(String s) { return writeln(s); }\n\t\tpublic FastWriter println() { return writeln(); }\n\t}\n\n\tpublic void trnz(int... o)\n\t{\n\t\tfor(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+\":\"+o[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n\t// print ids which are 1\n\tpublic void trt(long... o)\n\t{\n\t\tQueue<Integer> stands = new ArrayDeque<>();\n\t\tfor(int i = 0;i < o.length;i++){\n\t\t\tfor(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n\t\t}\n\t\tSystem.out.println(stands);\n\t}\n\n\tpublic void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(long[]... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long[] r : b) {\n\t\t\t\tfor (long x : r) {\n\t\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic void tf(long... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long x : b) {\n\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n  public void run(){\n    Locale.setDefault(Locale.US);\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    double a[][] = new double[n][n];\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) a[i][j] = in.nextDouble();\n\n    double f[] = new double[1<<n];\n    f[(1<<n)-1] = 1;\n\n    for(int mask = (1<<n)-1;mask > 0;mask--){\n      int k = Integer.bitCount(mask);\n      if (k == 1) continue;\n\n      for(int i=0;i<n;i++){\n        if ((mask & (1 << i)) > 0){\n          for(int j=0;j<n;j++){\n            if ((mask & (1 << j)) > 0){\n              f[mask&(~(1<<j))]+=f[mask]*a[i][j]/(k*(k-1)/2); \n            }  \n          }\n        }\n      }\n    }\n    for(int i=0;i<n;i++)\n      System.out.print(f[1<<i]+\" \");\n  }\n\n  public static void main(String args[]){\n    new Main().run();\n  }\n}", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "\n/**\n *\n * @author saurabh\n */\npublic class myTemplate {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) throws Exception{\n        // TODO code application logic here\n       java.io.BufferedReader br = new java.io.BufferedReader(new \n                 java.io.InputStreamReader(System.in));\n       \n       int ch[],arr[];\n       int x,i,j,k,t,n=Integer.parseInt(br.readLine());\n        //System.out.println(n);\n        \n       if(n>0)\n            System.out.println(n);\n       else\n       {\n           //n= -n;\n           //n=-n;\n           x= n/100;\n           \n           x = x*10 + n%10;\n         //  System.out.println(x);\n           if(n/10 > x)\n               System.out.println(n/10);\n           else\n              System.out.println(x);\n           \n       }\n       \n    }\n}\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tpublic static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n\tpublic static void main(String[] args) throws IOException {\n\t\treadInput();\n\t\tout.close();\n\t}\n\n\tstatic boolean sq(long x) {\n\t\tlong l = 1;\n\t\tlong r = (int)Math.sqrt(1e16)+1;\n\t\twhile (l+1<r) {\n\t\t\tlong m = (l+r)>>1;\n\t\t\tif (m * m > x) r = m;\n\t\t\telse l = m;\n\t\t}\n\t\treturn l*l == x;\n\t}\n\t\n\tstatic boolean solve(long x) {\n\t\tif ((x&1)==1) return false;\n\t\tif ((x & (x-1)) == 0) return true;\n\t\tlong num = 2;\n\t\twhile (num < x && x % num == 0) {\n\t\t\tif (sq(x/num)) return true;\n\t\t\tnum*=2;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static void readInput() throws IOException {\n\t\t// br = new BufferedReader(new FileReader(\".in\"));\n\t\t// out = new PrintWriter(new FileWriter(\".out\"));\n\t\tint t = Integer.parseInt(br.readLine());\n\t\twhile (t-->0) {\n\t\t\tint x = Integer.parseInt(br.readLine());\n\t\t\tout.println(solve(x) ? \"YES\":\"NO\");\n\t\t}\n\t}\n}\n", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class test\n{\n\n\tpublic static void main(String[] args)\n\t{\n\t\tnew test().run();\n\t}\n\n\tPrintWriter out = null;\n\n\tvoid run()\n\t{\n\t\tScanner in = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tint n = in.nextInt();\n\t\tint a = in.nextInt();\n\t\tint b = in.nextInt();\n\n\t\tint[] h = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\th[i] = in.nextInt();\n\n\t\tArrays.sort(h);\n\n\t\tif (h[b] == h[b - 1])\n\t\t\tout.println(0);\n\t\telse\n\t\t\tout.println(h[b] - h[b - 1]);\n\t\tout.close();\n\t}\n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\npublic class A {\n \n\tstatic final int mod = 1000000007;\n\tstatic final long temp = 998244353;\n\tstatic final long MOD = 1000000007;\n\tstatic final long M = (long)1e9+7;\n \n\t\n\n\tstatic class Pair implements Comparable<Pair>\n\t{\n\t\tint first, second;\n\t\tpublic Pair(int aa, int bb)\n\t\t{\n\t\t\tfirst = aa; second = bb;\n\t\t}\n\t\tpublic int compareTo(Pair p)\n\t\t{\n\t\t\tif(first == p.first) return (int)(second - p.second);\n\t\t\treturn (int)(first - p.first);\n\t\t}\n\t}\n\n\tpublic static class DSU\n\t{\n\t\tint[] parent;\n\t\tint[] rank; //Size of the trees is used as the rank\n\t\tpublic DSU(int n)\n\t\t{\n\t\t\tparent = new int[n];\n\t\t\trank = new int[n];\n\t\t\tArrays.fill(parent, -1);\n\t\t\tArrays.fill(rank, 1);\n\t\t}\n\t\t\n\t\tpublic int find(int i) //finding through path compression\n\t\t{\n\t\t\treturn parent[i] < 0 ? i : (parent[i] = find(parent[i]));\n\t\t}\n\t\t\n\t\tpublic boolean union(int a, int b) //Union Find by Rank \n\t\t{\n\t\t\ta = find(a);\n\t\t\tb = find(b);\n\t\t\t\n\t\t\tif(a == b) return false; //if they are already connected we exit by returning false.\n\t\t\t\n\t\t\t// if a's parent is less than b's parent\n\t\t\tif(rank[a] < rank[b])\n\t\t\t{\n\t\t\t\t//then move a under b\n\t\t\t\tparent[a] = b;\n\t\t\t}\n\t\t\t//else if rank of j's parent is less than i's parent\n\t\t\telse if(rank[a] > rank[b])\n\t\t\t{\n\t\t\t\t//then move b under a\n\t\t\t\tparent[b] = a;\n\t\t\t}\n\t\t\t//if both have the same rank..\n\t\t\telse\n\t\t\t{\n\t\t\t\t//move a under b (it doesnt matter if its the other way around.\n\t\t\t\tparent[b] = a;\n\t\t\t\trank[a] = 1 + rank[a];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\t\n\t}\n\n\tstatic class Reader {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) throws IOException {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong[] longReadArray(int n) throws IOException {\n\t\t\tlong[] a=new long[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\t\n\t\tpublic static boolean isPrime(int n) \n\t\t{\n\t\t\tif(n == 1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor(int i = 2;i*i<=n;i++)\n\t\t\t{\n\t\t\t\tif(n%i == 0)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t}\n\t\n\tpublic static List<Integer> SieveList(int n)\n\t{\n\t\tboolean prime[] = new boolean[n+1];\n\t\tArrays.fill(prime, true);\n\t\t\n\t\tList<Integer> l = new ArrayList<>();\n\t\tfor (int p=2; p*p<=n; p++) \n\t\t{ \n\t\t\tif (prime[p] == true) \n\t\t\t{ \t\n\t\t\t    for(int i=p*p; i<=n; i += p) \n\t\t\t\t{\n\t\t\t\t    prime[i] = false; \n\t\t\t\t}\t\n\t\t\t} \n\t\t} \n \n\t\tfor (int p=2; p<=n; p++) \n\t\t{\n\t\t    if (prime[p] == true)\n\t\t    {\n\t\t       l.add(p); \n\t\t    }\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\tpublic static int gcd(int a, int b)\n\t{\n\t\tif(b == 0)\n\t\t return a;\n\t\t\n\t\telse\n\t\treturn gcd(b,a%b);\n\t} \n \n\t\tpublic static int lcm(int a, int b)\n\t    {\n\t        return (a / gcd(a, b)) * b;\n\t    }\n\t\n\tpublic static long LongGCD(long a, long b)\n\t{\n\t\tif(b == 0)\n\t\t\t return a;\n\t\t\t\n\t\t\telse\n\t\t\treturn LongGCD(b,a%b);\n\t}\n\t\n\t\tpublic static long LongLCM(long a, long b)\n\t    {\n\t        return (a / LongGCD(a, b)) * b;\n\t    }\n\t\n\t\tpublic static int phi(int n)  //euler totient function\n\t    { \n\t        int result = 1; \n\t        for (int i = 2; i < n; i++) \n\t            if (gcd(i, n) == 1) \n\t                result++; \n\t        return result; \n\t    }\n\t\n\tpublic static long fastPow(long x, long n) \n\t{\n\t\tif(n == 0)\n\t\t\treturn 1;\n\t\telse if(n%2 == 0)\n\t\t\treturn fastPow(x*x,n/2);\n\t\telse\n\t\t\treturn x*fastPow(x*x,(n-1)/2);\n\t}\n\t\n\t   public static long modPow(long x, long y, long p)\n\t    {\n\t        long res = 1;\n\t        x = x % p;\n\t \n\t        while (y > 0) {\n\t            if (y % 2 == 1)\n\t                res = (res * x) % p;\n\t \n\t            y = y >> 1; \n\t            x = (x * x) % p;\n\t        }\n\t        return res;\n\t    }\n\t   \n\t   static long modInverse(long n, long p)\n\t    {\n\t        return modPow(n, p - 2, p);\n\t    }\n\t \n\t    // Returns nCr % p using Fermat's little theorem.\n\t    \n\t    public static long nCrModP(long n, long r,long p)\n\t    {\n\t          if (n<r) \n\t              return 0;\n\t          \n\t        if (r == 0)\n\t            return 1;\n\t \n\t        long[] fac = new long[(int)(n) + 1];\n\t        fac[0] = 1;\n\t \n\t        for (int i = 1; i <= n; i++)\n\t            fac[i] = fac[i - 1] * i % p;\n\t \n\t        return (fac[(int)(n)] * modInverse(fac[(int)(r)], p)\n\t                % p * modInverse(fac[(int)(n - r)], p)\n\t                % p)\n\t            % p;\n\t    }\n\t    \n\t    public static long nCr(long n, long r)\n\t    {\n\t    \tlong ans = 1;\n\t    \tfor(long i = 1,j = n;i<=r;i++,j--)\n\t    \t{\n\t    \t\tans = ans * j / i;\n\t    \t}\n\t    \treturn ans;\n\t    }\n \n\t\tpublic static void Sort(int[] a) {\n\t\t\tList<Integer> l=new ArrayList<>();\n\t\t\tfor (int i : a) l.add(i);\n\t\t\tCollections.sort(l);\n\t\t\t//Collections.reverse(l);  //Use to Sort decreasingly \n\t\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t\t}\n\t\t\n\t\tpublic static void ssort(char[] a)\n\t\t{\n\t\t\tList<Character> l = new ArrayList<>();\n\t\t\tfor (char i : a) l.add(i);\n\t\t\tCollections.sort(l);\n\t\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t\t}\n\t\t\n\t\t\n\t\t//Modular Operations for Addition and Multiplication. \n\t\t   public static long perfomMod(long x)\n\t\t   {\n\t\t        return ((x%M + M)%M);\n\t\t    }\n\t\t   public static long addMod(long a, long  b)\n\t\t   {\n\t\t        return perfomMod(perfomMod(a)+perfomMod(b));\n\t\t    }\n\t\t   public static long mulMod(long  a, long b)\n\t\t   {\n\t\t        return perfomMod(perfomMod(a)*perfomMod(b));\n\t\t   }\n\t\t\n\t\t   public static int LowerBound(int a[], int x) \n\t\t   {\n\t\t\t\t  int l=-1,r=a.length;\n\t\t\t\t  while(l+1<r) {\n\t\t\t\t    int m=(l+r)>>>1;\n\t\t\t\t    if(a[m]>=x) r=m;\n\t\t\t\t    else l=m;\n\t\t\t\t  }\n\t\t\t\t  return r;\n\t\t\t}\n\t\t\n\t\t   \n\t\t\tpublic static int UpperBound(int a[], int x) \n\t\t\t{\n\t\t\t    int l=-1;\n\t\t\t    int r=a.length;\n\t\t\t    while(l+1<r) {\n\t\t\t       int m=(l+r)>>>1;\n\t\t\t       if(a[m]<=x) l=m;\n\t\t\t       else r=m;\n\t\t\t    }\n\t\t\t    return l+1;\n\t\t\t}\n\t\t\t\n\t\n\tpublic static void main(String[] args) throws IOException \n\t{\n\t\tReader sc = new Reader();\n\t\tPrintWriter fout = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] a = sc.readArray(n);\n\t\t\n\t\tStack<Integer> stk = new Stack<>();\n\t\tfor(int i = 0;i<n;i++)\n\t\t{\n\t\t\ta[i] &= 1;\n\t\t\tif(!stk.isEmpty() && (stk.peek() == a[i]))\n\t\t\t{\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstk.push(a[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfout.println((stk.size() <= 1 ? \"YES\" : \"NO\"));\n\t\t\n\t\tfout.close();\n\t}\n\t\n\t\n}", "complexity": "linear", "problem": "1092_D1", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n\npublic class a{ \n     static int[] count,count1,count2;\n     static Node[] nodes;\n     static long[] arr;\n     static int[] dp,arrInt,darrInt;\n     static char[] ch,ch1;\n     static long[] darr,farr;\n     static char[][] mat,mat1;\n     static int[][] space;\n     static boolean[][] vis;\n     static long x,h;\n     static long maxl;\n     static double dec;\n     static long mx = (long)1e10;\n     static String s,s1,s2,s3,s4;\n     static long minl;\n     static int start_row;\n     static int start_col;     \n     static int end_row;     \n     static int end_col;     \n     static long mod = 998244353;\n     // static int minl = -1;\n     // static long n;\n     static int n,n1,n2,q,r1,c1,r2,c2;\n     static long a;\n     static long b;\n     static long c;\n     static long d;\n     static long y,z;\n     static int m;\n     static long k;\n     static FastScanner sc;\n     static String[] str,str1;\n     static Set<Long> set,set1,set2;\n     static SortedSet<Long> ss;\n     static List<Long> list,list1,list2,list3;\n     static PriorityQueue<Integer> pq,pq1;\n     static LinkedList<Node> ll;\n     static Map<Integer,List<Integer>> map1;\n     static Map<Long,Integer> map;\n     static StringBuilder sb,sb1,sb2;\n     static int index;\n     static long[] sum;\n     static int[] dx = {0,-1,0,1,-1,1,-1,1};\n     static int[] dy = {-1,0,1,0,-1,-1,1,1};\n\n     // public static void solve(){\n\n     //    FastScanner sc = new FastScanner();\n     //    // int t = sc.nextInt();\n     //    int t = 1;\n     //    for(int tt = 0 ; tt < t ; tt++){\n\n     //        // s = sc.next();\n     //        // s1 = sc.next();\n\n     //        n = sc.nextInt();\n     //        // m = sc.nextInt();\n     //        sb = new StringBuilder();\n     //        // map = new HashMap<>();\n     //        // q = sc.nextInt();\n     //        // k = sc.nextLong();\n     //        // ch = sc.next().toCharArray();\n     //        // boolean ans = false;\n     //        // int charge = n;\n     //        // int prev = 0;\n\n     //        count = new int[7];\n           \n     //        // m = sc.nextInt();\n     //        // long ans = 0;\n     //        // long added = 0;\n     //        for(int j = 0 ; j < n ; j++){\n\n\n     //        }\n\n     //    }\n        \n     // }\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n\n     public static void solve(){\n\n        long k = a;\n        long n = b;\n        long s = c;\n        long p = d;\n\n        System.out.println((((n+s-1)/s) * k + p - 1)/p);\n\n     }\n        \n     public static void main(String[] args) {\n\n            sc = new FastScanner();\n            // Scanner sc = new Scanner(System.in);\n            // int t = sc.nextInt();\n            int t = 1;\n            // int l = 1;\n            while(t > 0){\n                \n                // n = sc.nextInt();\n                // n = sc.nextLong();\n                // k = sc.nextLong();\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // z = sc.nextLong();\n\n                a = sc.nextLong();\n                b = sc.nextLong();\n                c = sc.nextLong();\n                d = sc.nextLong();\n\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // z = sc.nextLong();\n                // d = sc.nextLong();\n                // n = sc.nextLong();\n\n                // n = sc.nextInt();\n\n                // n = 3;\n                // n1 = sc.nextInt();\n\n                // m = sc.nextInt();\n                // q = sc.nextInt();\n\n                // k = sc.nextLong();\n                // d = sc.nextLong();\n                // s = sc.next();\n\n                // ch = sc.next().toCharArray();\n                // ch1 = sc.next().toCharArray();\n\n                // n = 3;\n                // arr = new long[n];\n                // for(int i = 0 ; i < n ; i++){\n                //     arr[i] = sc.nextLong();\n                // }\n\n                // arrInt = new int[n];\n                // for(int i = 0 ; i < n ; i++){\n                //     arrInt[i] = sc.nextInt();\n                // }\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // ch = sc.next().toCharArray();\n                // m = n;\n                // darr = new long[m];\n                // for(int i = 0 ; i < m ; i++){\n                //     darr[i] = sc.nextLong();\n                // }\n\n                // m = n;\n                // darrInt = new int[m];\n                // for(int i = 0 ; i < m ; i++){\n                //     darrInt[i] = sc.nextInt();\n                // }\n\n                // farr = new int[n];\n                // for(int i = 0; i < n ; i++){\n                //     farr[i] = sc.nextInt();\n                // }\n\n                // mat = new long[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat[i][j] = sc.nextLong();\n                //     }\n                // }\n\n                // m = n;\n                // mat = new char[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     String s = sc.next();\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat[i][j] = s.charAt(j);\n                //     }\n                // }\n\n                // m = n;\n                // mat1 = new char[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     String s = sc.next();\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat1[i][j] = s.charAt(j);\n                //     }\n                // }\n\n                // n= 5 ;\n                // str = new String[n];\n                // for(int i = 0 ; i < n ; i++)\n                //     str[i] = sc.next();\n\n                // nodes = new Node[n];\n                // for(int i = 0 ; i < n ;i++)\n                //     nodes[i] = new Node(sc.nextInt(),(i+1));\n\n                // m = sc.nextInt();\n\n                // System.out.println(solve()?\"YES\":\"NO\");\n                 solve();       \n                 // System.out.println(solve());\n                 t -= 1;\n            }\n\n     }\n\n     // public static dfs(int i){\n\n     //    if(count[i] == 1)\n     //        return;\n     //    list = map.get(i);\n     //    for(Integer j : list){\n     //        if(j == i)\n     //            continue;\n     //        dfs(j);\n     //    }\n     // }\n\n    public static int log(long n,long base){\n\n         if(n == 0 || n == 1)\n             return 0;\n\n         if(n == base)\n             return 1;\n\n         double num = Math.log(n);\n         double den = Math.log(base);\n\n         if(den == 0)\n             return 0;\n\n         return (int)(num/den);\n     }\n\n    public static boolean isPrime(long n) { \n    // Corner cases \n        if (n <= 1)  \n            return false; \n\n        if (n <= 3)  \n            return true; \n      \n        // This is checked so that we can skip  \n        // middle five numbers in below loop \n        if (n%2 == 0 || n%3 == 0) \n            return false; \n      \n        for (int i=5; i*i<=n; i=i+6) \n            if (n%i == 0 || n%(i+2) == 0) \n               return false; \n      \n        return true; \n    } \n\n    public static long gcd(long a, long b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b); \n    }\n\n     public static long mod_inverse(long a,long mod){\n        long x1=1,x2=0;\n        long p=mod,q,t;\n        while(a%p!=0){\n          q = a/p;\n          t = x1-q*x2;\n          x1=x2; x2=t;\n          t=a%p;\n          a=p; p=t;\n        }\n        return x2<0 ? x2+mod : x2;\n    }\n\n     public static void swap(int i,int j){\n         long temp = arr[j];\n         arr[j] = arr[i];\n         arr[i] = temp;\n     } \n\n    static final Random random=new Random();\n\n    static void ruffleSortLong(long[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            long temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSortInt(int[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            int temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n    \n    static void ruffleSortChar(char[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            char temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class Node{\n        Integer first;\n        Integer second;\n        Node(Integer f,Integer s){\n            this.first = f;\n            this.second = s;\n        }\n    }\n\n     static class FastScanner {\n\n                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n                StringTokenizer st=new StringTokenizer(\"\");\n                String next() {\n                        while (!st.hasMoreTokens())\n                                try {\n                                        st=new StringTokenizer(br.readLine());\n                                } catch (IOException e) {\n                                        e.printStackTrace();\n                                }\n                        return st.nextToken();\n                }\n                \n                int nextInt() {\n                        return Integer.parseInt(next());\n                }\n                int[] readArray(int n) {\n                        int[] a=new int[n];\n                        for (int i=0; i<n; i++) a[i]=nextInt();\n                        return a;\n                }\n                long nextLong() {\n                        return Long.parseLong(next());\n                }\n        }\n\n}", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class EdC {\n\tstatic long[] mods = {1000000007, 998244353, 1000000009};\n\tstatic long mod = mods[0];\n\tpublic static MyScanner sc;\n    public static PrintWriter out;\n    static char[][] grid;\n    static int n;\n    static int t;\n    static int[][] dp;\n    static int[] times;\n    static int[] genre;\n\tpublic static void main(String[] omkar) throws Exception{\n\t\t// TODO Auto-generated method stub\n \t\tsc = new MyScanner();\n \t\tout = new PrintWriter(System.out);\n \t\tn = sc.nextInt();\n \t\tt = sc.nextInt();\n \t\ttimes = new int[n];\n \t\tgenre = new int[n];\n \t\tfor(int j =0 ;j<n;j++){\n \t\t\ttimes[j] = sc.nextInt();\n \t\t\tgenre[j] = sc.nextInt();\t\t\n \t\t}\n \t\tdp = new int[1<<n][4];\n \t\tfor(int j = 0;j<1<<n;j++)\n \t\t\tArrays.fill(dp[j],  -1);\n \t\tfor(int j=0;j<1<<n;j++){\n \t\t\tletsgodp(j, 1);\n \t\t\tletsgodp(j, 2);\n \t\t\tletsgodp(j, 3);\n \t\t}\n \t\tint ans = 0;\n \t\tfor(int j=0;j<1<<n;j++){\n \t\t\tint time = 0;\n \t\t\tfor(int k = 0;k<n;k++){\n \t\t\t\tif (((1<<k) & j) != 0){\n \t\t\t\t\ttime+=times[k];\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (time == t){\n \t\t\t\tans+=dp[j][1];\n \t\t\t\tans%=mod;\n \t\t\t\tans+=dp[j][2];\n \t\t\t\tans%=mod;\n \t\t\t\tans+=dp[j][3];\n \t\t\t\tans%=mod;\n \t\t\t}\n \t\t}\n \t\tout.println(ans);\n \t\tout.close();\t\n \t}\n\tpublic static void letsgodp(int mask, int dg){\n\t\tif (dp[mask][dg] != -1)\n\t\t\treturn;\n\t\tdp[mask][dg] = 0;\n\t\tfor(int j = 0;j<n;j++){\n\t\t\tif (((1<<j) & mask) != 0 && genre[j] == dg){\n\t\t\t\tint submask = mask - (1<<j);\n\t\t\t\tint og1 = genre[j]+1 > 3 ? genre[j]-2 : genre[j]+1;\n\t\t\t\tint og2 = genre[j]+2 > 3 ? genre[j]-1 : genre[j]+2;\n\t\t\t\tif (submask != 0){\n\t\t\t\t\tletsgodp(submask, og1);\n\t\t\t\t\tletsgodp(submask, og2);\n\t\t\t\t\tdp[mask][dg] +=(dp[submask][og1] + dp[submask][og2]);\n\t\t\t\t\tdp[mask][dg] %=mod;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[mask][dg] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void sort(int[] array){\n\t\tArrayList<Integer> copy = new ArrayList<Integer>();\n\t\tfor (int i : array)\n\t\t\tcopy.add(i);\n\t\tCollections.sort(copy);\n\t\tfor(int i = 0;i<array.length;i++)\n\t\t\tarray[i] = copy.get(i);\n\t}\n\tstatic String[] readArrayString(int n){\n\t\tString[] array = new String[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.next();\n\t\treturn array;\n\t}\n\tstatic int[] readArrayInt(int n){\n    \tint[] array = new int[n];\n    \tfor(int j = 0;j<n;j++)\n    \t\tarray[j] = sc.nextInt();\n    \treturn array;\n    }\n\tstatic int[] readArrayInt1(int n){\n\t\tint[] array = new int[n+1];\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tarray[j] = sc.nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\tstatic long[] readArrayLong(int n){\n\t\tlong[] array = new long[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextLong();\n\t\treturn array;\n\t}\n\tstatic double[] readArrayDouble(int n){\n\t\tdouble[] array = new double[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextDouble();\n\t\treturn array;\n\t}\n\tstatic int minIndex(int[] array){\n\t\tint minValue = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(long[] array){\n\t\tlong minValue = Long.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(double[] array){\n\t\tdouble minValue = Double.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic long power(long x, long y){\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y%2 == 1)\n\t\t\treturn (x*power(x, y-1))%mod;\n\t\treturn power((x*x)%mod, y/2)%mod;\n\t}\n\tstatic void verdict(boolean a){\n        out.println(a ? \"YES\" : \"NO\");\n    }\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try{\n                str = br.readLine();\n            } \n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n    }\t\n}\n\n//StringJoiner sj = new StringJoiner(\" \"); \n//sj.add(strings)\n//sj.toString() gives string of those stuff w spaces or whatever that sequence is", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n\n            int[][] ab = in.nextIntArray2D(n, 2);\n\n            Random random = new Random();\n            int[] values = new int[2 * n];\n            for (int i = 0; i < 2 * n; i++) {\n                values[i] = ab[i / 2][i % 2];\n                swap(values, i, random.nextInt(i + 1));\n            }\n            Arrays.sort(values);\n\n            for (int[] x : ab) {\n                x[0] = Arrays.binarySearch(values, x[0]);\n                x[1] = Arrays.binarySearch(values, x[1]);\n            }\n\n            UnionFind uf = new UnionFind(values.length);\n            int[] cnt = new int[values.length];\n\n            final int inf = values.length;\n            int low = -1, high = inf;\n            LOOP:\n            while (high - low > 1) {\n                final int mid = (low + high) / 2;\n\n                for (int i = 0; i <= mid; i++) {\n                    uf.data[i] = -1;\n                    cnt[i] = 0;\n                }\n                uf.clear();\n                for (int[] x : ab) {\n                    int a = x[0];\n                    int b = x[1];\n                    if (mid < a) {\n                        low = mid;\n                        continue LOOP;\n                    }\n                    if (mid >= b) {\n                        uf.union(a, b);\n                    }\n                }\n\n                for (int[] x : ab) {\n                    int a = x[0];\n                    cnt[uf.root(a)]++;\n                }\n\n                for (int i = 0; i <= mid; i++) {\n                    if (uf.root(i) == i) {\n                        if (uf.size(i) < cnt[i]) {\n                            low = mid;\n                            continue LOOP;\n                        }\n                    }\n                }\n                high = mid;\n            }\n            out.println(high == inf ? -1 : values[high]);\n        }\n\n        static void swap(int[] xs, int i, int j) {\n            int t = xs[i];\n            xs[i] = xs[j];\n            xs[j] = t;\n        }\n\n        class UnionFind {\n            private int[] data;\n\n            public UnionFind(int size) {\n                data = new int[size];\n                clear();\n            }\n\n            public void clear() {\n                Arrays.fill(data, -1);\n            }\n\n            public int root(int x) {\n                return data[x] < 0 ? x : (data[x] = root(data[x]));\n            }\n\n            public void union(int x, int y) {\n                if ((x = root(x)) != (y = root(y))) {\n                    if (data[y] < data[x]) {\n                        final int t = x;\n                        x = y;\n                        y = t;\n                    }\n                    data[x] += data[y];\n                    data[y] = x;\n                }\n            }\n\n            public int size(int x) {\n                return -data[root(x)];\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        public int[][] nextIntArray2D(final int n, final int k) {\n            final int[][] res = new int[n][];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextIntArray(k);\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "problem": "1027_F", "from": "CODEFORCES", "tags": "binary search,dfs and similar,dsu,graph matchings,graphs"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class problemA {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int[] numbs = new int[n];\n        int[] smallest_color = new int[n];\n        for(int i =  0; i < n;i++){\n            numbs[i] = scan.nextInt();\n        }\n        Arrays.sort(numbs);\n        int count = 0;\n        for(int i =0; i < n; i++){\n            for(int j=0; j <n;j++ ){\n                if(smallest_color[j] == 0){\n                    count++;\n                    smallest_color[j] = numbs[i];\n                    break;\n                }\n                if(numbs[i] % smallest_color[j] == 0){\n                    break;\n                }\n            }\n        }\n        System.out.println(count);\n    }\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "\n\nimport java.awt.Point;\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class ProblemA_15 {\n    \n    final boolean ONLINE_JUDGE=System.getProperty(\"ONLINE_JUDGE\")!=null;\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok=new StringTokenizer(\"\");\n    \n    void init() throws FileNotFoundException{\n        if (ONLINE_JUDGE){\n            in=new BufferedReader(new InputStreamReader(System.in));\n            out =new PrintWriter(System.out);\n        }\n        else{\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        }\n    }\n    \n    String readString() throws IOException{\n        while(!tok.hasMoreTokens()){\n            tok=new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n    \n    int readInt() throws IOException{\n        return Integer.parseInt(readString());\n    }\n    \n    public static void main(String[] args){\n        new ProblemA_15().run();\n    }\n    \n    public void run(){\n        try{\n            long t1=System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            long t2=System.currentTimeMillis();\n            System.err.println(\"Time = \"+(t2-t1));\n        }catch (Exception e){\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n    \n    void solve() throws IOException{\n        int n=readInt();\n        int t=readInt();\n        Point[] a=new Point[n];\n        for (int i=0; i<n; i++){\n            a[i]=new Point(readInt(), readInt());\n        }\n        int count=2;\n        Arrays.sort(a, new Comparator<Point>(){\n\n            @Override\n            public int compare(Point p1, Point p2) {\n                return p1.x-p2.x;\n            }\n            \n        });\n        for (int i=1; i<n; i++){\n            double li=a[i-1].x+(double)a[i-1].y/2;\n            double ri=a[i].x-(double)a[i].y/2;\n            if (ri-li>t){\n                count+=2;\n            }\n            if (ri-li==t){\n                count++;\n            }\n        }\n        out.print(count);\n    }       \n}\n\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1187G extends PrintWriter {\n\tCF1187G() { super(System.out); }\n\tstatic class Scanner {\n\t\tScanner(InputStream in) { this.in = in; } InputStream in;\n\t\tint k, l; byte[] bb = new byte[1 << 15];\n\t\tbyte getc() {\n\t\t\tif (k >= l) {\n\t\t\t\tk = 0;\n\t\t\t\ttry { l = in.read(bb); } catch (IOException e) { l = 0; }\n\t\t\t\tif (l <= 0) return -1;\n\t\t\t}\n\t\t\treturn bb[k++];\n\t\t}\n\t\tint nextInt() {\n\t\t\tbyte c = 0; while (c <= 32) c = getc();\n\t\t\tint a = 0;\n\t\t\twhile (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n\t\t\treturn a;\n\t\t}\n\t}\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1187G o = new CF1187G(); o.main(); o.flush();\n\t}\n\n\tstatic final int INF = 0x3f3f3f3f;\n\tArrayList[] aa_;\n\tint n_, m_;\n\tint[] pi, dd, bb;\n\tint[] uu, vv, uv, cost, cost_;\n\tint[] cc;\n\tvoid init() {\n\t\taa_ = new ArrayList[n_];\n\t\tfor (int u = 0; u < n_; u++)\n\t\t\taa_[u] = new ArrayList<Integer>();\n\t\tpi = new int[n_];\n\t\tdd = new int[n_];\n\t\tbb = new int[n_];\n\t\tuu = new int[m_];\n\t\tvv = new int[m_];\n\t\tuv = new int[m_];\n\t\tcost = new int[m_];\n\t\tcost_ = new int[m_];\n\t\tcc = new int[m_ * 2];\n\t\tm_ = 0;\n\t}\n\tvoid link(int u, int v, int cap, int cos) {\n\t\tint h = m_++;\n\t\tuu[h] = u;\n\t\tvv[h] = v;\n\t\tuv[h] = u ^ v;\n\t\tcost[h] = cos;\n\t\tcc[h << 1 ^ 0] = cap;\n\t\taa_[u].add(h << 1 ^ 0);\n\t\taa_[v].add(h << 1 ^ 1);\n\t}\n\tboolean dijkstra(int s, int t) {\n\t\tArrays.fill(pi, INF);\n\t\tpi[s] = 0;\n\t\tTreeSet<Integer> pq = new TreeSet<>((u, v) -> pi[u] != pi[v] ? pi[u] - pi[v] : dd[u] != dd[v] ? dd[u] - dd[v] : u - v);\n\t\tpq.add(s);\n\t\tInteger first;\n\t\twhile ((first = pq.pollFirst()) != null) {\n\t\t\tint u = first;\n\t\t\tint d = dd[u] + 1;\n\t\t\tArrayList<Integer> adj = aa_[u];\n\t\t\tfor (int h_ : adj)\n\t\t\t\tif (cc[h_] > 0) {\n\t\t\t\t\tint h = h_ >> 1;\n\t\t\t\t\tint p = pi[u] + ((h_ & 1) == 0 ? cost_[h] : -cost_[h]);\n\t\t\t\t\tint v = u ^ uv[h];\n\t\t\t\t\tif (pi[v] > p || pi[v] == p && dd[v] > d) {\n\t\t\t\t\t\tif (pi[v] != INF)\n\t\t\t\t\t\t\tpq.remove(v);\n\t\t\t\t\t\tpi[v] = p;\n\t\t\t\t\t\tdd[v] = d;\n\t\t\t\t\t\tbb[v] = h_;\n\t\t\t\t\t\tpq.add(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn pi[t] != INF;\n\t}\n\tvoid push(int s, int t) {\n\t\tint c = INF;\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tc = Math.min(c, cc[h_]);\n\t\t}\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_] -= c; cc[h_ ^ 1] += c;\n\t\t}\n\t}\n\tvoid push1(int s, int t) {\n\t\tfor (int u = t, h_, h; u != s; u ^= uv[h]) {\n\t\t\th = (h_ = bb[u]) >> 1;\n\t\t\tcc[h_]--; cc[h_ ^ 1]++;\n\t\t}\n\t}\n\tint edmonds_karp(int s, int t) {\n\t\tcost_ = Arrays.copyOf(cost, m_);\n\t\twhile (dijkstra(s, t)) {\n\t\t\tpush1(s, t);\n\t\t\tfor (int h = 0; h < m_; h++) {\n\t\t\t\tint u = uu[h], v = vv[h];\n\t\t\t\tif (pi[u] != INF && pi[v] != INF)\n\t\t\t\t\tcost_[h] += pi[u] - pi[v];\n\t\t\t}\n\t\t}\n\t\tint c = 0;\n\t\tfor (int h = 0; h < m_; h++)\n\t\t\tc += cost[h] * cc[h << 1 ^ 1];\n\t\treturn c;\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tint[] ii = new int[k];\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tii[h] = sc.nextInt() - 1;\n\t\tArrayList[] aa = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = new ArrayList<Integer>();\n\t\tfor (int h = 0; h < m; h++) {\n\t\t\tint i = sc.nextInt() - 1;\n\t\t\tint j = sc.nextInt() - 1;\n\t\t\taa[i].add(j);\n\t\t\taa[j].add(i);\n\t\t}\n\t\tint t = n + k + 1;\n\t\tn_ = n * t + 1;\n\t\tm_ = k + (m * 2 * k + n) * (t - 1);\n\t\tinit();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrayList<Integer> adj = aa[i];\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s;\n\t\t\t\tfor (int j : adj) {\n\t\t\t\t\tint v = j * t + s + 1;\n\t\t\t\t\tfor (int x = 1; x <= k; x++)\n\t\t\t\t\t\tlink(u, v, 1, c + (x * 2 - 1) * d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int s = 0; s < t - 1; s++) {\n\t\t\t\tint u = i * t + s, v = u + 1;\n\t\t\t\tlink(u, v, k, i == 0 ? 0 : c);\n\t\t\t}\n\t\tfor (int h = 0; h < k; h++)\n\t\t\tlink(n_ - 1, ii[h] * t + 0, 1, 0);\n\t\tprintln(edmonds_karp(n_ - 1, 0 * t + t - 1));\n\t}\n}\n", "complexity": "cubic", "problem": "1187_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "import static java.util.Arrays.*;\nimport static java.lang.Math.*;\nimport static java.math.BigInteger.*;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class A implements Runnable\n{\n    String file = \"input\";\n    \n    boolean TEST = System.getProperty(\"ONLINE_JUDGE\") == null;\n    \n    void solve() throws IOException\n    {\n        int n = nextInt();\n        int[] a = new int[n];\n        for(int i = 0; i < n; i++) a[i] = nextInt();\n        int[] b = a.clone();\n        qsort(b);\n        //sortInt(b);\n        int count = 0;\n        for(int i = 0; i < a.length; i++)\n            if(a[i] != b[i]) count++;\n        if(count == 0 || count == 2) out.println(\"YES\");\n        else out.println(\"NO\");\n    }\n    \n    void qsort(int[] a)\n    {\n        List<Integer> as = new ArrayList<Integer>();\n        for(int x : a) as.add(x);\n        Collections.shuffle(as);\n        int j = 0;\n        for(int x : as) a[j++] = x;\n        sort(a);\n    }\n    \n    Random rnd = new Random();\n    \n    void sortInt(int[] a)\n    {\n        sortInt(a, 0, a.length - 1);\n    }\n    \n    void sortInt(int[] a, int from, int to)\n    {\n        if(from >= to) return;\n        int i = from - 1;\n        int p = rnd.nextInt(to - from + 1) + from;\n        int t = a[p]; a[p] = a[to]; a[to] = t;\n        for(int j = from; j < to; j++)\n            if(a[j] <= a[to])\n            {\n                i++;\n                t = a[i]; a[i] = a[j]; a[j] = t;\n            }\n        t = a[i + 1]; a[i + 1] = a[to]; a[to] = t;\n        sortInt(a, i + 2, to);\n        while(i >= 0 && a[i] == a[i + 1]) i--;\n        sortInt(a, from, i);\n        \n    }\n    \n    String next() throws IOException\n    {\n        while(st == null || !st.hasMoreTokens()) st = new StringTokenizer(input.readLine());\n        return st.nextToken();\n    }\n    \n    int nextInt() throws IOException\n    {\n        return Integer.parseInt(next());\n    }\n    \n    long nextLong() throws IOException\n    {\n        return Long.parseLong(next());\n    }\n    \n    double nextDouble() throws IOException\n    {\n        return Double.parseDouble(next());\n    }\n    \n    void print(Object... o)\n    {\n        System.out.println(deepToString(o));\n    }\n    \n    void gcj(Object o)\n    {\n        String s = String.valueOf(o);\n        out.println(\"Case #\" + test + \": \" + s);\n        System.out.println(\"Case #\" + test + \": \" + s);\n    }\n    \n    BufferedReader input;\n    PrintWriter out;\n    StringTokenizer st;\n    int test;\n    \n    void init() throws IOException\n    {\n        if(TEST) input = new BufferedReader(new FileReader(file + \".in\")); \n        else input = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n    }\n    \n    public static void main(String[] args) throws IOException\n    {\n        new Thread(null, new A(), \"\", 1 << 22).start();\n    }\n    \n    public void run()\n    {\n        try\n        {\n            init();\n            if(TEST) \n            {\n                int runs = nextInt();\n                for(int i = 0; i < runs; i++) solve();\n            }\n            else solve();\n            out.close();        \n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n}", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class bender {\n    static long[] dx = new long[]{0, 1, 0, -1};\n    static long[] dy = new long[]{-1, 0, 1, 0};\n    static long n, x, y, c;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        //BufferedReader in = new BufferedReader(new FileReader(\"bender.in\"));\n        \n        StringTokenizer dxdync = new StringTokenizer(in.readLine());\n        n = Long.parseLong(dxdync.nextToken());\n        x = Long.parseLong(dxdync.nextToken());\n        y = Long.parseLong(dxdync.nextToken());\n        c = Long.parseLong(dxdync.nextToken());\n        \n        long a = 0;\n        long b = c;\n        \n        while(a < b){\n            long m = (a + b)/2;\n            \n            long[] dxn = new long[4];\n            long[] dyn = new long[4];\n            \n            for(int d = 0; d < 4; d++){\n                dxn[d] = x + dx[d] * m;\n                dyn[d] = y + dy[d] * m;\n            }\n            \n            long ret = (m+1)*(m+1) + m*m;\n            \n            ret -= h(1 - dyn[0]);\n            ret -= h(dyn[2] - n);\n            ret -= h(dxn[1] - n);\n            ret -= h(1 - dxn[3]);\n            \n            ret += q(1 - dyn[0] - (n-x+1));\n            ret += q(1 - dyn[0] - x);\n            ret += q(dyn[2] - n - (n - x + 1));\n            ret += q(dyn[2] - n - (x));\n            \n            if (ret < c) a = m + 1;\n            else b = m;\n        }\n        \n        System.out.println(a);\n    }\n    \n    public static long h(long x) {\n        if (x <= 0) return 0;\n        return 2*q(x) - x;\n    }\n    private static long q(long x){\n        if (x <= 0) return 0;\n        return x*(x+1)/2;\n    }\n}", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "public class P1 {\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"25\");\n\t}\n\n}", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\nimport java.util.Scanner;\n\npublic class DarkAssembly {\n\tstatic double ans = 0;\n\tstatic int n = 0 ;\n\tstatic double [] l;\n\tstatic int [] b;\n\tstatic double a;\n\tpublic static void main(String [] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tn = in.nextInt();\n\t\tint k = in.nextInt();\n\t\ta = in.nextInt();\n\t\tl = new double[n];\n\t\tb = new int[n];\n\t\tfor(int i= 0 ; i < n ; i++){\n\t\t\tb[i]=in.nextInt();\n\t\t\tl[i]=in.nextInt()/100d;\n\t\t}\n\t\tmake(0,k);\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static void make(int i ,int k){\n\t\tif(k==0){\n\t\t\tans = Math.max(prob(), ans);\n\t\t\tif(ans >= 1){\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(i==n){\n\t\t\tans = Math.max(prob(), ans);\n\t\t\tif(ans >= 1){\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint f = i;\n\t\tif(l[i]<0.95){\n\t\t\tl[i]+=0.1d;\n\t\t\tmake(i,k-1);\n\t\t\tl[i]-=0.1d;\n\t\t}\n\t\tmake(f+1,k);\n\t\t\n\t}\n\tpublic static double prob(){\n\t\tdouble ans = 0;\n\t\tfor(int i = 0 ; i < (1<<n) ; i++){\n\t\t\tdouble B = 0 ;\n\t\t\tdouble t = 1;\n\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\tif ( (i & ( 1 << j)) != 0){\n\t\t\t\t\tt*=l[j];\n\t\t\t\t\tif(t==0) \n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tt*=1-l[j];\n\t\t\t\t\tif(t==0) \n\t\t\t\t\t\tbreak;\n\t\t\t\t\tB+=b[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Integer.bitCount(i)*2 <= n){\n\t\t\t\tt*= a/(a+B);\n\t\t\t}\n\t\t\tans+=t;\n\t\t\t\n\t\t}\n\t\treturn ans;\n\t\t\n\t}\n\t\n}", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic final class FollowTrafficRules {\n    private static double[] acce(double i, double a, double v) {\n        double[] r = new double[2];\n        r[0] = (v - i)/a;\n        r[1] = 1d/2d * a * pow(r[0], 2) + i * r[0];\n        return r;\n    }\n\n    private static double solve(double i, double a, double l) {\n        double e = sqrt(pow(i, 2) + 2d * a * l);\n        e = a > 0 ? e : -1d * e;\n        return (e - i)/a;\n    }\n\n    private static double time(double i, double a, double v, double l) {\n        double[] r = acce(i, a, v);\n        if (r[1] >= l) return solve(i, a, l);\n        return r[0] + (l - r[1])/v;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double a = sc.nextDouble();\n        double v = sc.nextDouble();\n        double l = sc.nextDouble();\n        double d = sc.nextDouble();\n        double w = sc.nextDouble();\n\n        double t = 0d;\n        if (v <= w) t = time(0, a, v, l);\n        else {\n            double[] r = acce(0, a, w);\n            if (r[1] >= d) t = time(0, a, v, l);\n            else {\n                t += r[0];\n                t += 2d * time(w, a, v, (d - r[1])/2d);\n                t += time(w, a, v, l - d);\n            }\n        }\n\n        System.out.println(t);\n    }\n}\n", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class D {\n\n\tstatic final boolean stdin = true;\n\tstatic final String filename = \"\";\n\tstatic FastScanner br;\n\tstatic PrintWriter pw;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (stdin) {\n\t\t\tbr = new FastScanner();\n\t\t\tpw = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t} else {\n\t\t\tbr = new FastScanner(filename + \".in\");\n\t\t\tpw = new PrintWriter(new FileWriter(filename + \".out\"));\n\t\t}\n\n\t\tSolver solver = new Solver();\n\t\tsolver.solve(br, pw);\n\t}\n\n\tstatic class Solver {\n\t\tstatic long mod = (long) (1e10);\n\n\t\tpublic void solve(FastScanner br, PrintWriter pw) throws IOException {\n\t\t\tint n = br.ni();\n\t\t\tInteger[] in = br.nIa(n);\n\t\t\tTreeSet<Integer> ts = new TreeSet<Integer>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tts.add(in[i]);\n\t\t\t}\n\t\t\tString twoSol = \"\";\n\t\t\tfor (int i = 0; i <= 30; i++) {\n\t\t\t\tfor (int j : in) {\n\t\t\t\t\tif (ts.contains(j + (int) Math.pow(2, i))) {\n\t\t\t\t\t\tif (ts.contains(j - (int) Math.pow(2, i))) {\n\t\t\t\t\t\t\tpw.println(3);\n\t\t\t\t\t\t\tpw.println(j + \" \" + (j + (int) Math.pow(2, i)) + \" \" + (j - (int) Math.pow(2, i)));\n\t\t\t\t\t\t\tpw.close();\n\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttwoSol = (j + \" \" + (j + (int) Math.pow(2, i)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (twoSol.isEmpty()) {\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.println(in[0]);\n\t\t\t} else {\n\t\t\t\tpw.println(2);\n\t\t\t\tpw.println(twoSol);\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tstatic long gcd(long a, long b) {\n\t\t\tif (a > b)\n\t\t\t\treturn gcd(b, a);\n\t\t\tif (a == 0)\n\t\t\t\treturn b;\n\t\t\treturn gcd(b % a, a);\n\t\t}\n\n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n\n\t\tstatic long pow(long a, long b) {\n\t\t\tif (b == 0)\n\t\t\t\treturn 1L;\n\t\t\tlong val = pow(a, b / 2);\n\t\t\tif (b % 2 == 0)\n\t\t\t\treturn val * val % mod;\n\t\t\telse\n\t\t\t\treturn val * val % mod * a % mod;\n\t\t}\n\n\t}\n\n\tstatic class Point implements Comparable<Point> {\n\t\tint a;\n\t\tint b;\n\n\t\tPoint(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn this.a - o.a;\n\t\t}\n\n\t}\n\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tArrayList<Integer>[] ng(int n, int e) {\n\t\t\tArrayList<Integer>[] adj = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < e; i++) {\n\t\t\t\tint a = ni() - 1;\n\t\t\t\tint b = ni() - 1;\n\t\t\t\tadj[a].add(b);\n\t\t\t\tadj[b].add(a);\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\n\t\tInteger[] nIa(int n) {\n\t\t\tInteger[] arr = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = ni();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] nia(int n) {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = ni();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tLong[] nLa(int n) {\n\t\t\tLong[] arr = new Long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nl();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] nla(int n) {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nl();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tString[] nsa(int n) {\n\t\t\tString[] arr = new String[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tString nt() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint ni() {\n\t\t\treturn Integer.parseInt(nt());\n\t\t}\n\n\t\tlong nl() {\n\t\t\treturn Long.parseLong(nt());\n\t\t}\n\n\t\tdouble nd() {\n\t\t\treturn Double.parseDouble(nt());\n\t\t}\n\n\t}\n}", "complexity": "nlogn", "problem": "0988_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class C{\n\tpublic static void main (String[] args) throws java.lang.Exception{\n\t\tScanner scan=new Scanner(System.in);\n\t\tlong x=scan.nextLong(), k=scan.nextLong();\n\t\tlong MOD = 1000000007;\n\t\tif(x==0){\n\t\t\tSystem.out.println(\"0\");\n\t\t\treturn;\n\t\t}\n\t\tx %= MOD;\n\t\tlong ans= (((new myC()).fastPow(2L, k+1)*x)%MOD - (new myC()).fastPow(2L, k) + MOD + 1)% MOD;\n\t\tans %= MOD;\n\t\tSystem.out.println(ans);\n\t}\n}\n\nclass myC{\n\tlong MOD = 1000000007;\n\tlong fastPow(long x, long k){\n\t\tlong bb=x%MOD, ans=1;\n\t\twhile(k > 0){\n\t\t\tif((k&1)==1){\n\t\t\t\tans=(ans*bb)%MOD;\n\t\t\t}\n\t\t\tbb=(bb*bb)%MOD;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "// Dummy text\nimport java.io.*; \nimport java.util.*; \n  public class forgery\n  {  \n    public static void main(String[] args) throws IOException \n    { \n           BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n           int n=Integer.parseInt(br.readLine());\n          long answer=0;\n          if(n==1)\n          answer=1;\n          else\n          answer= 2*n*n-2*n+1;\n          System.out.println(answer);\n }\n  }", "complexity": "constant", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class B {\n    static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n    static MyScanner sc;\n\n    static {\n        try {\n            sc = new MyScanner();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        doTask();\n        out.flush();\n    }\n\n    public static void doTask(){\n        long n = sc.nextInt();\n        long k = sc.nextInt();\n        long c = -2*(n+k);\n        long d =  9 - 4*c;\n        double result = n - (-3 + Math.sqrt(1.0*d))/2;\n        out.println(Math.round(result));\n    }\n\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() throws FileNotFoundException {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n}\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "//package com.example.programming;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Test {\n    static class Pair {\n        int f,s;\n        public Pair(int x, int y) {f = x; s = y;}\n    }\n    public static void main(String[] args) throws Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        String[] s = br.readLine().split(\" \");\n        int[] arr = new int[n];\n        for(int i = 0; i<n; i++) arr[i] = Integer.parseInt(s[i]);\n\n        HashMap<Integer, ArrayList<Pair>> map = new HashMap<>();\n        for(int i = 0; i<n; i++) {\n            int sum = 0;\n            for(int j = i; j>=0; j--) {\n                sum += arr[j];\n                ArrayList<Pair> list = map.get(sum);\n                if(list == null) {\n                    list = new ArrayList<>();\n                    map.put(sum, list);\n                }\n                list.add(new Pair(j, i));\n            }\n        }\n\n        Iterator it = map.entrySet().iterator();\n        ArrayList<Pair> ans = new ArrayList<>();\n        for(;it.hasNext();){\n            Map.Entry<Integer, ArrayList<Pair>> entry = (Map.Entry<Integer, ArrayList<Pair>>)it.next();\n            ArrayList<Pair> list = entry.getValue();\n            ArrayList<Pair> pre = new ArrayList<>();\n            int r = -1;\n            for(Pair p : list) {\n                if(p.f > r) {\n                    pre.add(p);\n                    r = p.s;\n                }\n            }\n            if(ans.size()<pre.size()) ans = pre;\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(ans.size()).append('\\n');\n        for(Pair p : ans) {\n            sb.append(p.f+1).append(' ').append(p.s+1).append('\\n');\n        }\n        System.out.print(sb);\n    }\n\n}\n", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.util.*;\npublic class Hotels {\n\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint n = input.nextInt();\n\t\tint[] cities = new int[n];\n\t\tint d = input.nextInt();\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcities[i] = input.nextInt();\n\t\t}\n\t\tint possibilities = 0;\n\t\tArrayList<Integer> newHotels = new ArrayList<Integer>();\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tint plusD = cities[i]+d;\n\t\t\tif (newHotels.indexOf(cities[i]+d)==-1 && minDist(plusD,cities)==d) {\n\t\t\t\tpossibilities++;\n\t\t\t\tnewHotels.add(cities[i]+d);\n\t\t\t}\n\t\t\tif (newHotels.indexOf(cities[i]-d)==-1 && minDist(cities[i]-d,cities)==d) {\n\t\t\t\tpossibilities++;\n\t\t\t\tnewHotels.add(cities[i]-d);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(possibilities);\n\t}\n\tpublic static int minDist(int a, int[] arr) {\n\t\tint minDist = Integer.MAX_VALUE;\n\t\tfor (int i=0; i<arr.length; i++) {\n\t\t\tminDist = Math.min(Math.abs(arr[i]-a), minDist);\n\t}\n\t\treturn minDist;\n\t}\n\n}\n", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class E {\n\n\tstatic final int P = 1_000_000_007;\n\n\tvoid submit() {\n\t\tint m = nextInt();\n\t\tint n = nextInt();\n\n\t\tint[][] ways = new int[m + 10][];\n\t\tfor (int i = 0; i < ways.length; i++) {\n\t\t\tways[i] = new int[i + 1];\n\t\t\tways[i][0] = ways[i][i] = 1;\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tways[i][j] = (ways[i - 1][j] + ways[i - 1][j - 1]) % P;\n\t\t\t}\n\t\t}\n\n\t\tint[] bell = new int[m + 1];\n\t\tbell[0] = 1;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\tbell[i + 1] += (int) ((long) bell[j] * ways[i][j] % P);\n\t\t\t\tif (bell[i + 1] >= P) {\n\t\t\t\t\tbell[i + 1] -= P;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tchar[][] f = new char[n][];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = nextToken().toCharArray();\n\t\t}\n\t\t\n\t\tHashMap<Long, Integer> map = new HashMap<>();\n\t\t\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tlong key = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tkey *= 2;\n\t\t\t\tif (f[j][i] == '1') {\n\t\t\t\t\tkey++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmap.merge(key, 1, Integer::sum);\n\t\t}\n\t\t\n\t\tint ans = 1;\n\t\tfor (int size : map.values()) {\n\t\t\tans = (int)((long)ans * bell[size] % P);\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tE() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew E();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n", "complexity": "quadratic", "problem": "0908_E", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,math"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.TreeSet;\n\npublic class B {\n\tpublic static void main(String[] args) {\n\t\tMScanner sc = new MScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tlong N = sc.nextLong();\n\t\tlong X = sc.nextLong();\n\t\tlong Y = sc.nextLong();\n\t\tlong C = sc.nextLong();\n\n\t\tlong low = 0;\n\t\tlong high = N*2;\n\t\tlong mid = 0;\n\t\tlong ans = 0;\n\t\twhile (low <= high) {\n\t\t\tmid = (low + high) >> 1;\n\t\t\tlong painted = F(mid, X-1, Y-1, N);\n\t\t\tif (painted < C) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tans = mid;\n\t\t\t\thigh = mid - 1;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\n\t}\n\n\tprivate static long F(long mid, long x, long y, long n) {\n\t\tlong base = 2 * mid * (mid + 1) + 1;\n\t\tbase -= excess(mid - x);\n\t\tbase -= excess(mid - y);\n\t\tbase -= excess(mid - (n-1-x));\n\t\tbase -= excess(mid - (n-1-y));\n\t\tbase += corner(mid - (x + y + 1));\n\t\tbase += corner(mid - (x + (n - y - 1) + 1));\n\t\tbase += corner(mid - ((n - x - 1) + y + 1));\n\t\tbase += corner(mid - (1 + (n - 1 - y) + (n - 1 - x)));\n\t\treturn base;\n\t}\n\n\tprivate static long corner(long a) {\n\t\tif (a < 0)return 0;\n\t\treturn (a * a + a) >> 1;\n\t}\n\n\tprivate static long excess(long thing) {\n\t\tif(thing<0)return 0;\n\t\treturn thing * thing;\n\t}\n\n\tstatic class MScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic MScanner() {\n\t\t\tstream = System.in;\n\t\t\t// stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextInt(int N) {\n\t\t\tint[] ret = new int[N];\n\t\t\tfor (int a = 0; a < N; a++)\n\t\t\t\tret[a] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tint[][] nextInt(int N, int M) {\n\t\t\tint[][] ret = new int[N][M];\n\t\t\tfor (int a = 0; a < N; a++)\n\t\t\t\tret[a] = nextInt(M);\n\t\t\treturn ret;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLong(int N) {\n\t\t\tlong[] ret = new long[N];\n\t\t\tfor (int a = 0; a < N; a++)\n\t\t\t\tret[a] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDouble(int N) {\n\t\t\tdouble[] ret = new double[N];\n\t\t\tfor (int a = 0; a < N; a++)\n\t\t\t\tret[a] = nextDouble();\n\t\t\treturn ret;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] next(int N) {\n\t\t\tString[] ret = new String[N];\n\t\t\tfor (int a = 0; a < N; a++)\n\t\t\t\tret[a] = next();\n\t\t\treturn ret;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextLine(int N) {\n\t\t\tString[] ret = new String[N];\n\t\t\tfor (int a = 0; a < N; a++)\n\t\t\t\tret[a] = nextLine();\n\t\t\treturn ret;\n\t\t}\n\n\t}\n}\n", "complexity": "logn", "problem": "0256_B", "from": "CODEFORCES", "tags": "binary search,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class _1517_D {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer line = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(line.nextToken());\n        int m = Integer.parseInt(line.nextToken());\n        int k = Integer.parseInt(line.nextToken());\n        int[][] edges1 = new int[n][m - 1];\n        int[][] edges2 = new int[n - 1][m];\n        for(int i = 0; i < n; i++) {\n            line = new StringTokenizer(in.readLine());\n            for(int j = 0; j < m - 1; j++) {\n                edges1[i][j] = Integer.parseInt(line.nextToken());\n            }\n        }\n        for(int i = 0; i < n - 1; i++) {\n            line = new StringTokenizer(in.readLine());\n            for(int j = 0; j < m; j++) {\n                edges2[i][j] = Integer.parseInt(line.nextToken());\n            }\n        }\n        if(k % 2 == 1) {\n            for(int i = 0; i < n; i++) {\n                StringBuilder sb = new StringBuilder();\n                for (int j = 0; j < m; j++) {\n                    sb.append(-1);\n                    if(j < m - 1) sb.append(' ');\n                }\n                out.println(sb.toString());\n            }\n        }else {\n            int[][][] dp = new int[n][m][k + 1];\n            for(int i = 0; i < n; i++) {\n                for(int j = 0; j < m; j++) {\n                    Arrays.fill(dp[i][j], Integer.MAX_VALUE);\n                    dp[i][j][0] = 0;\n                }\n            }\n            for(int a = 2; a <= k; a += 2) {\n                for(int i = 0; i < n; i++) {\n                    for(int j = 0; j < m; j++) {\n                        if(i > 0) {\n                            dp[i][j][a] = Math.min(dp[i][j][a], dp[i - 1][j][a - 2] + 2 * edges2[i - 1][j]);\n                        }\n                        if(i < n - 1) {\n                            dp[i][j][a] = Math.min(dp[i][j][a], dp[i + 1][j][a - 2] + 2 * edges2[i][j]);\n                        }\n                        if(j > 0) {\n                            dp[i][j][a] = Math.min(dp[i][j][a], dp[i][j - 1][a - 2] + 2 * edges1[i][j - 1]);\n                        }\n                        if(j < m - 1) {\n                            dp[i][j][a] = Math.min(dp[i][j][a], dp[i][j + 1][a - 2] + 2 * edges1[i][j]);\n                        }\n                    }\n                }\n            }\n            for(int i = 0; i < n; i++) {\n                StringBuilder sb = new StringBuilder();\n                for(int j = 0; j < m; j++) {\n                    sb.append(dp[i][j][k]);\n                    if(j < m - 1) sb.append(' ');\n                }\n                out.println(sb.toString());\n            }\n        }\n        in.close();\n        out.close();\n    }\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Deltix {\n    static PrintWriter out;\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            Stack<Integer> s = new Stack<>();\n            int [] a = new int[n];\n            for (int i = 0; i < n; ++i) a[i] = sc.nextInt();\n            for (int i = 0; i < n; i++) {\n                if (a[i] == 1) {\n                    s.push(1);\n                } else {\n                    while (s.peek() != a[i] - 1) {\n                        s.pop();\n                    }\n                    s.pop();\n                    s.push(a[i]);\n                }\n                print(s);\n            }\n        }\n        out.close();\n    }\n\n    static void print(Stack<Integer> s) {\n        ArrayDeque<Integer> a = new ArrayDeque<>();\n        while (!s.isEmpty()) {\n            a.addFirst(s.pop());\n        }\n        while (!a.isEmpty()) {\n            int x = a.pollFirst();\n            out.print(x);\n            s.push(x);\n            if (a.size() != 0) out.print(\".\");\n        }\n        out.println();\n    }\n\n\n    static void sort(int[] a) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i : a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n\n    static void sort(long[] a) {\n        ArrayList<Long> q = new ArrayList<>();\n        for (long i : a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "import java.util.*;\n\npublic class LCM235A\n{\n    public static void main(String[] args) \n    {\n        // Set up scanner\n        Scanner sc = new Scanner(System.in); \n        // System.out.println(\"Enter n\");\n        long n = sc.nextLong();\n        \n        if (n==1)\n        {\n            System.out.println(1);\n            return;\n        }\n        if (n==2)\n        {\n            System.out.println(2);\n            return;\n        }\n        if (n==3)\n        {\n            System.out.println(6);\n            return;\n        }\n        if (n==4)\n        {\n            System.out.println(12);\n            return;\n        }\n        \n        if (n%2 ==1)   // Odd number easy\n        {\n            System.out.println(n*(n-1)*(n-2));\n            return;\n        }\n        \n        // Even number is a bit harder\n        if (n%3 == 0)\n        {\n            System.out.println((n-1)*(n-2)*(n-3));\n        }\n        else\n        {\n            System.out.println(n*(n-1)*(n-3));\n        }\n    }\n}", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.*;\n\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class A {\n\n\tstatic class pair implements Comparable<pair> {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic pair(int d, int k) {\n\t\t\tx = d;\n\t\t\ty = k;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair arg0) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tif (x == arg0.x) {\n\t\t\t\treturn y - arg0.y;\n\t\t\t}\n\t\t\treturn x - arg0.x;\n\t\t}\n\t}\n\n\tstatic PrintWriter pw;\n\tstatic int n;\n\tstatic int m;\n\tstatic int k;\n\n\tstatic ArrayList<Integer> a;\n\n\tstatic int bin(int x) {\n\t\tint s = 0;\n\t\tint e = a.size() - 1;\n\t\tint ans = -1;\n\t\twhile (s <= e) {\n\t\t\tint mid = (s + e) / 2;\n\t\t\tif (a.get(mid) <= x) {\n\t\t\t\ts = mid + 1;\n\t\t\t\tans = mid;\n\t\t\t} else\n\t\t\t\te = mid - 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(System.out);\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tlong m = Long.parseLong(st.nextToken());\n\t\tlong n = Long.parseLong(st.nextToken());\n\n\t\tif (m == n)\n\t\t\tpw.println(0);\n\t\telse {\n\t\t\tchar[] a = Long.toBinaryString(n).toCharArray();\n\t\t\tchar[] b = Long.toBinaryString(m).toCharArray();\n\t\t\tchar[] c = new char[a.length];\n\t\t\tint i = a.length - 1;\n\t\t\tfor (int j = b.length - 1; j >= 0; j--, i--) {\n\t\t\t\tc[i] = b[j];\n\t\t\t}\n\n\t\t\tfor (; i >= 0; i--)\n\t\t\t\tc[i] = '0';\n\t\t\ti = 0;\n\t\t\tfor (i = 0; i < a.length; i++) {\n\t\t\t\tif (a[i] != c[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(pow(2,a.length-i) - 1);\n\t\t}\n\t\tpw.flush();\n\t\tpw.close();\n\n\t}\n\n\tstatic long pow(long a, long e) // O(log e)\n\t{\n\t\tlong res = 1;\n\t\twhile (e > 0) {\n\t\t\tif ((e & 1) == 1)\n\t\t\t\tres *= a;\n\t\t\ta *= a;\n\t\t\te >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\n\n}\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tstatic long inf=(long)1e9;\n\tstatic HashSet<Long>squares;\n\tstatic void main() throws Exception{\n\t\tlong n=sc.nextInt();\n\t\tif((n%2==0 && squares.contains(n/2)) || (n%4==0 && squares.contains(n/4))) {\n\t\t\tpw.println(\"YES\");\n\t\t}\n\t\telse {\n\t\t\tpw.println(\"NO\");\n\t\t}\n    }\n    public static void main(String[] args) throws Exception{\n    \tsc=new MScanner(System.in);\n    \tpw = new PrintWriter(System.out);\n        int tc=1;\n        tc=sc.nextInt();\n        squares=new HashSet<Long>();\n        for(long i=1;i*i<=inf;i++) {\n        \tsquares.add(i*i);\n        }\n        for(int i=1;i<=tc;i++) {\n//            pw.printf(\"Case #%d: \", i);\n            main();\n        }\n        pw.flush();\n    }\n    static PrintWriter pw;\n    static MScanner sc;\n    static class MScanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public MScanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n     \n        public MScanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n     \n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        public int[] intArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public long[] longArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public int[] intSortedArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public long[] longSortedArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public Integer[] IntegerArr(int n) throws IOException {\n            Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public Long[] LongArr(int n) throws IOException {\n            Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n     \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n     \n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n     \n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n     \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n     \n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n     \n        public void waitForInput() throws InterruptedException {\n            Thread.sleep(3000);\n        }\n        \n    }\n    static void sort(int[]in) {\n    \tshuffle(in);\n        Arrays.sort(in);\n    }\n    static void sort(long[]in) {\n    \tshuffle(in);\n        Arrays.sort(in);\n    }\n    static void shuffle(int[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            int tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n    static void shuffle(long[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            long tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n}", "complexity": "linear", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n    private BufferedReader in;\n    private PrintWriter out;\n    private StringTokenizer st;\n    \n    private void eat(String line)\n    {\n        st = new StringTokenizer(line);\n    }\n    \n    private String next() throws IOException\n    {\n        while(!st.hasMoreTokens()) {\n            String line = in.readLine();\n            if(line == null)\n                return null;\n            eat(line);\n        }\n        return st.nextToken();\n    }\n    \n    private int nextInt() throws IOException\n    {\n        return Integer.parseInt(next());\n    }\n    \n    public void run()\n    {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            eat(\"\");\n            \n            go();\n            \n            out.close();\n        } catch(Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n    \n    public static void main(String[] args)\n    {\n        new Thread(new Main()).start();\n    }\n    \n    public void go() throws IOException\n    {\n        int n = nextInt(), t = nextInt();\n        int[] x = new int[n], a = new int[n];\n        for(int i = 0; i < n; ++i) {\n            x[i] = nextInt();\n            a[i] = nextInt();\n        }\n        out.println(new Algo().solve(n, t, x, a));\n    }\n}\n\nfinal class Algo {\n    public int solve(int n, int t, final int[] x, final int[] a)\n    {\n        Integer[] order = new Integer[n];\n        for(int i = 0; i < n; ++i)\n            order[i] = i;\n        Arrays.sort(order, new Comparator<Integer>() {\n            public int compare(Integer a, Integer b)\n            {\n                return x[a] - x[b];\n            }\n        });\n        int result = 2;\n        for(int i = 0; i + 1 < n; ++i) {\n            int u = order[i], v = order[i + 1];\n            int dist = 2 * (x[v] - x[u]) - (a[v] + a[u]);\n            if(dist > 2 * t)\n                result += 2;\n            else if(dist == 2 * t)\n                ++result;\n        }\n        return result;\n    }\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "\nimport java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\n\tpublic long gcd(long a, long b) {\n\t\tlong tmp;\n\t\twhile (b > 0) {\n\t\t\ta %= b;\n\t\t\ttmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic void solve() throws Exception {\n\t\tlong a = sc.nextLong();\n\t\tlong b = sc.nextLong();\n\t\tlong ans = 0;\n\t\tlong k = 0;\n\t\tif (a == 1 || b == 1) {\n\t\t\tout.println(max(a, b));\n\t\t\treturn;\n\t\t}\n\t\twhile (a > 1 && b > 1) {\n\t\t\tif (a > b) {\n\t\t\t\tk = a / b;\n\t\t\t\tans += k;\n\t\t\t\ta -= (k * b);\t\t\t\t\n\t\t\t} else {\n\t\t\t\tk = b / a;\n\t\t\t\tans += k;\n\t\t\t\tb -= (k * a);\n\t\t\t}\n\t\t\tk = gcd(a, b);\n\t\t\ta /= k;\n\t\t\tb /= k;\n\t\t}\n\t\tif (a == 1)\n\t\t\tans += b;\n\t\telse\n\t\t\tans += a;\n\t\tout.println(ans);\n\t}\n\t\n\tstatic Throwable throwable;\n\t\n\tBufferedReader in;\n\tPrintWriter out;\n\tFastScanner sc;\n\t\n\tpublic static void main(String[] args) throws Throwable {\n\t\tThread thread = new Thread(null, new Solution(), \"\", (1 << 26));\n\t\tthread.start();\n\t\tthread.join();\n\t\tif (throwable != null) {\n\t\t\tthrow throwable;\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsc = new FastScanner(in);\n\t\t\tsolve();\n\t\t} catch (Throwable throwable) {\n\t\t\tthis.throwable = throwable;\t\t\t\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\t\t\n\t}\n\n}\n\nclass FastScanner {\n\tBufferedReader reader;\n\tStringTokenizer strTok;\n\t\n\tpublic FastScanner(BufferedReader reader) {\n\t\tthis.reader = reader;\n\t}\n\t\n\tpublic String nextToken() throws Exception {\n\t\twhile (strTok == null || !strTok.hasMoreTokens()) {\n\t\t\tstrTok = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn strTok.nextToken();\n\t}\n\t\n\tpublic int nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tpublic long nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\t\n\tpublic double nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import java.util.*;\n\npublic class A {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        System.out.println(\"0 0 \" + n);\n    }\n}", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\nimport java.util.Set;\nimport java.util.Map.Entry;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\n\npublic class test {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        String num = input.nextLine();\n\n        System.out.println(\"25\");\n    }\n}", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.util.*;\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++) a[i] = s.nextInt();\n\t\tint r = 0, an = 0;\n\t\tArrays.sort(a);\n\t\tint t = 0;\n\t\tfor(int z : a) t += z;\n\t\tfor(int i=a.length-1;i>=0;i--){\n\t\t\tr += a[i];\n\t\t\tan++;\n\t\t\tif (r > t - r) break;\n\t\t}\n\t\tSystem.out.println(an);\n\t}\n}", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.io.*;\n\nimport java.util.*;\n\npublic class j\n\n{\n\npublic static void main(String a[])throws IOException\n\n{\n\nBufferedReader b = new BufferedReader(new FileReader(\"input.txt\"));\n\nPrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n\nint l=0,x2=0,x=0,y1=0,y=0,max=-1,min=100000,x1=0,n=0,j=0,k=0,p=0,m=0,i=0;\n\nString s;\n\ns=b.readLine();\n\nStringTokenizer c=new StringTokenizer(s);\n\nn=Integer.parseInt(c.nextToken());\n\nm=Integer.parseInt(c.nextToken());\n\nk=Integer.parseInt(b.readLine());\n\nint e[][]=new int[k][2];\n\ns=b.readLine();\n\nStringTokenizer z=new StringTokenizer(s);\n\nfor(i=0;i<k;i++)\n\n{\n\ne[i][0]=Integer.parseInt(z.nextToken());\n\ne[i][1]=Integer.parseInt(z.nextToken());\n\n}\n\nfor(i=1;i<=n;i++)\n\n{\n\nfor(j=1;j<=m;j++)\n\n{\n\nfor(l=0;l<k;l++)\n\n{\n\np=(int)Math.abs(e[l][0]-i)+(int)Math.abs(e[l][1]-j);\n\nif(p<min)\n\n{\n\nmin=p;\n\nx1=i;\n\ny1=j;\n\n}\n\n}\n\nif(min>max)\n\n{\n\nmax=min;\n\nx=x1;\n\ny=y1;\n\n}\n\nmin=100000;\n\n}\n\n}\n\nout.print(x+\" \"+y);\n\nout.close();\n\n}\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.SortedSet;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * #\n * @author pttrung\n */\npublic class D_Edu_Round_35 {\n\n    public static long MOD = 1000000007;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n        // \"output.txt\")));\n        PrintWriter out = new PrintWriter(System.out);\n        Scanner in = new Scanner();\n        int n = in.nextInt();\n        int[] data = new int[n];\n        for (int i = 0; i < n; i++) {\n            data[i] = in.nextInt();\n        }\n        FT tree = new FT(n + 1);\n        int result = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            tree.update(data[i], 1);\n            result += tree.get(data[i] - 1);\n            result %= 2;\n        }\n        int q = in.nextInt();\n        int[] tmp = new int[n];\n        for (int i = 0; i < q; i++) {\n            int l = in.nextInt() - 1;\n            int r = in.nextInt() - 1;\n\n            int total = r - l + 1;\n            total = total * (total - 1) / 2;\n            total %= 2;\n\n            result += total;\n            result %= 2;\n            if (result % 2 == 0) {\n                out.println(\"even\");\n            } else {\n                out.println(\"odd\");\n            }\n        }\n        out.close();\n    }\n\n    public static int[] KMP(String val) {\n        int i = 0;\n        int j = -1;\n        int[] result = new int[val.length() + 1];\n        result[0] = -1;\n        while (i < val.length()) {\n            while (j >= 0 && val.charAt(j) != val.charAt(i)) {\n                j = result[j];\n            }\n            j++;\n            i++;\n            result[i] = j;\n        }\n        return result;\n\n    }\n\n    public static boolean nextPer(int[] data) {\n        int i = data.length - 1;\n        while (i > 0 && data[i] < data[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return false;\n        }\n        int j = data.length - 1;\n        while (data[j] < data[i - 1]) {\n            j--;\n        }\n        int temp = data[i - 1];\n        data[i - 1] = data[j];\n        data[j] = temp;\n        Arrays.sort(data, i, data.length);\n        return true;\n    }\n\n    public static int digit(long n) {\n        int result = 0;\n        while (n > 0) {\n            n /= 10;\n            result++;\n        }\n        return result;\n    }\n\n    public static double dist(long a, long b, long x, long y) {\n        double val = (b - a) * (b - a) + (x - y) * (x - y);\n        val = Math.sqrt(val);\n        double other = x * x + a * a;\n        other = Math.sqrt(other);\n        return val + other;\n\n    }\n\n    public static class Point implements Comparable<Point> {\n\n        int x, y;\n\n        public Point(int start, int end) {\n            this.x = start;\n            this.y = end;\n        }\n\n        @Override\n        public int hashCode() {\n            int hash = 5;\n            hash = 47 * hash + this.x;\n            hash = 47 * hash + this.y;\n            return hash;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final Point other = (Point) obj;\n            if (this.x != other.x) {\n                return false;\n            }\n            if (this.y != other.y) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            return Integer.compare(x, o.x);\n        }\n    }\n\n    public static class FT {\n\n        int[] data;\n\n        FT(int n) {\n            data = new int[n];\n        }\n\n        public void update(int index, int value) {\n            while (index < data.length) {\n                data[index] += value;\n                data[index] %= 2;\n                index += (index & (-index));\n            }\n        }\n\n        public int get(int index) {\n            int result = 0;\n            while (index > 0) {\n                result += data[index];\n                result %= 2;\n                index -= (index & (-index));\n            }\n            return result;\n\n        }\n    }\n\n    public static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static long pow(long a, long b, long MOD) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        long val = pow(a, b / 2, MOD);\n        if (b % 2 == 0) {\n            return val * val % MOD;\n        } else {\n            return val * (val * a % MOD) % MOD;\n\n        }\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() throws FileNotFoundException {\n            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n            //  br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"input.txt\"))));\n        }\n\n        public String next() {\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "/*\nKeep solving problems.\n*/\n\nimport java.util.*;\nimport java.io.*;\n\npublic class CFA {\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    private static final long MOD = 1000L * 1000L * 1000L + 7;\n    private static final int[] dx = {0, -1, 0, 1};\n    private static final int[] dy = {1, 0, -1, 0};\n    private static final String yes = \"Yes\";\n    private static final String no = \"No\";\n\n    void solve() throws IOException {\n        int n = nextInt();\n        long d = nextInt();\n        long[] arr = nextLongArr(n);\n        Set<Long> res = new HashSet<>();\n        for (long cur : arr) {\n            if (findMin(cur - d, arr) == d) {\n                res.add(cur - d);\n            }\n            if (findMin(cur + d, arr) == d) {\n                res.add(cur + d);\n            }\n        }\n\n        outln(res.size());\n    }\n\n    long findMin(long cur, long[] arr) {\n        long res = Long.MAX_VALUE;\n        for (long v : arr) {\n            res = Math.min(res, Math.abs(v - cur));\n        }\n\n        return res;\n    }\n\n    void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n    long gcd(long a, long b) {\n        while(a != 0 && b != 0) {\n            long c = b;\n            b = a % b;\n            a = c;\n        }\n        return a + b;\n    }\n\n    private void outln(Object o) {\n        out.println(o);\n    }\n    private void out(Object o) {\n        out.print(o);\n    }\n    private void formatPrint(double val) {\n        outln(String.format(\"%.9f%n\", val));\n    }\n    public CFA() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFA();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\n\n/**\n * @author khokharnikunj8\n */\n\npublic class Main {\n    public static void main(String[] args) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                new Main().solve();\n            }\n        }, \"1\", 1 << 26).start();\n    }\n\n    void solve() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FCookies solver = new FCookies();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FCookies {\n        long[] BIT;\n        long[] BIT1;\n        int[] cookie;\n        int[] time;\n        long[] max;\n        long T;\n        int[][][] G;\n\n        void update(int x, long delta) {\n            for (; x <= 1000001; x += x & -x)\n                BIT[x] += delta;\n        }\n\n        long query(int x) {\n            if (x <= 0) return 0;\n            long sum = 0;\n            for (; x > 0; x -= x & -x)\n                sum += BIT[x];\n            return sum;\n        }\n\n        void update1(int x, long delta) {\n            for (; x <= 1000001; x += x & -x)\n                BIT1[x] += delta;\n        }\n\n        long query1(int x) {\n            if (x <= 0) return 0;\n            long sum = 0;\n            for (; x > 0; x -= x & -x)\n                sum += BIT1[x];\n            return sum;\n        }\n\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            BIT = new long[1000001];\n            BIT1 = new long[1000001];\n            int n = in.scanInt();\n            T = in.scanLong();\n            cookie = new int[n + 1];\n            time = new int[n + 1];\n            max = new long[n + 1];\n            for (int i = 1; i <= n; i++) cookie[i] = in.scanInt();\n            for (int i = 1; i <= n; i++) time[i] = in.scanInt();\n            int[] from = new int[n - 1];\n            int[] to = new int[n - 1];\n            int[] weight = new int[n - 1];\n            for (int i = 0; i < n - 1; i++) {\n                from[i] = i + 2;\n                to[i] = in.scanInt();\n                weight[i] = in.scanInt();\n            }\n            G = CodeHash.packGraphW(from, to, weight, n);\n            dfs(1, -1, 0);\n            out.println(max[1]);\n\n        }\n\n        private void dfs(int n, int p, long t) {\n            update(time[n], ((long) time[n]) * cookie[n]);\n            update1(time[n], cookie[n]);\n            if (t > T) {\n                max[n] = 0;\n                update(time[n], -(((long) time[n]) * cookie[n]));\n                update1(time[n], -cookie[n]);\n                return;\n            } else max[n] = findMax(T - t);\n            long max1 = 0;\n            long max2 = 0;\n            for (int[] i : G[n]) {\n                if (i[0] == p) continue;\n                dfs(i[0], n, t + 2 * i[1]);\n                if (max1 <= max[i[0]]) {\n                    max2 = max1;\n                    max1 = max[i[0]];\n                } else if (max2 <= max[i[0]]) {\n                    max2 = max[i[0]];\n                }\n            }\n            update(time[n], -(((long) time[n]) * cookie[n]));\n            update1(time[n], -cookie[n]);\n            if (n != 1) max[n] = Math.max(max[n], max2);\n            else max[n] = Math.max(max[n], max1);\n        }\n\n        private long findMax(long TT) {\n            int index2 = -1;\n            {\n                int low = 0;\n                int high = 1000000;\n                while (low <= high) {\n                    int mid = (low + high) / 2;\n                    if (query(mid) <= TT) {\n                        index2 = mid;\n                        low = mid + 1;\n                    } else {\n                        high = mid - 1;\n                    }\n                }\n            }\n            if (index2 == -1) return 0;\n            if (query(index2) == TT) return query1(index2);\n            int index = -1;\n            {\n                int low = index2 + 1;\n                int high = 1000000;\n                while (low <= high) {\n                    int mid = (low + high) / 2;\n                    if (query(mid) > TT) {\n                        index = mid;\n                        high = mid - 1;\n                    } else {\n                        low = mid + 1;\n                    }\n                }\n            }\n            if (index == -1) return query1(index2);\n            long index1 = -1;\n            {\n                long low = 0;\n                long high = query1(index) - query1(index - 1);\n                long prev = query(index - 1);\n                while (low <= high) {\n                    long mid = (low + high) / 2;\n                    if (prev + ((mid) * index) <= TT) {\n                        index1 = mid;\n                        low = mid + 1;\n                    } else {\n                        high = mid - 1;\n                    }\n                }\n            }\n            if (index1 == -1) return 0;\n            return query1(index - 1) + index1;\n\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int index;\n        private BufferedInputStream in;\n        private int total;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (index >= total) {\n                index = 0;\n                try {\n                    total = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (total <= 0) return -1;\n            }\n            return buf[index++];\n        }\n\n        public int scanInt() {\n            int integer = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    integer *= 10;\n                    integer += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * integer;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n        public long scanLong() {\n            long integer = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    integer *= 10;\n                    integer += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * integer;\n        }\n\n    }\n\n    static class CodeHash {\n        public static int[][][] packGraphW(int[] from, int[] to, int[] w, int n) {\n            int[][][] g = new int[n + 1][][];\n            int[] p = new int[n + 1];\n            for (int i : from) p[i]++;\n            for (int i : to) p[i]++;\n            for (int i = 0; i <= n; i++) g[i] = new int[p[i]][2];\n            for (int i = 0; i < from.length; i++) {\n                --p[from[i]];\n                g[from[i]][p[from[i]]][0] = to[i];\n                g[from[i]][p[from[i]]][1] = w[i];\n                --p[to[i]];\n                g[to[i]][p[to[i]]][0] = from[i];\n                g[to[i]][p[to[i]]][1] = w[i];\n            }\n            return g;\n        }\n\n    }\n}", "complexity": "nlogn", "problem": "1099_F", "from": "CODEFORCES", "tags": "binary search,data structures,dfs and similar,dp,games,trees"}
{"src": "import java.io.*;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Array implements Runnable {\n\n    void solve() throws IOException {\n        int n = readInt();\n        int k = readInt();\n        int a[] = new int[n];\n        int startIdx = 0;\n        int endIdx = -1;\n        Map<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int i = 0; i < n; i ++) {\n            a[i] = readInt();\n            if(map.containsKey(a[i]))\n                map.put(a[i], map.get(a[i]) + 1);\n            else\n                map.put(a[i], 1);\n            if(map.size() == k && endIdx == -1) {\n                endIdx = i;\n                break;\n            }\n        }\n\n        if(endIdx != -1) {\n            while(startIdx < n && map.get(a[startIdx])>1) {\n                map.put(a[startIdx], map.get(a[startIdx]) - 1);\n                startIdx ++;\n            }\n            startIdx ++;\n            endIdx   ++;\n        } else\n            startIdx = -1;\n\n        out.println((startIdx)+\" \"+(endIdx));\n\n\n    }\n\n\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args) {\n        new Array().run();\n    }\n\n    public void run() {\n        try {\n            long t1 = System.currentTimeMillis();\n            if (System.getProperty(\"ONLINE_JUDGE\") != null) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(\"/Users/shenchen/input.txt\"));\n                out = new PrintWriter(\"/Users/shenchen/output.txt\");\n            }\n            Locale.setDefault(Locale.US);\n            solve();\n            in.close();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \" + (t2 - t1));\n        } catch (Throwable t) {\n            t.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n\n}", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "//package round528;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class C {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tint[] s, a, b;\n\t\n\tint[] toi(char[] a)\n\t{\n\t\tint[] ret = new int[a.length];\n\t\tfor(int i = 0;i < a.length;i++){\n\t\t\tret[i] = a[i] - 'a';\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvoid solve()\n\t{\n\t\touter:\n\t\tfor(int T = ni();T > 0;T--){\n\t\t\tint K = ni();\n\t\t\ts = toi(ns().toCharArray());\n\t\t\ta = toi(ns().toCharArray());\n\t\t\tb = toi(ns().toCharArray());\n\t\t\tint n = s.length;\n\t\t\tint com = n;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(a[i] != b[i]){\n\t\t\t\t\tcom = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] f = new int[K];\n\t\t\tArrays.fill(f, -1);\n\t\t\tint used = 0;\n\t\t\tfor(int i = 0;i < com;i++){\n\t\t\t\tif(f[s[i]] != -1){\n\t\t\t\t\tif(f[s[i]] != b[i]){\n\t\t\t\t\t\tout.println(\"NO\");\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(used<<~b[i]<0){\n\t\t\t\t\t\tout.println(\"NO\");\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t\tf[s[i]] = b[i];\n\t\t\t\t\tused |= 1<<b[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(com < n){\n\t\t\t\tif(a[com]+1 < b[com]){\n\t\t\t\t\tif(f[s[com]] == -1){\n\t\t\t\t\t\tfor(int i = a[com]+1;i < b[com];i++){\n\t\t\t\t\t\t\tif(used<<~i>=0){\n\t\t\t\t\t\t\t\tf[s[com]] = i;\n\t\t\t\t\t\t\t\tused |= 1<<i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f[s[com]] != -1 && a[com] < f[s[com]] && f[s[com]] < b[com]){\n\t\t\t\t\t\tok(f, used);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = sup(com, Arrays.copyOf(f, K), s, b, used);\n\t\t\tif(res != 0)continue;\n\t\t\t\n\t\t\tres = inf(com, Arrays.copyOf(f, K), s, a, used);\n\t\t\tif(res != 0)continue;\n\t\t\t\n\t\t\tout.println(\"NO\");\n\t\t}\n\t}\n\t\n\tint sup(int com, int[] f, int[] s, int[] b, int used)\n\t{\n\t\tint n = s.length;\n\t\tfor(int i = com;i < n;i++){\n//\t\t\ttr(i, f, used, s, a, b);\n\t\t\tif(f[s[i]] != -1){\n\t\t\t\tif(f[s[i]] > b[i]){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(f[s[i]] < b[i])return 0;\n\t\t\t}else{\n\t\t\t\tif(used<<~b[i]<0){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tf[s[i]] = b[i];\n\t\t\t\tused |= 1<<b[i];\n\t\t\t}\n\t\t\t\n\t\t\tif(i+1 < n){\n\t\t\t\tif(f[s[i+1]] == -1){\n\t\t\t\t\tfor(int j = 0;j < b[i+1];j++){\n\t\t\t\t\t\tif(used<<~j>=0){\n\t\t\t\t\t\t\tf[s[i+1]] = j;\n\t\t\t\t\t\t\tused |= 1<<j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f[s[i+1]] != -1 && f[s[i+1]] < b[i+1]){\n\t\t\t\t\tok(f, used);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok(f, used);\n\t\treturn 1;\n\t}\n\t\n\tint inf(int com, int[] f, int[] s, int[] a, int used)\n\t{\n\t\tint n = s.length;\n//\t\ttr(f, used);\n\t\tfor(int i = com;i < n;i++){\n\t\t\tif(f[s[i]] != -1){\n\t\t\t\tif(f[s[i]] < a[i]){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(f[s[i]] > a[i])return 0;\n\t\t\t}else{\n\t\t\t\tif(used<<~a[i]<0){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tf[s[i]] = a[i];\n\t\t\t\tused |= 1<<a[i];\n\t\t\t}\n\t\t\t\n\t\t\tif(i+1 < n){\n\t\t\t\tif(f[s[i+1]] == -1){\n\t\t\t\t\tfor(int j = a[i+1] + 1;j < f.length;j++){\n\t\t\t\t\t\tif(used<<~j>=0){\n\t\t\t\t\t\t\tf[s[i+1]] = j;\n\t\t\t\t\t\t\tused |= 1<<j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f[s[i+1]] != -1 && f[s[i+1]] > a[i+1]){\n\t\t\t\t\tok(f, used);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok(f, used);\n\t\treturn 1;\n\t}\n\t\n\tvoid ok(int[] f, int used)\n\t{\n\t\tfor(int i = 0;i < f.length;i++){\n\t\t\tif(f[i] == -1){\n\t\t\t\tint v = Integer.numberOfTrailingZeros(~used);\n\t\t\t\tf[i] = v;\n\t\t\t\tused |= 1<<v;\n\t\t\t}\n\t\t}\n\t\tout.println(\"YES\");\n\t\tfor(int i = 0;i < f.length;i++){\n\t\t\tout.print((char)('a'+f[i]));\n\t\t}\n\t\tout.println();\n\t\t\n//\t\t// check\n//\t\tint[] u = new int[s.length];\n//\t\tfor(int i = 0;i < s.length;i++){\n//\t\t\tu[i] = f[s[i]];\n//\t\t}\n//\t\ttr(\"f\", f, used);\n//\t\tfor(int i = 0;i < s.length;i++){\n//\t\t\tif(a[i] != u[i]){\n//\t\t\t\tassert a[i] < u[i];\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t}\n//\t\tfor(int i = 0;i < s.length;i++){\n//\t\t\tif(b[i] != u[i]){\n//\t\t\t\tassert b[i] > u[i];\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t}\n\t\t\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new C().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "complexity": "quadratic", "problem": "1086_C", "from": "CODEFORCES", "tags": "constructive algorithms,greedy,implementation,strings"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    long fast_pow(long a, long b) {\n        if(b == 0)\n            return 1L;\n        long val = fast_pow(a, b / 2);\n        if(b % 2 == 0)\n            return val * val % mod;\n        else\n            return val * val % mod * a % mod;\n    }\n    long mod = (long)1e9 + 7;\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n\n        long x = sc.nextLong();\n        long k = sc.nextLong();\n\n        if(x == 0) {\n            w.print(\"0\");\n            w.close();\n            return;\n        }\n\n        x = x % mod;\n\n        long pkp1 = fast_pow(2, k + 1L);\n        long pk = fast_pow(2, k);\n\n        long sub = (pk - 1 + mod) % mod * pk % mod;\n        long add = x * pkp1 % mod * pk % mod;\n        long num = (add - sub + mod) % mod;\n        long deninv = fast_pow(pk, mod - 2);\n        long ans = num * deninv % mod;\n        w.print(ans);\n\n        w.close();      \n    }\n}", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.SplittableRandom;\nimport java.util.StringTokenizer;\n\npublic class Div1_429D2 {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Div1_429D2().execute();\n\t}\n\n\tSplittableRandom rng = new SplittableRandom();\n\n\tfinal int SQRT = 548;\n\n\tvoid execute() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tStringTokenizer inputData = new StringTokenizer(reader.readLine());\n\t\tint nI = Integer.parseInt(inputData.nextToken());\n\t\tint nQ = Integer.parseInt(inputData.nextToken());\n\t\tint[] items = new int[nI];\n\t\tinputData = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0; i < nI; i++) {\n\t\t\titems[i] = Integer.parseInt(inputData.nextToken());\n\t\t}\n\t\tQuery[] queries = new Query[nQ];\n\t\tfor (int i = 0; i < nQ; i++) {\n\t\t\tinputData = new StringTokenizer(reader.readLine());\n\t\t\tqueries[i] = new Query(Integer.parseInt(inputData.nextToken()) - 1,\n\t\t\t\t\tInteger.parseInt(inputData.nextToken()) - 1, Integer.parseInt(inputData.nextToken()), i);\n\t\t}\n\n\t\tArrays.sort(queries);\n\t\tint[] ans = new int[nQ];\n\n\t\tint[] cnt = new int[nI + 1];\n\n\t\tint cL = 0;\n\t\tint cR = -1;\n\n\t\tfor (Query cQ : queries) {\n\t\t\twhile (cL < cQ.l) {\n\t\t\t\tcnt[items[cL++]]--;\n\t\t\t}\n\t\t\twhile (cQ.l < cL) {\n\t\t\t\tcnt[items[--cL]]++;\n\t\t\t}\n\t\t\twhile (cR < cQ.r) {\n\t\t\t\tcnt[items[++cR]]++;\n\t\t\t}\n\t\t\twhile (cQ.r < cR) {\n\t\t\t\tcnt[items[cR--]]--;\n\t\t\t}\n\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 80; i++) {\n\t\t\t\tint tI = cL + rng.nextInt(cR - cL + 1);\n\t\t\t\tif (items[tI] < min && cQ.k * cnt[items[tI]] > cR - cL + 1) {\n\t\t\t\t\tmin = items[tI];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[cQ.i] = min == Integer.MAX_VALUE ? -1 : min;\n\t\t}\n\t\tfor (int i = 0; i < nQ; i++) {\n\t\t\tprinter.println(ans[i]);\n\t\t}\n\t\tprinter.close();\n\t}\n\n\tclass Query implements Comparable<Query> {\n\t\tint l;\n\t\tint r;\n\t\tint buck;\n\t\tint k;\n\t\tint i;\n\n\t\tQuery(int l, int r, int k, int i) {\n\t\t\tthis.l = l;\n\t\t\tthis.r = r;\n\t\t\tbuck = l / SQRT;\n\t\t\tthis.k = k;\n\t\t\tthis.i = i;\n\t\t}\n\n\t\tpublic int compareTo(Query o) {\n\t\t\tint res = Integer.compare(buck, o.buck);\n\t\t\treturn res != 0 ? res : Integer.compare(r, o.r);\n\t\t}\n\t}\n\n}\n", "complexity": "cubic", "problem": "0840_D", "from": "CODEFORCES", "tags": "data structures,probabilities"}
{"src": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tset.add(sc.nextInt());\n\t\t}\n\n\t\tif(set.size() >= 2)\n\t\t\tSystem.out.println(set.toArray()[1]);\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n/**\n *\n * @Har_Har_Mahadev\n */\n\npublic class D {\n\n\tprivate static long INF = 2000000000000000000L, M = 1000000007, MM = 998244353;\n\tprivate static int N = 0;\n\tprivate static long[][][] dp;\n\tprivate static long[][] ff;\n\tprivate static long[][] ss;\n\n\tpublic static void process() throws IOException {\n\n\t\tint n = sc.nextInt(),m = sc.nextInt(),k = sc.nextInt();\n\t\t\n\t\tff = new long[n][m];\n\t\tss = new long[n][m];\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tfor(int j = 0; j<m-1; j++) {\n\t\t\t\tff[i][j] = sc.nextLong();\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i<n-1; i++) {\n\t\t\tfor(int j = 0; j<m; j++) {\n\t\t\t\tss[i][j] = sc.nextLong();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(k%2 == 1) {\n\t\t\tfor(int i = 0; i<n; i++) {\n\t\t\t\tfor(int j = 0; j<m; j++)System.out.print(-1+\" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdp = new long[n+1][m+1][11];\n\t\tfor(int i = 0; i<=n; i++) {\n\t\t\tfor(int j = 0; j<=m; j++)Arrays.fill(dp[i][j], -1);\n\t\t}\n\t\tfor(int i = 0; i<=n; i++) {\n\t\t\tfor(int j = 0; j<=m; j++) {\n\t\t\t\tdp[i][j][0] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tk/=2;\n\t\tlong ans[][] = new long[n][m];\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tfor(int j = 0; j<m; j++) {\n\t\t\t\tans[i][j] = solve(i,j,k,n,m)*2L;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tfor(int j = 0; j<m; j++)print(ans[i][j]+\" \");\n\t\t\tprintln();\n\t\t}\n\t}\n\n\tprivate static long solve(int i, int j, int k, int n, int m) {\n\t\tif(dp[i][j][k] != -1)return dp[i][j][k];\n\t\tlong ans = Long.MAX_VALUE;\n\t\tif(i+1<n) {\n\t\t\tans = min(ans,ss[i][j] + solve(i+1, j, k-1, n, m));\n\t\t}\n\t\tif(i-1>=0) {\n\t\t\tans = min(ans,ss[i-1][j] + solve(i-1, j, k-1, n, m));\n\t\t}\n\t\tif(j+1<m) {\n\t\t\tans = min(ans,ff[i][j] + solve(i, j+1, k-1, n, m));\n\t\t}\n\t\tif(j-1>=0) {\n\t\t\tans = min(ans,ff[i][j-1] + solve(i, j-1, k-1, n, m));\n\t\t}\n\t\t\n\t\treturn dp[i][j][k] = ans;\n\t}\n\n\t//=============================================================================\n\t//--------------------------The End---------------------------------\n\t//=============================================================================\n\n\tstatic FastScanner sc;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tboolean oj = true;\n\t\tif (oj) {\n\t\t\tsc = new FastScanner();\n\t\t\tout = new PrintWriter(System.out);\n\t\t} else {\n\t\t\tsc = new FastScanner(100);\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t}\n\t\tint t = 1;\n//\t\tt = sc.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tprocess();\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint x, y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn Integer.compare(this.x, o.x);\n\t\t}\n\n\t\t//\t\t @Override\n\t\t//\t\t    public boolean equals(Object o) {\n\t\t//\t\t        if (this == o) return true;\n\t\t//\t\t        if (!(o instanceof Pair)) return false;\n\t\t//\t\t        Pair key = (Pair) o;\n\t\t//\t\t        return x == key.x && y == key.y;\n\t\t//\t\t    }\n\t\t//\t\t \n\t\t//\t\t    @Override\n\t\t//\t\t    public int hashCode() {\n\t\t//\t\t        int result = x;\n\t\t//\t\t        result = 31 * result + y;\n\t\t//\t\t        return result;\n\t\t//\t\t    }\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\tstatic void println(Object o) {\n\t\tout.println(o);\n\t}\n\n\tstatic void println() {\n\t\tout.println();\n\t}\n\n\tstatic void print(Object o) {\n\t\tout.print(o);\n\t}\n\n\tstatic void pflush(Object o) {\n\t\tout.println(o);\n\t\tout.flush();\n\t}\n\n\tstatic int ceil(int x, int y) {\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\n\t}\n\n\tstatic long ceil(long x, long y) {\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int abs(int x) {\n\t\treturn Math.abs(x);\n\t}\n\n\tstatic long abs(long x) {\n\t\treturn Math.abs(x);\n\t}\n\n\tstatic long sqrt(long z) {\n\t\tlong sqz = (long) Math.sqrt(z);\n\t\twhile (sqz * 1L * sqz < z) {\n\t\t\tsqz++;\n\t\t}\n\t\twhile (sqz * 1L * sqz > z) {\n\t\t\tsqz--;\n\t\t}\n\t\treturn sqz;\n\t}\n\n\tstatic int log2(int N) {\n\t\tint result = (int) (Math.log(N) / Math.log(2));\n\t\treturn result;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tBigInteger b1 = BigInteger.valueOf(a);\n\t\tBigInteger b2 = BigInteger.valueOf(b);\n\t\tBigInteger gcd = b1.gcd(b2);\n\t\treturn gcd.intValue();\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tBigInteger b1 = BigInteger.valueOf(a);\n\t\tBigInteger b2 = BigInteger.valueOf(b);\n\t\tBigInteger gcd = b1.gcd(b2);\n\t\treturn gcd.longValue();\n\t}\n\n\tpublic static long lcm(long a, long b) {\n\t\treturn (a * b) / gcd(a, b);\n\t}\n\n\tpublic static int lcm(int a, int b) {\n\t\treturn (a * b) / gcd(a, b);\n\t}\n\n\tpublic static int lower_bound(int[] arr, int x) {\n\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\twhile (low < high) {\n\t\t\tmid = (low + high) / 2;\n\n\t\t\tif (arr[mid] >= x)\n\t\t\t\thigh = mid;\n\t\t\telse\n\t\t\t\tlow = mid + 1;\n\t\t}\n\n\t\treturn low;\n\t}\n\n\tpublic static int upper_bound(int[] arr, int x) {\n\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\twhile (low < high) {\n\t\t\tmid = (low + high) / 2;\n\n\t\t\tif (arr[mid] > x)\n\t\t\t\thigh = mid;\n\t\t\telse\n\t\t\t\tlow = mid + 1;\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner() throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tFastScanner(int a) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tint[] readArray(int n) throws IOException {\n\t\t\tint[] A = new int[n];\n\t\t\tfor (int i = 0; i != n; i++) {\n\t\t\t\tA[i] = sc.nextInt();\n\t\t\t}\n\t\t\treturn A;\n\t\t}\n\n\t\tlong[] readArrayLong(int n) throws IOException {\n\t\t\tlong[] A = new long[n];\n\t\t\tfor (int i = 0; i != n; i++) {\n\t\t\t\tA[i] = sc.nextLong();\n\t\t\t}\n\t\t\treturn A;\n\t\t}\n\t}\n\n\tstatic void ruffleSort(int[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\n\tstatic void ruffleSort(long[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tlong temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        // TODO code application logic here\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int iTotTerm, i, j, iSml = 0, iPos = 0;\n        iTotTerm = Integer.parseInt(br.readLine());\n        String seq[];\n        seq = br.readLine().split(\" \");\n        int iSeq[] = new int[iTotTerm];\n        for (i = 0; i < iTotTerm; i++) {\n            iSeq[i] = Integer.parseInt(seq[i]);\n        }\n        for (i = 0; i < iTotTerm; i++) {\n            iSml = iSeq[i];\n            iPos = i;\n            for (j = i; j < iTotTerm; j++) {\n                if (iSeq[j] < iSml) {\n                    iSml = iSeq[j];\n                    iPos = j;\n                }\n            }\n            iSeq[iPos] = iSeq[i];\n            iSeq[i] = iSml;\n            if (i != 0 && iSeq[i - 1] != iSeq[i]) {\n                break;\n            }\n        }\n        if (iSml != iSeq[0]) {\n            System.out.print(iSml);\n        } else {\n            System.out.print(\"NO\");\n        }\n    }\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class A {\n    void solve(){\n        long k = readLong();\n\n       long x = 9;\n       long y = 1;\n       while(k > x * y){\n           k -= x * y;\n           x *= 10;\n           y++;\n       }\n\n\n       long w = k / y + (k % y == 0 ? 0 : 1);\n       long e = (k % y - 1 % y + y) % y;\n\n       long num = x/9 + w - 1;\n       String s = Long.toString(num);\n       out.print(s.charAt((int) e) - '0');\n    }\n\n    public static void main(String[] args) {\n        new A().run();\n    }\n\n    void run(){\n        init();\n        solve();\n        out.close();\n    }\n\n    BufferedReader in;\n    PrintWriter out;\n\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init(){\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out  = new PrintWriter(System.out);\n    }\n\n    String readLine(){\n        try{\n            return in.readLine();\n        }catch(Exception ex){\n            throw new RuntimeException(ex);\n        }\n    }\n    String readString(){\n        while(!tok.hasMoreTokens()){\n            String nextLine = readLine();\n            if(nextLine == null) return null;\n            tok = new StringTokenizer(nextLine);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt(){\n        return Integer.parseInt(readString());\n    }\n\n    long readLong(){\n        return Long.parseLong(readString());\n    }\n\n    double readDouble(){\n        return Double.parseDouble(readString());\n    }\n}\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "\n\nimport java.awt.Point;\n\nimport java.io.*;\n\nimport java.math.BigInteger;\n\nimport java.util.*;\n\n\n\n\n\nimport static java.lang.Math.*;\n\n\n\npublic class Main implements Runnable {\n\n    \n\n    BufferedReader in;\n\n    PrintWriter out;\n\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n\n\n    void init() throws FileNotFoundException {\n\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n\n            out = new PrintWriter(\"output.txt\");\n\n    }\n\n\n\n    String readString() throws IOException {\n\n        while (!tok.hasMoreTokens()) {\n\n            tok = new StringTokenizer(in.readLine());\n\n        }\n\n        return tok.nextToken();\n\n    }\n\n\n\n    int readInt() throws IOException {\n\n        return Integer.parseInt(readString());\n\n    }\n\n\n\n    long readLong() throws IOException {\n\n        return Long.parseLong(readString());\n\n    }\n\n\n\n    double readDouble() throws IOException {\n\n        return Double.parseDouble(readString());\n\n    }\n\n\n\n\n\n    public static void mergeSort(int[] a) {\n\n            mergeSort(a, 0, a.length - 1);\n\n    }\n\n\n\n    private static void mergeSort(int[] a, int leftIndex, int rightIndex) {\n\n            final int MAGIC_VALUE = 50;\n\n            if (leftIndex < rightIndex) {\n\n                    if (rightIndex - leftIndex <= MAGIC_VALUE) {\n\n                            insertionSort(a, leftIndex, rightIndex);\n\n                    } else {\n\n                            int middleIndex = (leftIndex + rightIndex) / 2;\n\n                            mergeSort(a, leftIndex, middleIndex);\n\n                            mergeSort(a, middleIndex + 1, rightIndex);\n\n                            merge(a, leftIndex, middleIndex, rightIndex);\n\n                    }\n\n            }\n\n    }\n\n\n\n    private static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {\n\n            int length1 = middleIndex - leftIndex + 1;\n\n            int length2 = rightIndex - middleIndex;\n\n            int[] leftArray = new int[length1];\n\n            int[] rightArray = new int[length2];\n\n            System.arraycopy(a, leftIndex, leftArray, 0, length1);\n\n            System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n\n            for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n\n                    if (i == length1) {\n\n                            a[k] = rightArray[j++];\n\n                    } else if (j == length2) {\n\n                            a[k] = leftArray[i++];\n\n                    } else {\n\n                            a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];\n\n                    }\n\n            }\n\n    }\n\n\n\n    private static void insertionSort(int[] a, int leftIndex, int rightIndex) {\n\n            for (int i = leftIndex + 1; i <= rightIndex; i++) {\n\n                    int current = a[i];\n\n                    int j = i - 1;\n\n                    while (j >= leftIndex && a[j] > current) {\n\n                            a[j + 1] = a[j];\n\n                            j--;\n\n                    }\n\n                    a[j + 1] = current;\n\n            }\n\n    }\n\n    \n\n    public static void main(String[] args) {\n\n        new Main().run();\n\n    }\n\n\n\n    public void run() {\n\n        try {\n\n            long t1 = System.currentTimeMillis();\n\n            init();\n\n            solve();\n\n            out.close();\n\n            long t2 = System.currentTimeMillis();\n\n            System.err.println(\"Time = \" + (t2 - t1));\n\n        } catch (Exception e) {\n\n            e.printStackTrace(System.err);\n\n            System.exit(-1);\n\n        }\n\n    }\n\n\n\n    int mini = Integer.MAX_VALUE;\n\n    int maxi = Integer.MIN_VALUE;\n\n    int ans = 0;\n\n    int ans2 = 0;\n\n    int sum = 0;\n\n\n\n    void solve() throws IOException {\n\n        int n = readInt();\n\n        int m = readInt();\n\n        int maxi=0;\n\n        int  [][] a = new int [n][m];\n\n        int k = readInt();\n\n        ArrayDeque<Point> dq = new ArrayDeque<Point> ();\n\n        Point p = new Point();\n\n        for (int i = 0; i<n; i++)\n\n            for (int j= 0; j<m; j++){\n\n                a[i][j]=Integer.MAX_VALUE;\n\n            }\n\n        for (int i = 0; i<k; i++){\n\n            int x = readInt()-1;\n\n            int y = readInt()-1;\n\n            p.x=x;\n\n            p.y=y;\n\n            dq.add(new Point(x,y));\n\n            a[x][y]=0;\n\n        }\n\n        while (!dq.isEmpty()){\n\n            Point v = dq.pollFirst();\n\n            Point u = new Point();\n\n            if (v.x-1!=-1) {\n\n                if (a[v.x-1][v.y]>a[v.x][v.y]+1){\n\n                    a[v.x-1][v.y]=a[v.x][v.y]+1;\n\n                    maxi=max(maxi,a[v.x-1][v.y]);\n\n                    u.x=v.x-1;\n\n                    u.y=v.y;\n\n                    dq.add(new Point(u.x,u.y));\n\n                }\n\n            }\n\n            if (v.y-1!=-1) {\n\n                if (a[v.x][v.y-1]>a[v.x][v.y]+1){\n\n                    a[v.x][v.y-1]=a[v.x][v.y]+1;\n\n                    maxi=max(maxi,a[v.x][v.y-1]);\n\n                    u.y=v.y-1;\n\n                    u.x=v.x;\n\n                    dq.add(new Point(u.x,u.y));\n\n                }\n\n            }\n\n            if (v.x+1!=n) {\n\n                if (a[v.x+1][v.y]>a[v.x][v.y]+1){\n\n                    a[v.x+1][v.y]=a[v.x][v.y]+1;\n\n                    maxi=max(maxi,a[v.x+1][v.y]);\n\n                    u.x=v.x+1;\n\n                    u.y=v.y;\n\n                    dq.add(new Point(u.x,u.y));\n\n                }\n\n            }\n\n            if (v.y+1!=m) {\n\n                if (a[v.x][v.y+1]>a[v.x][v.y]+1){\n\n                    a[v.x][v.y+1]=a[v.x][v.y]+1;\n\n                    maxi=max(maxi,a[v.x][v.y+1]);\n\n                    u.y=v.y+1;\n\n                    u.x=v.x;\n\n                    dq.add(new Point(u.x,u.y));\n\n                }\n\n            }\n\n        }\n\n        for (int i =0; i<n; i++)\n\n            for (int j =0; j<m; j++){\n\n                if (maxi==a[i][j]) {\n\n                    out.print((i+1) + \" \" + (j+1));\n\n                    return;\n\n                }\n\n            }\n\n        \n\n      }\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n\n\n    char c[];\n\n    \n\n    void per (int left, int right){\n\n        if(left == right){\n\n            for (int i = 0; i<=right;i++){\n\n                out.print(c[i]);\n\n            }\n\n            out.println();\n\n        }\n\n        else {\n\n            for (int i = left; i <=right; i++){\n\n                char k = c[left];\n\n                c[left] = c[i];\n\n                c[i] = k;\n\n                per(left+1,right);\n\n                k = c[left];\n\n                c[left] = c[i];\n\n                c[i] = k;\n\n            }\n\n        }\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "/*\n * Code Author: Sanket Udgirkar.\n * DA-IICT\n */\nimport java.util.*;\nimport java.io.*;\npublic class Tester\n{\n\tpublic static long mod=(long)1e9+7;\n\t\n\tpublic static void main(String[] args) \n\t{\n\t\tInputReader s=new InputReader(System.in);\n        OutputStream outputStream = System.out;\n        //PrintWriter out=new PrintWriter(outputStream);\n        \n       String str=s.nextLine();\n       System.out.println(\"25\");\n        \n        \n        //out.close();\n\t}   \n\t\n\tstatic long gcd(long a,long b)\n\t{\n\t\tif(b==0)\n\t\t\treturn a;\n\t\ta%=b;\n\t\treturn gcd(b,a);\n\t}\n\t\n\tstatic long exp(long a, long b)\n\t{\n\t\tif(b==0)\n\t\t\treturn 1;\n\t\tif(b==1)\n\t\t\treturn a;\n\t\tif(b==2)\n\t\t\treturn a*a;\n\t\t\n\t\tif(b%2==0)\n\t\t\treturn exp(exp(a,b/2),2);\n\t\telse\n\t\t\treturn a*exp(exp(a,(b-1)/2),2);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair>\n\t{\n\t\tlong x,f;\n\t\tPair(long ii, long cc)\n\t\t{\n\t\t\tx=ii;\n\t\t\tf=cc;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Pair o) \n\t\t{\n\t\t\treturn Long.compare(this.x, o.x);\n\t\t}\n\t\t\n\t}\n\n    public static class InputReader \n    {\n    \tpublic BufferedReader reader;\n    \tpublic StringTokenizer tokenizer;\n     \n    \tpublic InputReader(InputStream inputstream) \n    \t{\n    \t      reader = new BufferedReader(new InputStreamReader(inputstream));\n    \t      tokenizer = null;\n    \t}\n    \t    \n    \tpublic String nextLine()\n    \t{\n    \t    String fullLine=null;\n    \t    while (tokenizer == null || !tokenizer.hasMoreTokens()) \n    \t    {\n    \t        try {\n    \t              fullLine=reader.readLine();\n    \t            } \n    \t        catch (IOException e) \n    \t        {\n    \t              throw new RuntimeException(e);\n    \t        }\n    \t        return fullLine;\n    \t     }\n    \t     return fullLine;\n    \t}\n    \t\tpublic String next() \n    \t\t{\n    \t      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n    \t        try {\n    \t          tokenizer = new StringTokenizer(reader.readLine());\n    \t        } catch (IOException e) {\n    \t          throw new RuntimeException(e);\n    \t        }\n    \t      }\n    \t      return tokenizer.nextToken();\n    \t    }\n    \t\tpublic long nextLong() {\n    \t\t      return Long.parseLong(next());\n    \t\t    }\n    \t    public int nextInt() {\n    \t      return Integer.parseInt(next());\n    \t    }\n    \t  }\n \n}", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.sort;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class A {\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = scanInt();\n\t\t}\n\t\tsort(a);\n\t\tint ans = 0;\n\t\tans: while (true) {\n\t\t\tfor (int i = 0;; i++) {\n\t\t\t\tif (i == n) {\n\t\t\t\t\tbreak ans;\n\t\t\t\t}\n\t\t\t\tif (a[i] != 0) {\n\t\t\t\t\t++ans;\n\t\t\t\t\tint t = a[i];\n\t\t\t\t\ta[i] = 0;\n\t\t\t\t\tfor (i++; i < n; i++) {\n\t\t\t\t\t\tif (a[i] % t == 0) {\n\t\t\t\t\t\t\ta[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class D1517 {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint[][] costRight = new int[n][m - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m - 1; j++) {\n\t\t\t\tcostRight[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tint[][] costDown = new int[n - 1][m];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tcostDown[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tif (k % 2 == 1) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tpw.print(-1 + \" \");\n\t\t\t\t}\n\t\t\t\tpw.println();\n\t\t\t}\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tint[][][] dp = new int[k + 1][n][m];\n\t\tfor (int w = 2; w <= k; w += 2) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tdp[w][i][j] = (int) 1e9;\n\t\t\t\t\tif (i + 1 < n)\n\t\t\t\t\t\tdp[w][i][j] = Math.min(dp[w][i][j], 2 * costDown[i][j] + dp[w - 2][i + 1][j]);\n\t\t\t\t\tif (i - 1 >= 0)\n\t\t\t\t\t\tdp[w][i][j] = Math.min(dp[w][i][j], 2 * costDown[i - 1][j] + dp[w - 2][i - 1][j]);\n\t\t\t\t\tif (j + 1 < m)\n\t\t\t\t\t\tdp[w][i][j] = Math.min(dp[w][i][j], 2 * costRight[i][j] + dp[w - 2][i][j + 1]);\n\t\t\t\t\tif (j - 1 >= 0)\n\t\t\t\t\t\tdp[w][i][j] = Math.min(dp[w][i][j], 2 * costRight[i][j - 1] + dp[w - 2][i][j - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tpw.print(dp[k][i][j] + \" \");\n\t\t\t}\n\t\t\tpw.println();\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader f) {\n\t\t\tbr = new BufferedReader(f);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArr(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Integer.parseInt(next());\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t}\n\n}\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "//package com.krakn.CF.D1159;\n\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n, k;\n        n = sc.nextInt();\n        k = sc.nextInt();\n\n        int a = (n - k) / 2;\n\n        StringBuilder s = new StringBuilder();\n\n        int i;\n        while (s.length() < n) {\n            i = 0;\n            while (i < a && s.length() < n) {\n                s.append(\"0\");\n                i++;\n            }\n            if (s.length() < n) s.append(\"1\");\n        }\n\n        System.out.println(s);\n    }\n}\n", "complexity": "linear", "problem": "1159_D", "from": "CODEFORCES", "tags": "brute force,greedy,constructive algorithms,math,strings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer; \n  \n\npublic class temp4 {\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\t\n/*\tstatic class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    } */\n//\tstatic class Print\n//\t{\n//\t    private final BufferedWriter bw;\n//\t    public Print()\n//\t    {\n//\t        bw=new BufferedWriter(new OutputStreamWriter(System.out));\n//\t    }\n//\t    public void print(String str)throws IOException\n//\t    {\n//\t        bw.append(str);\n//\t    }\n//\t    public void println(String str)throws IOException\n//\t    {\n//\t        print(str);\n//\t        bw.append(\"\\n\");\n//\t    }\n//\t    public void close()throws IOException\n//\t    {\n//\t        bw.close();\n//\t    }} \n//\t\t\n\t\t\n\t\n\t\tpublic static void main(String[] args) throws IOException {\t\t\t\n\t\t\tFastReader scn=new FastReader();\n\t\t//\tPrint pr=new Print();\n\t\t\tPrintWriter out=new PrintWriter(System.out);\n\t\t\tout.write(\"? 0 0\\n\");\n\t\t\tout.flush();\n\t\t\tint tie=scn.nextInt();\n\t\t\tint a=0,b=0,n1=0,n2=0,diff=0;\n\t\t\tfor(int i=29;i>=0;i--){\n\t\t\t\tout.write(\"? \"+((1<<i)|a)+\" \"+b+\"\\n\");\n\t\t\t\tout.flush();\n\t\t\t\tn1=scn.nextInt();\n\t\t\t\tout.write(\"? \"+a+\" \"+((1<<i)|b)+\"\\n\");\n\t\t\t\tout.flush();\n\t\t\t\tn2=scn.nextInt();\n\t\t\t\tdiff=n1-n2;\n\t\t\t\tif(diff==2){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(diff==-2){\n\t\t\t\t\ta=a|(1<<i);\n\t\t\t\t\tb=b|(1<<i);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(tie==1){\n\t\t\t\t\t\ta=a|(1<<i);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tb=b|(1<<i);\n\t\t\t\t\t}\n\t\t\t\t\ttie=n1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tout.write(\"! \"+a+\" \"+b+\"\\n\");\n\t\t\tout.flush();\n\t\t\t\n\t\t\tout.close();\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic static class node{\n\t\t\tint val;\n\t\t\tint idx;\n\t\t\tpublic node(int val,int idx){\n\t\t\t\tthis.val=val;this.idx=idx;\n\t\t\t}\n\t\t}\n}\n\t", "complexity": "logn", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\npublic class A {\n\tpublic static void main(String[] args) throws IOException\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint[] list = new int[n];\n\t\tfor(int i = 0; i < list.length; i++)\n\t\t\tlist[i] = Integer.parseInt(st.nextToken());\n\t\tint odd = 0;\n\t\tint even = 0;\n\t\tfor(int x: list)\n\t\t\tif(x%2==1)\t{\n\t\t\t\todd++;\n\t\t\t}\n\t\t\telse\t{\n\t\t\t\teven++;\n\t\t\t}\n\t\tfor(int i = 1; i <= list.length; i++)\t{\n\t\t\tif(list[i-1]%2==1 && odd == 1)\t{\n\t\t\t\tSystem.out.println(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if(list[i-1]%2 == 0 && even == 1){\n\t\t\t\tSystem.out.println(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n}\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "//package sept;\n\nimport java.io.*;\nimport java.util.*;\n\n\npublic class TimePass implements Runnable {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n    //boolean debug=false;\n    boolean debug=true;\n    static long mod=998244353;\n    static long mod2=1000000007;\n    \n    void solve() throws IOException\n    {\n        int n=ni();\n        int[] a=na(n);\n        long[] sum=new long[n];\n        sum[0]=a[0];\n        for(int i=1;i<n;i++)sum[i]=sum[i-1]+a[i];\n        HashMap<Long,ArrayList<Pair>> map=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i;j<n;j++)\n            {\n                long curr=sum[j]-(i>0?sum[i-1]:0);\n                if(map.containsKey(curr))\n                {\n                    map.get(curr).add(new Pair(i+1,j+1));\n                }\n                else\n                {\n                    ArrayList<Pair> list=new ArrayList<>();\n                    list.add(new Pair(i+1,j+1));\n                    map.put(curr,list);\n                }\n            }\n        }\n        int max=0;\n        long maxSum=0;\n        for(long key:map.keySet())\n        {\n            ArrayList<Pair> list=map.get(key);\n            list.sort(new Comparator<Pair>(){\n                public int compare(Pair p1,Pair p2)\n                {\n                    return p1.b-p2.b;\n                }\n            });\n            int prevl=0;\n            int cnt=0;\n            for(Pair pr:list)\n            {\n                if(pr.a>prevl)\n                {\n                    cnt++;\n                    prevl=pr.b;\n                }\n            }\n            if(max<cnt)\n            {\n                max=cnt;\n                maxSum=key;\n            }\n        }\n        int prevl=0;\n        ArrayList<Pair> list=map.get(maxSum);\n        ArrayList<Pair> ans=new ArrayList<>();\n        for(Pair pr:list)\n        {\n            if(pr.a>prevl)\n            {\n                //cnt++;\n                ans.add(pr);\n                //out.println(pr.a+\" \"+pr.b);\n                prevl=pr.b;\n            }\n        }\n        out.println(ans.size());\n        for(Pair pr:ans)\n        {\n            out.println(pr.a+\" \"+pr.b);\n        }\n    }\n    \n    static long fnc(int a,int b)\n    {\n        return a+(long)1000000007*b;\n    }\n    \n    static Pair[][] packU(int n,int[] from,Pair[] to)\n    {\n        Pair[][] g=new Pair[n][];\n        int[] p=new int[n];\n        for(int f:from)\n        {\n            p[f]++;\n        }\n        int m=from.length;\n        for(int i=0;i<n;i++)\n        {\n            g[i]=new Pair[p[i]];\n        }\n        for(int i=0;i<m;i++)\n        {\n            g[from[i]][--p[from[i]]]=to[i];\n        }\n        return g;\n    }\n\n    static int[][] packD(int n,int[] from,int[] to)\n    {\n        int[][] g=new int[n][];\n        int[] p=new int[n];\n        for(int f:from)\n        {\n            p[f]++;\n        }\n        int m=from.length;\n        for(int i=0;i<n;i++)\n        {\n            g[i]=new int[p[i]];\n        }\n        for(int i=0;i<m;i++)\n        {\n            g[from[i]][--p[from[i]]]=to[i];\n        }\n        return g;\n    }\n        \n    static class Pair\n    {\n        int a,b,c;\n        public Pair(int a,int b\n        //,int c\n        )\n        {\n            this.a=a;\n            this.b=b;\n            //this.c=c;\n        }\n    }\n    \n    static long lcm(int a,int b)\n    {\n        long val=a;\n        val*=b;\n        return (val/gcd(a,b));\n    }\n    \n    static long gcd(long a,long b)\n    {\n        if(a==0)return b;\n        return gcd(b%a,a);\n    }\n    \n    static int pow(int a, int b, int p)\n    {\n        long ans = 1, base = a;\n        while (b!=0)\n        {\n            if ((b & 1)!=0)\n            {\n                ans *= base;\n                ans%= p;\n            }\n            base *= base;\n            base%= p;\n            b >>= 1;\n        }\n        return (int)ans;\n    }\n\n    static int inv(int x, int p)\n    {\n        return pow(x, p - 2, p);\n    }\n    \n    public static long[] radixSort(long[] f){ return radixSort(f, f.length); }\n    public static long[] radixSort(long[] f, int n)\n    {\n        long[] to = new long[n];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < n;i++)b[1+(int)(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < n;i++)to[b[(int)(f[i]&0xffff)]++] = f[i];\n            long[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < n;i++)b[1+(int)(f[i]>>>16&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < n;i++)to[b[(int)(f[i]>>>16&0xffff)]++] = f[i];\n            long[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < n;i++)b[1+(int)(f[i]>>>32&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < n;i++)to[b[(int)(f[i]>>>32&0xffff)]++] = f[i];\n            long[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < n;i++)b[1+(int)(f[i]>>>48&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < n;i++)to[b[(int)(f[i]>>>48&0xffff)]++] = f[i];\n            long[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n\n    \n    public void run()\n    {\n        if(debug)oj=true;\n        is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        \n        long s = System.currentTimeMillis();\n        try {\n            solve();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        out.flush();\n        tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception {new Thread(null,new TimePass(),\"Main\",1<<26).start();}\n    \n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.util.*;\n\npublic class vas2 {\n    public static void main( String[] args ) {\n\tScanner in = new Scanner( System.in );\n\tint n = in.nextInt();\n\tString st = in.next();\n\tint[] a = new int[n];\n\tfor ( int i = 0; i < n; i++ )\n\t    a[i] = st.charAt( i ) - 48;\n\tboolean c = false;\n\tfor ( int i = 1; !c && i < n; i++ ) {\n\t    int s = 0;\n\t    for ( int j = 0; j < i; j++ )\n\t\ts += a[j];\n\t    int t = 0;\n\t    for ( int j = i; j < n; j++ ) {\n\t\tt += a[j];\n\t\tif ( t > s )\n\t\t    if ( t - a[j] != s )\n\t\t\tbreak;\n\t\t    else\n\t\t\tt = a[j];\n\t    }\n\t    if ( t == s )\n\t\tc = true;\n\t}\n\tSystem.out.println( c ? \"YES\" : \"NO\" );\n    }\n}\n", "complexity": "quadratic", "problem": "1030_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\n/**\n * Write a description of class VK2A here.\n * \n * @author (your name) \n * @version (a version number or a date)\n */\nimport java.util.*;\npublic class VK2A\n{\n    public static void main(String args[])\n    {\n        Scanner S = new Scanner(System.in);\n        int n = S.nextInt();\n        int a = S.nextInt();\n        int b = S.nextInt();\n        int[] A = new int[n];\n        for(int i = 0; i < n; i++)\n            A[i] = S.nextInt();\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < n - i - 1; j++)\n            {\n                if(A[j] < A[j + 1])\n                {\n                    int temp = A[j];\n                    A[j] = A[j + 1];\n                    A[j + 1] = temp;\n                }\n            }\n        \n            System.out.println(A[a - 1] - A[a]);\n        }\n \n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class TaskA {\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer stok;\n\n\tString nextToken() throws IOException {\n\t\twhile (stok == null || !stok.hasMoreTokens()) {\n\t\t\tString s = br.readLine();\n\t\t\tif (s == null) {\n\t\t\t\treturn \"-1\";\n\t\t\t}\n\t\t\tstok = new StringTokenizer(s);\n\t\t}\n\t\treturn stok.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() throws IOException {\n\t\treturn (char) (br.read());\n\t}\n\n\tString nextLine() throws IOException {\n\t\treturn br.readLine();\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\ta[n - 1] = a[n - 1] == 1 ? 2 : 1;\n\t\tArrays.sort(a);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tout.print(a[i]);\n\t\t\tout.print(' ');\n\t\t}\n\t}\n\n\tvoid run() throws IOException {\n\t\t// br = new BufferedReader(new FileReader(\"taska.in\"));\n\t\t// out = new PrintWriter(\"taska.out\");\n\t\t// br = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t// out = new PrintWriter(\"output.txt\");\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tbr.close();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// Locale.setDefault(Locale.US);\n\t\tnew TaskA().run();\n\t}\n}", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n        public int[] arr(int n){int[] ret = new int[n];for (int i = 0; i < n; i++) {ret[i] = i();}return ret;}\n    }\n    \n    \n \n           //       |----|       /\\      |    |   -----   |\n           //       |   /       /  \\     |    |     |     |\n           //       |--/       /----\\    |----|     |     |\n           //       |   \\     /      \\   |    |     |     |\n           //       |    \\   /        \\  |    |   -----   -------\n    \n    public static void main(String[] args)throws IOException\n    {\n        Reader sc=new Reader();\n        PrintWriter out=new PrintWriter(System.out);\n        int n=sc.i();\n        int arr[]=sc.arr(n);\n        int count=0;\n        for(int i=0;i<n;i++)for(int j=i+1;j<n;j++)if(arr[j]<arr[i])count++;\n        count%=2;\n        int q=sc.i();\n        while(q-->0)\n        {\n            int a=sc.i();\n            int b=sc.i();\n            long len=((long)(b-a+1)*(b-a))/2;\n            if(len%2==1)count^=1;\n            if(count==0)out.println(\"even\");\n            else out.println(\"odd\");\n        }\n        out.flush();\n    }\n}", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author bacali\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CNastyaAndAWardrobe solver = new CNastyaAndAWardrobe();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CNastyaAndAWardrobe {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            long mod = (long) (1e9 + 7);\n            long n = in.nextLong();\n            long k = in.nextLong();\n            if (n == 0) {\n                out.println(0);\n                return;\n            }\n            long c = (((2 * n - 1) % mod) * pow(2L, k, mod)) % mod + 1;\n            c %= mod;\n            out.println(c);\n        }\n\n        public long pow(long a, long b, long mod) {\n            long result = 1;\n            while (b > 0) {\n                if (b % 2 != 0) {\n                    result *= a;\n                    result %= mod;\n                    b--;\n                }\n                a *= a;\n                a %= mod;\n                b /= 2;\n            }\n\n            return result % mod;\n\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream inputStream) {\n            br = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "\nimport java.util.Scanner;\n\npublic class P23A {\n    public P23A() {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        sc.close();\n        \n        String maxStr = \"\";\n        for (int i = 0; i < str.length() - 1; i++){\n            for (int j = i + 1; j < str.length(); j++){\n                String pattern = str.substring(i, j);\n                if (str.substring(i+1).contains(pattern) && pattern.length() > maxStr.length()){\n                    maxStr = pattern;\n                }\n            }\n        }\n        System.out.println(maxStr.length());\n    }\n    \n    public static void main (String []args){\n        new P23A();\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.GregorianCalendar;\nimport java.util.Scanner;\n\n\npublic class ProblemB {\n\n    \n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        \n        int a = s.nextInt();\n        \n        int f1 = a/10;\n        \n        int b = a;\n        int last = a%10;\n        \n        b/=10;\n        b/=10;\n        b*=10;\n        b+=last;\n        \n        System.out.println(Math.max(a, Math.max(f1, b)));\n        \n        \n        \n    }\n\n}\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.util.*;\nimport java.io.*;\n \n public class Solution {\n \n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        long n = scan.nextLong();\n        long s = scan.nextLong();\n        \n        long l=1; long r=n; //System.out.println(sumfxn(43));\n        long ans=-1;\n         while(l<=r)\n         {\n             long mid=r+(l-r)/2;\n            \n             if(mid-sumfxn(mid)>=s)\n             {  long t=n-mid+1;\n                 if(ans<t)\n                   ans=n-mid+1;\n                 r=mid-1;\n                \n             }else{\n                 l=mid+1;\n             }\n             }\n        \n         if(ans==-1)\n        System.out.println(\"0\");\n        else\n         System.out.println(ans);\n \n \n    }\n    \n    public  static  long sumfxn(long n)\n    {\n        long sum=0;\n        \n        while(n!=0)\n        {\n           long d=n%10;\n           sum+=d;\n           n=n/10;\n        }\n        return sum;\n    }\n}", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lewin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public List<TaskC.Edge>[] graph;\n        public int[] res;\n        int n;\n\n        public boolean ok1(long x, long y) {\n            return x * x + y * y <= 1000000L * 1000000L;\n        }\n\n        public boolean ok2(long x, long y) {\n            return x * x + y * y <= 1500000L * 1500000L;\n        }\n\n        public void dfs(int node) {\n            for (TaskC.Edge next : graph[node]) {\n                res[next.to] = (next.same == 1 ? 1 : -1) * res[node];\n                dfs(next.to);\n            }\n        }\n\n        public boolean ok(int mask, ArrayList<TaskC.Vector> vs, OutputWriter out) {\n            long x = 0, y = 0;\n            for (int i = 0; i < vs.size(); i++) {\n                if (((mask >> i) & 1) == 1) {\n                    x += vs.get(i).x;\n                    y += vs.get(i).y;\n                } else {\n                    x -= vs.get(i).x;\n                    y -= vs.get(i).y;\n                }\n            }\n            if (ok2(x, y)) {\n                res = new int[n];\n                for (int i = 0; i < vs.size(); i++) {\n                    if (((mask >> i) & 1) == 1) {\n                        res[vs.get(i).id] = +1;\n                    } else {\n                        res[vs.get(i).id] = -1;\n                    }\n                    dfs(vs.get(i).id);\n                }\n                out.println(res);\n                return true;\n            }\n            return false;\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.nextInt();\n            ArrayList<TaskC.Vector> vs = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                vs.add(new TaskC.Vector(in.nextInt(), in.nextInt(), i));\n            }\n            graph = LUtils.genArrayList(n);\n            while (vs.size() > 10) {\n                vs.sort(Comparator.comparingDouble(x -> Math.atan2(x.y, x.x)));\n                ArrayList<TaskC.Vector> nvs = new ArrayList<>();\n                for (int i = 0; i < vs.size(); i++) {\n                    if (i + 1 < vs.size()) {\n                        TaskC.Vector a1 = vs.get(i);\n                        TaskC.Vector a2 = vs.get(i + 1);\n                        if (ok1(a1.x + a2.x, a1.y + a2.y)) {\n                            nvs.add(new TaskC.Vector(a1.x + a2.x, a1.y + a2.y, a1.id));\n                            graph[a1.id].add(new TaskC.Edge(a2.id, 1));\n                            i++;\n                        } else if (ok1(a1.x - a2.x, a1.y - a2.y)) {\n                            if (a1.x - a2.x >= 0) {\n                                nvs.add(new TaskC.Vector(a1.x - a2.x, a1.y - a2.y, a1.id));\n                                graph[a1.id].add(new TaskC.Edge(a2.id, 0));\n                            } else {\n                                nvs.add(new TaskC.Vector(a2.x - a1.x, a2.y - a1.y, a2.id));\n                                graph[a2.id].add(new TaskC.Edge(a1.id, 0));\n                            }\n                            i++;\n                        } else {\n                            nvs.add(vs.get(i));\n                        }\n                    } else {\n                        nvs.add(vs.get(i));\n                    }\n                }\n                vs = nvs;\n            }\n\n            for (int mask = 0; mask < 1 << vs.size(); mask++) {\n                if (ok(mask, vs, out)) {\n                    return;\n                }\n            }\n        }\n\n        static class Vector {\n            public int x;\n            public int y;\n            public int id;\n\n            public Vector(int x, int y, int id) {\n                this.x = x;\n                this.y = y;\n                this.id = id;\n            }\n\n        }\n\n        static class Edge {\n            public int to;\n            public int same;\n\n            public Edge(int to, int same) {\n                this.to = to;\n                this.same = same;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 16];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void println(int[] array) {\n            print(array);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class LUtils {\n        public static <E> List<E>[] genArrayList(int size) {\n            return Stream.generate(ArrayList::new).limit(size).toArray(List[]::new);\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "problem": "0995_C", "from": "CODEFORCES", "tags": "brute force,data structures,geometry,greedy,math,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class CE35D {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tBufferedReader sc = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tint n = Integer.parseInt(sc.readLine());\n\t\tString[] t = sc.readLine().split(\" \");\n\t\tint[] list = new int[n];\n\t\tfor(int x=0; x<n; x++){\n\t\t\tlist[x] = Integer.parseInt(t[x]);\n\t\t}\n\t\t\n\t\tboolean even = true;\n\t\t\n\t\tint[] indList = new int[n+1];\n\t\t\n\t\t\n\t\tfor(int x=0; x<n; x++){\n\t\t\tindList[list[x]] = x;\n\t\t}\n\t\t\n\t\tfor(int x=1; x<=n; x++){\n\t\t\tint theIndex = indList[x];\n\t\t\tint other = list[x-1];\n\t\t\tif(theIndex != x-1){\n\t\t\t\teven = !even;\n\n\t\t\t\tlist[x-1] = x;\n\t\t\t\tlist[theIndex] = other;\n\t\t\t\t\n\t\t\t\tindList[x] = x-1;\n\t\t\t\tindList[other] = theIndex;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(even);\n\t\t\n\t\tint numQ = Integer.parseInt(sc.readLine());\n\t\tfor(int x=0; x<numQ; x++){\n\t\t\tString[] dir = sc.readLine().split(\" \");\n\t\t\tint l = Integer.parseInt(dir[0]);\n\t\t\tint r = Integer.parseInt(dir[1]);\n\t\t\tint diff = r - l + 1;\n\t\t\tif(diff%4 > 1){\n\t\t\t\teven = !even;\n\t\t\t}\n\t\t\tif(even){\n\t\t\t\tSystem.out.println(\"even\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"odd\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\nint n = Integer.parseInt(sc.nextLine());\nString[] t = sc.nextLine().split(\" \");\nint[] list = new int[n];\nfor(int x=0; x<n; x++){\n\tlist[x] = Integer.parseInt(t[x]);\n}\n\t\t\nString[] dir = sc.nextLine().split(\" \");\nint a = Integer.parseInt(dir[0]);\nint b = Integer.parseInt(dir[1]);\nint c = Integer.parseInt(dir[2]);\nint d = Integer.parseInt(dir[3]);\nint e = Integer.parseInt(dir[4]);\n\nint n = Integer.parseInt(sc.nextLine());\n*/", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\n\tFastReader in = new FastReader();\n\tPrintWriter out = new PrintWriter(System.out);\n\tvoid run(){\n\t\twork();\n\t\tout.flush();\n\t}\n\tlong mod=998244353;\n\tlong gcd(long a,long b) {\n\t\treturn b==0?a:gcd(b,a%b);\n\t}\n\tvoid work() {\n\t\tint n=in.nextInt();\n\t\tint[] A=new int[n];\n\t\tfor(int i=0;i<n;i++)A[i]=in.nextInt();\n\t\tHashMap<Integer,Integer> map=new HashMap<>();\n\t\tHashMap<Integer,ArrayList<int[]>> rec=new HashMap<>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=i,cur=0;j>=0;j--) {\n\t\t\t\tcur+=A[j];\n\t\t\t\tif(map.get(cur)==null) {\n\t\t\t\t\tmap.put(cur,i);\n\t\t\t\t\trec.put(cur,new ArrayList<>());\n\t\t\t\t\trec.get(cur).add(new int[] {j,i});\n\t\t\t\t}else if(map.get(cur)<j) {\n\t\t\t\t\tmap.put(cur,i);\n\t\t\t\t\trec.get(cur).add(new int[] {j,i});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<int[]> ret=null;\n\t\tfor(ArrayList<int[]> list:rec.values()) {\n\t\t\tif(ret==null||ret.size()<list.size()) {\n\t\t\t\tret=list;\n\t\t\t}\n\t\t}\n\t\tout.println(ret.size());\n\t\tfor(int[] r:ret) {\n\t\t\tout.println((r[0]+1)+\" \"+(r[1]+1));\n\t\t}\n\t}\n}\t\n\n\n\nclass FastReader\n{\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic FastReader()\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tpublic String next() \n\t{\n\t\tif(st==null || !st.hasMoreElements())\n\t\t{\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() \n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong()\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "\nimport java.io.PrintWriter;\n\nimport java.util.*;\nimport java.util.Arrays ; \nimport java .lang.String.* ;\nimport java .lang.StringBuilder ;\n\n\npublic class Test{\n    static int pos = 0 ; \n    static int  arr[] ; \n  static LinkedList l1 = new  LinkedList() ; \nstatic void find(int p ,char[]x,int put[],String s){\n    int c= 0 ; \n    for (int i = 0; i < s.length(); i++) {\n        if(x[p]==s.charAt(i)){\n        c++ ; }\n    }\n    put[p] = c ;  \n}\nstatic int mode(int m ,int[]x ){\n    int temp = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return m-temp ; \n             \n        }\n    }\n     return m-temp ; \n}\nstatic int mode2(int m ,int[]x ){\n    int temp = 0 ; \n    \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return x[i] ; \n             \n        }\n    }\n     return 0 ; \n}\nstatic int find(int x[],int temp){\n    int j = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]==temp) return j+1 ; \n        j++ ; \n    }\n    return -1 ; \n}\nstatic String ch(long[]x,long b){\n    for (int i = 0; i < x.length; i++) {\n        if(x[i]==b)return \"YES\" ;\n    }\n    return \"NO\" ; \n}\n\n    public static void main(String[] args)  {\n\n        Scanner in = new Scanner(System.in) ;\n        PrintWriter pw = new PrintWriter(System.out);   \n        long n = in.nextLong() ; \n        long count =1 ; \n        long temp =n/2;\n     temp+=count ;\n      \n       \n        System.out.println(temp);\n }               \n}\n\n", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import java.io.*;\n     \n     \n     \n     \n    import java.math.*;\n    import java.util.*;    \n          public class Main1\n           {\n            private InputStream is;\n            private PrintWriter out;\n            static int MOD = (int)(1e9+7);\n            ArrayList<Integer>[] amp;\n            public static void main(String[] args) throws Exception\n            {\n                new Thread(null, new Runnable()\n                {\n                public void run()\n                {\n                    try {\n         } catch (Exception e)\n                    {\n                        System.out.println(e);\n                    }\n                }\n            }, \"1\", 1 << 26).start();\n                new Main1().soln();\n            }\n            char ch[][];\n            static ArrayList<Integer>[] g;\n            static ArrayList<Integer> ar[];\n            static long ok[];    \n            static int phi[]=new int[500005];\n            void solve()\n            {\n            \tint n=ni();\n                int a[]=na(n);\n                long sum=0;\n                HashMap<Integer,Integer> hm=new HashMap();\n                BigInteger ans=(BigInteger.ZERO);\n                int count=0;\n                for(int i=n-1;i>=0;i--)\n                {\n               \t int tmp1=0;\n               \t int tmp2=0;\n               \t int tmp3=0;\n               \t if(hm.containsKey(a[i]))\n               \t\t tmp1=hm.get(a[i]);\n               \t if(hm.containsKey(a[i]+1))\n               \t\t tmp2=hm.get(a[i]+1);\n               \t if(hm.containsKey(a[i]-1))\n               \t\t tmp3=hm.get(a[i]-1);\n               \t long lol=sum;\n               \t lol-=((long)tmp1*(long)a[i]);\n               \t lol-=((long)tmp2*(long)(a[i]+1));\n               \t lol-=((long)tmp3*(long)(a[i]-1));\n               \t int fr=(count)-tmp1-tmp2-tmp3;\n               \t long fuck=(lol)-((long)fr*(long)a[i]);\n               \t ans=ans.add(BigInteger.valueOf(fuck));\n               \t if(!hm.containsKey(a[i]))\n               \t\t hm.put(a[i],1);\n               \t else\n               \t\t hm.put(a[i],hm.get(a[i])+1);\n               \t sum+=(long)a[i];\n               \t count++;\n               \t// System.out.println(ans+\" \"+tmp1+\" \"+tmp2+\" \"+tmp3+\" \"+lol);\n                }\n                out.println(ans);\n            }\n           public static long multiply(long a)\n            {\n            \treturn a*10;\n            }\n            public static long query1(int v,int start,int end,int l,int r,int x)\n            {\n            \tif(r < start || end < l)\n                {\n                    return Long.MAX_VALUE;\n                }\n                if(l <= start && end <= r)\n                {\n                    return (tre[v]);\n                }\n                int mid = (start + end) / 2;\n                long p1 = query1(2*v, start, mid, l, r,x);\n                long p2 = query1(2*v+1, mid+1, end, l, r,x);\n                return Math.min(p1, p2);\t\n            }\n            public static void update1(int v,int tl,int tr,int index,long a2)\n            {\n            \tif(tl==tr)\n                {\n                    tre[v]=a2;\n                }\n                else\n                {\n                    int mid=(tl+tr)/2;\n                    if(tl <= index &&index <= mid)\n                    {\n                        update1(2*v,tl, mid, index, a2);\n                    }\n                    else\n                    {\n                        update1(2*v+1,mid+1,tr, index, a2);\n                    }\n                    tre[v]=(Math.min(tre[2*v],tre[2*v+1]));\n                }\n            }\n\t\t\tstatic boolean visited[][];\n\t\t\tstatic int a[][];\n            public static long query(int v,int start,int end,int l,int r,int x)\n            {\n            \tif(r < start || end < l)\n                {\n                    return 0;\n                }\n                if(l <= start && end <= r)\n                {\n                    return (tre[v]);\n                }\n                int mid = (start + end) / 2;\n                long p1 = query(2*v, start, mid, l, r,x);\n                long p2 = query(2*v+1, mid+1, end, l, r,x);\n                return Math.max(p1, p2);\t\n            }\n            public static void update(int v,int tl,int tr,int index,long a2)\n            {\n            \tif(tl==tr)\n                {\n                    tre[v]=a2;\n                }\n                else\n                {\n                    int mid=(tl+tr)/2;\n                    if(tl <= index &&index <= mid)\n                    {\n                        update(2*v,tl, mid, index, a2);\n                    }\n                    else\n                    {\n                        update(2*v+1,mid+1,tr, index, a2);\n                    }\n                    tre[v]=(Math.max(tre[2*v],tre[2*v+1]));\n                }\n            }\n            static long tre[]=new long[400005];\n          /* public static int find(int v,int start,int end,int l,int r)\n            {\n                if(r < start || end < l)\n                {\n                    return Integer.MIN_VALUE;\n                }\n                if(l <= start && end <= r)\n                {\n                    return (tre[v]);\n                }\n                int mid = (start + end) / 2;\n                int p1 = find(2*v, start, mid, l, r);\n                int p2 = find(2*v+1, mid+1, end, l, r);\n                return Math.max(p1, p2);          \n            }\n            static int tre[]=new int[4000005];\n            public static void Update(int v,int tl,int tr,int index,int val)\n            {\n                if(tl==tr)\n                {\n                    tre[v]=val;\n                }\n                else\n                {\n                    int mid=(tl+tr)/2;\n                    if(tl <= index &&index <= mid)\n                    {\n                        Update(2*v,tl, mid, index, val);\n                    }\n                    else\n                    {\n                        Update(2*v+1,mid+1,tr, index, val);\n                    }\n                    tre[v]=(Math.max(tre[2*v],tre[2*v+1]));\n                }\n            }\n            */\n            boolean isPrime(int x)\n                {\n                if(x==0||x==1)\n                    return false;\n                for(int i = 2;i*1L*i<=x;i++) if(x%i==0) return false;\n                return true;\n            }\n            int  p ;\n            long modInverse(long a, long mOD2){\n                return  power(a, mOD2-2, mOD2);\n            }\n            long power(long x, long y, long m)\n            {\n            if (y == 0)\n            return 1;\n            long p = power(x, y/2, m) % m;\n            p = (p * p) % m;\n        \n            return (y%2 == 0)? p : (x * p) % m;\n            }\n            public static long gcd(long a, long b){\n                if(b==0) return a;\n                return gcd(b,a%b);\n            }\n            class Pair1 implements Comparable<Pair1>{\n                long a;\n                long b;\n                long c;\n                Pair1(long x,long y,long z){\n                this.a=x;\n                this.b=y;\n                this.c=z;\n                }\n                public int hashCode() {\n                    return Objects.hash();\n                }\n                \n                @Override\n                public int compareTo(Pair1 arg0) {\n                    return (int)(arg0.c-c);\n                }    \n            }\n            long power(long x, long y, int mod){\n                long ans = 1;\n                while(y>0){\n                    if(y%2==0){\n                        x = (x*x)%mod;\n                        y/=2;\n                    }\n                    else{\n                        ans = (x*ans)%mod;\n                        y--;\n                    }\n                }\n                return ans;\n            }\n            void soln() {\n                is = System.in;\n                out = new PrintWriter(System.out);\n                long s = System.currentTimeMillis();\n                solve();\n                out.flush();\n            }\n             private byte[] inbuf = new byte[1024];\n            public int lenbuf = 0, ptrbuf = 0;\n            private int readByte() {\n                if (lenbuf == -1)\n                    throw new InputMismatchException();\n                if (ptrbuf >= lenbuf) {\n                    ptrbuf = 0;\n                    try {\n                        lenbuf = is.read(inbuf);\n                    } catch (IOException e) {\n                        throw new InputMismatchException();\n                    }\n                    if (lenbuf <= 0)\n                        return -1;\n                }\n                return inbuf[ptrbuf++];\n            }\n            private boolean isSpaceChar(int c) {\n                return !(c >= 33 && c <= 126);\n            }\n            private int skip() {\n                int b;\n                while ((b = readByte()) != -1 && isSpaceChar(b))\n                    ;\n                return b;\n            }\n            private double nd() {\n                return Double.parseDouble(ns());\n            }\n            private char nc() {\n                return (char) skip();\n            }\n            private String ns() {\n                int b = skip();\n                StringBuilder sb = new StringBuilder();\n                while (!(isSpaceChar(b))) {\n                    sb.appendCodePoint(b);\n                    b = readByte();\n                }\n                return sb.toString();\n            }\n            private char[] ns(int n) {\n                char[] buf = new char[n];\n                int b = skip(), p = 0;\n                while (p < n && !(isSpaceChar(b))) {\n                    buf[p++] = (char) b;\n                    b = readByte();\n                }\n                return n == p ? buf : Arrays.copyOf(buf, p);\n            }\n            private int[][] nm(int n, int m) {\n                int[][] map = new int[n][m];\n                for (int i = 0; i < n; i++)\n                {\n                    for(int j=0;j<m;j++)\n                        map[i][j]=ni();\n                }\n                return map;\n            }\n            private int[] na(int n) {\n                int[] a = new int[n];\n                for (int i = 0; i < n; i++)\n                    a[i] = ni();\n                return a;\n            }\n            private int ni() {\n                int num = 0, b;\n                boolean minus = false;\n                while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n                    ;\n                if (b == '-') {\n                    minus = true;\n                    b = readByte();\n                }\n                while (true) {\n                    if (b >= '0' && b <= '9') {\n                        num = num * 10 + (b - '0');\n                    } else {\n                        return minus ? -num : num;\n                    }\n                    b = readByte();\n                }\n            }\n            private long nl() {\n                long num = 0;\n                int b;\n                boolean minus = false;\n                while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n                    ;\n                if (b == '-') {\n                    minus = true;\n                    b = readByte();\n                }\n                while (true) {\n                    if (b >= '0' && b <= '9') {\n                        num = num * 10 + (b - '0');\n                    } else {\n                        return minus ? -num : num;\n                    }\n                    b = readByte();\n                }\n            }\n            private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n            private void tr(Object... o) {\n                if (!oj)\n                    System.out.println(Arrays.deepToString(o));\n            }\n        }  ", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\npublic class C_455\n{\n\tpublic static final long[] POWER2 = generatePOWER2();\n\tpublic static final IteratorBuffer<Long> ITERATOR_BUFFER_PRIME = new IteratorBuffer<>(streamPrime(1000000).iterator());\n\tprivate static BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer stringTokenizer = null;\n\tprivate static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n\tstatic class Array<Type> implements Iterable<Type>\n\t{\n\t\tprivate final Object[] array;\n\n\t\tpublic Array(int size)\n\t\t{\n\t\t\tthis.array = new Object[size];\n\t\t}\n\n\t\tpublic Array(int size, Type element)\n\t\t{\n\t\t\tthis(size);\n\t\t\tArrays.fill(this.array, element);\n\t\t}\n\n\t\tpublic Array(Array<Type> array, Type element)\n\t\t{\n\t\t\tthis(array.size() + 1);\n\t\t\tfor (int index = 0; index < array.size(); index++)\n\t\t\t{\n\t\t\t\tset(index, array.get(index));\n\t\t\t}\n\t\t\tset(size() - 1, element);\n\t\t}\n\n\t\tpublic Array(List<Type> list)\n\t\t{\n\t\t\tthis(list.size());\n\t\t\tint index = 0;\n\t\t\tfor (Type element : list)\n\t\t\t{\n\t\t\t\tset(index, element);\n\t\t\t\tindex += 1;\n\t\t\t}\n\t\t}\n\n\t\tpublic Type get(int index)\n\t\t{\n\t\t\treturn (Type) this.array[index];\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Type> iterator()\n\t\t{\n\t\t\treturn new Iterator<Type>()\n\t\t\t{\n\t\t\t\tint index = 0;\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext()\n\t\t\t\t{\n\t\t\t\t\treturn this.index < size();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Type next()\n\t\t\t\t{\n\t\t\t\t\tType result = Array.this.get(index);\n\t\t\t\t\tindex += 1;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tpublic Array set(int index, Type value)\n\t\t{\n\t\t\tthis.array[index] = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int size()\n\t\t{\n\t\t\treturn this.array.length;\n\t\t}\n\n\t\tpublic List<Type> toList()\n\t\t{\n\t\t\tList<Type> result = new ArrayList<>();\n\t\t\tfor (Type element : this)\n\t\t\t{\n\t\t\t\tresult.add(element);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \"[\" + C_455.toString(this, \", \") + \"]\";\n\t\t}\n\t}\n\n\tstatic class BIT\n\t{\n\t\tprivate static int lastBit(int index)\n\t\t{\n\t\t\treturn index & -index;\n\t\t}\n\n\t\tprivate final long[] tree;\n\n\t\tpublic BIT(int size)\n\t\t{\n\t\t\tthis.tree = new long[size];\n\t\t}\n\n\t\tpublic void add(int index, long delta)\n\t\t{\n\t\t\tindex += 1;\n\t\t\twhile (index <= this.tree.length)\n\t\t\t{\n\t\t\t\ttree[index - 1] += delta;\n\t\t\t\tindex += lastBit(index);\n\t\t\t}\n\t\t}\n\n\t\tpublic long prefix(int end)\n\t\t{\n\t\t\tlong result = 0;\n\t\t\twhile (end > 0)\n\t\t\t{\n\t\t\t\tresult += this.tree[end - 1];\n\t\t\t\tend -= lastBit(end);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic int size()\n\t\t{\n\t\t\treturn this.tree.length;\n\t\t}\n\n\t\tpublic long sum(int start, int end)\n\t\t{\n\t\t\treturn prefix(end) - prefix(start);\n\t\t}\n\t}\n\n\tstatic abstract class Edge<TypeVertex extends Vertex<TypeVertex, TypeEdge>, TypeEdge extends Edge<TypeVertex, TypeEdge>>\n\t{\n\t\tpublic final TypeVertex vertex0;\n\t\tpublic final TypeVertex vertex1;\n\t\tpublic final boolean bidirectional;\n\n\t\tpublic Edge(TypeVertex vertex0, TypeVertex vertex1, boolean bidirectional)\n\t\t{\n\t\t\tthis.vertex0 = vertex0;\n\t\t\tthis.vertex1 = vertex1;\n\t\t\tthis.bidirectional = bidirectional;\n\t\t\tthis.vertex0.edges.add(getThis());\n\t\t\tif (this.bidirectional)\n\t\t\t{\n\t\t\t\tthis.vertex1.edges.add(getThis());\n\t\t\t}\n\t\t}\n\n\t\tpublic abstract TypeEdge getThis();\n\n\t\tpublic TypeVertex other(Vertex<TypeVertex, TypeEdge> vertex)\n\t\t{\n\t\t\tTypeVertex result;\n\t\t\tif (vertex0 == vertex)\n\t\t\t{\n\t\t\t\tresult = vertex1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = vertex0;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic void remove()\n\t\t{\n\t\t\tthis.vertex0.edges.remove(getThis());\n\t\t\tif (this.bidirectional)\n\t\t\t{\n\t\t\t\tthis.vertex1.edges.remove(getThis());\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn this.vertex0 + \"->\" + this.vertex1;\n\t\t}\n\t}\n\n\tpublic static class EdgeDefault<TypeVertex extends Vertex<TypeVertex, EdgeDefault<TypeVertex>>> extends Edge<TypeVertex, EdgeDefault<TypeVertex>>\n\t{\n\t\tpublic EdgeDefault(TypeVertex vertex0, TypeVertex vertex1, boolean bidirectional)\n\t\t{\n\t\t\tsuper(vertex0, vertex1, bidirectional);\n\t\t}\n\n\t\t@Override\n\t\tpublic EdgeDefault<TypeVertex> getThis()\n\t\t{\n\t\t\treturn this;\n\t\t}\n\t}\n\n\tpublic static class EdgeDefaultDefault extends Edge<VertexDefaultDefault, EdgeDefaultDefault>\n\t{\n\t\tpublic EdgeDefaultDefault(VertexDefaultDefault vertex0, VertexDefaultDefault vertex1, boolean bidirectional)\n\t\t{\n\t\t\tsuper(vertex0, vertex1, bidirectional);\n\t\t}\n\n\t\t@Override\n\t\tpublic EdgeDefaultDefault getThis()\n\t\t{\n\t\t\treturn this;\n\t\t}\n\t}\n\n\tpublic static class FIFO<Type>\n\t{\n\t\tpublic SingleLinkedList<Type> start;\n\t\tpublic SingleLinkedList<Type> end;\n\n\t\tpublic FIFO()\n\t\t{\n\t\t\tthis.start = null;\n\t\t\tthis.end = null;\n\t\t}\n\n\t\tpublic boolean isEmpty()\n\t\t{\n\t\t\treturn this.start == null;\n\t\t}\n\n\t\tpublic Type peek()\n\t\t{\n\t\t\treturn this.start.element;\n\t\t}\n\n\t\tpublic Type pop()\n\t\t{\n\t\t\tType result = this.start.element;\n\t\t\tthis.start = this.start.next;\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic void push(Type element)\n\t\t{\n\t\t\tSingleLinkedList<Type> list = new SingleLinkedList<>(element, null);\n\t\t\tif (this.start == null)\n\t\t\t{\n\t\t\t\tthis.start = list;\n\t\t\t\tthis.end = list;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.end.next = list;\n\t\t\t\tthis.end = list;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Fraction implements Comparable<Fraction>\n\t{\n\t\tpublic static final Fraction ZERO = new Fraction(0, 1);\n\n\t\tpublic static Fraction fraction(long whole)\n\t\t{\n\t\t\treturn fraction(whole, 1);\n\t\t}\n\n\t\tpublic static Fraction fraction(long numerator, long denominator)\n\t\t{\n\t\t\tFraction result;\n\t\t\tif (denominator == 0)\n\t\t\t{\n\t\t\t\tthrow new ArithmeticException();\n\t\t\t}\n\t\t\tif (numerator == 0)\n\t\t\t{\n\t\t\t\tresult = Fraction.ZERO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint sign;\n\t\t\t\tif (numerator < 0 ^ denominator < 0)\n\t\t\t\t{\n\t\t\t\t\tsign = -1;\n\t\t\t\t\tnumerator = Math.abs(numerator);\n\t\t\t\t\tdenominator = Math.abs(denominator);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsign = 1;\n\t\t\t\t}\n\t\t\t\tlong gcd = gcd(numerator, denominator);\n\t\t\t\tresult = new Fraction(sign * numerator / gcd, denominator / gcd);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic final long numerator;\n\t\tpublic final long denominator;\n\n\t\tprivate Fraction(long numerator, long denominator)\n\t\t{\n\t\t\tthis.numerator = numerator;\n\t\t\tthis.denominator = denominator;\n\t\t}\n\n\t\tpublic Fraction add(Fraction fraction)\n\t\t{\n\t\t\treturn fraction(this.numerator * fraction.denominator + fraction.numerator * this.denominator, this.denominator * fraction.denominator);\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Fraction that)\n\t\t{\n\t\t\treturn Long.compare(this.numerator * that.denominator, that.numerator * this.denominator);\n\t\t}\n\n\t\tpublic Fraction divide(Fraction fraction)\n\t\t{\n\t\t\treturn multiply(fraction.inverse());\n\t\t}\n\n\t\tpublic boolean equals(Fraction that)\n\t\t{\n\t\t\treturn this.compareTo(that) == 0;\n\t\t}\n\n\t\tpublic boolean equals(Object that)\n\t\t{\n\t\t\treturn this.compareTo((Fraction) that) == 0;\n\t\t}\n\n\t\tpublic Fraction getRemainder()\n\t\t{\n\t\t\treturn fraction(this.numerator - getWholePart() * denominator, denominator);\n\t\t}\n\n\t\tpublic long getWholePart()\n\t\t{\n\t\t\treturn this.numerator / this.denominator;\n\t\t}\n\n\t\tpublic Fraction inverse()\n\t\t{\n\t\t\treturn fraction(this.denominator, this.numerator);\n\t\t}\n\n\t\tpublic Fraction multiply(Fraction fraction)\n\t\t{\n\t\t\treturn fraction(this.numerator * fraction.numerator, this.denominator * fraction.denominator);\n\t\t}\n\n\t\tpublic Fraction neg()\n\t\t{\n\t\t\treturn fraction(-this.numerator, this.denominator);\n\t\t}\n\n\t\tpublic Fraction sub(Fraction fraction)\n\t\t{\n\t\t\treturn add(fraction.neg());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\tString result;\n\t\t\tif (getRemainder().equals(Fraction.ZERO))\n\t\t\t{\n\t\t\t\tresult = \"\" + this.numerator;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = this.numerator + \"/\" + this.denominator;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic class IteratorBuffer<Type>\n\t{\n\t\tprivate Iterator<Type> iterator;\n\t\tprivate List<Type> list;\n\n\t\tpublic IteratorBuffer(Iterator<Type> iterator)\n\t\t{\n\t\t\tthis.iterator = iterator;\n\t\t\tthis.list = new ArrayList<Type>();\n\t\t}\n\n\t\tpublic Iterator<Type> iterator()\n\t\t{\n\t\t\treturn new Iterator<Type>()\n\t\t\t{\n\t\t\t\tint index = 0;\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext()\n\t\t\t\t{\n\t\t\t\t\treturn this.index < list.size() || IteratorBuffer.this.iterator.hasNext();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Type next()\n\t\t\t\t{\n\t\t\t\t\tif (list.size() <= this.index)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.add(iterator.next());\n\t\t\t\t\t}\n\t\t\t\t\tType result = list.get(index);\n\t\t\t\t\tindex += 1;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic static class MapCount<Type> extends SortedMapAVL<Type, Long>\n\t{\n\t\tprivate int count;\n\n\t\tpublic MapCount(Comparator<? super Type> comparator)\n\t\t{\n\t\t\tsuper(comparator);\n\t\t\tthis.count = 0;\n\t\t}\n\n\t\tpublic long add(Type key, Long delta)\n\t\t{\n\t\t\tlong result;\n\t\t\tif (delta > 0)\n\t\t\t{\n\t\t\t\tLong value = get(key);\n\t\t\t\tif (value == null)\n\t\t\t\t{\n\t\t\t\t\tvalue = delta;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvalue += delta;\n\t\t\t\t}\n\t\t\t\tput(key, value);\n\t\t\t\tresult = delta;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tthis.count += result;\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic int count()\n\t\t{\n\t\t\treturn this.count;\n\t\t}\n\n\t\tpublic List<Type> flatten()\n\t\t{\n\t\t\tList<Type> result = new ArrayList<>();\n\t\t\tfor (Entry<Type, Long> entry : entrySet())\n\t\t\t{\n\t\t\t\tfor (long index = 0; index < entry.getValue(); index++)\n\t\t\t\t{\n\t\t\t\t\tresult.add(entry.getKey());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<Type, Long> headMap(Type keyEnd)\n\t\t{\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void putAll(Map<? extends Type, ? extends Long> map)\n\t\t{\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tpublic long remove(Type key, Long delta)\n\t\t{\n\t\t\tlong result;\n\t\t\tif (delta > 0)\n\t\t\t{\n\t\t\t\tLong value = get(key) - delta;\n\t\t\t\tif (value <= 0)\n\t\t\t\t{\n\t\t\t\t\tresult = delta + value;\n\t\t\t\t\tremove(key);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult = delta;\n\t\t\t\t\tput(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tthis.count -= result;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic Long remove(Object key)\n\t\t{\n\t\t\tLong result = super.remove(key);\n\t\t\tthis.count -= result;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<Type, Long> subMap(Type keyStart, Type keyEnd)\n\t\t{\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<Type, Long> tailMap(Type keyStart)\n\t\t{\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\tpublic static class MapSet<TypeKey, TypeValue> extends SortedMapAVL<TypeKey, SortedSetAVL<TypeValue>> implements Iterable<TypeValue>\n\t{\n\t\tprivate Comparator<? super TypeValue> comparatorValue;\n\n\t\tpublic MapSet(Comparator<? super TypeKey> comparatorKey, Comparator<? super TypeValue> comparatorValue)\n\t\t{\n\t\t\tsuper(comparatorKey);\n\t\t\tthis.comparatorValue = comparatorValue;\n\t\t}\n\n\t\tpublic MapSet(Comparator<? super TypeKey> comparatorKey, SortedSetAVL<Entry<TypeKey, SortedSetAVL<TypeValue>>> entrySet, Comparator<? super TypeValue> comparatorValue)\n\t\t{\n\t\t\tsuper(comparatorKey, entrySet);\n\t\t\tthis.comparatorValue = comparatorValue;\n\t\t}\n\n\t\tpublic boolean add(TypeKey key, TypeValue value)\n\t\t{\n\t\t\tSortedSetAVL<TypeValue> set = computeIfAbsent(key, k -> new SortedSetAVL<>(comparatorValue));\n\t\t\treturn set.add(value);\n\t\t}\n\n\t\tpublic TypeValue firstValue()\n\t\t{\n\t\t\tTypeValue result;\n\t\t\tEntry<TypeKey, SortedSetAVL<TypeValue>> firstEntry = firstEntry();\n\t\t\tif (firstEntry == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = firstEntry.getValue().first();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic MapSet<TypeKey, TypeValue> headMap(TypeKey keyEnd)\n\t\t{\n\t\t\treturn new MapSet<>(this.comparator, this.entrySet.headSet(new AbstractMap.SimpleEntry<>(keyEnd, null)), this.comparatorValue);\n\t\t}\n\n\t\tpublic Iterator<TypeValue> iterator()\n\t\t{\n\t\t\treturn new Iterator<TypeValue>()\n\t\t\t{\n\t\t\t\tIterator<SortedSetAVL<TypeValue>> iteratorValues = values().iterator();\n\t\t\t\tIterator<TypeValue> iteratorValue = null;\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext()\n\t\t\t\t{\n\t\t\t\t\treturn iteratorValues.hasNext() || (iteratorValue != null && iteratorValue.hasNext());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic TypeValue next()\n\t\t\t\t{\n\t\t\t\t\tif (iteratorValue == null || !iteratorValue.hasNext())\n\t\t\t\t\t{\n\t\t\t\t\t\titeratorValue = iteratorValues.next().iterator();\n\t\t\t\t\t}\n\t\t\t\t\treturn iteratorValue.next();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tpublic TypeValue lastValue()\n\t\t{\n\t\t\tTypeValue result;\n\t\t\tEntry<TypeKey, SortedSetAVL<TypeValue>> lastEntry = lastEntry();\n\t\t\tif (lastEntry == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = lastEntry.getValue().last();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic boolean removeSet(TypeKey key, TypeValue value)\n\t\t{\n\t\t\tboolean result;\n\t\t\tSortedSetAVL<TypeValue> set = get(key);\n\t\t\tif (set == null)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = set.remove(value);\n\t\t\t\tif (set.size() == 0)\n\t\t\t\t{\n\t\t\t\t\tremove(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic MapSet<TypeKey, TypeValue> tailMap(TypeKey keyStart)\n\t\t{\n\t\t\treturn new MapSet<>(this.comparator, this.entrySet.tailSet(new AbstractMap.SimpleEntry<>(keyStart, null)), this.comparatorValue);\n\t\t}\n\t}\n\n\tpublic static class Matrix\n\t{\n\t\tpublic final int rows;\n\t\tpublic final int columns;\n\t\tpublic final Fraction[][] cells;\n\n\t\tpublic Matrix(int rows, int columns)\n\t\t{\n\t\t\tthis.rows = rows;\n\t\t\tthis.columns = columns;\n\t\t\tthis.cells = new Fraction[rows][columns];\n\t\t\tfor (int row = 0; row < rows; row++)\n\t\t\t{\n\t\t\t\tfor (int column = 0; column < columns; column++)\n\t\t\t\t{\n\t\t\t\t\tset(row, column, Fraction.ZERO);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void add(int rowSource, int rowTarget, Fraction fraction)\n\t\t{\n\t\t\tfor (int column = 0; column < columns; column++)\n\t\t\t{\n\t\t\t\tthis.cells[rowTarget][column] = this.cells[rowTarget][column].add(this.cells[rowSource][column].multiply(fraction));\n\t\t\t}\n\t\t}\n\n\t\tprivate int columnPivot(int row)\n\t\t{\n\t\t\tint result = this.columns;\n\t\t\tfor (int column = this.columns - 1; 0 <= column; column--)\n\t\t\t{\n\t\t\t\tif (this.cells[row][column].compareTo(Fraction.ZERO) != 0)\n\t\t\t\t{\n\t\t\t\t\tresult = column;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic void reduce()\n\t\t{\n\t\t\tfor (int rowMinimum = 0; rowMinimum < this.rows; rowMinimum++)\n\t\t\t{\n\t\t\t\tint rowPivot = rowPivot(rowMinimum);\n\t\t\t\tif (rowPivot != -1)\n\t\t\t\t{\n\t\t\t\t\tint columnPivot = columnPivot(rowPivot);\n\t\t\t\t\tFraction current = this.cells[rowMinimum][columnPivot];\n\t\t\t\t\tFraction pivot = this.cells[rowPivot][columnPivot];\n\t\t\t\t\tFraction fraction = pivot.inverse().sub(current.divide(pivot));\n\t\t\t\t\tadd(rowPivot, rowMinimum, fraction);\n\t\t\t\t\tfor (int row = rowMinimum + 1; row < this.rows; row++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (columnPivot(row) == columnPivot)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tadd(rowMinimum, row, this.cells[row][columnPivot(row)].neg());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate int rowPivot(int rowMinimum)\n\t\t{\n\t\t\tint result = -1;\n\t\t\tint pivotColumnMinimum = this.columns;\n\t\t\tfor (int row = rowMinimum; row < this.rows; row++)\n\t\t\t{\n\t\t\t\tint pivotColumn = columnPivot(row);\n\t\t\t\tif (pivotColumn < pivotColumnMinimum)\n\t\t\t\t{\n\t\t\t\t\tresult = row;\n\t\t\t\t\tpivotColumnMinimum = pivotColumn;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic void set(int row, int column, Fraction value)\n\t\t{\n\t\t\tthis.cells[row][column] = value;\n\t\t}\n\n\t\tpublic String toString()\n\t\t{\n\t\t\tString result = \"\";\n\t\t\tfor (int row = 0; row < rows; row++)\n\t\t\t{\n\t\t\t\tfor (int column = 0; column < columns; column++)\n\t\t\t\t{\n\t\t\t\t\tresult += this.cells[row][column] + \"\\t\";\n\t\t\t\t}\n\t\t\t\tresult += \"\\n\";\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tpublic static class Node<Type>\n\t{\n\t\tpublic static <Type> Node<Type> balance(Node<Type> result)\n\t\t{\n\t\t\twhile (result != null && 1 < Math.abs(height(result.left) - height(result.right)))\n\t\t\t{\n\t\t\t\tif (height(result.left) < height(result.right))\n\t\t\t\t{\n\t\t\t\t\tNode<Type> right = result.right;\n\t\t\t\t\tif (height(right.right) < height(right.left))\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(result.value, result.left, right.rotateRight());\n\t\t\t\t\t}\n\t\t\t\t\tresult = result.rotateLeft();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNode<Type> left = result.left;\n\t\t\t\t\tif (height(left.left) < height(left.right))\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(result.value, left.rotateLeft(), result.right);\n\t\t\t\t\t}\n\t\t\t\t\tresult = result.rotateRight();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> clone(Node<Type> result)\n\t\t{\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\tresult = new Node<>(result.value, clone(result.left), clone(result.right));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> delete(Node<Type> node, Type value, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tNode<Type> result;\n\t\t\tif (node == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint compare = comparator.compare(value, node.value);\n\t\t\t\tif (compare == 0)\n\t\t\t\t{\n\t\t\t\t\tif (node.left == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = node.right;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (node.right == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = node.left;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNode<Type> first = first(node.right);\n\t\t\t\t\t\t\tresult = new Node<>(first.value, node.left, delete(node.right, first.value, comparator));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (compare < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, delete(node.left, value, comparator), node.right);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, node.left, delete(node.right, value, comparator));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = balance(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> first(Node<Type> result)\n\t\t{\n\t\t\twhile (result.left != null)\n\t\t\t{\n\t\t\t\tresult = result.left;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> get(Node<Type> node, Type value, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tNode<Type> result;\n\t\t\tif (node == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint compare = comparator.compare(value, node.value);\n\t\t\t\tif (compare == 0)\n\t\t\t\t{\n\t\t\t\t\tresult = node;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (compare < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = get(node.left, value, comparator);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = get(node.right, value, comparator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> head(Node<Type> node, Type value, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tNode<Type> result;\n\t\t\tif (node == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint compare = comparator.compare(value, node.value);\n\t\t\t\tif (compare == 0)\n\t\t\t\t{\n\t\t\t\t\tresult = node.left;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (compare < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = head(node.left, value, comparator);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, node.left, head(node.right, value, comparator));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = balance(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static int height(Node node)\n\t\t{\n\t\t\treturn node == null ? 0 : node.height;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> insert(Node<Type> node, Type value, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tNode<Type> result;\n\t\t\tif (node == null)\n\t\t\t{\n\t\t\t\tresult = new Node<>(value, null, null);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint compare = comparator.compare(value, node.value);\n\t\t\t\tif (compare == 0)\n\t\t\t\t{\n\t\t\t\t\tresult = new Node<>(value, node.left, node.right);\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (compare < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, insert(node.left, value, comparator), node.right);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, node.left, insert(node.right, value, comparator));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = balance(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> last(Node<Type> result)\n\t\t{\n\t\t\twhile (result.right != null)\n\t\t\t{\n\t\t\t\tresult = result.right;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static int size(Node node)\n\t\t{\n\t\t\treturn node == null ? 0 : node.size;\n\t\t}\n\n\t\tpublic static <Type> Node<Type> tail(Node<Type> node, Type value, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tNode<Type> result;\n\t\t\tif (node == null)\n\t\t\t{\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint compare = comparator.compare(value, node.value);\n\t\t\t\tif (compare == 0)\n\t\t\t\t{\n\t\t\t\t\tresult = new Node<>(node.value, null, node.right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (compare < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = new Node<>(node.value, tail(node.left, value, comparator), node.right);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = tail(node.right, value, comparator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = balance(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <Type> void traverseOrderIn(Node<Type> node, Consumer<Type> consumer)\n\t\t{\n\t\t\tif (node != null)\n\t\t\t{\n\t\t\t\ttraverseOrderIn(node.left, consumer);\n\t\t\t\tconsumer.accept(node.value);\n\t\t\t\ttraverseOrderIn(node.right, consumer);\n\t\t\t}\n\t\t}\n\n\t\tpublic final Type value;\n\t\tpublic final Node<Type> left;\n\t\tpublic final Node<Type> right;\n\t\tpublic final int size;\n\t\tprivate final int height;\n\n\t\tpublic Node(Type value, Node<Type> left, Node<Type> right)\n\t\t{\n\t\t\tthis.value = value;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.size = 1 + size(left) + size(right);\n\t\t\tthis.height = 1 + Math.max(height(left), height(right));\n\t\t}\n\n\t\tpublic Node<Type> rotateLeft()\n\t\t{\n\t\t\tNode<Type> left = new Node<>(this.value, this.left, this.right.left);\n\t\t\treturn new Node<>(this.right.value, left, this.right.right);\n\t\t}\n\n\t\tpublic Node<Type> rotateRight()\n\t\t{\n\t\t\tNode<Type> right = new Node<>(this.value, this.left.right, this.right);\n\t\t\treturn new Node<>(this.left.value, this.left.left, right);\n\t\t}\n\t}\n\n\tpublic static class SingleLinkedList<Type>\n\t{\n\t\tpublic final Type element;\n\t\tpublic SingleLinkedList<Type> next;\n\n\t\tpublic SingleLinkedList(Type element, SingleLinkedList<Type> next)\n\t\t{\n\t\t\tthis.element = element;\n\t\t\tthis.next = next;\n\t\t}\n\n\t\tpublic void toCollection(Collection<Type> collection)\n\t\t{\n\t\t\tif (this.next != null)\n\t\t\t{\n\t\t\t\tthis.next.toCollection(collection);\n\t\t\t}\n\t\t\tcollection.add(this.element);\n\t\t}\n\t}\n\n\tpublic static class SmallSetIntegers\n\t{\n\t\tpublic static final int SIZE = 20;\n\t\tpublic static final int[] SET = generateSet();\n\t\tpublic static final int[] COUNT = generateCount();\n\t\tpublic static final int[] INTEGER = generateInteger();\n\n\t\tprivate static int count(int set)\n\t\t{\n\t\t\tint result = 0;\n\t\t\tfor (int integer = 0; integer < SIZE; integer++)\n\t\t\t{\n\t\t\t\tif (0 < (set & set(integer)))\n\t\t\t\t{\n\t\t\t\t\tresult += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static final int[] generateCount()\n\t\t{\n\t\t\tint[] result = new int[1 << SIZE];\n\t\t\tfor (int set = 0; set < result.length; set++)\n\t\t\t{\n\t\t\t\tresult[set] = count(set);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static final int[] generateInteger()\n\t\t{\n\t\t\tint[] result = new int[1 << SIZE];\n\t\t\tArrays.fill(result, -1);\n\t\t\tfor (int integer = 0; integer < SIZE; integer++)\n\t\t\t{\n\t\t\t\tresult[SET[integer]] = integer;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static final int[] generateSet()\n\t\t{\n\t\t\tint[] result = new int[SIZE];\n\t\t\tfor (int integer = 0; integer < result.length; integer++)\n\t\t\t{\n\t\t\t\tresult[integer] = set(integer);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static int set(int integer)\n\t\t{\n\t\t\treturn 1 << integer;\n\t\t}\n\t}\n\n\tpublic static class SortedMapAVL<TypeKey, TypeValue> implements SortedMap<TypeKey, TypeValue>\n\t{\n\t\tpublic final Comparator<? super TypeKey> comparator;\n\t\tpublic final SortedSetAVL<Entry<TypeKey, TypeValue>> entrySet;\n\n\t\tpublic SortedMapAVL(Comparator<? super TypeKey> comparator)\n\t\t{\n\t\t\tthis(comparator, new SortedSetAVL<>((entry0, entry1) -> comparator.compare(entry0.getKey(), entry1.getKey())));\n\t\t}\n\n\t\tprivate SortedMapAVL(Comparator<? super TypeKey> comparator, SortedSetAVL<Entry<TypeKey, TypeValue>> entrySet)\n\t\t{\n\t\t\tthis.comparator = comparator;\n\t\t\tthis.entrySet = entrySet;\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear()\n\t\t{\n\t\t\tthis.entrySet.clear();\n\t\t}\n\n\t\t@Override\n\t\tpublic Comparator<? super TypeKey> comparator()\n\t\t{\n\t\t\treturn this.comparator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsKey(Object key)\n\t\t{\n\t\t\treturn this.entrySet().contains(new AbstractMap.SimpleEntry<>((TypeKey) key, null));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsValue(Object value)\n\t\t{\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedSetAVL<Entry<TypeKey, TypeValue>> entrySet()\n\t\t{\n\t\t\treturn this.entrySet;\n\t\t}\n\n\t\tpublic Entry<TypeKey, TypeValue> firstEntry()\n\t\t{\n\t\t\treturn this.entrySet.first();\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeKey firstKey()\n\t\t{\n\t\t\treturn firstEntry().getKey();\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeValue get(Object key)\n\t\t{\n\t\t\tEntry<TypeKey, TypeValue> entry = new AbstractMap.SimpleEntry<>((TypeKey) key, null);\n\t\t\tentry = this.entrySet.get(entry);\n\t\t\treturn entry == null ? null : entry.getValue();\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<TypeKey, TypeValue> headMap(TypeKey keyEnd)\n\t\t{\n\t\t\treturn new SortedMapAVL<>(this.comparator, this.entrySet.headSet(new AbstractMap.SimpleEntry<>(keyEnd, null)));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty()\n\t\t{\n\t\t\treturn this.entrySet.isEmpty();\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<TypeKey> keySet()\n\t\t{\n\t\t\treturn new SortedSet<TypeKey>()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic boolean add(TypeKey typeKey)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean addAll(Collection<? extends TypeKey> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void clear()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Comparator<? super TypeKey> comparator()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean contains(Object o)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean containsAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic TypeKey first()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic SortedSet<TypeKey> headSet(TypeKey typeKey)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isEmpty()\n\t\t\t\t{\n\t\t\t\t\treturn size() == 0;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Iterator<TypeKey> iterator()\n\t\t\t\t{\n\t\t\t\t\tfinal Iterator<Entry<TypeKey, TypeValue>> iterator = SortedMapAVL.this.entrySet.iterator();\n\t\t\t\t\treturn new Iterator<TypeKey>()\n\t\t\t\t\t{\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean hasNext()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn iterator.hasNext();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic TypeKey next()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn iterator.next().getKey();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic TypeKey last()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean remove(Object o)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean removeAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean retainAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int size()\n\t\t\t\t{\n\t\t\t\t\treturn SortedMapAVL.this.entrySet.size();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic SortedSet<TypeKey> subSet(TypeKey typeKey, TypeKey e1)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic SortedSet<TypeKey> tailSet(TypeKey typeKey)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object[] toArray()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic <T> T[] toArray(T[] ts)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tpublic Entry<TypeKey, TypeValue> lastEntry()\n\t\t{\n\t\t\treturn this.entrySet.last();\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeKey lastKey()\n\t\t{\n\t\t\treturn lastEntry().getKey();\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeValue put(TypeKey key, TypeValue value)\n\t\t{\n\t\t\tTypeValue result = get(key);\n\t\t\tEntry<TypeKey, TypeValue> entry = new AbstractMap.SimpleEntry<>(key, value);\n\t\t\tthis.entrySet().add(entry);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic void putAll(Map<? extends TypeKey, ? extends TypeValue> map)\n\t\t{\n\t\t\tmap.entrySet()\n\t\t\t\t\t.forEach(entry -> put(entry.getKey(), entry.getValue()));\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeValue remove(Object key)\n\t\t{\n\t\t\tTypeValue result = get(key);\n\t\t\tEntry<TypeKey, TypeValue> entry = new AbstractMap.SimpleEntry<>((TypeKey) key, null);\n\t\t\tthis.entrySet.remove(entry);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size()\n\t\t{\n\t\t\treturn this.entrySet().size();\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<TypeKey, TypeValue> subMap(TypeKey keyStart, TypeKey keyEnd)\n\t\t{\n\t\t\treturn new SortedMapAVL<>(this.comparator, this.entrySet.subSet(new AbstractMap.SimpleEntry<>(keyStart, null), new AbstractMap.SimpleEntry<>(keyEnd, null)));\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedMapAVL<TypeKey, TypeValue> tailMap(TypeKey keyStart)\n\t\t{\n\t\t\treturn new SortedMapAVL<>(this.comparator, this.entrySet.tailSet(new AbstractMap.SimpleEntry<>(keyStart, null)));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn this.entrySet().toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic Collection<TypeValue> values()\n\t\t{\n\t\t\treturn new Collection<TypeValue>()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic boolean add(TypeValue typeValue)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean addAll(Collection<? extends TypeValue> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void clear()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean contains(Object value)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean containsAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isEmpty()\n\t\t\t\t{\n\t\t\t\t\treturn SortedMapAVL.this.entrySet.isEmpty();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Iterator<TypeValue> iterator()\n\t\t\t\t{\n\t\t\t\t\treturn new Iterator<TypeValue>()\n\t\t\t\t\t{\n\t\t\t\t\t\tIterator<Entry<TypeKey, TypeValue>> iterator = SortedMapAVL.this.entrySet.iterator();\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean hasNext()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.iterator.hasNext();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic TypeValue next()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.iterator.next().getValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean remove(Object o)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean removeAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean retainAll(Collection<?> collection)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int size()\n\t\t\t\t{\n\t\t\t\t\treturn SortedMapAVL.this.entrySet.size();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object[] toArray()\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic <T> T[] toArray(T[] ts)\n\t\t\t\t{\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic static class SortedSetAVL<Type> implements SortedSet<Type>\n\t{\n\t\tpublic Comparator<? super Type> comparator;\n\t\tpublic Node<Type> root;\n\n\t\tprivate SortedSetAVL(Comparator<? super Type> comparator, Node<Type> root)\n\t\t{\n\t\t\tthis.comparator = comparator;\n\t\t\tthis.root = root;\n\t\t}\n\n\t\tpublic SortedSetAVL(Comparator<? super Type> comparator)\n\t\t{\n\t\t\tthis(comparator, null);\n\t\t}\n\n\t\tpublic SortedSetAVL(Collection<? extends Type> collection, Comparator<? super Type> comparator)\n\t\t{\n\t\t\tthis(comparator, null);\n\t\t\tthis.addAll(collection);\n\t\t}\n\n\t\tpublic SortedSetAVL(SortedSetAVL<Type> sortedSetAVL)\n\t\t{\n\t\t\tthis(sortedSetAVL.comparator, Node.clone(sortedSetAVL.root));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(Type value)\n\t\t{\n\t\t\tint sizeBefore = size();\n\t\t\tthis.root = Node.insert(this.root, value, this.comparator);\n\t\t\treturn sizeBefore != size();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends Type> collection)\n\t\t{\n\t\t\treturn collection.stream()\n\t\t\t\t\t.map(this::add)\n\t\t\t\t\t.reduce(true, (x, y) -> x | y);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear()\n\t\t{\n\t\t\tthis.root = null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Comparator<? super Type> comparator()\n\t\t{\n\t\t\treturn this.comparator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object value)\n\t\t{\n\t\t\treturn Node.get(this.root, (Type) value, this.comparator) != null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> collection)\n\t\t{\n\t\t\treturn collection.stream()\n\t\t\t\t\t.allMatch(this::contains);\n\t\t}\n\n\t\t@Override\n\t\tpublic Type first()\n\t\t{\n\t\t\treturn Node.first(this.root).value;\n\t\t}\n\n\t\tpublic Type get(Type value)\n\t\t{\n\t\t\tNode<Type> node = Node.get(this.root, value, this.comparator);\n\t\t\treturn node == null ? null : node.value;\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedSetAVL<Type> headSet(Type valueEnd)\n\t\t{\n\t\t\treturn new SortedSetAVL<>(this.comparator, Node.head(this.root, valueEnd, this.comparator));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty()\n\t\t{\n\t\t\treturn this.root == null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Type> iterator()\n\t\t{\n\t\t\tStack<Node<Type>> path = new Stack<>();\n\t\t\treturn new Iterator<Type>()\n\t\t\t{\n\t\t\t\t{\n\t\t\t\t\tpush(SortedSetAVL.this.root);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext()\n\t\t\t\t{\n\t\t\t\t\treturn !path.isEmpty();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Type next()\n\t\t\t\t{\n\t\t\t\t\tif (path.isEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tNode<Type> node = path.peek();\n\t\t\t\t\t\tType result = node.value;\n\t\t\t\t\t\tif (node.right != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpush(node.right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnode = path.pop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (!path.isEmpty() && path.peek().right == node);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void push(Node<Type> node)\n\t\t\t\t{\n\t\t\t\t\twhile (node != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpath.push(node);\n\t\t\t\t\t\tnode = node.left;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t@Override\n\t\tpublic Type last()\n\t\t{\n\t\t\treturn Node.last(this.root).value;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object value)\n\t\t{\n\t\t\tint sizeBefore = size();\n\t\t\tthis.root = Node.delete(this.root, (Type) value, this.comparator);\n\t\t\treturn sizeBefore != size();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> collection)\n\t\t{\n\t\t\treturn collection.stream()\n\t\t\t\t\t.map(this::remove)\n\t\t\t\t\t.reduce(true, (x, y) -> x | y);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> collection)\n\t\t{\n\t\t\tSortedSetAVL<Type> set = new SortedSetAVL<>(this.comparator);\n\t\t\tcollection.stream()\n\t\t\t\t\t.map(element -> (Type) element)\n\t\t\t\t\t.filter(this::contains)\n\t\t\t\t\t.forEach(set::add);\n\t\t\tboolean result = size() != set.size();\n\t\t\tthis.root = set.root;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size()\n\t\t{\n\t\t\treturn this.root == null ? 0 : this.root.size;\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedSetAVL<Type> subSet(Type valueStart, Type valueEnd)\n\t\t{\n\t\t\treturn tailSet(valueStart).headSet(valueEnd);\n\t\t}\n\n\t\t@Override\n\t\tpublic SortedSetAVL<Type> tailSet(Type valueStart)\n\t\t{\n\t\t\treturn new SortedSetAVL<>(this.comparator, Node.tail(this.root, valueStart, this.comparator));\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray()\n\t\t{\n\t\t\treturn toArray(new Object[0]);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] ts)\n\t\t{\n\t\t\tList<Object> list = new ArrayList<>();\n\t\t\tNode.traverseOrderIn(this.root, list::add);\n\t\t\treturn list.toArray(ts);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \"{\" + C_455.toString(this, \", \") + \"}\";\n\t\t}\n\t}\n\n\tpublic static class Tree2D\n\t{\n\t\tpublic static final int SIZE = 1 << 30;\n\t\tpublic static final Tree2D[] TREES_NULL = new Tree2D[] { null, null, null, null };\n\n\t\tpublic static boolean contains(int x, int y, int left, int bottom, int size)\n\t\t{\n\t\t\treturn left <= x && x < left + size && bottom <= y && y < bottom + size;\n\t\t}\n\n\t\tpublic static int count(Tree2D[] trees)\n\t\t{\n\t\t\tint result = 0;\n\t\t\tfor (int index = 0; index < 4; index++)\n\t\t\t{\n\t\t\t\tif (trees[index] != null)\n\t\t\t\t{\n\t\t\t\t\tresult += trees[index].count;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static int count\n\t\t\t\t(\n\t\t\t\t\t\tint rectangleLeft,\n\t\t\t\t\t\tint rectangleBottom,\n\t\t\t\t\t\tint rectangleRight,\n\t\t\t\t\t\tint rectangleTop,\n\t\t\t\t\t\tTree2D tree,\n\t\t\t\t\t\tint left,\n\t\t\t\t\t\tint bottom,\n\t\t\t\t\t\tint size\n\t\t\t\t)\n\t\t{\n\t\t\tint result;\n\t\t\tif (tree == null)\n\t\t\t{\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint right = left + size;\n\t\t\t\tint top = bottom + size;\n\t\t\t\tint intersectionLeft = Math.max(rectangleLeft, left);\n\t\t\t\tint intersectionBottom = Math.max(rectangleBottom, bottom);\n\t\t\t\tint intersectionRight = Math.min(rectangleRight, right);\n\t\t\t\tint intersectionTop = Math.min(rectangleTop, top);\n\t\t\t\tif (intersectionRight <= intersectionLeft || intersectionTop <= intersectionBottom)\n\t\t\t\t{\n\t\t\t\t\tresult = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (intersectionLeft == left && intersectionBottom == bottom && intersectionRight == right && intersectionTop == top)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = tree.count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsize = size >> 1;\n\t\t\t\t\t\tresult = 0;\n\t\t\t\t\t\tfor (int index = 0; index < 4; index++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult += count\n\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\trectangleLeft,\n\t\t\t\t\t\t\t\t\t\t\trectangleBottom,\n\t\t\t\t\t\t\t\t\t\t\trectangleRight,\n\t\t\t\t\t\t\t\t\t\t\trectangleTop,\n\t\t\t\t\t\t\t\t\t\t\ttree.trees[index],\n\t\t\t\t\t\t\t\t\t\t\tquadrantLeft(left, size, index),\n\t\t\t\t\t\t\t\t\t\t\tquadrantBottom(bottom, size, index),\n\t\t\t\t\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static int quadrantBottom(int bottom, int size, int index)\n\t\t{\n\t\t\treturn bottom + (index >> 1) * size;\n\t\t}\n\n\t\tpublic static int quadrantLeft(int left, int size, int index)\n\t\t{\n\t\t\treturn left + (index & 1) * size;\n\t\t}\n\n\t\tpublic final Tree2D[] trees;\n\t\tpublic final int count;\n\n\t\tprivate Tree2D(Tree2D[] trees, int count)\n\t\t{\n\t\t\tthis.trees = trees;\n\t\t\tthis.count = count;\n\t\t}\n\n\t\tpublic Tree2D(Tree2D[] trees)\n\t\t{\n\t\t\tthis(trees, count(trees));\n\t\t}\n\n\t\tpublic Tree2D()\n\t\t{\n\t\t\tthis(TREES_NULL);\n\t\t}\n\n\t\tpublic int count(int rectangleLeft, int rectangleBottom, int rectangleRight, int rectangleTop)\n\t\t{\n\t\t\treturn count\n\t\t\t\t\t(\n\t\t\t\t\t\t\trectangleLeft,\n\t\t\t\t\t\t\trectangleBottom,\n\t\t\t\t\t\t\trectangleRight,\n\t\t\t\t\t\t\trectangleTop,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tSIZE\n\t\t\t\t\t);\n\t\t}\n\n\t\tpublic Tree2D setPoint\n\t\t\t\t(\n\t\t\t\t\t\tint x,\n\t\t\t\t\t\tint y,\n\t\t\t\t\t\tTree2D tree,\n\t\t\t\t\t\tint left,\n\t\t\t\t\t\tint bottom,\n\t\t\t\t\t\tint size\n\t\t\t\t)\n\t\t{\n\t\t\tTree2D result;\n\t\t\tif (contains(x, y, left, bottom, size))\n\t\t\t{\n\t\t\t\tif (size == 1)\n\t\t\t\t{\n\t\t\t\t\tresult = new Tree2D(TREES_NULL, 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsize = size >> 1;\n\t\t\t\t\tTree2D[] trees = new Tree2D[4];\n\t\t\t\t\tfor (int index = 0; index < 4; index++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttrees[index] = setPoint\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t\t\t\ttree == null ? null : tree.trees[index],\n\t\t\t\t\t\t\t\t\t\tquadrantLeft(left, size, index),\n\t\t\t\t\t\t\t\t\t\tquadrantBottom(bottom, size, index),\n\t\t\t\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult = new Tree2D(trees);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = tree;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic Tree2D setPoint(int x, int y)\n\t\t{\n\t\t\treturn setPoint\n\t\t\t\t\t(\n\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tSIZE\n\t\t\t\t\t);\n\t\t}\n\t}\n\n\tpublic static class Tuple2<Type0, Type1>\n\t{\n\t\tpublic final Type0 v0;\n\t\tpublic final Type1 v1;\n\n\t\tpublic Tuple2(Type0 v0, Type1 v1)\n\t\t{\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \"(\" + this.v0 + \", \" + this.v1 + \")\";\n\t\t}\n\t}\n\n\tpublic static class Tuple2Comparable<Type0 extends Comparable<? super Type0>, Type1 extends Comparable<? super Type1>> extends Tuple2<Type0, Type1> implements Comparable<Tuple2Comparable<Type0, Type1>>\n\t{\n\t\tpublic Tuple2Comparable(Type0 v0, Type1 v1)\n\t\t{\n\t\t\tsuper(v0, v1);\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Tuple2Comparable<Type0, Type1> that)\n\t\t{\n\t\t\tint result = this.v0.compareTo(that.v0);\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = this.v1.compareTo(that.v1);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tpublic static class Tuple3<Type0, Type1, Type2>\n\t{\n\t\tpublic final Type0 v0;\n\t\tpublic final Type1 v1;\n\t\tpublic final Type2 v2;\n\n\t\tpublic Tuple3(Type0 v0, Type1 v1, Type2 v2)\n\t\t{\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \"(\" + this.v0 + \", \" + this.v1 + \", \" + this.v2 + \")\";\n\t\t}\n\t}\n\n\tpublic static class Vertex\n\t\t\t<\n\t\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>\n\t\t\t\t\t>\n\t\t\timplements Comparable<Vertex<? super TypeVertex, ? super TypeEdge>>\n\t{\n\t\tpublic static <\n\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>,\n\t\t\t\tTypeResult\n\t\t\t\t> TypeResult breadthFirstSearch\n\t\t\t\t(\n\t\t\t\t\t\tTypeVertex vertex,\n\t\t\t\t\t\tTypeEdge edge,\n\t\t\t\t\t\tBiFunctionResult<TypeVertex, TypeEdge, TypeResult> function,\n\t\t\t\t\t\tArray<Boolean> visited,\n\t\t\t\t\t\tFIFO<TypeVertex> verticesNext,\n\t\t\t\t\t\tFIFO<TypeEdge> edgesNext,\n\t\t\t\t\t\tTypeResult result\n\t\t\t\t)\n\t\t{\n\t\t\tif (!visited.get(vertex.index))\n\t\t\t{\n\t\t\t\tvisited.set(vertex.index, true);\n\t\t\t\tresult = function.apply(vertex, edge, result);\n\t\t\t\tfor (TypeEdge edgeNext : vertex.edges)\n\t\t\t\t{\n\t\t\t\t\tTypeVertex vertexNext = edgeNext.other(vertex);\n\t\t\t\t\tif (!visited.get(vertexNext.index))\n\t\t\t\t\t{\n\t\t\t\t\t\tverticesNext.push(vertexNext);\n\t\t\t\t\t\tedgesNext.push(edgeNext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <\n\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>,\n\t\t\t\tTypeResult\n\t\t\t\t>\n\t\tTypeResult breadthFirstSearch\n\t\t\t\t(\n\t\t\t\t\t\tArray<TypeVertex> vertices,\n\t\t\t\t\t\tint indexVertexStart,\n\t\t\t\t\t\tBiFunctionResult<TypeVertex, TypeEdge, TypeResult> function,\n\t\t\t\t\t\tTypeResult result\n\t\t\t\t)\n\t\t{\n\t\t\tArray<Boolean> visited = new Array<>(vertices.size(), false);\n\t\t\tFIFO<TypeVertex> verticesNext = new FIFO<>();\n\t\t\tverticesNext.push(vertices.get(indexVertexStart));\n\t\t\tFIFO<TypeEdge> edgesNext = new FIFO<>();\n\t\t\tedgesNext.push(null);\n\t\t\twhile (!verticesNext.isEmpty())\n\t\t\t{\n\t\t\t\tresult = breadthFirstSearch(verticesNext.pop(), edgesNext.pop(), function, visited, verticesNext, edgesNext, result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <\n\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>\n\t\t\t\t>\n\t\tboolean\n\t\tcycle\n\t\t\t\t(\n\t\t\t\t\t\tTypeVertex start,\n\t\t\t\t\t\tSortedSet<TypeVertex> result\n\t\t\t\t)\n\t\t{\n\t\t\tboolean cycle = false;\n\t\t\tStack<TypeVertex> stackVertex = new Stack<>();\n\t\t\tStack<TypeEdge> stackEdge = new Stack<>();\n\t\t\tstackVertex.push(start);\n\t\t\tstackEdge.push(null);\n\t\t\twhile (!stackVertex.isEmpty())\n\t\t\t{\n\t\t\t\tTypeVertex vertex = stackVertex.pop();\n\t\t\t\tTypeEdge edge = stackEdge.pop();\n\t\t\t\tif (!result.contains(vertex))\n\t\t\t\t{\n\t\t\t\t\tresult.add(vertex);\n\t\t\t\t\tfor (TypeEdge otherEdge : vertex.edges)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (otherEdge != edge)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTypeVertex otherVertex = otherEdge.other(vertex);\n\t\t\t\t\t\t\tif (result.contains(otherVertex))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcycle = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstackVertex.push(otherVertex);\n\t\t\t\t\t\t\t\tstackEdge.push(otherEdge);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cycle;\n\t\t}\n\n\t\tpublic static <\n\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>\n\t\t\t\t>\n\t\tSortedSet<TypeVertex>\n\t\tdepthFirstSearch\n\t\t\t\t(\n\t\t\t\t\t\tTypeVertex start,\n\t\t\t\t\t\tBiConsumer<TypeVertex, TypeEdge> functionVisitPre,\n\t\t\t\t\t\tBiConsumer<TypeVertex, TypeEdge> functionVisitPost\n\t\t\t\t)\n\t\t{\n\t\t\tSortedSet<TypeVertex> result = new SortedSetAVL<>(Comparator.naturalOrder());\n\t\t\tStack<TypeVertex> stackVertex = new Stack<>();\n\t\t\tStack<TypeEdge> stackEdge = new Stack<>();\n\t\t\tstackVertex.push(start);\n\t\t\tstackEdge.push(null);\n\t\t\twhile (!stackVertex.isEmpty())\n\t\t\t{\n\t\t\t\tTypeVertex vertex = stackVertex.pop();\n\t\t\t\tTypeEdge edge = stackEdge.pop();\n\t\t\t\tif (result.contains(vertex))\n\t\t\t\t{\n\t\t\t\t\tfunctionVisitPost.accept(vertex, edge);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult.add(vertex);\n\t\t\t\t\tstackVertex.push(vertex);\n\t\t\t\t\tstackEdge.push(edge);\n\t\t\t\t\tfunctionVisitPre.accept(vertex, edge);\n\t\t\t\t\tfor (TypeEdge otherEdge : vertex.edges)\n\t\t\t\t\t{\n\t\t\t\t\t\tTypeVertex otherVertex = otherEdge.other(vertex);\n\t\t\t\t\t\tif (!result.contains(otherVertex))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstackVertex.push(otherVertex);\n\t\t\t\t\t\t\tstackEdge.push(otherEdge);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static <\n\t\t\t\tTypeVertex extends Vertex<TypeVertex, TypeEdge>,\n\t\t\t\tTypeEdge extends Edge<TypeVertex, TypeEdge>\n\t\t\t\t>\n\t\tSortedSet<TypeVertex>\n\t\tdepthFirstSearch\n\t\t\t\t(\n\t\t\t\t\t\tTypeVertex start,\n\t\t\t\t\t\tConsumer<TypeVertex> functionVisitPreVertex,\n\t\t\t\t\t\tConsumer<TypeVertex> functionVisitPostVertex\n\t\t\t\t)\n\t\t{\n\t\t\tBiConsumer<TypeVertex, TypeEdge> functionVisitPreVertexEdge = (vertex, edge) ->\n\t\t\t{\n\t\t\t\tfunctionVisitPreVertex.accept(vertex);\n\t\t\t};\n\t\t\tBiConsumer<TypeVertex, TypeEdge> functionVisitPostVertexEdge = (vertex, edge) ->\n\t\t\t{\n\t\t\t\tfunctionVisitPostVertex.accept(vertex);\n\t\t\t};\n\t\t\treturn depthFirstSearch(start, functionVisitPreVertexEdge, functionVisitPostVertexEdge);\n\t\t}\n\n\t\tpublic final int index;\n\t\tpublic final List<TypeEdge> edges;\n\n\t\tpublic Vertex(int index)\n\t\t{\n\t\t\tthis.index = index;\n\t\t\tthis.edges = new ArrayList<>();\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Vertex<? super TypeVertex, ? super TypeEdge> that)\n\t\t{\n\t\t\treturn Integer.compare(this.index, that.index);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \"\" + this.index;\n\t\t}\n\t}\n\n\tpublic static class VertexDefault<TypeEdge extends Edge<VertexDefault<TypeEdge>, TypeEdge>> extends Vertex<VertexDefault<TypeEdge>, TypeEdge>\n\t{\n\t\tpublic VertexDefault(int index)\n\t\t{\n\t\t\tsuper(index);\n\t\t}\n\t}\n\n\tpublic static class VertexDefaultDefault extends Vertex<VertexDefaultDefault, EdgeDefaultDefault>\n\t{\n\t\tpublic static Array<VertexDefaultDefault> vertices(int n)\n\t\t{\n\t\t\tArray<VertexDefaultDefault> result = new Array<>(n);\n\t\t\tfor (int index = 0; index < n; index++)\n\t\t\t{\n\t\t\t\tresult.set(index, new VertexDefaultDefault(index));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic VertexDefaultDefault(int index)\n\t\t{\n\t\t\tsuper(index);\n\t\t}\n\t}\n\n\tpublic static class Wrapper<Type>\n\t{\n\t\tpublic Type value;\n\n\t\tpublic Wrapper(Type value)\n\t\t{\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tpublic Type get()\n\t\t{\n\t\t\treturn this.value;\n\t\t}\n\n\t\tpublic void set(Type value)\n\t\t{\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn this.value.toString();\n\t\t}\n\t}\n\n\tpublic static void add(int delta, int[] result)\n\t{\n\t\tfor (int index = 0; index < result.length; index++)\n\t\t{\n\t\t\tresult[index] += delta;\n\t\t}\n\t}\n\n\tpublic static void add(int delta, int[]... result)\n\t{\n\t\tfor (int index = 0; index < result.length; index++)\n\t\t{\n\t\t\tadd(delta, result[index]);\n\t\t}\n\t}\n\n\tpublic static int binarySearchMaximum(Function<Integer, Boolean> filter, int start, int end)\n\t{\n\t\treturn -binarySearchMinimum(x -> filter.apply(-x), -end, -start);\n\t}\n\n\tpublic static int binarySearchMinimum(Function<Integer, Boolean> filter, int start, int end)\n\t{\n\t\tint result;\n\t\tif (start == end)\n\t\t{\n\t\t\tresult = end;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint middle = start + (end - start) / 2;\n\t\t\tif (filter.apply(middle))\n\t\t\t{\n\t\t\t\tresult = binarySearchMinimum(filter, start, middle);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = binarySearchMinimum(filter, middle + 1, end);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static void close()\n\t{\n\t\tout.close();\n\t}\n\n\tpublic static List<List<Integer>> combinations(int n, int k)\n\t{\n\t\tList<List<Integer>> result = new ArrayList<>();\n\t\tif (k == 0)\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (k == 1)\n\t\t\t{\n\t\t\t\tList<Integer> combination = new ArrayList<>();\n\t\t\t\tcombination.add(n);\n\t\t\t\tresult.add(combination);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int index = 0; index <= n; index++)\n\t\t\t\t{\n\t\t\t\t\tfor (List<Integer> combination : combinations(n - index, k - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tcombination.add(index);\n\t\t\t\t\t\tresult.add(combination);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static <Type> int compare(Iterator<Type> iterator0, Iterator<Type> iterator1, Comparator<Type> comparator)\n\t{\n\t\tint result = 0;\n\t\twhile (result == 0 && iterator0.hasNext() && iterator1.hasNext())\n\t\t{\n\t\t\tresult = comparator.compare(iterator0.next(), iterator1.next());\n\t\t}\n\t\tif (result == 0)\n\t\t{\n\t\t\tif (iterator1.hasNext())\n\t\t\t{\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (iterator0.hasNext())\n\t\t\t\t{\n\t\t\t\t\tresult = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static <Type> int compare(Iterable<Type> iterable0, Iterable<Type> iterable1, Comparator<Type> comparator)\n\t{\n\t\treturn compare(iterable0.iterator(), iterable1.iterator(), comparator);\n\t}\n\n\tpublic static long divideCeil(long x, long y)\n\t{\n\t\treturn (x + y - 1) / y;\n\t}\n\n\tpublic static Set<Long> divisors(long n)\n\t{\n\t\tSortedSetAVL<Long> result = new SortedSetAVL<>(Comparator.naturalOrder());\n\t\tresult.add(1L);\n\t\tfor (Long factor : factors(n))\n\t\t{\n\t\t\tSortedSetAVL<Long> divisors = new SortedSetAVL<>(result);\n\t\t\tfor (Long divisor : result)\n\t\t\t{\n\t\t\t\tdivisors.add(divisor * factor);\n\t\t\t}\n\t\t\tresult = divisors;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static LinkedList<Long> factors(long n)\n\t{\n\t\tLinkedList<Long> result = new LinkedList<>();\n\t\tIterator<Long> primes = ITERATOR_BUFFER_PRIME.iterator();\n\t\tLong prime;\n\t\twhile (n > 1 && (prime = primes.next()) * prime <= n)\n\t\t{\n\t\t\twhile (n % prime == 0)\n\t\t\t{\n\t\t\t\tresult.add(prime);\n\t\t\t\tn /= prime;\n\t\t\t}\n\t\t}\n\t\tif (n > 1)\n\t\t{\n\t\t\tresult.add(n);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long faculty(int n)\n\t{\n\t\tlong result = 1;\n\t\tfor (int index = 2; index <= n; index++)\n\t\t{\n\t\t\tresult *= index;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long gcd(long a, long b)\n\t{\n\t\twhile (a != 0 && b != 0)\n\t\t{\n\t\t\tif (a > b)\n\t\t\t{\n\t\t\t\ta %= b;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb %= a;\n\t\t\t}\n\t\t}\n\t\treturn a + b;\n\t}\n\n\tpublic static long[] generatePOWER2()\n\t{\n\t\tlong[] result = new long[63];\n\t\tfor (int x = 0; x < result.length; x++)\n\t\t{\n\t\t\tresult[x] = 1L << x;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static boolean isPrime(long x)\n\t{\n\t\tboolean result = x > 1;\n\t\tIterator<Long> iterator = ITERATOR_BUFFER_PRIME.iterator();\n\t\tLong prime;\n\t\twhile ((prime = iterator.next()) * prime <= x)\n\t\t{\n\t\t\tresult &= x % prime > 0;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long knapsack(List<Tuple3<Long, Integer, Integer>> itemsValueWeightCount, int weightMaximum)\n\t{\n\t\tlong[] valuesMaximum = new long[weightMaximum + 1];\n\t\tfor (Tuple3<Long, Integer, Integer> itemValueWeightCount : itemsValueWeightCount)\n\t\t{\n\t\t\tlong itemValue = itemValueWeightCount.v0;\n\t\t\tint itemWeight = itemValueWeightCount.v1;\n\t\t\tint itemCount = itemValueWeightCount.v2;\n\t\t\tfor (int weight = weightMaximum; 0 <= weight; weight--)\n\t\t\t{\n\t\t\t\tfor (int index = 1; index <= itemCount && 0 <= weight - index * itemWeight; index++)\n\t\t\t\t{\n\t\t\t\t\tvaluesMaximum[weight] = Math.max(valuesMaximum[weight], valuesMaximum[weight - index * itemWeight] + index * itemValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong result = 0;\n\t\tfor (long valueMaximum : valuesMaximum)\n\t\t{\n\t\t\tresult = Math.max(result, valueMaximum);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static boolean knapsackPossible(List<Tuple2<Integer, Integer>> itemsWeightCount, int weightMaximum)\n\t{\n\t\tboolean[] weightPossible = new boolean[weightMaximum + 1];\n\t\tweightPossible[0] = true;\n\t\tint weightLargest = 0;\n\t\tfor (Tuple2<Integer, Integer> itemWeightCount : itemsWeightCount)\n\t\t{\n\t\t\tint itemWeight = itemWeightCount.v0;\n\t\t\tint itemCount = itemWeightCount.v1;\n\t\t\tfor (int weightStart = 0; weightStart < itemWeight; weightStart++)\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tfor (int weight = weightStart; weight <= weightMaximum && (0 < count || weight <= weightLargest); weight += itemWeight)\n\t\t\t\t{\n\t\t\t\t\tif (weightPossible[weight])\n\t\t\t\t\t{\n\t\t\t\t\t\tcount = itemCount;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (0 < count)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tweightPossible[weight] = true;\n\t\t\t\t\t\t\tweightLargest = weight;\n\t\t\t\t\t\t\tcount -= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn weightPossible[weightMaximum];\n\t}\n\n\tpublic static long lcm(int a, int b)\n\t{\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tpublic static void main(String[] args)\n\t{\n\t\ttry\n\t\t{\n\t\t\tsolve();\n\t\t}\n\t\tcatch (IOException exception)\n\t\t{\n\t\t\texception.printStackTrace();\n\t\t}\n\t\tclose();\n\t}\n\n\tpublic static double nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(nextString());\n\t}\n\n\tpublic static int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static void nextInts(int n, int[]... result) throws IOException\n\t{\n\t\tfor (int index = 0; index < n; index++)\n\t\t{\n\t\t\tfor (int value = 0; value < result.length; value++)\n\t\t\t{\n\t\t\t\tresult[value][index] = nextInt();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int[] nextInts(int n) throws IOException\n\t{\n\t\tint[] result = new int[n];\n\t\tnextInts(n, result);\n\t\treturn result;\n\t}\n\n\tpublic static String nextLine() throws IOException\n\t{\n\t\treturn bufferedReader.readLine();\n\t}\n\n\tpublic static long nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static void nextLongs(int n, long[]... result) throws IOException\n\t{\n\t\tfor (int index = 0; index < n; index++)\n\t\t{\n\t\t\tfor (int value = 0; value < result.length; value++)\n\t\t\t{\n\t\t\t\tresult[value][index] = nextLong();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static long[] nextLongs(int n) throws IOException\n\t{\n\t\tlong[] result = new long[n];\n\t\tnextLongs(n, result);\n\t\treturn result;\n\t}\n\n\tpublic static String nextString() throws IOException\n\t{\n\t\twhile ((stringTokenizer == null) || (!stringTokenizer.hasMoreTokens()))\n\t\t{\n\t\t\tstringTokenizer = new StringTokenizer(bufferedReader.readLine());\n\t\t}\n\t\treturn stringTokenizer.nextToken();\n\t}\n\n\tpublic static String[] nextStrings(int n) throws IOException\n\t{\n\t\tString[] result = new String[n];\n\t\t{\n\t\t\tfor (int index = 0; index < n; index++)\n\t\t\t{\n\t\t\t\tresult[index] = nextString();\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static <T> List<T> permutation(long p, List<T> x)\n\t{\n\t\tList<T> copy = new ArrayList<>();\n\t\tfor (int index = 0; index < x.size(); index++)\n\t\t{\n\t\t\tcopy.add(x.get(index));\n\t\t}\n\t\tList<T> result = new ArrayList<>();\n\t\tfor (int indexTo = 0; indexTo < x.size(); indexTo++)\n\t\t{\n\t\t\tint indexFrom = (int) p % copy.size();\n\t\t\tp = p / copy.size();\n\t\t\tresult.add(copy.remove(indexFrom));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static <Type> List<List<Type>> permutations(List<Type> list)\n\t{\n\t\tList<List<Type>> result = new ArrayList<>();\n\t\tresult.add(new ArrayList<>());\n\t\tfor (Type element : list)\n\t\t{\n\t\t\tList<List<Type>> permutations = result;\n\t\t\tresult = new ArrayList<>();\n\t\t\tfor (List<Type> permutation : permutations)\n\t\t\t{\n\t\t\t\tfor (int index = 0; index <= permutation.size(); index++)\n\t\t\t\t{\n\t\t\t\t\tList<Type> permutationNew = new ArrayList<>(permutation);\n\t\t\t\t\tpermutationNew.add(index, element);\n\t\t\t\t\tresult.add(permutationNew);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static Stream<BigInteger> streamFibonacci()\n\t{\n\t\treturn Stream.generate(new Supplier<BigInteger>()\n\t\t{\n\t\t\tprivate BigInteger n0 = BigInteger.ZERO;\n\t\t\tprivate BigInteger n1 = BigInteger.ONE;\n\n\t\t\t@Override\n\t\t\tpublic BigInteger get()\n\t\t\t{\n\t\t\t\tBigInteger result = n0;\n\t\t\t\tn0 = n1;\n\t\t\t\tn1 = result.add(n0);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static Stream<Long> streamPrime(int sieveSize)\n\t{\n\t\treturn Stream.generate(new Supplier<Long>()\n\t\t{\n\t\t\tprivate boolean[] isPrime = new boolean[sieveSize];\n\t\t\tprivate long sieveOffset = 2;\n\t\t\tprivate List<Long> primes = new ArrayList<>();\n\t\t\tprivate int index = 0;\n\n\t\t\tpublic void filter(long prime, boolean[] result)\n\t\t\t{\n\t\t\t\tif (prime * prime < this.sieveOffset + sieveSize)\n\t\t\t\t{\n\t\t\t\t\tlong remainingStart = this.sieveOffset % prime;\n\t\t\t\t\tlong start = remainingStart == 0 ? 0 : prime - remainingStart;\n\t\t\t\t\tfor (long index = start; index < sieveSize; index += prime)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult[(int) index] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void generatePrimes()\n\t\t\t{\n\t\t\t\tArrays.fill(this.isPrime, true);\n\t\t\t\tthis.primes.forEach(prime -> filter(prime, isPrime));\n\t\t\t\tfor (int index = 0; index < sieveSize; index++)\n\t\t\t\t{\n\t\t\t\t\tif (isPrime[index])\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.primes.add(this.sieveOffset + index);\n\t\t\t\t\t\tfilter(this.sieveOffset + index, isPrime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.sieveOffset += sieveSize;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Long get()\n\t\t\t{\n\t\t\t\twhile (this.primes.size() <= this.index)\n\t\t\t\t{\n\t\t\t\t\tgeneratePrimes();\n\t\t\t\t}\n\t\t\t\tLong result = this.primes.get(this.index);\n\t\t\t\tthis.index += 1;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static <Type> String toString(Iterator<Type> iterator, String separator)\n\t{\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\tif (iterator.hasNext())\n\t\t{\n\t\t\tstringBuilder.append(iterator.next());\n\t\t}\n\t\twhile (iterator.hasNext())\n\t\t{\n\t\t\tstringBuilder.append(separator);\n\t\t\tstringBuilder.append(iterator.next());\n\t\t}\n\t\treturn stringBuilder.toString();\n\t}\n\n\tpublic static <Type> String toString(Iterator<Type> iterator)\n\t{\n\t\treturn toString(iterator, \" \");\n\t}\n\n\tpublic static <Type> String toString(Iterable<Type> iterable, String separator)\n\t{\n\t\treturn toString(iterable.iterator(), separator);\n\t}\n\n\tpublic static <Type> String toString(Iterable<Type> iterable)\n\t{\n\t\treturn toString(iterable, \" \");\n\t}\n\n\tpublic static long totient(long n)\n\t{\n\t\tSet<Long> factors = new SortedSetAVL<>(factors(n), Comparator.naturalOrder());\n\t\tlong result = n;\n\t\tfor (long p : factors)\n\t\t{\n\t\t\tresult -= result / p;\n\t\t}\n\t\treturn result;\n\t}\n\n\tinterface BiFunctionResult<Type0, Type1, TypeResult>\n\t{\n\t\tTypeResult apply(Type0 x0, Type1 x1, TypeResult x2);\n\t}\n\n\tpublic static final long BIG = 1000000007;\n\n\tpublic static long bigAdd(long x, long y)\n\t{\n\t\treturn (x + y) % BIG;\n\t}\n\n\tpublic static long bigMultiply(long x, long y)\n\t{\n\t\treturn (x * y) % BIG;\n\t}\n\n\tpublic static int convert(int n, int start, int end)\n\t{\n\t\treturn n * start + end;\n\t}\n\n\tpublic static long solve(long[] results, boolean[] statements, int start, int end)\n\t{\n\t\tint converted = convert(statements.length, start, end);\n\t\tlong result = results[converted];\n\t\tif (result == -1)\n\t\t{\n\t\t\tif (start == end)\n\t\t\t{\n\t\t\t\tresult = 1L;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (statements[start])\n\t\t\t\t{\n\t\t\t\t\tresult = solve(results, statements, start + 1, end);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult = 0L;\n\t\t\t\t\tfor (int index = start + 2; index <= end; index++)\n\t\t\t\t\t{\n\t\t\t\t\t\tlong inside = solve(results, statements, start + 1, index);\n\t\t\t\t\t\tlong outside = solve(results, statements, index, end);\n\t\t\t\t\t\tresult = C_455.bigAdd(result, C_455.bigMultiply(inside, outside));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults[converted] = result;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long solve(boolean[] statements)\n\t{\n\t\tlong[] results = new long[(statements.length + 1) * (statements.length + 1)];\n\t\tArrays.fill(results, -1);\n\t\treturn solve(results, statements, 0, statements.length);\n\t}\n\n\tpublic static long solveFast(boolean[] statements)\n\t{\n\t\tlong[] indent2Count = new long[statements.length];\n\t\tindent2Count[0] = 1;\n\t\tfor (boolean statement: statements)\n\t\t{\n\t\t\tif (statement)\n\t\t\t{\n\t\t\t\tlong count = 0;\n\t\t\t\tfor (int index = statements.length - 1; 0 <= index; index--)\n\t\t\t\t{\n\t\t\t\t\tcount = bigAdd(count, indent2Count[index]);\n\t\t\t\t\tindent2Count[index] = count;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int index = statements.length - 1; 1 <= index; index--)\n\t\t\t\t{\n\t\t\t\t\tindent2Count[index] = indent2Count[index - 1];\n\t\t\t\t}\n\t\t\t\tindent2Count[0] = 0;\n\t\t\t}\n\t\t}\n\t\treturn indent2Count[0];\n\t}\n\n\n\tpublic static void solve() throws IOException\n\t{\n\t\tint n = nextInt();\n\t\tboolean[] statements = new boolean[n];\n\t\tfor (int index = 0; index < n; index++)\n\t\t{\n\t\t\tstatements[index] = nextString().equals(\"s\");\n\t\t}\n\t\tout.println(solveFast(statements));\n\t}\n}", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class first\n{\n\tint max(int a1,int a2,int a3)\n\t{\n\t\tint max=a1;\n\t\tif(a2>=max)\n\t\t\tmax=a2;\n\t\tif(a3>=max)\n\t\t\tmax = a3;\n\t\treturn max;\t\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tint num=0;\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tnum = sc.nextInt();\n\t\tint num2 = num/10;\n\t\tint num3 = num%10;\n\t\tint num4 = (num2/10)*10+num3;\n\t\tfirst fs = new first();\n\t\tint result = fs.max(num,num2,num4);\n\t\tSystem.out.println(result);\n\t}\n}\t\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Sol {\n static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\t\n    public static void main(String[] args) {\n\t\tFastReader sc=new FastReader();\n\t\tint a=sc.nextInt();\n\t\tint b=sc.nextInt();\n\t\tint c=sc.nextInt();\n\t\tint n=sc.nextInt();\n\t\tif(n+c-a-b>=1&&c<=a&&c<=b)\n\t\t\tSystem.out.println(n+c-a-b);\n\t\telse\n\t\t\tSystem.out.println(\"-1\");\n\t}\n}", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\tstatic HashMap<Integer,ArrayList<seg>> ma;\n\tstatic class seg{\n\t\tseg(int a,int b){\n\t\t\tl=a;r=b;\n\t\t}\n\t\tint l,r;\n\t}\n\tstatic int n,sum,dex;\n\tstatic int arr[]=new int[1600];\n\tpublic static void main(String argas[]){\n\t\tScanner cin=new Scanner(System.in);\n\t\tma=new HashMap();\n\t\tn=cin.nextInt();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tarr[i]=cin.nextInt();\n\t\t\tsum=0;\n\t\t\tfor(int j=i;j>0;j--){\n\t\t\t\tsum+=arr[j];\n\t\t\t\tif(ma.containsKey(sum)) ma.get(sum).add(new seg(j,i));\n\t\t\t\telse {\n\t\t\t\t\tma.put(sum, new ArrayList<seg>());\n\t\t\t\t\tma.get(sum).add(new seg(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0,te;\n\t\tArrayList<seg> best=new ArrayList(),now,temp;\n\t\tIterator it=ma.entrySet().iterator();\n\t\twhile(it.hasNext()){\n\t\t\tnow=new ArrayList();\n\t\t\tte=0;\n\t\t\tMap.Entry entry=(Map.Entry) it.next();\n\t\t\ttemp=(ArrayList<seg>) entry.getValue();\n\t\t\tdex=0;\n\t\t\tfor(int i=0;i<temp.size();i++){\n\t\t\t\tif(temp.get(i).l>dex){\n\t\t\t\t\tdex=temp.get(i).r;\n\t\t\t\t\tte++;\n\t\t\t\t\tnow.add(new seg(temp.get(i).l,temp.get(i).r));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(te>ans){\n\t\t\t\tans=te;\n\t\t\t\tbest=now;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tfor(int i=0;i<best.size();i++){\n\t\t\tSystem.out.println(best.get(i).l+\" \"+best.get(i).r);\n\t\t}\n\t}\n}", "complexity": "quadratic", "problem": "1141_F2", "from": "CODEFORCES", "tags": "data structures,greedy"}
{"src": "import java.awt.Point;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Testt {\n\n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init() throws FileNotFoundException {\n        if (ONLINE_JUDGE) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    public static void main(String[] args) {\n        new Testt().run();\n    }\n\n    public static void mergeSort(int[] a) {\n        mergeSort(a, 0, a.length - 1);\n    }\n\n    private static void mergeSort(int[] a, int leftIndex, int rightIndex) {\n        final int MAGIC_VALUE = 50;\n        if (leftIndex < rightIndex) {\n            if (rightIndex - leftIndex <= MAGIC_VALUE) {\n                insertionSort(a, leftIndex, rightIndex);\n            } else {\n                int middleIndex = (leftIndex + rightIndex) / 2;\n                mergeSort(a, leftIndex, middleIndex);\n                mergeSort(a, middleIndex + 1, rightIndex);\n                merge(a, leftIndex, middleIndex, rightIndex);\n            }\n        }\n    }\n\n    private static void merge(int[] a, int leftIndex, int middleIndex,\n            int rightIndex) {\n        int length1 = middleIndex - leftIndex + 1;\n        int length2 = rightIndex - middleIndex;\n        int[] leftArray = new int[length1];\n        int[] rightArray = new int[length2];\n        System.arraycopy(a, leftIndex, leftArray, 0, length1);\n        System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n        for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n            if (i == length1) {\n                a[k] = rightArray[j++];\n            } else if (j == length2) {\n                a[k] = leftArray[i++];\n            } else {\n                a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++]\n                        : rightArray[j++];\n            }\n        }\n    }\n\n    private static void insertionSort(int[] a, int leftIndex, int rightIndex) {\n        for (int i = leftIndex + 1; i <= rightIndex; i++) {\n            int current = a[i];\n            int j = i - 1;\n            while (j >= leftIndex && a[j] > current) {\n                a[j + 1] = a[j];\n                j--;\n            }\n            a[j + 1] = current;\n        }\n    }\n\n    public void run() {\n        try {\n            long t1 = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \" + (t2 - t1));\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n\n    public void solve() throws IOException {\n        \n        int n  = readInt();\n        int [] a = new int [n];\n        for (int i = 0; i < n; i++){\n            a[i] = readInt();\n        }\n        mergeSort(a);\n        \n        int sum = 0;\n        for (int i = 0; i <n; i++){\n            sum+=a[i];\n        }\n        int sum2 = 0;\n        int ans = 0;\n        for (int i = n-1; i >=0; i-- ){\n            sum2+=a[i];\n            sum-=a[i];\n            ans++;\n            if (sum2>sum){\n                break;\n            }\n        }\n        \n        out.print(ans);\n    }\n/*  for (int i =0; i<n; i++){\n        out.print(a[i]+\" \");\n    }*/\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "/**\n * Created by IntelliJ IDEA.\n * User: Taras_Brzezinsky\n * Date: 8/13/11\n * Time: 6:10 PM\n * To change this template use File | Settings | File Templates.\n */\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.IOException;\n\npublic class DarkAssembly extends Thread {\n\n    public DarkAssembly() {\n        this.input = new BufferedReader(new InputStreamReader(System.in));\n        this.output = new PrintWriter(System.out);\n        this.setPriority(Thread.MAX_PRIORITY);\n    }\n\n    class Senator {\n        int loyalty;\n        int level;\n\n        public Senator(int level, int loyalty) {\n            this.level = level;\n            this.loyalty = loyalty;\n        }\n    }\n\n    private static double doIt(Senator[] senators, int A) {\n        double probability = .0;\n        for (int mask = 0; mask < (1 << senators.length); ++mask) {\n            int sum = A;\n            double current = 1.0;\n            for (int i = 0; i < senators.length; ++i) {\n                if ((mask & (1 << i)) != 0) {\n                    current *= .01 * senators[i].loyalty;\n                } else {\n                    current *= .01 * (100 - senators[i].loyalty);\n                    sum += senators[i].level;\n                }\n            }\n            if (getOnes(mask) > senators.length / 2) {\n                probability += current;\n            } else {\n                probability += current * (double)A / sum;\n            }\n        }\n        return probability;\n    }\n\n    private static double go(Senator []senators, int candies, int A, int current) {\n        if (current == senators.length) {\n            return doIt(senators, A);\n        } else {\n            double result = go(senators, candies, A, current + 1);\n            if (candies > 0 && senators[current].loyalty < 100) {\n                senators[current].loyalty += 10;\n                result = Math.max(result, go(senators, candies - 1, A, current));\n                senators[current].loyalty -= 10;\n            }\n           \n            return result;\n        }\n    }\n\n\n\n    static int getOnes(int mask) {\n        int result = 0;\n        while (mask != 0) {\n            mask &= mask - 1;\n            ++result;\n        }\n        return result;\n    }\n\n    public void run() {\n        try {\n            int n = nextInt();\n            int k = nextInt();\n            int A = nextInt();\n            Senator[] senators = new Senator[n];\n            for (int i = 0; i < n; ++i) {\n                senators[i] = new Senator(nextInt(), nextInt());\n            }\n            output.printf(\"%.10f\", go(senators, k, A, 0));\n\n            output.flush();\n            output.close();\n\n        } catch (Throwable e) {\n            System.err.println(e.getMessage());\n            System.err.println(Arrays.deepToString(e.getStackTrace()));\n        }\n    }\n\n\n    public static void main(String[] args) {\n        new DarkAssembly().start();\n    }\n\n    private String nextToken() throws IOException {\n        while (tokens == null || !tokens.hasMoreTokens()) {\n            tokens = new StringTokenizer(input.readLine());\n        }\n        return tokens.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n\n    private BufferedReader input;\n    private PrintWriter output;\n    private StringTokenizer tokens = null;\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.io.*;\nimport java.util.*;\npublic class CF_468B {\n    public static void main(String[] args) throws IOException {\n        new CF_468B().solve();\n    }\n    \n    int root(int[] father, int a){\n        if (father[a]==a) return a;\n        else return father[a]=root(father, father[a]);\n    }\n    void unite(int[] father, int a, int b){\n        father[root(father, a)]=root(father, b);\n    }\n    \n    \n    private void solve() throws IOException{\n        \n        InputStream in = System.in;\n        PrintStream out = System.out;\n        \n//        in = new FileInputStream(\"in.txt\");\n//        out = new PrintStream(\"out.txt\");\n        \n        long mod=1_000_000_007;\n        Scanner sc=new Scanner(in);\n        int n=sc.nextInt();\n        long a=sc.nextLong(), b=sc.nextLong();\n\n        int[] father=new int[n];\n        long[] p=new long[n];\n        HashMap<Long, Integer> pos=new HashMap<Long, Integer>();\n        for (int i=0;i<n;i++){\n            father[i]=i;\n            p[i]=sc.nextLong();\n            pos.put(p[i],i);\n        }        \n        for (int i=0;i<n;i++){\n            if (pos.containsKey(a-p[i])) unite(father,i,pos.get(a-p[i]) );\n            if (pos.containsKey(b-p[i])) unite(father,i,pos.get(b-p[i]) );\n        }\n        boolean[] canA=new boolean[n],\n                canB=new boolean[n];\n        Arrays.fill(canA,true);\n        Arrays.fill(canB,true);\n        for (int i=0;i<n;i++){\n            if (!pos.containsKey(a-p[i]) || \n                    root(father, i)!=root(father, pos.get(a-p[i]))) \n                canA[root(father, i)]=false;\n            if (!pos.containsKey(b-p[i]) || \n                    root(father, i)!=root(father, pos.get(b-p[i]))) \n                canB[root(father, i)]=false;\n            if (!canA[root(father,i)] && !canB[root(father,i)]){\n                out.println(\"NO\");\n                return;                    \n            }\n        }\n        out.println(\"YES\");\n        for (int i=0;i<n;i++)\n            if (canA[root(father, i)])\n                out.print(\"0 \");\n            else\n                out.print(\"1 \");\n            \n                \n    }\n}\n\n\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author anand.oza\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E1RotateColumnsEasyVersion solver = new E1RotateColumnsEasyVersion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E1RotateColumnsEasyVersion {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int t = in.nextInt();\n            for (int i = 0; i < t; i++) {\n                solve(in, out);\n            }\n        }\n\n        private void solve(InputReader in, PrintWriter out) {\n            int n = in.nextInt(), m = in.nextInt();\n\n            int[][] a = new int[n][];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.readIntArray(m);\n            }\n\n            out.println(solve(n, m, a));\n        }\n\n        private int solve(int n, int m, int[][] a) {\n            Cell[] cells = new Cell[n * m];\n            for (int i = 0, index = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    cells[index++] = new Cell(i, j, a[i][j]);\n                    if (index == cells.length)\n                        break;\n                }\n            }\n\n            Arrays.sort(cells, Comparator.comparingInt(cell -> -cell.x));\n\n            HashSet<Integer> colset = new HashSet<>();\n            for (int i = 0; colset.size() < n && colset.size() < m; i++) {\n                colset.add(cells[i].j);\n            }\n\n            ArrayList<Integer> cols = new ArrayList<>();\n            cols.addAll(colset);\n\n            int answer = 0;\n            for (long perm = 0; perm < pow(n, cols.size() - 1); perm++) {\n                long p = perm;\n                int[] offset = new int[cols.size()];\n                for (int col = 0; col < cols.size(); col++) {\n                    offset[col] = (int) (p % n);\n                    p /= n;\n                }\n                int sum = 0;\n                for (int row = 0; row < n; row++) {\n                    int max = 0;\n                    for (int col = 0; col < cols.size(); col++) {\n                        int cur = a[(row + offset[col]) % n][cols.get(col)];\n                        max = Math.max(max, cur);\n                    }\n                    sum += max;\n                }\n                answer = Math.max(answer, sum);\n            }\n\n            return answer;\n        }\n\n        private long pow(int base, int exponent) {\n            long p = 1;\n            for (int i = 0; i < exponent; i++) {\n                p *= base;\n            }\n            return p;\n        }\n\n        private class Cell {\n            final int i;\n            final int j;\n            final int x;\n\n            private Cell(int i, int j, int x) {\n                this.i = i;\n                this.j = j;\n                this.x = x;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] readIntArray(int n) {\n            int[] x = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextInt();\n            }\n            return x;\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        TaskC.InputReader in = new TaskC.InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.Solve(in, out);\n        out.close();\n    }\n\n\n    static class TaskC {\n\n        private long mod = 1_000_000_007;\n        private int n;\n        private boolean[] s;\n\n        public void Solve(InputReader in, PrintWriter out) {\n            n = in.NextInt();\n            s = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                String ss = in.Next();\n                s[i] = ss.charAt(0) == 'f';\n            }\n            if (s[n - 1]) {\n                out.println(0);\n                return;\n            }\n            long[] dpSum = new long[n + 1], lastDpSum = new long[n + 1];\n            for (int i = 0; i <= n; i++) {\n                lastDpSum[i] = i + 1;\n            }\n            for (int i = n - 2; i >= 0; i--) {\n                for (int j = 0; j <= i; j++) {\n                    if (!s[i]) {\n                        dpSum[j] = lastDpSum[j];\n                    } else {\n                        dpSum[j] = lastDpSum[j + 1] - lastDpSum[j];\n                    }\n                    if (j != 0) {\n                        dpSum[j] += dpSum[j - 1];\n                    }\n                    dpSum[j] %= mod;\n                    while (dpSum[j] < 0) dpSum[j] += mod;\n\n                }\n                long[] temp = dpSum;\n                dpSum = lastDpSum;\n                lastDpSum = temp;\n            }\n            out.println(lastDpSum[0]);\n        }\n\n        public static int GetMax(int[] ar) {\n            int max = Integer.MIN_VALUE;\n            for (int a : ar) {\n                max = Math.max(max, a);\n            }\n            return max;\n        }\n\n        public static int GetMin(int[] ar) {\n            int min = Integer.MAX_VALUE;\n            for (int a : ar) {\n                min = Math.min(min, a);\n            }\n            return min;\n        }\n\n        public static long GetSum(int[] ar) {\n            long s = 0;\n            for (int a : ar) s += a;\n            return s;\n        }\n\n        public static int[] GetCount(int[] ar) {\n            return GetCount(ar, GetMax(ar));\n        }\n\n        public static int[] GetCount(int[] ar, int maxValue) {\n            int[] dp = new int[maxValue + 1];\n            for (int a : ar) {\n                dp[a]++;\n            }\n            return dp;\n        }\n\n        static class InputReader {\n            public BufferedReader reader;\n            public StringTokenizer tokenizer;\n\n            public InputReader(InputStream stream) {\n                reader = new BufferedReader(new InputStreamReader(stream), 32768);\n                tokenizer = null;\n            }\n\n            public String Next() {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    try {\n                        tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n                return tokenizer.nextToken();\n            }\n\n            public int NextInt() {\n                return Integer.parseInt(Next());\n            }\n\n            public long NextLong() {\n                return Long.parseLong(Next());\n            }\n\n            public double NextDouble() {\n                return Double.parseDouble(Next());\n            }\n\n            public int[] NextIntArray(int n) {\n                return NextIntArray(n, 0);\n            }\n\n            public int[] NextIntArray(int n, int offset) {\n                int[] a = new int[n];\n                for (int i = 0; i < n; i++) {\n                    a[i] = NextInt() - offset;\n                }\n                return a;\n            }\n\n            public int[][] NextIntMatrix(int n, int m) {\n                return NextIntMatrix(n, m, 0);\n            }\n\n            public int[][] NextIntMatrix(int n, int m, int offset) {\n                int[][] a = new int[n][m];\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < m; j++) {\n                        a[i][j] = NextInt() - offset;\n                    }\n                }\n                return a;\n            }\n        }\n    }\n}\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\tint parity = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint count = 0;\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tif(arr[j] < arr[i]) {\n\t\t\t\t\tparity ^= 1;\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t}\n\t\tint m = s.nextInt();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint l = s.nextInt(), r = s.nextInt();\n\t\t\tif(((r - l + 1) / 2) % 2 == 1) {\n\t\t\t\tparity ^= 1;\n\t\t\t}\n\t\t\tSystem.out.println(parity == 1 ? \"odd\" : \"even\");\n\t\t}\n\t}\n\n}\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Random;\nimport java.io.Writer;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n\tpublic void solve(int testNumber, InputReader in, OutputWriter out) {\n        \n        \n        int n = in.nextInt();\n        int a[] = in.nextIntArray(n);\n        int i,j,k;\n\n        int b[] = a.clone();\n        ArrayUtils.randomShuffle(a);\n        Arrays.sort(a);\n        \n        int c[] = new int[n];\n        k=0;\n        for(i=0;i<n;++i) if(a[i]!=b[i]) c[k++] = i;\n        \n        String res = \"NO\";\n        if(k==0){\n            res = \"YES\";\n        }else\n        if(k==1){\n           \n        }else\n        if(k==2){\n            i = c[0]; j = c[1];\n            if(a[i]==b[j] && a[j]==b[i]) res = \"YES\";\n        }\n        \n        out.writeln(res);\n\t}\n}\n\nclass InputReader{\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    \n    public InputReader(InputStream stream){\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n    \n    public String next(){\n        while(tokenizer==null || !tokenizer.hasMoreTokens()){\n            try{\n                tokenizer = new StringTokenizer(reader.readLine());\n            }catch(Exception e){\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n    \n    public int nextInt(){\n        return Integer.parseInt(next());\n    }\n\n    public int[] nextIntArray(int size){\n        int array[] = new int[size];\n        for(int i=0; i<size; ++i) array[i] = nextInt();\n        return array;\n    }\n}\n\nclass OutputWriter{\n    private PrintWriter out;\n    \n    public OutputWriter(Writer out){\n        this.out = new PrintWriter(out);\n    }\n\n    public OutputWriter(OutputStream out){\n        this.out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out)));\n    }\n    \n    public void close(){\n        out.flush();\n        out.close();\n    }\n\n    public void writeln(Object ... o){\n        for(Object x : o) out.print(x);\n        out.println();\n    }\n}\n\nclass ArrayUtils{\n    private final static Random random = new Random(System.nanoTime());\n    \n    public static void randomShuffle(int a[]){\n        int n = a.length;\n        for(int i=0;i<n;++i){\n            int j = random.nextInt(n-i);\n            int t = a[i]; a[i] = a[j]; a[j] = t;\n        }\n    }\n}\n\n", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n//import java.util.Scanner;\nimport java.util.*;\n\npublic class t\n{\n\tstatic class FastReader\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastReader(){\n\t\t\tbr = new BufferedReader(new\n\t\t\tInputStreamReader(System.in));\n\t\t}\n\t\tString next(){\n\t\t\twhile (st == null || !st.hasMoreElements()){\n\t\t\t\ttry{\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt(){\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong(){\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble(){\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString nextLine()\n\t\t{\n\t\t\tString str = \"\";\n\t\t\ttry{\n\t\t\t\tstr = br.readLine();\n\t\t\t}\n\t\t\tcatch (IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tFastReader in=new FastReader();\n\t\t\n\n\t\tint n = in.nextInt();\n\t\tint p = in.nextInt();\n\t\tint[] ar = new int[n];\n\t\tint i;\n\t\tlong sum=0;\n\t\tfor(i=0;i<n;i++) {\n\t\t\tar[i]=in.nextInt();\n\t\t\tsum+=ar[i];\n\t\t}\n\t\tlong ans = 0;\n\t\tfor(i=0;i<n;i++) {\n\t\t\tlong nu = ar[i];\n\t\t\tlong nn = (sum-nu);\n\t\t\tlong an = (nu%p)+(nn%p);\n\t\t\tans=Math.max(ans, an);\n\t\t}\n\t\tSystem.out.println(ans);\n\n        \n\t}\n\t\n}", "complexity": "linear", "problem": "0958_C1", "from": "CODEFORCES", "tags": "brute force"}
{"src": "\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.math.BigInteger.*;\nimport static java.lang.Character.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class A {\n    public void run() {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        int n = s.length();\n        String[] ss = new String[n];\n        for (int i = 0; i < n; i++)\n            ss[i] = s.substring(i);\n        sort(ss);\n        int res = 0;\n        for (int i = 1; i < n; i++)\n            res = max(res, count(ss[i - 1], ss[i]));\n        System.out.println(res);\n    }\n\n    int count(String s, String t) {\n        int ret = 0;\n        for (int i = 0; i < min(s.length(), t.length()); i++)\n            if (s.charAt(i) != t.charAt(i))\n                return ret;\n            else\n                ret++;\n        return ret;\n    }\n\n    void debug(Object... os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n\n    public static void main(String... args) {\n        new A().run();\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\n\npublic class B {\n    private static StreamTokenizer in;\n    private static PrintWriter out;\n    \n    private static int nextInt() throws Exception{\n        in.nextToken();\n        return (int)in.nval;\n    }\n    \n    private static String nextString() throws Exception{\n        in.nextToken();\n        return in.sval;\n    }\n    \n    static{\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n    }\n    \n    public static void main(String[] args)throws Exception{\n        int n = nextInt();\n        char[] c = nextString().toCharArray();\n        \n        int tc = 0, hc = 0;\n        for(int i = 0;i<c.length; i++){\n            if(c[i] == 'T')tc++; else hc++;\n        }\n//      char g = 'T';\n//      if(tc > hc){\n//          tc = hc;\n//          g = 'H';\n//      }\n        \n        int max = -1;\n        int pos = 0;\n        for(int i = 0; i<c.length; i++){\n            int a = 0;\n            for(int j = 0; j<tc;j++){\n                int k = i+j;\n                if(k>=n)k-=n;\n                if(c[k] == 'T'){\n                    a++;\n                }\n            }\n            if(a>max){\n                max = a;\n                pos = i;\n            }\n        }\n        int min1 = tc - max;\n        \n        max = -1;\n        pos = 0;\n        for(int i = 0; i<c.length; i++){\n            int a = 0;\n            for(int j = 0; j<hc;j++){\n                int k = i+j;\n                if(k>=n)k-=n;\n                if(c[k] == 'H'){\n                    a++;\n                }\n            }\n            if(a>max){\n                max = a;\n                pos = i;\n            }\n        }\n        int min2 = hc - max;\n        \n        out.println(Math.min(min1, min2));\n        out.flush();\n    }\n}\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\t\n\n\tpublic void solve() throws Exception {\n\t\tint n = nextInt();\n\t\tint a [] = new int [n];\n\t\tfor (int i = 0 ;i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tif (n == 1) {\n\t\t\tif (a[0] == 1) {\n\t\t\t\tout.print(2);\n\t\t\t} else {\n\t\t\t\tout.print(1);\n\t\t\t}\n\t\t} else {\n\t\t\tout.print(1);\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tif (i == n-1 && a[i] == 1) {\n\t\t\t\t\tout.print(\" \"+2);\n\t\t\t\t} else {\n\t\t\t\t\tout.print(\" \"+a[i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\t\n\t/********************************************************************************************/\n\t/* THERE IS INPUT */\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tlong stime=0;\n\t\n\tprivate String next() throws Exception {\n\t\twhile (st == null || !st.hasMoreElements())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws Exception {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tprivate long nextLong() throws Exception {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tprivate double nextDouble() throws Exception {\n\t\treturn Double.parseDouble(next());\n\t}\n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\t//Locale.setDefault(Locale.US);\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t\tsolve();\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Thread(null, new Solution(), \"\", 1 << 25).start();\n\t}\n\n\t\n}\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        int testCount = 1;\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n}\n\nclass Task {\n    int n;\n    int[] a;\n    int[] b;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        n = in.readInt();\n        a = new int[n];\n        b = new int[n];\n        for (int i = 0; i < n; ++i)\n            a[i] = b[i] = in.readInt();\n        sort(0, n - 1);\n        int different = 0;\n        for (int i = 0; i < n; ++i)\n            if (a[i] != b[i])\n                ++different;\n        out.println(different <= 2 ? \"YES\" : \"NO\");\n    }\n\n    public void sort(int lo, int hi) {\n        if (lo < hi) {\n            int mid = (lo + hi) / 2;\n            sort(lo, mid);\n            sort(mid + 1, hi);\n            merge(lo, mid, hi);\n        }\n    }\n\n    public void merge(int lo, int mid, int hi) {\n        int n1 = mid - lo + 1;\n        int n2 = hi - (mid + 1) + 1;\n        int[] x = new int[n1 + 1];\n        int[] y = new int[n2 + 1];\n        for (int i = 0; i < n1; ++i)\n            x[i] = b[lo + i];\n        for (int j = 0; j < n2; ++j)\n            y[j] = b[mid + 1 + j];\n        x[n1] = y[n2] = Integer.MAX_VALUE;\n        for (int k = lo, i = 0, j = 0; k <= hi; ++k)\n            b[k] = x[i] < y[j] ? x[i++] : y[j++];\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public Long readLong() {\n        return Long.parseLong(readString());\n    }\n\n    public Double readDouble() {\n        return Double.parseDouble(readString());\n    }\n\n    public static boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n}", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class f{\n\n   public static void main(String[] args) {\n      MyScanner sc = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      \n      int n = sc.nextInt();\n      int m = sc.nextInt();\n      int[][] arr = new int[n][m];\n      for(int i=0; i<n; i++) {\n          for(int j=0; j<m; j++) {\n              arr[i][j] = sc.nextInt();\n          }\n      }\n      if(n==1) {\n          int min = Integer.MAX_VALUE;\n          for(int i=0; i<m-1; i++) {\n              min = Math.min(min, Math.abs(arr[0][i]-arr[0][i+1]));\n          }\n          out.println(min);\n          out.close();\n      }\n      int[][] adj = new int[n][n];\n      int[][] edgeadj = new int[n][n];\n      for(int i=0; i<n; i++) {\n          for(int j=i+1; j<n; j++) {\n              int min = Integer.MAX_VALUE;\n              for(int k=0; k<m; k++) {\n                  min = Math.min(min, Math.abs(arr[i][k]-arr[j][k]));\n              }\n              adj[i][j]=min;\n              adj[j][i]=min;\n              int min1 = Integer.MAX_VALUE;\n              int min2 = Integer.MAX_VALUE;\n              for(int k=0; k<m-1; k++) {\n                  min1 = Math.min(min1, Math.abs(arr[i][k]-arr[j][k+1]));\n                  min2 = Math.min(min2, Math.abs(arr[i][k+1]-arr[j][k]));\n              }\n              edgeadj[i][j]=min1;\n              edgeadj[j][i]=min2;\n          }\n      }\n      int power = (int)Math.pow(2,n);\n      int[][][] dp = new int[power][n][n];\n      for(int i=0; i<n; i++) {\n          dp[(int)Math.pow(2,i)][i][i] = Integer.MAX_VALUE;\n      }\n      for(int bit=0; bit<power; bit++) {\n          for(int j=0; j<n; j++) {\n              for(int k=0; k<n; k++) {\n                  if((bit & (1<<j))>0 && (bit & (1<<k))>0 && j!=k) {\n                      int temp = bit;\n                      temp &= ~(1<<k);\n                      int ans = 0;\n                      for(int l=0; l<n; l++) {\n                          if((temp & (1<<l))>0) {\n                              int min = Math.min(dp[temp][j][l], adj[l][k]);\n                              ans = Math.max(ans, min);\n                          }\n                      }\n                      if(j!=k) {\n                          dp[bit][j][k] = ans;\n                      }\n                    // out.println(bit + \" \" + j + \" \" + k + \" \" + dp[bit][j][k]);\n                  }\n              }\n          }\n      }\n      int answer = 0;\n      for(int i=0; i<n; i++) {\n          for(int j=0; j<n; j++) {\n              if(i!=j) {\n                int ans = Math.min(dp[power-1][i][j], edgeadj[i][j]);\n                answer = Math.max(answer, ans);\n              }\n          }\n      }\n    //   for(int i=0; i<n; i++) {\n    //       for(int j=0; j<n; j++) {\n    //           out.println(dp[power-1][i][j]+\" \"+edgeadj[i][j]);\n    //       }\n    //   }\n      out.println(answer);\n      \n      // Start writing your solution here. -------------------------------------\n   \n      /*\n      int n      = sc.nextInt();        // read input as integer\n      long k     = sc.nextLong();       // read input as long\n      double d   = sc.nextDouble();     // read input as double\n      String str = sc.next();           // read input as String\n      String s   = sc.nextLine();       // read whole line as String\n\n      int result = 3*n;\n      out.println(result);                    // print via PrintWriter\n      */\n\n      // Stop writing your solution here. -------------------------------------\n      out.close();\n   }\n\n   //-----------PrintWriter for faster output---------------------------------\n   public static PrintWriter out;\n      \n   //-----------MyScanner class for faster input----------\n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n\n   }\n   //--------------------------------------------------------\n}", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class C {\n\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer st = null;\n\n\tprivate void solution() throws IOException {\n\t\tint n = nextInt();\n\t\tint[] mas = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmas[i] = nextInt();\n\t\t}\n\n\t\tArrays.sort(mas);\n\n\t\tif (mas[n - 1] == 1) {\n\t\t\tmas[n - 1] = 2;\n\t\t} else {\n\t\t\tmas[n - 1] = 1;\n\t\t}\n\t\tArrays.sort(mas);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tSystem.out.print(mas[i] + \" \");\n\t\t}\n\n\t}\n\n\tString nextToken() throws IOException {\n\t\tif (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(bf.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tnew C().solution();\n\t}\n}", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.util.LinkedList;\n\nimport java.io.FileInputStream;\n\nimport java.io.InputStream;\n\nimport java.io.InputStreamReader;\n\nimport java.io.BufferedReader;\n\nimport java.util.Collection;\n\nimport java.io.OutputStream;\n\nimport java.io.PrintWriter;\n\nimport java.util.Queue;\n\nimport java.io.IOException;\n\nimport java.io.FileOutputStream;\n\nimport java.util.StringTokenizer;\n\n\n\n/**\n\n * Built using CHelper plug-in\n\n * Actual solution is at the top\n\n */\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        InputStream inputStream;\n\n        try {\n\n            inputStream = new FileInputStream(\"input.txt\");\n\n        } catch (IOException e) {\n\n            throw new RuntimeException(e);\n\n        }\n\n        OutputStream outputStream;\n\n        try {\n\n            outputStream = new FileOutputStream(\"output.txt\");\n\n        } catch (IOException e) {\n\n            throw new RuntimeException(e);\n\n        }\n\n        InputReader in = new InputReader(inputStream);\n\n        PrintWriter out = new PrintWriter(outputStream);\n\n        TaskC solver = new TaskC();\n\n        solver.solve(1, in, out);\n\n        out.close();\n\n    }\n\n}\n\n\n\nclass TaskC {\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n\n        int n = in.nextInt();\n\n        int m = in.nextInt();\n\n        int k = in.nextInt();\n\n        Queue<Point> points = new LinkedList<Point>();\n\n        int[][] burnTime = new int[n][m];\n\n        boolean[][] visited = new boolean[n][m];\n\n        for (int i = 0; i < k; i++) {\n\n            int x = in.nextInt() - 1;\n\n            int y = in.nextInt() - 1;\n\n            visited[x][y] = true;\n\n            burnTime[x][y] = 0;\n\n            points.add(new Point(x, y));\n\n\n\n        }\n\n        int[] dx = new int[]{-1, 0, 0, 1};\n\n        int[] dy = new int[]{0, -1, 1, 0};\n\n        while (points.size() != 0) {\n\n            Point cur = points.poll();\n\n            int x = cur.x;\n\n            int y = cur.y;\n\n            for (int i = 0; i < dx.length; i++) {\n\n                int nextX = x + dx[i];\n\n                int nextY = y + dy[i];\n\n                if (nextX >= 0 && nextX < n && nextY >= 0 && nextY < m && (burnTime[x][y] + 1 < burnTime[nextX][nextY] || !visited[nextX][nextY])) {\n\n                    points.add(new Point(nextX, nextY));\n\n                    visited[nextX][nextY] = true;\n\n                    burnTime[nextX][nextY] = burnTime[x][y] + 1;\n\n                }\n\n            }\n\n        }\n\n        int x, y;\n\n        x = y = 0;\n\n        for (int i = 0; i < n; i++) {\n\n            for (int j = 0; j < m; j++) {\n\n                if (burnTime[i][j] > burnTime[x][y]) {\n\n                    x = i;\n\n                    y = j;\n\n                }\n\n            }\n\n        }\n\n        out.printf(\"%d %d\", x + 1, y + 1);\n\n    }\n\n}\n\n\n\nclass Point {\n\n    int x;\n\n    int y;\n\n\n\n    public Point(int x, int y) {\n\n        this.x = x;\n\n        this.y = y;\n\n    }\n\n}\n\n\n\nclass InputReader {\n\n    public BufferedReader reader;\n\n    public StringTokenizer tokenizer;\n\n\n\n    public InputReader(InputStream stream) {\n\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n\n        tokenizer = null;\n\n    }\n\n\n\n    public String next() {\n\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\n            try {\n\n                tokenizer = new StringTokenizer(reader.readLine());\n\n            } catch (IOException e) {\n\n                throw new RuntimeException(e);\n\n            }\n\n        }\n\n        return tokenizer.nextToken();\n\n    }\n\n\n\n    public int nextInt() {\n\n        return Integer.parseInt(next());\n\n    }\n\n\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "\nimport java.util.*;\n\n\npublic class A\n{\n   public static void main(String[] args)\n   {\n      new A(new Scanner(System.in));\n   }\n\n   public A(Scanner in)\n   {\n      int n = in.nextInt();\n      int t = in.nextInt();\n      int tt = 2*t;\n\n      rect[] rs = new rect[n];\n      for (int i=0; i<n; i++)\n         rs[i] = new rect(in.nextInt(), in.nextInt());\n      \n      Arrays.sort(rs);\n\n      int res = 2;\n      for (int i=1; i<n; i++)\n      {\n         rect a = rs[i-1];\n         rect b = rs[i];\n         int d = b.p-a.p;\n         int dd = a.t+b.t;\n         int tv = 2*d-dd;\n         if (tt == tv)\n            res++;\n         if (tv > tt)\n            res+=2;\n      }\n      System.out.printf(\"%d%n\", res);\n   }\n}\n\nclass rect implements Comparable<rect>\n{\n   int p;\n   int t;\n\n   public rect(int pp, int tt)\n   {\n      p = pp;\n      t = tt;\n   }\n\n   public int compareTo(rect rhs)\n   {\n      return p-rhs.p;\n   }\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        private static final int MOD = (int) 1e9 + 7;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n\n            int[] primes = getPrimes(40_000);\n\n            int[][] a = new int[n][];\n            for (int i = 0; i < n; ++i) {\n                int x = in.nextInt();\n                IntList divs = new IntList();\n                for (int j : primes) {\n                    if (j * j > x) {\n                        break;\n                    }\n                    int cnt = 0;\n                    while (x % j == 0) {\n                        cnt++;\n                        x /= j;\n                    }\n                    if (cnt % 2 == 1) {\n                        divs.add(j);\n                    }\n                }\n                if (x > 1) {\n                    divs.add(x);\n                }\n                a[i] = divs.toArray();\n            }\n            Comparator<int[]> cmp = ((o1, o2) -> {\n                for (int i = 0; i < o1.length && i < o2.length; ++i) {\n                    if (o1[i] < o2[i]) {\n                        return -1;\n                    } else if (o2[i] < o1[i]) {\n                        return 1;\n                    }\n                }\n                return Integer.compare(o1.length, o2.length);\n            });\n            Arrays.sort(a, cmp);\n            IntList freqsList = new IntList();\n            int cnt = 1;\n            for (int i = 1; i < n; ++i) {\n                if (cmp.compare(a[i], a[i - 1]) == 0) {\n                    cnt++;\n                } else {\n                    freqsList.add(cnt);\n                    cnt = 1;\n                }\n            }\n            freqsList.add(cnt);\n            int[][] comb = new int[2 * n + 1][2 * n + 1];\n            for (int i = 0; i < comb.length; ++i) {\n                comb[i][0] = 1;\n                for (int j = 1; j <= i; ++j) {\n                    comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;\n                }\n            }\n            int[] dp = new int[n];\n            int[] ndp = new int[n];\n            dp[0] = 1;\n            int total = 0;\n            int ans = 1;\n            for (int x : freqsList.toArray()) {\n                Arrays.fill(ndp, 0);\n                for (int bad = 0; bad < n; ++bad) {\n                    if (dp[bad] == 0) {\n                        continue;\n                    }\n                    for (int putSeparately = 1; putSeparately <= x; ++putSeparately) {\n                        for (int breakEq = 0; breakEq <= putSeparately; ++breakEq) {\n                            int nState = bad + x - putSeparately - breakEq;\n                            if (nState < 0 || nState >= n) {\n                                continue;\n                            }\n                            int rem = total + 1 - bad;\n                            int notBreak = putSeparately - breakEq;\n                            if (breakEq > bad || notBreak > rem) {\n                                continue;\n                            }\n                            int add = (int) ((long) comb[bad][breakEq] * comb[rem][notBreak] % MOD *\n                                    comb[x - 1][putSeparately - 1] % MOD * dp[bad] % MOD);\n                            ndp[nState] += add;\n                            ndp[nState] %= MOD;\n                        }\n                    }\n                }\n                total += x;\n                int[] aux = dp;\n                dp = ndp;\n                ndp = aux;\n                ans = (int) ((long) ans * fact(x) % MOD);\n            }\n            ans = (int) ((long) ans * dp[0] % MOD);\n            out.println(ans);\n        }\n\n        private int fact(int n) {\n            int res = 1;\n            for (int i = 2; i <= n; ++i) {\n                res = (int) ((long) res * i % MOD);\n            }\n            return res;\n        }\n\n        private int[] getPrimes(int n) {\n            boolean[] isPrime = new boolean[n + 1];\n            Arrays.fill(isPrime, 2, isPrime.length, true);\n            for (int i = 2; i * i <= n; ++i) {\n                if (isPrime[i]) {\n                    for (int j = i * i; j <= n; j += i) {\n                        isPrime[j] = false;\n                    }\n                }\n            }\n            IntList primes = new IntList();\n            for (int i = 2; i <= n; ++i) {\n                if (isPrime[i]) {\n                    primes.add(i);\n                }\n            }\n            return primes.toArray();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new UnknownError();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n\n    static interface IntIterator extends Iterator<Integer> {\n    }\n\n    static class IntList implements Iterable<Integer> {\n        int[] elem;\n        int size;\n\n        public IntList() {\n            this(0, 0, 1);\n        }\n\n        public IntList(int size) {\n            this(size, 0, Math.max(1, size));\n        }\n\n        public IntList(int size, int value) {\n            this(size, value, Math.max(1, size));\n        }\n\n        public IntList(int size, int value, int capacity) {\n            elem = new int[capacity];\n            Arrays.fill(elem, 0, size, value);\n            this.size = size;\n        }\n\n        private IntList(int... e) {\n            elem = e.clone();\n            size = e.length;\n        }\n\n        public void add(int e) {\n            if (size + 1 > elem.length) {\n                increaseCapacity();\n            }\n            elem[size++] = e;\n        }\n\n        private void increaseCapacity() {\n            changeCapacity(3 * elem.length / 2 + 1);\n        }\n\n        private void changeCapacity(int newCapacity) {\n            int[] nElem = new int[newCapacity];\n            System.arraycopy(elem, 0, nElem, 0, Math.min(elem.length, newCapacity));\n            elem = nElem;\n        }\n\n        public IntIterator iterator() {\n            return new IntIterator() {\n                int pos = 0;\n\n\n                public Integer next() {\n                    return IntList.this.elem[pos++];\n                }\n\n\n                public boolean hasNext() {\n                    return pos < IntList.this.size;\n                }\n\n\n                public int nextInt() {\n                    return IntList.this.elem[pos++];\n                }\n            };\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(elem, size);\n        }\n\n        public int hashCode() {\n            int hashCode = 0;\n            for (int i = 0; i < size; ++i) {\n                hashCode = 31 * hashCode + elem[i];\n            }\n            return hashCode;\n        }\n\n    }\n}\n\n", "complexity": "cubic", "problem": "0840_C", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "\n\nimport java.io.DataInputStream;\nimport java.io.InputStream;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class B {\n\n    \n    public static void main(String[] args) throws Exception {\n        Parserdoubt2333 s = new Parserdoubt2333(System.in);\n        \n        int n = s.nextInt();\n        int k = s.nextInt();\n        int a[] = new int[n];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = s.nextInt();\n            \n        }\n        \n        TreeMap<Integer, Integer> tree = new TreeMap<Integer,Integer>();\n        \n        int left = 0;\n        int right = 0;\n        \n        for (right = 0; right < a.length; right++) {\n            if(tree.containsKey(a[right]))\n                tree.put(a[right], tree.get(a[right]) + 1);\n            else \n                tree.put(a[right],1);\n            if(tree.size() == k)\n                break;\n        }\n        \n        if(tree.size() < k){\n            System.out.println(\"-1 -1\");\n            return ;\n        }\n//      System.out.println(right);\n        for (left = 0; left < a.length; left++) {\n            int val = tree.get(a[left]);\n            val--;\n            if(val > 0)\n                tree.put(a[left],val);\n            if(val == 0)\n                break;\n            \n        }\n        left++;\n        right++;\n        System.out.println(left + \" \"+right);\n    }\n\n}\n\n\n\nclass Parserdoubt2333\n{\n   final private int BUFFER_SIZE = 1 << 18;\n \n   private DataInputStream din;\n   private byte[] buffer;\n   private int bufferPointer, bytesRead;\n \n   public Parserdoubt2333(InputStream in)\n   {\n      din = new DataInputStream(in);\n      buffer = new byte[BUFFER_SIZE];\n      bufferPointer = bytesRead = 0;\n   }\n   public String nextString() throws Exception\n   {\n       StringBuffer sb=new StringBuffer(\"\");\n       byte c = read();\n       while (c <= ' ') c = read();\n       do\n       {\n           sb.append((char)c);\n           c=read();\n       }while(c>' ');\n       return sb.toString();\n   }\n   public char nextChar() throws Exception\n   {\n       byte c=read();\n       while(c<=' ') c= read();\n       return (char)c;\n   }\n   public int nextInt() throws Exception\n   {\n      int ret = 0;\n      byte c = read();\n      while (c <= ' ') c = read();\n      boolean neg = c == '-';\n      if (neg) c = read();\n      do\n      {\n          ret = ret * 10 + c - '0';\n         c = read();\n      } while (c > ' ');\n      if (neg) return -ret;\n      return ret;\n   }\n   public long nextLong() throws Exception\n   {\n      long ret = 0;\n      byte c = read();\n      while (c <= ' ') c = read();\n      boolean neg = c == '-';\n      if (neg) c = read();\n      do\n      {\n          ret = ret * 10 + c - '0';\n         c = read();\n      } while (c > ' ');\n      if (neg) return -ret;\n      return ret;\n   }\n   private void fillBuffer() throws Exception\n   {\n      bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n      if (bytesRead == -1) buffer[0] = -1;\n   }\n \n   private byte read() throws Exception\n   {\n      if (bufferPointer == bytesRead) fillBuffer();\n      return buffer[bufferPointer++];\n   }\n} ", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import java.util.Scanner;\n\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int x = scan.nextInt();\n    solve(x);\n\n    }\n    public static void solve (int x){\n        int z = 0 ;\n        System.out.print(z+\" \");\n        System.out.print(z+\" \");\n        System.out.print(x);\n        \n    }\n\n}\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import java.io.* ;\nimport java.util.* ;\npublic class Codeshefcode {\n\tfinal static long r = 1000000007 ;\n\tstatic FasterScanner ip = new FasterScanner() ;\n\tstatic PrintWriter op = new PrintWriter(System.out) ;\n\tpublic static void main(String[] args) throws IOException{\n\t    int n = ip.i() ;\n\t    TreeMap<Character,Integer> map = new TreeMap<Character,Integer>() ;\n\t    TreeSet<Character> set = new TreeSet<Character>() ;\n\t    char c[] = ip.S().toCharArray() ;\n\t    for(char t : c)\n\t    \tset.add(t) ;\n\t    int size = set.size() ;\n\t    for(int i=0 ; i<size ; i++)\n\t    \tmap.put(set.pollFirst(),i) ;\n\t    int a[] = new int[n] ;\n\t    for(int i=0 ; i<n ; i++)\n\t    \ta[i]=map.get(c[i]) ;\n\t    int erl[][] = new int[size][n] ;\n\t    for(int i=0 ; i<size ; i++)\n\t    \tfor(int j=n-1 ; j>=0 ; j--)\n\t    \t\terl[i][j]=(a[j]==i) ? j : (j==n-1 ? -1 : erl[i][j+1]) ;\n\t    long min = Long.MAX_VALUE ;\n\t    for(int i=0 ; i<n ; i++){\n\t    \tlong maxt = Long.MIN_VALUE ;\n\t    \tfor(int j=0 ; j<size ; j++)\t\t\n\t    \t\tif(erl[j][i]!=-1)\n\t    \t\t\tmaxt = Long.max(maxt,(erl[j][i]-i+1)) ;\n\t    \t\telse{\n\t    \t\t\tmaxt = Long.MAX_VALUE ;\n\t    \t\t\tbreak ;\n\t    \t\t}\n\t    \tmin = Long.min(min,maxt) ;\t    \t\n\t    }\n\t    op.print(min) ;\n\t\tFinish() ;\n\t}\n\tstatic void Finish(){\n\t   op.flush(); \n\t   op.close();\n    }\t\n}\n@SuppressWarnings(\"serial\") \nclass MyList extends ArrayList<Long>{\n\t\n}\nclass pair {\n\tprivate int x  ;\n\tprivate int y ;\n\tpair(int a,int b){\n\t\tx=a ;\n\t\ty=b ;\t\t\n\t}\n\tpublic int x(){\n\t\treturn x ;\n\t}\n\tpublic int y(){\n\t\treturn y ;\n\t}\n}\nclass FasterScanner { \n    private InputStream mIs;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars; \n    public FasterScanner() {\n        this(System.in);\n    } \n    public FasterScanner(InputStream is) {\n        mIs = is;\n    } \n    public int read() {\n        if (numChars == -1) \n            throw new InputMismatchException();    \n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = mIs.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) \n                return -1;            \n        }\n        return buf[curChar++];\n    } \n    public String nextLine(){\n        int c = read();\n        while (isSpaceChar(c)) \n            c = read();        \n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    } \n    public String S(){\n        int c = read();\n        while (isSpaceChar(c)) \n            c = read();        \n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        }while (!isSpaceChar(c));\n        return res.toString();\n    } \n    public long l(){\n        int c = read();\n        while (isSpaceChar(c)) \n            c = read();        \n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do{\n           if (c < '0' || c > '9') \n               throw new InputMismatchException();            \n           res *= 10;\n           res += c - '0';\n           c = read();\n        }while(!isSpaceChar(c));\n        return res * sgn;\n    } \n    public int i(){\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();        \n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do{\n            if (c < '0' || c > '9') \n                throw new InputMismatchException();            \n            res *= 10;\n            res += c - '0';\n            c = read();\n        }while (!isSpaceChar(c));\n        return res * sgn;\n    } \n    public boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    } \n    public boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    } \n} ", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class E\n{\n    private static final int oo = 1000000000;\n    public static void main(String[] args) throws Exception\n    {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        if(n > m)\n        {\n            int t = n;\n            n = m;\n            m = t;\n        }\n\n        int [][] curr = new int[1<<n][1<<n];\n        fill(curr, oo);\n        Arrays.fill(curr[0], 0);\n\n        for(int j = 0 ; j < m ; j++)\n        {\n            int [][] next = new int[1<<n][1<<n];\n            fill(next, oo);\n            for(int c0 = 0 ; c0 < 1<<n ; c0++)\n                for(int c1 = 0 ; c1 < 1<<n ; c1++)\n                    if(curr[c0][c1] != oo)\n                        for(int c2 = 0 ; c2 < (j == m-1 ? 1 : 1<<n) ; c2++)\n                        {\n                            int all = (1<<n) - 1;\n                            int done = (all&(c1>>1)) | (all&(c1<<1)) | c0 | c2;\n                            done &= (all^c1);\n\n                            next[c1][c2] = Math.min(next[c1][c2], curr[c0][c1] + n - Integer.bitCount(done));\n\n                        }\n            curr = next;\n        }\n\n        int res = oo;\n        for(int i = 0 ; i < 1<<n ; i++)\n            for(int j = 0 ; j < 1<<n ; j++)\n                res = Math.min(res, curr[i][j]);\n\n        System.out.println(n*m - res);\n    }\n\n    private static void fill(int[][] array, int val)\n    {\n        for(int [] fill : array)\n            Arrays.fill(fill, val);\n    }\n}", "complexity": "np", "problem": "0112_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class CF8C {\n\tstatic int n;\n\tstatic int[] mem;\n\tstatic HashMap<Integer, String> map;\n\tstatic int INF = (int) 1e9;\n\tstatic StringBuilder sb;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner(System.in);\n\t\tString s = sc.nextLine();\n\t\tn = sc.nextInt();\n\t\tmem = new int[1 << n];\n\t\tArrays.fill(mem, -1);\n\t\tmap = new HashMap<>();\n\t\tmap.put(0, s);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tmap.put(i, sc.nextLine());\n\t\t}\n\t\tint val = dp(0);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tpw.println(val);\n\t\tsb = new StringBuilder();\n\t\tsb.append(\"0 \");\n\t\tbuild(0);\n\t\tpw.println(sb);\n\t\tpw.flush();\n\t}\n\n\t// node == 0 -- > count 0 // state == 0 has 1 // state == 1 has 2\n\n\tprivate static int dp(int msk) {\n\t\tif (msk == (1 << n) - 1)\n\t\t\treturn 0;\n\n\t\tif(mem[msk] != -1)\n\t\t\treturn mem[msk];\n\n\t\tboolean foundFirst = false;\n\t\tint val = (int)1e9; \n\t\tint mark = -1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif ((msk & 1 << (i - 1)) == 0){\n\t\t\t\tif(!foundFirst){\n\t\t\t\t\tfoundFirst = true;\n\t\t\t\t\tmark = i;\n\t\t\t\t\tval = dist(0, mark)*2 + dp(msk | 1 << (mark - 1));\n\t\t\t\t}else{\n\t\t\t\t\tval = Math.min(val, dist(0, mark) + dist(mark, i) + dist(i, 0) + dp((msk|1 << (mark - 1))|1 << (i - 1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mem[msk] = val;\n\t}\n\n\tprivate static int dist(int node, int i) {\n\t\tString from = map.get(i);\n\t\tString to = map.get(node);\n\t\tString[] fromco = from.split(\" \");\n\t\tString[] toco = to.split(\" \");\n\t\tint xs = Integer.parseInt(fromco[0]);\n\t\tint ys = Integer.parseInt(fromco[1]);\n\t\tint xf = Integer.parseInt(toco[0]);\n\t\tint yf = Integer.parseInt(toco[1]);\n\t\treturn (xs - xf) * (xs - xf) + (ys - yf) * (ys - yf);\n\t}\n\n\tprivate static void build(int msk) {\n\t\tif (msk == (1 << n) - 1) \n\t\t\treturn;\n\t\tboolean foundFirst = false;\n\t\tint ans = dp(msk);\n\t\tint mark = -1;\n\t\tint val = (int)1e9;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif ((msk & 1 << (i - 1)) == 0){\n\t\t\t\tif(!foundFirst){\n\t\t\t\t\tfoundFirst = true;\n\t\t\t\t\tmark = i;\n\t\t\t\t\tval = dist(0, mark)*2 + dp(msk | 1 << (mark - 1));\n\t\t\t\t\tif(val == ans){\n\t\t\t\t\t\tsb.append(mark + \" 0 \");\n\t\t\t\t\t\tbuild(msk | 1 << (mark - 1));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tval = dist(0, mark) + dist(mark, i) + dist(i, 0) + dp(msk|1 << (mark - 1)|1 << (i - 1));\n\t\t\t\t\tif(val == ans){\n\t\t\t\t\t\tsb.append(mark + \" \" + i + \" 0 \");\n\t\t\t\t\t\tbuild(msk|1 << (mark - 1)|1 << (i - 1));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class MyScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic MyScanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic MyScanner(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.util.*;\npublic class maximus {\n\tstatic long GCD(long a,long b){\n\tif(b==0)return a;\n\treturn GCD(b,a%b);\t\n\t}\npublic static void main(String [] args){\n  Scanner in=new Scanner(System.in);\n  long n=in.nextInt();\n  if(n<=2){\n  System.out.print(n);\n  return;\t\n  }\n  if(n%2==1){\n  System.out.print((n*(n-1)*(n-2)));\n  return;\n  }\n  if(n%2==0 && n<=6){\n  System.out.print(n*(n-1)*(n-2)/2);\n  return;\t\n  }\n  long temp=(n*(n-1)*(n-3))/GCD(n,n-3);\n  System.out.print(Math.max((n-1)*(n-2)*(n-3),temp));\n  }\n}", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Set;\n\n/**\n * @author Egor Kulikov (egor@egork.net)\n *         Created on 14.03.2010\n */\npublic class TaskA implements Runnable {\n\tprivate InputReader in;\n\tprivate PrintWriter out;\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new TaskA()).start();\n//\t\tnew Template().run();\n\t}\n\n\tpublic TaskA() {\n//\t\tString id = getClass().getName().toLowerCase();\n//\t\ttry {\n//\t\t\tSystem.setIn(new FileInputStream(id + \".in\"));\n//\t\t\tSystem.setOut(new PrintStream(new FileOutputStream(id + \".out\")));\n//\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n//\t\t\tSystem.setOut(new PrintStream(new FileOutputStream(\"output.txt\")));\n//\t\t} catch (FileNotFoundException e) {\n//\t\t\tthrow new RuntimeException();\n//\t\t}\n\t\tin = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t}\n\n\tpublic void run() {\n//        int numTests = in.readInt();\n//        for (int testNumber = 0; testNumber < numTests; testNumber++) {\n//\t\t\tout.print(\"Case \" + (testNumber + 1) + \": \");\n//        }\n\t\tString s = in.readString();\n\t\tSet<String> m = new HashSet<String>();\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tfor (int j = i + 1; j <= s.length(); j++) {\n\t\t\t\tif (m.contains(s.substring(i, j)))\n\t\t\t\t\tans = Math.max(ans, j - i);\n\t\t\t\telse\n\t\t\t\t\tm.add(s.substring(i, j));\n\t\t\t}\n\t\t}\n\t\tout.print(ans);\n\t\tout.close();\n\t}\n\n\tprivate static class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1000];\n\t\tprivate int curChar, numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int readInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long readLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuffer res = new StringBuffer();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate String readLine0() {\n\t\t\tStringBuffer buf = new StringBuffer();\n\t\t\tint c = read();\n\t\t\twhile (c != '\\n' && c != -1) {\n\t\t\t\tbuf.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\treturn buf.toString();\n\t\t}\n\n\t\tpublic String readLine() {\n\t\t\tString s = readLine0();\n\t\t\twhile (s.trim().length() == 0)\n\t\t\t\ts = readLine0();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic String readLine(boolean ignoreEmptyLines) {\n\t\t\tif (ignoreEmptyLines)\n\t\t\t\treturn readLine();\n\t\t\telse\n\t\t\t\treturn readLine0();\n\t\t}\n\n\t\tpublic BigInteger readBigInteger() {\n\t\t\ttry {\n\t\t\t\treturn new BigInteger(readString());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tpublic char readCharacter() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\treturn (char) c;\n\t\t}\n\n\t\tpublic double readDouble() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') {\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t}\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\n\npublic class A\n{\n    public static void main(String args[])\n    {\n        Scanner scan = new Scanner(System.in);\n        \n        String str = scan.next();\n        \n        for(int i=str.length();i >= 1;i--)\n        {\n            for(int j=0;j + i <= str.length();j++)\n            {\n                String sub = str.substring(j, j+i);\n                \n                int index = str.indexOf(sub, j+1);\n                \n                \n                if(index > -1)\n                {\n                    System.out.println(i);\n                    return;\n                }\n                \n            }\n        }\n        \n        System.out.println(0);\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        team[] t = new team[n];\n        for (int i = 0; i < n; i++)\n            t[i] = new team(in.nextInt(), in.nextInt());\n        Arrays.sort(t);\n        int cnt = 0;\n        team tm = t[t.length - k];\n        for (int i = t.length - 1; i >= 0; i--)\n            if (tm.equal(t[i]))\n                cnt++;\n        System.out.println(cnt);\n    }\n\n    static class team implements Comparable<team> {\n        int p, t;\n\n        public team(int pp, int tt) {\n            p = pp;\n            t = tt;\n        }\n\n        @Override\n        public int compareTo(team o) {\n            if (p == o.p)\n                return o.t - t;\n            return p - o.p;\n        }\n\n        public boolean equal(team a) {\n            return a.p == p && a.t == t;\n        }\n    }\n}", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class C {\n\n\tstatic int N,K;\n\tstatic int ar[];\n\tpublic static void main(String[] args) {\n\t\tFS in = new FS();\n\t\tN = in.nextInt();\n\t\tK = in.nextInt();\n\t\tchar c[] = in.next().toCharArray();\n\t\tar = new int[N];\n\t\tfor(int i = 0; i < N; i++) ar[i] = c[i]-'0';\n\t\t\n\t\tint suf[] = new int[2];\n\t\tint pref[] = new int[2];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tpref[ar[i]]++;\n\t\t\tif(i < N-1 && ar[i] != ar[i+1]) break;\n\t\t}\n\t\tfor(int i = N-1; i >= 0; i--) {\n\t\t\tsuf[ar[i]]++;\n\t\t\tif(i > 0 && ar[i] != ar[i-1]) break;\n\t\t}\n\t\t\n\t\tif(suf[0] + pref[0] + K >= N || suf[1] + pref[1] + K >= N) {\n\t\t\tp1Win();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean hasATie = false;\n\t\tfor(int i = 0; i < N-K+1; i++) {\n\t\t\t// change [i, i+K-1] to 1's or 0's and see if p2 can win\n\t\t\t\n\t\t\tint newSuf[] = Arrays.copyOf(suf, 2);\n\t\t\tint newPref[] = Arrays.copyOf(pref, 2);\n\t\t\t\n\t\t\t// change to 0's. Opponent has to change to 0's as well to win\n\t\t\tfor(int ch = 0; ch < 2; ch++) {\n\t\t\t\tif(newPref[ch] >= i) newPref[ch] = Math.max(newPref[ch], i+K);\n\t\t\t\tif(N-newSuf[ch] <= i+K) newSuf[ch] = Math.max(newSuf[ch], N-i);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tboolean p2wins = (newSuf[0] + newPref[0] + K >= N && newSuf[1] + newPref[1] + K >= N);\n\t\t\tif(!p2wins) hasATie = true;\n\t\t}\n\t\tif(hasATie) draw();\n\t\telse p2Win();\n\t\treturn;\n\t}\n\t\n\tstatic void p1Win() {\n\t\tSystem.out.println(\"tokitsukaze\");\n\t}\n\tstatic void p2Win() {\n\t\tSystem.out.println(\"quailty\");\n\t}\n\tstatic void draw() {\n\t\tSystem.out.println(\"once again\");\n\t}\n\t\n\tstatic class FS{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FS() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {\n\t\t\twhile(st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\t\tcatch(Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n}\n", "complexity": "linear", "problem": "1190_C", "from": "CODEFORCES", "tags": "brute force,games,greedy"}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tnew A().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\tArrays.sort(a);\n\t\tint i = 0;\n\t\twhile (i < n && a[i] == a[0])\n\t\t\ti++;\n\t\tif (i < n)\n\t\t\tSystem.out.println(a[i]);\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t\tsc.close();\n\t}\n\n\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class C {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/C4\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tint charToIndex(char c) {\n\t\tif (Character.isLowerCase(c))\n\t\t\treturn c - 'a';\n\t\telse if (Character.isUpperCase(c))\n\t\t\treturn c - 'A' + 26;\n\t\treturn -1;\n\t}\n\t\n\tint CH_NUM = 52;\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tString s = in.next();\n\t\t\n\t\tboolean[] exist = new boolean[CH_NUM];\n\t\tint typeNum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint idx = charToIndex(s.charAt(i));\n\t\t\tif (!exist[idx]) {\n\t\t\t\texist[idx] = true;\n\t\t\t\ttypeNum++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint get = 0;\n\t\tint tail = 0, head = 0;\n\t\tint res = Integer.MAX_VALUE;\n\t\tint[] cnt = new int[CH_NUM];\n\t\twhile (tail < n || head < n) {\n\t\t\tif (head == n || typeNum == get) {\n\t\t\t\tint idx = charToIndex(s.charAt(tail++));\n\t\t\t\tif (cnt[idx] == 1) get--;\n\t\t\t\tcnt[idx]--;\n\t\t\t} else {\n\t\t\t\tint idx = charToIndex(s.charAt(head++));\n\t\t\t\tif (cnt[idx] == 0) get++; \n\t\t\t\tcnt[idx]++;\n\t\t\t}\n\t\t\tif (typeNum == get)\n\t\t\t\tres = Math.min(res, head - tail);\n\t\t}\n\t\tSystem.out.println(res);\n\t\t/*\n\t\tint[] currentRightMost = new int[CH_NUM];\n\t\tArrays.fill(currentRightMost, -1);\n\t\tint[][] next = new int[n+1][CH_NUM];\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\tArrays.fill(next[i], 1 << 30);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint idx = charToIndex(s.charAt(i));\n\t\t\tfor (int j = 0; j < CH_NUM; j++) if (exist[j]) {\n\t\t\t\tif (currentRightMost[j] != -1)\n\t\t\t\t\tnext[currentRightMost[j]][idx] = Math.min(next[currentRightMost[j]][idx], i);\n\t\t\t}\n\t\t\tcurrentRightMost[idx] = i;\n\t\t}\n\t\t\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor (int leftMost = 0; leftMost < n; leftMost++) {\n\t\t\tint maxRightMost = 0;\n\t\t\tint idx = charToIndex(s.charAt(leftMost));\n\t\t\tfor (int j = 0; j < CH_NUM; j++) if (exist[j]) {\n\t\t\t\tif (j != idx)\n\t\t\t\t\tmaxRightMost = Math.max(maxRightMost, next[leftMost][j]);\n\t\t\t}\n\t\t\tres = Math.min(res, maxRightMost - leftMost + 1);\n\t\t}\n\t\tSystem.out.println(res);\n\t\t*/\n\t}\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew C().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\treturn nextIntArray(n, 0);\n\t\t}\n\n\t\tint[] nextIntArray(int n, int margin) {\n\t\t\tint[] array = new int[n + margin];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i + margin] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\treturn nextLongArray(n, 0);\n\t\t}\n\n\t\tlong[] nextLongArray(int n, int margin) {\n\t\t\tlong[] array = new long[n + margin];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i + margin] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\treturn nextDoubleArray(n, 0);\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n, int margin) {\n\t\t\tdouble[] array = new double[n + margin];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i + margin] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import java.awt.*;\nimport java.io.*;\nimport java.sql.Array;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(\n                    new InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n\n        long nextLong() { return Long.parseLong(next()); }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static final int N=405;\n    static final int mod=1000000007;\n    static final int INF=1000000009;\n    static final int numBit=17;\n    static FastReader r=new FastReader();\n    static PrintWriter pw = new PrintWriter(System.out);\n\n//    call dp[i][j] is number ways can turn on i computer but we just turn on j computer manually.\n    static int [][]dp=new int[N][N];\n    static int []p2=new int[N];\n    static int []fac=new int[N];\n    static int []ifac=new int[N];\n    static int M;\n\n    public static int mul(int a,int b){\n        return (int)(1l*a*b%M);\n    }\n\n    public static int poww(int a,int b){\n        int r=1;\n        while(b>0){\n            if(b%2==1) r=mul(r,a);\n            a=mul(a,a);\n            b>>=1;\n        }\n        return r;\n    }\n\n    public static int inv(int x){\n        return poww(x,M-2);\n    }\n\n    public static int add(int a,int b){\n        a+=b;\n        if(a>=M) a-=M;\n        return a;\n    }\n\n    public static int bino(int n,int k){\n        return mul(fac[n],mul(ifac[n-k],ifac[k]));\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n=r.nextInt();\n        M=r.nextInt();\n        fac[0]=1;\n        ifac[0]=1;\n        p2[0]=1;\n        for(int i=1;i<=n;++i){\n            fac[i]=mul(fac[i-1],i);\n            ifac[i]=inv(fac[i]);\n            p2[i]=mul(p2[i-1],2);\n        }\n        int ans=0;\n        dp[0][0]=1;\n        for(int i=0;i<=n;++i){\n            for(int k=0;k<=i;++k){\n                for(int j=1;j<=n-i+1;++j){\n                    dp[i+j+1][k+j]=add(dp[i+j+1][k+j],mul(dp[i][k],mul(p2[j-1],bino(j+k,j))));\n                }\n            }\n        }\n        for(int i=0;i<=n+1;++i){\n            ans=add(ans,dp[n+1][i]);\n        }\n        pw.print(ans);\n        pw.close();\n    }\n}\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport com.sun.swing.internal.plaf.basic.resources.basic;\n\npublic class Main {\n\n\tPrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\tScanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\n\tprivate void solution() throws IOException {\n\t\tint sx = in.nextInt();\n\t\tint sy = in.nextInt();\n\t\tint n = in.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\tint[] dp = new int[1 << n];\n\t\tint[] prev = new int[1 << n];\n\t\tArrays.fill(dp, Integer.MAX_VALUE / 2);\n\t\tdp[0] = 0;\n\t\tprev[0] = -1;\n\t\tfor (int mask = 0; mask < (1 << n); ++mask) {\n\t\t\tif (dp[mask] != Integer.MAX_VALUE / 2) {\n\t\t\t\tfor (int next = 0; next < n; ++next) {\n\t\t\t\t\tif (((mask >> next) & 1) == 0) {\n\t\t\t\t\t\tint nmask = mask | (1 << next);\n\t\t\t\t\t\tint val = dp[mask] + 2 * getDist(sx, sy, x[next], y[next]);\n\t\t\t\t\t\tif (dp[nmask] > val) {\n\t\t\t\t\t\t\tdp[nmask] = val;\n\t\t\t\t\t\t\tprev[nmask] = mask;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int next2 = next + 1; next2 < n; ++next2) {\n\t\t\t\t\t\t\tif (((nmask >> next2) & 1) == 0) {\n\t\t\t\t\t\t\t\tint nnmask = nmask | (1 << next2);\n\t\t\t\t\t\t\t\tint nval = dp[mask] + getDist(sx, sy, x[next], y[next]) \n\t\t\t\t\t\t\t\t\t\t\t\t\t+ getDist(x[next], y[next], x[next2], y[next2])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ getDist(x[next2], y[next2], sx, sy);\n\t\t\t\t\t\t\t\tif (dp[nnmask] > nval) {\n\t\t\t\t\t\t\t\t\tdp[nnmask] = nval;\n\t\t\t\t\t\t\t\t\tprev[nnmask] = mask;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tres.add(0);\n\t\tint mask = (1 << n) - 1;\n\t\twhile (mask > 0) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (((prev[mask] >> i) & 1) == 0 && ((mask >> i) & 1) == 1) {\n\t\t\t\t\tres.add(i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.add(0);\n\t\t\tmask = prev[mask];\n\t\t}\n\t\tCollections.reverse(res);\n\t\tout.println(dp[(1 << n) - 1]);\n\t\tfor (int i = 0; i < res.size(); ++i) {\n\t\t\tif (i != 0) {\n\t\t\t\tout.print(\" \");\n\t\t\t}\n\t\t\tout.print(res.get(i));\n\t\t}\n\t\tout.println();\n\t\tout.flush();\n\t}\n\n\tprivate int getDist(int x1, int y1, int x2, int y2) {\n\t\treturn (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n\t}\n\n\tprivate class Scanner {\n\n\t\tprivate StringTokenizer tokenizer;\n\t\tprivate BufferedReader reader;\n\n\t\tpublic Scanner(Reader in) {\n\t\t\treader = new BufferedReader(in);\n\t\t\ttokenizer = new StringTokenizer(\"\");\n\t\t}\n\n\t\tpublic boolean hasNext() throws IOException {\n\t\t\twhile (!tokenizer.hasMoreTokens()) {\n\t\t\t\tString tmp = reader.readLine();\n\t\t\t\tif (tmp == null)\n\t\t\t\t\treturn false;\n\t\t\t\ttokenizer = new StringTokenizer(tmp);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\thasNext();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\ttokenizer = new StringTokenizer(\"\");\n\t\t\treturn reader.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().solution();\n\t}\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class BetaRound8_C implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok;\n\n    @Override\n    public void run() {\n        try {\n            long startTime = System.currentTimeMillis();\n            if (System.getProperty(\"ONLINE_JUDGE\") != null) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            tok = new StringTokenizer(\"\");\n            Locale.setDefault(Locale.US);\n            solve();\n            in.close();\n            out.close();\n            long endTime = System.currentTimeMillis();\n            long totalMemory = Runtime.getRuntime().totalMemory();\n            long freeMemory = Runtime.getRuntime().freeMemory();\n            System.err.println(\"Time = \" + (endTime - startTime) + \" ms\");\n            System.err.println(\"Memory = \" + ((totalMemory - freeMemory) / 1024) + \" KB\");\n        } catch (Throwable e) {\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static void main(String[] args) {\n        new Thread(null, new BetaRound8_C(), \"\", 256 * 1024 * 1024).start();\n    }\n\n    // ------------------------------------------------------------------------------\n\n    final int INF = 1000 * 1000 * 1000;\n\n    int x0, y0;\n    int n;\n    int[] x, y;\n\n    int t(int i, int j) {\n        int dx = x[i] - x[j];\n        int dy = y[i] - y[j];\n        return dx * dx + dy * dy;\n    }\n\n    int t0(int i) {\n        int dx = x[i] - x0;\n        int dy = y[i] - y0;\n        return dx * dx + dy * dy;\n    }\n\n    int[] dp;\n    int[] p;\n\n    void solve() throws IOException {\n        x0 = readInt();\n        y0 = readInt();\n        n = readInt();\n        x = new int[n];\n        y = new int[n];\n        for (int i = 0; i < n; i++) {\n            x[i] = readInt();\n            y[i] = readInt();\n        }\n        dp = new int[1 << n];\n        p = new int[1 << n];\n        Arrays.fill(dp, INF);\n        dp[(1 << n) - 1] = 0;\n        get(0);\n        out.println(dp[0]);\n        printPath();\n    }\n\n    int get(int mask) {\n        if (dp[mask] != INF) {\n            return dp[mask];\n        }\n        int res = INF;\n        for (int i = 0; i < n; i++) {\n            if (((1 << i) & mask) == 0) { // \u043f\u043e\u0440\u044f\u0434\u043e\u043a \u043d\u0435\u0432\u0430\u0436\u0435\u043d, \u0442.\u043a. \u0432 i \u0432\u0441\u0435 \u0440\u0430\u0432\u043d\u043e \u0438\u0434\u0442\u0438, \u043f\u043e\u0439\u0434\u0435\u043c \u0442\u0443\u0434\u0430 \u0441\u0440\u0430\u0437\u0443\n                int test = get(mask ^ (1 << i)) + 2 * t0(i);\n                if (res > test) {\n                    res = test;\n                    p[mask] = mask ^ (1 << i);\n                }\n                for (int j = i + 1; j < n; j++) {\n                    if (((1 << j) & mask) == 0) {\n                        test = get(mask ^ (1 << i) ^ (1 << j)) + t0(i)\n                                + t(i, j) + t0(j);\n                        if (res > test) {\n                            res = test;\n                            p[mask] = mask ^ (1 << i) ^ (1 << j);\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        return dp[mask] = res;\n    }\n\n    void printPath() {\n        ArrayList<Integer> ans = new ArrayList<Integer>();\n        ans.add(0);\n        int mask = 0;\n        while (mask != (1 << n) - 1) {\n            for (int i = 0; i < n; i++) {\n                if (((mask ^ p[mask]) & (1 << i)) != 0) {\n                    ans.add(i + 1);\n                }\n            }\n            mask = p[mask];\n            ans.add(0);\n        }\n        for (int x : ans) {\n            out.print(x + \" \");\n        }\n    }\n\n}", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\npublic class VkR2A{\n    static BufferedReader br;\n    public static void main(String args[])throws Exception{\n        br=new BufferedReader(new InputStreamReader(System.in));\n\n        int nm[] = toIntArray();\n        int n = nm[0];\n        int a = nm[1];\n        int b = nm[2];\n        nm=toIntArray();\n        Arrays.sort(nm);\n        int k=nm[b-1];\n        int res=nm[b]-k;\n        System.out.println(res);\n\n    }\n\n\n    /****************************************************************/\n    public static int[] toIntArray()throws Exception{\n       String str[]=br.readLine().split(\" \");\n       int k[]=new int[str.length];\n       for(int i=0;i<str.length;i++){\n            k[i]=Integer.parseInt(str[i]);\n       }\n       return k;\n    }\n    public static int toInt()throws Exception{\n       return Integer.parseInt(br.readLine());\n    }\n    public static long[] toLongArray()throws Exception{\n       String str[]=br.readLine().split(\" \");\n       long k[]=new long[str.length];\n       for(int i=0;i<str.length;i++){\n            k[i]=Long.parseLong(str[i]);\n       }\n       return k;\n    }\n    public static long toLong()throws Exception{\n       return Long.parseLong(br.readLine());\n    }\n    public static double[] toDoubleArray()throws Exception{\n       String str[]=br.readLine().split(\" \");\n       double k[]=new double[str.length];\n       for(int i=0;i<str.length;i++){\n            k[i]=Double.parseDouble(str[i]);\n       }\n       return k;\n    }\n    public static double toDouble()throws Exception{\n       return Double.parseDouble(br.readLine());\n    }\n    public static String toStr()throws Exception{\n       return br.readLine();\n    }\n    public static String[] toStrArray()throws Exception{\n       String str[]=br.readLine().split(\" \");\n       return str;\n    }\n    /****************************************************************/\n\n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class D\n{\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tint n = sc.nextInt();\n\t\tint arr[] = new int[n];\n\t\tlong cum[] = new long[n];\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tarr[i] = sc.nextInt();\n\t\t\n//\t\tint n=(int)2e5;\n//\t\tfor(int i=0;i<n;i++){\n//\t\t\tarr[i]=1;\n//\t\t\tif(i>n/2)\n//\t\t\t\tarr[i]=(int)1e9;\n//\t\t}\n\t\t\n\t\tfor (int i = 0; i < cum.length; i++)\n\t\t{\n\t\t\tcum[i] = arr[i];\n\t\t\tif(i > 0)\n\t\t\t\tcum[i] += cum[i-1];\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans = ans.add(BigInteger.valueOf((1l*(i+1)*arr[i] - cum[i])));\n\t\t\n\t\tHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tans =  ans.subtract(BigInteger.valueOf(map.getOrDefault(arr[i]-1, 0)));\n\t\t\tans = ans.add(BigInteger.valueOf(map.getOrDefault(arr[i]+1, 0)));\n\t\t\tmap.put(arr[i], map.getOrDefault(arr[i], 0)+1);\n\t\t}\n\t\t\n\t\tpw.println(ans);\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\t\t\n\tstatic class Scanner\n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s)\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(String s) throws FileNotFoundException\n\t\t{\n\t\t\tbr = new BufferedReader(new FileReader(new File((s))));\n\t\t}\n\n\t\tpublic String next() throws IOException\n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException\n\t\t{\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-')\n\t\t\t{\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.')\n\t\t\t\t{\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException\n\t\t{\n\t\t\treturn br.ready();\n\t\t}\n\t}\n}\n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), md = sc.nextInt();\n        int k = (n + 1) / 2;int ans = 0;\n        int[][] dp = new int[k + 1][n + 1];dp[0][0] = 1;\n        for (int h = 1; h <= k; h++)\n            for (int l = h; l <= n - h + 1; l++)\n                dp[h][l] = (int) ((dp[h][l - 1] * 2L + dp[h - 1][l - 1]) * h % md);\n        for (int h = 1; h <= k; h++)\n            ans = (ans + dp[h][n - h + 1]) % md;\n        System.out.println(ans);\n    }\n}", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.util.*;\npublic class codeee {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        if(n==1){System.out.println(1); return;}\n        int []mas=new int[n];\n        int sum=0;\n        for (int i = 0; i < n; i++) {\n            mas[i]=sc.nextInt();\n            sum+=mas[i];\n        }\n        Arrays.sort(mas);\n        int sum1=0;\n        int ans=0;\n        for(int i=0;i<n;i++){\n            sum1+=mas[n-i-1];\n            if(sum1>(sum-sum1)){\n                ans=i;\n                break;\n            }\n        }\n        System.out.println(ans+1);\n    }\n}\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.util.concurrent.*;\n\npublic final class on_the_bench\n{\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\tstatic FastScanner sc=new FastScanner(br);\n    static PrintWriter out=new PrintWriter(System.out);\n\tstatic Random rnd=new Random();\n\tstatic int[] parent,size;\n\tstatic int maxn=(int)500;\n\tstatic long mod=(long)(1e9+7);\n\tstatic int[] fact,inv_fact;\n\t\n\tstatic int getParent(int u)\n\t{\n\t\tif(u==parent[u])\n\t\t{\n\t\t\treturn u;\n\t\t}\n\t\t\n\t\telse\n\t\t{\n\t\t\tint val=getParent(parent[u]);parent[u]=val;\n\t\t\t\n\t\t\treturn val;\n\t\t}\n\t}\n\t\n\tstatic void merge(int u,int v)\n\t{\n\t\tint x=getParent(u),y=getParent(v);\n\t\t\n\t\tif(x!=y)\n\t\t{\n\t\t\tparent[y]=x;\n\t\t\t\n\t\t\tsize[x]+=size[y];size[y]=0;\n\t\t}\n\t}\n\t\n\tstatic int add(long a,long b)\n\t{\n\t\tlong ret=a+b;\n\t\t\n\t\tif(ret>=mod)\n\t\t{\n\t\t\tret%=mod;\n\t\t}\n\t\t\n\t\treturn (int)ret;\n\t}\n\t\n\tstatic int mul(long a,long b)\n\t{\n\t\tlong ret=a*b;\n\t\t\n\t\tif(ret>=mod)\n\t\t{\n\t\t\tret%=mod;\n\t\t}\n\t\t\n\t\treturn (int)ret;\n\t}\n\t\n\tstatic int pow(long a,long b)\n\t{\n\t\tlong x=1,y=a;\n\t\t\n\t\twhile(b>0)\n\t\t{\t\n\t\t\tif(b%2==1)\n\t\t\t{\n\t\t\t\tx=mul(x,y);\n\t\t\t}\n\t\t\t\n\t\t\ty=mul(y,y);b=b/2;\n\t\t}\n\t\t\n\t\treturn (int)(x%mod);\n\t}\n\t\n\tstatic void build()\n\t{\n\t\tfact=new int[maxn];inv_fact=new int[maxn];fact[0]=1;\n\n\t\tfor(int i=1;i<maxn;i++)\n\t\t{\n\t\t\tfact[i]=mul(fact[i-1],i);\n\t\t}\n\n\t\tinv_fact[maxn-1]=pow(fact[maxn-1],mod-2);\n\n\t\tfor(int i=maxn-2;i>=0;i--)\n\t\t{\n\t\t\tinv_fact[i]=mul(inv_fact[i+1],(i+1));\n\t\t}\n\t}\n\t\n\tstatic int[] mul_poly(int[] a,int[] b,int deg1,int deg2)\n\t{\t\n\t\tint[] ret=new int[deg1+deg2+1];\n\t\t\n\t\tfor(int i=0;i<=deg1;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=deg2;j++)\n\t\t\t{\n\t\t\t\tint curr=mul(a[i],b[j]);\n\t\t\t\t\n\t\t\t\tret[i+j]=add(ret[i+j],curr);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tstatic int C(int n,int r)\n\t{\n\t\tif(n-r<0 || Math.min(n,r)<0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint val1=fact[n],val2=inv_fact[r],val3=inv_fact[n-r];\n\t\t\n\t\tint mul=mul(val2,val3);\n\t\t\n\t\treturn mul(val1,mul);\n\t}\n\t\n    public static void main(String args[]) throws Exception\n    {\n\t\tint n=sc.nextInt();build();\n\t\t\n\t\tint[] a=new int[n];parent=new int[n];size=new int[n];\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\ta[i]=sc.nextInt();\n\t\t\t\n\t\t\tparent[i]=i;\n\t\t\t\n\t\t\tsize[i]=1;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=i+1;j<n;j++)\n\t\t\t{\n\t\t\t\tlong curr=a[i]*1L*a[j],now=(long)Math.sqrt(curr);\n\t\t\t\t\n\t\t\t\tif(now*now==curr)\n\t\t\t\t{\n\t\t\t\t\tmerge(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<Integer> list=new ArrayList<>();\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(getParent(i)==i)\n\t\t\t{\n\t\t\t\tlist.add(size[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t//\tout.println(list);\n\t\t\n\t\tint res=0;int[] poly=new int[1];poly[0]=1;\n\t\t\n\t\tfor(int i=0;i<list.size();i++)\n\t\t{\n\t\t\tint size=list.get(i);\n\t\t\t\n\t\t\tint[] arr=new int[size];arr[0]=1;\n\t\t\t\n\t\t\tfor(int j=1;j<size;j++)\n\t\t\t{\n\t\t\t\tint now1=C(size,j),now2=mul(fact[size-1],inv_fact[size-1-j]);\n\t\t\t\t\n\t\t\t\tint qq=mul(now1,now2);\n\t\t\t\t\n\t\t\t\tarr[j]=qq;\n\t\t\t}\n\t\t\t\n\t\t\tpoly=mul_poly(poly,arr,poly.length-1,size-1);\n\t\t}\n\t\t\n\t\tfor(int i=1,x=1;i<poly.length;i++,x*=-1)\n\t\t{\n\t\t\tint now=add(x,mod);\n\t\t\t\n\t\t\tint curr=mul(fact[n-i],poly[i]);\n\t\t\t\n\t\t\tcurr=mul(curr,now);\n\t\t\t\n\t\t\tres=add(res,curr);\n\t\t}\n\t\t\n\t//\tout.println(res);\n\t\t\n\t\tint zz=mul(res,mod-1);res=add(fact[n],zz);\n\t\t\n\t\tout.println(res);out.close();\n    }\n}\nclass FastScanner\n{\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n\t\n    public String nextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\t\n\tpublic String next() throws Exception {\n\t\treturn nextToken().toString();\n\t}\n\t\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}", "complexity": "cubic", "problem": "0840_C", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Rustam Musin (PloadyFree@gmail.com)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        int n;\n        double k;\n        boolean[][] g;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.readInt();\n            k = in.readInt();\n\n            g = new boolean[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = in.readInt() == 1;\n                }\n            }\n\n            double answer = solve();\n            out.printFormat(\"%.20f\", answer);\n        }\n\n        private double solve() {\n            int firstPartSize = g.length / 2;\n            int secondPartSize = g.length - firstPartSize;\n\n            int[] firstPart = findMaxCliqueSize(firstPartSize);\n\n            int m1Full = (1 << firstPartSize) - 1;\n            int maxCliqueSize = 1;\n            for (int m = 0; m < 1 << secondPartSize; m++) {\n                if (isClique(secondPartSize, m, firstPartSize)) {\n                    int m1 = m1Full;\n                    for (int j = 0; j < secondPartSize; j++) {\n                        if (bit(m, j)) {\n                            for (int i = 0; i < firstPartSize; i++) {\n                                if (bit(m1, i) && !g[i][j + firstPartSize]) {\n                                    m1 ^= 1 << i;\n                                }\n                            }\n                        }\n                    }\n                    int firstCliqueSize = firstPart[m1];\n                    int secondCliqueSize = Integer.bitCount(m);\n                    int curCliqueSize = firstCliqueSize + secondCliqueSize;\n                    if (curCliqueSize > maxCliqueSize) {\n                        maxCliqueSize = curCliqueSize;\n                    }\n                }\n            }\n\n            return k * k * (maxCliqueSize - 1) / (2 * maxCliqueSize);\n        }\n\n        private int[] findMaxCliqueSize(int size) {\n            int[] dp = new int[1 << size];\n            for (int m = 1; m < 1 << size; m++) {\n                if (isClique(size, m, 0)) {\n                    dp[m] = Integer.bitCount(m);\n                }\n            }\n            for (int m = 1; m < 1 << size; m++) {\n                for (int i = 0; i < size; i++) {\n                    if ((m >> i & 1) == 0) {\n                        dp[m | (1 << i)] = Math.max(dp[m | (1 << i)], dp[m]);\n                    }\n                }\n            }\n            return dp;\n        }\n\n        private boolean isClique(int size, int m, int offset) {\n            for (int i = 0; i < size; i++) {\n                if (bit(m, i)) {\n                    for (int j = i + 1; j < size; j++) {\n                        if (bit(m, j) && !g[i + offset][j + offset]) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n\n        private boolean bit(int m, int b) {\n            return (m >> b & 1) != 0;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void printFormat(String format, Object... objects) {\n            writer.printf(format, objects);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n", "complexity": "np", "problem": "0839_E", "from": "CODEFORCES", "tags": "brute force,graphs,math,meet-in-the-middle"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class CFA {\n  BufferedReader br;\n  PrintWriter out;\n  StringTokenizer st;\n  boolean eof;\n  private static final long MOD = 1000L * 1000L * 1000L + 7;\n  private static final int[] dx = {0, -1, 0, 1};\n  private static final int[] dy = {1, 0, -1, 0};\n  private static final String yes = \"Yes\";\n  private static final String no = \"No\";\n\n  void solve() {\n    int T = nextInt();\n//    int T = 1;\n    for (int i = 0; i < T; i++) {\n      helper();\n    }\n  }\n\n  void helper() {\n    int n = nextInt();\n    int m = nextInt();\n    int[][] mat = new int[n][m];\n    List<Integer> all = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      mat[i] = nextIntArr(m);\n      for (int v : mat[i]) {\n        all.add(v);\n      }\n    }\n    Collections.sort(all);\n    Collections.reverse(all);\n    if (n < 4) {\n      int res = 0;\n      for (int i = 0; i < n; i++) {\n        res += all.get(i);\n      }\n      outln(res);\n      return;\n    }\n    int res = 0;\n    int[] maxCol = new int[m];\n    for (int j = 0; j < m; j++) {\n      int tmp = 0;\n      for (int i = 0; i < n; i++) {\n        tmp = Math.max(tmp, mat[i][j]);\n      }\n      maxCol[j] = tmp;\n    }\n    for (int j1 = 0; j1 < m; j1++) {\n      List<Integer> col = new ArrayList<>();\n      for (int i = 0; i < n; i++) {\n        col.add(mat[i][j1]);\n      }\n      Collections.sort(col);\n      Collections.reverse(col);\n\n      List<Integer> others = new ArrayList<>();\n      for (int j2 = 0; j2 < m; j2++) {\n        if (j2 != j1) {\n          others.add(maxCol[j2]);\n        }\n      }\n\n      Collections.sort(others);\n      Collections.reverse(others);\n\n      // Take one from col, three from others\n      if (others.size() >= 3) {\n        int tmp = col.get(0);\n        for (int i = 0; i < 3; i++) {\n          tmp+= others.get(i);\n        }\n        res = Math.max(res, tmp);\n      }\n      // Take two from col, two from others\n      if (others.size() >= 2) {\n        int tmp = col.get(0) + col.get(1);\n        tmp += others.get(0) + others.get(1);\n        res = Math.max(res, tmp);\n      }\n      // Take three from col, one from others\n      if (others.size() >= 1) {\n        int tmp = col.get(0) + col.get(1) + col.get(2);\n        tmp += others.get(0);\n        res = Math.max(res, tmp);\n      }\n      // Take all from col\n      res = Math.max(res, col.get(0) + col.get(1) + col.get(2) + col.get(3));\n    }\n\n    for (int j1 = 0; j1 < m; j1++) {\n      for (int j2 = 0; j2 < m; j2++) {\n        if (j2 != j1) {\n          for (int i1 = 0; i1 <= 3; i1++) {\n            for (int i = 0; i <= 3; i++) {\n              int tmp = mat[i1][j1] + mat[(i1 + 1) % 4][j1];\n              tmp += mat[i][j2] + mat[(i + 1) % 4][j2];\n              res = Math.max(res, tmp);\n            }\n          }\n\n          int m1 = mat[0][j1] + mat[2][j1];\n          m1 = Math.max(m1, mat[1][j1] + mat[3][j1]);\n          int m2 = mat[0][j2] + mat[2][j2];\n          m2 = Math.max(m2, mat[1][j2] + mat[3][j2]);\n          res = Math.max(res, m1 + m2);\n        }\n      }\n    }\n\n    outln(res);\n  }\n\n  void shuffle(long[] a) {\n    int n = a.length;\n    for(int i = 0; i < n; i++) {\n      int r = i + (int) (Math.random() * (n - i));\n      long tmp = a[i];\n      a[i] = a[r];\n      a[r] = tmp;\n    }\n  }\n\n  int gcd(int a, int b) {\n    while(a != 0 && b != 0) {\n      int c = b;\n      b = a % b;\n      a = c;\n    }\n    return a + b;\n  }\n  private void outln(Object o) {\n    out.println(o);\n  }\n  private void out(Object o) {\n    out.print(o);\n  }\n  private void formatPrint(double val) {\n    outln(String.format(\"%.9f%n\", val));\n  }\n  public CFA() {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    out = new PrintWriter(System.out);\n    solve();\n    out.close();\n  }\n  public static void main(String[] args) {\n    new CFA();\n  }\n\n  public long[] nextLongArr(int n) {\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n      res[i] = nextLong();\n    return res;\n  }\n  public int[] nextIntArr(int n) {\n    int[] res = new int[n];\n    for(int i = 0; i < n; i++)\n      res[i] = nextInt();\n    return res;\n  }\n  public String nextToken() {\n    while (st == null || !st.hasMoreTokens()) {\n      try {\n        st = new StringTokenizer(br.readLine());\n      } catch (Exception e) {\n        eof = true;\n        return null;\n      }\n    }\n    return st.nextToken();\n  }\n  public String nextString() {\n    try {\n      return br.readLine();\n    } catch (IOException e) {\n      eof = true;\n      return null;\n    }\n  }\n  public int nextInt() {\n    return Integer.parseInt(nextToken());\n  }\n  public long nextLong() {\n    return Long.parseLong(nextToken());\n  }\n  public double nextDouble() {\n    return Double.parseDouble(nextToken());\n  }\n}\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import java.util.*;\n\npublic class cf11d {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tboolean[][] g = new boolean[n][n];\n\t\tboolean[] ok = new boolean[1<<n];\n\t\tint[] f = new int[1<<n];\n\t\tfor(int i=1; i<(1<<n); i++) {\n\t\t\tok[i] = Integer.bitCount(i)>=3;\n\t\t\tf[i] = first(i);\n\t\t}\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tg[a][b] = g[b][a] = true;\n\t\t}\n\t\tlong[][] dp = new long[n][1<<n];\n\t\tfor(int i=0; i<n; i++)\n\t\t\tdp[i][1<<i] = 1;\n\t\tfor(int i=1; i<(1<<n); i++)\n\t\t\tfor(int j=0; j<n; j++)\n\t\t\t\tfor(int k=f[i]+1; k<n; k++)\n\t\t\t\t\tif((i&(1<<k)) == 0 && g[j][k])\n\t\t\t\t\t\tdp[k][i^(1<<k)] += dp[j][i];\n\t\tlong ret = 0;\n\t\tfor(int i=1; i<(1<<n); i++)\n\t\t\tfor(int j=0; j<n; j++)\n\t\t\t\tif(ok[i] && j != f[i])\n\t\t\t\t\tret += g[j][f[i]]?dp[j][i]:0;\n\t\tSystem.out.println(ret/2);\n\t}\n\tstatic int first(int x) {\n\t\tint ret = 0;\n\t\twhile(x%2==0) {\n\t\t\tx/=2;\n\t\t\tret++;\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n/*\n\n19 171\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n2 13\n2 14\n2 15\n2 16\n2 17\n2 18\n2 19\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 13\n3 14\n3 15\n3 16\n3 17\n3 18\n3 19\n4 5\n4 6\n4 7\n4 8\n4 9\n4 10\n4 11\n4 12\n4 13\n4 14\n4 15\n4 16\n4 17\n4 18\n4 19\n5 6\n5 7\n5 8\n5 9\n5 10\n5 11\n5 12\n5 13\n5 14\n5 15\n5 16\n5 17\n5 18\n5 19\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14\n6 15\n6 16\n6 17\n6 18\n6 19\n7 8\n7 9\n7 10\n7 11\n7 12\n7 13\n7 14\n7 15\n7 16\n7 17\n7 18\n7 19\n8 9\n8 10\n8 11\n8 12\n8 13\n8 14\n8 15\n8 16\n8 17\n8 18\n8 19\n9 10\n9 11\n9 12\n9 13\n9 14\n9 15\n9 16\n9 17\n9 18\n9 19\n10 11\n10 12\n10 13\n10 14\n10 15\n10 16\n10 17\n10 18\n10 19\n11 12\n11 13\n11 14\n11 15\n11 16\n11 17\n11 18\n11 19\n12 13\n12 14\n12 15\n12 16\n12 17\n12 18\n12 19\n13 14\n13 15\n13 16\n13 17\n13 18\n13 19\n14 15\n14 16\n14 17\n14 18\n14 19\n15 16\n15 17\n15 18\n15 19\n16 17\n16 18\n16 19\n17 18\n17 19\n18 19\n\n*/", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int k = in.nextInt();\n        int[] A = new int[n];\n        for (int i = 0; i < n; i++)\n            A[i] = in.nextInt();\n        Arrays.sort(A);\n        int cnt = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            if (k >= m) {\n                System.out.println(cnt);\n                return;\n            }\n            cnt++;\n            k += A[i] - 1;\n        }\n        if (k >= m)\n            System.out.println(cnt);\n        else\n            System.out.println(-1);\n    }\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "\n\nimport java.awt.Point;\n\nimport java.io.BufferedReader;\n\nimport java.io.BufferedWriter;\n\nimport java.io.FileReader;\n\nimport java.io.FileWriter;\n\nimport java.io.IOException;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\n\n\npublic class Main {\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t\n\n\t\tBufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n\n\t\t\n\n\t\tString dimensions = br.readLine();\n\n\t\tString extractDim = \"\";\n\n\t\tint n = 0, m;\n\n\t\tfor (int i = 0 ; i < dimensions.length() ; i++)\n\n\t\t{\n\n\t\t\tif(dimensions.charAt(i) == ' ')\n\n\t\t\t{\n\n\t\t\t\tn = Integer.parseInt(extractDim);\n\n\t\t\t\textractDim = \"\";\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\textractDim += dimensions.charAt(i);\n\n\t\t}\n\n\t\tm = Integer.parseInt(extractDim); \n\n\t\t\n\n\t\tString burningTrees = br.readLine();\n\n\t\t\n\n\t\tint k = Integer.parseInt(burningTrees);\t\t\n\n\t\t\n\n\t\tPoint[] coord = new Point[k];\n\n\t\t\n\n\t\tString coordSet = br.readLine();\n\n\t\tint spaceCount = 0;\n\n\t\tString newCoord = \"\";\n\n\t\tint s = 0;\n\n\t\tfor(int i = 0 ; i < coordSet.length() ; i++)\n\n\t\t{\n\n\t\t\tif(coordSet.charAt(i) == ' ')\n\n\t\t\t\tspaceCount++;\n\n\t\t\t\n\n\t\t\tif(spaceCount == 2)\n\n\t\t\t{\n\n\t\t\t\tString extractCoord = \"\";\n\n\t\t\t\tint x = 0, y;\n\n\t\t\t\tfor (int j = 0 ; j < newCoord.length() ; j++)\n\n\t\t\t\t{\n\n\t\t\t\t\tif(newCoord.charAt(j) == ' ')\n\n\t\t\t\t\t{\n\n\t\t\t\t\t\tx = Integer.parseInt(extractCoord);\n\n\t\t\t\t\t\textractCoord = \"\";\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\textractCoord += newCoord.charAt(j);\n\n\t\t\t\t}\n\n\t\t\t\ty = Integer.parseInt(extractCoord);\n\n\t\t\t\t\n\n\t\t\t\tcoord[s] = new Point(x,y);\n\n\t\t\t\ts++;\n\n\t\t\t\tnewCoord = \"\";\n\n\t\t\t\tspaceCount = 0;\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tnewCoord += coordSet.charAt(i);\n\n\t\t}\n\n\t\t\n\n\t\tString extractCoord = \"\";\n\n\t\tint x = 0, y;\n\n\t\tfor (int j = 0 ; j < newCoord.length() ; j++)\n\n\t\t{\n\n\t\t\tif(newCoord.charAt(j) == ' ')\n\n\t\t\t{\n\n\t\t\t\tx = Integer.parseInt(extractCoord);\n\n\t\t\t\textractCoord = \"\";\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\textractCoord += newCoord.charAt(j);\n\n\t\t}\n\n\t\ty = Integer.parseInt(extractCoord);\n\n\t\t\n\n\t\tcoord[s] = new Point(x,y);\n\n\t\ts++;\n\n\t\t\n\n\t\tbr.close();\n\n\t\t\n\n\t\tint[][] forest = new int[n+2][m+2];\n\n\t\t\n\n\t\tfor(int i = 0 ; i < forest.length ; i++)\n\n\t\t{\n\n\t\t\tfor(int j = 0 ; j < forest[i].length ; j++)\n\n\t\t\t{\n\n\t\t\t\tif(i == 0 || i == n+1 || j == 0 || j == m+1 )\n\n\t\t\t\t\tforest[i][j] = 0;\n\n\t\t\t\telse\n\n\t\t\t\t\tforest[i][j] = 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\t\n\n\t\tQueue<Point> q = new LinkedList<>();\n\n\t\t\n\n\t\tfor(int i = 0 ; i < coord.length ; i++)\n\n\t\t{\n\n\t\t\tforest[coord[i].x][coord[i].y] = 0;\n\n\t\t\tq.add(coord[i]);\n\n\t\t}\n\n\t\t\n\n\t\tPoint tree = new Point();\n\n\t\twhile(!q.isEmpty())\n\n\t\t{\n\n\t\t\tPoint temp = q.remove();\n\n\t\t\tforest[temp.x][temp.y] = 0;\n\n\t\t\t\n\n\t\t\tif(q.isEmpty())\n\n\t\t\t\ttree = new Point(temp.x ,temp.y);\n\n\t\t\tfor(int i = -1 ; i <= 1 ; i++)\n\n\t\t\t{\n\n\t\t\t\tfor(int j = -1; j <= 1; j++)\n\n\t\t\t\t{\n\n\t\t\t\t\tif(i != 0 && j != 0 || i == 0 && j == 0)\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif(forest[temp.x+i][temp.y+j] == 0)\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\telse\n\n\t\t\t\t\t{\n\n\t\t\t\t\t\tforest[temp.x+i][temp.y+j] = 0;\n\n\t\t\t\t\t\tq.add(new Point(temp.x+i , temp.y+j));\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t\n\n\t\t}\n\n\t\t\n\n\t\t\n\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(\"output.txt\"));\n\n\t\tbw.write(tree.x + \" \" + tree.y);\n\n\t\tbw.close();\n\n\t\t\n\n\t\n\n\t}\n\n\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\n\tpublic void _main() throws IOException {\n\t\tint n = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\tArrays.sort(a);\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tif (a[i] != a[0]) {\n\t\t\t\tout.print(a[i]);\n\t\t\t\treturn;\n\t\t\t}\n\t\tout.print(\"NO\");\n\t}\n\n\tprivate BufferedReader in;\n\tprivate PrintWriter out;\n\tprivate StringTokenizer st;\n\n\tprivate String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString rl = in.readLine();\n\t\t\tif (rl == null)\n\t\t\t\treturn null;\n\t\t\tst = new StringTokenizer(rl);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new Main()).start();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\t_main();\n\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(202);\n\t\t}\n\t}\n\n}\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n\tprivate static StreamTokenizer in;\n\tprivate static PrintWriter out;\n\tstatic {\n\t\tin = new StreamTokenizer(new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in)));\n\t\tout = new PrintWriter(System.out);\n\t}\n\n\tprivate static int nextInt() throws Exception {\n\t\tin.nextToken();\n\t\treturn (int) in.nval;\n\t}\n\n\tprivate static double nextDouble() throws Exception {\n\t\tin.nextToken();\n\t\treturn in.nval;\n\t}\n\n\tprivate static String nextString() throws Exception {\n\t\tin.nextToken();\n\t\treturn in.sval;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint n = nextInt(), k = nextInt(), A = nextInt(), r = n + k - 1;\n\t\tint[][] s = new int[n][];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] = new int[] { nextInt(), nextInt() };\n\t\t}\n\t\tdouble max = 0;\n\t\tint[] prb = new int[n];\n\t\tfor (int u = (1 << r); u >= 0; u--) {\n\t\t\t// \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u043c \u043d\u0430 n-1 \u0435\u0434\u0438\u043d\u0438\u0447\u0435\u043a\n\t\t\tint ones = 0;\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tif ((u & (1 << i)) != 0) {\n\t\t\t\t\tones++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ones != n - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u043b\u0438. \u0440\u0430\u0441\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432\n\t\t\tones = 0;\n\t\t\tint p = 0;\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tif ((u & (1 << i)) == 0) {\n\t\t\t\t\tones++;\n\t\t\t\t} else {\n\t\t\t\t\tprb[p] = ones * 10;\n\t\t\t\t\tp++;\n\t\t\t\t\tones = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprb[p] = ones * 10;\n\t\t\tp++;\n\t\t\tones = 0;\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (prb[i] > 100 - s[i][1])\n\t\t\t\t\tprb[i] = 100 - s[i][1];\n\t\t\t\ts[i][1] = prb[i] + s[i][1];\n\t\t\t}\n\t\t\tfor (int i = (1 << n) - 1; i >= 0; i--) {\n\t\t\t\tdouble prob = 1;\n\t\t\t\tint lvl = 0;\n\t\t\t\tint kill = 0;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif ((i & (1 << j)) != 0) {\n\t\t\t\t\t\tprob *= s[j][1] / 100.0;\n\t\t\t\t\t\tkill--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlvl += s[j][0];\n\t\t\t\t\t\tprob *= (1 - s[j][1] / 100.0);\n\t\t\t\t\t\tkill++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (kill >= 0) {\n\t\t\t\t\tsum += prob * ((double) A / (A + lvl));\n\t\t\t\t} else {\n\t\t\t\t\tsum += prob;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ts[i][1] = -prb[i] + s[i][1];\n\t\t\t}\n\t\t\tmax = Math.max(max, sum);\n\t\t}\n\t\tout.println(max);\n\t\tout.flush();\n\t}\n}\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Template implements Runnable {\n    private void solve() throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        boolean[][] g = new boolean[n][n];\n        for (int i = 0; i < m; ++i) {\n            int a = nextInt() - 1;\n            int b = nextInt() - 1;\n            g[a][b] = true;\n            g[b][a] = true;\n        }\n        /*for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                g[i][j] = true;*/\n        long[] am = new long[n + 1];\n        long[][] ways = new long[1 << n][n];\n        for (int start = 0; start < n; ++start) {\n            for (int mask = 0; mask < (1 << (n - start)); ++mask)\n                for (int last = start; last < n; ++last) {\n                    ways[mask][last - start] = 0;\n                }\n            ways[1][0] = 1;\n            for (int mask = 0; mask < (1 << (n - start)); ++mask) {\n                int cnt = 0;\n                int tmp = mask;\n                while (tmp > 0) {\n                    ++cnt;\n                    tmp = tmp & (tmp - 1);\n                }\n                for (int last = start; last < n; ++last)\n                    if (ways[mask][last - start] > 0) {\n                        long amm = ways[mask][last - start]; \n                        for (int i = start; i < n; ++i)\n                            if ((mask & (1 << (i - start))) == 0 && g[last][i]) {\n                                ways[mask | (1 << (i - start))][i - start] += amm;\n                            }\n                        if (g[last][start])\n                            am[cnt] += ways[mask][last - start];\n                    }\n            }\n        }\n        long res = 0;\n        for (int cnt = 3; cnt <= n; ++cnt) {\n            if (am[cnt] % (2) != 0)\n                throw new RuntimeException();\n            res += am[cnt] / (2);\n        }\n        writer.println(res);\n    }\n\n\n    public static void main(String[] args) {\n        new Template().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n\npublic class D {\n\n    private static void run() throws IOException {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int p = in.nextInt();\n\n        int[] dx = {1, -1, 0, 0};\n        int[] dy = {0, 0, 1, -1};\n        int[][][] map = new int[n][m][4];\n\n        ArrayList<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m - 1; j++) {\n                int len = in.nextInt();\n                edges.add(new Edge(new Point[]{new Point(i, j), new Point(i, j + 1)}, len));\n                map[i][j][2] = map[i][j + 1][3] = len;\n            }\n        }\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < m; j++) {\n                int len = in.nextInt();\n                edges.add(new Edge(new Point[]{new Point(i, j), new Point(i + 1, j)}, len));\n                map[i][j][0] = map[i + 1][j][1] = len;\n            }\n        }\n        if (p % 2 != 0) {\n            int[] ans = new int[m];\n            for (int i = 0; i < m; i++) {\n                ans[i] = -1;\n            }\n            for (int i = 0; i < n; i++) {\n                print_array(ans);\n            }\n            return;\n        }\n\n        edges.sort(Comparator.comparingInt(o -> o.len));\n\n        int[][][] dp = new int[2][n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int min = Integer.MAX_VALUE;\n                for (int k = 0; k < 4; k++) {\n                    if (map[i][j][k] == 0) continue;\n                    min = Math.min(min, map[i][j][k]);\n                }\n                dp[1][i][j] = min * 2;\n            }\n        }\n\n        for (int k = 2; k <= p / 2; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    dp[k & 1][i][j] = Integer.MAX_VALUE;\n                    for (int d = 0; d < 4; d++) {\n                        int nx = i + dx[d];\n                        int ny = j + dy[d];\n                        if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n\n                        dp[k & 1][i][j] = Math.min(dp[(k - 1) & 1][nx][ny] + map[i][j][d] * 2, dp[k&1][i][j]);\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            print_array(dp[(p / 2) & 1][i]);\n        }\n    }\n\n    static class Edge {\n        Point[] points;\n        int len;\n\n        public Edge(Point[] points, int len) {\n            this.points = points;\n            this.len = len;\n        }\n    }\n\n    static class Point {\n        final int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new Reader();\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n\n//        int t = in.nextInt();\n//        for (int i = 0; i < t; i++) {\n//        }\n        run();\n\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    private static int gcd(int a, int b) {\n        if (a == 0 || b == 0)\n            return 0;\n        while (b != 0) {\n            int tmp;\n            tmp = a % b;\n            a = b;\n            b = tmp;\n        }\n        return a;\n    }\n\n    static final long mod = 1000000007;\n\n    static long pow_mod(long a, long b) {\n        long result = 1;\n        while (b != 0) {\n            if ((b & 1) != 0) result = (result * a) % mod;\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return result;\n    }\n\n    private static long multiplied_mod(long... longs) {\n        long ans = 1;\n        for (long now : longs) {\n            ans = (ans * now) % mod;\n        }\n        return ans;\n    }\n\n    @SuppressWarnings(\"FieldCanBeLocal\")\n    private static Reader in;\n    private static PrintWriter out;\n\n    private static void print_array(int[] array) {\n        for (int now : array) {\n            out.print(now);\n            out.print(' ');\n        }\n        out.println();\n    }\n\n    private static void print_array(long[] array) {\n        for (long now : array) {\n            out.print(now);\n            out.print(' ');\n        }\n        out.println();\n    }\n\n    static class Reader {\n        private static final int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            final byte[] buf = new byte[1024]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    break;\n                }\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextSign() throws IOException {\n            byte c = read();\n            while ('+' != c && '-' != c) {\n                c = read();\n            }\n            return '+' == c ? 0 : 1;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        public int skip() throws IOException {\n            int b;\n            // noinspection ALL\n            while ((b = read()) != -1 && isSpaceChar(b)) {\n                ;\n            }\n            return b;\n        }\n\n        public char nc() throws IOException {\n            return (char) skip();\n        }\n\n        public String next() throws IOException {\n            int b = skip();\n            final StringBuilder sb = new StringBuilder();\n            while (!isSpaceChar(b)) { // when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) {\n                buffer[0] = -1;\n            }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) {\n                fillBuffer();\n            }\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            din.close();\n        }\n\n    }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "// https://codeforces.com/contest/1185/submission/55800229 (rainboy)\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1185G2 {\n\tstatic final int MD = 1000000007;\n\tstatic int[][] solve1(int[] aa, int t, int n) {\n\t\tint[][] da = new int[t + 1][n + 1];\n\t\tda[0][0] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = aa[i];\n\t\t\tfor (int s = t - 1; s >= 0; s--)\n\t\t\t\tfor (int m = 0; m < n; m++) {\n\t\t\t\t\tint x = da[s][m];\n\t\t\t\t\tif (x != 0) {\n\t\t\t\t\t\tint s_ = s + a;\n\t\t\t\t\t\tif (s_ <= t)\n\t\t\t\t\t\t\tda[s_][m + 1] = (da[s_][m + 1] + x) % MD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn da;\n\t}\n\tstatic int[][][] solve2(int[] aa, int[] bb, int t, int na, int nb) {\n\t\tint[][] da = solve1(aa, t, na);\n\t\tint[][][] dab = new int[t + 1][na + 1][nb + 1];\n\t\tfor (int s = 0; s <= t; s++)\n\t\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\t\tdab[s][ma][0] = da[s][ma];\n\t\tfor (int i = 0; i < nb; i++) {\n\t\t\tint b = bb[i];\n\t\t\tfor (int s = t - 1; s >= 0; s--)\n\t\t\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\t\t\tfor (int mb = 0; mb < nb; mb++) {\n\t\t\t\t\t\tint x = dab[s][ma][mb];\n\t\t\t\t\t\tif (x != 0) {\n\t\t\t\t\t\t\tint s_ = s + b;\n\t\t\t\t\t\t\tif (s_ <= t)\n\t\t\t\t\t\t\t\tdab[s_][ma][mb + 1] = (dab[s_][ma][mb + 1] + x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t}\n\t\treturn dab;\n\t}\n\tstatic int[][][] init(int n, int na, int nb, int nc) {\n\t\tint[][][] dp = new int[na + 1][nb + 1][nc + 1];\n\t\tint[][][][] dq = new int[na + 1][nb + 1][nc + 1][3];\n\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\tfor (int mb = 0; mb <= nb; mb++)\n\t\t\t\tfor (int mc = 0; mc <= nc; mc++)\n\t\t\t\t\tif (ma == 0 && mb == 0 && mc == 0) {\n\t\t\t\t\t\tdp[ma][mb][mc] = 1;\n\t\t\t\t\t\tdq[ma][mb][mc][0] = dq[ma][mb][mc][1] = dq[ma][mb][mc][2] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint x0 = ma > 0 ? (int) ((long) dq[ma - 1][mb][mc][0] * ma % MD) : 0;\n\t\t\t\t\t\tint x1 = mb > 0 ? (int) ((long) dq[ma][mb - 1][mc][1] * mb % MD) : 0;\n\t\t\t\t\t\tint x2 = mc > 0 ? (int) ((long) dq[ma][mb][mc - 1][2] * mc % MD) : 0;\n\t\t\t\t\t\tdp[ma][mb][mc] = (int) (((long) x0 + x1 + x2) % MD);\n\t\t\t\t\t\tdq[ma][mb][mc][0] = (x1 + x2) % MD;\n\t\t\t\t\t\tdq[ma][mb][mc][1] = (x2 + x0) % MD;\n\t\t\t\t\t\tdq[ma][mb][mc][2] = (x0 + x1) % MD;\n\t\t\t\t\t}\n\t\treturn dp;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint t = Integer.parseInt(st.nextToken());\n\t\tint[] aa = new int[n];\n\t\tint[] bb = new int[n];\n\t\tint[] cc = new int[n];\n\t\tint na = 0, nb = 0, nc = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint a = Integer.parseInt(st.nextToken());\n\t\t\tint g = Integer.parseInt(st.nextToken());\n\t\t\tif (g == 1)\n\t\t\t\taa[na++] = a;\n\t\t\telse if (g == 2)\n\t\t\t\tbb[nb++] = a;\n\t\t\telse\n\t\t\t\tcc[nc++] = a;\n\t\t}\n\t\tint[][][] dp = init(n, na, nb, nc);\n\t\tint[][][] dab = solve2(aa, bb, t, na, nb);\n\t\tint[][] dc = solve1(cc, t, nc);\n\t\tint ans = 0;\n\t\tfor (int tab = 0; tab <= t; tab++) {\n\t\t\tint tc = t - tab;\n\t\t\tfor (int ma = 0; ma <= na; ma++)\n\t\t\t\tfor (int mb = 0; mb <= nb; mb++) {\n\t\t\t\t\tint xab = dab[tab][ma][mb];\n\t\t\t\t\tif (xab == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int mc = 0; mc <= nc; mc++) {\n\t\t\t\t\t\tint xc = dc[tc][mc];\n\t\t\t\t\t\tif (xc == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tans = (int) ((ans + (long) xab * xc % MD * dp[ma][mb][mc]) % MD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "complexity": "cubic", "problem": "1185_G2", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\n\npublic class D11 {\n\n\tstatic StreamTokenizer in;\n\tstatic PrintWriter out;\n\t\n\tstatic int nextInt() throws IOException {\n\t\tin.nextToken();\n\t\treturn (int)in.nval;\n\t}\n\t\n\tstatic String nextString() throws IOException {\n\t\tin.nextToken();\n\t\treturn in.sval;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\tout = new PrintWriter(System.out);\n\n\t\tn = nextInt();\n\t\tm = nextInt();\n\t\t\n\t\tg = new boolean[n][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = nextInt()-1, b = nextInt()-1;\n\t\t\tg[a][b] = g[b][a] = true;\n\t\t}\n\t\t\n\t\tlong ans = 0;\n\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\tlong cur = solve(i);\n\t\t\tans += cur;\n\t\t}\n\t\t\n\t\tout.println(ans/2);\n\t\t\n\t\tout.flush();\n\t}\n\n\tstatic int n, m;\n\tstatic boolean[][] g;\n\t\n\tstatic long solve(int v) {\n\t\tlong[][] memo = new long[v][1 << v];\n\t\t\n\t\tfor (int i = 0; i < v; i++)\n\t\t\tif (g[v][i])\n\t\t\t\tmemo[i][1 << i] = 1;\n\t\t\n\t\tfor (int mask = 1; mask < (1 << v); mask++)\n\t\t\tfor (int i = 0; i < v; i++) if ((mask&(1 << i)) != 0)\n\t\t\t\tfor (int j = 0; j < v; j++) if (g[i][j] && (mask&(1 << j)) == 0)\n\t\t\t\t\tmemo[j][mask|(1 << j)] += memo[i][mask];\n\t\t\n\t\tlong res = 0;\n\t\tfor (int mask = 1; mask < (1 << v); mask++)\n\t\t\tfor (int i = 0; i < v; i++)\n\t\t\t\tif (Integer.bitCount(mask) > 1 && g[v][i]) res += memo[i][mask];\n\t\treturn res;\n\t}\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\n\tFastReader in = new FastReader();\n\tPrintWriter out = new PrintWriter(System.out);\n\tvoid run(){\n\t\tint t=in.nextInt();\n\t\tfor(int i=0;i<t;i++) {\n\t\t\tout.println(work());\n\t\t}\n\t\tout.flush();\n\t}\n\tlong mod=1000000007;\n\tlong gcd(long a,long b) {\n\t\treturn b==0?a:gcd(b,a%b);\n\t}\n\tint work() {\n\t\tint n=in.nextInt();\n\t\tint m=in.nextInt();\n\t\tint[][] A=new int[n][m];\n\t\tint[][] B=new int[n][m];\n\t\tint[][] R=new int[m][2];\n\t\tfor(int i=0;i<m;i++)R[i][1]=i;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tA[i][j]=in.nextInt();\n\t\t\t\tR[j][0]=Math.max(R[j][0], A[i][j]);\n\t\t\t}\n\t\t}\n\t\tArrays.sort(R,new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] arr1,int[] arr2) {\n\t\t\t\treturn arr2[0]-arr1[0];\n\t\t\t}\n\t\t});\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tint index=R[j][1];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tB[i][j]=A[i][index];\n\t\t\t}\n\t\t}\n\t\tm=Math.min(n, m);\n\t\tint[][] dp=new int[m][1<<n];\n\t\tint[][] rec=new int[m][1<<n];\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tfor(int s=0;s<n;s++) {//\u8f6c\n\t\t\t\tfor(int i=1;i<1<<n;i++) {\n\t\t\t\t\tint sum=0;\n\t\t\t\t\tfor(int b=0;b<n;b++) {\n\t\t\t\t\t\tif(((1<<b)&i)>0) {\n\t\t\t\t\t\t\tsum+=B[(b+s)%n][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trec[j][i]=Math.max(sum, rec[j][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tfor(int i=0;i<1<<n;i++) {\n\t\t\t\tif(j==0) {\n\t\t\t\t\tdp[j][i]=rec[j][i];\n\t\t\t\t}else {\n\t\t\t\t\tfor(int p=i+1;;p++) {\n\t\t\t\t\t\tif(p>=1<<n)break;\n\t\t\t\t\t\tp=p|i;\n\t\t\t\t\t\tdp[j][p]=Math.max(dp[j][p], rec[j][i]+dp[j-1][p^i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[m-1][(1<<n)-1];\n\t}\n}\n\n\n\nclass FastReader\n{\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic FastReader()\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tpublic String next() \n\t{\n\t\tif(st==null || !st.hasMoreElements())\n\t\t{\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() \n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong()\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n}", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "/**\n * BaZ :D\n */\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\npublic class Main\n{\n    static MyScanner scan;\n    static PrintWriter pw;\n    static long MOD = 1_000_000_007;\n    static long INF = 1_000_000_000_000_000_000L;\n    static long inf = 2_000_000_000;\n    public static void main(String[] args) {\n        new Thread(null, null, \"BaZ\", 1 << 27) {\n            public void run() {\n                try {\n                    solve();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n    static int n,m,need,a[][],dp[][][],real[][];\n    static void solve() throws IOException\n    {\n        //initIo(true);\n        initIo(false);\n        StringBuilder sb = new StringBuilder();\n        int t = ni();\n        while(t-->0) {\n            n = ni();\n            m = ni();\n            a = new int[n][m];\n            for(int i=0;i<n;++i) {\n                for(int j=0;j<m;++j) {\n                    a[i][j] = ni();\n                }\n            }\n            need = min(n,m);\n            Pair max_in_cols[] = new Pair[m];\n            for(int COL=0;COL<m;++COL) {\n                int max = 0;\n                for(int i=0;i<n;++i) {\n                    max = max(max, a[i][COL]);\n                }\n                max_in_cols[COL] = new Pair(max, COL);\n            }\n            real = new int[n][need];\n            Arrays.sort(max_in_cols);\n            for(int i=0;i<need;++i) {\n                int COL = max_in_cols[m-1-i].y;\n                for(int j=0;j<n;++j) {\n                    real[j][i] = a[j][COL];\n                }\n            }\n//            pl(\"need : \"+need);\n//            pa(\"Real\", real);\n            dp = new int[need][n+1][(1<<n)];\n            for(int i=0;i<need;++i) {\n                for(int j=0;j<=n;++j) {\n                    for(int k=0;k<(1<<n);++k) {\n                        dp[i][j][k] = -1;\n                    }\n                }\n            }\n            pl(f(0, n, 0));\n        }\n        pw.flush();\n        pw.close();\n    }\n    static int f(int idx, int bias, int mask) {\n        //pl(\"idx: \"+idx+\" bias : \"+bias + \" mask : \"+mask);\n        if(idx==need) {\n            return 0;\n        }\n        if(dp[idx][bias][mask]!=-1) {\n            return dp[idx][bias][mask];\n        }\n\n        //didn't fix bias yet\n        if(bias==n) {\n            int max = 0;\n            for(int b=0;b<n;++b) {\n                max = max(max, f(idx, b, mask));\n            }\n            //pl(\"maxxxxxxx : \"+max);\n            dp[idx][bias][mask] = max;\n            return max;\n        }\n        else {\n            int max = f(idx+1, n, mask);\n            for(int i=0;i<n;++i) {\n                if((mask&(1<<i))==0) {\n                    max = max(max, real[(i-bias+n)%n][idx] + f(idx, bias, mask | (1<<i)));\n                }\n            }\n            //pl(\"max : \"+max);\n            dp[idx][bias][mask] = max;\n            return max;\n        }\n    }\n    static class Pair implements Comparable<Pair>\n    {\n        int x,y;\n        Pair(int x,int y)\n        {\n            this.x=x;\n            this.y=y;\n        }\n        public int compareTo(Pair other)\n        {\n            if(this.x!=other.x)\n                return this.x-other.x;\n            return this.y-other.y;\n        }\n        public String toString()\n        {\n            return \"(\"+x+\",\"+y+\")\";\n        }\n    }\n    static void initIo(boolean isFileIO) throws IOException {\n        scan = new MyScanner(isFileIO);\n        if(isFileIO) {\n            pw = new PrintWriter(\"/Users/amandeep/Desktop/output.txt\");\n        }\n        else {\n            pw = new PrintWriter(System.out, true);\n        }\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static String ne() throws IOException\n    {\n        return scan.next();\n    }\n    static String nel() throws IOException\n    {\n        return scan.nextLine();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class MyScanner\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        MyScanner(boolean readingFromFile) throws IOException\n        {\n            if(readingFromFile) {\n                br = new BufferedReader(new FileReader(\"/Users/amandeep/Desktop/input.txt\"));\n            }\n            else {\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n        }\n        String nextLine()throws IOException\n        {\n            return br.readLine();\n        }\n        String next() throws IOException\n        {\n            if(st==null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        int nextInt() throws IOException\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong() throws IOException\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble() throws IOException\n        {\n            return Double.parseDouble(next());\n        }\n    }\n}", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "\nimport java.io.*;\nimport java.util.StringTokenizer;\n\n/**\n * Codeforces 11D - A Simple Task\n * Created by Darren on 14-10-21.\n * O(2^n * n^2) time and O(2^n * n) space.\n *\n * Tag: dynamic programming, bitmask, graph\n */\npublic class D {\n    Reader in = new Reader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        new D().run();\n    }\n\n    int n, m;\n    boolean[][] adjacency;  // Adjacency matrix\n\n    void run() throws IOException {\n        n = in.nextInt();\n        m = in.nextInt();\n        adjacency = new boolean[n+1][n];\n        for (int i = 0; i < m; i++) {\n            int u = in.nextInt(), v = in.nextInt();\n            adjacency[u-1][v-1] = adjacency[v-1][u-1] = true;   // Converted to 0-based\n        }\n\n        final int MASK_BOUND = (1 << n);\n\n        // dp[i][j]: the number of Hamiltonian walks over the subgraph formed by\n        // the mask i, starting at the smallest vertex and ending at vertex j\n        // dp[1<<i][i] = 1;\n        // dp[i][j] = sum_k{dp[i^j][k]} if j is within the mask i and (k,j) is an edge\n        long[][] dp = new long[MASK_BOUND][n];\n        for (int i = 0; i < n; i++)\n            dp[1<<i][i] = 1;\n\n        long sum = 0;\n        for (int mask = 1; mask < MASK_BOUND; mask++) {\n            int lowestVertex = (int) (Math.log(lowest(mask)) / Math.log(2));\n            for (int i = 0; i < n; i++) {\n                if (bit(i, mask) && i != lowestVertex) {\n                    for (int j = 0; j < n; j++) {\n                        if (adjacency[j][i]) {\n                            dp[mask][i] += dp[mask^(1<<i)][j];\n                        }\n                    }\n\n                    // A simple cycle with length not smaller than 3\n                    if (count(mask) >= 3 && adjacency[lowestVertex][i])\n                        sum += dp[mask][i];\n                } else {\n                    // dp[mask][i] = 0\n                }\n            }\n        }\n\n        out.println(sum / 2);   // A cycle is counted twice\n        out.flush();\n    }\n\n    // Return the number of '1's in the binary representation of the mask\n    int count(int mask) {\n        int count = 0;\n        while (mask > 0) {\n            if ((mask & 1) == 1)\n                count++;\n            mask >>= 1;\n        }\n        return count;\n    }\n\n    // Return an integer with only one '1' in its binary form and the position of the\n    // only '1' is the same with the lowest '1' in mask\n    int lowest(int mask) {\n        // mask = x1b where b is a sequence of zeros;\n        // -mask = x'1b', where x' and b' is formed by reversing digits in x and b;\n        // mask & (-mask) = 0...010...0, where the only 1 is the lowest 1 in mask\n        return mask & (-mask);\n    }\n\n    // Check whether the digit at the given index of the mask is '1'\n    boolean bit(int index, int mask) {\n        return ((1 << index) & mask) > 0;\n    }\n\n    static class Reader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public Reader(InputStream input) {\n            reader = new BufferedReader(new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        /** get next word */\n        String nextToken() throws IOException {\n            while ( ! tokenizer.hasMoreTokens() ) {\n                //TODO add check for eof if necessary\n                tokenizer = new StringTokenizer( reader.readLine() );\n            }\n            return tokenizer.nextToken();\n        }\n\n        String readLine() throws IOException {\n            return reader.readLine();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt( nextToken() );\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong( nextToken() );\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble( nextToken() );\n        }\n    }\n}\n", "complexity": "np", "problem": "0011_D", "from": "CODEFORCES", "tags": "bitmasks,dp,graphs"}
{"src": "import java.io.FileReader;\n\nimport java.io.FileWriter;\n\nimport java.io.IOException;\n\nimport java.io.PrintWriter;\n\nimport java.util.Scanner;\n\n\n\n\n\npublic class FireAgain {\n\n\n\n\tScanner in;\n\n\tPrintWriter out;\n\n\t\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// TODO Auto-generated method stub\n\n\t\tnew FireAgain().run();\n\n\n\n\t}\n\n\t\n\n\tvoid run() throws IOException {\n\n\t\tin = new Scanner(new FileReader(\"input.txt\"));\n\n        out = new PrintWriter(new FileWriter(\"output.txt\"));\n\n\n\n\t\tsolve();\n\n\n\n\t\tin.close();\n\n\t\tout.close();\n\n\t}\n\n\n\n\tprivate void solve() {\n\n\t\t// TODO Auto-generated method stub\n\n\t\tint N = in.nextInt();\n\n\t\tint M = in.nextInt();\n\n\t\tint[][] burn = new int[N + 1][M + 1];\n\n\t\tint K = in.nextInt();\n\n\t\t\n\n\t\tint[] qx = new int[N * M];\n\n\t\tint[] qy = new int[N * M];\n\n\t\t\n\n\t\tint first = 0;\n\n\t\tint last = 0;\n\n\t\tfor (int i = 0; i < K; i ++){\n\n\t\t\tqx[last] = in.nextInt();\n\n\t\t\tqy[last] = in.nextInt();\n\n\t\t\tburn[qx[last]][qy[last]] = 1;\n\n\t\t\tlast ++;\n\n\t\t}\n\n\t\t\n\n\t\twhile (first < last){\n\n\t\t\tint x = qx[first];\n\n\t\t\tint y = qy[first];\n\n\t\t\tif (x - 1 > 0 && burn[x - 1][y] == 0){\n\n\t\t\t\tburn[x - 1][y] = 1;\n\n\t\t\t\tqx[last] = x - 1;\n\n\t\t\t\tqy[last] = y;\n\n\t\t\t\tlast ++;\n\n\t\t\t}\n\n\t\t\tif (y - 1 > 0 && burn[x][y - 1] == 0){\n\n\t\t\t\tburn[x][y - 1] = 1;\n\n\t\t\t\tqx[last] = x;\n\n\t\t\t\tqy[last] = y - 1;\n\n\t\t\t\tlast ++;\n\n\t\t\t}\n\n\t\t\tif (x + 1 <= N && burn[x + 1][y] == 0){\n\n\t\t\t\tburn[x + 1][y] = 1;\n\n\t\t\t\tqx[last] = x + 1;\n\n\t\t\t\tqy[last] = y;\n\n\t\t\t\tlast ++;\n\n\t\t\t}\n\n\t\t\tif (y + 1 <= M && burn[x][y + 1] == 0){\n\n\t\t\t\tburn[x][y + 1] = 1;\n\n\t\t\t\tqx[last] = x;\n\n\t\t\t\tqy[last] = y + 1;\n\n\t\t\t\tlast ++;\n\n\t\t\t}\n\n\t\t\tfirst ++;\n\n\t\t}\n\n\t\t\n\n\t\tout.println(qx[last - 1] + \" \" + qy[last - 1]);\n\n\t}\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class D {\n\tFastScanner in;\n\tPrintWriter out;\n\tboolean systemIO = true;\n\n\t\n\t\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tHashMap<Long, Integer> map = new HashMap();\n\t\tBigInteger sum = BigInteger.ZERO;\n\t\tBigInteger ans = BigInteger.valueOf(0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong x = in.nextLong();\n\t\t\tans = ans.add(BigInteger.valueOf(i * x));\n\t\t\tif (map.containsKey(x + 1)) {\n\t\t\t\tans = ans.add(BigInteger.valueOf(map.get(x + 1)));\n\t\t\t}\n\t\t\tif (map.containsKey(x - 1)) {\n\t\t\t\tans = ans.subtract(BigInteger.valueOf(map.get(x - 1)));\n\t\t\t}\n\t\t\tif (map.containsKey(x)) {\n\t\t\t\tmap.put(x, map.get(x) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(x, 1);\n\t\t\t}\n\t\t\tans = ans.subtract(sum);\n\t\t\tsum = sum.add(BigInteger.valueOf(x));\n\t\t}\n\t\tout.print(ans.toString());\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tif (systemIO) {\n\t\t\t\tin = new FastScanner(System.in);\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t} else {\n\t\t\t\tin = new FastScanner(new File(\"segments.in\"));\n\t\t\t\tout = new PrintWriter(new File(\"segments.out\"));\n\t\t\t}\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tFastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\treturn br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\t// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\tpublic static void main(String[] arg) {\n\t\tnew D().run();\n\t}\n}", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class GG {\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n        int C = scanner.nextInt();\n        int D = scanner.nextInt();\n        MinCostMaxFlowSolver solver = new EdmondsKarp();\n        int[] people = new int[K];\n        for(int i = 0; i < K; i++) people[i] = scanner.nextInt()-1;\n        Node src = solver.addNode();\n        Node snk = solver.addNode();\n        int amt = 150;\n        Node[][] timeNodes = new Node[N][amt];\n        for(int i = 0; i < N; i++) {\n            for(int j = 1; j < amt; j++) {\n                timeNodes[i][j] = solver.addNode();\n                if (j > 1) solver.link(timeNodes[i][j-1], timeNodes[i][j], Integer.MAX_VALUE, 0);\n            }\n        }\n        for(int i = 0; i < K; i++) {\n            solver.link(src, timeNodes[people[i]][1], 1, 0);\n        }\n        for(int i = 1; i < amt; i++) {\n            for(int j = 0; j < K; j++) {\n                solver.link(timeNodes[0][i], snk, 1, C*i-C);\n            }\n        }\n        for(int i =0; i < M; i++) {\n            int a = scanner.nextInt()-1;\n            int b = scanner.nextInt()-1;\n            for(int j = 1; j < amt-1; j++) {\n                int prev = 0;\n                for(int k = 1; k <= K; k++) {\n                    solver.link(timeNodes[a][j], timeNodes[b][j + 1], 1, D*k*k- prev);\n                    solver.link(timeNodes[b][j], timeNodes[a][j + 1], 1, D*k*k - prev);\n                    prev = D * k * k;\n                }\n            }\n        }\n        long[] ret = solver.getMinCostMaxFlow(src, snk);\n        out.println(ret[1]);\n        out.flush();\n    }\n   \n    public static class Node {\n        // thou shall not create nodes except through addNode()\n        private Node() { }\n        \n        List<Edge> edges = new ArrayList<Edge>();\n        int index;          // index in nodes array\n        \n    }\n    \n    public static class Edge\n    {\n        boolean forward; // true: edge is in original graph\n        Node from, to;   // nodes connected\n        long flow;        // current flow\n        final long capacity;\n        Edge dual;      // reference to this edge's dual\n        long cost;      // only used for MinCost.\n        protected Edge(Node s, Node d, long c, boolean f)\n        {\n            forward = f;\n            from = s;\n            to = d;\n            capacity = c;\n        }\n        long remaining() { return capacity - flow; }\n        void addFlow(long amount) {\n            flow += amount;\n            dual.flow -= amount;\n        }\n    }\n    \n    public static abstract class MaxFlowSolver {\n        List<Node> nodes = new ArrayList<Node>();\n    \n        public void link(Node n1, Node n2, long capacity) {\n            link(n1, n2, capacity, 1);\n        }\n    \n        public void link(Node n1, Node n2, long capacity, long cost) {\n            Edge e12 = new Edge(n1, n2, capacity, true);\n            Edge e21 = new Edge(n2, n1, 0, false);\n            e12.dual = e21;\n            e21.dual = e12;\n            n1.edges.add(e12);\n            n2.edges.add(e21);\n            e12.cost = cost;\n            e21.cost = -cost;\n        }\n        void link(int n1, int n2, long capacity) {\n            link(nodes.get(n1), nodes.get(n2), capacity);\n        }\n        protected MaxFlowSolver(int n) {\n            for (int i = 0; i < n; i++)\n                addNode();\n        }\n        protected MaxFlowSolver() {\n            this(0);\n        }\n    \n        public abstract long getMaxFlow(Node src, Node snk);\n        public Node addNode() {\n            Node n = new Node();\n            n.index = nodes.size();\n            nodes.add(n);\n            return n;\n        }\n    }\n    static abstract class MinCostMaxFlowSolver extends MaxFlowSolver {\n        // returns [maxflow, mincost]\n        abstract long [] getMinCostMaxFlow(Node src, Node snk);\n        // unavoidable boiler plate\n        MinCostMaxFlowSolver ()      { this(0); }\n        MinCostMaxFlowSolver (int n) { super(n); }\n    }\n    \n    static class EdmondsKarp extends MinCostMaxFlowSolver\n    {\n        EdmondsKarp ()      { this(0); }\n        EdmondsKarp (int n) { super(n); }\n        long minCost;\n        \n        @Override\n        public long [] getMinCostMaxFlow(Node src, Node snk) {\n            long maxflow = getMaxFlow(src, snk);\n            return new long [] { maxflow, minCost };\n        }\n        static final long INF = Long.MAX_VALUE/4;\n        \n        @Override\n        public long getMaxFlow(Node src, Node snk) {\n            final int n = nodes.size();\n            final int source = src.index;\n            final int sink = snk.index;\n            long flow = 0;\n            long cost = 0;\n            long[] potential = new long[n]; // allows Dijkstra to work with negative edge weights\n            while (true) {\n                Edge[] parent = new Edge[n]; // used to store an augmenting path\n                long[] dist = new long[n]; // minimal cost to vertex\n                Arrays.fill(dist, INF);\n                dist[source] = 0;\n                PriorityQueue<Item> que = new PriorityQueue<Item>();\n                que.add(new Item(0, source));\n                while (!que.isEmpty()) {\n                    Item item = que.poll();\n                    if (item.dist != dist[item.v])\n                        continue;\n                    \n                    for (Edge e : nodes.get(item.v).edges) {\n                        long temp = dist[item.v] + e.cost + potential[item.v] - potential[e.to.index];\n                        if (e.capacity > e.flow && dist[e.to.index] > temp) {\n                            dist[e.to.index] = temp;\n                            parent[e.to.index] = e;\n                            que.add(new Item(temp, e.to.index));\n                        }\n                    }\n                }\n                if (parent[sink] == null)\n                    break;\n                for (int i = 0; i < n; i++)\n                    if (parent[i] != null)\n                        potential[i] += dist[i];\n                long augFlow = Long.MAX_VALUE;\n                for (int i = sink; i != source; i = parent[i].from.index)\n                    augFlow = Math.min(augFlow, parent[i].capacity - parent[i].flow);\n                for (int i = sink; i != source; i = parent[i].from.index) {\n                    Edge e = parent[i];\n                    e.addFlow(augFlow);\n                    cost += augFlow * e.cost;\n                }\n                flow += augFlow;\n            }\n            \n            minCost = cost;\n            return flow;\n        }\n        \n        static class Item implements Comparable<Item> {\n            long dist;\n            int v;\n            \n            public Item(long dist, int v) {\n                this.dist = dist;\n                this.v = v;\n            }\n            \n            public int compareTo(Item that) {\n                return Long.compare(this.dist, that.dist);\n            }\n        }\n    }\n    \n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n}\n", "complexity": "cubic", "problem": "1187_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class a {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint t = sc.nextInt();\n\t\tint[][] xa = new int[n][2];\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\txa[i][0] = sc.nextInt();\n\t\t\txa[i][1] = sc.nextInt();\n\t\t}\n\t    Arrays.sort(xa, new Comparator<int[]>(){\n            @Override\n            public int compare(int[] a0, int[] a1){\n                return a0[0]-a1[0];\n            }\n        });\n\t\t  int ans=2;\n\t        for(int i=0; i<n-1; i++){\n\t            int s=(xa[i+1][0]*2-xa[i+1][1])-(xa[i][0]*2+xa[i][1]);\n\t            if(s>t*2){\n\t                ans+=2;\n\t            }else if(s==t*2){\n\t                ans++;\n\t            }\n\t        }\n\t        System.out.println(ans+\"\");\n\t}\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n    @author KhanhNguyenn\n */\n \npublic class C{\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(in, out);\n        out.close();\n    }\n    // main solver\n    // sub-problem: 2 orders to merge together x1,x2,..,xn and y1,y2,..,ym\n    // D\u1ef1a v\u00e0o b\u00e0i to\u00e1n chia k\u1eb9p Euler, ta ch\u1ee9ng minh dc s\u1ed1 c\u00e1ch merge l\u00e0\n    // (m+n)C(m-1)=(m+n)C(n+1)\n    static class Task{\n        int M;\n        public void solve(InputReader in, PrintWriter out) {\n            int n= in.nextInt(); M= in.nextInt();\n            if(n<=1){\n                out.println(n);\n                return;\n            }\n            int[] pow2= new int[n+1];\n            pow2[0]=1;\n            for(int i=1;i<=n;i++) pow2[i]=mul(2,pow2[i-1]);\n\n            // calculate nCk\n            // nCk= (n-1)C(k-1)+ (n-1)Ck\n            int[][] Ckn= new int[n+1][n+1];\n            for(int i=0;i<=n;i++){\n                Ckn[i][i]=1; Ckn[0][i]=1;\n                for(int j=i-1;j>=1;j--){\n                    Ckn[j][i]= add(Ckn[j-1][i-1],Ckn[j][i-1]);\n                }\n            }\n\n            int ans=0;\n            int[][] dp= new int[n+1][n+1];\n            dp[1][1]=1;\n            //dp[i][j]: number of ways to turn on first i , using j manually\n            for(int i=2;i<=n;i++){\n                dp[i][i]= pow2[i-1];\n                for(int j=1;j<=i-1;j++){\n                    for(int k=1;k<=j;k++){\n                            dp[i][j]= add(dp[i][j],mul(mul(pow2[k-1],dp[i-k-1][j-k]),Ckn[k][j])); \n                    }\n                }\n            }\n            for(int i=0;i<=n;i++) ans= add(ans,dp[n][i]);\n            out.println(ans);\n        }\n\n        public int add(int a, int b){\n            a+=b;\n            if(a>=M) a-=M;\n            return a;\n        }\n\n        public int mul(int a, int b){\n            long res= (long)a*(long)b;\n            res %=M;\n            return (int)res;\n        }\n\n        \n\n    }\n    static class Pair {\n        public String x;\n        public int y;\n        public Pair(String x, int y){\n            this.x = x;\n            this.y=y;\n        }\n \n        // @Override\n        // public int compareTo(Pair o) {\n        //     if (this.x > o.x){\n        //         return 1;\n        //     }\n        //     else if (this.x < o.x){\n        //         return -1;\n        //     }\n        //     else{\n        //         return Integer.compare(this.y, o.y);\n        //     }\n        // }\n    }\n    // fast input reader class;\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream));\n        }\n \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (line == null) {\n                    return null;\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(nextToken());\n        }\n        public long nextLong(){\n            return Long.parseLong(nextToken());\n        }\n    }\n}", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class E {\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out, false);\n        int t = scanner.nextInt();\n        while(t-->0) {\n            int n = scanner.nextInt();\n            int m = scanner.nextInt();\n            Col[] cols = new Col[m];\n            int[][] mat = new int[m][n];\n            for(int i = 0; i < n; i++) {\n                for(int j =0; j < m; j++) {\n                    mat[j][i] = scanner.nextInt();\n                }\n            }\n            for(int i = 0; i < m; i++) {\n                cols[i] = new Col(mat[i]);\n            }\n            Arrays.sort(cols);\n            int maxMask = 1 << n;\n            int[] dp = new int[maxMask];\n            Arrays.fill(dp, -1);\n            dp[0] = 0;\n            int sz = Math.min(n, m);\n            int[][] ss = new int[sz][maxMask];\n            //2^n * n^3\n            for(int i = 0; i < sz; i++) {\n                int[] curArr = cols[i].arr.clone();\n                for(int j = 0; j < n; j++) {\n                    for(int mask = 0; mask < maxMask; mask++) {\n                        int cur = 0;\n                        for(int k = 0; k < n; k++) if ((( 1 << k) & mask) > 0) cur += curArr[k];\n                        ss[i][mask] = Math.max(ss[i][mask], cur);\n                    }\n                    curArr = shift(curArr);\n                }\n            }\n            for(int i = 0; i < Math.min(n, m); i++) {\n                for(int mask = maxMask-1; mask>=0; mask--) {\n                    for(int smask = mask; smask >= 0; smask = (smask-1)&mask) {\n                        if (dp[smask] == -1) continue;\n                        dp[mask] = Math.max(dp[mask], dp[smask] + ss[i][mask ^ smask]);\n                        if (smask == 0) break;\n                    }\n                }\n            }\n            out.println(dp[maxMask-1]);\n        }\n        out.flush();\n    }\n    static int[] shift (int[] a) {\n        int[] b = new int[a.length];\n        b[0] = a[a.length-1];\n        for(int i = 0; i < a.length-1; i++) {\n            b[i+1] = a[i];\n        }\n        return b;\n    }\n    static class Col implements Comparable<Col> {\n        int[] arr;\n        int[] sorted;\n        public Col(int[] a) {\n            arr = a;\n            sorted= arr.clone();\n            Arrays.sort(sorted);\n        }\n        public int compareTo(Col col) {\n            return -sorted[sorted.length-1] + col.sorted[sorted.length-1];\n        }\n    }\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n", "complexity": "np", "problem": "1209_E2", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,sortings"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tprivate void run() throws IOException {\n\t\tint cx = in.nextInt();\n\t\tint cy = in.nextInt();\n\t\tint n = in.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = in.nextInt() - cx;\n\t\t\ty[i] = in.nextInt() - cy;\n\t\t}\n\t\tint[] dp = new int[1 << n];\n\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\t\tdp[0] = 0;\n\t\tint[] prev = new int[1 << n];\n\t\tfor (int mask = 0; mask < (1 << n); ++mask) {\n\t\t\tif (dp[mask] == Integer.MAX_VALUE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (((mask >> i) & 1) == 0) {\n\t\t\t\t\tif (dp[mask | (1 << i)] > dp[mask] + dist(x[i], y[i])) {\n\t\t\t\t\t\tdp[mask | (1 << i)] = dp[mask] + dist(x[i], y[i]);\n\t\t\t\t\t\tprev[mask | (1 << i)] = mask;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\t\t\tif (((mask >> j) & 1) == 0) {\n\t\t\t\t\t\t\tif (dp[mask | (1 << i) | (1 << j)] > dp[mask] + dist(x[i], y[i], x[j], y[j])) {\n\t\t\t\t\t\t\t\tdp[mask | (1 << i) | (1 << j)] = dp[mask] + dist(x[i], y[i], x[j], y[j]);\n\t\t\t\t\t\t\t\tprev[mask | (1 << i) | (1 << j)] = mask;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(dp[(1 << n) - 1]);\n\t\tint mask = (1 << n) - 1;\n\t\tout.print(0);\n\t\twhile (mask != 0) {\n\t\t\tint p = prev[mask];\n\t\t\tint cur = p ^ mask;\n\t\t\tList<Integer> who = new ArrayList<Integer>();\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (((cur >> i) & 1) != 0) {\n\t\t\t\t\twho.add(i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int t : who) {\n\t\t\t\tout.print(\" \" + t);\n\t\t\t}\n\t\t\tout.print(\" \" + 0);\n\t\t\tmask = p;\n\t\t}\n\t\tout.flush();\n\t}\n\n\tprivate int dist(int x, int y, int x2, int y2) {\n\t\treturn x * x + y * y + x2 * x2 + y2 * y2 + (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\n\t}\n\n\tprivate int dist(int x, int y) {\n\t\treturn 2 * (x * x + y * y);\n\t}\n\n\tprivate class Scanner {\n\t\tprivate StringTokenizer tokenizer;\n\t\tprivate BufferedReader reader;\n\n\t\tpublic Scanner(Reader in) {\n\t\t\treader = new BufferedReader(in);\n\t\t\ttokenizer = new StringTokenizer(\"\");\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic boolean hasNext() throws IOException {\n\t\t\twhile (!tokenizer.hasMoreTokens()) {\n\t\t\t\tString next = reader.readLine();\n\t\t\t\tif (next == null)\n\t\t\t\t\treturn false;\n\t\t\t\ttokenizer = new StringTokenizer(next);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\thasNext();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\ttokenizer = new StringTokenizer(\"\");\n\t\t\treturn reader.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\tScanner in = new Scanner(new InputStreamReader(System.in));\n\tPrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n}\n", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    \n    class Team implements Comparable<Team>{\n        int ac;\n        int penalty;\n        \n        public Team(int ac, int penalty) {\n            this.ac = ac;\n            this.penalty = penalty;\n        }\n\n        @Override\n        public int compareTo(Team o) {\n            if (ac != o.ac)\n                return ac > o.ac ? -1 : 1;\n            return (penalty == o.penalty) ? 0 : (penalty < o.penalty ? -1 : 1);\n        }\n        \n    }\n\n    void solve() throws IOException {\n        int n = nextInt();\n        int k = nextInt() - 1;\n        \n        Team[] a = new Team[n];\n        for (int i = 0; i < n; i++)\n            a[i] = new Team(nextInt(), nextInt());\n        \n        Arrays.sort(a);\n        for (int i = 0; i < n;) {\n            int j = i;\n            while (j < n && a[j].compareTo(a[i]) == 0)\n                j++;\n            if (i <= k && k < j) {\n                out.println(j - i);\n                return;\n            }\n            i = j;\n        }\n    }\n\n    void inp() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new A().inp();\n    }\n\n    String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n\n    String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Main{\n\n        BufferedReader in;\n        StringTokenizer str = null;\n        PrintWriter out;\n\n        private String next() throws Exception{\n                if (str == null || !str.hasMoreTokens())\n                        str = new StringTokenizer(in.readLine());\n                return str.nextToken();\n        }\n        \n        private int nextInt() throws Exception{\n                return Integer.parseInt(next());\n        }\n        \n        private long nextLong() throws Exception{\n                return Long.parseLong(next());\n        }\n        \n        private double nextDouble() throws Exception{\n                return Double.parseDouble(next());\n        }\n\n        public void run() throws Exception{\n                in = new BufferedReader(new InputStreamReader(System.in));//new FileReader();\n                out = new PrintWriter(System.out);//new File();\n                int n = nextInt();\n                HashSet<Integer> hs = new HashSet<Integer>();\n                for(int i=0;i<n;i++) hs.add(nextInt());\n                if (hs.size() == 1){\n                  out.println(\"NO\");\n                  out.close();\n                  return;\n                }\n                int a[] = new int[hs.size()];\n                int yk = 0;\n                for(int i:hs) a[yk++] = i;\n                Arrays.sort(a);\n                out.println(a[1]);\n                out.close();\n        }\n\n        public static void main(String args[]) throws Exception{\n                new Main().run();\n        }\n}\n \n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "// Don't place your source in a package\nimport javax.swing.*;\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.stream.Stream;\n\n\n// Please name your class Main\npublic class Main {\n    static FastScanner fs=new FastScanner();\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int Int() {\n            return Integer.parseInt(next());\n        }\n\n        long Long() {\n            return Long.parseLong(next());\n        }\n\n        String Str(){\n            return next();\n        }\n    }\n\n\n    public static void main (String[] args) throws java.lang.Exception {\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n        int T=1;\n        for(int t=0;t<T;t++){\n            int n=Int(),k=Int();\n            int A[][]=new int[n][2];\n            for(int i=0;i<n;i++){\n                A[i][0]=Int();\n                A[i][1]=Int();\n            }\n\n            Solution sol=new Solution(out);\n            sol.solution(A,k);\n        }\n        out.close();\n\n    }\n\n\n    public static int Int(){\n        return fs.Int();\n    }\n    public static long Long(){\n        return fs.Long();\n    }\n    public static String Str(){\n        return fs.Str();\n    }\n\n}\n\n\n\n\n\n\nclass Solution{\n    PrintWriter out;\n    public Solution(PrintWriter out){\n        this.out=out;\n    }\n\n\n\n    long dp[][];\n    int mod=1000000007;\n    int time;\n    public void solution(int A[][],int t){\n        this.time=t;\n        dp=new long[4][1<<A.length+2];\n        for(int i=0;i<dp.length;i++){\n            Arrays.fill(dp[i],-1);\n        }\n\n        long a=dfs(A,0,(1<<A.length)-1);\n        out.println(a);\n    }\n\n    public long dfs(int A[][],int pre,int state){\n        int use=cal(A,state);\n        if(time-use==0){\n            return 1;\n        }\n        if(time<use||state==0){\n            return 0;\n        }\n\n        if(dp[pre][state]!=-1)return dp[pre][state];\n\n        long res=0;\n\n        for(int i=0;i<A.length;i++){\n            if(((state&(1<<i))!=0)&&A[i][1]!=pre){\n                res+=dfs(A,A[i][1],(state^(1<<i)));\n                res%=mod;\n            }\n        }\n\n        dp[pre][state]=res;\n        return res;\n    }\n\n    public int cal(int A[][],int state){\n        int t=0;\n        for(int i=0;i<A.length;i++){\n            if((state&(1<<i))==0){\n                t+=A[i][0];\n            }\n        }\n        return t;\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n                             ;\\\n                            |' \\\n         _                  ; : ;\n        / `-.              /: : |\n       |  ,-.`-.          ,': : |\n       \\  :  `. `.       ,'-. : |\n        \\ ;    ;  `-.__,'    `-.|\n         \\ ;   ;  :::  ,::'`:.  `.\n          \\ `-. :  `    :.    `.  \\\n           \\   \\    ,   ;   ,:    (\\\n            \\   :., :.    ,'o)): ` `-.\n           ,/,' ;' ,::\"'`.`---'   `.  `-._\n         ,/  :  ; '\"      `;'          ,--`.\n        ;/   :; ;             ,:'     (   ,:)\n          ,.,:.    ; ,:.,  ,-._ `.     \\\"\"'/\n          '::'     `:'`  ,'(  \\`._____.-'\"'\n             ;,   ;  `.  `. `._`-.  \\\\\n             ;:.  ;:       `-._`-.\\  \\`.\n              '`:. :        |' `. `\\  ) \\\n      -hrr-      ` ;:       |    `--\\__,'\n                   '`      ,'\n                        ,-'\n\n\n                      free bug dog\n*/\n\n\n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static point[] points;\n\n    static class point implements Comparable<point> {\n        int x, y;\n\n        public point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(point o) {\n            if (this.x  > o.x ) {\n                return 1;\n            } else if (this.x  == o.x ) {\n                return 0;\n            } else {\n                return -1;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return x + \" \" + y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            point point = (point) obj;\n            return Objects.equals(x, point.x) && Objects.equals(y, point.y);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        points = new point[3];\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        for (int i = 0; i < 3; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            points[i] = new point(a, b);\n        }\n\n        Arrays.sort(points);\n\n        int lMax = Math.max(Math.max(points[0].y, points[1].y), points[2].y);\n        int lMin = Math.min(Math.min(points[0].y, points[1].y), points[2].y);\n        int rMax = Math.max(Math.max(points[0].x, points[1].x), points[2].x);\n        int rMin = Math.min(Math.min(points[0].x, points[1].x), points[2].x);\n\n        Set<point> sets = new HashSet<>();\n\n        for (int i = lMin; i <= lMax; i++) {\n            sets.add(new point(points[1].x, i));\n        }\n        for (int i = rMin; i <= points[1].x; i++) {\n            sets.add(new point(i, points[0].y));\n        }\n        for (int i = points[1].x; i <= rMax; i++) {\n            sets.add(new point(i, points[2].y));\n        }\n        System.out.println(sets.size());\n        for (point i : sets) {\n            System.out.println(i);\n        }\n    }\n}\n\n\t  \t\t\t  \t \t\t \t \t\t\t  \t \t   \t\t\t\t\t", "complexity": "nlogn", "problem": "1086_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic Scanner in;\n\tstatic PrintWriter out;\n//\tstatic StreamTokenizer in; static int next() throws Exception {in.nextToken(); return (int) in.nval;}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tin = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n//\t\tin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tString s = in.next();\n\t\tint n = s.length();\n\n\t\tint max = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tString[] subs = new String[n - i + 1];\n\t\t\tfor (int j = 0; j + i <= n; j++) subs[j] = s.substring(j, j + i);\n\t\t\tArrays.sort(subs);\n\t\t\tboolean flag = false;\n\t\t\tfor (int j = 0; j < n - i; j++)\n\t\t\t\tif (subs[j].equals(subs[j + 1])) flag = true;\n\t\t\tif (flag) max = Math.max(max, i);\n\t\t}\n\n\t\tout.println(max);\n\n\t\tout.close();\n\t}\n}", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String s = in.readLine();\n        for (int i = s.length() - 1; i > 0; i--)\n            for (int j = 0; j <= s.length() - i; j++)\n                if (s.substring(0, j + i - 1).contains(s.substring(j, j + i))\n                        || s.substring(j + 1).contains(s.substring(j, j + i))) {\n                    System.out.println(i);\n                    return;\n                }\n        System.out.println(0);\n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic int m;\n\tstatic long pow(long b, int p) {\n\t\tlong ret = 1;\n\t\twhile (p > 0) {\n\t\t\tif ((p&1) == 1) ret = b*ret%m;\n\t\t\tb = b*b%m;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = readInt(); m = readInt();\n\t\tlong[] fac = new long[n + 1], pow2 = new long[n + 1];\n\t\tlong[][] C = new long[n + 1][n + 1], dp = new long[n + 1][n + 1];\n\t\tfac[0] = pow2[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfac[i] = i*fac[i - 1]%m;\n\t\t\tpow2[i] = 2*pow2[i - 1]%m;\n\t\t\tfor (int j = 0; j <= i; ++j)\n\t\t\t\tC[i][j] = fac[i]*(pow(fac[j], m - 2)*pow(fac[i - j], m - 2)%m)%m;\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tdp[i][i] = pow2[i - 1];\n\t\t\tfor (int j = 0; j <= i; ++j)\n\t\t\t\tfor (int k = 1; i + k + 1 <= n; ++k)\n\t\t\t\t\tdp[i + k + 1][j + k] = (dp[i + k + 1][j + k] + dp[i][j]*(C[j + k][k]*pow2[k - 1]%m))%m;\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tans = (ans + dp[n][i])%m;\n\t\tSystem.out.println(ans);\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic StringTokenizer st;\n\tstatic String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\tstatic int readInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n}\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    PriorityQueue<Integer> dfs(int i, int par) {\n        ArrayList<PriorityQueue<Integer>> list = new ArrayList<>();\n        PriorityQueue<Integer> largestQueue = new PriorityQueue<>();\n        int largestSize = 0;\n        for(int j : adj[i]) {\n            if(j != par) {\n                PriorityQueue<Integer> cur = dfs(j, i);\n                if(cur.size() > largestSize) {\n                    if(largestSize != 0)\n                        list.add(largestQueue);\n                    largestQueue = cur;\n                    largestSize = cur.size();\n                }\n                else {\n                    list.add(cur);\n                }\n            }\n        }\n\n        if(largestSize == 0) {\n            PriorityQueue<Integer> queue = new PriorityQueue<>(new Comparator<Integer>() {\n                public int compare(Integer i1, Integer i2) {\n                    if(i1 > i2)\n                        return -1;\n                    if(i1 < i2)\n                        return 1;\n                    return 0;\n                }\n            });\n            queue.add(1);\n            cntLeaf++;\n            return queue;\n        }\n\n        PriorityQueue<Integer> queue = largestQueue;\n        for(int j = 0; j < list.size(); ++j) {\n            PriorityQueue<Integer> cur = list.get(j);\n            while(cur.size() != 0)\n                queue.add(cur.poll());\n        } \n        int maxV = queue.poll();\n        queue.add(maxV + 1);\n        return queue;\n    }\n    void dfsFindLevel(int i, int par, int level) {\n        if(level > maxLevel) {\n            maxLevel = level;\n            maxNode = i;\n        }\n        for(int j : adj[i]) {\n            if(j != par)\n                dfsFindLevel(j, i, level + 1);\n        }\n    }\n    ArrayList<Integer> adj[];\n    int cntLeaf = 0;\n    int maxLevel = -1, maxNode = -1;\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        \n        int n = sc.nextInt();\n\n        adj = new ArrayList[n];\n        for(int i = 0; i < n; ++i)\n            adj[i] = new ArrayList<>();\n\n        for(int i = 0; i < n - 1; ++i) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            adj[u].add(v);\n            adj[v].add(u);\n        }\n\n        dfsFindLevel(0, -1, 0);\n\n        PriorityQueue<Integer> queue = dfs(maxNode, -1);\n        int maxV = queue.poll();\n        queue.add(maxV - 1);\n\n        int cans = 1;\n        for(int i = 0; i < cntLeaf; ++i) {\n            w.print(cans + \" \");\n            cans += queue.poll();\n        }\n\n        for(int i = cntLeaf; i < n; ++i)\n            w.print(cans + \" \");\n\n        w.close();      \n    }\n}", "complexity": "nlogn", "problem": "0958_B2", "from": "CODEFORCES", "tags": "data structures,dfs and similar,graphs,greedy,trees"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main\n{\n   public static void main(String[] args) throws IOException\n   {\n      new Main().run();\n   }\n\n   StreamTokenizer in;\n   PrintWriter out;\n\n   int nextInt() throws IOException\n   {\n      in.nextToken();\n      return (int)in.nval;\n   }\n   long nextLong() throws IOException\n   {\n      in.nextToken();\n      return (long)in.nval;\n   }\n   void run() throws IOException\n   {\n     // in = new StreamTokenizer(new BufferedReader(new FileReader(\"input.txt\")));\n     // out = new PrintWriter(new FileWriter(\"output.txt\"));\n      in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    out = new PrintWriter(new OutputStreamWriter(System.out));\n      solve();\n      out.flush();\n   }\n\n   void solve() throws IOException\n   {\n      int N=nextInt();\n      int m=nextInt();\n      int k=nextInt();\n     //  System.out.println(\"k \"+k);\n      ArrayList<Integer> ts= new ArrayList<Integer>();\n       for (int i = 0; i < N; i++) {\n           ts.add(nextInt());\n       }\n       int count=0,pos=0;\n       Collections.sort(ts);\n       int jj=ts.size()-1;\n      while(m>k){\n         \n      if((jj<0)||(k==0))\n      {pos=1;break;}\n      else{\n        //  System.out.println(k);\n      k+=ts.get(jj) -1;\n      jj--;\n      count++;\n      }\n      \n      }\n      if(pos==0)\n           out.println(count);\n      else\n           out.println(\"-1\");\n      \n   }\n}", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author aryssoncf\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            try {\n                int n = in.readInt();\n                int[] x = new int[n], w = new int[n];\n                in.readIntArrays(x, w);\n                int[] begin = new int[n], end = new int[n];\n                Arrays.setAll(begin, i -> x[i] - w[i]);\n                Arrays.setAll(end, i -> x[i] + w[i]);\n                int m = ArrayUtils.compress(begin, end).length;\n                int[] dp = new int[m + 1], order = ArrayUtils.order(end);\n                int idx = 0;\n                for (int i = 0; i < m; i++) {\n                    if (i > 0) {\n                        dp[i] = dp[i - 1];\n                    }\n                    while (idx < n && end[order[idx]] == i) {\n                        dp[i] = Math.max(dp[i], dp[begin[order[idx]]] + 1);\n                        idx++;\n                    }\n                }\n                int res = dp[m - 1];\n                out.printLine(res);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    static class Sorter {\n        private static final int INSERTION_THRESHOLD = 16;\n\n        private Sorter() {\n        }\n\n        public static void sort(IntList list, IntComparator comparator) {\n            quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,\n                    comparator);\n        }\n\n        private static void quickSort(IntList list, int from, int to, int remaining, IntComparator comparator) {\n            if (to - from < INSERTION_THRESHOLD) {\n                insertionSort(list, from, to, comparator);\n                return;\n            }\n            if (remaining == 0) {\n                heapSort(list, from, to, comparator);\n                return;\n            }\n            remaining--;\n            int pivotIndex = (from + to) >> 1;\n            int pivot = list.get(pivotIndex);\n            list.swap(pivotIndex, to);\n            int storeIndex = from;\n            int equalIndex = to;\n            for (int i = from; i < equalIndex; i++) {\n                int value = comparator.compare(list.get(i), pivot);\n                if (value < 0) {\n                    list.swap(storeIndex++, i);\n                } else if (value == 0) {\n                    list.swap(--equalIndex, i--);\n                }\n            }\n            quickSort(list, from, storeIndex - 1, remaining, comparator);\n            for (int i = equalIndex; i <= to; i++) {\n                list.swap(storeIndex++, i);\n            }\n            quickSort(list, storeIndex, to, remaining, comparator);\n        }\n\n        private static void heapSort(IntList list, int from, int to, IntComparator comparator) {\n            for (int i = (to + from - 1) >> 1; i >= from; i--) {\n                siftDown(list, i, to, comparator, from);\n            }\n            for (int i = to; i > from; i--) {\n                list.swap(from, i);\n                siftDown(list, from, i - 1, comparator, from);\n            }\n        }\n\n        private static void siftDown(IntList list, int start, int end, IntComparator comparator, int delta) {\n            int value = list.get(start);\n            while (true) {\n                int child = ((start - delta) << 1) + 1 + delta;\n                if (child > end) {\n                    return;\n                }\n                int childValue = list.get(child);\n                if (child + 1 <= end) {\n                    int otherValue = list.get(child + 1);\n                    if (comparator.compare(otherValue, childValue) > 0) {\n                        child++;\n                        childValue = otherValue;\n                    }\n                }\n                if (comparator.compare(value, childValue) >= 0) {\n                    return;\n                }\n                list.swap(start, child);\n                start = child;\n            }\n        }\n\n        private static void insertionSort(IntList list, int from, int to, IntComparator comparator) {\n            for (int i = from + 1; i <= to; i++) {\n                int value = list.get(i);\n                for (int j = i - 1; j >= from; j--) {\n                    if (comparator.compare(list.get(j), value) <= 0) {\n                        break;\n                    }\n                    list.swap(j, j + 1);\n                }\n            }\n        }\n\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void set(int index, int value);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public void swap(int first, int second) {\n            if (first == second) {\n                return;\n            }\n            int temp = get(first);\n            set(first, get(second));\n            set(second, temp);\n        }\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n        default public IntList sort(IntComparator comparator) {\n            Sorter.sort(this, comparator);\n            return this;\n        }\n\n        default IntList unique() {\n            int last = Integer.MIN_VALUE;\n            IntList result = new IntArrayList();\n            int size = size();\n            for (int i = 0; i < size; i++) {\n                int current = get(i);\n                if (current != last) {\n                    result.add(current);\n                    last = current;\n                }\n            }\n            return result;\n        }\n\n        default public IntList subList(final int from, final int to) {\n            return new IntList() {\n                private final int shift;\n                private final int size;\n\n                {\n                    if (from < 0 || from > to || to > IntList.this.size()) {\n                        throw new IndexOutOfBoundsException(\"from = \" + from + \", to = \" + to + \", size = \" + size());\n                    }\n                    shift = from;\n                    size = to - from;\n                }\n\n                public int size() {\n                    return size;\n                }\n\n                public int get(int at) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    return IntList.this.get(at + shift);\n                }\n\n                public void addAt(int index, int value) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void removeAt(int index) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void set(int at, int value) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    IntList.this.set(at + shift, value);\n                }\n\n                public IntList compute() {\n                    return new IntArrayList(this);\n                }\n            };\n        }\n\n    }\n\n    static interface IntComparator {\n        IntComparator DEFAULT = Integer::compare;\n\n        int compare(int first, int second);\n\n    }\n\n    static class Range {\n        public static IntList range(int from, int to) {\n            int[] result = new int[Math.abs(from - to)];\n            int current = from;\n            if (from <= to) {\n                for (int i = 0; i < result.length; i++) {\n                    result[i] = current++;\n                }\n            } else {\n                for (int i = 0; i < result.length; i++) {\n                    result[i] = current--;\n                }\n            }\n            return new IntArray(result);\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        IntIterator intIterator();\n\n        default Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public void readIntArrays(int[]... arrays) {\n            for (int i = 0; i < arrays[0].length; i++) {\n                for (int j = 0; j < arrays.length; j++) {\n                    arrays[j][i] = readInt();\n                }\n            }\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public int[] toArray() {\n            int size = size();\n            int[] array = new int[size];\n            int i = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                array[i++] = it.value();\n            }\n            return array;\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public int get(int at) {\n            return data[at];\n        }\n\n        public void addAt(int index, int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void set(int index, int value) {\n            data[index] = value;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static int[] range(int from, int to) {\n            return Range.range(from, to).toArray();\n        }\n\n        public static int[] createOrder(int size) {\n            return range(0, size);\n        }\n\n        public static int[] sort(int[] array, IntComparator comparator) {\n            return sort(array, 0, array.length, comparator);\n        }\n\n        public static int[] sort(int[] array, int from, int to, IntComparator comparator) {\n            if (from == 0 && to == array.length) {\n                new IntArray(array).sort(comparator);\n            } else {\n                new IntArray(array).subList(from, to).sort(comparator);\n            }\n            return array;\n        }\n\n        public static int[] order(final int[] array) {\n            return sort(createOrder(array.length), (first, second) -> Integer.compare(array[first], array[second]));\n        }\n\n        public static int[] unique(int[] array) {\n            return new IntArray(array).unique().toArray();\n        }\n\n        public static int[] compress(int[]... arrays) {\n            int totalLength = 0;\n            for (int[] array : arrays) {\n                totalLength += array.length;\n            }\n            int[] all = new int[totalLength];\n            int delta = 0;\n            for (int[] array : arrays) {\n                System.arraycopy(array, 0, all, delta, array.length);\n                delta += array.length;\n            }\n            sort(all, IntComparator.DEFAULT);\n            all = unique(all);\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i] = Arrays.binarySearch(all, array[i]);\n                }\n            }\n            return all;\n        }\n\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n        public void set(int index, int value) {\n            if (index >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            data[index] = value;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "problem": "0528_B", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import java.util.Scanner;\n\n\npublic class prob1 {\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tString s = input.next();\n\t\tint n = s.length();\n\t\tint i = n-1;\n\t\tCharSequence temp;\n\t\tfor(i = n-1; i > 0; i--)\n\t\t\tfor(int j = 0 ; j <= n-i; j++)\n\t\t\t{\n\t\t\t\ttemp = s.subSequence(j, i+j);\n\t\t\t\tif( s.substring(j+1, n).contains(temp) || s.substring(0, j+i-1).contains(temp))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\tSystem.out.println(0);\n\t}\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "\n\nimport java.awt.Point;\n\nimport java.io.*;\n\nimport java.util.Arrays;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\n\n\nimport static java.lang.Integer.*;\n\nimport static java.lang.Math.*;\n\n@SuppressWarnings(\"unused\")\n\npublic class round35C {\n\n    static class state{\n\n        int x, y, time;\n\n        public state(int xx, int yy, int t){\n\n            x = xx;\n\n            y = yy;\n\n            time = t;\n\n        }\n\n    }\n\n    static int N,M;\n\n    static int [] dx = new int [] {1,-1,0,0};\n\n    static int [] dy = new int [] {0,0,1,-1};\n\n    static Queue<state> bfs = new LinkedList<round35C.state>();\n\n    public static Point runBFS(){\n\n        boolean [][] vis = new boolean [N + 1][M + 1];\n\n        int max = -(int)1e9;\n\n        int bestx = -1;\n\n        int besty = -1;\n\n        while(!bfs.isEmpty()){\n\n            state p = bfs.poll();\n\n            int x = p.x;\n\n            int y = p.y;\n\n            int time = p.time;\n\n            if(vis[x][y])\n\n                continue;\n\n            vis[x][y] = true;\n\n            if(time > max){\n\n                max = time;\n\n                bestx = x + 1;\n\n                besty = y + 1;\n\n            }\n\n            for(int i = 0 ; i < 4 ; ++i){\n\n                int nx = x + dx[i];\n\n                int ny = y + dy[i];\n\n                if(nx < 0 || ny < 0 || nx >= N || ny >= M)\n\n                    continue;\n\n                if(vis[nx][ny] == false)\n\n                    bfs.offer(new state(nx, ny, time + 1));\n\n            }\n\n        }\n\n        return new Point(bestx, besty);\n\n    }\n\n    public static void main(String[] args)throws IOException {\n\n        BufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n\n        PrintWriter out = new PrintWriter(\"output.txt\");\n\n        String [] use = null;\n\n        use = br.readLine().split(\" \");\n\n        N = parseInt(use[0]);\n\n        M = parseInt(use[1]);\n\n        int K = parseInt(br.readLine());\n\n        use = br.readLine().split(\" \");\n\n        for(int i = 0 ; i < 2 * K ; i += 2){\n\n            int f = parseInt(use[i]) - 1;\n\n            int t = parseInt(use[i + 1]) - 1;\n\n            bfs.offer(new state(f, t, 0));\n\n        }\n\n        Point ans = runBFS();\n\n        out.println(ans.x + \" \" + ans.y);\n\n        out.flush();\n\n        out.close();\n\n    }\n\n\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.awt.*;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport java.util.Queue;\n\n\n\npublic class A {\n\n\n\n    static int[] dx = {-1, 0, 1, 0};\n\n    static int[] dy = {0, 1, 0, -1};\n\n\n\n    public static void main(String[] args) throws Exception {\n\n        Scanner sc = new Scanner(\"input.txt\");\n\n        PrintWriter out = new PrintWriter(\"output.txt\");\n\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n\n        int[][] dist = new int[n][m];\n\n        for(int[] a : dist) Arrays.fill(a, -1);\n\n        Queue<Point> q = new LinkedList<>();\n\n        for(int i = 0; i < k; i++)\n\n        {\n\n            int x = sc.nextInt() - 1, y = sc.nextInt() - 1;\n\n            dist[x][y] = 0;\n\n            q.add(new Point(x, y));\n\n        }\n\n        int ansX = -1, ansY = -1;\n\n        while(!q.isEmpty())\n\n        {\n\n            Point cur = q.remove();\n\n            ansX = cur.x; ansY = cur.y;\n\n            for(int i = 0; i < 4; i++)\n\n            {\n\n                int x = cur.x + dx[i], y = cur.y + dy[i];\n\n                if(x != -1 && y != -1 && x != n && y != m && dist[x][y] == -1)\n\n                {\n\n                    q.add(new Point(x, y));\n\n                    dist[x][y] = dist[cur.x][cur.y] + 1;\n\n                }\n\n            }\n\n        }\n\n        out.println((ansX + 1) + \" \" + (ansY + 1));\n\n        out.flush();\n\n        out.close();\n\n    }\n\n    static class Scanner\n\n    {\n\n        StringTokenizer st;\n\n        BufferedReader br;\n\n\n\n        public Scanner(InputStream system) {br = new BufferedReader(new InputStreamReader(system));}\n\n        public Scanner(String file) throws Exception {br = new BufferedReader(new FileReader(file));}\n\n        public String next() throws IOException\n\n        {\n\n            while (st == null || !st.hasMoreTokens())\n\n                st = new StringTokenizer(br.readLine());\n\n            return st.nextToken();\n\n        }\n\n        public String nextLine()throws IOException{return br.readLine();}\n\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n        public double nextDouble() throws IOException {return Double.parseDouble(next());}\n\n        public char nextChar()throws IOException{return next().charAt(0);}\n\n        public Long nextLong()throws IOException{return Long.parseLong(next());}\n\n        public boolean ready() throws IOException{return br.ready();}\n\n        public void waitForInput() throws InterruptedException {Thread.sleep(4000);}\n\n    }\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class A {\n    static InputStreamReader in = new InputStreamReader(System.in);\n    static BufferedReader bf = new BufferedReader(in);\n    static StreamTokenizer st = new StreamTokenizer(bf);\n    static Scanner sc = new Scanner(System.in);\n\n    static class Sort implements Comparable<Sort> {\n        int x, a;\n\n        public int compareTo(Sort arg0) {\n            if (this.x > arg0.x)\n                return 1;\n            return 0;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        double t = nextInt();\n        Sort[] p = new Sort[n];\n\n        for (int i = 0; i < n; i++) {\n            p[i] = new Sort();\n            p[i].x = nextInt();\n            p[i].a = nextInt();\n        }\n        int ans = 2;\n        Arrays.sort(p);\n        for (int i = 1; i < p.length; i++) {\n            double k = p[i].x - p[i].a / 2.0 - p[i - 1].x - p[i - 1].a / 2.0;\n            if (t == k)\n                ans++;\n            else if (k > t)\n                ans += 2;\n        }\n        System.out.println(ans);\n    }\n\n    private static String nextString() throws IOException {\n        st.nextToken();\n        return st.sval;\n    }\n\n    private static int nextInt() throws IOException {\n        st.nextToken();\n        return (int) st.nval;\n    }\n\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\nimport java.io.*;\nimport static java.lang.System.in;\n\npublic class Main {\n    public static void main(String[] args)throws IOException{\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] point = new int[n][];\n        for(int i=0;i<n;i++) point[i] = new int[]{sc.nextInt(),sc.nextInt()};\n        Arrays.sort(point,(a,b)->((a[0]-a[1])-(b[0]-b[1])));\n        TreeMap<Integer,Integer> tm = new TreeMap<>();\n        int ans = 0;\n        for(int i=n-1;i>=0;i--){\n            int x = point[i][0], w = point[i][1];\n            Map.Entry<Integer,Integer> cur =  tm.ceilingEntry(x+w);\n            int curRes;\n            if(cur==null) curRes = 1;\n            else curRes = cur.getValue()+1;\n            ans = Math.max(ans,curRes);\n            Map.Entry<Integer,Integer> upper = tm.ceilingEntry(x-w);\n            if(upper==null||upper.getValue()<curRes) tm.put(x-w,curRes);\n            //Integer key = tm.\n        }\n        System.out.println(ans);\n    }\n}\n", "complexity": "nlogn", "problem": "0528_B", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import java.io.BufferedWriter;\n\nimport java.io.File;\n\nimport java.io.FileWriter;\n\nimport java.io.IOException;\n\nimport java.io.OutputStreamWriter;\n\nimport java.util.Arrays;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\nimport java.util.Scanner;\n\n\n\n\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n\n        Scanner scn = new Scanner(new File(\"input.txt\"));\n\n        BufferedWriter out = new BufferedWriter(new FileWriter(\"output.txt\")); \n\n        \n\n        int r = scn.nextInt();\n\n        int c = scn.nextInt();\n\n        \n\n        int[][] a = new int[r][c];\n\n        \n\n        for(int[] i: a)\n\n            Arrays.fill(i, 1<<30);\n\n        \n\n        int k = scn.nextInt();\n\n            \n\n        Queue<State> q = new LinkedList<State>();\n\n        for(int l = 0; l < k; l++){\n\n            int i = scn.nextInt()-1;\n\n            int j = scn.nextInt()-1;\n\n        \n\n            a[i][j] = 0;\n\n            q.add(new State(i, j, 0));\n\n        }\n\n        \n\n        while(!q.isEmpty()){\n\n            State st = q.poll();\n\n            \n\n            a[st.i][st.j] = st.c;\n\n            \n\n            for(int d = 0; d < 4; d++){\n\n                int ii = st.i + di[d];\n\n                int jj = st.j + dj[d];\n\n                \n\n                if(ii < 0 || ii >= r || jj < 0 || jj >= c)continue;\n\n                if(a[ii][jj] != 1 << 30)continue;\n\n                \n\n                a[ii][jj] = st.c+1;\n\n                q.add(new State(ii, jj, st.c+1));\n\n            }\n\n        }\n\n        \n\n        int max = 0;\n\n        for(int i = 0; i < r; i++)\n\n            for(int j = 0; j < c; j++)\n\n                max = Math.max(max, a[i][j]);\n\n        \n\n        for(int i = 0; i < r; i++)\n\n            for(int j = 0; j < c; j++)\n\n                if(a[i][j] == max){\n\n//                  System.out.println(i+1 + \" \" + (j+1));\n\n                    out.write((i+1)+\" \"+(j+1));\n\n                    out.newLine();\n\n                    \n\n                    out.close();\n\n                    \n\n                    return;\n\n                }\n\n        \n\n    }\n\n    static int[] di = {0, 0, -1, 1};\n\n    static int[] dj = {1, -1, 0, 0};\n\n}\n\n\n\nclass State{\n\n    int i, j, c;\n\n    public State(int ii, int ji, int ci){\n\n        i = ii;\n\n        j = ji;\n\n        c = ci;\n\n    }\n\n}", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\n\npublic class P1517D {\n\t// author: Nagabhushan S Baddi\n\n\t// PRIMARY VARIABLES\n\tprivate static int n, m, k;\n\tprivate static int[][] hor, ver, a, b;\n\tprivate static long ans;\n\tprivate static int[][] id;\n\tprivate static Integer[][][] dp;\n\tprivate static int idf;\n\tprivate static String s, t;\n\tprivate static HashMap<Integer, ArrayList<Integer>> g;\n\n\t// CONSTANTS\n\tprivate static final int MOD = (int) 1e9 + 7;\n\n\tpublic static void main(String[] args) {\n\t\tn = ini();\n\t\tm = ini();\n\t\tk = ini();\n\t\t\n\t\tif (k%2!=0) {\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\tprint(-1+\" \");\n\t\t\t\t}\n\t\t\t\tprintln();\n\t\t\t}\n\t\t\tout.flush();\n\t\t\treturn;\n\t\t}\n\n\t\thor = new int[n][m-1];\n\t\tver = new int[n-1][m];\n\t\t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tfor(int j=0; j<m-1; j++) {\n\t\t\t\thor[i][j] = ini();\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n-1; i++) {\n\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\tver[i][j] = ini();\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp = new Integer[n][m][k+1];\n\t\t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\tprint(2*solve(i, j, k/2)+\" \");\n\t\t\t}\n\t\t\tprintln();\n\t\t}\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\t\n\tprivate static int solve(int i, int j, int kLeft) {\n\t\tif (i<0 || i>=n || j<0 || j>=m) {\n\t\t\treturn (int)1e9;\n\t\t} else if (kLeft==0) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (dp[i][j][kLeft]!=null) {\n\t\t\treturn dp[i][j][kLeft];\n\t\t}\n\t\t\n\t\tint ans = (int)1e9;\n\t\t\n\t\tfinal int[] dx = {-1, 1, 0, 0};\n\t\tfinal int[] dy = {0, 0, -1, 1};\n\t\t\n\t\tfor(int type=0; type<4; type++) {\n\t\t\tint ni = i+dx[type];\n\t\t\tint nj = j+dy[type];\n\t\t\tif (ni<0 || ni>=n || nj<0 || nj>=m) continue;\n\t\t\t\n\t\t\tint inhibit = 0;\n\t\t\tif (type==0) {\n\t\t\t\tinhibit = ver[ni][nj];\n\t\t\t} else if (type==1) {\n\t\t\t\tinhibit = ver[i][j];\n\t\t\t} else if (type==2) {\n\t\t\t\tinhibit = hor[ni][nj];\n\t\t\t} else {\n\t\t\t\tinhibit = hor[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tans = Math.min(ans, inhibit+solve(ni, nj, kLeft-1));\n\t\t}\n\t\t\n\t\treturn dp[i][j][kLeft]=ans;\n\t}\n\n\t// INIT\n\tprivate static void initCase(int z) {\n\t\tidf = z;\n\t\tans = 0;\n\t}\n\n\t// PRINT ANSWER\n\tprivate static void printAns(Object o) {\n\t\tout.println(o);\n\t}\n\n\tprivate static void printAns(Object o, int testCaseNo) {\n\t\tout.println(\"Case #\" + testCaseNo + \": \" + o);\n\t}\n\n\tprivate static void printArray(Object[] a) {\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tout.print(a[i] + \" \");\n\t\t}\n\t\tout.println();\n\t}\n\n\t// SORT SHORTCUTS - QUICK SORT TO MERGE SORT\n\tprivate static void sort(int[] a) {\n\t\tint n = a.length;\n\t\tInteger[] b = new Integer[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = a[i];\n\t\t}\n\n\t\tArrays.sort(b);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = b[i];\n\t\t}\n\t}\n\n\tprivate static void sort(long[] a) {\n\t\tint n = a.length;\n\t\tLong[] b = new Long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = a[i];\n\t\t}\n\n\t\tArrays.sort(b);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = b[i];\n\t\t}\n\t}\n\n\t// INPUT SHORTCUTS\n\n\tprivate static int[] ina(int n) {\n\t\tint[] temp = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttemp[i] = in.nextInt();\n\t\t}\n\t\treturn temp;\n\t}\n\n\tprivate static int[][] ina2d(int n, int m) {\n\t\tint[][] temp = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttemp[i] = ina(m);\n\t\t}\n\t\treturn temp;\n\t}\n\n\tprivate static int ini() {\n\t\treturn in.nextInt();\n\t}\n\n\tprivate static long inl() {\n\t\treturn in.nextLong();\n\t}\n\n\tprivate static double ind() {\n\t\treturn Double.parseDouble(ins());\n\t}\n\n\tprivate static String ins() {\n\t\treturn in.readString();\n\t}\n\n\t// PRINT SHORTCUTS\n\tprivate static void println(Object... o) {\n\t\tfor (Object x : o) {\n\t\t\tout.write(x + \"\");\n\t\t}\n\t\tout.write(\"\\n\");\n\t}\n\n\tprivate static void pd(Object... o) {\n\t\tfor (Object x : o) {\n\t\t\tout.write(x + \"\");\n\t\t}\n\t\tout.flush();\n\t\tout.write(\"\\n\");\n\t}\n\n\tprivate static void print(Object... o) {\n\t\tfor (Object x : o) {\n\t\t\tout.write(x + \"\");\n\t\t}\n\t}\n\n\t// GRAPH SHORTCUTS\n\tprivate static HashMap<Integer, ArrayList<Integer>> intree(int n) {\n\n\t\tHashMap<Integer, ArrayList<Integer>> g = new HashMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg.put(i, new ArrayList<>());\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint u = ini() - 1;\n\t\t\tint v = ini() - 1;\n\t\t\tg.get(u).add(v);\n\t\t\tg.get(v).add(u);\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tprivate static HashMap<Integer, ArrayList<Integer>> ingraph(int n, int m) {\n\t\tHashMap<Integer, ArrayList<Integer>> g = new HashMap<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg.put(i, new ArrayList<>());\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = ini() - 1;\n\t\t\tint v = ini() - 1;\n\t\t\tg.get(u).add(v);\n\t\t\tg.get(v).add(u);\n\t\t}\n\n\t\treturn g;\n\n\t}\n\n\tprivate static HashMap<Integer, ArrayList<Integer>> indirectedgraph(int n, int m) {\n\t\tHashMap<Integer, ArrayList<Integer>> g = new HashMap<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg.put(i, new ArrayList<>());\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = ini() - 1;\n\t\t\tint v = ini() - 1;\n\t\t\tg.get(u).add(v);\n\t\t}\n\n\t\treturn g;\n\n\t}\n\n\tprivate static HashMap<Integer, ArrayList<Edge>> inweightedgraph(int n, int m) {\n\t\tHashMap<Integer, ArrayList<Edge>> g = new HashMap<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg.put(i, new ArrayList<>());\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = ini() - 1;\n\t\t\tint v = ini() - 1;\n\t\t\tint w = ini();\n\t\t\tEdge edge = new Edge(u, v, w);\n\t\t\tg.get(u).add(edge);\n\t\t\tg.get(v).add(edge);\n\t\t}\n\n\t\treturn g;\n\n\t}\n\n\tprivate static class Edge implements Comparable<Edge> {\n\t\tprivate int u, v;\n\t\tprivate long w;\n\n\t\tpublic Edge(int a, int b, long c) {\n\t\t\tu = a;\n\t\t\tv = b;\n\t\t\tw = c;\n\t\t}\n\n\t\tpublic int other(int x) {\n\t\t\treturn (x == u ? v : u);\n\t\t}\n\n\t\tpublic int compareTo(Edge edge) {\n\t\t\treturn Long.compare(w, edge.w);\n\t\t}\n\t}\n\n\tprivate static class Pair {\n\t\tprivate int u, v;\n\n\t\tpublic Pair(int a, int b) {\n\t\t\tu = a;\n\t\t\tv = b;\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn u + v + u * v;\n\t\t}\n\n\t\tpublic boolean equals(Object object) {\n\t\t\tPair pair = (Pair) object;\n\t\t\treturn u == pair.u && v == pair.v;\n\t\t}\n\t}\n\n\tprivate static class Node implements Comparable<Node> {\n\t\tprivate int u;\n\t\tprivate long dist;\n\n\t\tpublic Node(int a, long b) {\n\t\t\tu = a;\n\t\t\tdist = b;\n\t\t}\n\n\t\tpublic int compareTo(Node node) {\n\t\t\treturn Long.compare(dist, node.dist);\n\t\t}\n\t}\n\n\t// MATHS AND NUMBER THEORY SHORTCUTS\n\tprivate static int gcd(int a, int b) {\n\t\t// O(log(min(a,b)))\n\t\tif (b == 0)\n\t\t\treturn a;\n\n\t\treturn gcd(b, a % b);\n\t}\n\n\tprivate static long modExp(long a, long b) {\n\t\tif (b == 0)\n\t\t\treturn 1;\n\n\t\ta %= MOD;\n\n\t\tlong exp = modExp(a, b / 2);\n\n\t\tif (b % 2 == 0) {\n\t\t\treturn (exp * exp) % MOD;\n\t\t} else {\n\t\t\treturn (a * ((exp * exp) % MOD)) % MOD;\n\t\t}\n\t}\n\n\tprivate long mul(int a, int b) {\n\t\treturn a * 1L * b;\n\t}\n\n\t// Segment Tree\n\tprivate static class SegmentTree<T extends Comparable<T>> {\n\t\tprivate int n, m;\n\t\tprivate T[] a;\n\t\tprivate T[] seg;\n\t\tprivate T NULLVALUE;\n\n\t\tpublic SegmentTree(int n, T NULLVALUE) {\n\t\t\tthis.NULLVALUE = NULLVALUE;\n\t\t\tthis.n = n;\n\t\t\tm = 4 * n;\n\t\t\tseg = (T[]) new Object[m];\n\n\t\t}\n\n\t\tpublic SegmentTree(T[] a, int n, T NULLVALUE) {\n\t\t\tthis.NULLVALUE = NULLVALUE;\n\t\t\tthis.a = a;\n\t\t\tthis.n = n;\n\t\t\tm = 4 * n;\n\t\t\tseg = (T[]) new Object[m];\n\t\t\tconstruct(0, n - 1, 0);\n\t\t}\n\n\t\tprivate void update(int pos) {\n\t\t\t// Range Sum\n\t\t\t// seg[pos] = seg[2*pos+1]+seg[2*pos+2];\n\n\t\t\t// Range Min\n\t\t\tif (seg[2 * pos + 1].compareTo(seg[2 * pos + 2]) <= 0) {\n\t\t\t\tseg[pos] = seg[2 * pos + 1];\n\t\t\t} else {\n\t\t\t\tseg[pos] = seg[2 * pos + 2];\n\t\t\t}\n\t\t}\n\n\t\tprivate T optimum(T leftValue, T rightValue) {\n\t\t\t// Range Sum\n\t\t\t// return leftValue+rightValue;\n\n\t\t\t// Range Min\n\t\t\tif (leftValue.compareTo(rightValue) <= 0) {\n\t\t\t\treturn leftValue;\n\t\t\t} else {\n\t\t\t\treturn rightValue;\n\t\t\t}\n\t\t}\n\n\t\tpublic void construct(int low, int high, int pos) {\n\t\t\tif (low == high) {\n\t\t\t\tseg[pos] = a[low];\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint mid = (low + high) / 2;\n\n\t\t\tconstruct(low, mid, 2 * pos + 1);\n\t\t\tconstruct(mid + 1, high, 2 * pos + 2);\n\t\t\tupdate(pos);\n\t\t}\n\n\t\tpublic void add(int index, T value) {\n\t\t\tadd(index, value, 0, n - 1, 0);\n\t\t}\n\n\t\tprivate void add(int index, T value, int low, int high, int pos) {\n\t\t\tif (low == high) {\n\t\t\t\tseg[pos] = value;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint mid = (low + high) / 2;\n\n\t\t\tif (index <= mid) {\n\t\t\t\tadd(index, value, low, mid, 2 * pos + 1);\n\t\t\t} else {\n\t\t\t\tadd(index, value, mid + 1, high, 2 * pos + 2);\n\t\t\t}\n\t\t\tupdate(pos);\n\t\t}\n\n\t\tpublic T get(int qlow, int qhigh) {\n\t\t\treturn get(qlow, qhigh, 0, n - 1, 0);\n\t\t}\n\n\t\tpublic T get(int qlow, int qhigh, int low, int high, int pos) {\n\t\t\tif (qlow > low || low > qhigh) {\n\t\t\t\treturn NULLVALUE;\n\t\t\t} else if (qlow <= low || qhigh >= high) {\n\t\t\t\treturn seg[pos];\n\t\t\t} else {\n\t\t\t\tint mid = (low + high) / 2;\n\t\t\t\tT leftValue = get(qlow, qhigh, low, mid, 2 * pos + 1);\n\t\t\t\tT rightValue = get(qlow, qhigh, mid + 1, high, 2 * pos + 2);\n\n\t\t\t\treturn optimum(leftValue, rightValue);\n\t\t\t}\n\t\t}\n\t}\n\n\t// DSU\n\tprivate static class DSU {\n\t\tprivate int[] id;\n\t\tprivate int[] size;\n\t\tprivate int n;\n\n\t\tpublic DSU(int n) {\n\t\t\tthis.n = n;\n\n\t\t\tid = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tid[i] = i;\n\t\t\t}\n\n\t\t\tsize = new int[n];\n\t\t\tArrays.fill(size, 1);\n\t\t}\n\n\t\tprivate int root(int u) {\n\t\t\twhile (u != id[u]) {\n\t\t\t\tid[u] = id[id[u]];\n\t\t\t\tu = id[u];\n\t\t\t}\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean connected(int u, int v) {\n\t\t\treturn root(u) == root(v);\n\t\t}\n\n\t\tpublic void union(int u, int v) {\n\t\t\tint p = root(u);\n\t\t\tint q = root(v);\n\n\t\t\tif (size[p] >= size[q]) {\n\t\t\t\tid[q] = p;\n\t\t\t\tsize[p] += size[q];\n\t\t\t} else {\n\t\t\t\tid[p] = q;\n\t\t\t\tsize[q] += size[p];\n\t\t\t}\n\t\t}\n\t}\n\n\t// KMP\n\tprivate static int countSearch(String s, String p) {\n\t\tint n = s.length();\n\t\tint m = p.length();\n\n\t\tint[] b = backTable(p);\n\n\t\tint j = 0;\n\t\tint count = 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (j == m) {\n\t\t\t\tj = b[j - 1];\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\twhile (j != 0 && s.charAt(i) != p.charAt(j)) {\n\t\t\t\tj = b[j - 1];\n\t\t\t}\n\t\t\tif (s.charAt(i) == p.charAt(j)) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\n\t\tif (j == m)\n\t\t\tcount++;\n\n\t\treturn count;\n\t}\n\n\tprivate static int[] backTable(String p) {\n\t\tint m = p.length();\n\n\t\tint j = 0;\n\t\tint[] b = new int[m];\n\n\t\tfor (int i = 1; i < m; i++) {\n\t\t\twhile (j != 0 && p.charAt(i) != p.charAt(j)) {\n\t\t\t\tj = b[j - 1];\n\t\t\t}\n\t\t\tif (p.charAt(i) == p.charAt(j)) {\n\t\t\t\tb[i] = ++j;\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tprivate static class LCA {\n\t\tprivate HashMap<Integer, ArrayList<Integer>> g;\n\t\tprivate int[] level;\n\t\tprivate int[] a;\n\t\tprivate int[][] P;\n\t\tprivate int n, m;\n\t\tprivate int[] xor;\n\n\t\tpublic LCA(HashMap<Integer, ArrayList<Integer>> g, int[] a) {\n\t\t\tthis.g = g;\n\t\t\tthis.a = a;\n\t\t\tn = g.size();\n\t\t\tm = (int) (Math.log(n) / Math.log(2)) + 5;\n\t\t\tP = new int[n][m];\n\t\t\txor = new int[n];\n\t\t\tlevel = new int[n];\n\n\t\t\tpreprocess();\n\t\t}\n\n\t\tprivate void preprocess() {\n\t\t\tdfs(0, -1);\n\n\t\t\tfor (int j = 1; j < m; j++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (P[i][j - 1] != -1) {\n\t\t\t\t\t\tP[i][j] = P[P[i][j - 1]][j - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void dfs(int u, int p) {\n\t\t\tP[u][0] = p;\n\t\t\txor[u] = a[u] ^ (p == -1 ? 0 : xor[p]);\n\t\t\tlevel[u] = (p == -1 ? 0 : level[p] + 1);\n\n\t\t\tfor (int v : g.get(u)) {\n\t\t\t\tif (v == p)\n\t\t\t\t\tcontinue;\n\t\t\t\tdfs(v, u);\n\t\t\t}\n\t\t}\n\n\t\tpublic int lca(int u, int v) {\n\t\t\tif (level[v] > level[u]) {\n\t\t\t\tint temp = v;\n\t\t\t\tv = u;\n\t\t\t\tu = temp;\n\t\t\t}\n\n\t\t\tfor (int j = m; j >= 0; j--) {\n\t\t\t\tif (level[u] - (1 << j) < level[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tu = P[u][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (u == v)\n\t\t\t\treturn u;\n\n\t\t\tfor (int j = m - 1; j >= 0; j--) {\n\t\t\t\tif (P[u][j] == -1 || P[u][j] == P[v][j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tu = P[u][j];\n\t\t\t\t\tv = P[v][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn P[u][0];\n\t\t}\n\n\t\tprivate int xor(int u, int v) {\n\t\t\tint l = lca(u, v);\n\n\t\t\treturn xor[u] ^ xor[v] ^ a[l];\n\t\t}\n\t}\n\n\t// FAST INPUT OUTPUT LIBRARY\n\tprivate static InputReader in = new InputReader(System.in);\n\tprivate static PrintWriter out = new PrintWriter(System.out);\n\n\tprivate static class InputReader {\n\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\n\t\tpublic InputReader(InputStream st) {\n\t\t\tthis.stream = st;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t}\n}\n\n\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\n\npublic class Prob015A\n{\n    public static void main( String[] Args )\n    {\n        Scanner scan = new Scanner( System.in );\n        int numHouses = scan.nextInt();\n        int side = scan.nextInt() * 2;\n\n        ArrayList<Integer> sides = new ArrayList<Integer>();\n        for ( int x = 0; x < numHouses; x++ )\n        {\n            int c = scan.nextInt() * 2;\n            int s = scan.nextInt();\n\n            int l = c - s;\n            int r = c + s;\n\n            int li = Collections.binarySearch( sides, l );\n            int ri = Collections.binarySearch( sides, r );\n\n            if ( li >= 0 && ri >= 0 )\n            {\n                sides.remove( li );\n                sides.remove( li );\n            }\n            else if ( li >= 0 )\n                sides.set( li, r );\n            else if ( ri >= 0 )\n                sides.set( ri, l );\n            else\n            {\n                sides.add( -li - 1, r );\n                sides.add( -li - 1, l );\n            }\n        }\n\n        int possibilities = 2;\n        for ( int x = 1; x < sides.size() - 1; x += 2 )\n            if ( sides.get( x + 1 ) - sides.get( x ) > side )\n                possibilities += 2;\n            else if ( sides.get( x + 1 ) - sides.get( x ) == side )\n                possibilities += 1;\n\n        System.out.println( possibilities );\n    }\n}\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\npublic class a {\npublic static void main(String[] args)\n{\n    Scanner input = new Scanner(System.in);\n    int n = input.nextInt(), m = input.nextInt(), k = input.nextInt();\n    int[] data = new int[n];\n    for(int i = 0; i<n; i++)\n        data[i] = input.nextInt();\n    Arrays.sort(data);\n    m -= k;\n    int at = n-1;\n    int count = 0;\n    while(at>=0 && m>0)\n    {\n        count++;\n        m++;\n        m -= data[at];\n        at--;\n    }\n    if(m>0)\n        System.out.println(-1);\n    else\n        System.out.println(count);\n}\n}\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class VKRound2Div2Task1 {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = br.readLine();\n\t\tString[] strs = str.split(\" \");\n\t\tint n = Integer.parseInt(strs[0]);\n\t\tint a = Integer.parseInt(strs[1]);\n\t\tint b = Integer.parseInt(strs[2]);\n\t\tstr = br.readLine();\n\t\tString[] hs = str.split(\" \");\n\t\tint[] h = new int[hs.length];\n\t\tfor(int i=0;i<hs.length;i++){\n\t\t\th[i] = Integer.parseInt(hs[i]);\n\t\t}\n\t\tArrays.sort(h);\n\t\tif(h[b-1]==h[b]){\n\t\t\tSystem.out.println(0);\n\t\t}else{\n\t\t\tSystem.out.println(h[b]-h[b-1]);\n\t\t}\n\t\t\n\t}\n\n}\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class GeorgeInterestingGraph {\n    \n    int N = 505;\n    int INF = (int) 1e9;\n    \n    List<Integer>[] G = new List[N];\n    int[] match = new int[N];\n    int[] used = new int[N];\n    int cur = 0;\n    \n    {\n        for (int i = 0; i < N; i++) G[i] = new ArrayList<>(1);\n    }\n    \n    void solve() {\n        int n = in.nextInt(), m = in.nextInt();\n        int[] fr = new int[m], to = new int[m];\n        for (int i = 0; i < m; i++) {\n            fr[i] = in.nextInt() - 1;\n            to[i] = in.nextInt() - 1;\n        }\n        \n        int ans = INF;\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                G[j].clear();\n                match[j] = -1;\n            }\n            for (int j = 0; j < m; j++) {\n                if (fr[j] == i || to[j] == i) {\n                    cnt++;\n                } else {\n                    G[fr[j]].add(to[j]);\n                }\n            }\n            \n            int other = m - cnt;\n            \n            int max = 0;\n            for (int j = 0; j < n; j++) {\n                cur++;\n                if (augment(j)) max++;\n            }\n            \n            ans = Math.min(ans, 2 * (n - 1) + 1 - cnt + other - max + (n - 1) - max);\n        }\n        out.println(ans);\n    }\n    \n    boolean augment(int u) {\n        if (used[u] == cur) return false;\n        used[u] = cur;\n        for (int v : G[u]) {\n            if (match[v] < 0 || augment(match[v])) {\n                match[v] = u;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new GeorgeInterestingGraph().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "complexity": "cubic", "problem": "0387_D", "from": "CODEFORCES", "tags": "graph matchings"}
{"src": "import java.io.*;\nimport java.util.*;\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class Main {\n\tstatic final int N=512;static final int inf=0x7fffffff;\n\tstatic int n, m, k,tp,d[][][],f[][][];\n\tstatic int dx[] = { 0,0,-1,1 };\n\tstatic int dy[] = { 1,-1,0,0 };\n\tstatic int dfs(int x, int y, int k) {\n\t\tif (k == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint mi = inf;\n\t\tif (f[x][y][k] != -1) {\n\t\t\treturn f[x][y][k];\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint tx = x + dx[i];\n\t\t\tint ty = y + dy[i];\n\t\t\tif (1 <= tx && tx <= n && 1 <= ty && ty <= m) {\n\t\t\t\tmi = Math.min(mi, dfs(tx, ty, k - 1) + d[x][y][i]);//\u56db\u4e2a\u65b9\u5411\u8d70\n\t\t\t}\n\t\t}\n\t\treturn f[x][y][k] = mi;//\u8bb0\u5fc6\u5316\n\t}\n\tstatic int gao(int x, int y) {\n\t\tif (k % 2 == 1) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn dfs(x, y, k / 2) * 2;\n\t\t}\n\t}\n    public static void main(String args[])\n    {\n    \td=new int[N][N][6];\n        f=new int[N][N][18];\n        for(int i=0;i<N;++i)\n        \tfor(int j=0;j<N;++j)\n        \t\tfor(int kk=0;kk<18;++kk)f[i][j][kk]=-1;\n        Scanner in = new Scanner(System.in);\n        n=in.nextInt();m=in.nextInt();k=in.nextInt();\n        for (int i = 1; i <= n; i++) {\n    \t\tfor (int j = 1; j < m; j++) {\n    \t\t\ttp=in.nextInt();\n    \t\t\td[i][j][0] = tp;\n    \t\t\td[i][j + 1][1] = tp;\n    \t\t}\n    \t}\n\n    \tfor (int i = 1; i < n; i++) {\n    \t\tfor (int j = 1; j <= m; j++) {\n    \t\t\ttp=in.nextInt();\n    \t\t\td[i][j][3] = tp;\n    \t\t\td[i + 1][j][2] = tp;\n    \t\t}\n    \t}\n    \tfor (int i = 1; i <= n; i++) {\n    \t\tfor (int j = 1; j <= m; j++) {\n    \t\t\tSystem.out.print(gao(i, j)+\" \");\n    \t\t}\n    \t\tSystem.out.println();\n    \t}\n    }\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tstatic int n, t[], g[], MOD = (int) 1e9 + 7;\n\tstatic int[][][] memo1, memo2[], memo3[];\n\n\tstatic int dp1(int idx, int remCnt, int remSum) {\n\t\tif (idx == n)\n\t\t\treturn remSum == 0 && remCnt == 0 ? 1 : 0;\n\t\tif (remCnt < 0 || remSum < 0)\n\t\t\treturn 0;\n\t\tif (memo1[idx][remCnt][remSum] != -1)\n\t\t\treturn memo1[idx][remCnt][remSum];\n\t\tint ans = dp1(idx + 1, remCnt, remSum);\n\t\tif (g[idx] == 0) {\n\t\t\tans += dp1(idx + 1, remCnt - 1, remSum - t[idx]);\n\t\t\tif (ans >= MOD)\n\t\t\t\tans -= MOD;\n\t\t}\n\t\treturn memo1[idx][remCnt][remSum] = ans;\n\t}\n\n\tstatic int dp2(int idx, int remCnt1, int remCnt2, int remSum) {\n\n\t\tif (idx == n)\n\t\t\treturn remSum == 0 && remCnt1 == 0 && remCnt2 == 0 ? 1 : 0;\n\t\tif (remSum < 0 || remCnt1 < 0 || remCnt2 < 0)\n\t\t\treturn 0;\n\t\tif (memo2[idx][remCnt1][remCnt2][remSum] != -1)\n\t\t\treturn memo2[idx][remCnt1][remCnt2][remSum];\n\t\tint ans = dp2(idx + 1, remCnt1, remCnt2, remSum);\n\n\t\tif (g[idx] == 1)\n\t\t\tans += dp2(idx + 1, remCnt1 - 1, remCnt2, remSum - t[idx]);\n\t\telse if (g[idx] == 2)\n\t\t\tans += dp2(idx + 1, remCnt1, remCnt2 - 1, remSum - t[idx]);\n\t\tif (ans >= MOD)\n\t\t\tans -= MOD;\n\t\treturn memo2[idx][remCnt1][remCnt2][remSum] = ans;\n\t}\n\n\tprivate static int dp3(int cnt0, int cnt1, int cnt2, int last) {\n\t\tif (cnt0 + cnt1 + cnt2 == 0)\n\t\t\treturn 1;\n\t\tif (memo3[last][cnt0][cnt1][cnt2] != -1)\n\t\t\treturn memo3[last][cnt0][cnt1][cnt2];\n\t\tlong ans = 0;\n\t\tif (cnt0 > 0 && last != 0)\n\t\t\tans += dp3(cnt0 - 1, cnt1, cnt2, 0);\n\t\tif (cnt1 > 0 && last != 1)\n\t\t\tans += dp3(cnt0, cnt1 - 1, cnt2, 1);\n\t\tif (cnt2 > 0 && last != 2)\n\t\t\tans += dp3(cnt0, cnt1, cnt2 - 1, 2);\n\t\treturn memo3[last][cnt0][cnt1][cnt2] = (int) (ans % MOD);\n\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tn = sc.nextInt();\n\t\tint[] fac = new int[n + 1];\n\t\tt = new int[n];\n\t\tg = new int[n];\n\t\tint[] cnt = new int[3];\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfac[i] = (int) (i * 1L * fac[i - 1] % MOD);\n\t\tint T = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tt[i] = sc.nextInt();\n\t\t\tg[i] = sc.nextInt() - 1;\n\t\t\tcnt[g[i]]++;\n\n\t\t}\n\t\tmemo1 = new int[n][cnt[0] + 1][T + 1];\n\t\tmemo2 = new int[n][cnt[1] + 1][cnt[2] + 1][T + 1];\n\t\tmemo3 = new int[4][cnt[0] + 1][cnt[1] + 1][cnt[2] + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= cnt[0]; j++)\n\t\t\t\tArrays.fill(memo1[i][j], -1);\n\t\t\tfor (int j = 0; j <= cnt[1]; j++)\n\t\t\t\tfor (int k = 0; k <= cnt[2]; k++)\n\t\t\t\t\tArrays.fill(memo2[i][j][k], -1);\n\n\t\t}\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j <= cnt[0]; j++)\n\t\t\t\tfor (int k = 0; k <= cnt[1]; k++)\n\t\t\t\t\tArrays.fill(memo3[i][j][k], -1);\n\t\tint ans = 0;\n\t\tfor (int cnt0 = 0; cnt0 <= cnt[0]; cnt0++)\n\t\t\tfor (int sum0 = 0; sum0 <= T; sum0++)\n\t\t\t\tfor (int cnt1 = 0; cnt1 <= cnt[1]; cnt1++)\n\t\t\t\t\tfor (int cnt2 = 0; cnt2 <= cnt[2]; cnt2++) {\n\t\t\t\t\t\tlong ways = dp1(0, cnt0, sum0) * 1L * dp2(0, cnt1, cnt2, T - sum0) % MOD;\n\t\t\t\t\t\tways = ways * dp3(cnt0, cnt1, cnt2, 3) % MOD;\n\t\t\t\t\t\tways *= fac[cnt0];\n\t\t\t\t\t\tways %= MOD;\n\t\t\t\t\t\tways *= fac[cnt1];\n\t\t\t\t\t\tways %= MOD;\n\t\t\t\t\t\tways *= fac[cnt2];\n\t\t\t\t\t\tways %= MOD;\n\t\t\t\t\t\tans += ways;\n\t\t\t\t\t\tif (ans >= MOD)\n\t\t\t\t\t\t\tans -= MOD;\n\t\t\t\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tboolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "complexity": "cubic", "problem": "1185_G2", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class A implements Runnable\n{\n\tpublic static void main(String [] args) throws IOException\n\t{\n\t\tnew Thread(null, new A(), \"\", 1 << 20).start();\n\t}\n\t\n\tString file = \"input\";\n\tBufferedReader input;\n\tPrintWriter out;\n\t\n\tpublic void run() \n\t{\n\t\ttry\n\t\t{\n\t\t\t//input = new BufferedReader(new FileReader(file + \".in\"));\n\t\t\tinput = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t\tsolve();\n\t\t\tinput.close();\n\t\t\tout.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tint N, T;\n\tvoid solve() throws IOException\n\t{\n\t\tStringTokenizer st = tokens();\n\t\tN = nextInt(st); T = nextInt(st);\n\t\tT *= 2;\n\t\tArrayList<Pair> list = new ArrayList<Pair>();\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tst = tokens();\n\t\t\tint c = nextInt(st), L = nextInt(st);\n\t\t\tc *= 2; L *= 2;\n\t\t\tlist.add(new Pair(c - L / 2, c + L / 2));\n\t\t}\n\t\tCollections.sort(list);\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < list.size(); i++)\n\t\t{\n\t\t\tif(i == 0 || list.get(i).x - list.get(i - 1).y >= T)\n\t\t\t{\n\t\t\t\tset.add(list.get(i).x - T / 2);\n\t\t\t}\n\t\t\tif(i == list.size() - 1 || list.get(i + 1).x - list.get(i).y >= T)\n\t\t\t{\n\t\t\t\tset.add(list.get(i).y + T / 2);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(set.size());\n\t}\n\tclass Pair implements Comparable<Pair>\n\t{\n\t\tint x, y;\n\t\tpublic Pair(int x, int y)\n\t\t{\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic int compareTo(Pair p)\n\t\t{\n\t\t\tif(x != p.x) return x - p.x;\n\t\t\treturn y - p.y;\n\t\t}\n\t}\n\n\tStringTokenizer tokens() throws IOException\n\t{\n\t\treturn new StringTokenizer(input.readLine());\n\t}\n\t\n\tString next(StringTokenizer st)\n\t{\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(input.readLine());\n\t}\n\t\n\tint nextInt(StringTokenizer st)\n\t{\n\t\treturn Integer.parseInt(st.nextToken());\n\t}\n\t\n\tdouble nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(input.readLine());\n\t}\n\t\n\tdouble nextDouble(StringTokenizer st)\n\t{\n\t\treturn Double.parseDouble(st.nextToken());\n\t}\n\t\n\tvoid print(Object... o)\n\t{\n\t\tout.println(deepToString(o));\n\t}\n}", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import java.util.*;\n\nimport java.math.*;\n\nimport java.io.*;\n\n\n\npublic class Main\n\n\t{\n\n\tpublic static void main(String args[]) throws IOException\n\n\t\t{\n\n\t\tScanner c = new Scanner(new FileReader(\"input.txt\"));\n\n\t\tPrintWriter out = new PrintWriter(new File(\"output.txt\"));\n\n\n\n\t\tint N=c.nextInt();\n\n\t\tint M=c.nextInt();\n\n\t\tint A[][]=new int[N][M];\n\n\t\tfor(int i=0;i<N;i++)\n\n\t\t\tArrays.fill(A[i],Integer.MAX_VALUE/100);\n\n\t\tint K=c.nextInt();\n\n\t\tfor(int i=0;i<K;i++)\n\n\t\t\t{\n\n\t\t\tint x=c.nextInt()-1;\n\n\t\t\tint y=c.nextInt()-1;\n\n\t\t\tfor(int i1=0;i1<N;i1++)\n\n\t\t\t\t{\n\n\t\t\t\tfor(int j1=0;j1<M;j1++)\n\n\t\t\t\t\tA[i1][j1]=Math.min(A[i1][j1],Math.abs(i1-x)+Math.abs(j1-y));\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\tint maxi=0;\n\n\t\tint maxj=0;\n\n\t\tfor(int i=0;i<N;i++)\n\n\t\t\t{\n\n\t\t\tfor(int j=0;j<M;j++)\n\n\t\t\t\t{\n\n\t\t\t\tif(A[i][j]>A[maxi][maxj])\n\n\t\t\t\t\t{\n\n\t\t\t\t\tmaxi=i;\n\n\t\t\t\t\tmaxj=j;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\tout.println((maxi+1)+\" \"+(maxj+1));\n\n\t\tout.close();\n\n\t\t}\n\n\t}\n\n\n\n//must declare new classes here", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF1497E2 extends PrintWriter {\n\tCF1497E2() { super(System.out); }\n\tstatic class Scanner {\n\t\tScanner(InputStream in) { this.in = in; } InputStream in;\n\t\tbyte[] bb = new byte[1 << 15]; int i, n;\n\t\tbyte getc() {\n\t\t\tif (i == n) {\n\t\t\t\ti = n = 0;\n\t\t\t\ttry { n = in.read(bb); } catch (IOException e) {}\n\t\t\t}\n\t\t\treturn i < n ? bb[i++] : 0;\n\t\t}\n\t\tint nextInt() {\n\t\t\tbyte c = 0; while (c <= ' ') c = getc();\n\t\t\tint a = 0; while (c > ' ') { a = a * 10 + c - '0'; c = getc(); }\n\t\t\treturn a;\n\t\t}\n\t}\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1497E2 o = new CF1497E2(); o.main(); o.flush();\n\t}\n\n\tstatic final int A = 10000000, K = 20;\n\tint[] cc = new int[A + 1]; {\n\t\tboolean[] composite = new boolean[A + 1];\n\t\tfor (int a = 1; a <= A; a++)\n\t\t\tcc[a] = a;\n\t\tfor (int a = 2; a <= A; a++) {\n\t\t\tif (composite[a])\n\t\t\t\tcontinue;\n\t\t\tfor (int b = a + a; b <= A; b += a)\n\t\t\t\tcomposite[b] = true;\n\t\t\tif (a <= A / a) {\n\t\t\t\tint a2 = a * a;\n\t\t\t\tfor (int b = a2; b <= A; b += a2) {\n\t\t\t\t\tint c = cc[b];\n\t\t\t\t\twhile (c % a2 == 0)\n\t\t\t\t\t\tc /= a2;\n\t\t\t\t\tcc[b] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid main() {\n\t\tint[] pp = new int[A + 1]; Arrays.fill(pp, -1);\n\t\tint t = sc.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tint[] aa = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\taa[i] = cc[sc.nextInt()];\n\t\t\tint[] mp = new int[k + 1];\n\t\t\tint[] ip = new int[k + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = aa[i];\n\t\t\t\tfor (int h = k; h >= 0; h--) {\n\t\t\t\t\tif (pp[a] >= ip[h]) {\n\t\t\t\t\t\tmp[h]++;\n\t\t\t\t\t\tip[h] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (h > 0 && (mp[h - 1] < mp[h] || mp[h - 1] == mp[h] && ip[h - 1] > ip[h])) {\n\t\t\t\t\t\tmp[h] = mp[h - 1];\n\t\t\t\t\t\tip[h] = ip[h - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpp[a] = i;\n\t\t\t}\n\t\t\tprintln(mp[k] + 1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = aa[i];\n\t\t\t\tpp[a] = -1;\n\t\t\t}\n\t\t}\n\t}\n}\n", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import static java.lang.Math.*;\n\nimport static java.util.Arrays.*;\n\nimport java.util.*;\n\nimport java.io.*;\n\n\n\npublic class Main {\n\n\n\n\tvoid solve() {\n\n\t\tint R = sc.nextInt();\n\n\t\tint C = sc.nextInt();\n\n\t\tint K = sc.nextInt();\n\n\t\tint[] x = new int[K];\n\n\t\tint[] y = new int[K];\n\n\t\tfor (int i = 0; i < K; i++) {\n\n\t\t\tx[i] = sc.nextInt();\n\n\t\t\ty[i] = sc.nextInt();\n\n\t\t}\n\n\n\n\t\tint best = -1;\n\n\t\tint bestX = 0;\n\n\t\tint bestY = 0;\n\n\n\n\t\tfor (int r = 1; r <= R; r++) for (int c = 1; c <= C; c++) {\n\n\t\t\tint here = R + C;\n\n\t\t\tfor (int i = 0; i < K; i++) {\n\n\t\t\t\tint t = abs(r - x[i]) + abs(c - y[i]);\n\n\t\t\t\there = min(here, t);\n\n\t\t\t}\n\n\t\t\tif (best < here){\n\n\t\t\t\tbest = here;\n\n\t\t\t\tbestX = r;\n\n\t\t\t\tbestY = c;\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\tout.println(bestX + \" \" + bestY);\n\n\t}\n\n\n\n\tvoid print(int[] a) {\n\n\t\tout.print(a[0]);\n\n\t\tfor (int i = 1; i < a.length; i++) out.print(\" \" + a[i]);\n\n\t\tout.println();\n\n\t}\n\n\n\n\tstatic void tr(Object... os) {\n\n\t\tSystem.err.println(deepToString(os));\n\n\t}\n\n\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tnew Main().run();\n\n\t}\n\n\n\n\tMyScanner sc = null;\n\n\tPrintWriter out = null;\n\n\tpublic void run() throws Exception {\n\n//\t\tsc = new MyScanner(System.in);\n\n//\t\tout = new PrintWriter(System.out);\n\n\t\tsc = new MyScanner(new FileInputStream(new File(\"input.txt\")));\n\n\t\tout = new PrintWriter(new File(\"output.txt\"));\n\n\t\tfor (;sc.hasNext();) {\n\n\t\t\tsolve();\n\n\t\t\tout.flush();\n\n\t\t}\n\n\t\tout.close();\n\n\t}\n\n\n\n\tclass MyScanner {\n\n\t\tString line;\n\n\t\tBufferedReader reader;\n\n\t\tStringTokenizer tokenizer;\n\n\n\n\t\tpublic MyScanner(InputStream stream) {\n\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\n\t\t\ttokenizer = null;\n\n\t\t}\n\n\t\tpublic void eat() {\n\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tline = reader.readLine();\n\n\t\t\t\t\tif (line == null) {\n\n\t\t\t\t\t\ttokenizer = null;\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\n\t\t\t\t} catch (IOException e) {\n\n\t\t\t\t\tthrow new RuntimeException(e);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tpublic String next() {\n\n\t\t\teat();\n\n\t\t\treturn tokenizer.nextToken();\n\n\t\t}\n\n\t\tpublic String nextLine() {\n\n\t\t\ttry {\n\n\t\t\t\treturn reader.readLine();\n\n\t\t\t} catch (IOException e) {\n\n\t\t\t\tthrow new RuntimeException(e);\n\n\t\t\t}\n\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\n\t\t\teat();\n\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\n\t\t}\n\n\t\tpublic int nextInt() {\n\n\t\t\treturn Integer.parseInt(next());\n\n\t\t}\n\n\t\tpublic long nextLong() {\n\n\t\t\treturn Long.parseLong(next());\n\n\t\t}\n\n\t\tpublic double nextDouble() {\n\n\t\t\treturn Double.parseDouble(next());\n\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\n\t\t\tint[] a = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\n\t\t\treturn a;\n\n\t\t}\n\n\t}\n\n}\n\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n/*\n\n2\n3 5\n\n2\n6 5\n1 11\n-10 12\n\n3\n3 6 2\n\n\n1   8   5   3\n-7  9   5   3\n-7  4   14  3\n\n\n1   8   5   3\n1   3   13  3\n-2  4   13  3\n   \n\n3\n1 3 6\n\n3 3 6\n\n5 12\n-7 19\n\n\n3 5 7 11 13\n-2 8\n\n\n5 9\n\n\n5 9\n\n\n3 6 7\n-3 9 7\n\n6 3 7\n\n\n*/\n\npublic class c {\n\tstatic int n;\n\tstatic int[] fs;\n\tstatic int[] cfs;\n\tstatic long[][] choose = chooseTable(1001);\n\tstatic long[] fact;\n\tstatic final long MOD = (long) (1e9 + 7);\n\tstatic long[][] memo;\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tn = in.nextInt();\n\t\tfact = new long[301];\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < fact.length; i++) {\n\t\t\tfact[i] = fact[i - 1] * i;\n\t\t\tfact[i] %= MOD;\n\t\t}\n\t\tHashMap<Long, Integer> map = new HashMap<Long, Integer>();\n\t\tfs = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong v = in.nextLong();\n\t\t\tlong r = 1;\n\t\t\tfor (int d = 2; d * d <= v; d++) {\n\t\t\t\tint cnt = 0;\n\t\t\t\twhile (v % d == 0) {\n\t\t\t\t\tv /= d;\n\t\t\t\t\tcnt ^= 1;\n\t\t\t\t}\n\t\t\t\tif (cnt == 1) {\n\t\t\t\t\tr *= d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr *= v;\n\t\t\tif (!map.containsKey(r)) {\n\t\t\t\tmap.put(r, map.size());\n\t\t\t}\n\t\t\tfs[map.get(r)]++;\n\t\t}\n\t\tcfs = new int[n];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcfs[i] = cfs[i - 1] + fs[i - 1];\n\t\t}\n\t\tmemo = new long[n+1][n+1];\n\t\tfor(long[] arr : memo)\n\t\t\tArrays.fill(arr, -1);\n\t\tSystem.out.println(go(0, 0));\n\t}\n\n\tstatic long go(int color, int priorities) {\n\t\tif (color == n)\n\t\t\treturn priorities == 0 ? 1 : 0;\n//\t\tSystem.out.println(color + \" \"+  priorities);\n\t\tif(memo[color][priorities] != -1)\n\t\t\treturn memo[color][priorities];\n\t\tint nonpriorities = cfs[color] - priorities + 1;\n\t\tlong ans = 0;\n\t\tfor (int cntPrio = 0; cntPrio <= priorities && cntPrio <= fs[color]; cntPrio++) {\n\t\t\tfor (int cntNonPrio = 0; cntNonPrio <= nonpriorities && cntNonPrio + cntPrio <= fs[color]; cntNonPrio++) {\n\t\t\t\tif(cntPrio + cntNonPrio == 0 && fs[color] != 0) continue;\n\t\t\t\tint cntExtra = fs[color] - cntPrio - cntNonPrio;\n\t\t\t\tlong tmp = choose(priorities, cntPrio);\n\t\t\t\ttmp *= choose(nonpriorities, cntNonPrio);\n\t\t\t\ttmp %= MOD;\n\t\t\t\ttmp *= multichoose(cntPrio + cntNonPrio, cntExtra);\n\t\t\t\ttmp %= MOD;\n\t\t\t\ttmp *= go(color + 1, priorities - cntPrio + cntExtra);\n\t\t\t\ttmp %= MOD;\n\t\t\t\ttmp *= fact[fs[color]];\n\t\t\t\ttmp %= MOD;\n\t\t\t\t\n\t\t\t\tans += tmp;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn memo[color][priorities] = ans;\n\t}\n\n\tstatic long[][] chooseTable(int n) {\n\t\tlong[][] table = new long[n][];\n\t\tfor (int x = 0; x < n; x++) {\n\t\t\ttable[x] = new long[x + 1];\n\t\t\ttable[x][0] = table[x][x] = 1;\n\t\t\tfor (int y = 1; y < x; y++) {\n\t\t\t\ttable[x][y] = table[x - 1][y - 1] + table[x - 1][y];\n\t\t\t\ttable[x][y] %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn table;\n\t}\n\n\tstatic long choose(int n, int k) {\n\t\tif (k == 0)\n\t\t\treturn 1;\n\t\tif (k >= choose[n].length) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn choose[n][k];\n\t}\n\n\tstatic long multichoose(int n, int k) {\n\t\treturn choose(n + k - 1, k);\n\t}\n\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(InputStream i) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(i));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n", "complexity": "cubic", "problem": "0840_C", "from": "CODEFORCES", "tags": "combinatorics,dp"}
{"src": "//make sure to make new file!\nimport java.io.*;\nimport java.util.*;\n\npublic class EG14{\n\n   public static long MOD;\n   public static int MAX = 405;\n   \n   public static long[] fac;\n   public static long[] ifac;\n   \n   public static void main(String[] args)throws IOException{\n      BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n      PrintWriter out = new PrintWriter(System.out);\n      \n      StringTokenizer st = new StringTokenizer(f.readLine());\n      \n      int n = Integer.parseInt(st.nextToken());\n      MOD = Long.parseLong(st.nextToken());\n      \n      long[] pow2 = new long[MAX];\n      pow2[0] = 1L;\n      for(int k = 1; k < MAX; k++){\n         pow2[k] = (2L*pow2[k-1] + MOD)%MOD;\n      }\n      \n      fac = new long[MAX];\n      ifac = new long[MAX];\n      fac[0] = 1L;\n      ifac[0] = 1L;\n      for(int k = 1; k < MAX; k++){\n         fac[k] = ((long)k*fac[k-1] + MOD)%MOD;\n         ifac[k] = modInverse(fac[k],MOD);\n      }\n      \n      long[][] dp = new long[n][n+1];                 //what n you're on, what how many computers you've turned on manually\n      \n      //initial\n      for(int k = 0; k < n; k++){\n         dp[k][k+1] = pow2[k];\n      }\n      \n      for(int k = 2; k < n; k++){\n         for(int j = 1; j <= n; j++){\n            if(dp[k-2][j-1] == 0) continue;\n            long start = dp[k-2][j-1];                //number for part up to previous block\n            \n            for(int add = 1; ; add++){\n               if(k+add-1 >= n || j+add-1 > n) break;\n               \n               long adder = (start * pow2[add-1] + MOD)%MOD;\n               adder = (adder * choose(j+add-1,j-1) + MOD)%MOD;\n               dp[k+add-1][j+add-1] = (dp[k+add-1][j+add-1] + adder + MOD)%MOD;\n            }\n         }\n      }\n      \n      long answer = 0L;\n      for(int k = 1; k <= n; k++){\n         answer = (answer + dp[n-1][k] + MOD)%MOD;\n      }\n      out.println(answer);\n      \n      \n      \n      \n      \n      \n      \n      \n      out.close();\n   }\n   \n   //a choose b\n   public static long choose(int a, int b){\n      long prod = (fac[a]*ifac[b] + MOD)%MOD;\n      return (prod*ifac[a-b] + MOD)%MOD;\n   }\n   \n      //from geeksforgeeks\n   public static long modInverse(long a, long m) \n   { \n       long m0 = m; \n       long y = 0L;\n       long x = 1L; \n     \n       if (m == 1L) \n         return 0L; \n     \n       while (a > 1L) \n       { \n           // q is quotient \n           long q = a / m; \n           long t = m; \n     \n           // m is remainder now, process same as \n           // Euclid's algo \n           m = a % m;\n           a = t; \n           t = y; \n     \n           // Update y and x \n           y = x - q * y; \n           x = t; \n       } \n     \n       // Make x positive \n       if (x < 0L) \n          x += m0; \n     \n       return x; \n   } \n      \n}", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class D{\n\n\tpublic static int grid[][][] = new int[505][505][11];\n\tpublic static int[][] rows = new int[505][505];\n\tpublic static int[][] cols = new int[505][505];\n\tpublic static int N,M,K;\n\n\tpublic static int dp(int i, int j, int k){\n\t\t\n\t\tif(D.grid[i][j][k] != 0 || k == 0){\n\t\t\treturn D.grid[i][j][k];\n\t\t}\n\t\tint res = 1<<30;\n\t\tif(i != 0) res = Math.min(res, D.cols[i-1][j] + dp(i-1, j, k-1));\n\t\tif(i != D.N-1) res = Math.min(res, D.cols[i][j] + dp(i+1, j, k-1));\n\t\tif(j != 0) res = Math.min(res, D.rows[i][j-1] + dp(i, j-1, k-1));\n\t\tif(j != D.M-1) res = Math.min(res, D.rows[i][j] + dp(i, j+1, k-1));\n\t\tD.grid[i][j][k] = res;\n\t\t//System.out.println(i + \" \" + j + \" \" + k + \": \" + res);\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tD.N = scan.nextInt();\n\t\tD.M = scan.nextInt();\n\t\tD.K = scan.nextInt();\n\n\t\tfor(int i = 0; i < D.N; i++){\n\t\t\tfor(int j = 0; j < D.M-1; j++){\n\t\t\t\tD.rows[i][j] = scan.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < D.N-1; i++){\n\t\t\tfor(int j = 0; j < D.M; j++){\n\t\t\t\tD.cols[i][j] = scan.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < D.N; i++){\n\t\t\tfor(int j = 0; j < D.M; j++){\n\t\t\t\tif(D.K%2 == 1){\n\t\t\t\t\tSystem.out.print(\"-1 \");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(2*D.dp(i, j, D.K/2) + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t\t//System.out.println(grid[0][0][1]);\n\t}\n}", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) throws IOException {\n    InputStreamReader in = new InputStreamReader(System.in);\n    BufferedReader br = new BufferedReader(in);\n\n    int t = Integer.parseInt(br.readLine());\n\n    // get primes up to 10000\n    /*\n    boolean[] prime = new boolean[10001];\n    for (int i = 0; i <= 10000; i++) {\n      prime[i] = true;\n    }\n\n    for (int p = 2; p * p <= 10000; p++) {\n      if (prime[p]) {\n        for (int i = p * p; i <= 10000; i += p) {\n          prime[i] = false;\n        }\n      }\n    }\n    ArrayList<Integer> primes = new ArrayList<>();\n\n    for (int i = 2; i < 10001; i++) {\n      if (prime[i]) {\n        primes.add(i);\n      }\n    }\n    */\n    int A = 10000000;\n    int[] convert = new int[A+1];\n    for (int a = 1; a <= A; a++) {\n      convert[a] = a;\n    }\n    for (int a = 2; a <= A/a; a++) {\n      int sq = a*a;\n      for (int b = sq; b <= A; b += sq) {\n        while (convert[b] % sq == 0) {\n          convert[b] /= sq;\n        }\n      }\n    }\n\n    int[] prevIndex = new int[A+1];\n    for (int i = 0; i <= A; i++) {\n      prevIndex[i] = -1;\n    }\n\n    for (int c = 0; c < t; c++) {\n      StringTokenizer st = new StringTokenizer(br.readLine());\n\n      int n = Integer.parseInt(st.nextToken());\n      int k = Integer.parseInt(st.nextToken());\n\n      int[] a = new int[n];\n      int maxA = 0;\n\n      st = new StringTokenizer(br.readLine());\n\n      for (int i = 0; i < n; i++) {\n        /*\n        int raw = Integer.parseInt(st.nextToken());\n        \n        for (int p : primes) {\n          if (p*p > raw) {\n            break;\n          }\n          while (raw % (p*p) == 0) {\n            raw /= p*p;\n          }\n        }\n        a[i] = raw;\n        */\n\n        a[i] = convert[Integer.parseInt(st.nextToken())];\n        maxA = Math.max(maxA, a[i]);\n      }\n\n      // hard version has extra here\n      // better version O(nk)\n\n      int[] partitions = new int[k+1];\n      int[] partIndex = new int[k+1];\n\n      for (int i = 0; i < n; i++) {\n        int cur = a[i];\n        for (int j = k; j >= 0; j--) {\n          if (prevIndex[cur] >= partIndex[j]) {\n            partitions[j]++;\n            partIndex[j] = i;\n          }\n          if (j > 0 && (partitions[j-1] < partitions[j] || partitions[j-1] == partitions[j] && partIndex[j-1] > partIndex[j])) {\n            partitions[j] = partitions[j-1];\n            partIndex[j] = partIndex[j-1];\n          }\n        }\n        prevIndex[cur] = i;\n      }\n\n      System.out.println(partitions[k]+1);\n\n      for (int i = 0; i < n; i++) {\n        int cur = a[i];\n        prevIndex[cur] = -1;\n      }\n\n\n      /* this should work (O(n*k^2))\n      int[][] minLeftIndex = new int[n][k+1];\n    \n      for (int j = 0; j <= k; j++) {\n        HashMap<Integer, Integer> interval = new HashMap<>();\n        int leftIndex = 0; // the right index is i in this case\n        int removed = 0;\n\n        for (int i = 0; i < n; i++) {\n          if (!interval.containsKey(a[i])) {\n            interval.put(a[i], 0);\n          }\n          interval.put(a[i], interval.get(a[i])+1);\n          if (interval.get(a[i]) > 1) {\n            removed++;\n          }\n          while (removed > j) {\n            interval.put(a[leftIndex], interval.get(a[leftIndex])-1);\n            if (interval.get(a[leftIndex]) > 0) {\n              removed--;\n            }\n            leftIndex++;\n          }\n          minLeftIndex[i][j] = leftIndex;\n          //System.out.println(i + \" \" + j + \" \" + leftIndex);\n        }\n      }\n\n      int[][] dp = new int[n][k+1];\n\n      // dp at all i = 0 = 0\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= k; j++) {\n          int min = Integer.MAX_VALUE;\n          for (int l = 0; l <= j; l++) {\n            if (minLeftIndex[i][l] > 0) {\n              min = Math.min(min, dp[minLeftIndex[i][l]-1][j-l] + 1); // \n            } else {\n              min = 0;\n            }\n            \n          }\n          if (min != Integer.MAX_VALUE) {\n            dp[i][j] = min;\n          }\n        }\n      }\n      \n      System.out.println(dp[n-1][k]+1);\n\n      \n\n      */\n\n      // easy solution\n      /*\n      HashSet<Integer> hs = new HashSet<>();\n\n      int segments = 1;\n\n      for (int i = 0; i < n; i++) {\n        if (hs.contains(a[i])) {\n          segments++;\n          hs.clear();\n        }\n        hs.add(a[i]);\n      }\n      System.out.println(segments);\n      */\n    } \n  }\n}", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n    public static Scanner scan = new Scanner(System.in);\n    public static boolean bg = true;\n\n    public static void main(String[] args) throws Exception {\n        String k1 = scan.next();\n        HashSet<String> met = new HashSet();\n        String ans = \"\";\n        for (int i=1;i<=k1.length()-1;i++){\n            for (int j=0;j+i<=k1.length();j++){\n                String cur = k1.substring(j, j+i);\n                if (!met.contains(cur)){\n                    met.add(cur);\n                }\n                else {\n                    if (cur.length()>ans.length())ans=cur;\n                }\n            }\n        }\n        System.out.println(ans.length());\n        \n    }\n}\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import java.util.*;\npublic class Etruco2 {\n\t\n\tstatic String[] vals = {\n\t\t\t\"%S3L{PYzV1%SGI'>$/4Gam=^#ODu|`Q!Bys%Mw|?fA*0ti{r69RB1N`{B>YC;.:XEmm3t-i^N\",\n\t\t\t\"#Y73mVxQ&J`inFO4.v<j?yg{4~O=p=t$'#UHQizDnbsn,+JyuS~@WKw0p*Gy%V:#sa5,L|9RX{\",\n\t\t\t\"f0J*n]5ZaRg:d-;{f!Y47]i_'u'cTz*=K$b#=}w[U]3*f+$|4ePs'K?]p8~0loSL$h_+T^{+ik\",\n\t\t\t\"@r),FzP0XP>vU2<s9GIJ;0K0e)b_Hwyaw2}n0-%|lUlV(kWB<nx7@M[30yXxR(n:5@CEc[~,B^o\",\n\t\t\t\"0<2C[Fz1*3iganAet-6RW8/X&nnSUf`Tu5-$~<5}F~$e_n5j9jD^Kk)_Xh=)WG@{4:XC;V4a|X]*\",\n\t\t\t\"(_gw]4[ktYOZ},E?GXG5h{UF<Fx1O$0YNdA0+5)7#j%f)=Ui|3p^tt:SV(N^mbR9.+!s4fy<.?WQ.\",\n\t\t\t\"%-i=_PJtuHA63yU,f)Gh@#Z*;FIWjaXwKS*bq=EOMA9yc>OD+}xg{z`X.~atEmXp9Z~*u]I3_7IxDZ\",\n\t\t\t\"#N,-ehU0na1kWpn=P9ZK{TRs/&@KgxaK4h+V/ea!9Y3QYy9ZL}n&pn>G+'I+]ekWM$(g'8ym$Mj+,?V\",\n\t\t\t\"coyL[=Xb>wzL0z?{kW5GQjeWPCy6YU<B/?paWq?^7__LMh<{ZJ+8!o7I.=<2b)j-)f!Cwk7!Ojrs[Zs\",\n\t\t\t\"A+If^46|x9Wfiv3OlqZAUE[u(p2nLL/x$!LmSrR4Do9+4oYG:0P-!#>g9'|axl=i;q`E:ja?MDOB<Gyk\",\n\t\t\t\"1$8eKLgE'nM]8^vi,NCMzBN{a<@{.}Yibo/OLo*`;G%v}'Lh~oGudWag6ECf{cpc<%]2ciRk*]k|/>y?V\",\n\t\t\t\")>A7nmMgLYs=3#7`G%X{Kr~U%||frj>qN)}H^GawXTT}/=bFAGD+u1?YNT_2Ht~w[m8?LLh=YBS!6(nYD:\",\n\t\t\t\"%W;~8W^>]K2kwP_JIVOGo.l5<Z0zR51sXzT'sS)-@WFA6I1Q*{$SR0UT1x}[!]|^JT.N>;yA`kfH`f>E.`6\",\n\t\t\t\"#iCwqRtf[6J>97)oD,nb>z+}nIJ=?2h40Mhp=)E'Bm|<?v1e<H68>yG'sA0#eN>Ft4N<Qt}eXeLHI|A7BmOV\",\n\t\t\t\"sYg3/'{oSnr!c#bd??s'UM==k<CN-|!,}c8Vb[&?tR}]?N38+U-w=$yYb_3?k*RDR1=.q]xSz2Lz(&53-xGF\",\n\t\t\t\"J<2wR!6o@K;#ftMP&,Gl;<VmX#2TNi]l_ZP]1Y$,bqcrIl_2KlqcXh46&fB&5{h/+[~5lLK8C*Ypm$UxRW4-N\",\n\t\t\t\"6:X}!AJ[uGdSD@Bbe7#$g]u{ByvOp[nkDIG*Ln1@d:`OnhYjr#c]4qa4>hatq4l_EoFb}6FtSOQfu3j$>o$98J\",\n\t\t\t\",:=#^-<(+n*e[l7/{uM<_x)#7GNxXsA*v@5~9+*;=l%XX[65ms-a3rQE({l3Y#L'>1[lHW*9/;8w^x96dK8d|H*\",\n\t\t\t\"'7C8`Ku%e]3X@+oX0(O/)~Up%;eaEA_q0kVkr>BtTCV{$~:ff]['Oy4lW[F&#5Epcri#A$q7qk3x(I[)Iu`+qjc2\",\n\t\t\t\"$a|sCP(`q)r!w>3jHD7~;@Y%U_BTgu%!<]/Qs}siNKUHJ`^mEFMI!6<o.la&tEkP%V^q#RZb2S4,izBiS_l.Yh2y{\",\n\t\t\t\"#ESSy)K!I_r#D'5qJ)s]SnZ8c:~PE4*;#A$[AeE9A8,{2._6YY;=~iOJ=33d8Hw)5vXp%g=WqVl+yy,VmtM,2ao4=N\",\n\t\t\t\"e<)oJ1mnPoS!A$'Y}`AZVCZUQ0Ky)'^jQZB{eVCW~xb4f_*_Lo$>.Cj_X+%~h2UsWSQbRj4XoL'#yW?IGXbd[!3U|6\",\n\t\t\t\"D`L&4'8NHO(dVv{+<uYwH5t#c?4YOB.5@z%:p>`HG#]pe,!!F.~|CZ$Qh]<J%_ON:6GMr|5b<w~)?1]6H%QT:hfMYAN\",\n\t\t\t\"48eMirgOAMc0``u#]nz{aP5u:cM>>5B%J|+w}8}(y_Uv_VFq]rCYB1wpD[{U}={#=S+SJQmQ@~1zY~idvR]4rKz#L3L{\",\n\t\t\t\"+`-#D+O:7z=[7GBB)R=eQ:5OZa'bc_[D+NFe=P3cdM3QKJVv*?x;RlNZixw?{qd#@8D>CoZzsJEqnGL!Xd3RoZ,qBv!4k\",\n\t\t\t\"'/q7_eOF].wH,o}YDkMDO^#+TvDqr*Q4.~%*h6DH=0TCpE*m3T++kJK(JQlIwA~+r/c{N0,QD;1DDX(<OZivC3Y>J5Uyfo\",\n\t\t\t\"$i+*e>tWyzs,GKQ>IP/+re2YX[.uY[jzUE$$o3KmUIDxlxy}ZdhF(wBOTip8DjA,cwHU&:qHwKta#[,SJ#oYa$BjEd<Fe]*\",\n\t\t\t\"#O*r,8u<Bz3Vs&Jdq1d2AIxB3}skyib'GPee/r0tw^7AaxMJUncL$:O-C?#`!j:sw!s3rlz:mtk$|rN{Ma`!jezRkTgI>n9.\",\n\t\t\t\"mH`mtJAcH6.~?en.+&TlY/[Wye#N<]Ei$ErRJJpnprYU1]lK{)rXjST-bu[KYUZw'1f<lYS({<1+Sz,T3~sB/);u$eO=PMmZ\",\n\t\t\t\"J^-Oc/l}!vGny~6jX-@G>;ot_||1)VA<AH4Sx'fRx?%:^tq-#+,99k0LY~S4u^>Wn>(ai?;7'C|f=5-*X%G<R6i7r}gr#nq/V\",\n\t\t\t\"8@>trXHR!F2,jQ<C4lqC5wlS)}t8@+,Ha]YnP1ACVvyJrDz[t6T9?n69yZk#&+p6;&kLk#Bwb:cA-|TKzXq0Tk{J3gTt*!(rRs\",\n\t\t\t\".AGXO=~svf*-P1ad/!n]Jc^EPtwzaC!6kKUUz*0TTW%qkFX`bO=/pH.QU!A|C,r-03O/_/@l*bKJZqO3HW7M*i;?h8;Fg`cS0Lk\",\n\t\t\t\"(r9y<CJ.RO,zE$/)g%8/Lrp?VQ4+-wr4D?5IpIWtzbNqQG3UL!/L,#N:h7RJYVAXK,6LT2ZSx,J5mEDS5Es&}Y3aSMh`hLeO0/[V\",\n\t\t\t\"%p%8Rcx~SIuxqTE=n?~W?J-$36syElGT#mdT~oi7bRh,X5Y;'iSv]VQ#R^os:M~B:daTv/#{|,.3mo/.xKESf^3FtfI#95yn9{;}:\",\n\t\t\t\"$0XUj],Dq.GU.t].u7/,H2CQ_`#=tV?sV'q%#/Nx9E)Qgalh]t(Dx}f0FNT(VW;V2pK7!P?Ov]j1kz])U-l%SjP<Q}C?}eW6t:c?t6\",\n\t\t\t\"#6CSvs;f%`_m<op_8dmjpm3wze?_~SUiAOHD@CEXM,vU}i+|V7zk{uw_uyynMDL>0b[9)}Wk-bC.J<SyR+?(zHXd9c{Bx]bA/uDrK|V\",\n\t\t\t\"byn4b~4K[/q[ZNRj){-dXsS~xlky#0,DdUaO<t5JD;33h1B+<17-{#m)LY:8$(y3!HwqUuygn-[x(k%Hmis9T|E;b{P5iXxw}u&MD[F\",\n\t\t\t\"FX|Q06PFPwj.#(LJ=`zx[*J2H?3~7vR:nL9)%!n|)x#KbXFkh{G'zb|#}0F.fZO}aV)7OGtt!^9}KBe[$N)d2@ZnYZnNx@s%W[DQr79N\",\n\t\t\t\"7(&-S]Jg#y1n-{jgr%y57TT`Fsppqgs|2Pk7Enqw^[4N%~:{vlU1[z%,!_-RPASA8~$rq$jMG6,V[(+wGiX(A|2AT)M8Tx%X>}3,+kQyJ\",\n\t\t\t\".3rtg&n9N_e.5[77e*ftW;C1O;U%Qf,}8>.0q~hd!{IHpG~(.O9NdCq`VeKx@H$9(&zgo[{KSq5J-@/$Tq<7eV;6(WMbEkOq[!`nPBB/(*\",\n\t\t\t\")+(4Xy##P^T-5H~m|Xp'{=+G_`7;s9u.SvcNw_xaI'&R)m;`$(8PX8xZ>*@2>xfJR<g]PeA8fk.,H+WoxSrJ$dMqs2nc)4x(T3jeQ<[^~c2\",\n\t\t\t\"&0<|E2l(VeGZt+;mpfAe/w(fyb#U,)i>{Q`s11FEBLydh,'Jz<a,_Lhd7pFC2(Xz(.b5-Yz}::NV/`Mm$;iZR4=}!ph:3+awm>mf&'%6KkX{\",\n\t\t\t\"$K$o}U#q@7(@BTdC.?bOK'KbtD4!bv49z}W=SX/2|G}.g1zn9-1wwY!CV<h2i!ve2ifU;Y}30mtC)Ks~JrllIN_L0q$lEiv3<^HS<d/U*RBvN\",\n\t\t\t\"#K3b}I$Zz}:>?3e>H4B|fEdd7Qf+_&*J<!HxkBjF=1W-YO*sxeKKt'<Sq}|C>:?O(AFgaID%'M![`@F&S0Wh]o_{/Rm4{Iz9w=6+'FZ8+By0x6\",\n\t\t\t\"r:W%R2Z}E)rayr$Gb]UCZFBVy-V7|mEr/3cur6A*;A~Lw2WYGd;@10.H>*.i;J=]6.(=~%JoHc1TBa2!6#[q&TdsqepNhlz#`{iO_</yT,QJ%N\",\n\t\t\t\"QIe,.{^Zi@pR~m4z`j#7)UUIKL&j|2656o<u+o)Iun/cgnSDn(Er*CU'Ix'oMqVLf#Q3px=i^Xe5IX>p.(RylcT?u2b<@dxI7CalOz%bt;ZO$@{\",\n\t\t\t\">S=~&b_O'HOj#A_%6}b!f&:J%)M>5+u1SDSR32En077OL`F#VRFoVroWa59I002YC@?]1LY(jhoD4S*R;}<*,Sw2mT*7'f6B?'^c*e)#c-)arm]k\",\n\t\t\t\"39yr+-}9xZ[IL`G-,~bcWQ$e<$~*!dZE#tMe[OZ-dpH$GXdT,qJ:NvaAi5+<VP3PGos<bgu7s>;%-k4a,=w0,6.WL08y1x)1F;]ITwV5UtL^m&_no\",\n\t\t\t\",O[]LZ531#KNR1W/Dp*p#xX:mf$]Dx{jXE=GW#C7$!mlZO80(W-nJBnpDzuq`'bh'ci>$23`M=wagB024KJB/zC$6GeoiF'_oeyMEh+eI0&8TjgT]*\",\n\t\t\t\"(H?He]J)!SWDW1'$5mj#LMOQ`>A(<!JWh/sqBVqh5`3Sn=~Q2Xd60ga6X8rmbsFN6$8;*KT$wtn?BI/GgH`Y;G-C<b(y{`/'g5W_R8%N7g$U2'{}>~.\",\n\t\t\t\"%yke'YZk3,v$aBhJ2v;^uu$ttS1Mop#,iA^_9]WHWvy7^Y,3_7^Qm{y~axM&s!e(Go'VS.4Bk9v[B:cFQ)O75HC5qY|:pH5lgyoRD.MTg3AcVQ~@A}8Z\",\n\t\t\t\"$J-~[Tc.xDAf+=IC91X/q9f881;?NR;9mE/RDn*%Ik,y9??^&bxA)xr/F,Va_'6eNq4i`kUsKl!|B=I#$}Mhk86(3HU&0dt{GTVR[&Ud|y:'jK&p']h|V\",\n\t\t\t\"#Q3OW&>Jm<pdtfR;qu!:ux&*t+u[Y%1Pt>!PSbJku'7'li(^>eL_l.Ykf$SSv:q-j95w@3v[iec>;CDP=eL]#~R9<pnl+=46=$c,aB|NCp,3z]V8Z2MtJs\",\n\t\t\t\"ytm.~`FCg@m(=F@@U{J0VYStErIP?I-H-a6s$.$#K{3B:tEBJzy|FEaCF&`2HrZ(Y&37=(^}eE+_AQn:/*$%:+ML,g',1k~^dfBSUBskMeZ~x2(Q6>Pq}k\",\n\t\t\t\"XQseb,o}gb]X/'2P%Q$%@Km16RjWt#91?0][T%}q==jMrJGCPP6y?{!OJ:AQ_2dfnHE*Ys+8aS(+D`s&'@A*)E<hlY>v{N@GM!U$jyRr%Q';X^;@gJ#2&xV\",\n\t\t\t\"DELtxBvP@0IqcRU%L-`xQ4no:.|f,NTu1xr`wDGEIVm-q@,G8|1Wst3v)9Dxdc77a1mM6&PgJKY9B~rMVkIoWIG'N>Mrl9YNg)o3)P}mUt^)8-cb$xI_;oX:\",\n\t\t\t\"7lAu)]H&x-r)=mE]6P2B&Ifm(9F9!zNjJd&TN,b}mE;BPwb/*Im&&^pdI%@,U&8ZA24^Us]WYEc[dS[<87^^~/+Nm;?jMe|TU[mP#N,_D}h%-CQxL86/HF-+6\",\n\t\t\t\"/t_'OVLqoVtJlGd%mSg;o^7S(~wf9+>I'INo<[BqyTn]v<PaeLj~eQ~}~X32b7ZTcAMzHu)6jtT2H?@M95(C1:?aNhYMKC(kvP=Z^~+6P@|viR#utIW/iI!3KV\",\n\t\t\t\"*u-akgNqo>b6tkqN5DJSt9NoLl<?DE>+T4N-|<(&kFCv$Q%-fo9dC*4U!gnv<w,Xc4bXAhBV|Jm,Z]J0pMlXBy=*nbA_Pjbr#O;$%dfzGRd}KeJQo/RZNogHMpF\",\n\t\t\t\"'eP7fDQH-H#!j|h>)IoEF6-WZC]lIVJ/@|?/s9&sqd)p^~ugx~zDDH`&P7ch~iZ-jKp5aGQo-v1@I0ugW3LsiA%U:CP`UP@jc>*E30?~zglP0lXb@p(<c$ePRwEN\",\n\t\t\t\"%cQ]O`I?Z^[TbsO6:jNKN`y7o[~KhRv~iu=cY;NVxR*ZQxNrIpfSqw7K{#{{4dOtIsKF-':@tqyVW[{x9t4U}[e1-0XXTABM^.J,{Tc{(wr3Uj@+O7`rznkDp>s]J\",\n\t\t\t\"$G?d*@BxvQ>{2NdbzHeR[LIa-7Q`Puj(Ht)5f+GP7]1AoL[>IIW(>*_Z2`H2Pq:pj2JQ^t|tr|;d5:JS/cG37|x(tV~iHgDQN-3-tyAc{hf#kdsD=lbd`v{64$E2e*\",\n\t\t\t\"#VUQemGH]0leFuV^:<V`hp?J7x?aenY:C^^R:27~{+4jYd+A4{txe>S*/pWVcA~Kjo<HDh=.Mqo`PR,/t1yx&5px3636chFvn1$PAdbtca1B=7:64O5`)Y9`q)hc1c2\",\n\t\t\t\"#$t@73::fTYCj%S]lKo/sIlI=zunsA#8Y5]YEEo6-Bq_u>F-NdUoPs-L'uH@/u++l[,a&e`PX|1u<TjyASURuXJFL'wxzLw<BTzE>*_JmA@$LcB,j:g<d3y`0R*r'!8{\",\n\t\t\t\"aWSp_j@Tzm%?v;)3UoRbqZr;p?D:^wBRjKN@S;`AB|b,1B;(HORok;Tc1W!0qAF%Uq3f@,!+zaG*?GaT*'k@QN3K|S.N$s?<Uw-J+ukf~H#FgGFU`RNx`ZWq(,9=kQQN\",\n\t\t\t\"KMrVDEkM16AuyoI;P*ZJBrv;!,rR/iDn7LxrWtsMh|I.#'x1]/]02wG2I^X3$WOMk0A?DkDk7Ta$FXEt]!hm&UK-RLlB$xpxW][P7=wuoM(e^M]ZerZ<Ey}eoNjw9pdt6\",\n\t\t\t\"=[3C~w/f.74V:6:vze7B-.zl4Mw#~{HFD?;@hicn$B@AU'>e|01JEdcS^bZS,M}DH[=Fc9G5&r7czx%499'f&s9uf4X*%Ei1`=&gz`MEBv6TchYh=G:{7^+(K3V-`*r:fN\",\n\t\t\t\"4NI+1'KkL4u,#{IDd(8p+|$@Q>sGQ;'T[>:skE#M4G7B^kOGP&~L5W)`DhVup.E!M46H{gMN+]THBE/1&.j>)x_a[0S:Cov+^]u&Sz/44.dqrhwnJlxxpLge!w{3%Ha!%4{\",\n\t\t\t\".I9PeehvXspF[F$??y]9*V0Da/~9kfR-%sg_NA#]Xxk~gJ(2JFVOd(F:H)G,LTuD]nY7weQX%'`M]sn{Q1abJ,J_KV{w?/.!I6SBb3I==k(pzLJ(0o$Ih35I)JJh(jdwLS(k\",\n\t\t\t\"*F=.dZ6XliY}&(4]/>7en<4)&}1)Yk2%tdSgZOi7M`g|D-eWdts32qTEnwEciT[1[mixh814UhZVbCc/eyiMlf<P:`hMxf~`wP><%l*pFpj3A,Uz{}zR]9/pWZq_'|{+lsPvo\",\n\t\t\t\"'c0|-O$kHD9._=4.EXU3rQN?)jM!C$%])y?0&TQLnGChYe1n(txC1vYA2L'z2Fx(#p2ONeuWeUR]N?uoLNKG_kk7DA:<v9Y#4[|a]h?eXDk1#TTWnDq+EI8WfPdGsF+woh+(]*\",\n\t\t\t\"%tHm:f~UE8a({i;ikm_%*IZyoVGIlQl6)E'S|E7,mO|Sy|g~&sXWSc3^atX-c_@2,g?h9w%Xax21gl4m}3k?ZXn;JVDh'H6A~D[Oc}S0wcI9X[xxR!IVyA/+CX;rwO/Q<F2m(f.\",\n\t\t\t\"$_r)|9(3McJ-d$423`!PiVacGmd-|wL|2TRIOvq&4>j$6PM!{pWp530Vk/pj9K#-J+MUCyGf%s|*:`fL)XzifrJ6A!Lur(>mBOhH_yW0A0WW'gC|iX;s]hv9u[{hfLp]9S|PoJaZ\",\n\t\t\t\"#oR;uMX=U1vgn%6nTONc7HP;wsY5|sj'm>zI|ff>V&U@ZW(S)S^%~51fbNUoSCQCMm73(MwEA{>5&,!L[:i%HT6Yjoac;Dx%K<=2{K`)xm/0:9:p9$]FeZ,M2^0bE|B'>3JX5hplV\",\n\t\t\t\"#:R)W$kuhEe3d_wB{!Y9%-/nZF$yNyk]o71|Uk1(2`Qfm8>g6Y7Wfzz0)-G8Vh%tqC$#mvyeE]-kr/W]ugLvm-y&HUtC^&71L+JG!!Z>U,}5qllO4?9`qnvKB+JHaCS!16I}8k5bBs\",\n\t\t\t\"sy38-RZ3/aMN`V6#v#QS]a5vnCRk%SMYn)8W!]gau]4egu3aCsW2T0c`J;`o<|v<<VC8`@!SIi,x'4lTcdbh?$-=-2EBPl2hcU>{+:m{Z%mFZbNyC'ePuR(@lE2DLSXeSTeSaa^QPk\",\n\t\t\t\"ZMhWciybNhr1kRtD|1_b<8Ax6tqq84EVb)wS%t-W^~psSX.G,jCrYO7wj~DwYFZAqLeR(53?h+g`INo7Gm$lCWz,209vpKRHUK:i/FY_aOWDl.gt3|wCSl5XWO0Fvh1o#?TvCp`4_7V\",\n\t\t\t\"IWy*`0ug(-b!Hu}e4v-W+y358)Kvnq#M_E)o3P=w{,-ta^8NI7sALy>QPAq>r!<3xS#it4'Zi(.eo_~UqS)z=}FKPQ9{d.~P^K*~K`fb<FlZo_<F8Vs<iA.&q=e_I,lq&DP_1iSco94:\",\n\t\t\t\"=s@WG606c{xgI~7*0!PO~*Opu4^+m>eGcD_^'/tf_Jr%QCIH>WOKnaw`pXz&xMbI(=+b,nt+qJr*+-TjK`Z,sURM]TL>d|[H[#(G`zF,:okg}c^(&aI0N%Z.`Sg!OI(X'kgH&K4MhLR?6\",\n\t\t\t\"5dc/|C@JoStGxr~,2i;p@;M.cezli},k%lPJ^o_A)^e}+p*e{(3k^*[[ZrGU]JU^Ag?ReXF_@$=6rUGrP#qR[q0^,Gp5$9IqT&n29ic`r?==r@^whM:ipsm2%[=s`A)^+K/Z4i0Z[Kj!xV\",\n\t\t\t\"0!RU141:2FQ7b-=QkN5lDbJJQq|S.[?N*0)h6S(/MqbBopgx,%e[!,YDzlC&{HLU',BFiP:8*!Q~qb8T!Gm[]Lt}f}Mru&:w5-16h#kvG.s|N.H)'&hYW)Zr%ZSypdd;.?S[ewN7CUJ|7'F\",\n\t\t\t\"+~Oy!c<ye{%@^P`HAFbH?yd.U_QPeZ-Un=#L>wU_PlYHx4I-O4aTY.z%cbL~#g3Wfxkx2.,J(d({fC&|~>Gqdnk+G{XFMIQY1Z1XAZ,qASVDt9j/zS7L~6F/jkb_QL<}3oQEI|!1s3,+]9QN\",\n\t\t\t\")1'xJf[WHGn}?ovZ(M[s;tx[3Gk$rRWA4bx+Yw]Xr>?n9.mssuU^/bwCos?]N?v9,@xow'95f>y9=t!V,S(G<3Gnq7BYHJ);&[R33!;lE+cPcR%jurr*LJi]m4av[qqKQjA|}#g,|MyfNA?@J\",\n\t\t\t\"'0MeY|zpcPO]+C}p[ScFIWpJ}'laL>}CR9LuWPtFfm;<bxFzP-K`h&HVtJ5M1wJgox/ehMdTdhv^gye}4A4_}vr6W7V?N&/C}duZI'Xz`HnaK=b.SfNWd'k/nYwtX-4`p(*BNE4`_K@)bbz*D*\",\n\t\t\t\"%f)ZWb4.HR#3AQ!}3/aNEJweg0ZI~D$6B}q1S6pL7RMc[?wc}Ks:=%PCcQVVlwXTW4/,6@DP?uX-y`DM0]F|)#Npx$HY2@@A@b~_ExX,8HiX=@,Ykg9aU`K~R>hg,+[}h>O(6r!!l2<HdY:Y=c2\",\n\t\t\t\"$d0Q?B+wWpn8pVU}Un4f[-JzQN?zhJtzI^V[%X#7>EIJ4C6#nb:.:Go2=j+UH[$r=~|Mq#x8c%Sz;Fg&E$`FwHdbnSUp1:IjEIGv[v1Mw+lg<aIzH@atHjwT=qI39mm*+!djVLZR?9{i9t7D@nu{\",\n\t\t\t\"#|f?>D1?`|Df:<~jRYwxGXRF|~}O=^(.6)(Ge'@U,83J^xFhoN&6(.O3710XFRLB_o7`g7!7?#UYi>Tl292a9-R:U&jIJ[cI%.F7'D;Q)|XV/]J~X&!vZ$}%T[_pPCBXu;'*BmD&t0:DB_Fd@!a-N\",\n\t\t\t\"#K-M@%$Z`Cb@'K>+z~C&~+]I;Y<~,DV)#k#pvMluvyl1Uq#E|(zgPb$_NaB8*.z^,uf~6goZrJdB9ZT5SvTG~SL#MJ^BV:Ua;(mf=!5/N4]-T:|O5-eqUKP5@([-QHtM/_M(_,+}jzwE,d8<xvc6p6\",\n\t\t\t\"#'y8SS*f5SdrItW5ZAgEzM|htCuqTLG`5S?LGyJfQ0Ez6^dkIm?<AN.13h%{}::'N731(S=2q/TOC2C?1U#g!IFIvE|F'<Q'FnvH2FTcmoBZZLlWWQG~y>/>S{:@;Rbp>b9ejm8?1-{DoJL8@Yt-+IN\",\n\t\t\t\"kC$'rcIg|P!GdR(kY2w_W*A*K9F[M]vO3&t=}I%mf08|r|@{<5]fy2xRwQJVe+*b}L0:AWdvVtR?Vi}AifSK%7b<,|n_sQXFAu_A6b:/.''?D@V#BkMM,@N&;ODqLq1XP?I}'J{T[r`D3'pezl7^6({\",\n\t\t\t\"Wb?|O-W}`m2#~)URv`a&j4~npK{Beqg]+!g*`pL!XCV_IDa&IxAoB&LQt;]#>wwen?HS)%rSJbR'GJ!&Hvp;G-b8,n'izx__|1a+pU@+k`~/rzMI'SoURS[:`_ezt!mm)$]]34F4!!KkfdMIC]/F=1Pk\",\n\t\t\t\"J!CDyVG#XcOnkE;-c<RE'[%&,M!m${C='`!Y$R1Q[hA%D/34uyM<X#QRV3W=<]p_+y9N`(<EH:*hQnj58gQ|R31b`^,w]?a_Gq=q'_wmDx2EuNX1UhQX`}OG+JP~+$pmqM+G1MN{rq}6T=_1Qe3q$AN~o\",\n\t\t\t\"?xq)>v8vOf@l`9oGm*)uWG05rKQyNqQji/a`1acf4AL?hJ*q?]v97!~5?^.XsI0m:oD770_IUuMe/{iXVLl#S#X_H+:<PB@&Qx(B,-{)>QY*9xY{Is2hS)!lcjsc.l?$l?/h78KuW}8'H!8|b`r#5wT<]*\",\n\t\t\t\"8O6O6|`gzc7![)&miUYasq@:fY,}e+MC#o~~.[gf0aU5P/Wq`(m6L-Kz|N5D(:dinev11:TF'c5FHAS!m!QKwo4$i`4%u]bj`6>^$jw*v%#2*QBKI$bk*W?|^_m*enz|wsoOi%j>?&PB(Tk.!UP@^bL:*M.\",\n\t\t\t\"2|<^@&/r.y`4N%ph?-'xXSf`-k>fnliC80KQO44BS~<xS^5s(8a$U2`c@o23mR(948HI6_Y:CrpIy4-{o)5Ux}V~rmNjvEf~ymKd`@t!{j$-*z&n[yIjQO]qD$U0'lZ2W3%sLMMrT-KLlk+&yE7_F~;|nr,Z\",\n\t\t\t\".qxph,NAEG,gz7x#,gR8y}^?vd{'1pzmJ]^nC@vss,h!e'de6B3t4vY)^42jSD}ey.N|Gb,Y-f]jEfyCOE)Q/m.Y22WOp;H~YQ|<JfZ),%MT56&jdAI#72K?+9=.Yn|x/U0YtPoOfY=tcA5fYkfkMgY_#G+[V\",\n\t\t\t\"+j|Fu,mnMb[[_I7{AP%`L!@GB->vOZFa{3PT{+&nZ;{Gd`CqZr?hW1%ZR3WqcpBQ2ayi}RE+>:&pLP5:rp]Qt+eZN[)tNwG.tAIztFPvVz]K~$@UB.o,6[iXpmKX2#)[+}0>:=H.al{0h1nA&|3w,4z#[PH;:s\",\n\t\t\t\")MQ6zmK`vZeC{H2Istj')PMbKVYeF<eM.o),T6DO<!&Rk=vGIuPYCTMY>czUhIjh?C;tiQugSI6|r's}rGh{H/(Y'a!a%9lU.n_:}Vf6ro}[;X0XOXrsl__lP1?lMroE|xEG0I:~UmEK+Q?vqsvKro7FpQdE.$k\",\n\t\t\t\"'fC;a;Ted#3(|RP[*S{K^RtLZeavB#xHv<|{RQpa|/%b|_tY?>Q;UtC4,4hO,u9gZ+@sd83Odl[=em=7-^H%*HCE<eat.]&wmMbV{)y@-9<%[Xm-8Z=Hy2|2<x57P,/;o8hZZH;m4pmO$M!1M~4?.xfK]DP#'zSV\",\n\t\t\t\"&H16w,mmofX[4yXDF.}Na@CH@^jFf,K}>M#OV>+R%0dS1M|`Q<yqyun1|8?Sr#xBau(!bR)MKQ,P>>xKRCI/Bxl2H4P#y0gD+}R:r+UeI$|[s6lHJ5>;oA~_=IX*#/U_t5tC?}%vd&R#g_fOENC_d{8:B?%AX^Sm:\",\n\t\t\t\"%H*Hw<Ia]{(CEN=TN%QfM?0^,L2@,wOG*82YV=;@_iZ?p]DnnO_l>fa*}/3^h?G.XH+d'Q<z4@6{x`Y={B=H?e-OthzW$!&UZI{2Un[sW'Iz*X^Eg`F=3YU%T9SIc8D-jiCOnjd]49t6)CI{/*i;W[@`:s(}ydvSS6\",\n\t\t\t\"$^s.%XfK,2Us*n]WU'k9Y>9Ti?20]8RxV2EX'=SXH:,X@;e|.Sb;.7R7wCrll+HHJ|O>jw:!P5[i?v'w~{:MycsG{*[}8JgOsqC%SL0t[HM}i41=Jf}')SGy@tfqofVg:6&Q|w,#b&/H'/.gM3>HqO:Aqi&$W|U1wGV\",\n\t\t\t\"$(,3<E-seNZ&V1R_W=Spc4Br?Rg4?~dFw$an{FvyZMra{{gqA9+.X|vAGE<<L##Eo!CMQ~!e?e,,h3=K?<wT)|e+z:%2.k@VLav8M|,N@)/ROo']/KQ1P:X|H%Po<NFFj-+%U729dyXh,-~=2~fTYI3|AB~u_PcH-];F\",\n\t\t\t\"#Zl-GtX['ct@ch9KkiOLP]77.6VNelm_SNNJdW.dFGXRP%<TwO#K98r$NfUG*#-L({8o%>XZF}J|D?E0DEL@v83NC.L!wex96!O|5QQ_*e7RG=j-Sj'o>2*{HV<)GOwH487evAZNk=r-T1y.=m,&Vi.(knw@I$;T,58^N\",\n\t\t\t\"#:wmn8J6`[w<COAVr/!`3[G5V}yy;>2<UfHofYl%Uhh;t&1M<H$Y7q(hJNy68M=yQESKE)T19)Z;oRk9WWNe4{]G1J<_oCXnTy`%GEly&XLiN[K`H<r^Z:9s>Bei|x({E(Aoo5T{_BYg%2Edli_86seC(U~'B+>1]FYq$J\",\n\t\t\t\"#!8/U;c]1nFCeP9%:a!g0~F%q3lXy#KH[k@uUwmEAGJt,wmWt8L{MMQ7Sr6'S!+L<z=tFrp^:'(^49)2fXPqLWd#<tHob8o^:|o9i]HcFT^;,8tDi#ES>'='m~au8*d?Dsmn>#WSWrgYm<5~x:g=(!gS%3/{L<~EgF!1s$*\",\n\t\t\t\"l'7.(t`M4Y7Tk7XzHdB&z`(SJ>m?-f(bJ3{6uUJbV4+;qxH#UAT^aB|4zph0r(2z52!]Vrcx*h3!Z_<rw@bUdg6]B?6M;XK2-I4#_H$8s0Gjo@2GGER/F7/o9]Y?]rb@50|~5UVv_o(y9GjTwNs]nvw4wFBw0,{Gz7N|Ec2\",\n\t\t\t\"]*=2VfKD12h27;a()?>O9fOx5@[2,TyP$:Xbhxtx]9}xp,-;&yi/Fo|0eMDY-50VUl)QoLe9=N0ed/1!<Q>Qoa5yto%M@Z,HIoStM+YJw;?vva-.}tFowDB#Wr/t14u4'nx%h6b1]XMVEMJEamjX;v=/<Km3>$S~N[5h)9T{\",\n\t\t\t\"PD(W!DH&6nUOB'l@y{vk3w^|[rZt.RGB+rS=m~CrP[XY#LewEHqr{I.3km60z=fFEG31N:tlvhC(A4gEa;.*grU~zK6AuPX31.+0r*;[a[19~H/h~PN8Gt1hlA=iy$7fJ.N`bKWSCL{v&BJ#f8?t`zjg<V(wRRU>cbfWcVofN\",\n\t\t\t\"G0^NuhwXa4w~)jZ[j*{E%YMCaa<&H.}X945dS|w^g;'GQc<-.a(E&5g/:ZEWy?abIifub!S|`!&]&AZs'ePT?t$6ZZCB`UI@|moZ75`Sg:_nG}k6A`&9<<^[>os<kF;0F4qe2!PA^}fqmcypQwv2)hC`D,*rEqHAm)uL_I;bl6\",\n\t\t\t\"?u2[Z<@uQ{/!E3#STHVkA'RhMEn,'e@y}aWko'B&:3Mu?UVS-@V;Ink)`@yu]:~My@|Xiz7rP@fa.GW~DlD=gKzDxOH{6fATk-UFfFe=>_8Cqi:zL{MP#[HM'6ob$BW-(@;x[H`}jv@lWTdXKMdyZ}mK=|=U+*ePW0`AR0Kuy-N\",\n\t\t\t\":.{n;Au!==aW_~~/31:%|ap'pU+C9#>Hlf;h;HKs)1CYZnJ5ly_+@AM%,@N`|Eihs-c~{A~6|1,M1cU>*Ej`k:&.VOu;t)&e~~#MjS5,jIA;nB4^V*|T_F_z[-,A5}jP/_/i~Gc;*(fL8p%0U-A},qRIs*YKv>qa!y19MO~^(Vy{\",\n\t\t\t\"5VN9jpHpDfSUTBca)i8|h}_bRyht0S'H!{CRO9.Sq[efz^ORXP8zS}x8~;];v@eD^HGNAle,7ZI`T1NU4Mg~{W(W-&M[<h|Q*[l1:/3!'g*aYkfa[REbi`==?-PzhwO:%'sXir$}=O}~Cs-vr5YyZ%qZCPzPPnFZ8h^fO~)wB|dyk\",\n\t\t\t\"1x3Vt~rj21Twzr|,,=oz8EPC)V[~)lB|>thqaR,X?GC(h`u)I7K/BWtaGwt_!_vcA%!zerw[UCYgMvE,KBX<%m8unQG2aTCbOqNk[v%}%`]IH]@0n=4^G#}`jdM3|Y2+n|TLx=~d/y0fqc&n,OZS^]3Z,]%Q#hQoYNX|b)e~?PhY)o\",\n\t\t\t\"/!t6rJh<$~fBmH<nWA'=$:;%E'e`;}v/jOSQ^b4YA*GEiGrK{~4fync%3;JCq+oDTJhIi|)u$TC>3!qC6a=d`ccOA,!aEI6XA~_W0%S4,2/KseIf>8eclVHN&a91=uADU2|N[-*E-xv+P@9xHT7&'w$DxgfW?nOJ,2NFOCcY@7s24]*\",\n\t\t\t\",`HDkC$U.~U'arpO^7jRs]noo(UES(0LwSUbf@#+JSp0sfGq{*b@i`n}Rc|9>Bu>_NU>#_DG)%QYR^a`od5Ur|x8lyt&]Wc}f{b5}c7:nQdLrV.Dqy|XUCZlrgL-g6uyCW8pg2DC[0qxk0B'!tA)s[y_?}xR`VGm$0pPcPn}g[Q>oD5.\",\n\t\t\t\"*jji4DRB!hfp?ZuKi9k'ac`.p6,[NI[W#/?|N!'[kkltdB+{[9p^&~s7_[4^)[[|S.)s+Aou|O;yO&xEZD^)'U#A2F}V?iqsuurhiF.N!)7K!t@^-LGY_n2cxwvAT>q>>3go&'seAX~WI2)qxnX8n|}*:*Xb|)&mR<;RbxYd<}*fg47TZ\",\n\t\t\t\")9CRIedE3+m?Od0R1]irO:W=/#h7)Lh=~{KW0X0f^g9XrRAdlZ$z?Fc;x7j8Sd-2|g55F$;cXNhs/mw<s,TQDSeWsm33#3(R{,Ob8`2~@{k]$1Jwe-yT'`c&x3y(O-OmpGPhh^LrZS6j`?yx4~7T]vdtnje8zi{@=jd05}`Z>IkH'5kSKV\",\n\t\t\t\"(#HoN7l>L4n=^ANA(IaRW.G[)a~Ba;X,w{e8v8clkID!fYH+5{|xDSS$uC6syF88!9+a9ih_egHrdO@.;1*{d8^F:zB-99jpxCc@:X8GEVd*'&05V`~33r%m+bT'lN`G[k|`QHd|TZtk4GW^DBSQ7e}K0muStmgPPmt`.n}-|KkY03@5^2s\",\n\t\t\t\"'!^B^p',7STXpZVf!2wPNs!z53Tk_-^^pl8bur(,DSd-'NfF0GGO+'=a2*d#8-^Ja>&jO:J+tBeaIU&^5e^11z{f~{ytN6ul%t.p-3yu$VYB-tfY(/oPp9aH1j/L26}w{'{scAx]z8@zK7[E8yMBe(HyyAg!;ccXrY-_N'@a!(&L(Dnb/cTk\",\n\t\t\t\"&2pjLw&NC{giV*juxwZWN_}/[*!%Ti?4@;z]A[]Dpj9h%~qj1_jYBnxTzo*(yHv`SJ^O]gr5jV{)(e2zqQZ%:t-CG+(Yh5K,%+!AAf:ME/x#fovahf5<|:Fw<oGcpve8n:[p[sThf_RUs&f:y}s&3wq/gD./o>3xtwx!+ir<@IB.*~}m6WypV\",\n\t\t\t\"%Pd*8Gq8{;atxi@9$8q?&?f#T]yuZ@^,6'54subP_v/fw,i.Z0|wzZ0C>Kyi`Sc@w4kUsL^CAlKy-Jza<4?pk+XHykmfao.1jaLrNOiidfXW`_8'_xjQkzN1_rC`uJ/>xaq=>wTY7'HY4~2Z=_Cjmj$4EIKc4H:#w8[*CKrh]7C=.S`R;8jcH:\",\n\t\t\t\"$zY+<nWAv5i;5blo,oAh0F/w[:=L@%K1XC1Op3Li<aDJFGJQWPb8Pd35kPWnJjUL<|hoHVruU)5ikGU6/s*|o1<E4Co{yhRn*>[C1+$fD0@A:1Xw^.m}j3NJ+3vw;Z.`WIKy!ZUBTS>k(y5qJnaw0X.)d*=oAk{B{qJw.+10!m$m&4Al=A1f0h6\",\n\t\t\t\"$OHucOmzWj'k|Jum@9Mg64h49fO.<8K2<m;z`P';F50%ZrwSiHx2t1fS[/Vx'G~#]6GA%x`QVa6/'%boOHc2U+4kXCnB38j]ff&7PfpLTCa*EDDM[*)ry;]$,o~vrZz=bw}CYJE-~|}^ubb6O{~]k9dB5?uW^F&MIYW@lgQRYK*zVy(Ur}2n4vtV\",\n\t\t\t\"$,PB8I?Ky'%q[q^yot]_Sjm8Wem9n=BQ&e2OXz#}<O)5gpTR7fucCdbZ[yh6a&xJkk~&=V;4!Ug,>sKDH|YQ((c@x=U6i@i<'U3B6.HtIftpsNF:xp<luo!!'9k94a}G=fV?[h$lWDCO,o$A_eWM=;n#/Xz?=4K<2:[4n0miA1kDTcF;`JNr~tbOF\",\n\t\t\t\"#lOxX(0q*A!6x.j;!R'WxF3pC=Vx}q(RXzrm,&EyEr1C[a|l,QZKf|+OUBof`Viu]gl8VQn<AoNKCcc.k8N#rEuv.2_}on<_%s1=Co/<c>3t];!V{']M/*&jJRzd,?ZiD[x%.`[5>`SDpjK<WI?N}Mk)wf2=03N5q4'uc]xqVz/n~:L~GG#CjO=tjN\",\n\t\t\t\"#S@AU=fe$SHn]yzn6gqIfj('27i23vxet%fC4Fy/8('5p.1'RED9mctIV'Tm]2H0BA'wCtJza8k>&&JC67wZtn$O`4HNixlu9xHK.(z:4u'8bq>f@NUXG-fktAC,m[8^t1E=@58C5%_n}I#S2-C0:]*!fx^]k$=xGXaEyh7puIJVR*34^DXH(ArqLeJ\",\n\t\t\t\"#?-RrehybIle8R52XUN-S51F3S*IX;?(cBUR25Uv(_}JP{?OI:P~2L5>LNU-Lb8lqf~mpkvv/s[m7_L?ov5Xb.(7IMSaBF]Pm~Wy)+0k90csQ{URTd:%zd}wkT3W87xMd;zJNHBFHH4!^28nJW0l^t^57H5^o%0|{x63}4rm%'<6!=@)(kWl7oNm3Qa*\",\n\t\t\t\"#.2hWTPyqLPcf!YQV^I.ok9GxDNS#ENgo(8{r198n0M(gLp8wZ<-4F4[$mmI;vfrbKM?5pK8S]}6jV!a;ZQAEKo*SI;IOQ]M#-{.;=[Wsn?Df^,RUEX#IC6Q>[~UZono|L'B}Ux^meu(F6#oSkphejQU+q57hm(z}<s@oW$+VU5QBl6Rzu{zpc$B?HIc2\",\n\t\t\t\"|xQ<OktmmS8Ky.b)v<(=>^0Wm['.76wt>X`B?9)fuW0)JoDfwQzn(MAedlPn}ec'Ce:7a>3(6)6b+)SoL4&)trtualfml=v$6Q5lVbzlhb0k_f=oqfzI:7n5Qg|y58?mJ$.$r+{^1#+cDWS.xAd]Vi@>+##Bsm8n`3OZhV9wiRT(lpHgT9iqZ5#m,(=4{\",\n\t\t\t\"pv*~5&:|m~ss@H+X|H0h~{XZ'oe}VR1'N#q3fECr1p%l5&j7c(WgI8<TPL>0Y.X*P6(V{e4e-[;x,a/9).'tNQ]c;kbZyQ%kYH;(3CaS(rS4XT~/e$[x/~#mgDoxv55I@s?CEs`*^_^ZbY/G3zD.3SW]a_c?g,j}6~]5?9kg_K#~J7>L<z}i&|}v'Ns~AN\",\n\t\t\t\"fe`c<@@ER5E?wAhfkO3jAKY+$anJ4X4iu{h![)lqYWaK98]!ZrQ3w$5Z'e3$5O~c!S5sMta/lpI4&8G4.@DpF?inWC1dDbZn`=Bz$M!;|8G):_X:q,/`<THEO5oVfJAum6}lHQQH$Qy!BUHe~vSP7<C>x@ggqh~Sk5+BxKu5ASf(rr%ls8ZqR;J:MjpD,h6\",\n\t\t\t\"^)fTj5!q<yp).wIma11RS7,=?v1-]iV8-fvs0m+eBTCC8*h@;I-YEXC{o#gHkz@CEz2u6W~r^f9'Rm8*.+2OQZzpIUjO94@m<aJY`|~ynb$Pg.R/j+3,DnahKN!3FX1:v4lJp_X'<lp0a+G{Sc=Dz$)BWqF|W2vEJ)NJpTmvi[+pa;+)aF9rM*g)PO-WminN\",\n\t\t\t\"UevaP{tsZ_IsFO.O,DrTETjhFk[Wm@#Y!IL:5t/CJ+eq+HwWl-OYn1Yp8zF$cJbFVw(rVM6A6xm]~:#rxW;mW+z:!>bGh%#/#>ZFPr`6eKpF8l%*tBz&wG@|yVt-6LFUUS4JuE,o@9&hYOGjJ:+<&o>nW);'0BvR/iWa{'%a/8vU/=}t$%p2KBHBS_KjSy+m{\",\n\t\t\t\"OJ{`D$g@95?7dOu1+UxJKIgk:kRZ!I1jiWpANY{$[9.BWkzDVt<yHs?dT~p^m%U@]30Q$-K=&?+OcjxOA(?:`_C.LUElc$Xr75ZGBVUiG/)1nQW}?5cWds>+D'3E~zHE|.a&M#$F:/4Gwh3-y}IE]r@A@)%/:^=NpD^*H2|J@TL~@G)gbvDQKDv2lI!xa|,2Dk\",\n\t\t\t\"J($ts4G+1>s:%rtmu!H*(UG%HoXPAR0)(c(_mDXZW?c|1:i*0Vq!gS2c[8heGEh?-KbP[k:A=7Y<M:IG/-5F=[Z/s/;:tVgk?,$|mjYbv1fF/t[di::Kp%3}l%eC}F!RGzy/1BOwfTA#}?5$`|StC$^Jc{b(z~~ALPw/[~]WMXi+>F=3=,MXmBvf](f}cLPHp1o\",\n\t\t\t\"EJ}~.I!*LesVOH,}'d^+y`qqHU0B2?<MERaZ_{E=yP&9ZTn/lL'dpd%qR]gmH}&(Rmv#i7QjV'1PgKnddXjj%sb$e3d5a&llD]q.Tq-p%dOn@F&6+Mw/Z1zfjcs:}vW|&]9H'4A<qs;)62i77F$5O-)AB&<SXi]:Zo>[U#CyBl|gN?D|eR~VD2ZvGsOlJ.W((m]*\",\n\t\t\t\"ALzX&|aT.Dmt`:~9xe7&fBf0vx+D:ZKNp9l9s3B%96fh.IXnH~R'an0yT?8{cVUG>0XF[*O=;nr[N(,tpq3^H(Aq*!h6.5%%cySP?;?bY4nfEyJ+,=rd8?9Hj[Xde.|Q:;_VoTV<;ep'T5kX4z(,.Mq19>c@y4VB+`|$}TF3,}ythw$VqVpMZ%N1^o*H=BMmE}vz.\",\n\t\t\t\">$rw|!m?2><`[:&M2C~i(d+iZMYy<dI7Gv=qzvvp*'G:=TOy3Up]|&o;(sc,se!5o>^kT~a!HFGqZVOGonQ7G+)lIYGe9!ys=Y!X|GJ@([iWe'e.QQKs+V`:^Ip=W1.^~Wg?y3IR6YNWV:qU`a3naI-I9#LK*}Z&Et;$?H1fgIcYSl:pwa{8uo.[0$pL3n@<qanU}Z\",\n\t\t\t\";'3^il_9O)ZDc7b@u'P(0|&4WuNdD--=?b[GdoBj'qqswyT^oYv.`UmEkrBAEM0/[5q>6+,a0._sDs^;XCo/_JkgCae>]9E^kL4=#?6u}QLcBU/{s$VYuVK'jbCF&+JEO(a9.f!./=Ph5a2votzQj8|(KMg#bSQZdU*@eYem{leJ?kN8|$&xqTYg_vrZJ'::'Sk./;V\",\n\t\t\t\"8MZ?;{+LTa;B,{[N^tb=&K&xKbuz(>oY:Y<BZTIC]q@STh_a:_>V>x}bA~vEb4S4zw5+NYd@e@*e&Y^?NDbUGqb&4VYj!kLq!z,f[kb+h+a2WC#>Y1kRt0`!i|3A'Pvo:Q]O@(QYZ}/6no[T+rV'rx[(}cZholzWm|Ykw<&i,u>!DK=rKAa!}9c-C9OLb{ag4sPTfl*s\",\n\t\t\t\"66pK~$<x#nX}}G2ov/*D3nSu{O&'w[ZFY5x*{9$;'v/}Xxe|{#?hzRC;%-Gly58=@)%v@p#d&&gyd520|(?>-P3zl%HZol(aQGhI}>_qSWGlV(@'ZvweZd<TjH)ovAS;NBc?[P<YJXB1JFxJW!YbG:Xf)nO#I4|<i_8)e,#>z_riy,T#AW=j3)GUI*5!pT9;Gj{o<E7(k\",\n\t\t\t\"4:J?]u@Lll<=)L~k(&DLSSq+oVUGVl@]Upgd%0l@&Qy0w]2&*OrS,w*~B6O_F?PW.byYh'vU,&1bQMv^*Q}P7byDt-!F@Y%RTkj$4vv1+UZNui~~>nlyjPzdgbpr&}/kK/RTx7PMBbl6)~(,JhS}gu$&./z7d[0aa*!Z,J88am1FfYk[17~6l;6Se5y+#.k!}.Qgu)X]/V\",\n\t\t\t\"2T_]&ocY++_6VV{$.GzkrjbY1+F&}bWvhUAEYmSKj}}3{nvy8J&U7QAFeFgOONyG/id2%p^Oc[WLC9XteY~by)UK@X]1{=TdWoDxAUvDE(}T3-[(jEt:o`e^OkdZb3z20;$%4t;l1Zs87l+DOV+|IFMZ$+7|DqL(<s-POEg^]nSL`G)Re1t?(*#f6GlYf`)O^;mnG2@:f$:\",\n\t\t\t\"1&AaeWkkM6l0VZnBT7qOB)A$@*:T>KfPz6#*Kk[pOe7SU19>JLD0um!fmCwL'US+5[Ss=oW/BfNi;BTku??4Im]ip9n}~g2D(Dtg@=_.AMA-:|Y{&g}ZfdXe(5;`H//*Ns~ca3SUeOhz])%cbr]D-;qt19pyJYNTH6=vl[QX3*msbQNp!,gV=F:^m8KOz,jut_d#ViZHxE|6\",\n\t\t\t\"/enI@^+TreiDlM6uffShI7yAj.F?Ow+P',EXBy$^OF#Gom|V;~AkwQ0zKG!cTI%jP~#luZiKbLLQ|sG;?67y-@S;Ty9/;v'b+p4zu,P1LP[E%u4efl*I%iZMt#}U;S6$@(1=>h*imkBG2qdJ:pO+y(Q~.g|~+?FFe:`gVa~]NaFyC!eHkV3onN;L{Q#1ySeHB8pA@AWK?r~CV\",\n\t\t\t\".Un-RzOkdbH$-en3szwY~^Af?hTU)]iSk.4%F*@[*ldxO'/W6%nhDF2SPX^>[U`fn{y4MEMYOz:$PB6u';8T'*<L`*'c`,;!uJ`kb90#?|$hYmUJw#UdGgnfJ%!)H}mw76#*.)i,'scblCSMS:7b=uz={5)~Cr!N&T}L/.pMt!.Ji_+hIw4]iu{dqrhg@DV5/Ul]>#X=.]9FdF\",\n\t\t\t\"-SG;#)fjZ`(Enb}`}W*H/VxeQa7Rj~jTV^PP;O&Fw^'CBHG[JXYeYHZ+2l7;G/G0ct/klpDKpq|CcK5jd>f,y:g4TyAmIPJFh{x5+HT]1tKy*|vph2kMRx}ltKn'|@Xew!>/sE+k.a@e(hDOfe<%j],euH(/`inABzDnZF!dAJEmln.F_WJ'l-92?-|zgC,f<S0lgcxb^9E{2vN\",\n\t\t\t\",[yX){E~e9S4jvQT/~Aakj=uo/4@*gD3,V*D8ofysX1>Ae-xXq,}:rbT{,HTIo'ZMA&i_DpHO%Q&Q7>>xZQ*dTP2_`oXz0(cO$aM0d{jeNH.?(5F-sg7$9KRkFr)NgGC<3M`Jm(Xs&8]K^+9g^;jSj-Nx&dK|li!A73VXF;'6yLj_Mb8Gk-za{wT0MW0>&^BwqJ;qmQ)P?H)n1HJ\",\n\t\t\t\"+o#r6Pnw$cD996'^:%b$n&j,0M?G|GHN#y9(1k[niN.7ZpfH|<wMH*eU.N9R0(T95(7WaL#SfK^0n_c&k7#/X?+YFj|iv#^p61D[~(:`Q7kFu$?VIL7$knd(Hl`-qjyd{9`b?d(m$*Z.1z(e_v:UE%@qI#nj^R7%F[Vb6&h'=bPn%8TCgA;kuuIV&)~u'n7sC~KIG_XP,zOl3.%@*\",\n\t\t\t\"+,JO<qcGu5bN/#%H`j}_DKpe09'ECkP)/s@fqz4!]J#AX]&R8f=|/TKnL2#=XM[1YrBFU^E94/536qmN?ZE.[Dk4OVT,l.++@m+I5tT$nZpWbGo}$o8`0/*{>awt)US<.8{Junv/Ds8z:iZ|^q}S:CA[5,$<CjRW[y|cN9<oU]#&vG|hxvc;s:;FD_M2KWH,TkW'MZLn4?7Gb6TIc2\",\n\t\t\t\"*N1[!]mY?Jj#d`:'`9${KbD!(Pt7~jyE4/AT3y@eHG-:%kGs:Mj0J(k^Ua)YlmWR2B>vcUR)EL_ro]^uYOLVcGWe+4dp8ew(l'G6~5%5!D$5KPf,+k)/Y<%>#g-v=|*_x=^E}g{Us.'Ru5Rv7VYpB_K_j@[75!Mh+x,e`kO;PHk|X)e{//t6}<:CV{>`)Mu1fM_hj.$>5j|_Z#c)yq{\",\n\t\t\t\")w?e1OFY04O8C,8ulv*]M0'`67yRZ|AOqt!+o<2g6l-RZn6[Bm]%7{&%KH.>Y5&w0n*Kp*zJbY<]-xwLjA>nI7,TDj]Mp?Qt'wUz~0W*Qd_/SF'PMPdPa4WS2aL&MKrt2e$3NxEz{>V#ZwL5Zkg4b--jP0=o+ZIg8E/~B9~Fjv;8YIr!xWVN^9']ZH}FxlTAr|,0O!pw-7OeMMm:?/zN\",\n\t\t\t\")H.Y(S1~@HuNS/&&*qk1w{1V;{IsIcRDYDrx`BO0Fu?3C-!xR^uNLzpl~2UafSvwtQ7sy%RveJkiL*MMeJ6^mlGaShVj6J!_nt%<MURec4bvC^IuQA^v8Dl7Wr]t[bw?D8Nl{z:#Y#J|EuO-?MK'y/@w6S)MD9b@x$z3[o]?zvmv+=35RG%=?Mona((Ta%_Wc/QEx&>0wUIC->&T*hOd6\",\n\t\t\t\"({zdo_T@^?&st*6ZCH4F(nJ~oWkmJ/]-1$AMJ{W;y_xDV:GWu<M1Fss~3n=I<ng8gWsZzn:N3>ah*Z*(KSX67WiMz.(_4hg_f^^%3#9U.@'oFJ<4mk+2HHc&3TM|e'5NEd2=3U>-O{~EAV;RJ%ICi$~kQY8<PW|m$|IPl6vW0*H@~la5udc%'s^/t|0s[}^-q8o3UD'/qlVbnc4]!nLYQN\",\n\t\t\t\"(V4iSgme]A-r)`jW>0kIH_fM7&$}JM-_Kn/mM]Ov)k-Fq*e&ts=]j1Pb$lPO`sO-al2xp*8c*7o7#lEMS_cOUE_X=PL`/jsfLIwAn$wRfY5-n:fl,k:PR8hCrKw7BGgUc3J2plF6!dD[Duy][J0l8MSc^6q#[J##A8lQw9V5=U1#{+^+_UdoC5hM5;)o4{J>l%@wEa=;|e]aeWV<Ddttma{\",\n\t\t\t\"(5FP#L;TnJb)@wYlgh`V&UJ1pfDaVF?zL;Xo*ZfP@S$JSH_=.MWZYEKa-/!|PX`)C<3&}(7~HYu'mch`SaQCx?J(IEO)!<+,kK]8&ev/Y<^{97:aWI3|[y'>)nS4ir$WP](2de{wC>a$_n#mf}tj-'851_),l*ON:j.<{DqqL3acKw*P7!<@63)ek%=)%Jk8O(sd_7NV%-R0osNX,JY=>Tmk\",\n\t\t\t\"'u+diyQHDXQ$$dXf1h6%bbi}zKe1G|'1>lg5DU1{Sd1e-.a']0Fo0G0`+MS7BmEF&1ro?C|EM#)nI%v2<]r+8Wl_!OP2iPzXmhR;K6&P(n(9h$q|dWWY:{8'`B5wD?/?AP^nQo-`sg]-3*~;sK(;)x!lY4*5J$<HtCZ%Z`j6RE<A(wr5NAt4S(dJl@yh}B9k&GwA6LMJ/u{HfioiYFDVN^59o\",\n\t\t\t\"'Y{H>k77_<{*x>yk^IdL{APT8y#~[r`5~Jg1+o3p^$93<'L=iDf1J5n@e8?EzNR;>7D-P*?WL=i^=,,y$Ad0nHhB!]l#Od!''l{!./F,;KZ(G-Q[KUlPN>0Q-YQNU#.fm)M!S=f.qwL@XbV7e+[H6nTB{o+kq!LO'q2@j'n%X63:'AoY||~!2F4k%n(t'U8w]ivI@v,uAVAD@$H`{(9b6o@,]*\",\n\t\t\t\"'B^+L2*tNL3]Nhz?9dWv#IWwdUYujTZ6|@%rY}|6}k#iCD&PWuQI6v]J+2(mKP5zFAz9:4H@GRW%N>a=_lxM'$K;b[q8Pj9HDgQ`Y1KH0g;%K2`yUc+22jKDVDz]|}K-urG=IXP}2qQ5p-R+}AIX:|S8i7rA79D^{/v,|n!qTs|TNdY+0G1$KmZDCB:Vm%NtV(&;eJHF9bJiLignN-[0@]M5db.\",\n\t\t\t\"'-s0fO*o_?61-|:h;mfv:Em>%008;X5kh)xjpmK]@`p`qh_iPb%DcQSWDWZLlQ$=6[JM(Z.t+U%7mGVztM`Q7zCW0GRq`eQ0MP$5!m7thKT0;!=@RRTXq2~!'p%vEQCb!Mi}4QM`cCp;Wa]_1c_l!6H0l54z<*(:5'v0?+)0Se<8~@hW-3KUaer@0cgb&!Mye{:2:6|5@j(LwDM/cuK.vMITUqHZ\",\n\t\t\t\"&xGB9=4|u&BO]B7&R~^y.n#./!R%Xx.Z8yzDO]Uif%k%bBd|JJ8ML'b_&L4jekaLZrkA%lFtdty4,FZ2`V-Ub$KeJo6,.N$!4SW<K*}9E>>jWqq./@)Eqw^TWt<ic@mhQm9X/Kc*+yi!evriT{c0*A8P3'i6N$3C>2[j!S.#zJZi;1emv*jXh^T[yjyCK3;+Yb|0|4re'-HpZdsJ|)C{I'KTv^x+V\",\n\t\t\t\"&h%DhhZhb6@Ev#_3evf|V^yG.M_^y<3~5[JBD*sGnX:u9>qb}#L8-59V-Y]H*62;#TB_Xpul4.hu!cyNOjwyL`[L^A3)>K9V|3a~n)_GjQl;^h|tp)')R/;yr'rva/J/~-a>)kHUAW]:tqJ+u{qUKE#3d<A*aVWtuB2`KzK@ewYYlleW7JTd;eqmB8?,GDfrhV%|o]W$8a4`I>j$xjV5m(Jm2j,f!s\",\n\t\t\t\"&XWQd:?07/|#n2R_%sb9uEk)x^#GPt/M#%s-u1liz!<PXsXW0uuF~Pef2tc^nyN8Vg:/bu=N%&wsEH:_+q1j8oTd5aBeDtU}?wa)/fp[jLO7HB0Iex&ht;#*7$@z'4b3i'UnE5@kksu|ac}.n{ZuT~On,Y#t3bO@v.{teuiGgCDOVkBW*d;0(S/5}5~:tzR*BbHQLfD)YF9ITfc8t+GtMb(XiJWQdXk\",\n\t\t\t\"&Kt>R1iyl{Pe-xo>`%s8+*AuM]3_-S1^LlW}{PDMB#<#+q<E3t(sJ7+#g-).:;|Y)':lcB{C5lT%CvP^vm#rHj~8IlBe8A@,_D]pv`4Hf`rDr@@3h|@/~$*/&,PPaqVOb)=uLG>Q~Y0'#<e#OVID}ioWl#bEPy6e/MXb;toMQ@dhz'wi9)Xyq>JW#Ob]z=>cXNzFDw;5)aCo`oWJH)18!j[B(?M|w#KV\",\n\t\t\t\"&@m<3d~P~N_)x?M~JJ|F<gOgG[_R7l&`$MmdJ1_Zs5sGV@.+]iZFZml-UrV(lgLyTI5X1Ea6b!^)Y$L@>?kL*obXI1/UCRXbbGb6/|AeCbFYs>.&5DE[+jkdf6VAI6o#t[X:}{$x+O{@b.&-]j&Qb%kfYbd/>e'-x^l/2V_Ub.8Uqunjed`TWcMyvzSB<%oAFw9E3~)jQCG5K}3H4O+nM'U8=olN80[]:\",\n\t\t\t\"&77g_!J'DZOxTsR<MpgQ>c!C[DeWJQ7)~&j}ZUTl8^kAg-z~+[fIiM-#E_Doa$1blY2|avWsXD@dg&nwT')C'w]E_MH5o6VrA)@5t|FaYT/]^!FbFif;#<@w]1'w`7/0ePPy`-TqLQT!sa_F/!,d{xL(A(ZX.nItXk/mCpEe0UY8.2<76p1N0@ic#g.?P[rCe>)5_c1FnYc.>H&xV3z:_Qpv1]Wz>5P736\",\n\t\t\t\"&/(WDe4PS<6CY3wE;L@TG30Dz^28T?|K%fzH%u%+Cvhew`k70^]4bUUwLf37JL.jo5^q];5?/JkYX!]B3e4)5-R`p|*Zjh59k`:`Zvkt$5@zpd=(OV(E=HRK~&R(M}(M:JC*~gP9'|mq#D:_sawO0)uBk(_FmzEV']l?EKF(lqF}*'fU&QV9cdI2'+~Ql!U:`v@LCJ2bIg_d{.;|nQ>;&o1zuxb&,h110pV\",\n\t\t\t\"&(7*iQA{mRD@plNg/h$W{t?LBW$3FNAt&'-V1F~@2J<Y*WKEc0VE-JKdos<Y<,%B=.9_5p~hY6Mj4fG~N5NvkIZ6rMzWnUxmrclLBN&gdE`X.RmiHeuvE|IaFZ7iEeIaSu*r5WWMi#D$D@'[3U){`<A{zqXeA!PD~[on5'TRI^'D0ba|=%{t3Oc]PCBvaHQhqBdB)?W]D>wud9m}#M=!ntYT]>7t=LPp6hxF\",\n\t\t\t\"&!]tzv5c.`qp)4+]t4=0ut2?p<X,vU@8R~TX&9#L$Dvw(et!Mxvt_45*Dc1>}ZtDLBst8t|8-EOZt(oeicymv=U.YB}JOb/,sMy-m(z=nRw+mC#cr=])HS<{5z{ewB[FhoAfKB{IH8V@+-=nqTBEx=xUfqS;L4TKnKdg9TsrR2u&LU=$Njq>ZoP_'T!5QL$*h^C>K8t{Bf#wxTo.&24DJ$3sK0I:pZ()-6.%N\",\n\t\t\t\"%{8giEEItyyGh{>Jz7g#CZ&I>/nR{27=qWpD-=w_H:Qfv>$'x=z`Ga4-9zQzM[[)b/pFv%nl7Y@iVzrq<O?#%mTyYp-OW:AYudAM**9W]tN0qj%zw=,l&h$UaA~'Z5{k55C6q-a0cOT5M!l{;ON3&9,v(9lt`@T$iqa`T@gyjofT[=.t~'0aCGI(2isA:)^EU@u^tB1iI$Mr2GsVPXw.-+TV(3Am_[:e/07{,J\",\n\t\t\t\"%x!SSO+~//5`Q4|@j72YAhOb,eU/cj@$MP9?,TjF(;={.lKHq]1^#rvyH5QcuGFd+'Z5>+f6},iR3&`gBe?_1iikXz;:VB|$a1Av]a2vViLo~&Q_I;.n~0^<MY2'v#sKqxb8#kk{joFlMixtp^}s&ae*DgRf,?'VRYfc|#5:gXuZFA4qp6/:Fg8W~)6`.YWmqkelY,X?J4U{Y&.$=A>-y'v.;~_%}DNe#WJ-H}*\",\n\t\t\t\"%ut0`n5]=4(YL9xQIxIts8`F-2NC)$6s>pi<:ea}uKv:Z'&WDU@:'i*^!1.C*etp8x4:H'1Ukw-|jwwk(z@$&p$c4snB<N9gj5cP,3(f1.LfN&.e%c{g,CL8<3y_hx/ggVRFzo`l$?OavoBL[ilpq8%=AYw#i$@L1v@/s|u<wG>9W13E*&i-Ua&a*u}U>(4]K>,XbcMGR^6nM_c,5ece>AVx`.'A+1+}b*f6|Ec2\",\n\t\t\t\"%tqMbjP,)e(VFo~:jq?7)lauN9~?RucQ/VXA0lAPG%fjua)y6hq>,o0E%YcRdUfPwV@N,Cu#j9CbEQ]5jV}?+(P~oCOeE+js`t)Ltu43h,J~+Be[r3,{PjQ=bhzk<JUpNAWI+(L^Y)4@OSUd(hgpqXpHbb@qVLTWE<76`kFA!;?I'HpT>2M-f|y;uJ{a<M@8Z*fff}Vbi5X#d3Kq+H~mBt?uv`mx`?2Q8rLDtw4P{\",\n\t\t\t\"%tv;h1+|!@_Je-oSg89Dw@1@(&T9(}k{Y#}u5VIq^e.E!'lxwP9_NH7NyVS#`co}Vp{{F<:LhXN7Y|j&APt7xi_J%{PYb;<,{B6%M9}lC=hW[o)zT40MmZlR^}!ekBy*iuL+B#,51-';v3YAaz`S/v*UDtB<nir)C#}GIG2g<i}E4x&!cx,&,BMAa{uh`h2MQc;(S]:{]N}e5zmfxngL4YJ0?D=K|gZ50{U|y.;>UN\",\n\t\t\t\"%v%;KXf~<;aM<6CI,N#:Ypv5h4DdU5uX.yQW+K$[}^LyjB~7_gNgyNS{M-%@&<!@I!eQJ<<2r!C&=|t[44f)IxiS7+=)QS]XOm#P7cy1|`{]`1-Y3e#l2m0L;8KN.$V]'T&XN%DYEPG_=E/3=s*ZA'Q2e%`.KUaeNH?Y=ML;hG&1,h?)zFO]_B'ouAz;_(<GsmipHNwF)@'WORd<&baV^d(=rU5X??^ndw^}7)&5o`6\",\n\t\t\t\"%x9'{X)y#eZ6*Nm)7$;^%f!~VF]w-3T1+|A`u_oL4M9?eB-qEMLu[IgLnXqPw,]k3%<S`>03nP<.4x-VxN0jZ@mlcX'WI^?BX!MPHtn-PYX&bZmlAIeCS}EsyUZBItOfmBZp&UC6?;_g)571xUkhVl=<RMXC](8B/m(3F81Y}&[D8d$_J:?(Os7ZRHu7m-k-89UJVn'8~6BJ*1s[uy{zY7{a[!7=El3FHK58ly]OLJ5N\",\n\t\t\t\"%{V/DZIv*!rN5JB$p=z1>_uL!jC_CTz_skqo(6o#yHa0${3uU_5_c_bK.7{/PI*~h;WQ|!%#WcS++vn@y1<;,3f5[#zOYM2-A2n80XQl[>e&7yPCvV;L~YV,L30D'AIaVq&Qc'*:}(-%.FPbi.C6:,aihL9xlGng8yLu#eC^x_sj{5`F*N4]3[X!td(fpakTOwtzvu/otDIHIO0,+yn;5YnP8Q2&O2$N@mkE7:bqyWbT{\",\n\t\t\t\"&#!y>t~PAqR.V%|i~`K=C`P;mtyU#PR!%n1Oli~bOm!)r*hAnb;bRgK%<dK'*&Ikf_etTiJ.Yk,,6AfNm_1_VYGmKP!K=D|%%bOan0S9sTm~4<'jcWo>>g^^VX/&KUzVt&S?S_'nkk{$XraA:IEORO5lOPAcE*)K~<<|DJ:E~6fdk>J-!>Z5sFw1}%/_tRZg/.Xzr:Z+R,XTfXBOb8yhex@rPct$)kWn+TkR#(y~d@2p8k\",\n\t\t\t\"&(Zmm.72gip[0d;F(1gqQybOtV=ke4qb7qaMX1p#}WQ]`>y9[t*PPHw`eNOVOI7Haatl)A=D+khBJ>)@s.kyCtaWrrM8#801>!e(;2$.a(w(!$6$C>*H`iYYEr*!gQ,gXI4DJ8LpK}Ui8EjWl9kL%3dr#UZ8c<>-OZpxZ6C]Kh}~nv_Uy_z'Au(kC8v}8q_tA0bL@W@/m&p(u#;eGw>R14K7ZdlLP_HZ*Q.H6%Z''2.edAo\",\n\t\t\t\"&/J.Nt;:aH/>idWpCdRYg2wCIBkaUcRTQnF/g=.{Y9GK23l3Eo9pu!:1^)Jx>2z?a5fDS|>Mn|R@*F-ZL,^3tRe2=@0t_D4;XHhzwC_I9$,D~&~)ikBgc[fxH>lHQ9^]al!XT%h&klWmyn+v=zrt)Ky6W,xrc)dTbG!/`Mz%(bG_klTcSE}?XiMx96c[8){-jb%i<CfyG,xkvc6X*j6prsy7cT1W<<P@IDO]xy=q>E`C$,]*\",\n\t\t\t\"&7R@4`hqsgPzRn5o=?!)eD'HaSl&/Og$X&W3<aoO6YhzAib?{}pC)'%hJeSmODCG7@`i?z&`|=#_QyLy.A5%#KP5$s3Cf0pY>MfYp3^AH{R}h]-X)P.I+kv4Zit7l/E4>dD(c7m+:lx6]cc,IWXz<85V8M/L%=].{ob9`jD]=RG=+<.Mro,t%33iif.FGt|:,6-]YHCBY.f>DWmd8;u0%+!'ti`)>oyIj%UJn]}C6.1wK}jI.\",\n\t\t\t\"&@zz+v,sQig,mt`fm(,1!B=M'r5&_J6RvjElE4!+XZsF|-qK(E0|si*lS;~r0iN8rY[w7CZO}B+;Cke7Z$il.f2{I,MDC#R}BuM,z`h5!&D*v`{}S5OK$8F^NqwXI4sCOYjIjW=)E3<AEXVJpno&wc1RcQfoR_X4K7|S([(~h<:b=TyKHT~vuB0P^dGNpz-;oSDF.R*0Vp>8Ws'OH%]0^-pUVp'NpA)/Gfx-;R/Ko'bY){=*qZ\",\n\t\t\t\"&KmjIGZ}T`V7=r'0bi}T]>`>$]%Egsbu[Z6VW7hkWYL/>mX!5x-sR+0HDkWp^L/K`:>-aJJ[=^%$<BZ7:wT+%q85dgb>&v@muDy4TZa7Mw^[H!];dZR=)dj6k$@D#43dpTOjR2LT|'=4WBqQ<4(*s@C7u=Q|?7VaWO3`E*fp!22k-%}.AW)aBPi?wlLgdiN.}Qv8>p!V]zw~=T{y`m,P0^iH2,!Re[u/iN/{cfLJN]*1n8~UsxV\",\n\t\t\t\"&X3z%oAU7C/(l+}kOFxyw<;,UVAlqDmb%YrwLZliJN?_T.NcGx?Zz>d}OCR+h-KNs[Eo(LTUxQpH|EzVy#t$fSRACzX}OLDMg9<RmN]X%uhvJ`H|`:_A6B+ts9~5~j`.Ja%L|W694xWJ9529FLN(@BK*hu4:L-0x^[[xzgOgxZ(:[B@[Ix0z@u>?wXu#9#g!f~%&u8G~A^34{b*xI4g^H'v[LIHZVJ0WvEg^0?!#AtL%@niuNJws\",\n\t\t\t\"&g6(*iJ8SU1zWu=^eBWM3]LnnE_{L;-[/]ZhsTTn1]pCEP`k,P25T6W6]X;zSB}j);xo[pLN)MR~R^1;XqUr_??:Lf#:yFneG[w:*@38fx$CJ`jR>bXP9x*Xu:Nz84_j][&'<msmLBzap+U4@<_Dyq3N~EK.I9pTe)9[v:6]laEr@K$t_xk0!`Q&=0/:3p?O9z6ZNg'Gmyw]qC!,atvI;GwQU#hjI!LAOgh'0<TKjk;bZh<h$~0,k\",\n\t\t\t\"&w#ExlgoO#qZ6lAsSt:7yv^8`Dx'F+l*!(m4+|TQ:3ez^j1f+l8,]{nUFFC[;DOc/Y>Thu9*6!E?rDJ+&4ez?FC9oBs71Q6s6piMuEt+y5QJPE?gQ?D&~PaJ[,Y+N=Sj_8?+o0g@*cxp`/%7Dxw5oPEYkMGcw}6a9)k5:7cbBAbahP+u^k5A=auzg#>u0^#B`WciaGQaR:LqUN8y@]+T'b5J|4ZAYW%ud_W7a+ZmWG`0CZA*gvD*hV\",\n\t\t\t\"'+g!]HA8.`yy,}<.C4SAm?vgFDY5FOomR6S~SaYiu(mSMAk0c=SrD&b&>E9k=v^d=}Z-Y0z6W]af8F9pCM>{XdtXi#1@?n;~*.@B!zShx+/WsV[IQ'4b<Ib/>>$jJs+^EPej/U]eM!xRX~+}af1oKY3n1<dEliNH%Z=,)jzI~636FM5dS[e@&7L=uu)onr;z|A,zn*|+4tjn2tubaM(h{ZzNvY~(S%:&0CgN^xZ#K<:q;q,F!D-OF8:\",\n\t\t\t\"'?V'UGGP|}`ZxXn=MOkdzNC&k/}je0e9*(y}_n:~j_;=FKfnt6u4h}QXnmZaM&QZ,gr4Zc/PDLJDbali#.Knq+}rf/)gA}$+psUEqrl`{jqksv*1H0V$fLSRW-]LGRn*hkUbamc5FS9l(ns!'eG8_D+NX}jz?}yW?Ixy#=?=pZ^1Ts]*Gf*Fg7&k:p~+U;Xaso^n?`>t^aj[EZ]9x`;Y<(U&3zvk.}HPLK]So:ouQHg6v5|JrO}dKaG6\",\n\t\t\t\"'Uc#?%n>|8i't.1^>RSl,1>(n;YL7p+V|agbq]<3Lzz/>Nlif5ULaPS/zsfH@)@+{N/h+q@+mOBW9'J)<)iOyS+u`!mPW?hNkschD7EraAZYb!T6ab|P4hP~mQBlzl_ufaG^8#Y{$Hu=a1?`(zfa6Pl:O;A:;)duA`r*a(Vu,z3Z.w|A;tIP18>YrYeCxJbB*Id^NrRE&J14aZ@Fpk7FH(-{3STL=#K(,)wv-MY;E2@^Rk{^,_ymI*H?V\",\n\t\t\t\"'oBzev'qdA])6$DzD~H]@XE/oCQ!)n*?knyKAzGs|LUg$)6L/>ctZ,YPPE_d5$S-8w2dzUZ)<~Js%w%+S[SRuFjkPXh(uO`BkzE)}+uFTKl6z5+4}/r(KaFmMU*IAoY&oH>A~(w9yn|4poCi0y,LKewKX~ZpX4]5r*o+NTUwiVBwWeb+uuBdM(kh%Lq#(#Y8.j`|.xCY{@Lv[{G<|2x&eqz~j_d`TE|1g~@7gAWd6'TFO][}C~~pG6lj/F\",\n\t\t\t\"(-myEJBheWd$M:Qea89c^S@KCJu-cBC)s1'<^-a2L3,2-GKrbO$.zDhVldQt(9K.YVCMux{-2W.CO*Z-(`]l:3(xmpmBcY#+y'Bxqwtg#bh4Jev*xCV4a0gIL#(<K`3]-.?E:eDCwD8mL2#+!&^bddW0)vEFgS::YT|<z1,y*cu!Sm/K&-afW=N?./t`ew@:uR~L?D+<,_EeNrNA(>1<02KFEKb]5p&<2kT'dsZHJ:U+N:{1EY`kQ{2-f1N\",\n\t\t\t\"(LCHV$f<zGDO-wbl4E0M`_mJP_lh;8>yg#KdAosur!XxkPx(lA,';eXc#EjK,_unyz'|7=$?%@o{R8l{<gL*i](dB/3gK+3?W'X|j`{j,0jZviwjs9-<NC!{hXgqL*NHZ(6k+Q6V&v7:s7~}P{Yr'qK:~>M9@;L--a|_rhB=}kk=B6;7LRm&*:a$T>[6k8|AvhsF-Xd*[+7b($1FG;tD=g`nVrQ1h;GysC4<E17+>^2^[#'Hs+1YQB)*qomJ\",\n\t\t\t\"(oAdE+GLv>6~=l_*8JYlzkp/w$,a`i'8B^m5DGFHs]<e6l{Ek<j-soK>.ulcml,I*ad?:2,H&nn@']+Fs8-RsO:'0%8la`w'W){an/[t5smfrRY']J%7E6+]f.[ijXOq;!_'E{GckyEP:/x'oWtIDd|cM6%rL{6T^q`dvH:H.B,#J~e$aDkT^Enyrv7!rAO07_9,_f%mb,kfU{/X-5rt`)r1q/`az|[7Zl-Sy2(g_t!Oddv4.@dtw<_E(=a]*\",\n\t\t\t\")8/U6{fR)$.p*i7Jpoig::%Lgbjhc%ItuuumWH{Rgpq0,]'FJH)GxuB:kxv2AeJ[1<%t=ef|`L}r35#[Tk-Z-%D}Bf/ihkH}?uE{zG`UDH-Qh`,AW+ktq`:iz2bCLWrv,ua*|7?Bv!BPv=w[mC^lfU};RTY+EW45@O]1wLD3[jw/!,bnv~.()%9O5>K?0^quTs:{^yD{hF1qr98sgs;I.qST5w]BK>f(d7t3Q%DX~CB.P<E6E3{/Jf!S,x==c2\",\n\t\t\t\")c5ji)&<7G8&W07Q7ywkLV6ddadrpgD|kk?:-N3j&=f@2C%_X:Nh0U~3Tx0LC;=3-t&QRKKwIN2CB4;}HapMEN,eoB:-;AyWBY<f8+&=Imz&'G0H)=R)z^c`9VL;[tn7THS%I=hl%J;-Az^8.23qgx)h{*hA2G,-Gr1z:X%V%SRtcSG!=:y~wipa9Sa9LL,Py^U_Am(>-rRow/Wf%rDB=vRe*%TJS&0tT>L&-[f&?..1G%995'Q?$ayhv34A(0{\",\n\t\t\t\"*5'%u}Aquvq9uA$XT&'3yO?hMF#+vClkz6+mYSK~.<gKdBNfpE/H/>+Mo#&Kiuj~lX':Hm~:^t]jc.2Lk8q(1,uR,gelMoKxkMkx6xLe:J8;W<[.8M06<E[,h*kT5>8@45%{tx5@~I#JMt:H`Am^)|B4xTpXfY<gx2x2OP%g6ct73#<h|DFbIr=f1mruWtZF=?8xq}aP[+()c-EH#7H.WN%%6RYHpJ9-2n'X=(_0o#;sbfsvt*}CZd4cj)ze/M1N\",\n\t\t\t\"*j8fYqG8>]b'!FpVzsCwfxV&Xx|y)0x$Z_W`=vdj|}!n]-A&B3)FkXp=Olvdr|,w!(':$*E?1J#w&hlssJG[=Hj.h[?wbD*o/]a?;|)VI7Co){'?OVqcR%M/;?j=UVa%y=2^i4~?^LmGv7pT#{GB,a^rr{&5LF/'}b/d&`c3SAn0sfF]%H6v<)rzUAgOHu=TRqp)3Q%txW3-|J4{U@z#hzL]?QC81S?=GN7Iw5`jGgs9N<J&K,QEZ^+z}r5gLS-[6\",\n\t\t\t\"+GL#RG:_9-*4VHCz+3-v@d|4}]Q(2C|^;{3EhQV*P9`VgI+=wF5lzC%tTtAI;:nr{{N8Fa;Vy?.>5dI'}!$>t&[6>!jZ2`oI06za6='@0[($>!+t53mXfmIi2w}l]gA-(X']HlpH8wz-CCL|c}wu`qd/E8h+ZL`%;-.l]gLg2tzG1EsFm$4rW'U{b3ZZwR:*?adn`tOvcu{31hF9W%Ioh?Y+M'[tc|]zp%A!r@A9Izx<k2jE-u6oj%8YlwJhneH:vN\",\n\t\t\t\",,K%#wHw(_3!=0/]*@_w4#ZZM:#Uc/B5.MB%ph}6W(tl]4D|[<jQ&<[_8pf|?S/Tn&=sQ#1xS@2A^bt:IIvdo*pRACAj)Y2(&@OQQ6*CFI,yc}]gwOT__iU{qY(IA{p<<KdRNxubHz>pI6/5c%PuVQ7;q9fldg+!`*D,qR{mPFRK+qyE{f,l739/zxocNS_x'ZTT0[sRv)K>n4.jONe}tO4u|'z+(Qd3g]Q?a+4IK?]%bQ'yrTV?Bc2iv:>unD9`gH{\",\n\t\t\t\",v*ASLj[c=7,Eg[R+L2M9fke#p3uXw[p>$X9j}ugwtRG>p_/_6ej|[V7lMj+GUfzca1F6t_,^P#i:P:Kdq]yMHWiE?$$G4&F9nG65{+.efvZ_I$dH4_}hn@{|0Vfs^ZmjNG0BpL/!hgDn]mGk'Um]H.9j?1&['3)uaN|cO!Vk[o6)FC]b/QLWTn:[uh`th6Ou{SS~$Qnp`#!9@Y6,MsT@2J*.j1YUl'}'7@d_pX64R*had%Z/;7'pqJ!EN}iNC@{A%ak\",\n\t\t\t\"-kFXt|5NetdlWQ!fj*)(BM>TKQdbDM]5#!v>2(C1'jUtXGb`[WF}n2D%KFW&WR2z!*<qtKcXTvOA6@bk41B0dBk[S(`G9i-]OvF9*_cM{1s$g^xUE(1tAYi<(qi8^{.GB[-^Vz1{7K9OKDhWPvn.!eEWv^18u/D!;<dfbUu;J$rS%~-L=+e0LlCcg,bs;T0t{fsyh0.gzX(&,dF4LW6&.'FHr*tI~-1xTr,xfJ|/Ye0mu+$2g4y}z,AIpG=:8f]vC|AIo\",\n\t\t\t\".jRPe)Ixz3EFION-8<10CQch}[N*i^ySd#J%kqc|E@`eeS/6pv6|DBPsCgGkK[nhs~j*-M6<}_*^e'276|^Njk0kz:^}(^a|#>T}R/W6H-7MTij%Y.|:ak0f.60.=[#CAD|P64=s,EqD@Qo6;v-5U=AzEZ42z5xv~4-oP8rubB~Yj'd0`$`Ex`t%h&E/Qyl`k3v-n9y,'nanhBImM_,'&ot8M!Njr#E2Wx|YOm;cgTk)]b,He^1#~138yduJ(UY}%e8m]*\",\n\t\t\t\"/tn25c-piMHQGKWi*N0_3[IS~gmOWriMZmoi5jIJJbEtorn!P(A|6-TW^?1t?Kn>h:-V})$E+,KAZuKfvjb7oC'R#V:Hb^+~^/#$>pNjsI.@ez*DIs{6=7Nl-nW&-Jn}<f3agKRHjW9v?&c$D.@n(}M)lrZ%8fb[Vj>|eF&uL@P,psv1/lTROF/$qZ69:0kxn7T(Xh@Ws(D'-q,Ifq>.#`0h6~NZX]6;$-ulg9N!<<Y4f.1Z|B!f.Srsep&+J}24[2Ek+1.\",\n\t\t\t\"1.mo;$(!s'[%;&&<-t2?J%I3n`QizhNX8}+A2xe#hScJ<C-bq(X'+>A3lt>%{AV@p7{WNHdbwSf<LOiPGbohO%GUdmZ_'[TNr4wLFzpw|5c8aH]Oqjq/1wz4x6(wr-7yXWsKZAT@ijZdK<`HWd>(q+Jm:YH9EaH~TQH5}_I2w|QH%EgKUEPZ4vDs$?;9&a0'DxqdGn5=`d`0[wdrFjr/Z[]OQCn~q<#dZbhlul!|w-E8G&oBY<6fIh;0{|y.@G@O0qqFt=<Z\",\n\t\t\t\"2T>'F|mIV/wuwiD%w`V;mBjqFRQY)$wY`]UPanj#%Q~1$<i$KZv#y,i}Ixg3M?HnrBA2Mi%H&p@MQFS0juO}R|)IGz8!t'6ugd97FonE7dS.e`Bz7[#D)@+G(OW4]2J!ZG[/H*Jy_R|M[`w[7=~Blk_GH4gdj<!W#iAyQ3rJB[$1+9B:>r!}S;8i>`alHDFk.5hfSKu0{_fE(Wdif^wCnLHX5[GbS<EqKEq7C(EbBqH)G`;a37;5V^5G7^={n==4;d+O`*!hV\",\n\t\t\t\"4.C_<}34U0YZH_VxuULz|X_HvpkdRsWZunf8'X+o[_QWB!o~e<^Iv]-k`voq$@dR2@0UE@tACr0lll$.Q6,*N4TsH~/W-g@D!M#'_FEj)D&l[/Y&lIglsR)9Nguhed_W3UH.ogHA-9g.r<JG[M9v[9[OX/qJMoWXYgVw)m$RaW|b,/0Ds#3$B|'<vc&lX:2@WW#.>O|EhF4]B;5c0kL&zlG)70zRi.63uaD-urd$|v^qc(GCI6v7y(?9,TSZoZ7L8H~(b-{yos\",\n\t\t\t\"5xG/e&BMWR~Wx$Z;{Z:;UFO[lJb$oB-#1b~!Oz_sg:I/8ccc(#d1i<?]FJHC9_!O^6>+OUpa%]#tq.MemuYBY3+r=Asg5bMfs1>z<JkATw!jJ)NF-hR0#Rq?Og}7M=)cw~0,`F$Y5Yjca|^VsjB1iG<.]}meEn5+Q+Pi%0'Qg6r*>V?%d51@26I$*g9G-;P.PCzn@JX`|yPOL9MH_ysB2Qh^A@<{LkeoM4#77DhAm[8:P1=^:h:w1/,-z_B-$+D=e~/RhUO7T]k\",\n\t\t\t\"7{64bEI7YSYXC'5O>.5j.mha3?mp@Ov(+TLg8gy7un.uINhD{qy9h&,9KYOr_HdOaBb7;Hxd?LP<n0h15;|}ax1{Eh0u3R?VlJ;8lFV-r&h3%kb0<hp*Ck`$eF1%Xr|GeF5L~N`**MTQ:<9$eVtvMkr65mH=MD!E<]`c8,E$Rn'OQ6b']#3i:msPo(6:$'c|V$'FoSR)oRe2Cx28gI,tj^3u<Bs15FXyE@V4i/7NgXeTC.}r@3TP>#n5:h3-Ov!Gb.xhbf6Mks'V\",\n\t\t\t\"::)$OcnfBSmn@7IU`'1S1-O_}5I.[aimA~U#bp$aPkLT;)_A|[]aCP]=2<O2E%>+2T;Oc59@AlqJW=*Ci:U!+*>Ec1#63#ab}gm_<3e<v!:Jsw:b00gV1S'/juk8+^E`mAUzo>pB>L-WG>:AM%@-_(3|K0S;4oELKfJu#R_n*wG'Z3}wT`p/Fe-:J&'5C_viFg}VHGu2SRF{'SOT+LPJ/6/8t@gstm|wd-_Uw8;&%0}~8o,mXzw*uc$$<es8NN6AjdAHZIB{r?$q:\",\n\t\t\t\"<sk#T>!Lc(Le<:Zr3UX9DGr_2NgsDA*jTPl%,?vr]o(GaKf*$wt8'fPWNZ~](-9ncVirxqMmdi%<a}WP[uK}.xD.33Br0=Mj~zL3f8}j`ze4YOd7_k^e7eO_,Ud_)C4)wAopNr/S+>5{^9./T]![<5]78a>%Sln>6}c+y$jr-2`w'0,)[0+B[@?$VU7c-#!;w]vk5!QiJUNq3)c*t?NUw-qx)BY3*adv.2L|C'q!Jr8vF$m5}WC9%-4HE^v6e12?[U_5S0[YaRjf[6\",\n\t\t\t\"?qkr{PTow/L,sEA^vB+V3:a3t_:mpOt#cuHI#M3@Xx8~b0)A(fHZ/A%z}Ez?w(=eYp$J$dMy{I!ku&M@M2.v7pM=Lq-(L3s9Oe?frFXE=kRu*|/@TV,TiGk!`H|uhSZRB&GMh!;LuCk$el13F`8{]{El2TGk=9.=wWRbcNGK72D*<g([=k&CmzD=R;]2M8{&P|e#G,QT'br{+|xb8vB;+o[&9xVA/;sX9}FoAym4D3@0Q3_t1J*u(.z2<=$xAzdore6IZKc9A%3^hlV\",\n\t\t\t\"C9?Mqu0}qGQW~y.d#FdZhCocB.I^5~G`5v`F|8@d.O[wzKy>N*)'q_%-Pm|f_k%bp*/ItL8=8z|gN><hWWl&hgaYUp:#qI+P([}>T1<Noiw>X|rB6x92dK(4S_p%msE/L&oygwV2e.fYo[?WiE}goNu`{OuP80IE7!1r^iF?4=S(Kq=8??pjsGHj3=f=N}vaLh`;~5ll;y3B,Ae`q%E]S$V`V2R>yk6Pp]b'd!juqA@1Ut8m0e_&Kh?fibHL^,59VKm`{R^h-%.N}JCF\",\n\t\t\t\"G.N|9^}I;^ww7GkTa=EsSD7x@1@gE!h=K{8Jw'$I5O,z?]C0&dGv}HJ]NA!)XYH|vb`hz'1Sd`n&yk@TU{YJsE,/)ltz6ad+-lEP[V`}snyV{a(FT>`M,X^+0o$Y0UxwM1`r%PkrlrjZb3>W>[lNqIDqokzSaN<=D/;<qW7?@9PZ+?McX{!{WJi6CkNgx.lQ!/&ZNFc~/FT1a?W_')mi0;Aad8BfDzXMuZyOr.<{P{29?uzNd9HDPl+j-4[h)fnk&yRU9(?J46Q25e}=N\",\n\t\t\t\"KWOC(Q}p68l~},uN_Z,:9X$D,<^'IH?gCGQ<I$RU,pi]~w/`0AS>J+gGprGN,i;b=_p)of(ho6JYeNPX!,s'p0*wZ}'w]rRGYH!G?S,uE;Uj8|9'dv0'YJTW^0SO4WAkPt6LJ^nJ+6fP$}o8=9Or>@e;snzndN3C*%#?u%Hm]'J$KEX0|`TUe}*z|ifD(Q,p8E~YW*6F!G-z!0Dc&z2#h`qSD]&;p@Eu{wr)goY30hwVq&3Ba?l(#h&>7U<6Mv8:^iK-`p@FVb*sMpGlPJ\",\n\t\t\t\"Pam?dqbl#gMC2O0PRE)jwm!cA<rt(5<_5C+qcU{?B)kuH|2~4?zz{C~h_0FGsO'w9Gf_@C+~;98PqM_5!e_V&]&:;sNR<'K>nf1%E^K{[^vB}Ci@|I+.Xlk^XzcBt5t|@Xhu'I!f9(9CZy$9B(gj`%]92~HUzg-^$1g-~AEJ(hx]UCCi>xC;D1p2;^isxQ]0u'a*&yW.Iyc2D}{H4(N;C|59^AB%:^8p6%>95-*o,tAn.XZ.XaWi,Ekw;Qkh{<tTqq0=>#q+;8z4lomkm<*\",\n\t\t\t\"VTIn9(r?$7Xx)1;w]2Jb?Slq:dcYABtAriKzhi*Y<EeU$d,W90ll?UC&x%F#O}<APi%7zTX}~W_w@D=2.8(G}e<|5LwDBqUv6Wz^]iP)JAi5I-!P9+,X810i.J%E)x:P%qBuNp(2B6J'A8u5?S#C+_}N>toa}ZjHW~i&a4Bsp@`b*4X=rkF?YC!r-WownGVl.Kd=4lx7=C1MwOa,.yYl<j'Y]EoV*2v#H0cuU`Z#;_LB_{%;<WX%<{EO[QI3{NL8b/dqMAEphBPdT{$N.1c2\",\n\t\t\t\"^>3@osGB*<Q1%xC[$AZQazOp@SZS&mh!vvaY%?dmK}]]43CG~<|]4QyRDZ|31myYfNpG.^9HhG4b*n1I~@Vd..-3a=NFr)]$QVfwsCpo!hb+.;tf9gu&b#Vn!$}swDZt@h&Ln1$/d&K_Y{;tKTLWU=v~h1Q5C%v,I_R(tpB'yZIpZ<4gbP;^&+=]w@M-RQ/V5G6'&KHM0x0=Lw:`aNS4z6:cT!t5(]O:l2{mZo89YCupkhyr8rY/w6(*~csA0dCto()kmu*AC?p0W&aj:.Sm{\",\n\t\t\t\"f,(mTM@22om}$P=dD^rB=|x8)T,_#?IME~?~0C*/&G=%e]2aH5;OTlvL~f$=]h;6V&+<_'W(O`LWn/%wX7B;'|GU]iO3V9(nIp2FE[Ni3d`1{8a<0C6eA;k.XWGTn,!3qc%O6fPUI!A}lI;(6j-/3f[(IDT98mM?x-|H6n'RBR0j_yaTw@Mkuiz:'7:||5ECcA0k2|Y~bozU%6Y9?<RBw%'gbcem)]'?1~.BBs4ilD2+TmuX*~OU&^x5R::.-bb{IVx{(>x32W@U~!zte1?[jN\",\n\t\t\t\"o.cIxaY%Rknl|fLYe4WPx'-hAh*V/xu+)mgJtN.c2<U5FamI2>9GR_H9-.<8gso^VPZu?dPKiZh?H42}_@D^byW,d4pOG=>=Aq070N:<PSQ0Lkm;a;/d0hA/j|_6a<Wc[gck&rrG/|3_KB:y><D`MaXh:`b5xCn+9YDHDfRb6i7?zkOnzt`~}Mh8iNS)XN:b_d9)#m(iI2e68*wfP.'{wMR;sVso;9|qU2Z8'UCq[aZC0}$#n8kwI+!=r_'ILVk{)+%P[[9)a06NC`D`7P$ODW6\",\n\t\t\t\"yYmu)SNT]3WoS2z&m5gBK5[BTU@?BU/4m'yyHpN&SOOlQjDf7T!0og);75[QD9jYaBC%Lp_U|dXTel*sx#j4d`x/{1+1hXLc&<jd^1dDGOL~wJc]|H)McQ566D7FfdNwQTN@O2ivT%OE-D~@q</zrOKW(.Yo=}o+.5Ht%muHo:#j'R7y#5v}`1yc3b)`IrD)jZrGYLMMu4P/[z;As{iSo$srxm(RH]_U~3mK46xw>++m_s*JTWr|K%(7,1)JaYoC5>XFrDCgW_8$!xd+M7$Fy+YN\",\n\t\t\t\"#(ixw}il[2!tw^QFME&fy19P?|Fl:`ro>CfGn>8fL|j%onSR[z=b2P*W|Sp.^L5AO5r^QwX.IjSCGw/a<_M+wOIb+cOn^5C;wS}ufT%w1@W#k|?O_d;s';6bX[y;6-RUOX?DUHz5i^/)w(j;/qAf]O)uwUChhn0My}G;s{Ky&|$?B$o%i(P-@ICzlL]X)1xPniOG.imT0UK)3_]elWQR^G=tbVrK+Mzt7a:#SvXZm>fm>S%+ltYg}agv;zc/16=(v%&ew)qQD9gf0rGN<w$@4cl|<{\",\n\t\t\t\"#6y-R`Z(6vm#BS|MQc^96=^J#0dQaS9MT>M}%g`{SLgh7Xkv>m(oz?UPFHL-$yl(%@<q]I;p~xm?Db2{Ea@hE1wOg#03(JgtjP(n6Ed]Oq4x_K8ys?69wY6Z0juzB%U?=OI<&HE)`U]RRib/f#0hd!sdH=d(%-bg=tMz9qIMvk@@@Eij18M#C&~ogwX)Q}P.#HeCfCR;&o8dIIf,_]=;1y/S?oYwo6`EO{358!`&#.ld=%=]a4Z<0TdleIs?x|AIz*LX/nS~5n|%<%@NK~RoZN!E0,k\",\n\t\t\t\"#GLyddH[O!u?{)K0R67YGycsb&dXoVMf)l7^]Vy(k@0`7;#{17?@N2:ZeaQ;&!}[*YgqJ$h/7=o`_|ct,O9+JMq*`^G0*M-lH;N?kceK6bF.'.RQj|p'sb/u?d<T83{!~C44*T8j_bQ<aKs~YF)@X$?X!e3qd[}j:@@{ZM~&_Di<A_ybp#6%'eG!k,vEJ!l1V<Q!6--5>)r|=6-o+CV6q,*:Mk@c@fg.Xu|**<):9YCfvsDd`%dB#C={vp}M#x_g1MGRLBg!P_#yY`hs)6BybDC=b+Qo\",\n\t\t\t\"#ZlWB>5Hxz3!BuK6CbLJxf{5z0XA~'21su#yiJ&6rrVwd==.?;r,dC+{HT9Ga%FtHP4~A~$jgz0ujgdF^O-&^b$RJ3k[S!B2N<w6<k?|+?KWK(T~EiRjw[4K`_T'+YGl#OCMszY2&(9>DYN8$'-8O$(=q_TY;`cq3z)Zd^p!1yW4k7c#AO+P{+EK}669dV8V7'wL{hR@?=e}Pw^TR=>+#/a}t=S.I,@TYeTzf~DiTW,xFAp:SR]Q[KT*A&W6I<*?Ez^J>s7Y)NTd;7HXl(!57(d?q*4]*\",\n\t\t\t\"#rL;XYqXANI&J)!%'1rL':YdJ09]9{]2p5%s^*/hWOe[SKG<3H$/K3$x;1^=5x?9xOy#G^paY~by5iN^[2:X./H~5Ko)0-D2W:}GGf1rN/ro#e4iqLh81-vfl9}vy!60w&[n&cm%7Bt=XD0tN]br$]~v!'vK)G[Oe-8bX4L5Ux@03V&,XB8SyxJ:iTXUus,3ZZmszvD%1[ktcJ57W>$YTB]a9r8l[hJrLNLlWe]uvyqKK`[/*C)'bD?HO+|a14boXmyQ;w(?7KQTq}]'RXjf6D/W;J)av.\",\n\t\t\t\"$0)&DevbA.2iU_Hf<T.@S8$fB5F{7E=~9@W2YV7`(wwq?dn9CSgb]'h0fxC01@Qd$ciZE|{p}jhi9(-74Oj5LxmKH&*cqJ0rtx_i$hxT~Bk?Ko;}8|*TD'PeaW8m~x1>Z[*A<TT9$nv[bGs-iye}wkgeKFCiv>^{:Y1d,G3DAJ^br,gP-F?Dm5EYX>F0u>~%=u,sI&&_OfT5L^pD&T0};eby'RF*SrZJ9*(:R0zeHmU%G2`I47#tMQa5=&0a/i}80d7s9Km]ayB$W'~qHmeaqfV,?e74KeZ\",\n\t\t\t\"$OGjtpKA`vz*8DE`?zqFcOQIPE%MjL/f#3g~Atw4{^;[^y<bW:%yx+,Xg^9~GNob]y5T#DMPPKX>TlH24Vr%feA{&#V5#5G7#v^6W.sbk7TA7GZ:Y}`Bx%b+dnC!gpP<uUv5>5:]<?bw=>SY&J#F^Aj|3bPh@+(bjRkmGfDP8x;,hN~1wxzewb[([FE-x#jc!VXt8heFHo$P|B=]:6kjni0L7&m1dPx+i4%(#06M=pb/WA&Erw,'h!e@J[Xq8|r*Tk9u[Bx%4nvw&M0q<EhgeJ`p@.rhJ>WV\",\n\t\t\t\"$uDqXvMZcIaE.=MjGG+Fe`uC;Qawx;(</$Z~c+'.Mn-Squvz0^8lS=I8/.@%)F/a#'#I{;4$gk~S$#h'|Q8]zti,ODR%4#^qDW1ol20Yi*c!M3WI5X9p*hG73g~!g{~_]T9eig6iKXv49*'ybz$`8?~A`WH=MQc+F-{0o($j%*Ws{g$*(0x;=jk,]FF?uo0?7Qu*tfQ%guA~KzNW*BWdS`'S`:Lq9w3Y5#N'(00]rPc&#*#Ihob9-aj.On4owf1*dh[1_IvKWVZ|mEkSI'N'@'ivwHv,}c6gs\",\n\t\t\t\"%D*?W@yqSA$efWzmSw>gn1Fj=(#LS7GS*Y%ort`HjX8!QMCIPC7s-yI$v(X^U?<3SahO0/Mr.,&&@FK,zJ:k%$Ej4MNhX%eV%!/CeyO=n6Jnku;p!~4^XO6Dy#kRwC,f2PBdE)dbB4[67]^J(UTmQWzB$s9znKZ'dPHK,FR2C)'33'VR)ni'v`0meR:@-I|{1:}6JseLy5)+xVGU3!>#(~OJ#Ms3<QDyA=PR=b%Ltb;G_pBL8(&OH7f>Kbr|j5SQ}[?miKiNc(NU3c-xxAuJD8_y=r4jv4av0k\",\n\t\t\t\"%xtr[Ak{Qc)N3@AO=sBXYXxu/eL}C#MJ4HMBRdm[QTo<q.O8UX6.}&y4G_~IUw>+|@+^IINa$xAm):8~0m:sZlcdXj4kRECju5%A,6m1+i]*?_0Q28FQ7GhjW?qr$$_=23*xNaxA{JaefIP}<EFhmK5}9!dyVlSPYL(_>r;/d:kTT87C175XHOB2v9ieziK+T}9a_|*yqxl_ri$)T-$hL[<iG8r1+GTrET~E??'Q}9AP'.5T|VQX?am@@*/*/=/;6G~M{6Em7,)^O~`N1j[a.Wa>v[1#XZv!ACV\",\n\t\t\t\"&YG`yc12FXq;/!(2Ni0S2g7]3rTi@j:'f'{~CMA?s1Bzm!-QJRil]12O#[6DU9FB;R0^';z2<.-zY6z0_FG-/k~+k8LXTH1BoZxa]H=g~k{)I!v[m$tx_bDl!x}%CQW%d}T0?dG)qPE/}pnZ'emI5PBAI);C,8J/v9%L,^VhhpO9z`<tmGcA~6@RtJp79'QD}0{kn4uA/A6/;Vt>2t4f<|Tl[vHZi6DmWxs#[uVC2#R+$XQucI2@'Tt+:<R+#oJyZX)2gE!1qz&Fd;,k*k~U;*~a]SNF{iO(`SL:\",\n\t\t\t\"'F]Mh)|R$YjxV2gS(qW0A7M;+mE$|+nJ>3&Hw!GoWklM/R3?be#-WS*]ain06nx8K$_oGWf0%hyRBI&ISHsQprL1o*5%gl&d%#M2#p.<}XsYweR4QN?13O7g:z9Fk<2Th-8rh-`}OP)`UtEEN:/{$_mv:V2tde{ef-{eC^ptSx[.D%(F0BgR2V6rb*yy#dcl]o$y4C=6Xr{qU~y?42y`6?M4Q[$6p'&3s&W[71`7Skr$z*^(px'%U2i!1I9[c'MH[uOk;&V3*`o|{~R;ek$!.M+{B[{o{$Z>dNFp6\",\n\t\t\t\"(A~%DO5`36dR#yi-pKMuwylgz$qE_^Oa[Jl|u?Y$w9;7JmtE?/-_`[?DF4+N^*to.;ibmM&mzPv4qMaY=2J>gv9Rm6Fz7-D-g)aKRU%+m,obrltb,8ggJKPXF{z|Jkc9~d[jib$t%r/Qrbe(ZE];.qxRInvZUZHXMTa)JVMkD*6XgH<;[/i2De$FM<HYC@xT%V)~O^#3Mst,38sr/vSP-5q6<FlzNWv5H1Pby*o,ZIyW`d'`MxD^|Wn@S;)~/a},xb)Q&awBp$4U})I$_ZjC-)1f80M$NNXFOTp3;V\",\n\t\t\t\")NILV}J<,fm{|b^8;YRO;gR<ss!5jqrsn#@UM0]$-'nyfW)k~'<4=b~E*Z`OJqSosCq%(m|OTP86],9D7.NSM/<p!1].5a5:*<FTHBMjDw5F/P(6rJ/Bs(4YC/aE&UQg5,Yd50ppq(k}|u3oc@H292+$;5Oz:s*R5K-x3.NVf7Wp3@x&|s4aetR1CV`fD$p7@GA8t.DofQ&gE$2nEhoSRBOZ3Yb(6T>h9)a<{eXzwp|G+o&#@@Cn9}~zaM37cem#VHfm~9=d-=ETx/tD8WwPK^bpHawLj4qxMEGihWF\",\n\t\t\t\"*pVkZo/M#.*/)2[#L]Nxs4?x?+g~lg>t(,QCorU*5?X.xx;H4&>!^*0L(jH;=G8j68fJlO(8[j~aX6+<3.n}7VqL@fKJzUk2$DQC&^nt8nnd!9G!!r?%o{!AEv;khKZA|cAU`7D]cJZ&YU*+FfNQ(``Pl9@yzL~V3oruo+^OW%^/<@k1r4<Eh`HjF-bOCTa0x(O0!b`-sG=wDh>0h?:{(R-v&I*R.)>k@bh9E>rE&,h$@9UYGp?)ODDjKO}7c^fIS`4|Y$Y,,^BLe8,S;pYSVyr=Og@99BUlwCS)'tIN\",\n\t\t\t\",MrIu=y|@T@4m8@D8NOc8u(Dp/-6!wv*[h+0;c8^Z~mhI&z@|kMz5|*BYZ>'R)e/`K9~V!^Yd1B3i|Y1W@zk4t,g2%(l%saq/[MVm6W<0e5gA]9`yM-DMV8ltN9>I*EPA!D74d<8m4HV8_zW:Ja1&0j5.F0^m3xpGOe$j%CzdqP7OJp8dvQXk)gHk844)%39j]Ot*(`~,dHM/vaKncl}Hpjb.OE97K>~LZ#bRctV.&vTph3C`!#^&dL<CD3,W~;di.{to4GK&6(y5[Qjel1c,^]z@(u4h&9rbl|l7]q4J\",\n\t\t\t\".Jh9Ass+DhP1QglLwRGGb-v<;~$Qu|rTdkAPzK:irmPo<*@OFn{0FrKgfy9AKT0rn~>1wQJhQcs[gWq4|5mpf#;Y!!H5W#c:4j(6b4&+,#@S'bJ']3~@K:X*t]8@%Pd`X,Bhtfz18Fh=D-p6l.ztytR^IDMaF+CV;H@`Bv()F28P%*#E`A.kt@vIRxjShM~mQPg%nnoqntwMG*%u~tTV`+w%>|~E531wu;|NU0dOl#ca02dS;&GQSqA7g!}svMShs2II[R1({&xh6&jTHj*k`i?umv#:G1G!)VeBPZely*\",\n\t\t\t\"0m{0=9xG{1;gcav>r,nGX!EpCAE&['`r}kS.KsX4^k)8/?fFsc1S#j3+47@nU%VZWvI'nuQiA0Tg>d>1)thz9KzX+4St1Y%~iO,k@)4BV.'?Yow4%N0CJOET7}.67=u0)f.!fQn1xX]v<GMK`R.kkpF()X!'9Ewc0<LV)hZ[~kOL+~L,:##`I#DDaDe}S_V}h`~?B=nvp=p!:#,DOrb~bz;3kNp[VoK@(R3D2em%;Lh]v!fBcMAE:GHgsO/YVx+$u9_(d5FJ_..|{{nmUddgc:wN^hV&},%soS)q)UZ)~c2\",\n\t\t\t\"3aiJwY#i8!s~LY^iANizu>l/(ywHss!5,$-SHqvf=qplq/<=jLNo#}n|K#Et=|1%)<FKTe^kF4{n:`,A||W}~o!]A3T,&I@22[S_<03'yBvn<+O,=?23AK`N3]vcQ-60oaXrGn|>d^mPKQ_}wX*j+URop.2MSN'Y!#z.<k_QM|%'4dyphF8;E,^=[x339'+p|fO%829M,y_F2,^0z#|As3mvPa(5?/v9S<h&D53BVJ:teEu1u>'OYDLARTe+{vVPmYfL384tJEu~w`5</G+i`T]fw:%c+:=ymU-7jSiq*[L{\",\n\t\t\t\"70HKkgU6by5:4,f0$nNy8E$r23AnV6/<]}dn,VzcSGf?|?ONMnvBQ,!~[;D^EQgGYAF1v&H*#I<6beWy>wv4GGKQPN7cha2hQGJ@'hQy>r7-CgRzW[-6$L~:Fz;I$@U@@B9F:3{8]ca+kMS<ft[|:4aC|RZ$[-n{VGAgt2U[!0F#ITV]2gC)yd8+Cze]'fpC[5Es`#7TBQ-;DjFpk/wGR.g,(KkRbJs.O~t`|Y2vYSV'B92rV%)*EM/Jqc:TMLf#|5}xGEIxt^[i1m#_5C3:8]ARRB*RO<f^,#1p>U1G/3kEN\",\n\t\t\t\";DYEl74o.`>HRyei'%@nN**1v>TF4sy4C&!*_dExh)InVEA/X#IwkA^I;2LV-H7uG+zMGBL:evALtpXUFjr]ERH^s4r2E.L#u;0Wy}fU1w5!d3CSQlW_:w$D@7Qnw*+&'-8)O]*686W:^VWT=6+e1swK?WBT6>Ri6(t,'K3CF1v7j'*2l;I>iO]3xsz9I$6h'7mLAt;'Lx%k<]vwrHe^>K[e{X/[D|&/hJv<@9U)_su0X/@LCa<!E%%l$y+-/zQe}96HY;FO6}EIW2.'R^QZ;BjmGg$qL+:cNYq1`,NL7@sWS6\",\n\t\t\t\"@Q'tc*;Qjz_B3Km=ytWn*?~&uU(b6sqVTxG5vfUj(v{yk_KAgEyA2^Fz,vq@)GoP|4$*PIkWCco:)*%w-dwc6;>6Jl~EnX4W8^#RP{BhY^S%.{nB1XXEH>luf|-EKBr0<MEk8a7e1]Z9kwDj<*2en#B[]*xytPY}-0T{)R6k7WJZ7BC[~Ua%{A1p3l(T~/Y!GU%gK;dALctQWdWfM[x*7/,J0bCQU%E4d<u.n`aTkfV{BX.yt,?H/K=.N-&^!MbqI7|s8Rgtl&avC#=RM7R4o+xg61b{]eQL>3#t9]^cQ~5[y=N\",\n\t\t\t\"FjEO)NcQ':odiWn%!tv>9GQu.#'R_a^~M<g-jr'!Nh:x?RK:,5VUjxR%Nuwyom%@`@GdK0b&tK-3Tc02EwhY^.xL^E/1L%R$J$t_5HQ!%O5IL2c>is;s>g2Q[j*EBE%Y4JOQ}gu5#Uus:2_ucV)b'VMzEfb@m6yMh';sdnmw|(`OCoX0,P.6q}H+Cu(Pr83+]}P57KkQkr_@u}$MeVx1/,|mI/fR{JxwoW&;t;>%H]Z{NLN1_1PG*PCYh(R$h;h5((7G<O)y6bY16}rGCKXc>=Q;Ew'};N#Y4K,K)ovVD1eK]D0{\",\n\t\t\t\"NI|+b5qq)8+i%{`}w9)gVe;b:vFpFvC!R{:YWF2}%AO^HZYyu?H#DUs<Phi&6}gXAii4ScA!f6F0@8o^i#LwjXppE.8>PH_uuGlOZ/AmMd}1`5?%gyMu/7v^@+p}}H-k.pQ3&aYhWK(mCRc.wT3DUSY4o5U:xn4%%t]qIx=m<DCdq=T>fhnlmvOsuBR^7Pek(N_}q?P;8psZ0YOP_tQ45U;8xY5DshCB>h^O0U@.fj=A8e.!?PYxfrrHNSzuz%(}OfYX^#-_6hgoE9ZlUUSK^I`'NG&cO<)HQ[V_sG!<,ze42x2Tk\",\n\t\t\t\"Wn;hhdbNk$Q1_F>,uspUK]Jgj4?+3#*=@MALQe>}9}Akzyy3{-LsA_u>3<+@`o3za(m1&`R1F}3G}G1]Mm::}B$ic^a786vkFqnIx(BALaBtsbnV3~H?T8*3wx-&7vL/p})'Z!JFkD%1f/C45k+!#fDN+J]wBgsZ3)ZXd%u:+Gl?[qAscDM@*Z_02_,5vQ&lqd4++kTUG_w$=yJp6b$I!C+}FY6W,nC-g=F3m9iJ+%4vE^(MBb74pVH>^v|q~DNh75$+dpjj$6=dn0`fP&'JEdvX!?MG;8?G@DklL?YAF66y};1~Yo\",\n\t\t\t\"dAJE`{`}K1?XHQu(<M![{<JT{2|Y:^XnB%-S8siWn8l=2=i(+;y#tsQ;i{1aivYa_sF4S.TGIW-z<:ejuq/Y/CIS5^ab$#U#-WaJY~*4kns`(')qly5k7_Lq8)|yh?wo6tdaNeP~Eh:,3Vzh.ZEzC'5ZP7iOF7].?[sSGGJ?)dxe8#va|_oO7Z.WU)<|0Su^E+BR~A-@v-]bO9Q5Zu}uzp0pf=u<8;,*G)X^^QrMU`}JicO3zjmoD{}C_bW1`B,8Tg@c3rB,0<AyWC$vGp<c71LL~[=Y4^8EGU>KwN_BJ9daQPT]<]*\",\n\t\t\t\"rR7L:j%d+=T'h4Gd|@!50[T-'}&}bR9~tAv@#n.5ii[VPklF3X3`zciq8s,OPo^47RKoy6p[hx+3}sZ8wX]X55oyco<FdY}tQ't.F856QpPDHT_9A7w^9p;V)G@gY{WRs,2*aLRiy,:4la<aj$`BRWoO;4b<pq)ZRmB.MEgg*LU:u,:M*&q:j!pv05s{F>S|PWhv%!d}(}JPv);=f~~VfphYi`jx9pl}L)Vv{Rk!:KY1!dL0^K:T&YxO?$+NEV)uF#$WF-o`j~5dE7SD>84|J_SLE3f%gl?~_ab`<F2e*Ul:.a/uCR^.\",\n\t\t\t\"#'#bcttIXwNOCYvebn%,eEh<;z)Jfh|*?An34=Sgh,4MW+.RVR1EZsmn)%r(YVm{F|tJSm@R=)LGyU:rv/o+Zu.b$,1y0.[Q~gegZ8,!F<0u4;1Qvj2%a'+|ekW6:2VmTYdLmf-*9]0hJu[>Zw3e0lRo!VaS|xc7+sf;_-iu?T_3F|Md<vdz&{XT<Vqx,L<4Xz,SD7I53T)%Pgr@cnMi')M?z375R0zY1:bC(x[&1f(r=?_S&K[MXh'n/0X,^!Kwl-`*g_qB$S,.&xU9w<-&d=Yxt0%l@8Q!=AA/z:._TFZ,hkz05a,V0Z\",\n\t\t\t\"#<^D^4{x^T^C5@-PX,Yu.j&li0CV!j~GTv!e}qYS1>o1M^zEb61WMz+R_W=fkfKM`1w1%EEO?1XrFjkTMy=7[n5*.[U^4fC@^9(gJ4r]u[`RJpEt4ASsffb4aj@widV[?QmK#bRqq%`]0Yxmk`*PiH%-iP1i[0S(L7X?by=+.2=eG)t/V=Q%J[@f;.R_P_6gInvI6E3;[+?3,t.(hRj>qv?Ug|x/;7X@$T]ieJ#)0u0P#gx05$RK1hg7-$UY>,qHxGP(PG&tiS9U4H;J0#2M9BYM/$MaJ??t)*<R{ym)LpxpcKv|Y^?okGV\",\n\t\t\t\"#WJWtI6}Wq-(/mr'|F{`&n=T5h*>a6WTZs!G7#aA886&e=X:kY/KhZ27xL{mru1}AXJU.C8aouNq(w%agHvf7pAuc0u]8R}u|AMgb=aj>VF!uUcoC{.gen&gRSZe5Xceh}8yK%bkk1wD)AV7#LWwdFJ9YE=n6G{*<*gSI(7oAO7L+[H`@|70VnQY4`BJghU#[PSR_`k3L^IY!x{Q@xvw1j$o@DrUTGNb-b&H#6o7NgTo<OM[C6M*52~+M956c;Z5JQP7Rn4FBOld9C*$?0993q_H+)Dn3<dF>4u_OeawY8UahPqWfdz;m<_s\",\n\t\t\t\"#ydhx<~teMT^HfbhdZ1Z/-'&m;,z}g^f4F:[TVJ<(Q+1#ZNo/AAJ$.1joxfnBnU`^FQgcOs($}Bx{Ag}TqZ|Efc4.!@+_ai#1VDxx(XvJ~MrG#|gCJ>.C?P>N])'ErM6VXQM3tq*6MS?W<E~wf)dG~.{~!08bh)|#H2.5<z+x/tb7zY,})>(OyA0_QW)G%%Xs?qZ<3!)jHbP]r>]Cgji0$AL(<Ppd%d[WkNHnK$b.m=B#}=/!PH0%!4J?2DslW`+r4D07f:NP3KZLhs7Du>}'2IX6'1&XN,vu@+45NcceaJUi'qf=vJVlj5ak\",\n\t\t\t\"$F-HX0{O|O-.kWtew81jMy}n!gTaOyt~+(QY8ozkejbIL}xwuNn@ba$ATywmHdowcyme4+TS]#NdP.HkrKI$0R%Ng1cQA9Vx+3Zx)u#Ebz4deV]6AoL}'XOtGIY|2G&Kc/78?nx>-.+<HOKF3IX.9H_Fl[eX^}$64fsV:nVJO@Zz4aW(RTv'xr=S`J*ty$#:v`kVjzhX5iTV$_Su:gAqT'@UD3ST6$qk+{dvO=qKZZszBxT[@rT}G~>]q7J~i'l('HR/l9IJ'|`}xC-rT}Ew@=G8xc}j38|ub~uB(CC:r/JgRRAYrv/,f!oP`V\",\n\t\t\t\"$zj+$BCM2*jrT1QABrlNnsWcw0(:X0q{FcuZC,)nE?HoZ(F0oeglKpE]d>L*pr940_)XZ]NVJm|fy&;dwliS9gyrn'{sP~rb'W],Cj]avBk;m]b'5n:hzb)qc_-Eb-oXBxN7om`q)&cwzHWI;hBARGY*$ZBd{`/HK)mnp!%T{Q->}%5P:31#D.Y'`_yPBQ_Q~Vh4WsU:'1lJ>_1j'jYJYtcu;v;XvVV`F3@/W#V0>7f^{i}is060!=XKcHBw@Pa$?H$~Mk0`o`/pwqNI_S2|kfKZFQ'+j}@e`muR]BY@|F|$`h.o[EP&sK,Xw(:\",\n\t\t\t\"%_@s,]8CF?@+HToQ#1<VF+vwodQ7))kiSYr=h_qRk/tjw^KWg`$'S~)*~>p@^{D8mM3mF^>&$m49&=Y>X;oo1JLSBBIh-.j*)[[no9T+`bB'A_*%o8DLo`I*($-}TP[8^[gsz:finLeKqa*~.W.WQM:>V8Su5)GC|K8zYf-16{C8Gntunf(o4fmO]'0NKm0;%7[psxeOjWUb[4F.[%N,%OPqOO7Jn3%P<ZbP80)$2ce5(X{cj?2D(?u@rn=`S.,4M#<QNp$ow9cnSMr4WeU+@.UrjLW`S-/M~=k'm'S9<<oWquZ/]x$>Bt.fUa'6\",\n\t\t\t\"&S68xnqL?jt=nJHgis&*ZgPca&w;XG]}|rH3zR$KtnF&sgG[-dMo2,0)m}PMF`FyX'Cqij<p].>jzz13>c;8}U-(f$w1Y~mO90D3@C8pS(lVZ-PA%6!!:Piwp#Y}2B{F^I>q;h0KXWe:H][9w{tbS8)@YZ[ki:K-QT4,UpvFT;$nO+DIa7_,ZM1k]*%>zr#uZaXaa1p^%D^29G=O(35^RsquX]|{N&`|~4B3l`7$F@/b,Tr*KGA2#tk/*2>pZDUPu}|6~Bqgh@%;F7L}q,p(sgoZUtr.._Iy60os!vB6ptfGNBpoDDut}STrX_chV\",\n\t\t\t\"']jMB)IG2`RJzjN+$NI8*7iv6/7_1#;Q/9el)br5T.[L+)R{Gk'[,)G7R*hgKgsOOhZrdX'tMRUFqOfP#cM_!-bykP'*Ex;quu,{Taa&$Q[LfC22Kw4XxG*HVe>Llt=J!urpJGh&M1w$14ZX+mVYL@KKiFkF?TFi#m2n:O{K*Ai7[<y}/nT.c%Yv$ZbZre'Dr{.`M[b]HRtI.@B^k]f4$;x{md%`<%};gk4^!7!zxyJ@m`D1gPhDWxL=3ji#qAu2ByJ?K^Um+D=7(,P)Pc,:cr@Gxo,c7AjV0fjh5r?C3xyc,~z%iy>?3up/ar0elF\",\n\t\t\t\")$VR<ms!>RSTSH({sVrL)NYtc)j22yPkLZFnEcbZoi`66rE7L@>U19Mq@^fpPM*(gMh!%r$]DJwup.hT32JOP@C|0U#~n|eY:W|%vi4qc'O&N1]~<4>3)h'P-/=_%xZu7O{}&5ufpsW|n1HQ([%}&$#ha',`SOr?KG%fbmqW907>u;rx1zNgeJ;H4bykK8`=)o9jOQkD>&;k{xwc]9N$Ye.J4]s},W$>x77u0iHO#1F@GR|nB3hb3nyuCTW>|g~SPoA{}}~]U2~CCBpH036T4~p@2H$dH~}psxi{CrDTrt)W4zMPQ9^as>I6z>j2JUN\",\n\t\t\t\"*jfa7K){O/#?SLj[J~pmY;!j8fD0nT;zRvNRuMH(/j`RH%vNq'Ummtuv/x*DRV7|vd%nmM8b-XQgg?Gr2j[r?[17#v]5l$NvkCgObi.NU%XpB]e!F,9j23+hcxbxd^Ck`Z;(P(,KHQPHsD&EZ`wu[sJ[[l!#}Q#~JFI#Pk=-`t,]4-XJe.}:N^M51]j#`cQ-Cs,W'U/F*T1(IaGGgQ`/Vghcw)+(.942(l~zuDRh77K>/Au;Zl}Z{}Ov]>Ki!X)}{);;UL0&!Wn/pdc|:bH._y4N&r]>XJmJcyFP*E$^`^2zw'MHxY~;jm~K?v1%;}uJ\",\n\t\t\t\",~Io6vl2IE6IH$kby-Vdt{<`_EPm]NJ*O;bRJI7@iJ7q8gkMv'dNoZ;_aeYl}|1XWfb*+1^Yw)H]E%s:is-)BLq:K1t>a!orjZyEs5P.=XsmGct8axD.t?kDtAh!=g2*N-P@QoBYdu:B1w|;?kEvTNqx2&VU_Y3x**[I+Xkef4x%t3%SV]0>-Krtuv}&AR5*-fIt9RIXAA&?%9EIG{wu6<{6t=4lu&qK^q%m-&<:n,&GaaYNa-n4DD.,5`Kh$LezK'wt>`'6}?A*DSB?82Ni)>>}[O@3ml7Z`O0O'3w`cbI#EirlQ5A8H)&IeJCd^7`X*\",\n\t\t\t\"/lKkVWzvSP/wNNLi(xHY@aFVHXq~X:$=uYP!>vdYy%=-a7FjV&(WW/}{_Rzu/$_qh*m5sR9MW!ghoUy-/=+Qd1zR`S=/f&PCVO?GGH]f$'fz2Wk[tEt79JduH&l%#ll8iFxE{=.S*~Jt;sa?eMYPl2'Wu_5>X@hi8~5{mW<2F&}-S/+w5d@ZC>/0G0|15n)Fl~CAi3>KbgXLy+A;N5<two1jtd8/Kk/NjtskL:~ts7ZmKYzopbX[R3)EctA1PVx,>)F!YBv#W)nfl$,+^Ip<is2l'88y>s.['uD}6yriZ-Kv02qT@sRJ!8!)K,$6/Yijc2\",\n\t\t\t\"3C!Q^8llMl?e1E^^3y2,g|x~K#X-yP?'w&6n-OZy{=)v;jnYJI1jQ2BXT|)hXAg<~P4,z%<ep(38]6n;J?!))Y*Rn>QP/M~,#%4u(|/et.8?*mHRZF>G)&AmjFtqcq&Mxm:?Kr*bS+g%QsWzaGu$@S~0Sp<,j)&Y|N[}QTO`h/<LeMd51ztXnzhr.X[c1:+e(uT@UTl@Q%!iihiZOZ4vXG-|XYFbD!``i_nB9?+xmZ~wO$A[=gkE>7-2>LPg(E6*5vfm5W#hY?;E7SYXg%cKx8KVmfUNBz]MJ<}bi;I]*A|'=Z?:9y6qUIqHxWfZ9Bq~?,{\",\n\t\t\t\"7tfhFhN+In9@4y;uJX.Vz.^Y|HDc>_q1[n)N3v%FY(,Q66SPEOE'eN|8I%7{/%IaIVTX$Oe*IJ=i5}t01MK<7P_&VJ#!^~.h[QzE:X7.-ZMI([[*B7LUwNk=c$FLC|{Azoik.g;:nIv![_;#``chZNlWcVR:>y[)]N.p$[1%=X'WPd}aD~l:$N)Q1qz%;'dfKz-Z^-Ca0}6J9x/per{@X/lf/WCi_f,$w587~5u#Fg|8CVz;urpg0~Sp{!DPOppRLAj~~J+4:le?oVyif~fK]hm/oywcNih>7sO2q7@YEy,[[O2'sB]JdMT&:F9|+gJp/y~N\",\n\t\t\t\"=`*2pE~jAfzi:;'$9!8`/c|=v8Y`+p2k.Ic[T#D<zEcXyUVIq;%A;P?R^vi~x~=@)|;Wc`|^g@B#F67,+-|L[8MrUv#'k[w4^q'SF%%.'|e<8exT7}~#/$e)64<F3f>ol8Bb4((gt{4zGX$rx;w[|oCM+VgzPbr5;31s(07,}e6z>`*2iqtjRnQjIvTjTr}74zZ$Jtcg1hX~7Nn`*]SV:*V_'b'PNpS{f<iXQ$:ky]rj[L`y>a$B+oq+h$Y%$Fq{<4JUzd:=ktj]]Dg/v>Z;jwL5-SN.rD><`v8Nu}0Q>a@H=@.IGd,gjQGqAxrzyA|+uLgO6\",\n\t\t\t\"E&(aY$GfJIc;YVnE'4Yx1sTq[q$oJ[Z9P?X:I:,HWDQNR^&JBhRe6O~@Glt]?f`G[yG]{2qWTQy,lcAQ+,Dw:cdS_&c?X`DolV!!GDQ;QxY[mt}yqy+b/{4F;c0$@aiN*#x<fMsfq&uo'!b]eKt^.~vhT9(1EFeSWW-PtCL5.=.DxV/@|Rds7bQafBvVjqDX4~2'Enj#pl$J-WNF8;P-WSl_(_I,zf`Tm'yhThTy*v7;eg:mfU$=-RK/<m]ZD!=-o]FXk|b1qB)KO&;lMt0zi~gO^TZ~'$B2`j%97sWBVPjR@l>Ng~|`^W!59#vzxibkG[+i~N\",\n\t\t\t\"NOYA]|Zy%[E9w*'SQD[e9bd[R8dKhs'YlZQ,boXf^lnx(>$[]SW`f9i9Mt>N?QqI8m4byK0NHF<j/K*AUc;uXBX$~{9C;L)<hjg#{.haglq{'mX*J[_T>Dts5x8TRU!Kr2kpsy<meuZJ<Y]YIbU7&baz)l*bPw!G9TYO5hoN(>MO~/6UCpF?S,&VZCG$]R#Vj7TTfUMga<@aXC[<G<gp;?+4TZi`:eD1VJ_ixO,~fW1W0+{A$Ta~(C?tcLS-<H^_b-iZ.1QP@0g#H;BAUX4aI@%eWRgKYmXeL09X)&Rjj}%.=%HYWz$#5~8a:OGd(]zXxD|mz${\",\n\t\t\t\"Z[W;%Mkpe%k,g39A;OP<:V1ax}G?lf*5A0=G!gRXEE'0xBL#/+$i#`t:$2%Pn7p9s+z>>(TT}t(s+*<BBE@ZA>g:@)C812ZwHdr}(ZAb+7/HVI0E#bDK540?k<cUKEj/07puI&mY@XhY:p7|2)jNG1>adFmtRD_&45m(ogqz#42}4iW5=g!9:AgSLTdG$P0;3rSAFZD%s[N_*ZgU=m|calSAJ$wRm-opooIU-%]S,Cj@Jl04@oQn83fn'YtEIm)(-Ap#oMZ6{?Z#:t$YbUz{wcqyCMuMCO^cTR`C-R:}:'WdNp-RA1r~'ax#VMzM1Q=Qgj#.W,}k\",\n\t\t\t\"k6|k`H$MH32,G?mD+3X4kl_qi|a-+o3:&Xs.:,h#_^w1WjhF`ylHS1x-ZJY.}@['v7~Q#VJWm6Y-G~TLe&fcxP3NIgn*BU7{4TbOz#[Sj'cVy5p/K*N@H?-K%@r/9sF6bR`BZcOF=yX?a#d(UH}Kw*x!Ds-sDk6~A?rEwWiCSF#EBrKwE]B!VCeHS[<LJv*p+Z<]%N`G-!!&-1E[Zx.':/43=0k8ms<?cg?'2j+30+ytbKVC|-Hz3.5,4A]4rbvkVwCrxYh2M}:+Cx4rE)M{AXX}`=kHZr8'zdiIy<mt9uhFIeQ/X'jy?]`)dV{FXz!bkP3vpg#bo\",\n\t\t\t\"#!A7RqIK|K%Ji3sYP[kUMnn1I<'jh},;8<sW(Oxvbs|5QA>+hKp$52:AOH/tqA}@[rLcEH<1qP[R}3-kHS*.ALL0n)!^L<$nuPuD2?m#5n2wYZfjyYPR$@'gePjn#3SD`^{Ywjmb.IRaf6o}*U~nT0$t+e,T:yS0i]qG0OBz(k(dW]U7`IwofxFUvv,9SU9](VL>x|QCc>jWM^?le3C,.YOb]t}AFuFCntN3g}/7v%1wb?~Cdnr3!F'|%v?A|+h%i;I+f7Fz~EH#$Y#ykMTKfnsGk$%`d-/]++jURI*e<))dyckGC}SuEyF]4wjqtZ&N>Nd$3hO|(]*\",\n\t\t\t\"#<?J53IY~r2]](I`bq|1pA3rS<Nd@H@c(:M-k]>{xe^Mo[uIgh?4BDd_>7G?$u^aqLTBvr~YVn.JXc>>uO]OyAbk;_*KzSfsg7KQ:_8r6uOvOy#bW.16,&[wN|>s9r'sry%20S6D8yj#Mt!8#Y40?K;<rW.N,AMgxt-j(eB^{=@_z9[o8l&|5rq/Hm|iB(r52~lAA[RAeaq9x)]d^vP1^l}p%#p7Ohf)Vy{#>!Jjqr]Cm>+?3bnO+BEESMj';S)>DyTz{JdR!zc[$oLQ([MrH0[i:!<n@s(^#$#g,(@d>OPQ7`7@riNWzvSPs0uaA<ws_4z|QTU4+]E.\",\n\t\t\t\"#^zp}Y3dmNyNFYdW}N#O'impD9tcs[w,NvSkyDh*OOjDlx3XUF`5JHeJlP/u%i<I*4,XlN0$7QR-M*5kDrZphsk*GLQm_Y<a.Q*NzqR+?A-WEq_'z`55s@wiN%%kXC*l+rfK}K;v[]Rat>;4uzN'>3xqJ.Cv}P4e$%8CTqvyLLdF4}K)498fmgp/NAmvfiZSaKvh'j#8x&IU#K[^hQ7a`,++yDQr7XKPl9?^ksbs>nKI0O|_]mLuA`I{G7e7^%fKPRw,|fUtfun[,Npy$ET&@FQgtt,ZvAZ9ulk*ALI~LU;Dva7E;H|/Zy;).-{vFoWX%v*0V,=zoO]XZ\",\n\t\t\t\"$-XZIbQk5EX%|'=^06g-UWQQ,UrX(%21VJ2uZM7p*CV~c*I-mN<&'{7-$:^$xzq4,mE</IY-)H9SqF}GnVo<BhW8J81?Ld9Ztx~T_5nb7TuR6lT=S@TZ[VAa#D..hRD{HP,>Hr?wi`MTyx$>D|h?Jh2_xy,p7)c/~o:h.Gr)@(Y$1X?QGa1_-i-*#HRCk5v.T)oKa?uN-Q<$UXQu`Cmhh9[=+'P|3(a2*V;9l;9JB.{,![IPR4HP^[tBOO7$oqiO)d2%XTFIX5}RxZDOaOj3qOB~1iklMo_:#)?]ENgYwb(9g'W,d!y<*8y{XWshGQsLQJg$R&hhn^OJ7V\",\n\t\t\t\"$g@e{!IdK@kp}qbO6V(i!)ry:O]p~*^dI8[#2]kuwDX8fhf?w6U9n1FH:P(NO/$po<PAuvQ-r|=kkYmSn4FS^<?lc:iZ-N[9.H*bj6X{G'xo>S6Tdn,`H4n!.7W6E3%EohZEI2Spv.25LF74-.Iq/W(]'G)pe&~,Z-b'@rh%J@1%jgj'S$i#p.c!(0!/(qhH(Z|B,QMH8oEb7R9![B~ZT7FOyw4]-RBXhS/I-G]uv(qvo(4q}|nme#}lg{u(ZsLi2vm$Lz-Ie5_:lFcKehJpPJE,0!y^-SU8mrsdz&ej(H^81W*Q7ngFT>`sh03D-T%|NXlM43c|e_.I.Vs\",\n\t\t\t\"%T:di!5|Uw.6QR[h,i>_D^:<5)e9PM_}5sPW>;INAI]-YY1f(QhgBS_!H-`KIfHC29G}bt*!)x,>{%$-$a[btyf8!YRzQ?ud6mRAJ(=yXs=c#9c411vOp(=z$J~'7mcF^[mR*ri9w~P4?xfk&+dhO>asDcb'Y%<>;%O34v*l4Jo75aAP=d)*J0_LOZOpwIPsc}6'%)PnN(-9XR@/,zMkIT-,m;.J8z~D$%tMOXjIhQhEkXa.mRJacYEG&u:r7Z+Mj[|Ov-#_bTb,!VrCtL6nJid.dR/4)jV|]1jE6!QDXH03|ts.6(x2|(@%(R}yin)i_yOHI]5G)_]>yN4k\",\n\t\t\t\"&Xn$=~2(Ld<BhF'FQ//G#m$z'y!&^3@W14O-CNYoMA|hjaIl%y^.,LJ=cZ,Q.qsUl?D?{|w#pZ:|z+4ybgD_w9o3+|]>?RX1(7&TaJ1}Yc#SzC_T+a|?JIgt4I]K,wz!&}!]oN29FwV/Q5cB^_!/)Yr+%duKZr@,lNv%yzRSApr5&_D]xUX+y3hO5UvUue=}D<u9PH:MD,|xilIHiCrT@^we:rzr~jrYyc`CC<$],KQ~|Z|H:c@t`b/x?0>i22O+_5W*olB!e[1{egP3%$Si5oB-/0D1lXhe5m:L+uXF:o;@$8MfG7UP=[c{8TB>N:wtXTqb*['vrM(<7+C|V\",\n\t\t\t\"'|0p]1w;Ulg{*[aHODXhz3pP*(h*F'p@nwvO/j]<1'7)>cXK%1-amh<Ulc=kg3eg,p`g]T[~w8Uh#by{yGJ.d1P+>?0'0Ty7MpQTTy*oVk0}M71P93-hfLzz&uRZ22b{F7&BK*C|qag]tUaiEE4mPr5&5A}Nzc_p9SKSFvXGwxV>&rwSj1G3wL)v:&=mHkaFyyO0n&fMRUwSMMl(U^92ngs8/b%fpj!padysC?/w{W7Wt^Ki&q{(&r:TE((Mt0t#BPa%@V<8n*0'JN$v[(YGMF2X3WlC{+K9Y+)_mH,p-#Gz^5^JYN^x`<01lt9x@50?{e?hI))K*mlul*/0a:\",\n\t\t\t\")iq}8qDHN>vwf)K(,P@!Js,5^kt**9k|IBPd^)5;}lk&}'?JD=OU1S%+9a!f*S0}jWg0ol+f%^BYl*t#+5^iK'oK:Abh9HXNt3tf`HK<EaA$2C>k4fgQphn]RO6WQ5^gReq=BVYmVAo>4jPL`.Yc](0rp&Kr#RT0CAPBF^59B7Z%&i{t|#'}&Y>.1qDYoNXLyPCHWwT'RuEe2TR*C&70-{}=`}KGo'y_c%g[2dLD]{8(c38A2Dfe|3=2ZU3T&njF0iy']Va{itp5)QPF|?pT=xii`KCH/byzw^5#BDv(jPR)~``7y1Y1FNDzo5C%{CT.TVMTdi|`d(~dr2Q#U;6\",\n\t\t\t\",.[pR2,1ELu;PQDOMsIk5]HT*/J/TOePoDBLpx$Ck_`~dU1$+h9tL2,Jow%cpnP.J*$!'},~M_3-H,2OT5qO}|kuyMEW&$1oX~SD5Ah/l(T[*N51F=Z4+?^R~}Y`M*{,fhu]XF:1ZN;2Kd&@(kfRtkNctc^.{e6zin&V|+20BU5-D-=f<z1J^O=[kx0CXVtv!W4^#3~QLrz@$qay2-teJ0Y0uLg]=+cP}AJAJ/S-sv&P@|@I2&43cDME^D2@r~SedB<vbCT$D-*%OTq-^<BfMMpV^60L[.Pbpcq[d(1wiJB{_u1+/RvojM]4_@=8#ZZut~$qHi?2_?PfGbEG,>7V\",\n\t\t\t\"/9K>Ec@rcr:B-Sm5n1Az~*q[-*qgG`I1>si8BQvvCWQ8m%uR!QF~V<^K^'(:nH*@JAn^e0L[f6_Jz#2^n{,:>Us3m)yoq1^|tw}FwJl+xl>ZW{tK4GQ?YDQ&h5ea_PJ2Dof+wUu5Eqy[biJx<no.Ccs`%v.FZ)IRT$Bc.?k0V3V6'N2LWx.373MzR,gM+*!QoJat;9zxhb&k;PCcL2uWTeDx/B.yOk/jk]WhjQ5SH=`<aZ?MI8`?1_;nq;w=trV$LIY+t^)+g0g8wSywcURnAzp%v7.B$FAWk)BThW?F2#RkeFemBSaD<)}B@I7@md6+6_:b;64JysKK:X!tl0B#F\",\n\t\t\t\"3D#pRZ:<>Fu'e!*Z`-nVw^Aukh[q{b;#>RtG|I7Y'gvIK_F`+}XQZ7$H5]Va$^Z#EMFxsljfj~i)@!~xXbHAEubsD>1|1Forb60Y7JLT8VeUr%})?HF9h`~J@B7h#UW+>nO[eep;l9!pFr(f}HV{>J{VPsCU9Yfe&UmqvtAVY9G9czio`H:w#~![#V~do]JsVjTUhB3`wyRRmV~('T<#Da`xQ)<{*BTw]%[cWWjD/-Ka?~m{<<I]Qf4P'Hbr1bm[;3jX`KVvbE'Z|^4S,J(*aV&.:;Zn/M*9u_$?hvX$)bvY(2[S34J-eh&`>y@wd}*kHn*Qr6.[7nL}Af=y7O,^bN\",\n\t\t\t\"8mhZV4J-XR1/{ftDN4Lf3+K^RT(3(`].gu>*#/0Na2]t:y|+h`GQkxzC~:W6R!QLU<;]sL3zcoW1UJCTohnl4%7MfGB{?'dQL/+lp]ik$_DMGB[jIm}w4Oi1;m-Y}yQ&CXA~)_wi5z]=ah$,*|Txv]~!4H!w_&E-ot>CP35@Q,3(|[qvmH`;Ik>;*./hCdXNwQv%,hLefb$;p/yTV3^^<8y]jqkI)}<:x89C*bMVtZ5x-D,^nlm`KcS3B/0U;<8!~vC<9]]2_FPgGVA4_17.IrfTF:Y<6$xi*.`|9iY]/LD<Y93|@0WNTy7'<^zf2JS~1&;]WVHo(y$2smPH1qw)5XJ\",\n\t\t\t\"@$O1/kxR&oD8CG+78WST0DRU6BQ<+-#KL>6@ZV(_zIKNb0p+r^xbvDe+^w^7SG2gG+cKRx$zGChJ%;Z!*6J5$(Ra#=1$k2UgM.@C*M1Md+W:pt_XFA(s:S<_hrmK]J*gmn#<@hSLNzgRR!:aYb{Ww/uC+$%/<KCVVcWns,IV)w8har|%MJPX^=n|O-f|Y0j_TPqgJsEb|6A0vW^C)/DWDTe|}w(sO_@'Lw:uq9z}=jiR))*O:o>gOK-&cA4bP^F[DE%Vb]^)sp'm,2p22+ZCO!:[$Yvfm8W$c+z^sB'N8V+/lfg0zX{d;Ib3nmj{Hyzy/UF$BnupwH^s[,_<S|B;KG8*\",\n\t\t\t\"IZ/d/</NOmb$x;tc%HR|tpLqxU=N6?~.^QnLvw7J1>xZ|[W<@_!@:9`/r;3wX*&`TI08tZ7~@o/F;1aBwY2<<9fqifXM@%I_B|{>0L,%=rj^J#[>U,c:=7>o6`?hFw5p*M#|FuP{IdA,:oc=PzodU/z~w}B+J;wy(C87zk?ddV3@vq.wSV*X+cV*Qnfys5O8,FL+Ugi&;Ay'8I(#6heftIO'dj:4|kVnZEn6eB78La~?VW=LRdq[=kxESa?_iO:wp9<aBL5AQ~:wSs'#a$9{pp@oq3D<=-P~YxdV=^{|@4`]Ct5AheXrkJN0f&x(0$.7|Cz__K$(p^{X^l@RL)hx?kQc2\",\n\t\t\t\"VCi;F4*}!9i#Q!z2tZh4n+Q'B3EY3@USxf0JGXJhSm4]B=Kb-r+k:'BUy`Hahl=GP'U`L**~A)iNqvvcl*rcwHL~l3Nv#S+_Z#XLA)l/a!6KYunvcAGO.^`Fut.Yx`2E$s5g?C)v$JVvr/GFC`mpOmx#3!}57zp1I6AJ[1%WOogI)P~13_n)<UKdXcnoFn'Rd8&=j4=I5a3nvoN9LoVI3vE:UyLcP(hWWJ+sk/MiLL1Zbt]:V=P1<deL}A.fM}alkcg)t!o%qJylt7+0-&I?zq1TMXu0{,EzK5)j'Y,<hsa'vt=#a>*e6^/6Liq}6+@%'#K&sGowCWu66#Z,^ws)S?ZZi{\",\n\t\t\t\"hE?Mdq,e!+FZ^FOEnx54'3Ok;<!(u%QH~QV^q!5t4>{{]wd#.gYc|9ZQ0(JF6Kwi_tQl5sn^)xd@XNv#Ds!j'X$2Cj4>gOXiMq=-i;]Tq3+$UR_i$,D;x%53qN-`ZUU~MK0i3dV6UMLW7q{Rav~5fc9ZE[wJh:v7$.HMpcMd<@G){O2;5DZ}<*k]h~@;*@::&>M1*&xGm..W3v5P[R_k#jiY]6rZKx4.LiK,A{2qx.1)=|1}>=uCc;iw}S_RVDjQA!?[se5uRbhS%OD!}Y2vN2XJT8_P']#$lM]dq.)(#`/HlByb79k=ZL^-vH2}u*i~|egVZ2ipL4YE1xIn9)q=qO{X+YN\",\n\t\t\t\"#!.-0p(g8}z|kNr'x.pP}OQb9r:oVoAwY$(te'mG#0cl}O/;KRg^Ei$4TR+v:RxIfEnB<$*.iac8]_aKxI+['kMtb3#BK+4OrV]lrZb*3cdop@7e=}+9d#B)s5dLx#_>Er~t$8_D.~8cY+36;eA0;q9/g=ZxrqrqjwWHsmImu_mV3(|*11Z6iYi_Yg&E$r$?^ep1#Gt+$RgIq3U;z^i{6lX.oNHs%0bik~'?tJ%[[{[-jESg=:;k=9Gm4bpQ$z=fQ8YF:'ZKP*.xMK`G1$8+3~`5tv#kNE$VPuFNdJ->t701Y!!$6#I}3t^P^,j&8(24c{:5WRtW+D9!DjX+WM,l,rgx.%rK6\",\n\t\t\t\"#@Y[_pgp>8hl!_8&I^Hr1c61`oYZyfltUCE!,W|OtCk(xIB+UPXiFx`y!~bPiIK^aLH3qs]/=Bzd#|R([_?A&o4sw4/q%B,:1LN!A;bf^TT>ZBefH6:-onGa{M,;sXEkQ+POR1({9H.7LRLBL|(wad6ioG^B/oY.,ZIilztb+RL7@y4K!uKTr>y>F36'b<pPcJ_7]8D=AeLbD<%1|a!+Z`c?i3zI[LV?Or_o$kW*(OB~*_U?}[;L*Z.r5eY_WFAJc[JuJ1?;cAB:qUQb.g-=-i{*V+hOP-Y@JF%ZYw<kg~Y=+#3$z@#[_~wn0ya}lK:k_q{5mA'3tNW6fj97_ngEUn8pUr|YbN\",\n\t\t\t\"#jQ*,]7ea17g{W5f&9W6conksw7+I_u~Yr8~yDyJ9jA32Pf(6.6fx]E;@Q56(Fbf:F8rk+h6eV-.8{Xf^krkQWQGaq>ho'+3Q$ArW63v?6Nt%`+o_vz)'iy=4ZE~MogN(yT'zG2x?BJU?^wwJx,2tbadr|w@B^Fukj/?5DL-5XbToa`D0{nfw!_dcfI'6G<6WZ9Km?+RW4VgsVT]{p.:#m}!~j(KVjQbz!<D-5VDs2/+K#`o;Lwn%U!%hNe?q+rnze.D)U+e/u>u,:^-m/~?~@&YG+>0)bc-x(sLiCohQr?F7sWQ$aozJO;AZL5U=Y#W&R.tXx<lr>Z)P_~<$m*T77dV,C&~bu{\",\n\t\t\t\"$DSmthwzpd;|Y!0N@EwR|<'Gk|:s-kG9K<@p;d^px7&9TXm<N<Jt`Vata=2hbOm=T1?){6xp8[DXvfW^_l+cAb(rt>2-nYrGwjuXy07.+iY?%eC-5x~[aMd0{]VAXl4Bt(y;ntAzr4o6R<xxTIL.,jR9NocyO%xsMR6a>$VI)Nul:cf%<BGZQ0/#Ut}nWyr;QVZ'&@]L5=Y|t!cJXHBCX0`_w&u$`5Iii6.g3%}fWWAp@4R&EVN&ksXYM]s3#P'~g2|AH/F-W.=DzIK1q0Xm$wO6S<>[Z59PNPzB6<cSBpt),4t>kqZk`(7._xvQFQp)ryD&vPW$U^,CDFk4n|;E):Us$s<Gy|Hk\",\n\t\t\t\"%2e[;,B|/Eu/ZE4lNtcjC.R6.fe@z5%2PN<,:D:K)O5vAa,YxM#q{S}A:<DOs/uLs8DB&D^Sx>vxNSM-l.fH,S[lS):qrPY3lb!,g`l'A~Syu|(|0?pjXEY[wZXIOM$;zs??,~g]v0gR~Do3]>6d.4{c($[<Qv^Wiv![/,xru^c=lBuvpq:lbN:0(Or4[|i=pxfT&V:-N<YbgC)M4d*gNI3,!.:IIaA.E=WOUqxwXC,kboWnpgZLN_e9!&g-IP6K)Es3w]Z`V@Y,;>:j>?/d1huGG(aI|?Jc.o6Y#/<tl0zy>_+aJoxiU8%qIPkwPSTmjWt.ngDEk4U8GjT1~Z5hmHX8>wHskb1jo\"};\n\t\n\tstatic String chars = \"!#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~\";\n\tstatic int N = 400;\n\tstatic long mod;\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong b = chars.length();\n\t\tint n = sc.nextInt();\n\t\tmod = sc.nextLong();\n\t\tif(n > 110) {\n\t\t\tchar[] s = vals[n-111].toCharArray();\n\t\t\tlong res = 0;\n\t\t\tfor(char c: s) {\n\t\t\t\tres *= b;\n\t\t\t\tres += chars.indexOf(c);\n\t\t\t\tres %= mod;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\telse {\n\t\t\tc = new long[N+1][N+1];\n\t\t\tc[0][0] = 1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tc[i][0] = 1;\n\t\t\t\tfor(int j = 1; j <= i; j++){\n\t\t\t\t\tc[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdpcl = new long[N+1][N+1];\n\t\t\tdpop = new long[N+1][N+1];\n\t\t\tfor(int i = 0; i <= N; i++){\n\t\t\t\tfor(int j = 0; j <= N; j++){\n\t\t\t\t\tdpcl[i][j] = -1;\n\t\t\t\t\tdpop[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j <= n-1; j++){\n\t\t\t\t\tfor(int a = 0; a <= j; a++) {\n\t\t\t\t\t\tlong leftv = dpop(i, a);\n\t\t\t\t\t\tlong rightv = dpop(n-i-1, j-a);\n\t\t\t\t\t\tlong curr = leftv * rightv % mod;\n\t\t\t\t\t\tlong fac = c[j][a];\n\t\t\t\t\t\tlong v = curr * fac % mod;\n\t\t\t\t\t\tres = (res + v) % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tstatic long[][] c, dpcl, dpop;\n\tstatic long dpcl(int n, int k) {\n\t\tif(dpcl[n][k] >= 0) return dpcl[n][k];\n\t\tif(n == 0 || n == 1) {\n\t\t\tif(k == 0) {\n\t\t\t\treturn dpcl[n][k] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn dpcl[n][k] = 0;\n\t\t\t}\n\t\t}\n\t\tif(k == 0) { // n > 1\n\t\t\treturn dpcl[n][k] = 0;\n\t\t}\n\t\tlong res = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int a = 0; a <= k-1; a++) {\n\t\t\t\tlong leftv = dpcl(i, a);\n\t\t\t\tlong rightv = dpcl(n-i-1, k-1-a);\n\t\t\t\tlong curr = leftv * rightv % mod;\n\t\t\t\tlong fac = c[k-1][a];\n\t\t\t\tlong v = curr * fac % mod;\n\t\t\t\tres = (res + v) % mod;\n\t\t\t}\n\t\t}\n\t\treturn dpcl[n][k] = res;\n\t}\n\tstatic long dpop(int n, int k) {\n\t\tif(dpop[n][k] >= 0) return dpop[n][k];\n\t\tif(n == 0) {\n\t\t\tif(k == 0) {\n\t\t\t\treturn dpop[n][k] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn dpop[n][k] = 0;\n\t\t\t}\n\t\t}\n\t\tif(k == 0) { // n > 0\n\t\t\treturn dpop[n][k] = 0;\n\t\t}\n\t\tlong res = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int a = 0; a <= k-1; a++) {\n\t\t\t\tlong leftv = dpcl(i, a);\n\t\t\t\tlong rightv = dpop(n-i-1, k-1-a);\n\t\t\t\tlong curr = leftv * rightv % mod;\n\t\t\t\tlong fac = c[k-1][a];\n\t\t\t\tlong v = curr * fac % mod;\n\t\t\t\tres = (res + v) % mod;\n\t\t\t}\n\t\t}\n\t\treturn dpop[n][k] = res;\n\t}\n\n}\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "// Don't place your source in a package\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n\n\n\n\n\n\n\n\n// Please name your class Main\npublic class Main {\n    static FastScanner fs=new FastScanner();\n    static class FastScanner {//scanner from SecondThread\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int Int() {\n            return Integer.parseInt(next());\n        }\n\n        long Long() {\n            return Long.parseLong(next());\n        }\n\n        String Str(){\n            return next();\n        }\n    }\n\n\n    public static void main (String[] args) throws java.lang.Exception {\n        PrintWriter out = new PrintWriter(System.out);\n\n        int primes[]=new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\n                73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,\n                173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269,\n                271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\n                383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,\n                491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n                613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727,\n                733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607,\n                1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721,\n                1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847,\n                1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973,\n                1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373,\n                3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517,\n                3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999};\n\n        int T=Int();\n        for(int t=0;t<T;t++){\n            int n=Int();\n            int k=Int();\n            int A[]=new int[n];\n            for(int i=0;i<n;i++){\n                A[i]=Int();\n            }\n            Sol sol=new Sol();\n            sol.solution(out,A,k,primes);\n        }\n        out.flush();\n\n    }\n\n    public static int Int(){\n        return fs.Int();\n    }\n    public static long Long(){\n        return fs.Long();\n    }\n    public static String Str(){\n        return fs.Str();\n    }\n\n}\n\n\n\nclass Sol{\n    int dp[][];\n    public void solution(PrintWriter out,int A[],int K,int primes[]){\n        int n=A.length;\n        int id=0;\n        int dp[][]=new int[n+1][K+1];\n        for(int i=0;i<dp.length;i++){\n            Arrays.fill(dp[i],n);\n        }\n\n        //pre-processing\n        Map<String,Integer>f=new HashMap<>();\n        for(int i=0;i<A.length;i++){\n            String h=hash(A[i],primes);\n            if(!f.containsKey(h)){\n                f.put(h,id);\n                A[i]=id;\n                id++;\n            }\n            else{\n                A[i]=f.get(h);\n            }\n        }\n\n\n        int dis[][]=new int[A.length][K+1];\n        for(int k=0;k<=K;k++){//how far it can go\n            int r=n-1;\n            Map<Integer,Integer>ff=new HashMap<>();\n            for(int i=n-1;i>=0;i--){\n                put(ff,A[i]);\n                while(ff.size()+k<(r-i+1)){\n                    remove(ff,A[r]);\n                    dis[r][k]=i+1;\n                    r--;\n                }\n            }\n        }\n\n\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=K;j++){\n                if(j>=i+1){\n                    dp[i][j]=1;\n                    continue;\n                }\n                for(int k=0;k<=j;k++){//take k change\n                    int reach=dis[i][k];//the maximum place I can reach\n                    if(reach==0)dp[i][j]=1;\n                    else dp[i][j]=Math.min(dp[i][j],1+dp[reach-1][j-k]);\n                }\n            }\n        }\n        out.println(dp[n-1][K]);\n\n    }\n\n    public void put(Map<Integer,Integer>f,int key){\n        if(!f.containsKey(key))f.put(key,1);\n        else f.put(key,f.get(key)+1);\n    }\n    public void remove(Map<Integer,Integer>f,int key){\n        f.put(key,f.get(key)-1);\n        if(f.get(key)==0)f.remove(key);\n    }\n\n\n    public String hash(int n,int primes[]){\n        StringBuilder str=new StringBuilder(\"a,\");\n        for(int i:primes){\n            if(i*i>n)break;\n            int cnt=0;\n            while(n%i==0){\n                n/=i;\n                cnt++;\n            }\n            cnt%=2;\n            if(cnt!=0)str.append(i+\",\");\n        }\n        if(n!=1)str.append(n+\",\");\n        return str.toString();\n    }\n\n}\n\n\n\n\n\n\n", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
