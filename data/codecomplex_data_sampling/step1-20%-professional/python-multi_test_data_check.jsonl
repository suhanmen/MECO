{
    "src": "mod = 1000000007\nx, k = map(int, input().split())\nif x == 0:\n    print(0)\nelse:\n    ans = (pow(2, k + 1, mod) * x % mod - (pow(2, k, mod) - 1 + mod) % mod + mod) % mod\n    print(ans)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\nimport threading\ninp = sys.stdin.buffer.readline      \ninput = lambda: sys.stdin.readline().rstrip()\ndef I(): return list(map(int,inp().split()))\ndef main():\n    n,=I() ; vis=[0]*n ; st=[0]*n\n    if n==1:\n        print(1)\n        exit(0)\n    def dfs(g,e):\n        if vis[e]==1: return\n        else: \n            vis[e]=1\n            for i in g[e]:\n                dfs(g,i)\n            if len(g[e])==1 and e!=0: st[e]+=1\n            for i in g[e]:\n                st[e]+=st[i]\n    a=[int(i)-1 for i in input().split()]\n    g=[[] for i in range(n)]\n    for i in range(n-1):\n        g[i+1].append(a[i])\n        g[a[i]].append(i+1)\n    dfs(g,0)\n    st.sort()\n    print(*st)\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()",
    "complexity": "quadratic",
    "problem": "1056_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"
}
{
    "src": "n, p = map(int, input().split())\na = list(map(int, input().split()))\na = [c % p for c in a]\ns = sum(a)\nsp = s % p\nif sp == s or sp + 1 == p:\n    print(sp)\nelse:\n    print(sp + p)",
    "complexity": "linear",
    "problem": "0958_C1",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "cs = int(input())\n\nfor c in range(cs):\n    l, r = map(int, input().split())\n    #odd     => -\n    #even    => +\n    \n    if l%2 == 0 and r%2 == 0:\n        print((r - l) // 2 + l)\n    if l%2 == 1 and r%2 == 0:\n        print((r - l + 1) // 2)\n    if l%2 == 0 and r%2 == 1:\n        print(-(r - l + 1) // 2)\n    if l%2 == 1 and r%2 == 1:\n        print(-(r - l) // 2 - l)",
    "complexity": "constant",
    "problem": "1080_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\ninput=sys.stdin.readline\nn=int(input())\nar=list(map(int,input().split()))\ndic={}\nli=[]\nfor i in range(n):\n    xx=[]\n    for j in range(n-i):\n        xx.append(0)\n    li.append(xx.copy())\nfor i in range(n):\n    for j in range(n-i):\n        if(i==0):\n            li[i][j]=ar[j]\n        else:\n            li[i][j]=li[i-1][j]^li[i-1][j+1]\nfor i in range(1,n):\n    for j in range(n-i):\n        li[i][j]=max(li[i][j],li[i-1][j],li[i-1][j+1])\nfor _ in range(int(input())):\n    l,r=map(int,input().split())\n    print(li[r-l][l-1])",
    "complexity": "quadratic",
    "problem": "0983_B",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "from os import path\nimport sys,time\n# mod = int(1e9 + 7)\n# import re\nfrom math import ceil, floor,gcd,log,log2 ,factorial\nfrom collections import * \n# from bisect import *\nmaxx = float('inf')\n#----------------------------INPUT FUNCTIONS------------------------------------------#\nI = lambda :int(sys.stdin.buffer.readline())\ntup= lambda : map(int , sys.stdin.buffer.readline().split())\nlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\nS = lambda: sys.stdin.readline().replace('\\n', '').strip()\ndef grid(r, c): return [lint() for i in range(r)]\nstpr = lambda x : sys.stdout.write(f'{x}' + '\\n')\nstar = lambda x: print(' '.join(map(str, x)))\nlocalsys = 0\nstart_time = time.time()\nif (path.exists('input.txt')):\n\tsys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n#left shift --- num*(2**k) --(k - shift)\nn = I()\nls = [int(i) for i in S()]\npre , s =[] , 0\nfor i in ls:\n\ts+=i\n\tpre.append(s)\nfor i in range(n-1):\n\tcnt =0\n\tsu =0\n\tfor j in range(i+1 , n):\n\t\tsu+=ls[j]\n\t\tif su == pre[i]:\n\t\t\tcnt+=1\n\t\t\tsu =0\n\tif cnt and su ==0:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n\n\n\n\n\n\n\n\n\nif localsys:\n\tprint(\"\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")\n",
    "complexity": "quadratic",
    "problem": "1030_C",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "from math import ceil\ndef test(f):\n    for i in range(n):\n        if (r1+ f) > f * lift[i]:\n            return 0\n        f -= (r1 + f) / lift[i]\n        if (r1+ f) > f * land[i + 1]:\n            return 0\n        f -= (r1 + f) / land[i + 1]\n    return 1\np=int(input())\ntotal_wgt=int(input());r1=total_wgt\nlift=list(map(int,input().split()))\nland=list(map(int,input().split()));n=len(land);ans=1e20\nlift+=[lift[0]];land+=[land[0]]\nl=0.0;r=1e20\nfor i in range(1000):\n  mid=(l+r)/2.0\n  #print(mid)\n  if test(mid):r=mid\n  else:l=mid\nif r<1e19:\n    print('%.17f' %r)\nelse:\n    print(-1)\n",
    "complexity": "linear",
    "problem": "1010_A",
    "from": "CODEFORCES",
    "tags": "binary search,math"
}
{
    "src": "from collections import defaultdict\nfrom sys import stdin\n\nall_in = stdin.read().splitlines()\n\nn = int(all_in[0])\ns = all_in[1:]\n\none = defaultdict(lambda: 0)\ntwo = defaultdict(lambda: 0)\n\nfor el in s:\n    I = 0\n    min_ = 0\n\n    for char in el:\n        I += {'(': 1, ')': -1}[char]\n        min_ = min(min_, I)\n\n    if I >= 0 and min_ == 0:\n        one[I] += 1\n\n    if I <= 0 and min_ == I:\n        two[I] += 1\n\nans = 0\nfor el in one.keys():\n    ans += one[el] * two[-el]\n\nprint(ans)\n",
    "complexity": "linear",
    "problem": "0990_C",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "def forninho(miolo, s):\n    premiolo = miolo\n    temp = 0\n    while (miolo > 0):\n        temp += miolo % 10;\n        miolo = miolo // 10;\n    if (premiolo - temp >= s):\n        return 1\n    else:\n        return 0\n\nentrada = input().split()\nn = int(entrada[0])\ns = int(entrada[1])\n\nresult = -1\nl = 1\nr = n\nwhile (r-l >= 0):\n    miolo = (l + r) // 2\n    if(forninho(miolo,s) == 1):\n        r = miolo - 1\n        result = miolo\n    else:\n        l = miolo + 1\n\nif (result == -1):\n    print(\"0\")\nelse:\n    print(n - result + 1)\n  \t\t  \t \t\t\t \t   \t \t\t \t  \t\t  \t",
    "complexity": "logn",
    "problem": "0817_C",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,dp,math"
}
{
    "src": "a=int(input())\nb=str(a)\nc=[]\nfor i in range(2,a+1):\n    if(a%i==0):\n        c.append(i)\n\nl=0\nfor j in c:\n    r=str(j)\n    t=len(r)\n    o=0\n    for p in r:\n        if(p==\"4\" or p==\"7\"):\n            o=o+1\n    if(o==t):\n        l=l+1\nif(l>0):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n            \n    \n",
    "complexity": "constant",
    "problem": "0122_A",
    "from": "CODEFORCES",
    "tags": "brute force,number theory"
}
{
    "src": "# A. Game Shopping\n\nn, m = map(int, input().split())\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nans = 0\ni = 0\nfor bill in a:\n    try:\n        i += next(ind for ind, el in enumerate(c[i:]) if el <= bill) + 1\n        ans += 1\n    except StopIteration:\n        break\n\nprint(ans)\n",
    "complexity": "linear",
    "problem": "1009_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import math\nx, k = list(map(int, input().split()))\nmod = 10**9 + 7\nprint((pow(2, k+1, mod)*x - pow(2, k, mod) + 1) % mod if x > 0 else 0)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "# import os\n\nn = int(input())\n\nr = []\nfor _ in range(n):\n    a,b,c,d = map(int,input().split())\n    r.append(sum([a,b,c,d]))\n\nthomas = r[0]\nprint(sorted(r, reverse=True).index(thomas)+1)\n",
    "complexity": "linear",
    "problem": "1017_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import json\nimport os\n\n\ndef convert_files_to_json():\n    answer = dict()\n    for file in os.listdir(\"bad/\"):\n        if '_' in file:\n            # x, y = map(int, file.split('_'))\n            answer[file] = [list(map(int, line.split())) for line in open(\"bad/\" + file).read().split('\\n')[:2]]\n\n    return json.dumps(answer)\n\n\ndef extract_list(compressed_list, start_val=1):\n    answer = []\n    for num in compressed_list:\n        answer += [start_val] * num\n        start_val += 1\n    return answer\n\n\nanswer = json.loads('{\"1_12\": [[], [2, 2, 2, 2, 2, 3]], \"6_11\": [[1, 1, 1, 1, 1, 7], [2, 3, 1, 2, 2, 2, 2, 3]], '\n                    '\"3_10\": [[], [1, 1, 4, 1, 1, 5]], \"3_17\": [[1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], \"6_9\": [[], [1, 1, '\n                    '1, 1, 1, 10]], \"9_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 19]], \"18_21\": [[], [1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22]], \"10_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], \"15_18\": [['\n                    '], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], \"1_10\": [[], [2, 2, 2, 2, 3]], \"6_19\": [[], '\n                    '[1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 8]], \"3_13\": [[1, 1, 4, 1, 1, 4], [2]], \"2_22\": [[], [1, 3]], '\n                    '\"3_6\": [[], [1, 1, 7]], \"10_14\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 1, 1, 1, 1, 7], '\n                    '[1, 3]], \"9_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [2]], \"6_15\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 7]], '\n                    '\"7_22\": [[], [1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 9]], \"1_15\": [[], [2]], \"10_15\": [[], [1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 16]], \"3_15\": [[], [1, 1, 4]], \"11_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '12], [1, 3, 1, 4, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4]], \"15_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 16, 1, 1, 4, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 1, 4]], \"18_19\": [[], [1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20]], \"11_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12], '\n                    '[2]], \"2_2\": [[], [1, 3]], \"16_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 3, 1, 2, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 3, '\n                    '3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, '\n                    '3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], \"3_12\": [[], [1, 1, 4, 1, 1, 7]], \"18_22\": [['\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 15, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 3, 1, 3, 1, '\n                    '3, 1, 3, 1, 1, 1, 1, 1, 7], [1, 3]], \"21_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 23]], \"8_19\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 1, 4, 1, 4, 1, 1, 3, 1, 1, 4, 1, '\n                    '4]], \"13_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14], [1, 1, 1, 6, 1, 1, 1, 1, 5, 1, 1, 1, 5, '\n                    '1, 1, 1, 6]], \"5_18\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3, 1, 2, 1, 3, 3]], '\n                    '\"8_16\": [[], [1, 1, 1, 1, 1, 1, 1, 17]], \"18_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 19]], \"1_19\": [[], [2]], \"5_15\": [[], [1, 1, 1, 1, 6]], \"1_6\": [[], [2, 2, 3]], '\n                    '\"11_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23]], \"17_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 19]], \"7_16\": [[1, 1, 1, 1, 1, 1, 8], [1, 3, 1, 4, 1, 1, 3, 1, 3, 1, 4]], '\n                    '\"3_3\": [[], [1, 1, 4]], \"15_16\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], '\n                    '\"5_11\": [[1, 1, 1, 1, 6], [2]], \"1_2\": [[], [3]], \"1_17\": [[], [2]], \"14_17\": [[1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 15, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 3, 3, 1, 2, 1, 2, 1, 1, '\n                    '1, 1, 1, 1, 1, 9, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 6], [3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, '\n                    '2, 1, 3, 3]], \"13_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6], [2]], \"1_8\": [[], [2, 2, 2, 3]], \"9_20\": [[1, '\n                    '1, 1, 1, 1, 1, 1, 1, 10], [1, 3, 1, 3, 3, 1, 2, 1, 3, 1, 3, 1, 3, 3]], \"8_22\": [[], [1, 1, 1, 1, '\n                    '1, 1, 1, 9, 1, 1, 1, 1, 1, 9]], \"7_17\": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 4, 2, 2, 2, 2, 1, 1, 4], '\n                    '[2]], \"17_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 1, 4, 1, 1, 3, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 13, 1, 4, 1, 4, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 4, 1, 4, '\n                    '1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 3, 1, 4]], \"12_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13], [1, 1, '\n                    '7, 1, 1, 1, 1, 1, 4, 1, 1, 4, 1, 1, 7]], \"5_19\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [2]], '\n                    '\"14_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 2, 3, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, '\n                    '2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 5], [2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3]], '\n                    '\"6_6\": [[], [1, 1, 1, 1, 1, 7]], \"7_11\": [[1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 1, 1, 4], [2]], '\n                    '\"2_10\": [[], [1, 3]], \"5_7\": [[1, 1, 1, 1, 6, 2, 2, 1, 1, 4], [2]], \"2_7\": [[], [1, 3, 1, 4]], '\n                    '\"10_13\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 1, 2, 1, 2, 1, 1, '\n                    '1, 5], [3, 3, 3, 1, 2, 1, 2, 1, 2, 2, 3]], \"12_12\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], '\n                    '\"4_15\": [[1, 1, 1, 5, 1, 1, 1, 5], [3, 1, 2, 2, 3, 1, 2, 2, 3]], \"9_14\": [[1, 1, 1, 1, 1, 1, 1, '\n                    '1, 10, 2, 3, 1, 2, 2, 1, 1, 1, 5], [2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 3]], \"11_15\": [[1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], '\n                    '\"15_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], \"3_14\": [[], [1, 1, 4, 1, 1, 4, '\n                    '1, 4]], \"7_18\": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 5, 3, 1, 2, 1, 1, 1, 5], [3, 1, 2, 2, 3, 3, 1, '\n                    '2, 1, 2, 2, 3]], \"2_13\": [[], [1, 3, 1, 3, 1, 3, 3]], \"10_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], '\n                    '[1, 3]], \"9_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 3, 3, 1, 2, 1, 3, 1, 3, 1, 3, 3]], '\n                    '\"8_18\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 3, 1, 5, 1, 1, 1, 3, 1, 3, 1, 5]], \"6_10\": [[1, 1, 1, 1, '\n                    '1, 7], [1, 3]], \"16_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 2, 3, 1, 2, 2, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 7], [2, 3, 2, 3, 2, 3, '\n                    '1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 3]], \"21_21\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 22]], \"12_16\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], \"10_19\": [[1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 11], [2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]], \"2_9\": [[], [1, 3, 1, 3, '\n                    '3]], \"1_18\": [[], [2, 2, 2, 2, 2, 2, 2, 2, 3]], \"8_9\": [[], [1, 1, 1, 1, 1, 1, 1, 10]], '\n                    '\"5_13\": [[1, 1, 1, 1, 6, 1, 1, 4, 2, 2, 1, 1, 4], [2]], \"4_10\": [[], [1, 1, 1, 5, 1, 5]], '\n                    '\"1_5\": [[], [2]], \"18_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], '\n                    '\"3_8\": [[], [1, 1, 4, 1, 4]], \"2_12\": [[], [1, 3, 1, 3, 1, 5]], \"2_21\": [[], [1, 3, 1, 3, 1, 3, '\n                    '1, 3, 1, 3, 3]], \"6_13\": [[1, 1, 1, 1, 1, 7], [2, 2, 3, 1, 2, 2, 2, 2, 3]], \"4_6\": [[], [1, 1, '\n                    '1, 7]], \"2_8\": [[], [1, 3, 1, 5]], \"12_13\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14]], '\n                    '\"5_10\": [[], [1, 1, 1, 1, 11]], \"3_4\": [[], [1, 1, 5]], \"10_11\": [[], [1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 12]], \"16_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 1, 5, 1, 1, 1, 3, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 11], [1, 5, 1, 5, 1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 5, 1, 5]], \"4_12\": [[], [1, '\n                    '1, 1, 5]], \"11_14\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 9, 3, 3, '\n                    '1, 2, 1, 2, 1, 1, 1, 1, 6], [3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 3, 3]], \"4_16\": [[], [1, 1, 1, 5, 1, '\n                    '1, 1, 9]], \"5_16\": [[], [1, 1, 1, 1, 6, 1, 1, 1, 1, 7]], \"5_17\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6, '\n                    '2, 2, 1, 1, 4, 2, 2, 1, 1, 4], [2]], \"10_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 3]], '\n                    '\"4_18\": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 5]], \"4_19\": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 1, 5]], '\n                    '\"8_8\": [[], [1, 1, 1, 1, 1, 1, 1, 9]], \"19_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 21]], \"3_20\": [[], [1, 1, 4, 1, 1, 4, 1, 1, 4, 1, 4]], \"5_14\": [[], [1, 1, 1, 1, 6, '\n                    '1, 1, 1, 6]], \"13_15\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 12, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], \"1_3\": [[], [2]], '\n                    '\"5_21\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [2]], \"1_20\": [[], [2, 2, 2, 2, 2, 2, 2, 2, 2, 3]], '\n                    '\"15_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 12, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, '\n                    '4], [2]], \"14_21\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22]], \"4_5\": [[], [1, 1, 1, 6]], '\n                    '\"3_21\": [[], [1, 1, 4]], \"4_9\": [[1, 1, 1, 5], [2, 3, 1, 2, 2, 3]], \"7_7\": [[], [1, 1, 1, 1, 1, '\n                    '1, 8]], \"11_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12], [1, 1, 5, 1, 1, 1, 4, 1, 1, 1, 5, 1, 1, '\n                    '5]], \"15_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 1, '\n                    '1, 1, 1, 9], [2, 2, 3, 2, 2, 3, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 3]], \"14_14\": [[], [1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], \"4_17\": [[1, 1, 1, 5, 1, 1, 1, 5], [2, 3, 1, 2, 2, 3, 1, 2, 2, '\n                    '3]], \"6_12\": [[], [1, 1, 1, 1, 1, 13]], \"1_1\": [[], [2]], \"19_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 2, 2, '\n                    '2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 2, 2, '\n                    '2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, '\n                    '2, 1, 1, 4], [2]], \"9_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 1, 4]], \"17_21\": [[1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, '\n                    '6], [2]], \"16_17\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18]], \"4_21\": [[], [1, 1, '\n                    '1, 5, 1, 1, 1, 5, 1, 1, 1, 6]], \"5_6\": [[], [1, 1, 1, 1, 7]], \"10_10\": [[], [1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 11]], \"8_15\": [[1, 1, 1, 1, 1, 1, 1, 9], [2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 3]], '\n                    '\"13_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 9], [1, '\n                    '4, 1, 4, 1, 1, 3, 1, 1, 3, 1, 1, 4, 1, 4]], \"20_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 23]], \"9_10\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 11]], \"2_19\": [[], [1, 3, 1, 3, '\n                    '1, 3, 1, 3, 1, 4]], \"6_22\": [[1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 7], [1, 3]], \"13_13\": [[], [1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14]], \"17_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '18, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 12, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 9, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, '\n                    '2, 1, 1, 1, 1, 6], [3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 3]], \"6_18\": [[], [1, 1, '\n                    '1, 1, 1, 7]], \"5_12\": [[1, 1, 1, 1, 6], [1, 3, 3, 1, 2, 1, 3, 3]], \"17_17\": [[], [1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18]], \"8_20\": [[], [1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 9]], '\n                    '\"11_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6], [2]], \"1_4\": [[], '\n                    '[2, 3]], \"3_11\": [[1, 1, 4, 1, 1, 4], [2]], \"3_9\": [[], [1, 1, 4]], \"7_14\": [[], [1, 1, 1, 1, 1, '\n                    '1, 15]], \"13_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 1, 1, '\n                    '7], [2, 2, 3, 2, 2, 3, 1, 2, 2, 2, 1, 2, 2, 2, 2, 3]], \"8_13\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 4, '\n                    '1, 1, 3, 1, 1, 4, 1, 4]], \"9_13\": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 1, 1, 1, 1, 6], '\n                    '[2]], \"11_13\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, '\n                    '1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], '\n                    '\"9_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 5, 2, 3, 1, 2, 2, 1, 1, 1, 5], [2, 3, 1, 2, 2, 3, '\n                    '2, 3, 1, 2, 2, 1, 2, 2, 3]], \"6_21\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 10]], \"12_14\": [[], '\n                    '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], \"3_7\": [[1, 1, 4], [2]], \"14_20\": [[1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 15, 1, 5, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 9], [1, 5, 1, 5, 1, 1, 1, 3, 1, 1, '\n                    '1, 3, 1, 3, 1, 5]], \"9_11\": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, '\n                    '1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], \"12_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '13], [1, 3, 1, 5, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 5]], \"5_20\": [[], [1, 1, 1, 1, 6, 1, 1, 1, 1, '\n                    '11]], \"1_16\": [[], [2, 2, 2, 2, 2, 2, 2, 3]], \"7_12\": [[1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 1, 3, 1, '\n                    '3, 1, 4]], \"12_15\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16]], \"7_9\": [[1, 1, 1, 1, 1, 1, 8, '\n                    '2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 1, 1, 4], [2]], \"15_15\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 16]], \"5_5\": [[], [1, 1, 1, 1, 6]], \"9_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [2]], '\n                    '\"8_11\": [[1, 1, 1, 1, 1, 1, 1, 9, 3, 1, 2, 1, 1, 1, 1, 6], [3, 3, 1, 2, 1, 2, 1, 3, 3]], '\n                    '\"2_3\": [[], [1, 4]], \"7_10\": [[1, 1, 1, 1, 1, 1, 8, 3, 1, 2, 1, 1, 1, 5], [3, 3, 1, 2, 1, 2, 2, '\n                    '3]], \"8_14\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 5, 1, 1, 1, 3, 1, 3, 1, 5]], \"11_11\": [[], [1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 12]], \"2_11\": [[], [1, 3, 1, 3, 1, 4]], \"2_15\": [[], [1, 3, 1, 3, 1, 3, 1, '\n                    '4]], \"10_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [2, 2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]], '\n                    '\"10_12\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], \"13_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '14, 1, 1, 4, 2, 2, 1, 1, 4, 1, 1, 1, 1, 6, 1, 1, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], '\n                    '[2]], \"12_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 1, 3, 3, 1, 2, 1, 3, 1, 1, 1, 1, 6], [1, '\n                    '3, 3, 1, 3, 3, 1, 2, 1, 3, 1, 2, 1, 3, 3]], \"9_9\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 10]], '\n                    '\"3_18\": [[], [1, 1, 4, 1, 1, 4, 1, 1, 7]], \"14_15\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '16]], \"14_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, '\n                    '1, 7], [1, 3]], \"13_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 11, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, 3, '\n                    '3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], \"6_8\": [[], [1, 1, 1, 1, 1, 9]], \"3_16\": [[], [1, 1, 4, 1, '\n                    '1, 4, 1, 1, 5]], \"2_6\": [[], [1, 3]], \"20_21\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 22]], \"6_7\": [[], [1, 1, 1, 1, 1, 8]], \"2_4\": [[], [1, 5]], \"9_12\": [[], [1, 1, '\n                    '1, 1, 1, 1, 1, 1, 13]], \"8_12\": [[], [1, 1, 1, 1, 1, 1, 1, 13]], \"8_10\": [[], [1, 1, 1, 1, 1, 1, '\n                    '1, 11]], \"15_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 14, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, '\n                    '1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], \"2_17\": [[], [1, 3, 1, 3, 1, 3, 1, 3, '\n                    '3]], \"16_16\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], \"1_22\": [[], [2, 2, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 3]], \"4_11\": [[], [1, 1, 1, 5, 1, 1, 5]], \"4_4\": [[], [1, 1, 1, 5]], '\n                    '\"11_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 3, 1, 2, 2, 1, 1, 1, 1, 1, 7], [2, 3, 2, 3, 1, '\n                    '2, 2, 1, 2, 2, 2, 2, 3]], \"2_18\": [[], [1, 3]], \"6_16\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 7]], '\n                    '\"2_14\": [[], [1, 3]], \"7_13\": [[1, 1, 1, 1, 1, 1, 8], [2]], \"3_22\": [[], [1, 1, 4, 1, 1, 4, 1, '\n                    '1, 4, 1, 1, 5]], \"19_19\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20]], '\n                    '\"8_17\": [[1, 1, 1, 1, 1, 1, 1, 9], [2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 3]], \"2_5\": [[], [1, 3, '\n                    '3]], \"19_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 3, 1, 2, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, '\n                    '3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, '\n                    '1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, 3, 3, 3, 3, 3, '\n                    '1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], \"10_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 5, 1, '\n                    '1, 1, 3, 1, 1, 1, 5, 1, 5]], \"22_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 23]], \"4_13\": [[], [1, 1, 1, 5, 1, 1, 1, 6]], \"7_20\": [[], [1, 1, 1, 1, 1, 1, 8, 1, '\n                    '1, 1, 1, 1, 8]], \"5_22\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [1, 3, 3, 1, 2, 1, 3, 3, 1, 2, 1, 3, '\n                    '3]], \"16_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], \"13_14\": [[], [1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], \"5_8\": [[1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3]], \"1_11\": [[], '\n                    '[2]], \"7_21\": [[], [1, 1, 1, 1, 1, 1, 8]], \"11_12\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], '\n                    '\"12_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], \"7_19\": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, '\n                    '6, 2, 2, 1, 1, 1, 1, 6, 2, 2, 1, 1, 4, 2, 2, 2, 2, 1, 1, 4], [2]], \"7_8\": [[], [1, 1, 1, 1, 1, '\n                    '1, 9]], \"10_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 1, 5, 1, 1, 1, 4, 1, 1, 4, 1, 1, 5]], '\n                    '\"6_20\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 9]], \"3_19\": [[1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], '\n                    '\"11_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 4, 2, 2, 1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], '\n                    '\"6_17\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 7]], \"20_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 21]], \"4_8\": [[], [1, 1, 1, 9]], \"8_21\": [[1, 1, 1, 1, 1, 1, 1, 9, 1, 1, '\n                    '1, 1, 6, 3, 1, 2, 1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3]], \"12_17\": [[1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 4, 1, 1, 3, 1, 1, '\n                    '3, 1, 3, 1, 4]], \"2_20\": [[], [1, 3, 1, 3, 1, 3, 1, 3, 1, 5]], \"1_9\": [[], [2]], \"14_16\": [[], '\n                    '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], \"4_20\": [[], [1, 1, 1, 5]], \"2_16\": [[], [1, 3, 1, '\n                    '3, 1, 3, 1, 5]], \"1_14\": [[], [2, 2, 2, 2, 2, 2, 3]], \"1_21\": [[], [2]], \"13_19\": [[1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8], [2]], \"7_15\": [[1, 1, 1, 1, '\n                    '1, 1, 8], [2]], \"5_9\": [[1, 1, 1, 1, 6], [2]], \"4_7\": [[1, 1, 1, 5], [3, 1, 2, 2, 3]], '\n                    '\"4_14\": [[], [1, 1, 1, 5, 1, 1, 1, 7]], \"3_5\": [[1, 1, 4], [2]], \"9_15\": [[1, 1, 1, 1, 1, 1, 1, '\n                    '1, 10], [1, 1, 4]], \"6_14\": [[1, 1, 1, 1, 1, 7], [1, 3]], \"14_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 15, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, '\n                    '1, 7], [1, 3]], \"12_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13], [1, 1, 1, 5]], \"1_13\": [[], '\n                    '[2]], \"4_22\": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 1, 1, 7]], \"16_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 21]], \"1_7\": [[], [2]], \"17_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 18, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 2, '\n                    '2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]]}')\n\nn, x, y = map(int, input().split())\nn -= 1\nif x > y:\n    x, y = y, x\nprefix = extract_list(answer[str(x) + '_' + str(y)][0])\npattern = extract_list(answer[str(x) + '_' + str(y)][1], prefix[-1] + 1 if prefix else 1)\nif n < len(prefix):\n    print(prefix[n])\nelse:\n    n -= len(prefix)\n    print(n // len(pattern) * (pattern[-1] - pattern[0] + 1) + pattern[n % len(pattern)])\n",
    "complexity": "np",
    "problem": "1463_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,math"
}
{
    "src": "def bs(l, h):\n    while l < h:\n        m = (l + h) // 2\n        if gf(m):\n            h = m\n        else:\n            l = m + 1\n    return l\n\ndef gf(x):\n    d = {}\n    for i in range(x):\n        if s[i] in d:\n            d[s[i]] += 1\n        else:\n            d[s[i]] = 1\n    if len(d) == len(u):\n        return 1\n    for i in range(x, n):\n        if s[i] in d:\n            d[s[i]] += 1\n        else:\n            d[s[i]] = 1\n        d[s[i - x]] -= 1\n        if not d[s[i - x]]:\n            del d[s[i - x]]\n        if len(d) == len(u):\n            return 1\n    return 0\n\nn = int(input())\ns = input()\nu = set([*s])\nprint(bs(1, n))",
    "complexity": "linear",
    "problem": "0701_C",
    "from": "CODEFORCES",
    "tags": "binary search,strings,two pointers"
}
{
    "src": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------- fast io --------------------\nfrom math import gcd, ceil\n\ndef prod(a, mod=10**9+7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\nfor _ in range(int(input()) if not True else 1):\n    n = int(input())\n    #n, k = map(int, input().split())\n    #a, b = map(int, input().split())\n    #c, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    #b = list(map(int, input().split()))\n    #s = input()\n    mod =  10**9 + 7\n    twopow = [1]*(10**5+69)\n    for i in range(1, 10**5+69):\n        twopow[i] = (twopow[i-1] * 2) % mod\n    count = [0]*100069\n    for i in a:\n        count[i] += 1\n    multiples = [0]*100069\n    for i in range(1, 10**5+1):\n        for j in range(i, 10**5+1, i):\n            multiples[i] += count[j]\n    gcd_of = [0]*100069\n    for i in range(10**5, 0, -1):\n        gcd_of[i] = (twopow[multiples[i]] - 1) % mod\n        for j in range(2*i, 10**5+1, i):\n            gcd_of[i] -= gcd_of[j]\n    print(gcd_of[1] % mod)",
    "complexity": "np",
    "problem": "0803_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,combinatorics,number theory"
}
{
    "src": "MAX = 100001\nparent = []\n\ndef makeSet():\n    global parent\n    parent = [i for i in range(MAX + 1)]\n\ndef findSet(u):\n    global parent\n    if u != parent[u]:\n        parent[u] = findSet(parent[u])\n    return parent[u]\n\ndef unionSet(u, v):\n    up = findSet(u)\n    vp = findSet(v)\n    parent[up] = vp\n\nmakeSet()\nn, a, b = map(int, input().split())\np = list(map(int, input().split()))\npos = dict()\nfor i in range(n):\n    pos[p[i]] = i + 1\n\nfor i in range(n):\n    unionSet(i + 1, pos.get(a - p[i], n + 1))\n    unionSet(i + 1, pos.get(b - p[i], 0))\n\nA = findSet(0)\nB = findSet(n + 1)\n\nif A != B:\n    print('YES')\n    for i in range(1, n + 1):\n        if findSet(i) == B:\n            print('1', end = \" \")\n        else:\n            print('0', end = \" \")\nelse:\n    print('NO')\n",
    "complexity": "linear",
    "problem": "0468_B",
    "from": "CODEFORCES",
    "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"
}
{
    "src": "M = 10 ** 9 + 7\nx, k = map(int, input().split())\nif x == 0: print(0); exit(0)\nP = pow(2, k, M)\nr = (P * x) % M - (0.5 * (-1 + P)) % M\nprint(int((2 * r + M) % M))\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "#n, m = map(int, input().split())\n#x = int(input())\nn, m = map(int, input().split())\nans = m // n + min(1, m % n)\nprint(ans)",
    "complexity": "constant",
    "problem": "1061_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "k=int(input())\n\ns=0\ni=1\nwhile  (s +  i * ( 9 * pow ( 10,i-1)) ) < k :\n    s +=  i * (9 * pow(10, i - 1))\n    i+=1\nelse:\n    i-=1\n\nk=k-s-1\nx= k // (i+1)\ny= k %(i+1)\nx= pow(10,i)+x\nss=str(x)\nprint(ss[y])\n",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "n = int(input())\n\nmult = 1\nres = []\nremain = n\nwhile remain >0:\n    if remain == 2:\n        res.extend([mult, mult*2])\n        remain = 0\n    elif remain == 3:\n        res.extend([mult, mult, mult *3])\n        remain = 0\n    else:\n        half = remain // 2\n        extra = remain - half\n        res.extend([mult]*extra)\n        remain  = half\n        mult = mult *2\nprint(*res)\n    \n",
    "complexity": "logn",
    "problem": "1059_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "# for #!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\nclass union_find:\n    def __init__(self, n):\n        self.n = n\n        self.rank = [0]*n\n        self.parent = [int(j) for j in range(n)]\n    \n    def union(self,i,j):\n        i = self.find(i)\n        j = self.find(j)\n        if self.rank[i] == self.rank[j]:\n            self.parent[i] = j\n            self.rank[j] += 1\n\n        elif self.rank[i] > self.rank[j]:\n            self.parent[j] = i\n        else:\n            self.parent[i] = j\n\n    def find(self, i):\n        temp = i\n        if self.parent[temp] != temp:\n            self.parent[temp] = self.find(self.parent[temp])\n        return self.parent[temp]\nfrom math import log2, ceil\nfrom collections import deque, Counter as CC, defaultdict as dd\ndef main():\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n    # for t in range(int(input())):\n        \n        # n = int(input())\n        p,q,r  = [int(j) for j in input().split()]\n        a = [int(j) for j in input().split()]\n        b = [int(j) for j in input().split()]\n        c = [int(j) for j in input().split()]\n        a.sort()\n        b.sort()\n        c.sort()\n        l = [a,b,c]\n\n        dp = [[[0 for i in range(r+1)] for j in range(q+1)] for k in range(p+1)]\n        for i in range(p+1):\n            for j in range(q+1):\n                for k in range(r+1):\n                    s = [i-1,j-1,k-1]\n                    for u in range(3):\n                        \n                        s[u]+=1\n                        try:\n                            tmp = dp[s[0]][s[1]][s[2]]\n                        except:\n                            s[u]-=1\n                            continue\n                        tmp2 = 1\n                        flag =True\n                        for t in range(3):\n                            if(u!=t):\n                                if(s[t]==-1):\n                                    flag = False\n                                    break\n                                tmp2 *= l[t][s[t]] \n                        tmp += tmp2\n                        s[u]-=1\n                        if(flag):\n                            dp[i][j][k] = max(dp[i][j][k], tmp)\n        print(dp[p][q][r])\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\nif __name__ == \"__main__\":\n    main()",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "n,k = map(int,input().split())\ns = input()\nc=0\nfor i in range(len(s)):\n\tif s[:i]==s[-i:]:\n\t\tc=i\nprint(s+s[c:]*(k-1))",
    "complexity": "quadratic",
    "problem": "1029_A",
    "from": "CODEFORCES",
    "tags": "implementation,strings"
}
{
    "src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\na = li()\nb = [abs(x) for x in a] \nif n == 1:\n    ans = a[0]\nelif all(x > 0 for x in a) or all(x < 0 for x in a):\n    b.sort()\n    ans = sum(b) - 2 * b[0]\nelse:\n    ans = sum(b)\nprint(ans)\n",
    "complexity": "nlogn",
    "problem": "1038_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,implementation"
}
{
    "src": "n, m=[int(k) for k in input().split()]\nres=[]\nfor j in range(n//2):\n    for k in range(m):\n        res.append(str(j+1)+\" \"+str(k+1))\n        res.append(str(n-j)+\" \"+str(m-k))\nif n%2:\n    for j in range(m//2):\n        res.append(f\"{n//2+1} {j+1}\")\n        res.append(f\"{n//2+1} {m-j}\")\n    if m%2:\n        res.append(f\"{n//2+1} {m//2+1}\")\nprint(\"\\n\".join(res))",
    "complexity": "quadratic",
    "problem": "1179_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms"
}
{
    "src": "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nn,m = map(int, input().split())\na = []\nfor i in range(n):\n    ai = list(map(int, input().split()))\n    a.append(ai)\n\ndef check(mid):\n    mask = (1<<m)-1\n    s = set()\n    d = dict()\n    for i in range(n):\n        state = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                state += 1<<j\n        if state in s:\n            continue\n        s.add(state)\n        k = state\n        while k>=0:\n            k &= state\n            d[k] = i\n            k -= 1\n        need = mask^state\n        if need in d:\n            q1, q2 = d[need], i\n            if q1 > q2:\n                q1, q2 = q2, q1\n            return True, (q1, q2)\n    return False, (-1, -1)\n\nleft = 0\nright = 10**9+1\ni,j = 0, 0\nwhile right-left>1:\n    mid = (right+left)//2\n    flag, (q1, q2) = check(mid)\n    if flag:\n        left = mid\n        i,j = q1, q2\n    else:\n        right = mid\nprint(i+1, j+1)\n\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\ns = input()[:-1]\nleft, right = 0, n\nwhile left < right:\n    mid = right - (right - left) // 2\n    A = [[0] * (n + 2) for _ in range(k)]\n\n    for c in range(k):\n        A[c][n] = A[c][n + 1] = n + 1\n        L = 0\n        for i in range(n - 1, -1, -1):\n            if s[i] == '?' or ord(s[i]) - ord('a') == c: L += 1\n            else: L = 0\n            A[c][i] = i + mid if L >= mid else A[c][i + 1]\n\n    dp = [n + 1] * (1 << k)\n    dp[0] = 0\n    for mask in range(1 << k):\n        for i in range(k):\n            if mask >> k & 1: continue\n            t = mask | 1 << i\n            dp[t] = min(dp[t], A[i][dp[mask]])\n    if dp[-1] <= n: left = mid\n    else: right = mid - 1\nprint(left)",
    "complexity": "np",
    "problem": "1550_E",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,brute force,dp,strings,two pointers"
}
{
    "src": "a = int(input())\nc = [1] * 30\nfor i in range (1,20):\n\tc[i] = 9 * i * pow(10,i-1)\nfor i in range (1,15):\n\tif (a > c[i]):\n\t\ta -= c[i]\n\telse:\n\t\td = int((a-1) / i + pow(10,i-1) - 1)\n\t\te = (a-1) % i + 1\n\t\tf = str(d+1)\n\t\tprint(f[e-1])\n\t\texit()",
    "complexity": "constant",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "## necessary imports\nimport sys\ninput = sys.stdin.readline\nfrom math import ceil, floor, factorial;\n\n# swap_array function\ndef swaparr(arr, a,b):\n    temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp\n\n## gcd function\ndef gcd(a,b):\n    if a == 0:\n        return b\n    return gcd(b%a, a)\n\n## nCr function efficient using Binomial Cofficient\ndef nCr(n, k): \n    if(k > n - k): \n        k = n - k \n    res = 1\n    for i in range(k): \n        res = res * (n - i) \n        res = res / (i + 1) \n    return int(res) \n\n## upper bound function code -- such that e in a[:i] e < x;\ndef upper_bound(a, x, lo=0):\n    hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x:\n            lo = mid+1\n        else:\n            hi = mid\n    return lo\n\n## prime factorization\ndef primefs(n):\n    ## if n == 1    ## calculating primes\n    primes = {}\n    while(n%2 == 0):\n        primes[2] = primes.get(2, 0) + 1\n        n = n//2\n    for i in range(3, int(n**0.5)+2, 2):\n        while(n%i == 0):\n            primes[i] = primes.get(i, 0) + 1\n            n = n//i\n    if n > 2:\n        primes[n] = primes.get(n, 0) + 1\n    ## prime factoriazation of n is stored in dictionary\n    ## primes and can be accesed. O(sqrt n)\n    return primes\n\n## MODULAR EXPONENTIATION FUNCTION\ndef power(x, y, p): \n    res = 1\n    x = x % p  \n    if (x == 0) : \n        return 0\n    while (y > 0) : \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n        y = y >> 1      \n        x = (x * x) % p \n    return res \n\n## DISJOINT SET UNINON FUNCTIONS\ndef swap(a,b):\n    temp = a\n    a = b\n    b = temp\n    return a,b\n\n# find function with path compression included (recursive)\n# def find(x, link):\n#     if link[x] == x:\n#         return x\n#     link[x] = find(link[x], link);\n#     return link[x];\n\n# find function with path compression (ITERATIVE)\ndef find(x, link):\n    p = x;\n    while( p != link[p]):\n        p = link[p];\n    \n    while( x != p):\n        nex = link[x];\n        link[x] = p;\n        x = nex;\n    return p;\n\n\n# the union function which makes union(x,y)\n# of two nodes x and y\ndef union(x, y, link, size):\n    x = find(x, link)\n    y = find(y, link)\n    if size[x] < size[y]:\n        x,y = swap(x,y)\n    if x != y:\n        size[x] += size[y]\n        link[y] = x\n\n## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES\ndef sieve(n): \n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n#### PRIME FACTORIZATION IN O(log n) using Sieve ####\nMAXN = int(1e6 + 5)\ndef spf_sieve():\n    spf[1] = 1;\n    for i in range(2, MAXN):\n        spf[i] = i;\n    for i in range(4, MAXN, 2):\n        spf[i] = 2;\n    for i in range(3, ceil(MAXN ** 0.5), 2):\n        if spf[i] == i:\n            for j in range(i*i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i;\n    ## function for storing smallest prime factors (spf) in the array\n\n################## un-comment below 2 lines when using factorization #################\n# spf = [0 for i in range(MAXN)]\n# spf_sieve() \ndef factoriazation(x):\n    ret = {};\n    while x != 1:\n        ret[spf[x]] = ret.get(spf[x], 0) + 1;\n        x = x//spf[x]\n    return ret\n    ## this function is useful for multiple queries only, o/w use\n    ## primefs function above. complexity O(log n)\n\n## taking integer array input\ndef int_array():\n    return list(map(int, input().strip().split()))\n## taking string array input\ndef str_array():\n    return input().strip().split();\n\n#defining a couple constants\nMOD = int(1e9)+7;\nCMOD = 998244353;\nINF = float('inf'); NINF = -float('inf');\n\n################### ---------------- TEMPLATE ENDS HERE ---------------- ###################\n\nn, l, r, x = int_array(); a = sorted(int_array());\nans = 0;\nfor mask in range( 1 << n):\n    mx = NINF; mn = INF; sub = 0;\n    for i in range(n):\n        if (1 << i) & mask:\n            sub += a[i];\n            mx = max(mx, a[i]);\n            mn = min(mn, a[i]);\n    if sub >= l and sub <= r:\n        if mx - mn >= x:\n            ans += 1;\nprint(ans);",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "a, b = [int(x) for x in input().split(' ')]\nidx = 0\nif(a == b):\n    print(0)\nelse:\n    for i in range(63,-1,-1):\n        set1 = (a >> i) & 1\n        set2 = (b >> i) & 1\n        if(set1!=set2):\n            idx = i\n            break\n    print((1<<(idx+1))-1)",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "import math\n\nif __name__ == '__main__':\n    n, m, k, l = map(int, input().split())\n    one_friend = (k + l) // m + int((k + l) % m != 0)\n    if one_friend * m > n:\n        print(-1)\n    else:\n        print(one_friend)\n",
    "complexity": "constant",
    "problem": "1068_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "def getsum(a, b):\n    if a % 2 == 0:\n        return (a + b) * ((b - a) // 2 + 1) // 2\n    else:\n        return -(a + b) * ((b - a) // 2 + 1) // 2\n\nq = int(input())\nfor i in range(q):\n    l, r = map(int, input().split())\n    if l == r:\n        print(l if l % 2 == 0 else -l)\n    else:\n        print(\n            getsum(l if l % 2 == 1 else l + 1, r if r % 2 == 1 else r - 1) + \n            getsum(l if l % 2 == 0 else l + 1, r if r % 2 == 0 else r - 1)\n        )",
    "complexity": "constant",
    "problem": "1080_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n,s = map(int,input().split())\nif s>=n:\n    print('0')\nelse:\n    for i in range(s,n+2):\n        l=0\n        for j in str(i):\n            l+=int(j)\n        if i-l>=s:\n            break\n    print(n-i+1)",
    "complexity": "logn",
    "problem": "0817_C",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,dp,math"
}
{
    "src": "n, A, C = list(map(int, input().split()))\n\ndef Ro(x, y):\n    return A * x - y + C\n \nhuh = []\n \nfor i in range(n):\n    z, x, y = list(map(int, input().split()))\n    huh.append((Ro(x + z, z * A + y), x))\nhuh = sorted(huh)\nanss = 0\nc1 = 0\nc2 = 0\nprev = (-9999999999999, -999999999999999)\ng = []\n\nhuh.append((-9999999999999, -999999999999999))\n#print(huh)\nfor huhh in huh:\n    if huhh[0] != prev[0]:\n        g.append(c1)\n        #print(g)\n        for j in g:\n            anss += (c2 - j) * j\n        g = []\n        c1 = 1\n        c2 = 1\n        prev = (huhh[0], huhh[1])\n        continue\n    c2 += 1\n    if huhh[1] != prev[1]:\n        g.append(c1)\n        c1 = 0\n        prev = (huhh[0], huhh[1])\n    c1 += 1\nprint(anss)\n    ",
    "complexity": "linear",
    "problem": "0975_D",
    "from": "CODEFORCES",
    "tags": "geometry,math"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\n\nmax_mod = 0\nmax_i = -1\nfor i in range(n):\n\tif a[i] >= 0:\n\t\ta[i] = -a[i] - 1\n\tif -a[i] > max_mod:\n\t\tmax_mod = -a[i]\n\t\tmax_i = i\n\nif n % 2 == 1:\n\ta[max_i] = -a[max_i] - 1\n\nprint(' '.join(list(map(str, a))))\n",
    "complexity": "linear",
    "problem": "1180_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation"
}
{
    "src": "import math\nres = [0, 1, 0, 3, 0, 15, 0, 133, 0, 2025, 0, 37851, 0, 1030367, 0, 36362925, 0]\nn = int(input())\nprint(res[n] * math.factorial(n) % (10 ** 9 + 7))\n\n  \t   \t\t\t\t\t\t \t  \t\t\t\t \t  \t\t\t\t\t\t",
    "complexity": "np",
    "problem": "0285_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,combinatorics,dp,implementation,meet-in-the-middle"
}
{
    "src": "import os, sys\nfrom io import BytesIO, IOBase\nfrom copy import deepcopy\n\n\ndef main():\n    n = rint()\n    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []\n    for i in range(4):\n        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])\n    print(['No', 'Yes'][a2.mat in ans])\n\n\nclass Matrix:\n    def __init__(self, r, c, mat=None, id=None):\n        self.r, self.c = r, c\n\n        if mat != None:\n            self.mat = deepcopy(mat)\n        else:\n            self.mat = [[0 for i in range(c)] for j in range(r)]\n\n    def __add__(self, other):\n        mat0 = Matrix(self.r, self.c)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]\n\n        return mat0\n\n    def __mul__(self, other):\n        mat0 = Matrix(self.r, other.c)\n\n        for i in range(self.r):\n            for j in range(other.c):\n                for k in range(self.c):\n                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]\n\n        return mat0\n\n    def dot_mul(self, other):\n        res = 0\n        for i in range(self.r):\n            for j in range(self.c):\n                res += self.mat[i][j] * other.mat[j][i]\n\n        return res\n\n    def trace(self):\n        res = 0\n        for i in range(self.r):\n            res += self.mat[i][i]\n\n        return res\n\n    def rotate(self):\n        mat0 = Matrix(self.c, self.r)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]\n\n        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r\n        return self.mat\n\n    def flipv(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def fliph(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def mat_pow(self, mat, p, mod=None):\n        sq = Matrix(mat.r, mat.r, id=1)\n\n        while p:\n            if p & 1:\n                p -= 1\n                sq = sq * mat\n\n            p //= 2\n            mat = mat * mat\n\n        return sq.mat\n\n\n# FASTIO REGION\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [list(rstr()) for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\nif __name__ == '__main__':\n    main()\n",
    "complexity": "quadratic",
    "problem": "0958_A1",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\nmod = 998244353\na.sort()\ndp = [1] + [0] * n\nfor i in range(1, n + 1):\n    x, pt = 1, i - 2\n    while pt >= 0 and 2 * a[pt] > a[i - 1]:\n        x = x * (n - pt - 2) % mod\n        pt -= 1\n    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod\nprint(dp[-1])",
    "complexity": "cubic",
    "problem": "1437_F",
    "from": "CODEFORCES",
    "tags": "combinatorics,dp,math,two pointers"
}
{
    "src": "def solve(n, k):\n\n\tif n >= 60:\n\t\treturn \"YES \" + str(n - 1)\n\n\tmxxx = (4 ** n - 1) // 3\n\t\n\tif k > mxxx:\n\t\treturn 'NO'\n\n\tmn, mx = 0, 0\n\n\tfor i in range(n):\n\t\tmn += 2 ** (i + 1) - 1\n\t\tmx += 4 ** i\n\t\tif mn <= k and mx >= k:\n\t\t\treturn \"YES \" + str(n - i - 1)\n\t\t# print(mn, mx)\n\n\tif k >= 22 and k <= 25:\n\t\treturn 'YES ' + str(n - 3) # OK\n\n\tif k == 2: # OK\n\t\tif n >= 2:\n\t\t\treturn 'YES ' + str(n - 1)\n\t\treturn 'NO'\n\t\n\tif k == 3: # OK\n\t\tif n <= 2:\n\t\t\treturn 'NO'\n\t\treturn 'YES ' + str(n - 1)\n\n\tif k >= 6 and k <= 10: #OK\n\t\treturn 'YES ' + str(n - 2)\n\nt = int(input())\n\nfor i in range(t):\n\tn, k = map(int, input().split())\n\tprint(solve(n, k))\n",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "from itertools import combinations\ndef out1(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==1 and b==0 and c==0:\n        return 1\n    return a*(out2(a-1,b,c)+out3(a-1,b,c))\ndef out2(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==1 and c==0:\n        return 1\n    return b*(out1(a,b-1,c)+out3(a,b-1,c))\ndef out3(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==0 and c==1:\n        return 1\n    return c*(out2(a,b,c-1)+out1(a,b,c-1))\ndef column(matrix, i):\n    return [row[i] for row in matrix]\n    \nN, T = [int(x) for x in input().split()]\nA = []\ns = 0\nfor i in range(N):\n    A.append([int(x) for x in input().split()])\nfor i in range(1,N+1):\n    comb = list(combinations(A, i))\n    for x in comb:\n        if sum(column(x,0))==T:\n            a = column(x,1).count(1)\n            b = column(x,1).count(2)\n            c = column(x,1).count(3)\n            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))\nprint(s%1000000007)",
    "complexity": "np",
    "problem": "1185_G1",
    "from": "CODEFORCES",
    "tags": "bitmasks,combinatorics,dp"
}
{
    "src": "t = int(input())\ndef maxsa(A):\n    ans = 0\n    #print(\"asdasd\")\n    for i in range(n):\n        cur_maxx = 0\n        for j in range(4):\n            cur_maxx = max(cur_maxx, A[j][i])\n        ans+= cur_maxx\n    return ans\n\ndef fu(A):\n    answer = 0\n    for j in range(n):\n        A[0] = A[0][1:] + A[0][:1]\n        for i in range(n):\n            A[1] = A[1][1:] + A[1][:1]\n            for k in range(n):\n                A[2] = A[2][1:] + A[2][:1]\n                for l in range(n):\n                    A[3] = A[3][1:] + A[3][:1]\n                    #print(A)\n                    cur_ans = maxsa(A)\n                    answer = max(answer, cur_ans)\n    return answer\n\n\nfor j in range(t):\n    n,m = map(int,input().split())\n    A = [0] * n\n    inds = [-1,-1,-1,-1]\n    maxs  =[ 0,0,0,0]\n    for j in range(n):\n        A[j] = list(map(int,input().split()))\n    for j in range(m):\n        cur_maxs = 0\n        for i in range(n):\n            cur_maxs = max(cur_maxs, A[i][j])\n        maxs.append(cur_maxs)\n        inds.append(j)\n        ind  = 4\n        #print(cur_maxs)\n        while ind !=0 and maxs[ind] > maxs[ind-1]:\n            inds[ind], inds[ind-1] = inds[ind-1] , inds[ind]\n            maxs[ind], maxs[ind - 1] = maxs[ind - 1], maxs[ind]\n            ind-=1\n        maxs.pop()\n        inds.pop()\n\n\n    #print(maxs)\n    #print(inds)\n    S = [0] * 4\n    for j in range(4):\n        if inds[j] != -1:\n            #print(A)\n            #print(inds[j])\n            S[j] = [s[inds[j]] for s in A]\n            #print(S[j])\n        else:\n            S[j] = [0] * n\n    #print(S)\n    print(fu(S))",
    "complexity": "np",
    "problem": "1209_E1",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,dp,greedy,sortings"
}
{
    "src": "yellow, blue = map(int, input().split())\nx, y, z = map(int, input().split())\nanswer1 = x*2+y-yellow\nanswer2 = z*3+y - blue\nif answer1 > 0:\n    if answer2 > 0:\n        print(answer1+answer2)\n    else:\n        print(answer1)\nelse:\n    if answer2 > 0:\n        print(answer2)\n    else:\n        print(0)\n",
    "complexity": "constant",
    "problem": "0912_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "#476B\nfrom math import factorial as fact\ns=input()\nt=input()\npos=s.count('+')-t.count('+')\nneg=s.count('-')-t.count('-')\nque=t.count('?')\nif pos<0 or neg<0:\n    print(0)\nelse:\n    print((fact(que)/(fact(pos)*fact(neg)))/(2**que))",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\nchet = 0\nne_chet = 0\nchet1 = []\nne_chet1 = []\nfor i in range(len(a)):\n    if a[i] % 2 == 0:\n        chet += 1\n        chet1.append(a[i])\n    else:\n        ne_chet += 1\n        ne_chet1.append(a[i])\n    if chet >= 1 and ne_chet >= 1 and (chet > 1 or ne_chet > 1):\n        break\nif chet == 1:\n    print(a.index(chet1[0]) + 1)\nelif ne_chet == 1:\n    print(a.index(ne_chet1[0]) + 1)\n",
    "complexity": "linear",
    "problem": "0025_A",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "from collections import deque\nfrom sys import stdin, stderr\nlines = deque(line.strip() for line in stdin.readlines())\n\ndef nextline():\n    return lines.popleft()\n\ndef types(cast, sep=None):\n    return tuple(cast(x) for x in strs(sep=sep))\n\ndef ints(sep=None):\n    return types(int, sep=sep)\n\ndef strs(sep=None):\n    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))\n\ndef signum(n):\n    return 1 if n > 0 else 0 if n == 0 else -1\n\ndef range_includes(i, j):\n    s = signum(j - i)\n    return range(i, j + s, s)\n\ndef main():\n    # lines will now contain all of the input's lines in a list\n    first = ints()\n    aCoords = tuple(first[i:i+2] for i in range(0, 8, 2))\n    minX = min(aCoord[0] for aCoord in aCoords)\n    minY = min(aCoord[1] for aCoord in aCoords)\n    maxX = max(aCoord[0] for aCoord in aCoords)\n    maxY = max(aCoord[1] for aCoord in aCoords)\n    def inFirst(x, y):\n        return x >= minX and x <= maxX and y >= minY and y <= maxY\n\n    second = ints()\n    bCoords = tuple(second[i:i+2] for i in range(0, 8, 2))\n    minSum = min(sum(bCoord) for bCoord in bCoords)\n    maxSum = max(sum(bCoord) for bCoord in bCoords)\n    minDiff = min(bCoord[0] - bCoord[1] for bCoord in bCoords)\n    maxDiff = max(bCoord[0] - bCoord[1] for bCoord in bCoords)\n    def inSecond(x, y):\n        return x + y >= minSum and x + y <= maxSum and x - y >= minDiff and x - y <= maxDiff\n\n    for aCoord in aCoords:\n        if inSecond(*aCoord):\n            return True\n    for i in range(-1, 3):\n        c1 = bCoords[i]\n        c2 = bCoords[i + 1]\n        for x, y in zip(range_includes(c1[0], c2[0]), range_includes(c1[1], c2[1])):\n            if inFirst(x, y):\n                return True\n    return False\n\nif __name__ == '__main__':\n    print(\"YES\" if main() else \"NO\")\n",
    "complexity": "constant",
    "problem": "0994_C",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "from sys import stdout\nm = 30\na, b = 0, 0\nfle = 1\nfor i in range(m):\n    if fle:\n        print('? {} {}'.format(a, b))\n        stdout.flush()\n        resp1 = int(raw_input())\n        fle = 0\n    print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i)))\n    stdout.flush()\n    resp2 = int(raw_input())\n    #print(resp1,resp2,a,b)\n    if resp1 == -1 and resp2 == 1:\n        b += 2**(m-1-i)\n        fle = 1\n    elif resp1 == 1 and resp2 == -1:\n        a += 2**(m-1-i)\n        fle = 1\n    else:\n        fle = 0\n        print('? {} {}'.format(a + 2**(m-1-i), b))\n        stdout.flush()\n        resp3 = int(raw_input())\n        if resp3 == -1:\n            b += 2**(m-1-i)\n            a += 2**(m-1-i)\n        #print(resp1,resp2,resp3,a,b)\nprint('! {} {}'.format(a,b))\nstdout.flush()",
    "complexity": "logn",
    "problem": "1088_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,constructive algorithms,implementation,interactive"
}
{
    "src": "import sys\ninput=sys.stdin.buffer.readline\nn,k=map(int,input().split())\narr=list(map(int,input().split()))\nd=[{} for i in range(11)]\nfor i in range(n):\n    st=arr[i]\n    for j in range(11):\n        r=st % k\n        try:\n            d[j][r]+=1\n        except KeyError:\n            d[j][r] =1\n        st*=10\ncount_pair=0\nfor i in arr:\n    st=str(i)\n    l=len(st)\n    mod_st=(k-(i % k)) %k\n    if mod_st in d[l]:\n        count_pair +=d[l][mod_st]\n        if int(st + st) %k==0:\n            count_pair -=1\nprint(count_pair)",
    "complexity": "nlogn",
    "problem": "1029_D",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "def binar(a,st,d):\n    if st==0:\n        return 1\n    \n    elif st==1:\n        return a%d\n    \n    return (   binar(a**2%d,st//2,d) *  binar(a, st%2,d)   )%d\n\nx,k=map(int,input().split())\n\nif x==0:\n\tprint(0)\n\texit()\n\nres= ((x*binar(2,k+1,1000000007)) - (binar(2,k,1000000007))+1)% 1000000007 \nprint(res)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import math\n\ndef getdt():\n    return map(int,input().split())\ndef calc(v0,v,a,x):\n    t = (v - v0)/a\n    x0 = v0 * t + 0.5*a*t*t\n    if x0>=x:\n        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)\n    return (x0,t)\ndef go(v0,v,a,x):\n    x0,t = calc(v0,v,a,x)\n    return t + (x-x0)/v\n\na,v = getdt()\nl,d,w = getdt()\nif w>v:\n    w = v\nx,t = calc(0,w,a,d)\nif x==d:\n    print(go(0,v,a,l))\nelse:\n    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))",
    "complexity": "constant",
    "problem": "0005_D",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "N = 1030\nMOD = int(1e9+7)\nc = [[0] * N for i in range(N)]\nfor i in range(N):\n    c[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, N):\n        c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD\n\narr = list(map(int, list(input())))\ncnt = int(input())\nif cnt == 0:\n    print(1)\n    exit()\n\ndp = [0] * N\nfor i in range(2, N):\n    dp[i] = dp[bin(i).count('1')] + 1\nres = 0\nfor i in range(1, N):\n    if dp[i] != cnt - 1:\n        continue\n    n, k = len(arr)-1, i\n    for pos in range(len(arr)):\n        if arr[pos] == 1:\n            res = (res + c[n][k]) % MOD\n            k -= 1\n        n -= 1\n    if n == -1 and k == 0:\n        res += 1\nif cnt == 1: \n    res -= 1\nprint(res)",
    "complexity": "linear",
    "problem": "0914_C",
    "from": "CODEFORCES",
    "tags": "brute force,combinatorics,dp"
}
{
    "src": "a, b= map(int,input().split())\n\nif a == b:\n    print(0)\n\nelse:\n    x = a ^ b\n    c = 0\n\n    while x:\n        x //= 2\n        c += 1\n\n    print(2**c-1)",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "# Author Name: Ajay Meena\n# Codeforce : https://codeforces.com/profile/majay1638\nimport sys\nimport math\nimport bisect\nimport heapq\nfrom bisect import bisect_right\nfrom sys import stdin, stdout\n\n# -------------- INPUT FUNCTIONS ------------------\n\n\ndef get_ints_in_variables(): return map(\n    int, sys.stdin.readline().strip().split())\n\n\ndef get_int(): return int(sys.stdin.readline())\n\n\ndef get_ints_in_list(): return list(\n    map(int, sys.stdin.readline().strip().split()))\ndef get_list_of_list(n): return [list(\n    map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n\ndef get_string(): return sys.stdin.readline().strip()\n\n# -------- SOME CUSTOMIZED FUNCTIONS-----------\n\n\ndef myceil(x, y): return (x + y - 1) // y\n\n# -------------- SOLUTION FUNCTION ------------------\n\n\ndef Solution(td, n, k):\n    # Write Your Code Here\n    mxHeap = []\n    td = sorted(td, key=lambda x: x[0])\n    prefix = []\n    tmp = 0\n    for v in td:\n        b = v[1]\n        tmpAns = tmp+b\n        if len(mxHeap) == k:\n            if len(mxHeap) and b > mxHeap[0]:\n                t = heapq.heappop(mxHeap)\n                heapq.heappush(mxHeap, b)\n                tmp -= t\n                tmp += b\n        elif len(mxHeap) < k:\n            tmp += b\n            heapq.heappush(mxHeap, b)\n        prefix.append([tmpAns, v[2]])\n\n    ans = [0 for _ in range(n)]\n    for v in prefix:\n        ans[v[1]] = v[0]\n    print(*ans)\n\n\ndef main():\n    # Take input Here and Call solution function\n    n, k = get_ints_in_variables()\n    a = get_ints_in_list()\n    b = get_ints_in_list()\n    td = [[a[i], b[i], i] for i in range(n)]\n    Solution(td, n, k)\n\n\n# calling main Function\nif __name__ == '__main__':\n    main()\n",
    "complexity": "nlogn",
    "problem": "0994_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "import sys\ninput = sys.stdin.readline\nfrom itertools import combinations\nfrom collections import defaultdict\nn,m = map(int,input().split())\na = [list(map(int,input().split())) for i in range(n)]\nmx = max(max(a[i]) for i in range(n))\nif n == 1:\n  print(1,1)\n  exit()\nl = 0\nr = mx+1\nwhile l+1 < r:\n  flg = 0\n  x = (l+r)//2\n  jud = set()\n  dc = defaultdict(int)\n  for i in range(n):\n    jnum = 0\n    for j in range(m):\n      if a[i][j] >= x:\n        jnum += 1<<j\n    if dc[jnum] == 0:\n      dc[jnum] = i+1\n    if jnum == (1<<m)-1:\n      flg = 1\n      if i == 0:\n        ans = (i+1,i+2)\n      else:\n        ans = (1,i+1)\n    jud.add(jnum)\n  for p,q in combinations(jud,2):\n    if p|q == (1<<m)-1:\n      flg = 1\n      ans = (dc[p],dc[q])\n  if flg:\n    l = x\n  else:\n    r = x\nif l == 0:\n  print(1,2)\nelse:\n  print(*ans)",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nok = False\nfor i in range(len(a)):\n    if (a[i] > min(a) ):\n        ans = a[i]\n        ok = True\n        break\nif (ok):\n    print(ans)\nelse:\n    print(\"NO\")",
    "complexity": "nlogn",
    "problem": "0022_A",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "n,l,r,x=map(int,input().split())\na=list(map(int,input().split()))\ncount=0\nt=0\nans=[]\nfor i in range(3,(2**n)+1):\n    c=i\n    ans=[]\n    sum=0\n    while c!=0:\n        c=c&(c-1)\n        count+=1\n    if count>1:\n        for j in range(n):\n            if i & (1 << j):\n                sum+=a[j]\n                ans.append(a[j])\n        if l<=sum<=r and (max(ans)-min(ans))>=x:\n            t+=1\nprint(t)\n",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "lis = list(map(int,input().split()))\nif lis[2] <= lis[0] and lis[2] <= lis[1]:\n\tif ((lis[0]+lis[1]) - lis[2]) < lis[3]:\n\t\tprint(lis[3] - ((lis[0]+lis[1]) - lis[2]))\n\telif sum(lis) == 0:\n\t\tprint(-1)\n\telif lis[0] == 0 and lis[1] == 0 and lis[2] == 0 :\n\t\tprint(lis[3])\n\telse:\n\t\tprint(-1)\nelse:\n\tprint(-1)\n\n\n\n\n\n\t\t\n\n\n\n",
    "complexity": "constant",
    "problem": "0991_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n = int(input())\nm = int(input())\nif(n<=26):\n    print(m%(2**n))\nelse:\n    print(m)\n    ",
    "complexity": "constant",
    "problem": "0913_A",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "n, k = [int(x) for x in input().split()]\nps = [int(x) for x in input().split()]\nmapping = [-1 for _ in range(256)]\n\nres = []\nfor p in ps:\n    if mapping[p] == -1:\n        j = p - k + 1\n        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):\n            j += 1\n        for i in range(j, p+1):\n            mapping[i] = j\n    res.append(mapping[p])\nprint(\" \".join(map(str, res)))",
    "complexity": "quadratic",
    "problem": "0980_C",
    "from": "CODEFORCES",
    "tags": "games,greedy"
}
{
    "src": "t=int(input())\nfor _ in range(t):\n\tn,k=list(map(int,input().split()))\n\tif n>=32:\n\t\tprint(\"YES \"+str(n-1))\n\telse:\n\t\tans=-1\n\t\tfor i in range(1,n+1):\n\t\t\tp=(4**i)-(2**(i+1))+1\n\t\t\tp*=(((4**(n-i))-1)//3)\n\t\t\tg=(((4**i)-1)//3)\n\t\t\tp+=(((4**i)-1)//3)\n\t\t\tg=(((4**i)-1)//3)-(((4**(i-1))-1)//3)\n\t\t\tif g<=k and p>=k:\n\t\t\t\tans=n-i\n\t\t\t\tbreak\n\t\tif ans!=-1:\n\t\t\tprint(\"YES \"+str(ans))\n\t\telse:\n\t\t\tprint(\"NO\")",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "N = int(input())\nX = list(map(int, input().split()))\nfrom collections import defaultdict\ndp = defaultdict(lambda :-1)\nfor i in range(N):\n    dp[i+1001] = X[i]\nfor i in range(2, N+1):\n    for j in range(N-i+1):\n        for k in range(1, i):\n            u, v = dp[j+1001*k], dp[j+k+1001*(i-k)]\n            if u == -1 or v == -1 or u != v:\n                continue\n            dp[j+1001*i] = u+1;break\n \n \n#print(dp)\ndp2 = [0]*(N+1)\nfor i in range(N):\n    dp2[i+1] = dp2[i]+1\n    if dp[1001*(i+1)] != -1:\n        dp2[i+1] = 1\n        continue\n    for j in range(i+1):\n        if dp[j+(i+1-j)*1001] == -1:\n            continue\n        dp2[i+1] = min(dp2[i+1], dp2[j]+1)\nprint(dp2[-1])",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\n\nans = 0\n\nfor mask in range(2**n):\n    cnt, csum = 0, 0\n    mn, mx = 10**18, -(10**18)\n    for i in range(n):\n        if (mask & (1 << i) != 0):\n            cnt += 1\n            csum += c[i]\n            mn = min(mn, c[i])\n            mx = max(mx, c[i])\n    if (cnt >= 2) and (csum >= l) and (csum <= r) and (mx - mn >= x):\n        ans += 1\n        \nprint(ans)\n    ",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "## \nmax_ = 10**18\narr  = [0, 1]\narr2 = [0, 3] \nwhile arr[-1] < max_:\n    arr.append(arr[-1]*4)\n    arr2.append(arr2[-1]*2+1)\n    \nfor i in range(1, len(arr)):\n    arr[i] += arr[i-1]\n    \ndef solve(n, k):\n    if n==2 and k==3:\n        return 'NO'\n    if n==2 and k==4:\n        return 'YES 0'\n    if n+1<=len(arr) and k > arr[n]:\n         return 'NO'\n        \n    i=0\n    while k >= arr[i+1]:\n        i+=1\n    if k-arr[i] > arr2[i]:\n        i+=1\n    return 'YES ' +str(n-i)    \n\nfor _ in range(int(input())):\n    n, k = map(int, input().split())\n    print(solve(n, k))",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "m = 10**18\n\ndef run():\n    n, k = [int(x) for x in input().split()]\n    currn, currs = 1, n\n    rem = 0\n\n    while True:\n        if k == 0:\n            print(f'YES {currs}')\n            return\n        if k < currn or currs == 0:\n            print('NO')\n            return\n        currs -= 1\n        k -= currn\n        if currs >= 40:\n            rem = m\n        else:\n            rem = min(m, rem + cc[currs]*((currn-1)*2+1))\n        currn = (currn - 1) * 2 + 3\n\n        if k <= rem:\n            print(f'YES {currs}')\n            return\n\n\ncc = [0, 1]\nfor i in range(2, 50):\n    cc.append(min(m, 1 + 4*cc[-1]))\nfor i in range(int(input())): run()\n",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "import sys\n\ndef main():\n\n    n,k=map(int,sys.stdin.readline().strip().split())\n    arr=list(map(int,sys.stdin.readline().strip().split()))\n    arr.sort()\n    dic={}\n    for a in arr:\n        if a/k not in dic:\n            dic[a]=1\n    \n    print(len(dic))\n\nmain()",
    "complexity": "nlogn",
    "problem": "0274_A",
    "from": "CODEFORCES",
    "tags": "binary search,greedy,sortings"
}
{
    "src": "n=int(input())\ns=list(map(int,input().split()))\nc=list(map(int,input().split()))\ndp=[float('inf')]*(n)\nfor i in range(1,n):\n    mn=float('inf')\n    for j in range(i):\n        if s[i]>s[j]:\n            mn=min(mn,c[i]+c[j])\n    dp[i]=mn\nres=float('inf')\nfor i in range(1,n):\n    for j in range(i):\n        if s[i]>s[j]:\n            res=min(res,c[i]+dp[j])\nif res==float('inf'):\n    res=-1\nprint(res)\n            \n    \n    ",
    "complexity": "quadratic",
    "problem": "0987_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,implementation"
}
{
    "src": "# B. Preparing Olympiad\n\ndef check_combination(v):\n    sm = sum(v)\n    if l <= sm <= r:\n        if max(v) - min(v) >= x:\n            global ans\n            ans += 1\n\n\ndef go(offset, k):\n    # https://stackoverflow.com/questions/12991758/creating-all-possible-k-combinations-of-n-items-in-c/28698654\n    if k == 0:\n        check_combination(combination)\n        return\n    for i in range(offset, len(problems) - k + 1):\n        combination.append(problems[i])\n        go(i+1, k-1)\n        combination.pop()\n\n\nn, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\n\nproblems = list()\ncombination = list()\n\nans = 0\n\nfor i in range(2, len(c) + 1):\n    problems = c.copy()\n    go(0, i)\n\nprint(ans)\n",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "def getsum(n):\n    return ((1 << (2*n)) - 1) // 3\n\ndef b(n, k):\n    l = n - 1\n    r = max(0, l - 41)\n    while True:\n        mid = (l + r) // 2\n        count = getsum(n - mid)\n        if count <= k:\n            l = mid\n        else:\n            r = mid\n        if l - r <= 1:\n            break\n        del count\n    g = getsum(n - r)\n    if g < k:\n        del g\n        return None\n    elif g == k:\n        del g\n        return r\n    return l        \n\n\nt = int(input())\nfor i in range(t):\n    n, k = map(int, input().split())\n    min_side = b(n, k)\n    if min_side is None:\n        print('NO')\n        continue\n    k -= getsum(n - min_side)\n    if n == 2 and min_side == 1 and k == 2:\n        print('NO')\n        continue\n    num_squares = (1 << (n - min_side)) * 2 - 1\n    if k >= num_squares:\n        print('YES ' + str(min_side - 1))\n    else:\n        print('YES ' + str(min_side))",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\nimport math as mt\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef lcm(a, b):\n    return (a * b) / gcd(a, b)\n\n\nmod = int(1e9) + 7\n\n\ndef power(k, n):\n    if n == 0:\n        return 1\n    if n % 2:\n        return (power(k, n - 1) * k) % mod\n    t = power(k, n // 2)\n    return (t * t) % mod\n\n\ndef totalPrimeFactors(n):\n    count = 0\n    if (n % 2) == 0:\n        count += 1\n        while (n % 2) == 0:\n            n //= 2\n\n    i = 3\n    while i * i <= n:\n        if (n % i) == 0:\n            count += 1\n            while (n % i) == 0:\n                n //= i\n        i += 2\n    if n > 2:\n        count += 1\n    return count\n\n\n# #MAXN = int(1e7 + 1)\n# # spf = [0 for i in range(MAXN)]\n#\n#\n# def sieve():\n#     spf[1] = 1\n#     for i in range(2, MAXN):\n#         spf[i] = i\n#     for i in range(4, MAXN, 2):\n#         spf[i] = 2\n#\n#     for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n#         if (spf[i] == i):\n#             for j in range(i * i, MAXN, i):\n#                 if (spf[j] == j):\n#                     spf[j] = i\n#\n#\n# def getFactorization(x):\n#     ret = 0\n#     while (x != 1):\n#         k = spf[x]\n#         ret += 1\n#         # ret.add(spf[x])\n#         while x % k == 0:\n#             x //= k\n#\n#     return ret\n\n\n# Driver code\n\n# precalculating Smallest Prime Factor\n# sieve()\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[a[i]] = i\n    found=[-1, -1, -1]\n    found2=[-1, -1]\n    for i in range(n):\n        c=1\n        while c<(1<<31):\n            if a[i]- c in d.keys() and a[i]+c in d.keys():\n                found[0]=a[i]-c\n                found[1]=a[i]\n                found[2]=a[i]+c\n            if a[i]- c in d.keys() :\n                found2=[a[i], a[i]-c]\n            if a[i]+ c in d.keys() :\n                found2=[a[i], a[i]+c]\n            c*=2\n    if found[0]==found[1]:\n        if found2[0]==found2[1]:\n            print(1)\n            print(a[0])\n        else:\n            print(2)\n            print(*found2)\n    else:\n        print(3)\n        print(*found)\n\n\n\n\n\n\n\n\n\n\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "complexity": "nlogn",
    "problem": "0988_D",
    "from": "CODEFORCES",
    "tags": "brute force,math"
}
{
    "src": "# from typing import List, Set, Dict, Tuple, Text, Optional\nfrom collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__  # type: ignore\n\n#########\n# INPUT #\n#########\n\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n    # type: () -> str\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\n##########\n# OUTPUT #\n##########\n\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n    # type: (str) -> None\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n    # type: (str) -> None\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\n###########\n# LIBRARY #\n###########\n\n\ndef bootstrap(f, stack=[]):\n  # Deep Recursion helper.\n  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst\n  # Usage:\n\n  # @bootstrap\n  # def recur(n):\n  #   if n == 0:\n  #     yield 1\n  #   yield (yield recur(n-1)) * n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\n\n'''\narrayInit([3, 4, 5], 0):\nInitialize 3-dim array with [3][4][5] with 0 as its initial value\n\nTested with:\nhttps://codeforces.com/contest/625/problem/B\n'''\n\n\nclass MDArray(object):\n  # Faster implementation of md array, using a single array and a lot of math.\n  '''\n  >>> x = MDArray([1, 2, 5], 5)\n  >>> x.get([0, 0, 0])\n  5\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.set([0, 1, 2], 3)\n  3\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.set([0, 1, 3], 1)\n  1\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.get([0, 1, 3])\n  1\n  '''\n\n  def __init__(self, dimensions, initial_value=0):\n    # type: (Iterable[int], Any) -> None\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n    # type: (Iterable[int]) -> Any\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n    # type: (Iterable[int], Any) -> Any\n    self.arr[self._index(indexes)] = value\n    return value\n\n\n#########\n# LOGIC #\n#########\n\ndef encode(row, col, n, m):\n  return row * m + col\n\n\ndef solve(node, remain, adj, dp):\n  if remain == 0:\n    return 0\n  key = (node, remain)\n  mem = dp.get(key)\n  if mem != -1:\n    return mem\n\n  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))\n  dp.set(key, ans)\n  return ans\n\n\ndef main(inp, out):\n  # type: (Input, Output) -> any\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = [-1] * (n*m*(k/2+1))\n\n  for i in range(n*m):\n    dp[i] = 0\n\n  for t in range(1, k/2+1):\n    for i in range(n*m):\n      ans = min(map(lambda x: dp[x[0]+((t-1)*n*m)] + x[1], adj[i]))\n      dp[i+(t*n*m)] = ans\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(dp[node+(k/2*n*m)] * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\n\n###############\n# BOILERPLATE #\n###############\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "def rec(r,g,b):\n    if(dp[r][g][b]!=-1):\n        return dp[r][g][b]\n    ans=0\n    if r<R and g<G:\n        ans=max(ans, red[r]*green[g]+rec(r+1, g+1, b))\n    if r<R and b<B:\n        ans=max(ans, red[r]*blue[b]+rec(r+1, g, b+1))\n    if b<B and g<G:\n        ans=max(ans, blue[b]*green[g]+rec(r, g+1, b+1))\n    dp[r][g][b]=ans\n    return ans\nR,G,B=map(int,input().split())\nred=sorted(list(map(int, input().split())), reverse=True)\ngreen=sorted(list(map(int, input().split())), reverse=True)\nblue=sorted(list(map(int, input().split())), reverse=True)\ndp=[[[-1]*(B+1) for _ in range(G+1)] for _ in range(R+1)]\nprint(rec(0,0,0))",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "from math import factorial,pow\nsend = input()\nreceived = input()\n\npos = 0\nfor p in send:\n\tpos = pos +1 if p=='+' else pos-1\nqcount = 0\ncurr_pos = 0\nfor p in received:\n\tif p=='+':\n\t\tcurr_pos = curr_pos +1  \n\telif(p=='-'):\n\t\tcurr_pos = curr_pos-1\n\tif p=='?':\n\t\tqcount +=1\n\nif qcount == 0:\n\tprint(\"{:.12f}\".format(1.0 if pos==curr_pos else 0.0))\nelse:\n\texp_val_q = abs(pos -curr_pos)\n\tif exp_val_q%2!=qcount%2 or qcount<exp_val_q:\n\t\tprint(\"{:.12f}\".format(0.0))\n\telse:\n\t\tneg = (qcount - exp_val_q)/2\n\t\tposi = qcount - neg\n\t\tval = factorial(qcount)/(factorial(neg)*factorial(posi)*pow(2,qcount))\n\t\tprint(\"{:.12f}\".format(val))\n\n\n\n",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "import sys\nimport bisect\nfrom bisect import bisect_left as lb\ninput_=lambda: sys.stdin.readline().strip(\"\\r\\n\")\nfrom math import log\nfrom math import gcd\nfrom math import atan2,acos\nfrom random import randint\nsa=lambda :input_()\nsb=lambda:int(input_())\nsc=lambda:input_().split()\nsd=lambda:list(map(int,input_().split()))\nsflo=lambda:list(map(float,input_().split()))\nse=lambda:float(input_())\nsf=lambda:list(input_())\nflsh=lambda: sys.stdout.flush()\n#sys.setrecursionlimit(10**6)\nmod=10**9+7\ngp=[]\ncost=[]\ndp=[]\nmx=[]\nans1=[]\nans2=[]\nspecial=[]\nspecnode=[]\na=0\nkthpar=[]\ndef dfs(root,par):\n    if par!=-1:\n        dp[root]=dp[par]+1\n    for i in range(1,20):\n        if kthpar[root][i-1]!=-1:\n            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]\n    for child in gp[root]:\n        if child==par:continue\n        kthpar[child][0]=root\n        dfs(child,root)\nans=0\ndef hnbhai(t):\n    n=sb()\n    p=[]\n    for i in range(n):\n        p.append(sflo())\n    #print(p)\n    dp=[0]*(1<<n)\n    dp[1]=1\n    for i in range(2,1<<n):\n        for j in range(1,n):\n            for k in range(0,j):\n                if (i>>j)&1 and (i>>k)&1:\n                    dp[i]=max(dp[i],dp[i^(1<<j)]*p[k][j]+dp[i^(1<<k)]*p[j][k])\n    #print(dp)\n    print(dp[-1])\nfor _ in range(1):\n    hnbhai(_+1)\n",
    "complexity": "np",
    "problem": "0678_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,math,probabilities"
}
{
    "src": "import math\ns1=list(input())\ns2=list(input())\np1,m1,p2,m2,c=0,0,0,0,0\nfor i in range(len(s1)):\n\tif(s1[i]=='+'):\n\t\tp1+=1\n\tif(s1[i]=='-'):\n\t\tm1+=1\n\tif(s2[i]=='+'):\n\t\tp2+=1\n\tif(s2[i]=='-'):\n\t\tm2+=1\n\tif(s2[i]=='?'):\n\t\tc+=1\np=abs(p1-p2)\nm=abs(m1-m2)\nif((p+m)==c):\n\tprint(math.factorial(c)/(math.factorial(p)*math.factorial(m)*pow(2,c)))\nelse:\n\tprint(0/1)",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "l, r = map(int, input().split())\n\nif l == r:\n    print(0)\n    exit()\nbinr, binl = bin(r)[2:], bin(l)[2:]\nbinl = '0' * (len(binr) - len(binl)) + binl\n# print(binl, binr)\nfor i in range(len(binl)):\n    if binl[i] != binr[i]:\n        binl = '1' * len(binl[i:])\n        break\n\nprint(int(binl, 2))\n",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "def cal(r, g, b):\n\tif dp[r][g][b] != -1:\n\t\treturn dp[r][g][b]\n\n\tarea = 0\n\tif r<R and g<G:\n\t\tarea = max(area, rl[r] * gl[g] + cal(r+1, g+1, b))\n\tif r<R and b<B:\n\t\tarea = max(area, rl[r] * bl[b] + cal(r+1, g, b+1))\n\tif g<G and b<B:\n\t\tarea = max(area, gl[g] * bl[b] + cal(r, g+1, b+1))\n\tdp[r][g][b] = area\n\treturn area\n\nif __name__ == \"__main__\":\n\tR, G, B = map(int,input().split())\n\trl = sorted(list(map(int,input().split())), reverse=True)\n\tgl = sorted(list(map(int,input().split())), reverse=True)\n\tbl = sorted(list(map(int,input().split())), reverse=True)\n\tdp = [[[-1]*(B+1) for i in range(G+1)] for i in range(R+1)]\n\tprint(cal(0,0,0))\n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "import math,sys,bisect,heapq,os\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\nfrom functools import lru_cache\n#sys.setrecursionlimit(200000000)\nint1 = lambda x: int(x) - 1\ndef input(): return sys.stdin.readline().rstrip('\\r\\n')\n#input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\naj = lambda: list(map(int, input().split()))\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n#MOD = 1000000000 + 7\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\n\n\ndef solve():\n\tG = defaultdict(list)\n\n\tdef addEdge(a,b):\n\t\tG[a].append(b)\n\n\tdef Kahn(N):\n\t    in_degree = [0]*(N+1)\n\t    for i in G.keys():\n\t        for j in G[i]:\n\t            in_degree[j] += 1\n\t    queue = deque()\n\t    for i in range(1,N+1):\n\t        if in_degree[i] == 0:\n\t            queue.append(i)\n\t    cnt =0\n\t    top_order = []\n\t    while queue:\n\t        u = queue.popleft()\n\t        top_order.append(u)\n\t        for i in G.get(u,[]):\n\t            in_degree[i] -= 1\n\t            if in_degree[i] == 0:\n\t                queue.append(i)\n\t        cnt += 1\n\t    if cnt != N:\n\t        Y(0);exit(0)\n\t    else:\n\t        Y(1);print(*top_order)\n\n\tn,m,k = aj()\n\tmark= {}\n\tfor i in range(n):\n\t\ts = input()\n\t\tmark[s] = i+1\n\n\tB = []\n\tfor i in range(2**k):\n\t\tf = bin(i)[2:]\n\t\tf = '0'*(k - len(f)) + f\n\t\tB.append(f)\n\n\tfor i in range(m):\n\t\ts,mt = input().split(\" \")\n\t\tmt = int(mt)\n\t\tst = set()\n\t\tfor j in B:\n\t\t\tss = ['']*k\n\t\t\tfor l in range(k):\n\t\t\t\tif j[l] == '1':\n\t\t\t\t\tss[l] = s[l]\n\t\t\t\telse:\n\t\t\t\t\tss[l] = '_'\n\t\t\tss = \"\".join(ss)\n\t\t\tif ss in mark:\n\t\t\t\tst.add(mark[ss])\n\t\t#print(st)\n\t\tif mt not in st:\n\t\t\tY(0);exit(0)\n\t\tst.discard(mt)\n\t\tfor j in st:\n\t\t\taddEdge(mt,j)\n\t#print(G)\n\tKahn(n)\n\n\ntry:\n\t#os.system(\"online_judge.py\")\n\tsys.stdin = open('input.txt', 'r') \n\tsys.stdout = open('output.txt', 'w')\nexcept:\n\tpass\n\nsolve()",
    "complexity": "np",
    "problem": "1476_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"
}
{
    "src": "t=list(map(int,input().split()))\nn=t[0]\nc=t[1]\na=list(map(int,input().split()))\nf=[]\nfor i in range(0,500001):\n\tf.append(0)\nl=[]\nfor i in range(0,500001):\n\tl.append([0])\nm=0\nfor i in range(n):\n\tl[a[i]].append(f[a[i]]-m)\n\tif a[i]==c:\n\t\tm+=1\n\tf[a[i]]+=1\n\tl[a[i]].append(f[a[i]]-m)\nma=0\nfor i in l:\n\tmi=0\n\tfor j in i:\n\t\tif(j<mi):\n\t\t\tmi=j\n\t\tif(ma<j-mi):\n\t\t\tma=j-mi\nprint(m+ma)",
    "complexity": "linear",
    "problem": "1082_E",
    "from": "CODEFORCES",
    "tags": "binary search,dp,greedy"
}
{
    "src": "import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int,sys.stdin.readline().strip().split()))\n\nfor i in range (0, n):\n    if a[i] >= 0:\n        a[i] = - a[i] - 1\n\nif n % 2 == 1:\n    i = a.index(min(a))\n    a[i] = - a[i] - 1\n\na = list(map(str,a))\nprint(\" \".join(a))\n\n",
    "complexity": "linear",
    "problem": "1180_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation"
}
{
    "src": "n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2024)]\n \nd = [[] for _ in range(n)]\nfor j, v in enumerate(b):\n\te[v][j] = j\n\td[j].append(j)\n \nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n \na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])\n\t\t\t\t \t\t  \t\t\t\t\t  \t \t\t\t\t\t \t \t \t\t\t",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import sys, math\nimport io, os\n# data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\n# from heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n# from itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\n# from fractions import Fraction\n# sys.setrecursionlimit(100000)\nINF = 10001\nmod = int(1e9) + 7\n\n\nn=int(data())\na=mdata()\nans=[n]\ndp1=[[0]*n for i in range(n)]\ndp2=[[n]*n for i in range(n)]\nfor i in range(n-1,-1,-1):\n    dp1[i][i]=a[i]\n    dp2[i][i]=1\n    for j in range(i+1,n):\n        for k in range(i,j):\n            if dp1[i][k] == dp1[k+1][j] != 0:\n                dp1[i][j] = dp1[i][k] + 1\n                dp2[i][j] = 1\n            dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j])\nout(dp2[0][n-1])",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "\nimport sys\ninput = sys.stdin.buffer.readline\n\nn,k=map(int,input().split())\narr=[int(x) for x in input().split()]\n\nx=0\ndp=[]\nfor i in range(n):\n    x=x+arr[i]\n    dp.append(x)\n\nans=0\nfor i in range(n):\n    for j in range(i+k-1,n):\n        ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1))\nprint(ans) ",
    "complexity": "quadratic",
    "problem": "1003_C",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,math"
}
{
    "src": "from sys import stdin, stdout\nfrom math import gcd\ninput = stdin.buffer.readline\n\nx, k = map(int, input().split())\nif x == 0:\n\tprint(0)\n\texit()\nx *= 2\nmod = 1000000007\nx = pow(2, k, mod) * x % mod - (pow(2, k, mod) - 1)\nprint(x % mod)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "'''\n      ___           ___                         ___                       ___           ___                         ___\n     /\\__\\         /\\  \\         _____         /\\  \\                     /\\  \\         /\\  \\                       /\\__\\\n    /:/ _/_        \\:\\  \\       /::\\  \\        \\:\\  \\       ___         /::\\  \\       |::\\  \\         ___         /:/ _/_\n   /:/ /\\  \\        \\:\\  \\     /:/\\:\\  \\        \\:\\  \\     /\\__\\       /:/\\:\\__\\      |:|:\\  \\       /\\__\\       /:/ /\\  \\\n  /:/ /::\\  \\   ___  \\:\\  \\   /:/  \\:\\__\\   ___ /::\\  \\   /:/__/      /:/ /:/  /    __|:|\\:\\  \\     /:/  /      /:/ /::\\  \\\n /:/_/:/\\:\\__\\ /\\  \\  \\:\\__\\ /:/__/ \\:|__| /\\  /:/\\:\\__\\ /::\\  \\     /:/_/:/__/___ /::::|_\\:\\__\\   /:/__/      /:/_/:/\\:\\__\\\n \\:\\/:/ /:/  / \\:\\  \\ /:/  / \\:\\  \\ /:/  / \\:\\/:/  \\/__/ \\/\\:\\  \\__  \\:\\/:::::/  / \\:\\~~\\  \\/__/  /::\\  \\      \\:\\/:/ /:/  /\n  \\::/ /:/  /   \\:\\  /:/  /   \\:\\  /:/  /   \\::/__/       ~~\\:\\/\\__\\  \\::/~~/~~~~   \\:\\  \\       /:/\\:\\  \\      \\::/ /:/  /\n   \\/_/:/  /     \\:\\/:/  /     \\:\\/:/  /     \\:\\  \\          \\::/  /   \\:\\~~\\        \\:\\  \\      \\/__\\:\\  \\      \\/_/:/  /\n     /:/  /       \\::/  /       \\::/  /       \\:\\__\\         /:/  /     \\:\\__\\        \\:\\__\\          \\:\\__\\       /:/  /\n     \\/__/         \\/__/         \\/__/         \\/__/         \\/__/       \\/__/         \\/__/           \\/__/       \\/__/\n\n'''\n\"\"\"\n\u2591\u2591\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\n\u2591\u2584\u2580\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2591\u2588\u2591\n\u2591\u2588\u2591\u2584\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2584\u2591\u2588\u2591\n\u2591\u2588\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2588\u2591\n\u2591\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2591\n\u2584\u2588\u2580\u2588\u2580\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2580\u2580\u2588\u2588\u2588\n\u2588\u2588\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2588\u2588\n\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2580\u2591\u2591\u2591\u2591\u2580\u2588\u2591\u2591\u2591\u2591\u2588\u2588\n\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\u2588\n\u2591\u2580\u2588\u2588\u2588\u2584\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2588\u2588\u2588\u2580\u2591\n\u2591\u2591\u2591\u2580\u2588\u2588\u2584\u2591\u2580\u2588\u2588\u2580\u2591\u2584\u2588\u2588\u2580\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\"\"\"\nimport sys\nimport math\nimport collections\nimport operator as op\nfrom collections import deque\nfrom math import gcd, inf, sqrt, pi, cos, sin, ceil, log2, floor, log\nfrom bisect import bisect_right, bisect_left, bisect\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\nfrom functools import reduce\nfrom sys import stdin, stdout, setrecursionlimit\nsetrecursionlimit(2**20)\n\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(op.mul, range(n, n - r, -1), 1)\n    denom = reduce(op.mul, range(1, r + 1), 1)\n    return numer // denom  # or / in Python 2\n\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return (list(factors))\n\n\ndef isPowerOfTwo(x):\n    return (x and (not(x & (x - 1))))\n\nMOD = 1000000007\nPMOD = 998244353\nN = 10**18 + 1\nLOGN = 30\nalp = 'abcdefghijklmnopqrstuvwxyz'\nT = 1\n# T = int(stdin.readline())\nfor _ in range(T):\n    n, k = list(map(int, stdin.readline().rstrip().split()))\n    # n = int(stdin.readline())\n    # a = list(map(int, stdin.readline().rstrip().split()))\n    # b = list(map(int, stdin.readline().rstrip().split()))\n    # s = str(stdin.readline().strip('\\n'))\n    # s = list(stdin.readline().strip('\\n'))\n    # m = int(stdin.readline())\n    # c = list(map(int, stdin.readline().rstrip().split()))\n    det = (int(sqrt(9 + 8 * (n + k)) - 3)) // 2\n    print(n - det)\n",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "n=int(input())\nc=0\nlst=[4,7,47,74,447,474,744,477,747,774]\nif n in lst:\n    print(\"YES\")\nelse:\n    for i in lst:\n        if n%i==0:\n            print(\"YES\")\n            c=c+1\n            break\n        else:\n            continue\n    if c==0:\n        print(\"NO\")\n    \n",
    "complexity": "constant",
    "problem": "0122_A",
    "from": "CODEFORCES",
    "tags": "brute force,number theory"
}
{
    "src": "import os, sys\nfrom io import BytesIO, IOBase\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\nvalid = lambda x, y: -1 < x < n and -1 < y < m\ndx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)\n\nn, m, k = inp(int)\nif k & 1:\n    [print(*([-1] * m)) for _ in range(n)]\n    exit()\n\nright, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]\nmem = [[[float('inf')] * (k // 2 + 1) for _ in range(m + 1)] for _ in range(n + 1)]\n\nfor _ in range(n):\n    for i, j in enumerate(inp(int)):\n        right[_][i] = j\n\nfor _ in range(n - 1):\n    for i, j in enumerate(inp(int)):\n        down[_][i] = j\n\nfor i in range(n):\n    for j in range(m):\n        mem[i][j][0] = 0\n\nfor k1 in range(1, k // 2 + 1):\n    for i in range(n):\n        for j in range(m):\n            ans = []\n            ans.append(mem[i - 1][j][k1 - 1] + down[i - 1][j])\n            ans.append(mem[i + 1][j][k1 - 1] + down[i][j])\n            ans.append(mem[i][j - 1][k1 - 1] + right[i][j - 1])\n            ans.append(mem[i][j + 1][k1 - 1] + right[i][j])\n            mem[i][j][k1] = min(ans)\n\n[print(*[mem[i][x][-1] * 2 for x in range(m)]) for i in range(n)]\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "inp = list(map(int, input().strip().split()))\nmoves = inp[0]\ncandiesAtTheEnd = inp[1]\n\ndef find(moves, candiesAtTheEnd):\n  result = -1\n  start = 0\n  end = moves-1\n  while result!=candiesAtTheEnd:\n    #print(\"start: \",start, \", end: \", end)\n    mid=((end-start+1)//2)+start\n    #print(\"mid: \", mid)\n    pluses=moves-mid\n    minuses=mid\n    #print(\"pluses: \", pluses, \", minuses: \", minuses)\n    result=((pluses+1)/2)*pluses\n    result=result-minuses\n    #print(\"result: \", result)\n    if result==candiesAtTheEnd:\n      return minuses\n    elif result>candiesAtTheEnd:\n      start=mid\n    else:\n      end=mid\n    \n\nresult_final=find(moves,candiesAtTheEnd)\nprint(result_final)\n",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "t = int(input())\n\ndef get_max(n):\n    ans = 0\n    while n:\n        ans = 4 * ans + 1\n        n = n - 1\n        if ans > 10**19:\n            break\n    return ans\n\nfor _ in range(t):\n    n, k = map(int, input().split())\n    if n == 1:\n        if k == 1:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    elif n == 2:\n        if k <= 2:\n            print(\"YES 1\")\n        elif k != 3 and k <= 5:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    else:\n        siz = n - 1\n        l = 1\n        cnt = 3\n        while siz:\n            if l <= k < l+cnt:\n                print(\"YES {}\".format(siz))\n                break\n            l = l + cnt\n            cnt = 2 * cnt + 1\n            siz = siz - 1\n        else:\n            if k <= get_max(n):\n                print(\"YES 0\")\n            else:\n                print(\"NO\")\n",
    "complexity": "linear",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "n, s = map(int, input().split())\nprint((s + n - 1) // n)",
    "complexity": "constant",
    "problem": "1061_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "def main():\n    def solve():\n        n = int(input())\n        arr = sorted(map(int, input().split()))\n        a = arr[-2]\n        print(min(n - 2, a - 1))\n    \n    import sys\n    input = sys.stdin.readline\n    \n    for _ in range(int(input())):\n        solve()\n    \n    return 0\n\nmain()",
    "complexity": "nlogn",
    "problem": "1197_A",
    "from": "CODEFORCES",
    "tags": "greedy,math,sortings"
}
{
    "src": "from sys import stdin, stdout\n\nnxt = []\n\ndef find_it(s, left, right):\n    global nxt\n    dp = [[1000 for i in range(len(right) + 1)] for j in range(len(left) + 1)]\n    dp[0][0] = 0\n    for i in range(len(left)+1):\n        for j in range(len(right)+1):\n            if dp[i][j] > len(s):\n                continue\n            if j < len(right) and nxt[ord(right[j]) - 97][dp[i][j]] != -1:\n                if nxt[ord(right[j]) - 97][dp[i][j]] < dp[i][j+1]:\n                    dp[i][j+1] = nxt[ord(right[j]) - 97][dp[i][j]] +1\n            if i < len(left) and nxt[ord(left[i]) - 97][dp[i][j]] != - 1:\n                if nxt[ord(left[i]) - 97][dp[i][j]] < dp[i+1][j]:\n                    dp[i+1][j] = nxt[ord(left[i]) - 97][dp[i][j]] +1\n    if dp[len(left)][len(right)] != 1000:\n        return True\n    else:\n        return False\n\ndef main():\n    global nxt\n    n = int(stdin.readline())\n    for _ in range(n):\n        s = stdin.readline().rstrip()\n        t = stdin.readline().rstrip()\n        nxt = [[-1 for _ in range(len(s)+1)] for i in range(26)] \n        for i,x in enumerate(s):\n            nxt[ord(x) - 97][i] = i\n        for i in range(26):\n            for j in range(len(s)-1 ,-1,-1):\n                if nxt[i][j] != j:\n                    nxt[i][j] = nxt[i][j+1]\n        \n        r = False            \n        for i in range(len(t)):\n            res = find_it(s, t[:i], t[-len(t)+i:])\n            if res is True:\n                r = True\n                break\n        \n        if r is True:\n            stdout.write(\"YES\\n\")\n        else:\n            stdout.write(\"NO\\n\")\n            \n\nmain()            ",
    "complexity": "cubic",
    "problem": "1303_E",
    "from": "CODEFORCES",
    "tags": "dp,strings"
}
{
    "src": "n,m = map(int,input().split())\nprint(n*\"8\")\nprint((n-1)*\"1\"+\"2\")",
    "complexity": "constant",
    "problem": "1028_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "import sys\nlines = int(sys.stdin.readline())\ndp = [0] * lines\nf = 1\ndp[0] = 1\n\nfor i in range(lines):\n  char_in = sys.stdin.readline()[0]\n  if char_in == 'f':\n    f += 1\n  else:\n    # num ways to write the statements\n    # the more for loops, the more we can combination\n    # any single statement can be the indent of anything previously\n    # sum over previous, but also update all of previous\n    for j in range(1, f):\n      dp[j] = (dp[j] + dp[j- 1]) % 1000000007\nprint(dp[f - 1])",
    "complexity": "quadratic",
    "problem": "0909_C",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "n = int(input())\n\nif n>=2:\n    print(25)\n",
    "complexity": "constant",
    "problem": "0630_A",
    "from": "CODEFORCES",
    "tags": "number theory"
}
{
    "src": "from collections import defaultdict\nfrom sys import stdin\ninput = stdin.readline\ndef check(mid, m):\n    d = defaultdict(int)\n    for idx, i in enumerate(a):\n        string = ''\n        for j in i:\n            if j >= mid:\n                string+='1'\n            else:\n                string+='0'\n        d[int(string, 2)] = idx\n    for i in d.keys():\n        for j in d.keys():\n            if i|j == 2**m - 1:\n                 return [d[i], d[j]]\n    return []\ndef binarySearch(lo, hi, m):\n    ans = []\n    while lo < hi:\n        mid = lo + (hi-lo+1)//2\n        x = check(mid, m)\n        if x:\n            lo = mid\n            ans = [x[0]+1, x[1]+1]\n        else:\n            hi = mid-1\n    return ans\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\nprint(*binarySearch(-1, 10**9+1, m))",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "\n\n\ndef solve(matrix, col, N, M):\n    if col == M:\n        '''\n        for row in matrix:\n            print(row)\n        print()\n        '''\n\n        ans = 0\n        for row in matrix:\n            if len(row) == 1:\n                ans += row[0]\n            else:\n                ans += max(*row)\n\n        return ans\n\n    # girar la columna `col` N - 1 veces\n\n    if N == 1:\n        return solve(matrix, col + 1, N, M)\n\n    ans = solve(matrix, col + 1, N, M)\n    for _ in range(N-1):\n        tmp = matrix[0][col]\n        for n in range(1, N):\n            matrix[n-1][col] = matrix[n][col]\n        matrix[N-1][col] = tmp\n\n        local_ans = solve(matrix, col + 1, N, M)\n        if local_ans > ans:\n            ans = local_ans\n\n    return ans\n\ndef main():\n    T = int(input())\n    for t in range(T):\n        N, M = list(map(lambda x: int(x), input().split()))\n\n        matrix = []\n        for n in range(N):\n            matrix.append(\n                list(map(lambda x: int(x), input().split()))\n            )\n\n        elements = []\n        for n in range(N):\n            for m in range(M):\n                elements.append((matrix[n][m], m))\n\n        elements.sort(reverse=True)\n\n        candidates = []\n        for t in elements:\n            if t[1] not in candidates:\n                candidates.append(t[1])\n                if len(candidates) == N:\n                    break\n\n        simplified = []\n        for n in range(N):\n            row = []\n            for m in candidates:\n                row.append(matrix[n][m])\n            simplified.append(row)\n\n        ans = solve(simplified, 0, N, min(N, M))\n        print(ans)\n\nmain()\n",
    "complexity": "np",
    "problem": "1209_E1",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,dp,greedy,sortings"
}
{
    "src": "c = [[0 for i in range(5205)] for j in range(5205)]\nK = 998244353\ninv = [0 for i in range(5205)]\n\ndef mu(a, n):\n\tif n == 0: return 1\n\tq = mu(a, n // 2)\n\tif n % 2 == 0:\n\t\treturn q * q % K\n\telse: return q * q % K * a % K\n\ndef calc(m, d, S):\n\tres = 0\n\tif m == 0:\n\t\tif S == 0: return 1\n\t\treturn 0\n\n\tfor u in range(0, m + 1):\n\t\tif (u * d > S): break\n\t\tU = c[m][u] * c[S - u * d + m - 1][m - 1] % K \n\t\tif u % 2 == 0:\n\t\t\tres = (res + U) % K\n\t\telse: res = (res - U + K) % K \n\treturn res\n\n\nc[0][0] = 1\ninv[0] = 1\nfor i in range(1, 5101):\n\tinv[i] = mu(i, K - 2)\n\nfor i in range(1, 5101):\n\tc[i][0] = 1\n\tfor j in range (1, i):\n\t\tc[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K\n\tc[i][i] = 1\n\np, s, r = map(int, input().split())\n\nres = 0\nden = 0\n\nfor i in range(1, p + 1):\n\tA = 0\n\tfor d in range(r, s // i + 1):\n\t\tif (i < p): A = (A + calc(p - i, d, s - d * i)) % K\n\t\telse:\n\t\t\tif (s - i * d == 0): A += 1\n\tA = A * inv[i] % K\n\tres = (res + A * c[p - 1][i - 1] % K) % K\n\nden = c[s - r + p - 1][p - 1]\nres = res * mu(den, K - 2) % K\nprint(res)\n\n\n",
    "complexity": "cubic",
    "problem": "1096_E",
    "from": "CODEFORCES",
    "tags": "combinatorics,dp,math,probabilities"
}
{
    "src": "n = int(input())\nboard = list(map(int,input().split(\" \")))\nindex = list(range(0,n))\nascending = [x for _,x in sorted(zip(board,index))]\n\nwinners = n * [\"\"]\n\n\nfor c in reversed(ascending):\n\tif board[c] == n:\n\t\twinners[c] = \"B\"\n\t# going down\n\ttoCheck = c - board[c]\n\twhile(toCheck >= 0):\n\t\tif winners[toCheck] == \"B\":\n\t\t\twinners[c] = \"A\"\n\t\ttoCheck = toCheck - board[c]\n\tif winners[c] == \"\":\n\t\ttoCheck = c + board[c]\n\t\twhile(toCheck < n):\n\t\t\tif winners[toCheck] == \"B\":\n\t\t\t\twinners[c] = \"A\"\n\t\t\ttoCheck = toCheck + board[c]\n\tif winners[c] == \"\":\n\t\twinners[c] = \"B\"\n\t#print(\"board at c\",board[c])\n\t#print(c)\n\t#print(winners)\n\nfor i in range(n):\n\tprint(winners[i],end=\"\")\nprint()\n\t\t\n\t\n\n",
    "complexity": "nlogn",
    "problem": "1033_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,games"
}
{
    "src": "# import itertools\n# import bisect\n# import math\nfrom collections import defaultdict, Counter\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n# sys.setrecursionlimit(10 ** 5)\nii = lambda: int(input())\nlmii = lambda: list(map(int, input().split()))\nslmii = lambda: sorted(map(int, input().split()))\nli = lambda: list(input())\nmii = lambda: map(int, input().split())\nmsi = lambda: map(str, input().split())\n\n\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\n\ndef lcm(a, b): return (a * b) // gcd(a, b)\n\n\ndef main():\n    # for _ in \" \" * int(input()):\n    w, h, n = mii()\n    ws, dws, hs, dhs, hsm, wsm = SortedList([]), defaultdict(int), SortedList([]), defaultdict(int), SortedList(\n        []), SortedList([])\n    hsm.add(h);\n    wsm.add(w);\n    hs.add(0);\n    ws.add(0);\n    hs.add(h);\n    ws.add(w);\n    dhs[h] = 1;\n    dhs[0] = 1;\n    dws[0] = 1;\n    dws[w] = 1\n    for i in range(n):\n        t, p = map(str, input().split())\n        p = int(p)\n        if t == \"H\":\n            if dhs[p] == 0:\n                hs.add(p)\n                dhs[p] = 1\n            ind = hs.bisect_left(p)\n            pre, nex = hs[ind - 1], hs[ind + 1]\n            hsm.__delitem__(hsm.bisect_left(nex - pre));\n            hsm.add(p - pre);\n            hsm.add(nex - p)\n        else:\n            if dws[p] == 0:\n                ws.add(p)\n                dws[p] = 1\n            ind = ws.bisect_left(p)\n            pre, nex = ws[ind - 1], ws[ind + 1]\n            wsm.__delitem__(wsm.bisect_left(nex - pre));\n            wsm.add(p - pre);\n            wsm.add(nex - p)\n        print(wsm[-1] * hsm[-1])\n    pass\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "complexity": "nlogn",
    "problem": "0527_C",
    "from": "CODEFORCES",
    "tags": "binary search,data structures,implementation"
}
{
    "src": "a = input().split()\nb = [int(i) for i in a]\ninputs = []\ndiff = []\nsinComprimir = 0\nfor i in range(b[0]):\n    input1 = input().split()\n    input2 = [int(i) for i in input1]\n    inputs.append(input2)\n\ncomprimido = 0\nfor k in range(len(inputs)):\n    sinComprimir = sinComprimir + inputs[k][0]\n    diff.append(inputs[k][0] - inputs[k][1])\n    comprimido = comprimido + inputs[k][1] \n\ndifference = sorted(diff)\ninvDifference = difference[::-1]\nnewTotal = sinComprimir\niteraciones = 0\niterador = 0\nif sinComprimir <= b[1]:\n    print(\"0\")\nelif comprimido > b[1]:\n    print(\"-1\")\nelse:\n    while newTotal > b[1]:\n        iterador = iterador + 1\n        newTotal = newTotal - invDifference[iterador-1] \n        iteraciones += 1\n    print(iteraciones)",
    "complexity": "nlogn",
    "problem": "1015_C",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "n, k = map(int, input().split())\nlst = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    lst.append([-a, b])\nlst.sort()\nprint(lst.count(lst[k-1]))",
    "complexity": "nlogn",
    "problem": "0166_A",
    "from": "CODEFORCES",
    "tags": "binary search,implementation,sortings"
}
{
    "src": "def res(d,N):\n    for i in range(1,N):\n        if d[i][1] <= d[i-1][1]:\n            return str(d[i][2]+1) + ' ' + str(d[i-1][2]+1)\n    return '-1 -1'    \n\nN = int(input())\nd = []\nfor i in range(N):\n    a,b = map(int,input().split())\n    d.append((a,b,i))\nd = sorted(d, key = lambda x:(x[0],-x[1]))\nprint(res(d,N))\n",
    "complexity": "nlogn",
    "problem": "0976_C",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "def smallest(d):\n    out = \"\"\n    for j in range(0, 10):\n        out += (\"%d\" % j)*d[j]\n    return out\n\n\ndef largest(d):\n    out = \"\"\n    for j in range(9, -1, -1):\n        out += (\"%d\" % j)*d[j]\n    return out\n\n\nsa = input()\nsb = input()\nb = int(sb)\n\nh = int(sa)\ndigits_a = [0]*10\nwhile h > 0:\n    digits_a[h % 10] += 1\n    h //= 10\n\nout = \"\"\nif len(sb) > len(sa):\n    print(largest(digits_a))\n    exit()\n\nout = 0\nfor i in range(len(sa)-1, -1, -1):\n    for j in range(9, -1, -1):\n        if digits_a[j] == 0:\n            continue\n\n        if j < (b % (10 ** (i+1))) // (10 ** i):\n            digits_a[j] -= 1\n            if out > 0:\n                print(\"{}{}{}\".format(out, j, largest(digits_a)))\n                exit()\n            else:\n                print(\"{}{}\".format(j, largest(digits_a)))\n                exit()\n\n        if j == (b % (10 ** (i+1))) // (10 ** i):\n            if i == 0:\n                out = 10*out + j\n                print(out)\n                exit()\n            digits_a[j] -= 1\n            if int(smallest(digits_a)) <= b % (10 ** i):\n                out = 10*out + j\n                break\n            else:\n                digits_a[j] += 1\n\nprint(out)\n",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n=int(input())\na=str(n)\nm=len(a)\nb=int(a[0:m-1])\nc=int(a[0:m-2]+a[-1])\nd=max(n,b,c)\nprint(d)\n",
    "complexity": "constant",
    "problem": "0313_A",
    "from": "CODEFORCES",
    "tags": "implementation,number theory"
}
{
    "src": "n,K=map(int,input().split())\nb=sorted([int(x)for x in input().split()])\nl=cur=0\nfor i in range(1,n):\n    if b[i]==b[i-1]:continue\n    if b[i]>b[i-1]+K:l=i\n    else:cur+=(i-l);l=i\nprint(n-cur)\n",
    "complexity": "nlogn",
    "problem": "0990_B",
    "from": "CODEFORCES",
    "tags": "greedy,sortings"
}
{
    "src": "t = int(input())\n\nfor iter in range(t):\n    n, k = map(int, input().split())\n    if n >= 50:\n        if k == 0:\n            print(\"YES \" + str(n))\n        else:\n            print(\"YES \" + str(n - 1))\n    else:\n        a = [0] * (n + 1)\n        b = [0] * (n + 1)\n        c = [0] * (n + 1)\n        a[0] = 0\n        b[n] = 1\n        c[n] = 0\n\n        for i in range(1, n + 1):\n            a[i] = 4 * a[i - 1] + 1\n        for i in range(n - 1, -1, -1):\n            b[i] = b[i + 1] * 2 + 1\n        for i in range(n - 1, -1, -1):\n            c[i] = c[i + 1] + b[i + 1]\n\n        res = -1\n        for d in range(n + 1):\n            if c[d] <= k and k <= a[n] - a[d] * b[d]:\n                res = d\n\n        if res == -1:\n            print(\"NO\")\n        else:\n            print(\"YES \" + str(res))\n",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "\ndef check(mid,n,m,arr):\n\tmasks = {}\n\tfor index in range(n):\n\t\tarray = arr[index]\n\t\tx = 0\n\t\tfor i in range(m):\n\t\t\tif array[i] >= mid:\n\t\t\t\tx ^= (1<<i)\n\t\tmasks[x] = index+1\n\tans = False\n\ta,b = 1,1\n\tif (1<<m)-1 in masks.keys():\n\t\treturn True,(masks[(1<<m)-1],masks[(1<<m)-1])\n\tfor i in  masks.keys():\n\t\tfor j in masks.keys():\n\t\t\torAns = i|j\n\t\t\tif(orAns == ((1<<m)-1)):\n\t\t\t\tif i == (1<<m)-1 and (i in masks.keys()):\n\t\t\t\t\ta = masks[i]\n\t\t\t\t\tans = True\n\t\t\t\t\tbreak\n\t\t\t\telif j == (1<<m)-1 and (j in masks.keys()):\n\t\t\t\t\tb =  masks[j]\n\t\t\t\t\tans = True\n\t\t\t\t\tbreak\n\t\t\t\telif (i in masks.keys()) and (j in masks.keys()):\n\t\t\t\t\tans = True\n\t\t\t\t\ta,b = masks[i],masks[j]\n\t\t\t\t\tbreak\n\treturn ans,(a,b)\n\ndef solve(n,m,arr):\n\tmini = 0\n\tmaxi = int(1e9)+5\n\ti,j = 1,1\n\twhile(mini<=maxi):\n\t\tmid = (mini+maxi)//2\n\t\tans,res = check(mid,n,m,arr)\n\t\tif(ans):\n\t\t\ti,j = res\n\t\t\tmini =mid +1\n\t\telse:\n\t\t\tmaxi = mid -1\n\tprint(i,j)\n\ndef main():\n\tn,m = map(int,input().split(' '))\n\tarr = []\n\tfor _ in range(n):\n\t\tx = list(map(int,input().split(' ')))\n\t\tarr.append(x)\n\tsolve(n,m,arr)\n\nmain()",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "n,m = map(int,input().split())\narr1 = list(map(int,input().split()))\narr2 = list(map(int,input().split()))\n\nprint(*sorted([x for x in arr2 if x in arr1],key = lambda k:arr1.index(k)))",
    "complexity": "quadratic",
    "problem": "0994_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "if __name__ == \"__main__\":\n    n = int(input())\n    nums = [int(a) for a in input().strip().split()]\n    counts = 0\n\n    for i in range(n-1):\n        for j in range(i + 1, n):\n            if nums[i] > nums[j]:\n                counts += 1\n\n    ans = counts % 2\n    ans_tmp = []\n    m = int(input())\n    for i in range(m):\n        l, r = [int(a) for a in input().strip().split()]\n\n        tmp = r - l + 1\n        tmp_count = (tmp * (tmp - 1) // 2)\n        if tmp_count % 2 == 1:\n            ans = (ans + 1) % 2\n        ans_tmp.append(ans)\n    \n    for i in range(m):\n        ans = ans_tmp[i]\n        if ans % 2 == 1:\n            print(\"odd\")\n        else:\n            print(\"even\")\n\n \t  \t\t \t \t \t    \t  \t\t \t\t    \t \t",
    "complexity": "quadratic",
    "problem": "0911_D",
    "from": "CODEFORCES",
    "tags": "brute force,math"
}
{
    "src": "a,b=map(int,input().split())\nans=0\nwhile a and b:\n  ans+=a//b\n  a,b=b,a%b\nprint(ans)",
    "complexity": "constant",
    "problem": "0343_A",
    "from": "CODEFORCES",
    "tags": "math,number theory"
}
{
    "src": "#n=int(input())\nn,m=map(int,input().split())\n\nvert=[]\n\nfor i in range(n):\n    v=int(input())\n    vert.append(v)\n\nhorz=[]\n\nfor i in range(m):\n    x1,x2,y=map(int,input().split())\n    if x1==1:\n        horz.append(x2)\n\nvert.sort()\nhorz.sort()\n\nvert.append(1000000000)\n\ndef next(k,a,x):\n    while k<len(a) and a[k]<x:\n        k+=1\n    return k\n\nnum=next(0,horz,vert[0])\n\nans=len(horz)-num\n\nfor i in range(1,len(vert)):\n    num2=next(num,horz,vert[i])\n    t=i+len(horz)-num2\n    if t<ans: ans=t\n    num=num2\n\nprint(ans)\n\n\n\n\n",
    "complexity": "nlogn",
    "problem": "1075_C",
    "from": "CODEFORCES",
    "tags": "two pointers"
}
{
    "src": "#!usr/bin/python\n\na = input()\nb = input()\n\nlength_of_a = len(a)\nlength_of_b = len(b)\nfound_digit = False\nchk_finnish = False\nappended_digit_count = 0\nn = {}\nnum = []\nfor i in range(0,10):\n\tn[i] = 0\n\nfor i in range(0,length_of_a):\n\tc = int(a[i])\n\tn[c] += 1\n\n\nif length_of_a < length_of_b:\n\tnum = sorted(a,reverse=True)\n\tfor i in range(0,length_of_a):\n\t\tprint(num[i],end=\"\")\nelse:\n\tfor i in range(0,length_of_b):\n\t\tdigit = int(b[i])\n\t\tif n[digit] > 0:\n\t\t\tnum.append(digit)\n\t\t\tn[digit] -= 1\n\t\t\t# print(\"from start as equal : n[\"+str(digit)+\"] : \"+str(n[digit]))\n\t\t\t# print(num)\n\t\t\tappended_digit_count += 1\n\t\telse:\n\t\t\tj = digit - 1\n\t\t\twhile j > -1:\n\t\t\t\tif n[j] > 0:\n\t\t\t\t\tnum.append(j)\n\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\tn[j] -= 1\n\t\t\t\t\t# print(\"from 2nd : n[\"+str(j)+\"] : \"+str(n[j]))\n\t\t\t\t\t# print(num)\n\t\t\t\t\tfound_digit = True\n\t\t\t\t\tchk_finnish = True\n\t\t\t\t\tbreak\n\t\t\t\tj -= 1\n\n\t\t\tif found_digit:\n\t\t\t\tj = 9\n\t\t\t\twhile j > -1:\n\t\t\t\t\tif n[j] > 0:\n\t\t\t\t\t\tdigit_count = n[j]\n\t\t\t\t\t\tfor k in range(0,digit_count):\n\t\t\t\t\t\t\tnum.append(j)\n\t\t\t\t\t\t\tn[j] -= 1\n\t\t\t\t\t\t\t# print(\"form 3rd : n[\"+str(j)+\"] : \"+str(n[j]))\n\t\t\t\t\t\t\t# print(num)\n\t\t\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\tj -= 1\n\t\t\t\tif chk_finnish:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tfound_digit = False\n\t\t\t\twhile found_digit == False:\n\t\t\t\t\tpop_up = num[appended_digit_count-1]\n\t\t\t\t\t# print(pop_up,end=\" \")\n\t\t\t\t\tdel num[-1]\n\t\t\t\t\tj = pop_up - 1\n\t\t\t\t\tn[pop_up] += 1\n\t\t\t\t\t# print(\"form 4th popped : n[\"+str(pop_up)+\"] : \"+str(n[pop_up]))\n\t\t\t\t\t# print(num)\n\t\t\t\t\t# print(n[pop_up])\n\t\t\t\t\tappended_digit_count -= 1\n\t\t\t\t\twhile j > -1:\n\t\t\t\t\t\tif n[j] > 0:\n\t\t\t\t\t\t\tnum.append(j)\n\t\t\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\t\t\tn[j] -= 1\n\t\t\t\t\t\t\t# print(\"from 5th appeneded n[\"+str(j)+\"] : \"+str(n[j]))\n\t\t\t\t\t\t\t# print(num)\n\t\t\t\t\t\t\tfound_digit = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tj -= 1\n\t\t\t\tj = 9\n\t\t\t\twhile j > -1:\n\t\t\t\t\tif n[j] > 0:\n\t\t\t\t\t\t# print(\"from 5th : n[\"+str(j)+\"] : \"+str(n[j]))\n\t\t\t\t\t\t# print(num)\n\t\t\t\t\t\tdigit_count = n[j]\n\t\t\t\t\t\tfor k in range(0,digit_count):\n\t\t\t\t\t\t\tnum.append(j)\n\t\t\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\tj -= 1\n\t\t\t\tbreak\n\t\t\t\n\n\tfor i in range(0,length_of_b):\n\t\tprint(num[i],end=\"\")",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a = sorted(a)\n    print(min(a[-2]-1, n-2))\n",
    "complexity": "nlogn",
    "problem": "1197_A",
    "from": "CODEFORCES",
    "tags": "greedy,math,sortings"
}
{
    "src": "def digit(a):\n    s=0\n    while a:\n        s+=a%10\n        a//=10\n    return s\n\ndef big(n,s):\n    # lst=[[i,i-digit(i)] for i in range(1,n+1)]\n    lo=1\n    hi=n\n    while lo<=hi:\n        mid=(lo+hi)//2\n        if mid-digit(mid)<s:\n            # print(digit(mid))\n            lo=mid+1\n        else:\n            hi=mid-1\n            # hi=mid-1\n    return n-lo+1\n\na,b=map(int,input().strip().split())\nprint(big(a,b))",
    "complexity": "logn",
    "problem": "0817_C",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,dp,math"
}
{
    "src": "from sys import stdin,stdout\n# input=stdin.readline\nmod=10**9+7\nt=1\nfor _ in range(t):\n    a=input()\n    b=input()\n    n=len(a)\n    m=len(b)\n    dp=[[0 for i in range(2)] for j in range(m+1)]\n    dp[1][0]=int(b[0])^1\n    dp[1][1]=int(b[0])\n    for i in range(2,m+1):\n        dp[i][0]=dp[i-1][0]+(int(b[i-1])^1)\n        dp[i][1]=dp[i-1][1]+int(b[i-1])\n    ans=0\n    for i in range(n):\n        count0=dp[m-n+i+1][0]-dp[i][0]\n        count1=dp[m-n+i+1][1]-dp[i][1]\n        ans+=count0*int(a[i])+count1*(int(a[i])^1)\n    print(ans)",
    "complexity": "linear",
    "problem": "0608_B",
    "from": "CODEFORCES",
    "tags": "combinatorics,strings"
}
{
    "src": "def go():\n    n = int(input())\n    for i in range(n):\n        a, b, d = [int(i) for i in input().split(' ')]\n        if a > d or b > d:\n            print(-1)\n        elif a % 2 == b % 2:\n            if a % 2 == d % 2:\n                print(d)\n            else:\n                print(d - 2)\n        else:\n            if a % 2 == b % 2:\n                if d % 2 == a % 2:\n                    print(d)\n                else:\n                    print(d - 2)\n            else:\n                print(d - 1)\ngo()\n",
    "complexity": "constant",
    "problem": "1036_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import io\nimport os\n\nfrom functools import lru_cache\nfrom collections import defaultdict\n\n\ndef solve(N, A):\n    # Compute all intervals that merge down to a single value\n    # val -> leftEndpoint -> rightEndpoints\n    valToLeftRight = defaultdict(lambda: defaultdict(set))\n    # val -> rightEndpoint -> leftEndpoints\n    valToRightLeft = defaultdict(lambda: defaultdict(set))\n    # Initialize with intervals of length 1 (left and right endpoints inclusive)\n    for i, x in enumerate(A):\n        valToLeftRight[x][i].add(i)\n        valToRightLeft[x][i].add(i)\n\n    # Go from smallest to largest values\n    # Note: max val formable is with A = [1000] * 500 which should be around 1000 + lg(500)\n    maxVal = 1000 + 100\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val - 1].items():\n            for r in rights:\n                # Merge (l, r) with (l2, r2) with value (val - 1)\n                l2 = r + 1\n                if l2 in valToLeftRight[val - 1]:\n                    for r2 in valToLeftRight[val - 1][l2]:\n                        assert l <= r\n                        assert r + 1 == l2\n                        assert l2 <= r2\n                        valToLeftRight[val][l].add(r2)\n                        valToRightLeft[val][r2].add(l)\n                # Merge (l2, r2) with (l, r) with value (val - 1)\n                r2 = l - 1\n                if r2 in valToRightLeft[val - 1]:\n                    for l2 in valToRightLeft[val - 1][r2]:\n                        assert l2 <= r2\n                        assert r2 == l - 1\n                        assert l <= r\n                        valToLeftRight[val][l2].add(r)\n                        valToRightLeft[val][r].add(l2)\n\n    # Merge all left to right endpoints regardless of value formed\n    intervals = defaultdict(list)\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val].items():\n            for r in rights:\n                # print(A[l : r + 1], l, r, val)\n                intervals[l].append(r)\n\n    # DP[i] returns most area you can cover in A[i:]\n    dp = {}\n    dp[N] = 0\n    for left in range(N - 1, -1, -1):\n        best = float(\"inf\")\n        for right in intervals[left]:\n            # left to right inclusive is combined down to one character\n            best = min(best, 1 + dp[right + 1])\n        dp[left] = best\n\n    # print(intervals)\n    # print(A)\n    # print([g[i] for i in range(N + 1)])\n    return dp[0]\n\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    ans = solve(N, A)\n    print(ans)\n",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import collections\n\n\ndef main():\n    # # n = int(input())\n    # x, y, z, t1, t2, t3 = list(map(int, input().split()))\n    # stair = t1 * abs(y - x)\n    # ele = t2 * (abs(y - x) + abs(z - x)) + 3 * t3\n    # # print(stair, ele)\n    # print(\"YES\" if ele <= stair else \"NO\")\n\n    # n = int(input())\n    # num = list(map(int, input().split()))\n    # prevMax, totMax = -1, float('-inf')\n    # for i, v in enumerate(num):\n    #     totMax = max(totMax, v)\n    #     if totMax - prevMax in [0, 1]:\n    #         prevMax = totMax\n    #     else:\n    #         print(i + 1)\n    #         return\n    # print(-1)\n\n    n = int(input())\n    left = list(map(int, input().split()))\n    right = list(map(int, input().split()))\n    res = [0] * n\n    val = n\n\n    if all(not left[i] and not right[i] for i in range(n)):\n        print(\"YES\")\n        print(' '.join(['1'] * n))\n        return\n\n    while not all(not left[i] and not right[i] for i in range(n)):\n        zeroSet = set()\n        for i in range(n):\n            if not left[i] and not right[i] and res[i] == 0:\n                zeroSet.add(i)\n                res[i] = val\n        for v in zeroSet:\n            for i in range(v + 1, n):\n                if i not in zeroSet and res[i] == 0:\n                    left[i] -= 1\n            for i in range(v):\n                if i not in zeroSet and res[i] == 0:\n                    right[i] -= 1\n        val -= 1\n        # print(zeroSet, left, right)\n        if not zeroSet:\n            print(\"NO\")\n            return\n\n    for i in range(n):\n        if not res[i]:\n            res[i] = str(val)\n        else:\n            res[i] = str(res[i])\n    if any(i == '0' for i in res):\n        print(\"NO\")\n        return\n    print(\"YES\")\n    print(' '.join(res))\n\n\nmain()\n",
    "complexity": "quadratic",
    "problem": "1054_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation"
}
{
    "src": "n = int(input())\na = []\nfor i in range(n):\n    a.append(list(map(int,input().split()))+[i+1])\na.sort(key = lambda e:e[0])\nf = 0\nfor i in range(n-1):\n    if a[i][0] == a[i+1][0]:\n        if a[i][1] >= a[i+1][1]:\n            print(a[i+1][2],a[i][2])\n        else:print(a[i][2],a[i+1][2])\n        f =1\n        break\n    if a[i][1] >= a[i+1][1]:\n        f = 1\n        print(a[i+1][2],a[i][2])\n        break\nif f == 0:print(-1,-1)\n",
    "complexity": "nlogn",
    "problem": "0976_C",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "#!/usr/bin/python3.5\n\nN = int(input())\nL = [int(s) for s in input().split(\" \")]\nR = [int(s) for s in input().split(\" \")]\n\nC = [N - L[i] - R[i] for i in range(0, N)]\n\nfor i, x in enumerate(C):\n    if C[i] <= 0:\n        print(\"NO\")\n        exit()\n\n    l = 0\n    r = 0\n\n    j = i-1\n    while j >= 0:\n        if C[j] > C[i]:\n            l = l + 1\n            \n        j = j - 1\n\n    j = i+1\n    while j < N:\n        if C[j] > C[i]:\n            r = r + 1\n\n        j = j + 1\n\n    if L[i] != l or R[i] != r:\n        print(\"NO\")\n        exit()\n\nprint(\"YES\")\nfor i in range(0, N-1):\n    print(C[i], end=\" \")\n\nprint(C[N-1])\n\n",
    "complexity": "quadratic",
    "problem": "1054_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation"
}
{
    "src": "import collections\nimport sys\n\ndef can_win(i, dp):\n    if i in dp:\n        return dp[i]\n    else:\n        for next in possible[i]:\n            if not can_win(next, dp):\n                dp[i] = True\n                return True\n        dp[i] = False\n        return False\n\ndata = sys.stdin.readlines()\nnb = int(data[0])\nnums = data[1].split(' ') \nnums = [int(c) for c in nums]\npossible = [[] for _ in range(nb)]\nfor i in range(nb):\n    if nums[i] == 1:\n        possible[i] = [k for k in range(nb) if k != i] \n    else:\n        for j in range(i+nums[i], nb, nums[i]):\n            if nums[j] > nums[i]:\n                possible[i].append(j)\n        for j in range(i-nums[i], -1, -nums[i]):\n            if nums[j] > nums[i]:\n                possible[i].append(j)\n\nres = \"\"\ndp = {}\nfor i in range(nb):\n    if can_win(i, dp):\n        res += \"A\"\n    else:\n        res += \"B\"\nprint(res)\n        \n",
    "complexity": "quadratic",
    "problem": "1033_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,games"
}
{
    "src": "n = int(input())\nm = int(input())\nprint(m%2**n)",
    "complexity": "constant",
    "problem": "0913_A",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "from sys import stdout\nfrom sys import stdin\ndef get():\n    return stdin.readline().strip()\ndef getf(sp = \" \"):\n    return [int(i) for i in get().split(sp)]\ndef put(a, end = \"\\n\"):\n    stdout.write(str(a) + end)\ndef putf(a, sep = \" \", end = \"\\n\"):\n    stdout.write(sep.join([str(i) for i in a]) + end)\n   \n#from collections import defaultdict as dd, deque\n#from random import randint, shuffle, sample\n#from functools import cmp_to_key, reduce\n#from math import factorial as fac, acos, asin, atan2, gcd, log, e\n#from bisect import bisect_right as br, bisect_left as bl, insort\n\nfrom math import log\nfrom bisect import bisect_right as br, bisect_left as bl\n\ndef main():\n    n, k = getf()\n    a = getf()\n    rem = [[] for i in range(11)]\n    ln = [0] * n\n    for i in range(n):\n        ln[i] = int(log(a[i], 10)) + 1\n        rem[ln[i]] += [a[i] % k]\n    for i in range(11):\n        rem[i].sort()\n    ans = 0\n    for i in range(n):\n        res = 0\n        for add_len in range(1, 11):\n            cur_rem = ((a[i] % k) * pow(10, add_len, k)) % k\n            need_rem = (k - cur_rem) % k\n            sz = len(rem[add_len])\n            l = bl(rem[add_len], need_rem)\n            r = br(rem[add_len], need_rem)\n            if(l > sz - 1):\n                continue\n            if(rem[add_len][l] == need_rem):\n                res += (r - l)\n        if((a[i] + (a[i] % k) * pow(10, ln[i], k)) % k == 0):\n            res -= 1\n        ans += res\n    put(ans)\nmain()\n",
    "complexity": "nlogn",
    "problem": "1029_D",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "import sys\nimport logging\nlogging.root.setLevel(level=logging.DEBUG)\nimport re\n\ns = sys.stdin.readline().strip()\n\nfrom collections import defaultdict\nsubstr = defaultdict(int)\nfor left in range(len(s)):\n    for right in range(left+1,len(s)+1):\n        substr[s[left:right]] += 1\nmax_len = 0\nfor segment,times in substr.items():\n    if times >= 2:\n        max_len = max(max_len,len(segment))\nprint(max_len)\n\n",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "n=int(input())\nif n>=0:\n    print(n)\nelse:\n    a=str(n)\n    a=a[1::]\n    if len(a)>2:\n        a=a[::-1][1::][::-1]\n        num1=int(a)\n        a=str(n)\n        a=a[1::]\n        b=a[::-1]\n        p1=b[0]\n        p2=b[2::]\n        p=p1+p2\n        p=p[::-1]\n        num2=int(p)\n        small=min(num1,num2)\n        print(-1*small)\n        \n    elif len(a)==2:\n        m=a[0]\n        n=a[1]\n        small=min(int(m),int(n))\n        print(-1*small)\n    ",
    "complexity": "constant",
    "problem": "0313_A",
    "from": "CODEFORCES",
    "tags": "implementation,number theory"
}
{
    "src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##########################################################\nfrom collections import Counter, defaultdict\nimport bisect\nimport math\n\nfor _ in range(1):\n    n = int(input())\n    #n,k=map(int, input().split())\n    arr = list(map(int, input().split()))\n    t=[0]*n\n    cur=0\n    for i in range(n-1,-1,-1):\n        cur=max(cur-1,0,arr[i]+1)\n        t[i]=cur\n    ans=0\n    for i in range(n):\n        cur=max(cur,t[i])\n        ans+=cur\n    for i in range(n):\n        ans-=(arr[i]+1)\n    print(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "complexity": "linear",
    "problem": "0924_C",
    "from": "CODEFORCES",
    "tags": "data structures,dp,greedy"
}
{
    "src": "import math\nn, k = map(int, input().split())\n\nq = int(-3 + math.sqrt(9 + 8*(n+k)))//2\n\nr = n-q\n\nprint(r)",
    "complexity": "constant",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "n= int(input())\nb = [int(_) for _ in input().split()]\nd = [[b[i] if i == j else -1 for i in range(n)] for j in range(n)]\n\ndef f(i, j):\n\tif d[i][j] != -1:\n\t\treturn d[i][j]\n\td[i][j] = 0\n\tfor m in range(i, j):\n\t\tl = f(i, m)\n\t\tif f(m+1, j) == l and l:\n\t\t\td[i][j] = l+1\n\t\t\tbreak\n\treturn d[i][j]\n\na = [_ for _ in range(1, n+1)]\nfor e in range(1, n):\n\tfor s in range(e+1):\n\t\tif f(s, e):\n\t\t\ta[e] = min(a[e], ((a[s-1]+1) if s > 0 else a[s]))\nprint(a[-1])",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n = int(input())\ns = input()\nmaxn = 0\nnow = 0\nfor i in s:\n    if i == '+':\n        now += 1\n    else:\n        now -= 1\n    maxn = max(maxn, -now)\nprint(now + maxn)",
    "complexity": "linear",
    "problem": "1159_A",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "import math\n\nn, m, k, l = map(int, input().split())\n\nx = (l + k) // m\nif x * m < l + k:\n    x += 1\nassert x * m >= l + k\n\nif m * x > n:\n    print(-1)\nelse:\n    print(x)",
    "complexity": "constant",
    "problem": "1068_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "t=int(input())\nfor l in range(t):\n\tn=int(input())\n\tarr=list(map(int,input().split()))\n\tarr.sort()\n\ta=arr[-2]\n\tprint(min(a-1,n-2))\n\t",
    "complexity": "nlogn",
    "problem": "1197_A",
    "from": "CODEFORCES",
    "tags": "greedy,math,sortings"
}
{
    "src": "# encontrar o m\u00e1ximo xor entre um par que se encontra no intervalo [l,r]\n\ndef main():\n    l,r = map(int,input().split())\n\n    if l == r:\n        print(0)\n        return\n\n    l = bin(l)[2:]\n    r = bin(r)[2:]\n\n    if len(l) == len(r):\n        i = 1 #ambos come\u00e7am com 1, n\u00e3o preciso checar\n        while l[i] == r[i]:\n            i += 1\n        tam = len(l)-i\n    else:\n        tam = len(r)\n\n    num = \"\"\n    for i in range(tam):\n        num += '1'\n\n    print(int(num,2))    \n\nmain()",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "pfs=[i*i for i in range(1,3163)]\np=[i for i in range(0,10000001)]\nfor i in range(1,10000001):\n    if(p[i]==i):\n        for j in pfs:\n            if(i*j>10000000): break\n            p[i*j]=i\nt=int(input())\nfor lll in range(0,t):\n    n,k=map(int,input().split())\n    zc=list(map(int,input().split()))\n    s=[p[zc[i]] for i in range(0,len(zc))]\n    dp=[n]*(k+1)\n    dp[0]=1\n    ys=[{}]*(n+1)\n    for i in range(0,len(s)):\n        for j in range(k,-1,-1):\n            if(dp[j]==n): continue\n            if(ys[j].get(s[i],-1)!=-1):\n                if(j<k and dp[j]<dp[j+1]):\n                    dp[j+1]=dp[j]\n                    ys[j+1]=ys[j]\n                dp[j]+=1\n                ys[j]={}\n            ys[j][s[i]]=1\n    print(min(dp))\n\t\t\t\t\t\t  \t\t      \t \t \t \t \t\t   \t\t",
    "complexity": "cubic",
    "problem": "1497_E2",
    "from": "CODEFORCES",
    "tags": "data structures,dp,greedy,math,number theory,two pointers"
}
{
    "src": "x,k=map(int,input().split())\nif x==0:\n  print(0)\nelse:\n    u=(pow(2,k,1000000007)*(2*x-1)+1)%1000000007\n    print(int(u))\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "from copy import deepcopy\nx,k=map(int,input().split(' '))\nif(x==0):\n\tprint(0)\nelse:\n\tprint((((pow(2,k,1000000007))*((2*x-1)%1000000007))+1)%1000000007)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n=int(input())\ndef judge(x):\n    if x%2==0:\n        return 0\n    else:\n        return 1\nls=[int(x) for x in input().split()]\nif judge(ls[0])==judge(ls[1]):\n    for x in ls[2:]:\n        if judge(x)!=judge(ls[0]):\n            print(ls.index(x)+1)\n            break\nelse:\n    if judge(ls[2])==judge(ls[0]):\n        print(2)\n    elif judge(ls[2])==judge(ls[1]):\n        print(1)",
    "complexity": "linear",
    "problem": "0025_A",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "k = int(input())\n\nif k <= 9:\n\tprint(k)\n\nelse:\n\ts = 9\n\tn = 1\n\t\n\twhile s < k:\n\t\tn += 1\n\t\tprev_s = s\n\t\ts += (10**n - 10**(n-1)) * n\n\n\tdigit_pos = k - (prev_s + 1)\n\tnumber = 10**(n-1) + digit_pos // n\n\t\n\tif digit_pos / n != digit_pos // n:\n\t\tdigit_pos = digit_pos - (digit_pos // n) * n\n\n\n\telse:\n\t\tdigit_pos = 0\n\n\tprint(str(number)[digit_pos])",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "import sys\nfrom math import gcd, sqrt\nfrom typing import Deque\n\nsys.setrecursionlimit(10 ** 5)\n\n\ninf = float(\"inf\")\nen = lambda x: list(enumerate(x))\n\nii = lambda: int(input())\nr = lambda: map(int, input().split())\nrr = lambda: list(r())\n\n\nn = ii()\narr = rr()\narr = en(arr)\n\narr.sort(key=lambda x: x[1])\n\ni = 0\nbrr = []\n\nfor j in input():\n    if j == \"0\":\n        brr.append(arr[i])\n        print(arr[i][0] + 1, end=\" \")\n        i += 1\n    else:\n        x = brr.pop()\n        print(x[0] + 1, end=\" \")\n",
    "complexity": "nlogn",
    "problem": "0982_B",
    "from": "CODEFORCES",
    "tags": "data structures,greedy,implementation"
}
{
    "src": "n=int(input())\na=[]\nfor i in range(n):\n    l=[int(i) for i in input().split()]\n    if i==0:\n        t=sum(l)\n    a.append(sum(l))\na.sort(reverse=True)\nprint(a.index(t)+1)",
    "complexity": "linear",
    "problem": "1017_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "from math import ceil\nn, k = map(int, input().split())\ncou = 0\ncou += ceil(n*2/k)\ncou += ceil(n*5/k)\ncou += ceil(n*8/k)\nprint(cou)",
    "complexity": "constant",
    "problem": "1080_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "def main():\n    q = int(input())\n    ans = []\n    for i in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        min_ans = 10 ** 9\n        pr1 = [0]\n        pr2 = [0]\n        pr3 = [0]        \n        for i in range(n):\n            count1 = 0\n            count2 = 0\n            count3 = 0\n            if i % 3 == 0:\n                if s[i] != \"R\":\n                    count1 += 1\n                if s[i] != \"G\":\n                    count2 += 1\n                if s[i] != \"B\":\n                    count3 += 1\n            if i % 3 == 1:\n                if s[i] != \"G\":\n                    count1 += 1\n                if s[i] != \"B\":\n                    count2 += 1\n                if s[i] != \"R\":\n                    count3 += 1 \n            if i % 3 == 2:\n                if s[i] != \"B\":\n                    count1 += 1\n                if s[i] != \"R\":\n                    count2 += 1\n                if s[i] != \"G\":\n                    count3 += 1\n            pr1.append(pr1[-1] + count1)\n            pr2.append(pr2[-1] + count2)\n            pr3.append(pr3[-1] + count3)\n            j = i + 1\n            if j >= k:\n                count1 = pr1[j] - pr1[j - k]\n                count2 = pr2[j] - pr2[j - k]\n                count3 = pr3[j] - pr3[j - k]\n                min_ans = min(min_ans, count1, count2, count3)     \n        ans.append(min_ans)\n    print(*ans, sep=\"\\n\")\n\nmain()",
    "complexity": "linear",
    "problem": "1196_D2",
    "from": "CODEFORCES",
    "tags": "data structures,dp,implementation,two pointers"
}
{
    "src": "from collections import Counter\n\nn,k=list(map(int,input().split()))\nx=list(map(int,input().split()))\n\ndd=Counter()\nfor i in range(k):\n   \n    dd[x[i]]=dd[x[i]]+1\n\n \nfinal=0   \nfor i in range(1,k+1):\n    ans=0\n    d=dd.copy()\n    for j in range(n):\n        for jj in d:\n            if d[jj]>=i:\n                d[jj]-=i\n                ans=ans+1\n                break\n    if ans>=n:\n        final=i\n    else:\n        break\nprint(final)",
    "complexity": "nlogn",
    "problem": "1011_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,implementation"
}
{
    "src": "import math\nimport sys\n\nn=int(input())\ns=list(map(int,input().split()))\nce=list(map(int,input().split()))\n\nbest=10**9\nfor j in range(1,n-1):\n    a=ce[j];b=10**9;c=10**9\n    for i in range(j-1,-1,-1):\n        if s[i]<s[j]:\n            b=min(b,ce[i])\n    for k in range(j+1,n):\n        if s[k]>s[j]:\n            c=min(c,ce[k])\n    best=min(best,a+b+c)\n\nif best>=10**9:\n    print(-1)\nelse:\n    print(best)",
    "complexity": "quadratic",
    "problem": "0987_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,implementation"
}
{
    "src": "a=list(map(int,input().split()))\nmr=0\nfor t in range(14):\n    b=list(a)\n    m=b[t]\n    k=t\n    i=1\n    b[k]=0\n    while(m>0):\n        if(m//14==0):\n            b[(k+i)%14]+=1\n            m-=1\n            i+=1\n        else:\n            q=m//14\n            for c in range(14):\n                b[c]+=q\n            m-=14*q\n    p=sum([ x  for x in b if x%2==0 ])\n    mr=max(p,mr)\nprint(mr)\n        \n        \n",
    "complexity": "constant",
    "problem": "0975_B",
    "from": "CODEFORCES",
    "tags": "brute force,implementation"
}
{
    "src": "from bisect import insort,bisect_right,bisect_left\nfrom sys import stdout, stdin, setrecursionlimit\nfrom heapq import heappush, heappop, heapify \nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import * \nfrom string import *\nfrom queue import *\nfrom math import *\nfrom re import *\nfrom os import *\n\n# sqrt,ceil,floor,factorial,gcd,log2,log10,comb\n\n####################################---fast-input-output----#########################################\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ngraph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())\ndef getStr(): return input()\ndef getInt(): return int(input())\ndef listStr(): return list(input())\ndef getStrs(): return input().split()\ndef isInt(s): return '0' <= s[0] <= '9'\ndef input(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in input().split()]\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))\n\n\ndef getPrimes(N = 10**5):\n    SN = int(sqrt(N))\n    sieve = [i for i in range(N+1)]\n    sieve[1] = 0\n    for i in sieve:\n        if i > SN:\n            break\n        if i == 0:\n            continue\n        for j in range(2*i, N+1, i):\n            sieve[j] = 0\n    prime = [i for i in range(N+1) if sieve[i] != 0] \n    return prime\ndef primeFactor(n,prime=getPrimes()):\n    lst = []\n    mx=int(sqrt(n))+1\n    for i in prime:\n        if i>mx:break\n        while n%i==0:\n            lst.append(i)\n            n//=i\n    if n>1:\n        lst.append(n)\n    return lst    \n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\ndaysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n\n#################################################---Some Rule For Me To Follow---#################################\n\"\"\"\n    --instants of Reading problem continuously try to understand them.\n\n    --Try & again try, maybe you're just one statement away!\n\n\"\"\"\n##################################################---START-CODING---###############################################\n\n\na = getInt()\nb = getInt()\n\n\narr = list(str(a))\n\narr = sorted(arr)\nans=''\n\nwhile arr:\n    for i in range(len(arr)-1,-1,-1):\n        x=ans+arr[i]\n\n        for j in arr[:i]:\n            x+=j\n        for j in arr[i+1:]:\n            x+=j\n        if int(x)<=b:\n            ans+=arr[i]\n            arr.pop(i)\n            break\n\nprint(ans)",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import math\n\nn, r = map(int, input().split())\ns = math.sin(math.pi / n)\nprint('%.7lf' % (r * s / (1 - s)))",
    "complexity": "constant",
    "problem": "1100_C",
    "from": "CODEFORCES",
    "tags": "binary search,geometry,math"
}
{
    "src": "import math\nnum=int(input())\nk=math.ceil(num/2)\nif num%2==0:\n    print(k+1)\nelse:\n    print(k)",
    "complexity": "constant",
    "problem": "0964_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "# URDL\nDR = [1,0,-1,0]\nDC = [0,1,0,-1]\n\nn, m, k = map(int, input().split())\nw = [[[0] * m for _ in range(n)] for _ in range(4)]\nfor r in range(n):\n    for c, e in enumerate(map(int, input().split())):\n        w[1][r][c] = w[3][r][c + 1] = e\nfor r in range(n - 1):\n    for c, e in enumerate(map(int, input().split())):\n        w[0][r][c] = w[2][r + 1][c] = e\n\n\nINF = 10 ** 9\n\n\ndef solve():\n    global k\n    global w\n    if k % 2 == 1:\n        return [[-1] * m] * n\n    k //= 2\n    best = [[[0] * m for _ in range(n)] for _ in range(k + 1)]\n    for steps in range(1, k + 1):\n        for r in range(n):\n            for c in range(m):\n                best[steps][r][c] = INF\n                for d in range(4):\n                    r2, c2 = r + DR[d], c + DC[d]\n                    if 0 <= r2 < n and 0 <= c2 < m:\n                        best[steps][r][c] = min(best[steps][r][c], 2 * w[d][r][c] + best[steps - 1][r2][c2])\n    return best[k]\n\n\nres = solve()\nfor e in res:\n    print(*e)",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "\ndef STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n#visited = [[False for i in range(m)] for j in range(n)]\n#for tt in range(INT()):\n\ndef Binary_Search(arr , x , n):\n    l ,r = 0 , n-1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if arr[mid] == x :\n            return mid+1\n        elif arr[mid] > x:\n            r = mid - 1\n        else:\n            l = mid + 1\n    return r + 1\n\n\nn , q = MAP()\na = LIST()\nb = LIST()\nps = list(accumulate(a))\nans = []\n\narrows = 0\nfor arrow in b :\n    arrows += arrow\n    if arrows >= ps[-1]:\n        ans.append(n)\n        arrows = 0\n    else:\n        res = Binary_Search(ps , arrows , n)\n        ans.append(n - res)\n\nfor i in ans:\n    print(i)\n\n",
    "complexity": "nlogn",
    "problem": "0975_C",
    "from": "CODEFORCES",
    "tags": "binary search"
}
{
    "src": "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n \nmax_val = 0\nn, m = [int(item) for item in input().split()]\narray = []\nfor i in range(n):\n    line = [int(item) for item in input().split()]\n    array.append(line)\n    max_val = max(max_val, max(line))\n \ngood = (1 << m) - 1\nl = 0; r = max_val + 1\na = 0; b = 0\nwhile r - l > 1:\n    mid = (l + r) // 2\n    bit_array = dict() \n    for k, line in enumerate(array):\n        val = 0\n        for i, item in enumerate(line):\n            if item >= mid:\n                val |= 1 << i\n        bit_array[val] = k\n    ok = False\n    for key1 in bit_array.keys():\n        for key2 in bit_array.keys():\n            if key1 | key2 == good:\n                ok = True\n                i = bit_array[key1]\n                j = bit_array[key2]\n                break\n    if ok:\n        a = i; b = j\n        l = mid\n    else:\n        r = mid\nprint(a+1, b+1)",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "from sys import stdin\nfrom math import factorial\n\nn, mod = map(int, stdin.readline().split())\n\ndef binom(n, m):\n    return factorial(n) // factorial(m) // factorial(n-m)\n\ndef foo(x, k):\n    ans = 0\n    for i in range(k, 0, -1):\n        sign = 1 if (i-k)%2 == 0 else -1\n        ans += sign * binom(k, i) * (i**x)\n        ans %= mod\n    return ans\n\ndef f(x, k):\n    return (foo(x, k) * pow(2, x-k, mod)) % mod\n\nans = 0\nfor i in range((n+1)//2):\n    ans = (ans + f(n-i, i+1))\n    ans %= mod\nprint(ans)",
    "complexity": "cubic",
    "problem": "1515_E",
    "from": "CODEFORCES",
    "tags": "combinatorics,dp,math"
}
{
    "src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn, k = mi()\nans = (n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k\nprint(ans)\n",
    "complexity": "constant",
    "problem": "1080_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "'''input\n3\n1 1\n2 2\n2 12\n'''\nfor _ in range(int(input())):\n\tdef get(n):\n\t\treturn (4**n-1)//3\n\tn,k = map(int,input().split())\n\tif n<32 and 4**n < 1*3*k:\n\t\tprint(\"NO\")\n\t\tcontinue\n\tnow = 1\n\tp = 2\n\tans = n\n\tsq = 0\n\tbuff = 0\n\td = 4\n\twhile k>=now:\n\t\tk -= now\n\t\tp *= 2\n\t\tnow = p-1\n\t\tans -= 1\n\n\t\tsq = sq*4 + d-3\n\t\td *= 2\n\t\tif n < 60:\n\t\t\tbuff += sq * (4**ans-1)//3\n\t\telse:\n\t\t\tbuff = 10**19\n\t\t# print(sq, k, buff)\n\t\tif ans == 0: break\n\t\t# if n < 60:\n\t\t# \tbuff += get(ans)\n\tif buff < k: print(\"NO\")\n\telse: print(\"YES\",max(ans,0))",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "# A. Nastya and an Array\n\nn = int(input())\na = set(map(int, input().split()))\n\nans = len(a) - 1 if 0 in a else len(a)\nprint(ans)\n",
    "complexity": "linear",
    "problem": "0992_A",
    "from": "CODEFORCES",
    "tags": "implementation,sortings"
}
{
    "src": "l,r=map(int,input().split())\nal=[]\nar=[]\nwhile(r):\n    p=r%2\n    ar.append(p)\n    r=r//2\nwhile(l):\n    p=l%2\n    al.append(p)\n    l=l//2\nif len(ar)!=len(al):\n    ans=(2**len(ar))-1\nelse:\n    n=len(ar)\n    s=0\n    k=0\n    for i in range(n-1,-1,-1):\n        if ar[i]!=al[i]:\n            k=i+1\n            break\n    ans=(2**k)-1\n    if k==0:\n        ans=0\nprint(ans)",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "n, m = map(int, input().split())\na = list(map(str, input().strip()))\n\ndp = [10 ** 10] * (1 << 20)\ncnt = [0] * (1 << 20)\n\n\ndef get(x):\n    return 1 << (ord(x) - ord('a'))\n\n\nfor i, v in enumerate(a):\n    if i:\n        cnt[get(a[i]) | get(a[i - 1])] += 1\n\nfor i in range(m):\n    for j in range(1 << m):\n        if (1 << i) & j:\n            cnt[j] += cnt[j ^ (1 << i)]\n            # print(bin(j), bin(j ^ 1 << i), cnt[j])\n\n# for i in range(1 << m):\n#     for j in range(m):\n#         if not i & (1 << j):\n#             cnt[i | (1 << j)] += cnt[i]\n#             print(bin(i | (1 << j)), bin(i), cnt[i | 1 << j])\n\ndp[0] = 0\n\nfor i in range(1 << m):\n    for j in range(m):\n        if not i & (1 << j):\n            dp[i | (1 << j)] = min(dp[i | (1 << j)],\n                                   dp[i] + n - 1 - cnt[i | (1 << j)] - cnt[(1 << m) - 1 - (i | (1 << j))])\nprint(dp[(1 << m) - 1])\n",
    "complexity": "np",
    "problem": "1238_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "num=int(input())\n\nvals=list(map(int,input().split()))\n\nvals.sort()\n\nflag=0\n\nfor i in vals:\n    if i>vals[0]:\n        print(i)\n        flag=1\n        break\n    \n\nif flag==0:\n    print('NO')\n    ",
    "complexity": "nlogn",
    "problem": "0022_A",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "n, m = [int(x) for x in input().split()]\nxs = [int(x) for x in input().split()]\nts = [int(x) for x in input().split()]\n\n\ntaxi_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 1])\npassenger_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 0])\n\na_is = [0] * len(taxi_idx)\nt_idx = 0\np_idx = 0\n\nwhile True:\n    if p_idx >= len(passenger_idx):\n        break\n\n    if t_idx == len(taxi_idx) - 1:\n        a_is[t_idx] += 1\n    else:\n        while t_idx < len(taxi_idx) - 1:\n            d1 = abs(passenger_idx[p_idx] - taxi_idx[t_idx])\n            d2 = abs(passenger_idx[p_idx] - taxi_idx[t_idx + 1])\n            # print(t_idx, d1, d2)\n            if d1 > d2:\n                t_idx += 1\n            else:\n                break\n\n        a_is[t_idx] += 1\n\n    p_idx += 1\n\nprint(' '.join([str(x) for x in a_is]))\n",
    "complexity": "quadratic",
    "problem": "1075_B",
    "from": "CODEFORCES",
    "tags": "implementation,sortings"
}
{
    "src": "from random import randint\nfor _ in range(int(input())):\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n    ans = 0\n    for _ in range(100):\n        for j in range(m):\n            x = randint(0, n - 1)\n            if x:\n                B = []\n                for i in range(n):\n                    B.append(A[i][j])\n                B = B[x:] + B[:x]\n                for i in range(n):\n                    A[i][j] = B[i]\n        c = 0\n        for i in range(n):\n            c += max(A[i])\n        ans = max(ans, c)\n    print(ans)",
    "complexity": "np",
    "problem": "1209_E1",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,dp,greedy,sortings"
}
{
    "src": "n,l,r,x = map(int,input().split())\na = list(map(int,input().split()))\nans = 0\nfor i in range(1,(2**n)+1):\n    j = bin(i)\n    j = j[2:]\n    if len(j)<n:\n        j = '0'*(n-len(j))+j\n    #print(j)\n    c = 0\n    temp = []\n    for k in j:\n        if k=='1':\n            temp.append(a[c])\n        c+=1\n    s = sum(temp)\n    #print(s)\n    if len(temp)>=2 and s>=l and s<=r and (max(temp)-min(temp))>=x:\n        ans+=1\n    #print(ans)\n    #print()\n    #print(j)\nprint(ans)",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "from math import ceil\n\nk, n, s, p = map(int, input().split())\nn_sheets = ceil(n / s)* k\nn_p = ceil(n_sheets / p)\nprint(n_p)",
    "complexity": "constant",
    "problem": "0965_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n=int(input())\nl1=list(map(int,input().split()))\nans=0\nl1.sort()\nvisited=[0]*n\nfor i in range(n):\n    if visited[i]==1:\n        continue\n    visited[i]=1\n    ans+=1\n    for j in range(i+1,n):\n        if visited[j]==0 and l1[j]%l1[i]==0:\n            visited[j]=1\nprint(ans)",
    "complexity": "quadratic",
    "problem": "1209_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res//x * (x-1)\n            while n%x==0:\n                n //= x\n    if n!=1:\n        res = res//n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n//=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):#\u6392\u4ed6\u7684\u8ad6\u7406\u548c\u306e\u968e\u4e57\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\n#O(|S|)\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=None):\n        self.BIT=[0]*(n+1)\n        self.num=n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        self.mod = mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matrix[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matrix[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matrix[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]+other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]-other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matrix[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m//=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matrix[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nclass SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def bisect_l(self,l,r,x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:\n                    Rmin = r-1\n            l >>= 1\n            r >>= 1\n\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        else:\n            return -1\n\nfrom heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        forward = [to, cap, cost, None]\n        backward = forward[3] = [fr, 0, -cost, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [None]*N\n\n        d0 = [INF]*N\n        dist = [INF]*N\n\n        while f:\n            dist[:] = d0\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                r0 = dist[v] + H[v]\n                for e in G[v]:\n                    w, cap, cost, _ = e\n                    if cap > 0 and r0 + cost - H[w] < dist[w]:\n                        dist[w] = r = r0 + cost - H[w]\n                        prv_v[w] = v; prv_e[w] = e\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return None\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, prv_e[v][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = prv_e[v]\n                e[1] -= d\n                e[3][1] += d\n                v = prv_v[v]\n        return res\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import log,gcd\n\ninput = lambda :sys.stdin.buffer.readline()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn = int(input())\na = li()\n\ninv = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        if a[i] > a[j]:\n            inv += 1\ninv %= 2\n\nm = int(input())\nfor _ in range(m):\n    l,r = mi()\n    L = r-l+1\n\n    all = L*(L-1)//2\n    if all%2==1:\n        inv = 1 - inv\n\n    print(\"odd\" if inv else \"even\")\n",
    "complexity": "quadratic",
    "problem": "0911_D",
    "from": "CODEFORCES",
    "tags": "brute force,math"
}
{
    "src": "######################################################################\n# Write your code here\nimport sys\ninput = sys.stdin.readline\n#import resource\n#resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY])\n#sys.setrecursionlimit(0x100000)\n# Write your code here\nRI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nrw = lambda : input().strip().split()\n#from collections import defaultdict as df\n#import heapq \n#heapq.heapify(li) heappush(li,4) heappop(li)\n#import random\n#random.shuffle(list)\ninfinite = float('inf')\n#######################################################################\n\nt=int(input())\n\nfor _ in range(t):\n    n,k=RI()\n    s=input()\n\n    mini=n\n    \n    test=\"RGB\"*(k//3 + 5)\n    for i in range(n-k+1):\n        count=0\n        \n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    test=\"GBR\"*(k//3 + 5)\n    for i in range(n-k+1):\n        count=0\n        \n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    test=\"BRG\"*(k//3 + 5)\n    for i in range(n-k+1):\n        count=0\n        \n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    print(mini)\n",
    "complexity": "quadratic",
    "problem": "1196_D1",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "from collections import defaultdict\nn = int(input())\narr = defaultdict(int)\nfor a0 in range(n):\n\tl,r = input().strip().split()\n\tl,r=int(l),int(r)\n\tarr[l]+=1\n\tarr[r+1]-=1\n\nbrr=[0]*(n+1)\n\nl=sorted(arr.keys())\nsum=arr[l[0]]\nprevpoint=l[0]\nfor key in l[1:]:\n\tbrr[sum]+=key-prevpoint\n\tprevpoint=key\n\tsum+=arr[key]\nprint(*brr[1:])",
    "complexity": "nlogn",
    "problem": "1000_C",
    "from": "CODEFORCES",
    "tags": "data structures,implementation,sortings"
}
{
    "src": "import sys\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\nr, g, b = nm()\nR = nl()\nG = nl()\nB = nl()\ndp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\nR.insert(0, 0)\nG.insert(0, 0)\nB.insert(0, 0)\ndp[0][0][0], ans = 0, 0\nfor i in range(0, r+1):\n    for j in range(0, g+1):\n        for k in range(0, b+1):\n            if i==0 and j==0 and k==0:continue\n            if i and j and dp[i - 1][j - 1][k] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])\n            if k and j and dp[i][j - 1][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])\n            if i and k and dp[i - 1][j][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "import sys\nreadline = sys.stdin.buffer.readline\n\nN = int(readline())\nA = list(map(int, readline().split()))\n\ndp = [[0]*N for _ in range(N)]\nfor j in range(N):\n    dp[j][0] = A[j]\n\nfor l in range(1, N):\n    for j in range(l, N):\n        for k in range(j-l, j):\n            if dp[k][k-j+l] == dp[j][j-k-1] > 0:\n                dp[j][l] = 1+dp[j][j-k-1]\n                break\n\ndp = [None] + dp\nDp = [0]*(N+1)\nfor j in range(1, N+1):\n    res = N\n    for l in range(j):\n        if dp[j][l]:\n            res = min(res, 1+Dp[j-l-1])\n    Dp[j] = res\nprint(Dp[N])\n\n",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import math\n#n,s = map(int, input().strip().split(' '))\nn=int(input())\n#lst = list(map(int, input().strip().split(' ')))\ns2=input()\ns2=list(s2)\ns=[]\nfor i in range(n):\n    if s2[i]=='0':\n        continue\n    else:\n        s.append(int(s2[i]))\ns1=sum(s)\nn=len(s)\nl=[]\nfor i in range(2,n+1):\n    if s1%i==0:\n        l.append(s1//i)\nf=0\nif len(s)==0:\n    f=1\nfor i in range(len(l)):\n    c=0\n    if f==1:\n        break\n    for j in range(n):\n        c+=s[j]\n        if c==l[i]:\n            c=0\n            if j==n-1:\n                f=1\n        elif c<l[i]:\n            c=c\n        else:\n            break\nif f==0:\n    print('NO')\nelse:\n    print('YES')",
    "complexity": "quadratic",
    "problem": "1030_C",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "\"\"\"\nID: happyn61\nLANG: PYTHON3\nPROB: loan\n\"\"\"\nfrom itertools import product\nimport itertools\n#from collections import defaultdict\nimport sys\nimport heapq\nfrom collections import deque\nMOD=1000000000007\n#fin = open ('loan.in', 'r')\n#fout = open ('loan.out', 'w')\n#print(dic[\"4734\"])\ndef find(parent,i):\n\n\n    if parent[i] != i: \n        parent[i]=find(parent,parent[i]) \n    return parent[i] \n\n        # A utility function to do union of two subsets \ndef union(parent,rank,xx,yy): \n    x=find(parent,xx)\n    y=find(parent,yy)\n    if rank[x]>rank[y]:\n        parent[y]=x\n    elif rank[y]>rank[x]:\n        parent[x]=y\n    else:\n        parent[y]=x\n        rank[x]+=1\nans=0\n#NK=sys.stdin.readline().strip().split()\n#K=int(sys.stdin.readline().strip())\n#N=int(NK[0])\n#K=int(NK[1])\n#M=int(NK[2])\n#ol=list(map(int,sys.stdin.readline().strip().split()))\n#d={0:0,1:0}\n\nx=0\ny=0\n\nMAX=1000000000\nN,M,K=list(map(int,sys.stdin.readline().strip().split()))\nW=[[[MAX,MAX,MAX,MAX] for j in range(M)] for i in range(N)] #L R U D\nfor i in range(N):\n    l=list(map(int,sys.stdin.readline().strip().split()))\n    for j in range(M-1):\n        W[i][j][1]=l[j]\n        W[i][j+1][0]=l[j]\nfor i in range(N-1):\n    l=list(map(int,sys.stdin.readline().strip().split()))\n    for j in range(M):\n        #print(l,i,j)\n        W[i][j][3]=l[j]\n        W[i+1][j][2]=l[j]\n        \n#print(W)\nif K%2==1:\n    for i in range(N):\n        ans=[]\n        for j in range(M):\n            ans.append(\"-1\")\n        print(\" \".join(ans))\nelse:\n    \n    K=K//2\n    dp=[[[0 for j in range(M)] for i in range(N)] for k in range(K+1)]\n    for kt in range(1,K+1):\n        \n        dl=((0,-1),(0,1),(-1,0),(1,0))\n        for i in range(N):\n            for j in range(M):\n                ans=MAX\n                for t in range(4):\n                    \n                    ii,jj=dl[t]\n                \n                    if i+ii>=0 and i+ii<N and j+jj>=0 and j+jj<M:\n                        ans=min(ans,dp[kt-1][i+ii][j+jj]+W[i][j][t]*2)\n                    #print(i,j,ii,jj,ans)\n                dp[kt][i][j]=ans\n    #print(dp[-1])\n    for i in range(N):\n        ans=[]\n        for j in range(M):\n            ans.append(str(dp[-1][i][j]))\n        print(\" \".join(ans))\n\n                \n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "from collections import defaultdict\nfrom math import gcd\nn = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\ndp = defaultdict(lambda: float(\"inf\"))\nfor a, b in zip(A, B):\n    dp[a] = min(dp[a], b)\n    for d in dp.copy():\n        cur = gcd(a, d)\n        dp[cur] = min(dp[cur], dp[a] + dp[d])\nif 1 not in dp:\n    print(-1)\nelse:\n    print(dp[1])",
    "complexity": "np",
    "problem": "0510_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,dp,math"
}
{
    "src": "n,k = [int(x) for x in input().split()]\na = []\nfor _ in range(n):\n    a.append([int(x) for x in input().split()])\n\na.sort(key = lambda x: x[1])\na.sort(reverse=True,key=lambda x: x[0])\nb=a[k-1] \nprint(a.count(b))",
    "complexity": "nlogn",
    "problem": "0166_A",
    "from": "CODEFORCES",
    "tags": "binary search,implementation,sortings"
}
{
    "src": "import sys\n\nIS_LOCAL = False\n\n\ndef readMultiple(f):\n    return f(map(int, input().split()))\n\n\ndef main():\n    n = 3\n    a = [1, 2, -4]\n\n    if not IS_LOCAL:\n        n = int(input())\n        a = readMultiple(list)\n\n    for i, x in enumerate(a):\n        if x >= 0:\n            a[i] = -x - 1\n\n    cnt_neg = 0\n    for x in a:\n        if x < 0:\n            cnt_neg += 1\n\n    b = sorted([(abs(x), i) for i, x in enumerate(a)])\n    if cnt_neg % 2 == 1:\n        ind = b[n-1][1]\n        a[ind] = -a[ind] - 1\n\n    print(' '.join(map(str, a)))\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1 and sys.argv[1] == 'True':\n        IS_LOCAL = True\n    main()\n",
    "complexity": "nlogn",
    "problem": "1180_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation"
}
{
    "src": "k=int(input())\ni=0\nr=1\nwhile(k>=r):\n    r+=9*(i+1)*10**i\n    i+=1\nr=r-(9*i*10**(i-1))\nans=str(((k-r)//i)+10**(i-1))[(k-r)%i]\nprint(ans)",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "def mul(x, y, md):\n\treturn x * y % md;\n\ndef power(x, y, md) :\n\tres = 1;\n\twhile (y != 0):\n\t\tif (y & 1):\n\t\t\tres = mul(res, x, 1000000007);\n\t\tx = mul(x, x, 1000000007);\n\t\ty >>= 1;\n\treturn res\n\ndef inv(x, md):\n\treturn power(x, md - 2, 1000000007);\n\nt = input().split()\na = int(t[0])\nk = int(t[1])\nif (a == 0):\n\tprint(0)\nelse:\n\tfirst = power(2, 2 * k, 1000000007);\n\tsecond = power(2, k, 1000000007);\n\tans = mul(first, 2 * a - 1, 1000000007) + second;\n\tthird = inv(second, 1000000007);\n\tans = mul(ans, third, 1000000007);\n\tprint(ans)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "#########################################################################################################\\\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\nimport sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math \n\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):  \n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n    \"\"\"\n    L is a list.\n    The function returns the power set, but as a list of lists.\n    \"\"\"\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n    \n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n        \n    #the function could stop here closing with\n    #return powerset\n\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n        \n    return powerset_orderred\ndef fastPlrintNextLines(a):\n    # 12\n    # 3\n    # 1\n    #like this\n    #a is list of strings\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\n#__________________________TEMPLATE__________________OVER_______________________________________________________\n\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\") \n# else:\n#     input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nt = 1\n# t = int(input())\nfor _ in range(t):\n    n,m = li()\n    s = list(si())\n    t = list(si())\n    if '*' not in s:\n        if s==t:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n        continue\n    i = s.index('*')\n    if s[:i]==t[:i]:\n        s = s[i:]\n        t = t[i:]\n        s=s[::-1]\n        t = t[::-1]\n        i = s.index('*')\n        \n        if len(t)>=i and s[:i]==t[:i]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")\n    \n",
    "complexity": "linear",
    "problem": "1023_A",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,strings"
}
{
    "src": "mecces, burgerKing, both, groupSize = map(int,input().strip().split(' '))\nmecces -= both\nburgerKing -= both\nnotPassed = groupSize - sum((mecces,burgerKing,both))\nif notPassed > 0 and burgerKing >= 0 and mecces >= 0:\n    print(notPassed)\nelse:\n    print(-1)",
    "complexity": "constant",
    "problem": "0991_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import math\nn,k=map(int,input().split())\nfor _ in range(k):\n    l,r=map(int,input().split())\nfor i in range(1,n+1):\n    if i%2==0:\n        print('0',end='')\n    else:\n        print('1',end='')\nprint()\n\n",
    "complexity": "linear",
    "problem": "1004_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,greedy,implementation,math"
}
{
    "src": "I = lambda: map(int,input().split())\nn,l,r,x=I()\nC,k=[*I()],0\nfor i in range(2**n):\n    W = [w for w,b in zip(C, bin(i)[2:].zfill(n)) if b=='1']\n    \n    if l <= sum(W) <= r and max(W)-min(W) >= x:\n        k += 1\nprint(k)",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "\nr,g,b = map(int,input().split())\nl1 = list(map(int,input().split()))\nl2 = list(map(int,input().split()))\nl3 = list(map(int,input().split()))\nl1.sort(reverse=True)\nl2.sort(reverse=True)\nl3.sort(reverse=True)\ndp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]\nans = 0\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            if i == 0 and j == 0:\n                dp[i][j][k] = 0\n            if j == 0 and k == 0:\n                dp[i][j][k] = 0\n            if i == 0 and k == 0:\n                dp[i][j][k] = 0\n            if i>0 and j>0 and k>0:\n                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])\n            else:\n                if i>0 and j>0:\n                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]\n                elif i>0 and k>0:\n                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]\n                elif j>0 and k>0:\n                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]\n            ans = max(ans,dp[i][j][k])\n                    \nprint(ans)\n                                   \n                \n            \n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "from sys import stdin\ninput=stdin.readline\ndef answer():\n    dp=[[[1e9 for i in range(k//2 + 1)] for j in range(m)] for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            dp[i][j][0]=0\n    \n    for x in range(1,k//2 + 1):\n\n        for i in range(n):\n            for j in range(m):\n\n                if(i > 0):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1] + c[i-1][j])\n                if(j > 0):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1] + r[i][j-1])\n                if(i + 1 < n):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1] + c[i][j])\n                if(j + 1 < m):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1] + r[i][j])\n\n    for i in range(n):\n        for j in range(m):\n            print(2*dp[i][j][-1],end=' ')\n\n        print()\n\n\n\nn,m,k=map(int,input().split())\n\nr=[list(map(int,input().split())) for i in range(n)]\nc=[list(map(int,input().split())) for i in range(n-1)]\n\nif(k & 1):\n    for i in range(n):\n        for j in range(m):\n            print(-1,end=' ')\n    \nelse:answer()\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "n, v = map(int, input().strip().split())\nanswer = 0\nn -= 1\nif n <= v:\n    print(n)\nelse:\n    answer =v\n\n    for i in range(1,n-v + 1):\n\n        answer += (i + 1)\n    print(answer)",
    "complexity": "linear",
    "problem": "1113_A",
    "from": "CODEFORCES",
    "tags": "dp,greedy,math"
}
{
    "src": "# -*- coding: utf-8 -*-\n\ns = input()\nn,m = len(s),0\n\nfor i in range(n-1):\n    for j in range(i,n+1):\n        if len(s[i:j]) > m and s[i:j] in s[i+1:n]: m = len(s[i:j])\n    \nprint(m)\n",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "n, k = [int(i) for i in input().split()]\np = [int(i) for i in input().split()]\nans = [-1] * (max(p) + 1)\nans[0] = 0\nfor i in range(n):\n\tif ans[p[i]] < 0:\n\t\tposition = p[i] - k + 1\n\t\tfor j in range(max(0,p[i] - k + 1), p[i] + 1):\n\t\t\tif ans[j] < 0:\n\t\t\t\tposition = j\n\t\t\t\tbreak\n\t\tj = max(0, position - 1)\n\t\tkey = ans[j]\n\t\tcount = 0\n\t\twhile j >= 0:\n\t\t\tif ans[j] != key:\n\t\t\t\tposition1 = j + 1\n\t\t\t\tbreak\n\t\t\tj -= 1\n\t\t\tcount += 1\n\t\tif count + p[i] + 1 - position > k:\n\t\t\tkey = position\n\t\tfor j in range(position, p[i] + 1):\n\t\t\tans[j] = key\n\nfor i in range(n):\n\tif i != len(p) - 1:\n\t\twk1 = \" \"\n\telse:\n\t\twk1 = \"\\n\"\n\tprint(ans[p[i]], end = wk1)\n",
    "complexity": "quadratic",
    "problem": "0980_C",
    "from": "CODEFORCES",
    "tags": "games,greedy"
}
{
    "src": "arra = []\narrb = []\narr = []\ns = \"\"\ntemp = 1 \nvalue = ans = n = 0\n \ndef fill(myList = [], *args):\n    for i in range(n):\n        arra.insert(0,0)  \n        \ndef check():\n    for i,j in zip(arra,arrb):\n        if i == j:\n            return 1\n        else:\n            return 0\n\n        \ndef Engine1(num): \n    if num > 1: \n        Engine1(num // 2) \n    arra.append( num%2 )\ndef Engine2(num):\n    if num > 1: \n        Engine2(num // 2) \n    arrb.append( num%2 )\n\na,b = map(int,input().split())\nEngine1(a)\nEngine2(b)\n\nn = abs(len(arra)-len(arrb))\nif(len(arra)>len(arrb)):\n    fill(arrb)\nif(len(arra)<len(arrb)):\n    fill(arra)\n    \n\nfor i in range(len(arra)):\n    if(check() == 0):\n        break\n    check()\n    arra.pop(0)\n    arrb.pop(0)\n\nfor i in range(len(arra)):\n    ans += temp\n    temp *= 2\nprint(ans)",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "def process(S):\n    n = len(S)\n    h_count = 0\n    answer = float('inf')\n    for c in S:\n        if c=='H':\n            h_count+=1\n    current = 0\n    for i in range(h_count):\n        if S[i]=='H':\n            current+=1\n    answer = min(answer, h_count-current)\n    for i in range(h_count, n+h_count):\n        if i > n-1:\n            i1 = i-n\n        else:\n            i1 = i \n        i2 = i-h_count\n        if S[i1]=='H':\n            current+=1\n        if S[i2]=='H':\n            current-=1\n        answer = min(answer, h_count-current)\n    return answer\n\nn = int(input())\nS = input()\nprint(process(S))",
    "complexity": "linear",
    "problem": "0046_C",
    "from": "CODEFORCES",
    "tags": "two pointers"
}
{
    "src": "# from typing import List, Set, Dict, Tuple, Text, Optional\nfrom collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__  # type: ignore\n\n#########\n# INPUT #\n#########\n\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n    # type: () -> str\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\n##########\n# OUTPUT #\n##########\n\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n    # type: (str) -> None\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n    # type: (str) -> None\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\n###########\n# LIBRARY #\n###########\n\n\ndef bootstrap(f, stack=[]):\n  # Deep Recursion helper.\n  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst\n  # Usage:\n\n  # @bootstrap\n  # def recur(n):\n  #   if n == 0:\n  #     yield 1\n  #   yield (yield recur(n-1)) * n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\n\n'''\narrayInit([3, 4, 5], 0):\nInitialize 3-dim array with [3][4][5] with 0 as its initial value\n\nTested with:\nhttps://codeforces.com/contest/625/problem/B\n'''\n\n\nclass MDArray(object):\n  # Faster implementation of md array, using a single array and a lot of math.\n  '''\n  >>> x = MDArray([1, 2, 5], 5)\n  >>> x.get([0, 0, 0])\n  5\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.set([0, 1, 2], 3)\n  3\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.set([0, 1, 3], 1)\n  1\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.get([0, 1, 3])\n  1\n  '''\n\n  def __init__(self, dimensions, initial_value=0):\n    # type: (Iterable[int], Any) -> None\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n    # type: (Iterable[int]) -> Any\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n    # type: (Iterable[int], Any) -> Any\n    self.arr[self._index(indexes)] = value\n    return value\n\n\n#########\n# LOGIC #\n#########\n\ndef encode(row, col, n, m):\n  return row * m + col\n\n\ndef solve(node, remain, adj, dp):\n  if remain == 0:\n    return 0\n  key = (node, remain)\n  mem = dp.get(key)\n  if mem != -1:\n    return mem\n\n  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))\n  dp.set(key, ans)\n  return ans\n\n\ndef main(inp, out):\n  # type: (Input, Output) -> any\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = MDArray([total_nodes, k+2], -1)\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(solve(node, k/2, adj, dp) * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\n\n###############\n# BOILERPLATE #\n###############\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "# https://codeforces.com/problemset/problem/701/C\n# two pointers method\n\n\ndef main():\n    n = int(input())\n    s = input()\n\n    u_set = set()\n    for i in s:\n        u_set.add(i)\n    u_cnt = len(u_set)\n\n    d = {}\n    j = 0\n    ans = 10**9\n    for i in range(n):\n        while len(d.keys()) < u_cnt and j < n:\n            d[s[j]] = d.get(s[j], 0) + 1\n            j += 1\n\n        if len(d.keys()) == u_cnt:\n            if j - i < ans:\n                ans = j - i\n        elif j == n:\n            break\n\n        d[s[i]] -= 1\n        if d[s[i]] == 0:\n            del d[s[i]]\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n",
    "complexity": "linear",
    "problem": "0701_C",
    "from": "CODEFORCES",
    "tags": "binary search,strings,two pointers"
}
{
    "src": "n = int(input())\nm = input().split()\nt = []\nfor i in range(n):\n    m[i] = int(m[i])\n    if i == 0:\n        t.append(m[i]+1)\n    else:\n        t.append(max(t[i-1], m[i]+1))\ns = t[n-1] - m[n-1] - 1\nfor i in range(n-2, -1, -1):\n    if t[i] < t[i+1]-1:\n        t[i] = t[i+1]-1\n    s += t[i] - m[i] - 1\nprint(s)",
    "complexity": "linear",
    "problem": "0924_C",
    "from": "CODEFORCES",
    "tags": "data structures,dp,greedy"
}
{
    "src": "n, k = [int(i) for i in input().split()]\na, j = sorted([int(i) for i in input().split()]), 0\nfor i in a:\n    while i > a[j]:\n        if i <= a[j] + k:\n            n -= 1\n        j += 1\nprint(n)",
    "complexity": "nlogn",
    "problem": "0990_B",
    "from": "CODEFORCES",
    "tags": "greedy,sortings"
}
{
    "src": "# %matplotlib inline\n\ndef main():\n    n, k = [int(x) for x in input().split(' ')]\n    if k==1:\n        print(n)\n        return\n    a = []\n    b = {}\n    a = [int(x) for x in input().split(' ')]\n    a.sort()\n\n    a=dict(zip(a,range(n)))\n    count = {}\n\n    for x in a:\n        if x % k == 0 and int(x / k) in a:\n            b[x] = b[int(x / k)]\n            count[b[int(x / k)]] += 1\n        else:\n            b[x] = x\n            count[x] = 1\n\n    for x,y in count.items():\n        n -= int(y / 2)\n\n    print(n)\n\n\nmain()\n",
    "complexity": "nlogn",
    "problem": "0274_A",
    "from": "CODEFORCES",
    "tags": "binary search,greedy,sortings"
}
{
    "src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\n\nzl = getIntList()\nzr = getIntList()\n\nzt = [ (zl[i] + zr[i], i) for i in range(N) ]\nzt.sort()\nza = [0 for i in range(N) ]\nnow = N\nfor i in range(N):\n    if i>0 and zt[i-1][0] <zt[i][0]:\n        now-=1\n    za[ zt[i][1] ] = now\n\nfor i in range(N):\n    l = 0\n    r = 0\n    for j in range(i):\n        if za[j] > za[i]:\n            l+=1\n    for j in range(i+1, N):\n        if za[j] > za[i]:\n            r+=1\n    if zl[i] != l or zr[i] != r:\n        print('NO')\n        sys.exit()\nprint('YES')\nfor i in range(N):\n    print(za[i],end = ' ')\n\n\n\n\n",
    "complexity": "quadratic",
    "problem": "1054_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation"
}
{
    "src": "import sys\ninput=sys.stdin.buffer.readline\nn,m=map(int,input().split())\nfor i in range(n//2+n%2):\n    x1=i+1\n    x2=n-i\n    if(x1==x2):\n        for j in range(m//2+m%2):\n            if(j+1==m-j):\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n            else:\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(m-j)+\"\\n\"))\n    else:\n        if(i%2==0):\n            for j in range(m):\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(m-j)+\"\\n\"))\n        else:\n            for j in range(m):\n                sys.stdout.write((str(x1)+\" \"+str(m-j)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(j+1)+\"\\n\"))",
    "complexity": "quadratic",
    "problem": "1179_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms"
}
{
    "src": "def maxx(n):\n\treturn n&-n\nn,q=map(int,input().split())\nroot=n//2+1\nwhile q>0:\n\tx=int(input())\n\ts=input()\n\n\tfor i in s:\n\t\tif i=='U' and x!=root:\n\t\t\tp=x+maxx(x)\n\t\t\tif x==p-maxx(p)//2:\n\t\t\t\tx=p\n\t\t\telse:\n\t\t\t\tx=x-maxx(x)\n\t\telif i=='L':\n\t\t\tx=x-maxx(x)//2\n\t\telif i=='R':\n\t\t\tx=x+maxx(x)//2\n\tq=q-1\n\tprint(x)",
    "complexity": "np",
    "problem": "0792_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,trees"
}
{
    "src": "l,r=input().split(\" \")\nl,r=int(l),int(r)\n\na,b,c=l,l+1,l+2\n\nif (l % 2 != 0):\n    a,b,c=a+1,b+1,c+1\n    \nif (c > r):\n    print(-1)\n    \nelse:\n    print(a,b,c)",
    "complexity": "constant",
    "problem": "0483_A",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,math,number theory"
}
{
    "src": "import sys, heapq\n\nn, x = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\nres = dict().fromkeys(set(arr), 0)\nfor i in arr:\n    res[i] += 1\ncan = False\nfor i in res:\n    if res[i] >= 2:\n        can = True\n        break\nif can:\n    print(0)\nelse:\n    res = dict().fromkeys([i for i in range(max(arr) + 1)])\n    for i in res:\n        res[i] = []\n    for i in range(n):\n        temp = set()\n        now = arr[i]\n        cnt = 0\n        while True:\n            added = False\n            before = len(temp)\n            temp.add(now)\n            after = len(temp)\n            if before == after:\n                break\n            heapq.heappush(res[now], cnt)\n            now = now & x\n            cnt += 1\n    ans = 9876543210\n    for i in res:\n        if len(res[i]) >= 2:\n            ans = min(ans, heapq.heappop(res[i]) + heapq.heappop(res[i]))\n    print(ans if ans != 9876543210 else -1)",
    "complexity": "linear",
    "problem": "1013_B",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "def main():\n    n, m = map(int, input().split())\n    w = [c == '*' for i in range(n) for c in input()]\n    nm = n * m\n    q = [*[range(i, i + m) for i in range(0, nm, m)],\n            *[range(i, nm, m) for i in range(m)]]\n    e = [1000] * nm\n    for f in True, False:\n        for r in q:\n            v = 0\n            for i in r:\n                if w[i]:\n                    v += 1\n                    if e[i] > v:\n                        e[i] = v\n                else:\n                    v = e[i] = 0\n        if f:\n            w.reverse()\n            e.reverse()\n    e = [c if c != 1 else 0 for c in e]\n    for f in True, False:\n        for r in q:\n            v = 0\n            for i in r:\n                if v > e[i]:\n                    v -= 1\n                else:\n                    v = e[i]\n                if v:\n                    w[i] = False\n        if f:\n            w.reverse()\n            e.reverse()\n    if any(w):\n        print(-1)\n    else:\n        r = []\n        for i, c in enumerate(e):\n            if c:\n                r.append(f'{i//m+1} {i%m+1} {c-1}')\n        print(len(r), '\\n'.join(r), sep='\\n')\n\n\nmain()",
    "complexity": "quadratic",
    "problem": "1015_E2",
    "from": "CODEFORCES",
    "tags": "binary search,dp,greedy"
}
{
    "src": "n = int(input())\nl = [4,7,47,74,444,447,474,477,747,744,774,777]\n\nfor i in l:\n    if n % i == 0:\n        print('YES')\n        break\n    else:\n        pass\nelse:\n    print('NO')\n    \n        \n\n\n\n            \n",
    "complexity": "constant",
    "problem": "0122_A",
    "from": "CODEFORCES",
    "tags": "brute force,number theory"
}
{
    "src": "\nn=int(input())\narr=[]\nfor i in range(n):\n    arr.append(input())\n\narr.sort(key=lambda x: len(x))\nflag=False\nfor i in range(n-2,-1,-1):\n    if arr[i] not in arr[i+1]:\n        flag=True\n        break\n\nif flag:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in arr:\n        print(i)",
    "complexity": "nlogn",
    "problem": "0988_B",
    "from": "CODEFORCES",
    "tags": "sortings,strings"
}
{
    "src": "n=input()\ni=0\nwhile(True):\n    if (n-9*10**i*(i+1))<=0:\n        break\n    n-=9*10**i*(i+1)\n    i+=1\n\na=n/(i+1)\nb=n%(i+1)\nif(b!=0):\n    print(str(10**i+a)[b-1])\nelse:\n    print(str(10**i+a-1)[-1])\n",
    "complexity": "constant",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "n = int(input())\nr = 0\ni = 2\nwhile i*2 <=n:\n\ta = int(n/i)\n\tr += (a+2)*(a-2+1)/2\n\ti += 1\nprint(int(4*r))\n",
    "complexity": "linear",
    "problem": "1062_D",
    "from": "CODEFORCES",
    "tags": "dfs and similar,graphs,implementation,math"
}
{
    "src": "from sys import stdin\ninput = stdin.buffer.readline\n \nn,k=map(int,input().split())\narr=[int(x) for x in input().split()]\n \nl=[]\nfor i in range(n):\n    l.append((arr[i],i))\n \nl.sort(reverse=True)\n \ndp=[]\nx=0\nfor i in range(k):\n    dp.append(l[i][1])\n    x=x+l[i][0]\n \nprint(x)\ndp.sort()\ndp=[-1]+dp\n \nl=len(dp)\nfor i in range(1,l-1):\n    print(dp[i]-dp[i-1],end=\" \")\nprint(n-1-dp[l-2])    ",
    "complexity": "nlogn",
    "problem": "1006_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "'''\n\n                            Online Python Compiler.\n                Code, Compile, Run and Debug python program online.\nWrite your code in this editor and press \"Run\" button to execute it.\n\n'''\n\ntot, choc = [int(i) for i in input().split()]\n\n# add = 0\n# mid = tot\nbg = 1\nend = tot\n\nwhile True:\n    mid = (bg + end) / 2\n    add = (mid * (mid + 1)) / 2\n    sub = tot - mid\n    if add - sub == choc:\n        print(int(sub))\n        break\n    if add - sub < choc:\n        bg = mid + 1\n    else:\n        end = mid - 1\n    \n",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "\nn=int(input())\ns=list(input())\nt=list(input())\nd={}\nans=0\nx,y=-1,-1\nfor i in range(n):\n\tif s[i]!=t[i]:\n\t\td[(s[i],t[i])]=i\n\t\tans+=1\nl=[chr(i+97) for i in range(26)]\nfor i in l:\n\tfor j in l:\n\t\tif (i,j) in d and (j,i) in d:\n\t\t\tans-=2\n\t\t\tx=d[(i,j)]+1\n\t\t\ty=d[(j,i)]+1\n\t\t\tbreak\n\tif x!=-1:\n\t\tbreak\nif x==y==-1:\n\tfor i in l:\n\t\tfor j in l:\n\t\t\tfor k in l:\n\t\t\t\tif (i,j) in d and (j,k) in d:\n\t\t\t\t\tans-=1\n\t\t\t\t\tx=d[(i,j)]+1\n\t\t\t\t\ty=d[(j,k)]+1\n\t\t\t\t\tbreak\n\t\tif x!=-1:\n\t\t\tbreak\nprint(ans)\nprint(x,y)",
    "complexity": "linear",
    "problem": "0527_B",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "def matches(pos, c, case):\n    if case==0:\n        return pos%3==\"RGB\".index(c)\n    elif case==1:\n        return pos%3==\"GBR\".index(c)\n    else:\n        return pos%3==\"BRG\".index(c)\n\nq = int(input())\nfor _ in range(q):\n    n, k = map(int, input().split())\n\n    s = input()\n\n    mglobal = k\n\n    r=g=b=0\n\n    for i, c in enumerate(s[:k]):\n            \n        r += not matches(i, c, 0)\n        g += not matches(i, c, 1)\n        b += not matches(i, c, 2)\n    \n    mglobal = min([mglobal, r, g, b])\n    for i, c in enumerate(s[k:]):\n        i+=k\n        r += -(not matches(i-k, s[i-k], 0)) + (not matches(i, c, 0))    \n        g += -(not matches(i-k, s[i-k], 1)) + (not matches(i, c, 1))    \n        b += -(not matches(i-k, s[i-k], 2)) + (not matches(i, c, 2))    \n    \n        mglobal = min([mglobal, r, g, b])\n\n    print(mglobal)\n",
    "complexity": "linear",
    "problem": "1196_D1",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))[::-1]\nb = list(map(int, input().split()))\nans = [0] * n\nmarked = [True] * (n + 1)\nfor i in range(n):\n    if marked[b[i]]:\n        while True:\n            marked[a[-1]] = False\n            ans[i] += 1\n            if a[-1] == b[i]:\n                a.pop()\n                break\n            a.pop()\n    else:\n        continue\nprint(*ans)",
    "complexity": "quadratic",
    "problem": "1073_B",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key,lru_cache\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nimport sys\n# input = sys.stdin.readline\n \nM = mod = 10 ** 9 + 7\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\ndef li2():return [str(i)[2:-1] for i in input().rstrip().split()]\ndef li3():return [int(i) for i in st()]\n\n\n\nn = val()\nl = li()\nc = li()\n\nelement = l[0]\nfor i in range(1, n):element = math.gcd(element, l[i])\n\nif element != 1:\n    print(-1)\n    exit()\n    \nmyset = {}\n\nfor ind, i in enumerate(l):\n    for j in list(myset):\n        temp = math.gcd(j, i)\n        if(temp not in myset):myset[temp] = myset[j] + c[ind]\n        else:myset[temp] = min(myset[temp], c[ind] + myset[j])\n    \n    if i not in myset:myset[i] = c[ind]\n    else:myset[i] = min(myset[i], c[ind])\n\nprint(myset[1])",
    "complexity": "np",
    "problem": "0510_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,dp,math"
}
{
    "src": "n,m = map(int, input().split())\nb = [int(s) for s in input().split()]\ng = [int(s) for s in input().split()]\nans = 0\nmaxb2, maxb = sorted(b)[-2:]\nming = min(g)\nif maxb > ming:\n    ans = -1\nelse:\n    ans += sum(b)*m\n    ans += (sum(g)-ming)-(maxb*(m-1))\n    if ming > maxb:\n        ans += ming-maxb2\nprint(ans)",
    "complexity": "nlogn",
    "problem": "1159_C",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nans = []\n\n\ndef check(mid: int) -> bool:\n    global ans\n    dic = {}\n    for i in range(n):\n        bit = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                bit += 1\n            bit <<= 1\n        dic[bit >> 1] = i\n    for x, idx in dic.items():\n        for y, idy in dic.items():\n            if x | y == 2**m-1:\n                ans = idx + 1, idy + 1\n                return True\n    return False\n\n\nle = 0\nri = int(1e9)\nwhile le <= ri:\n    mid = (le + ri) >> 1\n    if check(mid):\n        le = mid + 1\n    else:\n        ri = mid - 1\nprint(ans[0], ans[1])\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "def f(n,s):\n    d=[-n,-n];\n    d[s]=0;\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)];\n    return d[s];\nimport math;\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny=y+x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))",
    "complexity": "np",
    "problem": "1463_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,math"
}
{
    "src": " ### @author Juan Sebastian Beltran Rojas \n ### @mail jsbeltran.valhalla@gmail.com \n ### @veredict \n ### @url https://codeforces.com/problemset/problem/1195/B\n ### @category \n ### @date 12/11/2019\n\nimport math\n\nline = input().split()\nN = int(line[0])\nK = int(line[1])\n\nn = (-3 + math.sqrt(9+4*(2*N+2*K)))/2\n\nprint(int(N-n))\n",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "n,m,a,b=[int(x) for x in input().split()]\nif n>m:\n\tif n%m==0:\n\t\tprint(0)\n\telse:\n\t\tt1=n%m\n\t\tprint(min(t1*b,(m-t1)*a))\nelif n==m:\n\tprint(0)\nelse:\n\tprint(min(n*b,(m-n)*a))",
    "complexity": "linear",
    "problem": "0990_A",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "from math import ceil\n\nn=int(input())\nd={1:[1],2:[1,2],3:[1,1,3]}\nif n in d:\n    for i in d[n]:\n        print(i,end=' ')\n    exit()\ndef f(n):\n    if n in d:\n        return d[n]\n    odds=ceil(n/2)\n    lis=[1]*odds\n    even=n//2\n    lis1=f(even)\n    for i in range(len(lis1)):\n        lis1[i]*=2\n    return lis+lis1\nans=f(n)\nfor i in ans:\n    print(i,end=' ')",
    "complexity": "nlogn",
    "problem": "1059_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "x,k = map(int,input().split())\nmod = 10**9 + 7\nif x == 0:\n    print(0)\nelse:\n    print(((2*x-1)*pow(2,k,mod) + 1)%mod)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n\nn = ria()[0]\nif n == 1:\n    print(1)\n    exit(0)\n\nif n == 2:\n    print(1, 2)\n    exit(0)\n\nif n == 3:\n    print(1, 1, 3)\n    exit(0)\n\nar = [0] * 30\n\nfor i in range(30):\n    ar[i] = n // (2 ** i) - n // (2 ** (i + 1))\nsd = 0\nfor i in range(30):\n    if sd == n - 1:\n        if n==(2**i):\n            print(2**i)\n        else:\n            print(n-n%(2**(i-1)))\n        exit(0)\n    for j in range(ar[i]):\n        print(2 ** i, end=' ')\n        sd += 1\n",
    "complexity": "linear",
    "problem": "1059_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\n\ndef check(a,mid,n,m,z):\n    b=Counter()\n    for i in range(n):\n        c=[\"0\"]*m\n        for j in range(m):\n            if a[i][j]>=mid:\n                c[j]=\"1\"\n        zz=int(\"\".join(c),2)\n        b[zz]=i\n    c=list(b.keys())\n    lc=len(c)\n    for i in range(lc):\n        for j in range(i,lc):\n            if c[i]|c[j]==z:\n                mi,x,y=10000000000,b[c[i]],b[c[j]]\n                for k in range(m):\n                    mi=min(mi,max(a[x][k],a[y][k]))\n                if mi>=mid:\n                    return (x,y)\ndef main():\n    n,m= map(int, input().split())\n    a=[list(map(int,input().split())) for _ in range(n)]\n    lo,hi,ans,y=0,10**9,[1,1],(1<<m)-1\n    while lo<=hi:\n        mid=(lo+hi)//2\n        z=check(a,mid,n,m,y)\n        if z:\n            lo=mid+1\n            ans=[z[0]+1,z[1]+1]\n        else:\n            hi=mid-1\n    print(*ans)\n# (region fastio\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "from sys import stdout, stdin, setrecursionlimit\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom bisect import *\nfrom string import *\nfrom queue import *\nfrom heapq import *\nfrom math import *\nfrom re import *\nfrom os import *\n\n####################################---fast-input-output----#########################################\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ndef fast(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in fast().split()]\n\n\nz, zz = fast, lambda: (map(int, z().split()))\nszz, graph, mod, szzz = lambda: sorted(\n    zz()), {}, 10**9 + 7, lambda: sorted(zzz())\n\n\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\n\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\n\n\n#################################################---Some Rule For Me To Follow---#################################\n\"\"\"\n    --instants of Reading problem continuously try to understand them.\n\n    --If you Know some-one , Then you probably don't know him !\n\n    --Try & again try\n\n\"\"\"\n##################################################---START-CODING---###############################################\n\n\n\nn, m = zz()\narr = zzz()\ns = sum(arr)\nx = [[] for i in range(m)]\nfor i in range(n): x[arr[i] % m].append(i)\nj = 0\nfor i in range(m):\n    while len(x[i]) > n // m:\n        while j < i or len(x[j % m]) >= n // m: j += 1\n        k = x[i].pop()\n        arr[k] += (j - i) % m\n        x[j % m].append(k)\nprint(sum(arr) - s)\nprint(*arr)\n",
    "complexity": "linear",
    "problem": "0999_D",
    "from": "CODEFORCES",
    "tags": "data structures,greedy,implementation"
}
{
    "src": "# %matplotlib inline\n\ndef main():\n    n, k = [int(x) for x in input().split(' ')]\n    if k==1:\n        print(n)\n        return\n    a = []\n    b = {}\n    a = [int(x) for x in input().split(' ')]\n    a.sort()\n\n    a=dict(zip(a,range(n)))\n    count = {}\n\n    for x in a:\n        if x % k == 0 and int(x / k) in a:\n            b[x] = b[int(x / k)]\n            count[b[int(x / k)]] += 1\n        else:\n            b[x] = x\n            count[x] = 1\n\n    for x,y in count.items():\n        n -= int(y / 2)\n\n    print(n)\n\n\nmain()\n",
    "complexity": "nlogn",
    "problem": "0274_A",
    "from": "CODEFORCES",
    "tags": "binary search,greedy,sortings"
}
{
    "src": "n = int(input())\na = [int(i) for i in input().split()]\na.sort()\ncount = 0\nfor i in range(n):\n    cur_c = a[i]\n    if not cur_c:\n        continue\n    count += 1\n    for j in range(i+1,n):\n        if a[j]%cur_c == 0:\n            a[j] = 0\nprint(count)",
    "complexity": "quadratic",
    "problem": "1209_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "n=int(input())\nif n==1:\n    print(1)\nelse:\n    p=list(map(int,input().split()))\n    children=[]\n    for i in range(n):\n        children.append([])\n    for i in range(n-1):\n        children[p[i]-1].append(i+1)\n    layers=[1]+[0]*(n-1)\n    layer=[0]\n    num=2\n    bylayer=[]\n    while len(layer)>0:\n        bylayer.append(layer)\n        newlayer=[]\n        for vert in layer:\n            for child in children[vert]:\n                layers[child]=num\n                newlayer.append(child)\n        layer=newlayer\n        num+=1\n    bylayer=bylayer[::-1]\n    count=[0]*n\n    for layer in bylayer:\n        for vert in layer:\n            if children[vert]==[]:\n                count[vert]=1\n            else:\n                count[vert]=sum(count[v] for v in children[vert])\n    count.sort()\n    out=\"\"\n    for guy in count:\n        out+=str(guy)+\" \"\n    print(out)",
    "complexity": "quadratic",
    "problem": "1056_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"
}
{
    "src": "n, m, k = map(int,input().split())\nline = [int(x) for x in input().split()]\nline.sort(reverse = True)\ncount = 0\nif k >=m:\n    print(count)\n    exit(0)\nfor i in range(n):\n    k += line[i]-1\n    count += 1\n    if k >= m:\n        print(count)\n        exit(0)\nprint(-1)",
    "complexity": "nlogn",
    "problem": "0257_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "import math\n\n\na, b = [int(x) for x in input().split()]\nwhile a != 0 and b != 0:\n    x = int(math.log(a, 2))\n    y = int(math.log(b, 2))\n    if x != y:\n        break\n    a = a & (~(1 << x))\n    b = b & (~(1 << y))\n\nif a == 0 and b == 0:\n    print(0)\nelse:\n    if b > a:\n        a, b = b, a\n    x = int(math.log(a, 2)) + 1\n    b = (1 << x) - 1\n    a = a | b\n    print(a)\n",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "R, G, B = map(int, input().split())\nL = [sorted(map(int, input().split())) for _ in range(3)]\n \nDP = [0] * ((R+1) * (G+1) * (B+1))\ndef idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b\n \nfor r in range(R+1):\n\tfor g in range(G+1):\n\t\tfor b in range(B+1):\n\t\t\tbest = 0\n \n\t\t\tif r:\n\t\t\t\tif g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]\n\t\t\t\tif b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])\n \n\t\t\tif g and b:\n\t\t\t\tbest = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])\n \n\t\t\tDP[idx(r, g, b)] = best\n \nprint(max(DP))",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "import math\ns1=str(input())\ns2=str(input())\nd1=0;d2=0;n=0\nanswer=0\nfor i in s1:\n    if i=='+':d1+=1\n    else:\n        d1-=1\nfor i in s2:\n    if i=='+':d2+=1\n    elif i=='?':n+=1\n    else:\n        d2-=1\nif n>=abs(d2-d1):\n    y=(n-abs(d1-d2))/2\n    if y%1==0:\n        answer=math.factorial(n)/math.factorial(n-y)/math.factorial(y)/2**n\nprint('%.9f'%answer)",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "# _\n#####################################################################################################################\n\ndef main():\n    pieces_Dimension = int(input())\n    piece1 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece2 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece3 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece4 = ''.join(input() for _ in range(pieces_Dimension))\n\n    brokenPieces = (piece1, piece2, piece3, piece4)\n    nSquares = pieces_Dimension*pieces_Dimension\n    squares = '01'*-(-nSquares//2)\n\n    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)\n\n\ndef nSquaresToRecolorIn(brokenPieces, nSquares, squares):\n    possible_nSquares = [(sum(piece[i] != squares[:-1][i] for i in range(nSquares)),\n                          sum(piece[i] != squares[1:][i] for i in range(nSquares)))\n                         for piece in brokenPieces]\n    possible_nSquares.sort(key=lambda x: x[0])\n\n    return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1]\n\n\nif __name__ == '__main__':\n    print(main())\n    # main()\n",
    "complexity": "quadratic",
    "problem": "0961_C",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,implementation"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n\nn,k=map(int,input().split())\n\nMIN=0\nMAX=n\n\nwhile True:\n    ANS=(MIN+MAX)//2\n    \n    if (n-ANS)*(n-ANS+1)//2-ANS>k:\n        MIN=ANS+1\n    elif (n-ANS)*(n-ANS+1)//2-ANS<k:\n        MAX=ANS-1\n    else:\n        print(ANS)\n        break\n",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "l,r = map(int,input().split())\n\nx = 64\nwhile x>=0 and  (l&(1<<x)) == (r&(1<<x)):\n    x-=1\nprint((1<<(x+1))-1)",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport collections\nimport itertools\nimport bisect\nimport heapq\n# sys.setrecursionlimit(100000)\n# ^^^TAKE CARE FOR MEMORY LIMIT^^^\nimport random\n\n\ndef main():\n    pass\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\n\ndef decimal(s):\n    return (int(s, 2))\n\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n //= 2\n        p += 1\n    return (p)\n\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\ndef primeFactorsCount(n):\n    cnt=0\n    while n % 2 == 0:\n        cnt+=1\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            cnt+=1\n            n = n // i\n    if n > 2:\n        cnt+=1\n    return (cnt)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\n\ndef countcon(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if (s[i] == ch):\n            c += 1\n        else:\n            break\n    return (c)\n\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\n\n\ndef isSubSequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\n\n\ndef maxfac(n):\n    root = int(n ** 0.5)\n    for i in range(2, root + 1):\n        if (n % i == 0):\n            return (n // i)\n    return (n)\n\n\ndef p2(n):\n    c = 0\n    while (n % 2 == 0):\n        n //= 2\n        c += 1\n    return c\n\n\ndef seive(n):\n    primes = [True] * (n + 1)\n    primes[1] = primes[0] = False\n    i = 2\n    while (i * i <= n):\n        if (primes[i] == True):\n            for j in range(i * i, n + 1, i):\n                primes[j] = False\n        i += 1\n    pr = []\n    for i in range(0, n + 1):\n        if (primes[i]):\n            pr.append(i)\n    return pr\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\n\ndef denofactinverse(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (pow(fac, m - 2, m))\n\n\ndef numofact(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (fac)\n\ndef sod(n):\n    s = 0\n    while (n > 0):\n        s += n % 10\n        n //= 10\n    return s\nx,k=map(int,input().split())\nmod=1000000007\ntp=pow(2,k+1,mod)\ntp2=pow(2,k,mod)\nans=(tp*x-tp2+1)%mod\nprint(ans if x!=0 else 0)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "#!/usr/bin/env python3\nimport sys\ndef ask(i):\n    print('?', i + 1)\n    sys.stdout.flush()\n    a_i = int(input())\n    return a_i\ndef answer(i):\n    print('!', i + 1 if i != -1 else -1)\n    sys.exit()\n\ndef has_intersection(l1, r1, l2, r2):\n    if l1 <= l2 and r2 <= r1:\n        return True\n    if l2 <= l1 and r1 <= r2:\n        return True\n    return False\n\nn = int(input())\nassert n >= 2 and n % 2 == 0\nif (n // 2) % 2 == 1:\n    answer(-1)\nelse:\n    assert n % 4 == 0\n    l1 = 0\n    r1 = n // 2\n    a_l1 = ask(l1)\n    a_r1 = ask(r1)\n    if a_l1 == a_r1:\n        answer(0)\n    a_l2 = a_r1\n    a_r2 = a_l1\n    # print('binary search [', l1, ',', r1, ') ->', (l1 + r1) // 2, file=sys.stderr)\n    while True:\n        m1 = (l1 + r1) // 2\n        m2 = (m1 + n // 2) % n\n        a_m1 = ask(m1)\n        a_m2 = ask(m2)\n        if a_m1 == a_m2:\n            answer(m1)\n        if has_intersection(a_l1, a_m1, a_l2, a_m2):\n            r1 = m1\n            a_r1 = a_m1\n            a_r2 = a_m2\n        else:\n            assert has_intersection(a_m1, a_r1, a_m2, a_r2)\n            l1 = m1\n            a_l1 = a_m1\n            a_l2 = a_m2\n        # print('binary search [', l1, ',', r1, ') ->', (l1 + r1) // 2, file=sys.stderr)\nassert False\n",
    "complexity": "logn",
    "problem": "1019_B",
    "from": "CODEFORCES",
    "tags": "binary search,interactive"
}
{
    "src": "from collections import deque\nn, d, k = map(int, input().split())\nif n==1:\n    print('NO')\n    exit(0)\nif n==2:\n    if d>1:\n        print('NO')\n    else:\n        print('YES')\n        print(1, 2)\n    exit(0)\nif (not 2<=d<=n-1) or k==1:\n    print('NO')\n    exit(0)\nans = []\nfor i in range(d):\n    ans.append((i+1, i+2))\nnow = d+2\nfor i in range(d-1):\n    q = deque([(i+2, min(i, d-i-2))])\n    first = True\n    while q and len(ans)<n-1:\n        node, depth = q.popleft()\n        end = now+k-1\n        if first:\n            end -= 1\n        for j in range(now, end):\n            ans.append((node, j))\n            if len(ans)==n-1:\n                break\n            if depth>0:\n                q.append((j, depth-1))\n        now = end\n        first = False\n\nif len(ans)==n-1:\n    print('YES')\n    for i, j in ans:\n        print(i, j)\nelse:\n    print('NO')",
    "complexity": "quadratic",
    "problem": "1003_E",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,graphs"
}
{
    "src": "def reach_max(n, k):\n    return n * k + 1 - n * (n + 1) // 2\n\n\nn, k = map(int, input().split())\n\nif n == 1:\n    print(0)\n    exit()\n\nlo, hi = 1, k - 1\n\nif n > reach_max(hi, k):\n    print(-1)\n    exit()\n\n\nwhile lo < hi:\n    mid = (lo + hi) // 2\n    if reach_max(mid, k) < n:\n        lo = mid + 1\n    else:\n        hi = mid\n\nprint(lo)\n",
    "complexity": "logn",
    "problem": "0287_B",
    "from": "CODEFORCES",
    "tags": "binary search,math"
}
{
    "src": "n=int(input())\nd={\"purple\":\"Power\",\"green\":\"Time\",\"blue\":\"Space\",\"orange\":\"Soul\",\"red\":\"Reality\",\"yellow\":\"Mind\"}\nl=[]\nfor i in range(n):\n    s=input()\n    l.append(s)\nprint(6-n)\nfor i in d:\n    if i not in l:\n        print(d[i])",
    "complexity": "constant",
    "problem": "0987_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n,k=map(int,input().split())\narr=list(map(int,input().split()))\nd={}\nfor i in arr:\n\tif i in d:\n\t\td[i]+=1\n\telse:\n\t\td[i]=1\nflag=True\nfor i in range(100,0,-1):\n\tt2=0\n\tfor j in d.values():\n\t\tt2+=j//i\n\tif(t2>=n):\n\t\tprint(i)\n\t\tflag=False\n\t\tbreak\nif(flag):\n\tprint(0)",
    "complexity": "nlogn",
    "problem": "1011_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,implementation"
}
{
    "src": "n, k = map(int, input().split())\nif n == 1:\n    print(0)\nelif (k*k -k)//2 +1 < n:\n    print(-1)\nelse:\n    g, b = 0, k//2\n    while b != 0:\n        while g +b <= k and (k*k -k)//2 +1 -((g +b)**2 -(g +b))//2 >= n:\n            g += b\n        b //= 2\n    print(k -g)\n",
    "complexity": "logn",
    "problem": "0287_B",
    "from": "CODEFORCES",
    "tags": "binary search,math"
}
{
    "src": "'''\n    Auther: ghoshashis545 Ashis Ghosh\n    College: Jalpaiguri Govt Enggineering College\n\n'''\nfrom os import path\nfrom io import BytesIO, IOBase\nimport sys\nfrom heapq import heappush,heappop\nfrom functools import cmp_to_key as ctk\nfrom collections import deque,Counter,defaultdict as dd \nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input().rstrip()\ndef mi():return map(int,input().split())\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef bo(i):\n    return ord(i)-ord('0')\n\nfile = 1\ndef ceil(a,b):\n    return (a+b-1)//b\n\n\n\n\ndef solve():\n\n    \n    # for _ in range(1,ii()+1):\n      \n    l,r = mi()\n    s1 = bin(l)[2:]\n    s2 = bin(r)[2:]\n    if len(s1) != len(s2):\n      print((1<<len(s2))-1)\n      return\n    \n    x = 0\n    for i in range(62,-1,-1):\n      if ((l>>i)&1)^((r>>i)&1):\n        x +=(1<<(i+1))\n        x -=1\n        break\n    print(x)\n\n\n\n\n\n\n\n\n            \n\n\n\n\n\n    \n        \n\n\n\n\n\n\n\n\n        \nif __name__ ==\"__main__\":\n\n    if(file):\n    \n       if path.exists('input.txt'):\n           sys.stdin=open('input.txt', 'r')\n           sys.stdout=open('output.txt','w')\n       else:\n           input=sys.stdin.readline\n    solve()\n",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "k=int(input())\ni=0\nr=1\nwhile(k>=r):\n    r+=9*(i+1)*10**i\n    i+=1\nr=r-(9*i*10**(i-1))\nans=str(((k-r)//i)+10**(i-1))[(k-r)%i]\nprint(ans)",
    "complexity": "constant",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "from _collections import deque\nn = int(input())\nm = list(map(int, input().split()))\na = []\nb = deque()\n \ni = 1\nfor x in m:\n    a.append((x, i))\n    i += 1\na.sort(key=lambda p: -p[0])\n \ns = input()\nans = []\n \nfor x in s:\n    if x == \"1\":\n        v = b.pop()\n        ans.append(v[1])\n    else:\n        v = a.pop()\n        ans.append(v[1])\n        b.append(v)\nprint(*ans)",
    "complexity": "nlogn",
    "problem": "0982_B",
    "from": "CODEFORCES",
    "tags": "data structures,greedy,implementation"
}
{
    "src": "import math\nk, n, s, p = map(int, input().split())\nsheets = math.ceil(n/s) * k\nprint(math.ceil(sheets/p))\n \t  \t\t\t\t\t\t\t\t\t\t  \t \t\t \t\t\t\t",
    "complexity": "constant",
    "problem": "0965_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import heapq\n\n\ndef read_int():\n    return int(input().strip())\n\n\ndef read_ints():\n    return list(map(int, input().strip().split(' ')))\n\n\ndef solve():\n    '''\n    8 8 8 8 8 8\n    9 9\n    9 9\n\n    81+81\n\n    72+72+72+72\n    '''\n    R, G, B = read_ints()\n    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]\n    # dp[R][G][B]\n    Rs = read_ints()\n    Gs = read_ints()\n    Bs = read_ints()\n    Rs.sort(reverse=True)\n    Gs.sort(reverse=True)\n    Bs.sort(reverse=True)\n    answer = 0\n    for r in range(R+1):\n        for g in range(G+1):\n            for b in range(B+1):\n                if r > 0 and g > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])\n                if g > 0 and b > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])\n                if r > 0 and b > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])\n                answer = max(answer, dp[r][g][b])\n    return answer\n\n\nif __name__ == '__main__':\n    print(solve())\n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "d = {\"purple\":\"Power\", \"green\":\"Time\", \"blue\":\"Space\", \"orange\":\"Soul\", \"red\":\"Reality\", \"yellow\":\"Mind\"}\ns = set()\nn = int(input())\nfor _ in range(n):\n\tw = input()\n\ts.add(w)\nprint(6 - n)\nfor (key, value) in d.items():\n\tif key not in s:\n\t\tprint(value)\n ",
    "complexity": "constant",
    "problem": "0987_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nwhile len(a) > 0:\n    k = a.pop(0)\n    a = [i for i in a if i % k != 0]\n    ans += 1\n\nprint(ans)\n",
    "complexity": "quadratic",
    "problem": "1209_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "n = int(input())\nl = [0]+list(map(int,input().split()))\nfrom collections import defaultdict\nans = ['A','B']\nx = defaultdict(int)\ntable = [-1]*(n+1)\nfor i in range(1,n+1):\n\tx[l[i]] = i\n\ntable[x[n]] = 1\nfor i in range(n-1,0,-1):\n\tif(x[i]-i>0):\n\t\tfor j in range(x[i],0,-i):\n\t\t\tif(l[j]>i):\n\t\t\t\tif(table[j]==1):\n\t\t\t\t\ttable[x[i]] = 0\n\t\t\t\t\tbreak\n\tif(n-i>0 and table[x[i]]==-1):\n\t\tfor j in range(x[i],n+1,i):\n\t\t\tif(l[j]>i):\n\t\t\t\tif(table[j]==1):\n\t\t\t\t\ttable[x[i]] = 0\n\t\t\t\t\tbreak\n\n\tif(table[x[i]]==-1):\n\t\ttable[x[i]] = 1\n\nfor i in table[1:]:\n\tprint(ans[i],end='')",
    "complexity": "linear",
    "problem": "1033_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,games"
}
{
    "src": "n = int(input())\n\nlst = []\nfor x in range(n):\n    (a, b) = map(int, input().split())\n    lst.append((a, b))\n\ndef scal(x1, y1, x2, y2, x3, y3):\n    if (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1) == 0:\n        return True\n    return False\n\ndef check():\n    for x in range(n - 2):\n        if len(s2) >= 3:\n            if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):\n                return False\n        if scal(lst[0][0], lst[0][1], lst[1][0], lst[1][1], lst[x + 2][0], lst[x + 2][1]):\n            s1.append(x + 2)\n        else:\n            s2.append(x + 2)\n    if len(s2) >= 3:\n        if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):\n            return False\n    return True\n\nflag = True\n\nif n >= 5:\n    s1 = []\n    s2 = []\n    if not check():\n        lst[1], lst[s2[0]] = lst[s2[0]], lst[1]\n        x = s2[0]\n        s1 = []\n        s2 = []\n        if not check():\n            lst[0], lst[s2[0]] = lst[s2[0]], lst[0]\n            s1 = []\n            s2 = []\n            if not check():\n                flag = False\n\nif flag:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
    "complexity": "nlogn",
    "problem": "0961_D",
    "from": "CODEFORCES",
    "tags": "geometry"
}
{
    "src": "n, m = list(map(int, input().split()))\ncl = []\nfor i in range(n):\n  cl.append(input())\n\ndef is_squad(x, y):\n  if cl[x][y]=='#' and cl[x+1][y]=='#' and cl[x+2][y]=='#' and cl[x+2][y+1]=='#' and cl[x+2][y+2]=='#' and cl[x+1][y+2]=='#' and cl[x][y+2]=='#' and cl[x][y+1]=='#':\n    return True\n  else:\n    return False\n\ndef cv(x, y):\n  counter = 0\n  if x-2>=0 and y+2<=m-1 and is_squad(x-2, y):\n    return True\n   \n  elif x-1>=0 and x+1<=n-1 and y+2<=m-1 and is_squad(x-1, y):\n    return True\n\n  elif x+2<=n-1 and y+2<=m-1 and is_squad(x, y):\n    return True\n  \n  elif x+2<=n-1 and y+1<=m-1 and y-1>=0 and is_squad(x, y-1):\n    return True\n\n  elif x+2<=n-1 and y-2>=0 and is_squad(x, y-2):\n    return True\n\n  elif x+1<=n-1 and x-1>=0 and y-2>=0 and is_squad(x-1, y-2):\n    return True\n\n  elif x-2>=0 and y-2>=0 and is_squad(x-2, y-2):\n    return True\n\n  elif x-2>=0 and y-1>=0 and y+1<=m-1 and is_squad(x-2, y-1):\n    return True\n  else:\n    return False\n  \n\n  \n\n  \n  \n\nfor i in range(n):\n  for j in range(m):\n    if cl[i][j]=='#':\n      if not cv(i, j):\n        print('NO')\n        exit()\n\nprint('YES')",
    "complexity": "quadratic",
    "problem": "1059_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "from sys import stdin\ninput=stdin.readline\ndef check(mid,a,limit):\n\tres=[]\n\ts=0\n\tfor r,t,id in a:\n\t\tif r>=mid and t+s<=limit:\n\t\t\tres.append(id+1)\n\t\t\ts+=t\n\t\telif t+s>limit:\n\t\t\tbreak\n\t\tif len(res)==mid:\n\t\t\tbreak\n\t# print(res,s)\n\treturn res\n\ndef f(a,limit):\n\ta.sort(key=lambda s:s[1])\n\tans=None\n\tlo=0\n\thi=len(a)+1\n\twhile lo<=hi:\n\t\tmid=(lo+hi)//2\n\t\tres=check(mid,a,limit)\n\t\tif len(res)>=mid:\n\t\t\tlo=mid+1\n\t\t\tans=(res,mid)\n\t\telse:\n\t\t\thi=mid-1\n\tprint(ans[1])\n\tprint(ans[1])\n\tprint(*ans[0])\n\n\nn,limit=map(int,input().strip().split())\nq=[]\nfor i in range(n):\n\tx,y=map(int,input().strip().split())\n\tq.append((x,y,i))\nf(q,limit)",
    "complexity": "nlogn",
    "problem": "0913_D",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,data structures,greedy,sortings"
}
{
    "src": "def solve():\n    n, k = list(map(lambda x: int(x), input().split()))\n    upper_bound = n+1\n    lower_bound = -1\n    while upper_bound > lower_bound + 1:\n        m = (upper_bound + lower_bound) // 2\n        if (n - m) * (n - m + 1) // 2 - m > k:\n            lower_bound = m\n        else:\n            upper_bound = m\n    print(upper_bound)\n\nsolve()\n\n",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "\ndef f(n):\n    return n + n//2\n        \n        \nn = int(input())\nprint(f(n))\n",
    "complexity": "constant",
    "problem": "0084_A",
    "from": "CODEFORCES",
    "tags": "math,number theory"
}
{
    "src": "t = int(input())\n\ndef sol(n, k):\n    p = 1\n    q = 1\n    acc = 0\n    while n > 0 and k >= p:\n#        print(\"itr\", k, n, p, q)\n        k -= p\n        n -= 1\n        if n >= 40:\n            return n\n        acc += q*(4**n-1)//3\n#        print(\"k<=acc\", k, acc)\n        if k <= acc:\n            return n\n        p = 2*p+1\n        q = 2*q+3\n    return -1\n\nfor _ in range(t):\n    n, k = (int(v) for v in input().split())\n    ans = sol(n, k)\n    if ans == -1:\n        print(\"NO\")\n    else:\n        print(\"YES\", ans)\n",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "x,k=map(int,input().split())\nmod=1000000007\nif x==0: print(0)\nelse:\n    print((x*pow(2,(k+1),mod)-pow(2,k,mod)+1)%mod)\n\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "from sys import stdin\nMOD = 1000000007\ns = stdin.readline().strip()\nn = len(s)\nbuc = [0] * 101\nfac = [0] * (n + 1)\ninv = [0] * (n + 1)\ndp = [0] * (n + 1)\n# temp_dp = [0] * (n+1)\nans = [[0] * 55 for _ in range(55)]\n\n\ndef find(c: 'str') -> 'int':\n    if 'A' <= c <= 'Z':\n        return ord(c) - ord('A') + 26\n    else:\n        return ord(c) - ord('a')\n\n\ndef add(a: 'int', b: 'int') -> 'int':\n    a += b\n    if a >= MOD:\n        a -= MOD\n    return a\n\n\ndef sub(a: 'int', b: 'int') -> 'int':\n    a -= b\n    if a < 0:\n        a += MOD\n    return a\n\n\n# c = Counter(s)\n\n# # store frequency\n# for k in c.keys():\n#     buc[find(k)] = c[k]\n\nfor i in s:\n    buc[find(i)] += 1  # naive count is fater than counter\n\n# compute factorial and inv\n\nfac[0] = 1\nfor i in range(1, n + 1):\n    fac[i] = (fac[i - 1] * i) % MOD\ninv[n] = pow(fac[n], MOD - 2, MOD)\nfor i in range(n - 1, -1, -1):\n    inv[i] = (inv[i + 1] * (i + 1)) % MOD\n\nnum = pow(fac[n // 2], 2, MOD)\nfor i in range(0, 52):\n    num = (num * inv[buc[i]]) % MOD\n\ndp[0] = 1\n\nfor i in range(0, 52):\n    if not buc[i]:\n        continue\n    for j in range(n, buc[i] - 1, -1):\n        dp[j] = add(dp[j], dp[j - buc[i]])\n\nfor i in range(52):\n    ans[i][i] = dp[n // 2]\n\nfor i in range(52):\n    if not buc[i]:\n        continue\n    temp_dp = dp.copy()\n    for k in range(buc[i], n + 1):\n        temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[i]])\n\n    for j in range(i + 1, 52):\n        if not buc[j]:\n            continue\n        for k in range(buc[j], n + 1):\n            temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[j]])\n\n        ans[i][j] = (2 * temp_dp[n // 2]) % MOD\n\n        for k in range(n, buc[j] - 1, -1):\n            temp_dp[k] = add(temp_dp[k], temp_dp[k - buc[j]])\n\nq = int(input())\nl = stdin.read().splitlines()\nfor i in l:\n    x, y = map(int, i.split())\n    l, r = find(s[x - 1]), find(s[y - 1])\n    if l > r:\n        l, r = r, l\n    print(num * ans[l][r] % MOD)\n",
    "complexity": "cubic",
    "problem": "1111_D",
    "from": "CODEFORCES",
    "tags": "combinatorics,dp,math"
}
{
    "src": "t = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    arr.sort(reverse=True)\n    print(min(arr[1] - 1, len(arr) - 2))",
    "complexity": "nlogn",
    "problem": "1197_A",
    "from": "CODEFORCES",
    "tags": "greedy,math,sortings"
}
{
    "src": "from math import *\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef bin_search(arr, n):\n\n\tpos = -1\n\n\t# all nums < n\n\n\tfor i in range(35, -1, -1):\n\t\tjump = (1 << i)\n\n\t\tif (pos + jump) >= len(arr):\n\t\t\tcontinue\n\n\t\tif arr[pos + jump] <= n-1:\n\t\t\tpos += jump\n\n\n\treturn len(arr) - pos - 1  \n\ndef main():\n\tn, m = [int(x) for x in input().split(' ')]\n\n\tvert = []\n\tfor i in range(n):\n\t\tvert.append(int(input()))\n\n\thor = []\n\tfor i in range(m):\n\t\tcol1, col2, row = [int(x) for x in input().split(' ')]\n\n\t\tif col1 != 1:\n\t\t\tcontinue\n\n\t\thor.append((col2))\n\n\n\tvert.append(1000000000)\n\n\tvert = sorted(vert)\n\thor = sorted(hor)\n\n\tbest = int(1e10)\n\n\n\tfor i in range(len(vert)):\n\t\tcur_ans = bin_search(hor, vert[i]) + i\n\t\tbest = min(best, cur_ans)\n\n\n\n\tprint(best)\n\nif __name__ == \"__main__\":\n\tmain()",
    "complexity": "nlogn",
    "problem": "1075_C",
    "from": "CODEFORCES",
    "tags": "two pointers"
}
{
    "src": "n, m = map(int, input().split())\na = []\nb = []\ncheck = True\nwhile n >= 0:\n    if check == True:\n        a.append(5)\n        n -= 5\n        b.append(4)\n        check = False\n    else:\n         check = True\n         a.append(4)\n         n -= 4\n         b.append(5)\n\n\nif m != 1:\n    a.append(5)\n    b.append(6)\nelse:\n    a.append(5)\n    b.append(5)\n\nprint(*a, sep = \"\")\nprint(*b, sep = \"\")\n",
    "complexity": "constant",
    "problem": "1028_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "#!/usr/bin/python\n\nx,k = map(int, input().strip().split())\n\nMOD = 1000000007\n\nif x > 0:\n\tr = (pow(2, k+1, MOD) * x - pow(2, k, MOD) + 1 + MOD * 10) % MOD\nelse:\n\tr = 0\n\nprint(r)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n,m=map(int,input().split())\narr=[ int(x) for x in input().split()]\n\narr=sorted(arr,reverse=True)\narr.append(0)\n#print(arr)\nisum=sum(arr)\nans=[]\ntop=arr[0]\nfor i in range(n):\n\tif(arr[i]==1):\n\t\tans.append(1)\n\t\tarr[i+1]=1\n\t\tcontinue\n\tif(arr[i+1] >arr[i]):\n\t\tarr[i+1]=arr[i]\n\tif arr[i]-arr[i+1]==0:\n\t\tans.append(1)\n\t\th=1\n\telse:\n\t\tans.append(arr[i]-arr[i+1])\n\t\th=arr[i]-arr[i+1]\n\n\ttop=arr[i]-h\n\tarr[i+1]=top\n# \tprint(\"top:\",top)\n# \tprint(\"arr:\",arr)\n# \tprint(\"ans:\",ans)\n# print(ans)\nprint(isum-sum(ans))",
    "complexity": "nlogn",
    "problem": "1061_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "from itertools import combinations\n \nn, l, r, x = map(int, input().split())\n(*a,) = map(int, input().split())\nsumu = 0\nfor i in range(2, n + 2):\n    for j in combinations(a, i):\n        if (r >= sum(j) >= l) and (max(j) - min(j) >= x):\n            sumu += 1\nprint(sumu)\n\t \t\t      \t \t  \t\t   \t  \t\t \t \t",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "if __name__ == '__main__':\n    cin = input\n    n, m = map(int, cin().split())\n    s, l, f = [[] for _ in range(n)], [0] * m, 0\n\n    for i in range(n):\n        t = cin()\n        for j in range(m):\n            if t[j] == \"1\":\n                l[j] += int(t[j])\n                s[i].append(j)\n    for i in range(n):\n        r = set(l[c] - 1 for c in s[i])\n        if not 0 in r:\n            f = not f\n            break\n    print(\"YNEOS\"[not f::2])",
    "complexity": "quadratic",
    "problem": "0985_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "def isValid(arr, l, r, x):\n\treturn l <= sum(arr) <= r and max(arr)-min(arr) >= x\n\nn, l, r, x = map(int, input().strip().split())\narr = list(map(int, input().strip().split()))\nvalid = 0\n\nfor i in range(1, 1<<n):\n\ts = str(bin(i))[2:].rjust(n, '0')\n\ttemp = []\n\tfor j in range(n):\n\t\tif s[j] == '1':\n\t\t\ttemp.append(arr[j])\n\tif isValid(temp, l, r, x):\n\t\tvalid += 1\nprint(valid)",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect, insort\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nfrom copy import deepcopy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ntry:\n    # sys.setrecursionlimit(int(pow(10,6)))\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\nexcept:\n    pass\ndef pmat(A):\n    for ele in A: print(*ele,end=\"\\n\")\n\n# from sys import stdin\n# input = stdin.buffer.readline\n# I = lambda : list(map(int,input().split()))\n\n# import sys\n# input=sys.stdin.readline\n\n\n\nn, m = L()\nk = L()[0]\na = [[0] * m for _ in range(n)]\ndq = deque()\nline = list(map(lambda x: int(x) - 1, L()))\nfor i in range(0, 2 * k, 2):\n    a[line[i]][line[i + 1]] = 1\n    dq.append((line[i], line[i + 1]))\n \n \nx, y = -1, -1\nwhile dq:\n    x, y = dq.popleft()\n    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):\n        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:\n            a[tx][ty] = 1\n            dq.append((tx, ty))\n \nprint(f'{x+1} {y+1}')\n",
    "complexity": "cubic",
    "problem": "0035_C",
    "from": "CODEFORCES",
    "tags": "brute force,dfs and similar,shortest paths"
}
{
    "src": "from collections import defaultdict, Counter\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd\n \ndef read(): return list(map(int, input().strip().split()))\n \nans_ = []\n\n \n# for _ in range(int(input())):\nt_p = [2**i for i in range(31)]\nn = int(input()); \narr = Counter(read())\nd = defaultdict(int)\nm = 1; ans_lis = [list(arr.keys())[0]]\n\nfor i in arr:\n    for j in t_p:\n        a, b, c = i, i+j, i+2*j\n        s = (arr[a] > 0) + (arr[b] > 0) + (arr[c] > 0)\n        if s > m:\n            m = s\n            ans_lis = [x for x in [a, b, c] if arr[x]]\n\n\nans_.append(m)\nt = \"\"\nfor i in ans_lis:t += (str(i)+\" \")\nans_.append(t)\n\n\n\n\n\n \n \n# print(ans_)\nfor i in ans_:\n    print(i)\n \n \n\"\"\"\n0 2 4 \n3 5 7\n\n\n0 8 16\n\n\n\"\"\"",
    "complexity": "nlogn",
    "problem": "0988_D",
    "from": "CODEFORCES",
    "tags": "brute force,math"
}
{
    "src": "n, m, k = map(int, input().split())\n\na = list(map(int, input().split()))\n\nbest = 0\ndp = [0] * (n + 1)\nfor i in range(n):\n    b2 = 0\n    for j in range(max(-1, i - m), i + 1):\n        b2 = max(b2, dp[j] - k + sum(a[j + 1:i + 1]))\n    dp[i] = max(b2, a[i] - k)\n    best = max(best, dp[i])\n\nprint(best)\n# print(dp)\n",
    "complexity": "quadratic",
    "problem": "1197_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,math"
}
{
    "src": "def main():\n    a = sorted(input(), reverse=True)\n    b = int(input())\n    k = \"\"\n    while len(a) > 0:\n        for i in range(len(a)):\n            num = k + a[i] + \"\".join(sorted(a[:i] + a[i + 1:]))\n            if int(num) <= b:\n                k += a[i]\n                a = a[:i] + a[i + 1:]\n                break\n    print(k)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n=int(input())\na=list(map(int,input().split()))\nd=set()\nt={}\nrep=set()\nif a.count(0)>=2:\n\tprint(\"cslnb\")\n\texit()\n\nfor i in a:\n\tif i in d:\n\t\tif t[i]+1==3:\n\t\t\tprint(\"cslnb\")\n\t\t\texit()\n\t\telse:\n\t\t\tt[i]+=1\n\t\t\trep.add(i)\n\t\t\tif len(rep)>=2:\n\t\t\t\tprint(\"cslnb\")\n\t\t\t\texit()\n\telse:\n\t\tt[i]=1\n\t\td.add(i)\nif rep:\n\tfor c in rep:\n\t\tif c-1 in d:\n\t\t\tprint(\"cslnb\")\n\t\t\texit()\ns=0\na.sort()\nfor i in range(n):\n\ts+=a[i]-i\nif s%2==1:print(\"sjfnb\")\nelse:print(\"cslnb\")",
    "complexity": "nlogn",
    "problem": "1190_B",
    "from": "CODEFORCES",
    "tags": "games"
}
{
    "src": "import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\nimport pprint\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n# sys.stdout = open('output.txt', 'w')\n\n\nn = ria()[0]\nx, y = ria()\nd1 = abs(1 - x) + abs(1 - y)\nd2 = abs(n - x) + abs(n - y)\nif d1<=d2:\n    print('White')\nelse:\n    print('Black')",
    "complexity": "constant",
    "problem": "1075_A",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right \nfrom heapq import heappop,heappush,heapify\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n\nk = inpl(); k.sort()\nif k.count(1) >= 1 or k.count(2) >= 2 or k.count(3) >= 3 or k == [2,4,4]:\n    print('YES')\nelse:\n    print('NO')",
    "complexity": "constant",
    "problem": "0911_C",
    "from": "CODEFORCES",
    "tags": "brute force,constructive algorithms"
}
{
    "src": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO,IOBase\nfrom math import inf\n\ndef main():\n    n = int(input())\n    a = [0]+list(map(int,input().split()))\n    dp = [[[-1,0]for _ in range(n+1)]for _ in range(n+1)]\n    ### int: value , bool: can it be reduced to length 1\n    for i in range(1,n+1):\n        dp[i][i][0],dp[i][i][1] = a[i],1\n    for i in range(n-1,0,-1):\n        for j in range(i+1,n+1):\n            for k in range(j-i):\n                a,b = dp[i][i+k],dp[i+k+1][j]\n                if a[1] and b[1] and a[0] == b[0]:\n                    dp[i][j][0],dp[i][j][1] = a[0]+1,1\n                    break\n    val = [0,0]+[inf]*n\n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            if dp[i][j][1]:\n                val[j+1] = min(val[j+1],val[i]+1)\n    print(val[-1])\n\n#Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n=int(input())\narr=list(map(int,input().split()));ans=0\nwhile len(arr)!=0:\n e=arr.pop(0)\n ans+=arr.index(e)\n arr.remove(e)\nprint(ans)\n \n\n  \n",
    "complexity": "quadratic",
    "problem": "0995_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "def main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = 10 ** 10\n    for i in range(n):\n        x = i if i > n - i - 1 else n - i - 1\n        ans = min(ans, arr[i] // x)\n    print(ans)\nmain()",
    "complexity": "linear",
    "problem": "1159_B",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "from collections import namedtuple\nn = int(input())\nvertex = namedtuple('vertex', ['degree', 'id'])\na, b, c = [], [], 0\n\nrr = list(map(int, input().split()))\n\nfor i in range(n):\n    tmp = rr[i]\n    v = vertex(tmp, i + 1)\n    if tmp > 1:\n        a.append(v)\n    else:\n        b.append(v)\n    c += tmp\n\nif c < (n - 1)*2:\n    print('NO')\nelse:\n    if len(a) == 0:\n        print('YES 1')\n        print('1 2')\n    else:\n        print('YES', len(a) - 1 + min(2, len(b)))\n        print(n - 1)\n        for i in range(len(a)):\n            if i == 0:\n                continue\n            print(a[i - 1].id, a[i].id)\n        if len(b) > 0:\n            print(b[0].id, a[0].id)\n        if len(b) > 1:\n            print(b[1].id, a[-1].id)\n        j = 2\n        for i in range(len(a)):\n            if j >= len(b):\n                yes = 1\n                break\n            k = a[i].degree - 2\n            yes = 0\n            for t in range(k):\n                print(a[i].id, b[j].id)\n                j += 1\n                if j >= len(b):\n                    yes = 1\n                    break\n            if yes == 1:\n                break",
    "complexity": "linear",
    "problem": "1082_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,graphs,implementation"
}
{
    "src": "n=int(input())\nl1=list(map(int,input().split()))\nif n%2==0:\n    for i in range(n):\n        if l1[i]>=0:\n            l1[i]=-1*l1[i]-1\nelse :\n    for i in range(n):\n        if l1[i]>=0:\n            l1[i]=-1*l1[i]-1\n    l1[l1.index(min(l1))]=l1[l1.index(min(l1))]*-1 -1\nprint(' '.join(str(x) for x in l1))",
    "complexity": "linear",
    "problem": "1180_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation"
}
{
    "src": "n = int(input())\n\nlst = list(map(int, input().split()))\n\nevens = []\nodds = []\n\nfor e, x in enumerate(lst):\n    if x % 2 == 0:\n        evens.append(e + 1)\n    else:\n        odds.append(e + 1)\n\nif len(evens) < len(odds):\n    print(evens[0])\nelse:\n    print(odds[0])\n",
    "complexity": "linear",
    "problem": "0025_A",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "a, b= list(map(int, input().split()))\nc = 1\nresult = a^b\nwhile c <= result:\n    c *= 2\nc -= 1\n \nprint(c)\n \t\t \t   \t\t\t\t \t\t   \t\t   \t  \t  \t",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "from math import log2\nn = int(input())\nif n == 1:\n    print(1)\n    exit()\nelif n == 3:\n    print(1, 1, 3)\n    exit()\nl = [1] * (n // 2)\nif n % 2 == 1:\n    l.append(1)\n\nxn = int(log2(n))\ntmp = n - len(l)\nfor i in range(2, xn+1):\n    fn = tmp // 2\n    if tmp % 2 == 1:\n        fn += 1\n    tmp -= fn\n    l += ([pow(2, i-1)] * fn)\nl.append((n // pow(2, xn - 1)) * pow(2, xn - 1))\nprint(' '.join(str(i) for i in l))",
    "complexity": "linear",
    "problem": "1059_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "t = int(input())\n\ndef get_max(n):\n    ans = 0\n    while n:\n        ans = 4 * ans + 1\n        n = n - 1\n        if ans > 10**19:\n            break\n    return ans\n\nfor _ in range(t):\n    n, k = map(int, input().split())\n    if n == 1:\n        if k == 1:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    elif n == 2:\n        if k <= 2:\n            print(\"YES 1\")\n        elif k != 3 and k <= 5:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    else:\n        siz = n - 1\n        l = 1\n        cnt = 3\n        while siz:\n            if l <= k < l+cnt:\n                print(\"YES {}\".format(siz))\n                break\n            l = l + cnt\n            cnt = 2 * cnt + 1\n            siz = siz - 1\n        else:\n            if k <= get_max(n):\n                print(\"YES 0\")\n            else:\n                print(\"NO\")\n",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "def add(num):\n    if(num<=1):\n        return 0\n    return (num*(num-1))//2\n    \n    \nn,k=map(int,input().split())\n\na=list(map(int,input().split()))\npre=[a[0]]\nbase=(2**(k))-1\nhb=2**(k-1)\nfor i in range(1,n):\n    pre.append(a[i]^pre[-1])\n    \ncnt=dict()\ncnt[0]=[0,0]\n\nfor i in range(n):\n    if(pre[i]>=hb):\n        if(base-pre[i] not in cnt):\n            cnt[base-pre[i]]=[0,0]\n        cnt[base-pre[i]][1]+=1\n    else:\n        if(pre[i] not in cnt):\n            cnt[pre[i]]=[0,0]\n        cnt[pre[i]][0]+=1\ncnt1=0\n#print(pre)\n#print(cnt)\nfor i in cnt.values():\n    sum1=i[0]+i[1]\n    cnt1+=add(sum1//2)\n    cnt1+=add((sum1+1)//2)\ncnt1+=sum(cnt[0])//2\n#print(cnt1)\nprint((n*(n+1))//2 - cnt1)\n    \n    \n\n    \n",
    "complexity": "linear",
    "problem": "1054_D",
    "from": "CODEFORCES",
    "tags": "greedy,implementation"
}
{
    "src": "if __name__ == '__main__':\n\t\tn,m = map(int, input().split())\n\t\tl = list(map(int, input().split()))\n\t\td = dict()\n\t\tif len(set(l)) < n:\n\t\t\tprint(0)\n\t\telse:\n\t\t\tfor i in range (m):\n\t\t\t\td.setdefault(l[i],0)\n\t\t\t\td[l[i]]+=1\n\t\t\tmin1 = 999999999\n\t\t\tfor i in d.values():\n\t\t\t\tif i < min1 :\n\t\t\t\t\tmin1 = i\n\t\t\tprint(min1)",
    "complexity": "quadratic",
    "problem": "0961_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "x, y, z, t1, t2, t3 = [int(i) for i in input().split()]\nif abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
    "complexity": "constant",
    "problem": "1054_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "#!/usr/bin/env python3\nimport sys\n\ndef rint():\n    return map(int, sys.stdin.readline().split())\n#lines = stdin.readlines()\n\ndef writable(r, c):\n    if r+2 >= n or c+2 >= m:\n        return False\n    t = set()\n    t.add(cells[r][c])\n    t.add(cells[r][c+1])\n    t.add(cells[r][c+2])\n    t.add(cells[r+1][c])\n    t.add(cells[r+1][c+2])\n    t.add(cells[r+2][c])\n    t.add(cells[r+2][c+1])\n    t.add(cells[r+2][c+2])\n    return not '.' in t\n\ndef fill_ink(r,c):\n    paper[r][c] = \"#\"\n    paper[r][c+1] = \"#\"\n    paper[r][c+2] = \"#\"\n    paper[r+1][c] = \"#\"\n    paper[r+1][c+2] = \"#\"\n    paper[r+2][c] = \"#\"\n    paper[r+2][c+1] = \"#\"\n    paper[r+2][c+2] = \"#\"\n\nn, m = rint()\n\ncells = []\nfor i in range(n):\n    cells.append(input())\n\n#for i in range(n):\n#    for j in range(m):\n#        print(cells[i][j], end='')\n#    print()\n\npaper = [[\".\" for j in range(m)] for i in range(n)]\n\nfor r in range(n):\n    for c in range(m):\n        if writable(r,c) is True:\n            fill_ink(r, c)\n\nfor r in range(n):\n    for c in range(m):\n        if cells[r][c] != paper[r][c]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\n",
    "complexity": "quadratic",
    "problem": "1059_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import math\n\nt = int(input())\nres = []\nwhile t:\n\tt -= 1\n\tn, k = map(int, input().split())\n\tlimit = -1\n\tif n <= 60:\n\t\tlimit = 0\n\t\tpow4 = 1\n\t\tfor _ in range(n):\n\t\t\tlimit += pow4\n\t\t\tpow4 *= 4\n\tif limit < k and limit != -1 or n == 2 and k == 3:\n\t\tres.append('NO')\n\telse:\n\t\tdiv = 1\n\t\tk -= 1\n\t\tsize = 1\n\t\twhile div < n and k >= 4 * size - 1:\n\t\t\tk -= 4 * size - 1\n\t\t\tsize *= 2\n\t\t\tdiv += 1\n\t\tres.append('YES ' + str(n - div))\n\nprint('\\n'.join(res))",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "def solve(i, j, k):\n    if dp[i][j][k]!=-1:\n        return dp[i][j][k]\n    call = 0\n    if i>0 and j>0:\n        call = max(call, R[i]*G[j]+solve(i-1, j-1, k))\n    if j>0 and k>0:\n        call = max(call, G[j]*B[k]+solve(i, j-1, k-1))\n    if k>0 and i>0:\n        call = max(call, B[k]*R[i]+solve(i-1, j, k-1))\n    dp[i][j][k] = call\n    return call\n\n\nnr, ng, nb = map(int,input().split())\nR = [0]+list(map(int,input().split()))\nG = [0]+list(map(int,input().split()))\nB = [0]+list(map(int,input().split()))\nR.sort()\nG.sort()\nB.sort()\ndp = [[[-1]*(nb+1) for j in range(ng+1)] for i in range(nr+1)]\nans = solve(nr, ng, nb)\nprint(ans)",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "print(\"? 0 0\")\nt = int(input())\nA=[]\nB=[]\na=0\nb=0\nfor i in range(30):\n    A.append(-1)\n    B.append(-1)\ni = 29\nd = 2**i\nwhile i>=0:\n    a+=d\n    b+=d\n    print(\"?\", end=' ')\n    print(a, end=' ')\n    print(b)\n    s=int(input())\n    if s == -t:\n        if s==1:\n            A[i]=0\n            B[i]=1\n            b-=d\n            print(\"?\", end=' ')\n            print(a, end=' ')\n            print(b)\n            t=int(input())\n        elif s==-1:\n            A[i]=1\n            a-=d\n            B[i]=0\n            print(\"?\", end=' ')\n            print(a, end=' ')\n            print(b)\n            t=int(input())\n    i-=1\n    d//=2\nd=1\nfor j in range(30):\n    if A[j]==-1:\n        a = a^d\n        print(\"?\", end=' ')\n        print(a, end=' ')\n        print(b)\n        s = int(input())\n        if s==1:\n            A[j]=1\n            B[j]=1\n        else:\n            A[j]=0\n            B[j]=0\n        a = a^d\n    d*=2\nd=1\na=0\nb=0\nfor i in range(30):\n    a+=d*A[i]\n    b+=d*B[i]\n    d*=2\nprint(\"!\", end=' ')\nprint(a, end=' ')\nprint(b)\n",
    "complexity": "constant",
    "problem": "1088_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,constructive algorithms,implementation,interactive"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n\n\nn, m, k = map(int, input().split())\nA = [[0] * (m) for _ in range(n)]\nB = [[0] * (m) for _ in range(n)]\nfor i in range(n):\n    tmp = list(map(int, input().split()))\n    for j in range(m - 1):\n        A[i][j + 1] = tmp[j] # + A[i][j]\nfor i in range(n - 1):\n    tmp = list(map(int, input().split()))\n    for j in range(m):\n        B[i + 1][j] = tmp[j] # + B[i][j]\n\nif k % 2:\n    ans = [[-1] * m for _ in range(n)]\n    for a in ans:\n        print(*a)\n    sys.exit()\nans = [[0] * m for _ in range(n)]\nlim = k // 2\ndp = [[[float(\"inf\")] * (lim + 1) for _ in range(m)] for _ in range(n)]\nfor i in range(n):\n    for j in range(m):\n        dp[i][j][0] = 0\n\nfor k in range(1, lim + 1):\n    for i in range(n):\n        for j in range(m):\n            if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j])\n            if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j])\n            if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j])\n            if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1])\nfor i in range(n):\n    for j in range(m):\n        ans[i][j] = dp[i][j][-1] * 2\nfor a in ans:\n    print(*a)",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "import sys\nreadline = sys.stdin.readline\n\ndef popcount(i):\n    assert 0 <= i < 0x100000000\n    i = i - ((i >> 1) & 0x55555555)\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\nN, M = map(int, readline().split())\n\nAr = [tuple(map(int, readline().split())) for _ in range(N)]\n\npc = [popcount(i) for i in range(1<<(M+1))]\n\ninf = 1<<31\nmaxi = [0]*(1<<M)\n\nfor i in range(N):\n    a = Ar[i]\n    dp = [0]*(1<<M)\n    for S in range(1, 1<<M):\n        p = pc[S]\n        if p == 1:\n            k = S.bit_length() - 1\n            dp[S] = a[k]\n        else:\n            dp[S] = min(dp[-S&S], dp[S^(-S&S)]) \n        maxi[S] = max(maxi[S], dp[S])\nfor i in range(M):\n    for j in range(1<<M):\n        if not j & (1<<i):\n            maxi[j] = max(maxi[j], maxi[j|(1<<i)])\n\nD = (1<<M)-1\nans = maxi[D]\naS, bS = D, D\nfor S in range(1<<M):\n    candi = min(maxi[S], maxi[D^S])\n    if candi > ans:\n        aS, bS = S, D^S\n        ans = candi\n\nAns = [None]*2\npre = False\nfro = False\n\nfor i in range(N):\n    a = Ar[i]\n    resa = inf\n    resb = inf\n    for j in range(M):\n        if (1<<j)&aS:\n            resa = min(resa, a[j])\n        else:\n            resb = min(resb, a[j])\n    if resa >= ans:\n        pre = True\n        Ans[0] = i+1\n    if resb >= ans:\n        fro = True\n        Ans[1] = i+1\n    if pre and fro:\n        break\nprint(*Ans)\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "import io\nimport os\n\nfrom collections import Counter, defaultdict, deque\n\nDEBUG = False\n\n\ndef bisect_f(f, lo, hi):\n    if DEBUG:\n        assert f(lo) and not f(hi)\n    while hi - lo > 1:\n        mid = (lo + hi) // 2\n        if f(mid):\n            lo = mid\n        else:\n            hi = mid\n        if DEBUG:\n            assert f(lo) and not f(hi)\n    if DEBUG:\n        assert hi - lo == 1\n        assert f(lo) and not f(hi)\n    return lo\n\n\ndef solve(N, M, arrs):\n    def isPossible(target):\n        possible = set()\n        for arr in arrs:\n            mask = 0\n            for pos, x in enumerate(arr):\n                if x >= target:\n                    mask += 1 << pos\n            possible.add(mask)\n        allMask = (1 << M) - 1\n        for mask1 in possible:\n            for mask2 in possible:\n                if mask1 | mask2 == allMask:\n                    return (mask1 << 8) + mask2\n        return 0\n\n    lo = min(arrs[0])\n    hi = 10 ** 9 + 1\n    index = bisect_f(isPossible, lo, hi)\n\n    mask1, mask2 = divmod(isPossible(index), 1 << 8)\n    ans = [-1, -1]\n    for i, arr in enumerate(arrs):\n        mask = 0\n        for pos, x in enumerate(arr):\n            if x >= index:\n                mask += 1 << pos\n        if mask == mask1:\n            ans[0] = str(i + 1)\n        if mask == mask2:\n            ans[1] = str(i + 1)\n    return \" \".join(ans)\n\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, M = [int(x) for x in input().split()]\n    arrs = [[int(x) for x in input().split()] for i in range(N)]\n    ans = solve(N, M, arrs)\n    print(ans)\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "def f(a,b):\n\tr=list(bin(b).lstrip(\"0b\"))\n\tl=list((len(bin(b))-len(bin(a)))*(\"0\")+bin(a).lstrip(\"0b\"))\n\tfor i in range(len(r)):\n\t\tif (r[i]==\"1\" and l[i]==\"1\"):\n\t\t\tr[i]=\"0\"\n\t\t\tif int(\"\".join(r),2)>=a:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tr[i]=\"1\"\n\t\tif l[i]==\"0\" and r[i]==\"0\":\n\t\t\tl[i]=\"1\"\n\t\t\tif int(\"\".join(l),2)<=b:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tl[i]=\"0\"\n\tl=int(\"\".join(l),2)\n\tr=int(\"\".join(r),2)\n\treturn l^r\n\n\n\na,b=map(int,input().strip().split())\nprint(f(a,b))",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "def helper(n,m,k):\n    \n    if k % 2 == 1:\n        res = [[-1] * m for i in range(n)]\n        return res\n    \n    k = k // 2\n    \n    pool = [[[0]*m for i in range(n)] for j in range(k+1)]\n    \n    dx = [0,0,1,-1]\n    dy = [1,-1,0,0]\n    \n    for t in range(1,k+1):\n        for i in range(n):\n            for j in range(m):\n                tres = [9999999] * 4\n                for c in range(4):\n                    if 0 <= i+dx[c] < n and 0 <= j+dy[c] < m:\n                        if c == 0:\n                            tres[c] = hedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                        elif c == 1:\n                            tres[c] = hedge[i][j-1]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                        elif c == 2:\n                            tres[c] = vedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                        else:\n                            tres[c] = vedge[i-1][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                pool[t][i][j] = min(tres)\n    #print(pool)\n\n    return pool[k]\n\n#t = int(input())\n#for i in range(t):\n#n = int(input())\nn,m,k = map(int,input().split(\" \"))\nhedge = []\nvedge = []\nfor i in range(n):\n    hedge.append(list(map(int,input().split(\" \"))))\nfor i in range(n-1):\n    vedge.append(list(map(int,input().split(\" \"))))\n#a = list(map(int,input().split(\" \")))\n#print(len(a))\nres = helper(n,m,k)\nfor j in range(len(res)):\n    print(\" \".join(map(str,res[j])))\n#print(res)",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "import sys\nstdin=sys.stdin\n\nip=lambda: int(sp())\nfp=lambda: float(sp())\nlp=lambda:list(map(int,stdin.readline().split()))\nsp=lambda:stdin.readline().rstrip()\nYp=lambda:print('Yes')\nNp=lambda:print('No')\n\nN = ip()\nL = []\nfor _ in range(N):\n    x,w = lp()\n    L.append([x-w,x+w])\nL.sort(reverse=True)\nans = 0\nedge = 1<<40\nfor i in range(N):\n    if L[i][1] <= edge:\n        edge = L[i][0]\n        ans += 1\nprint(ans)",
    "complexity": "nlogn",
    "problem": "0528_B",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "a = list(input())\nb = input()\nout = []\nmx = '/'\na.sort()\na.reverse()\nx = len(a)\nif x == len (b):\n    for i in range(x):\n        q = 0\n        \n        for j in range(len(a)):\n            if a[j] == b[i]:\n                out.append(a[j])\n                a.pop(a.index(a[j]))\n                q = 1\n                break\n            elif a[j] < b[i]:\n                out.append(a[j])\n                a.pop(a.index(a[j]))\n                print(''.join(out), end = '')\n                print(''.join(a))\n                exit(0)\n        if q == 0:\n            break\n    if q == 1:\n        print(''.join(out))\n    else:\n        y = len(out)\n        for i in range(y-1, -1, -1):\n            for j in range(len(a)):\n                if a[j] < b[i] and a[j]>mx:\n                    mx = a[j]\n            if mx != '/':\n                   \n                    \n                a.append(out[len(out)-1])\n                out.pop()\n                out.append(mx)\n                a.pop(a.index(mx))\n                a.sort()\n                a.reverse()              \n                print(''.join(out), end = '')\n                print(''.join(a))\n                exit(0)\n            else:\n                a.append(out[len(out)-1])\n                out.pop()\n                a.sort()\n                a.reverse()\n                    \n                    \n                    \n        a.pop(a.index(mx))\n        print(mx, end ='')\n        print(''.join(a))\n                \n                \nelse:\n    print(''.join(a))\n        \n'''15778899\n98715689'''\n\n",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "N, K = input().split()\nN, K = int(N), int(K)\nP = [int(x) for x in input().split()]\nA = [None]*256\nA[0] = 0\nfor i in range(N):\n    pn = P[i]\n    if A[pn] is None:\n        for j in range(K-1, -1, -1):\n            if pn < j: continue\n            if A[pn-j] is None:\n                A[pn-j] = pn-j\n                break\n            else:\n                if A[pn-j] + K - 1 >= pn:\n                    break\n        for jj in range(j, -1, -1):\n            A[pn-jj] = A[pn-j]\nprint(*[A[P[i]] for i in range(N)])\n",
    "complexity": "quadratic",
    "problem": "0980_C",
    "from": "CODEFORCES",
    "tags": "games,greedy"
}
{
    "src": "def check(e,value,pre):\n    global maxi,count\n    e[str(value)]-=1\n    pre+=str(value)\n    arr=[]\n    for i in e:\n        for j in range(e[i]):\n            arr.append(i)\n    arr.sort(reverse=True)\n    st=''\n    for i in arr:\n        st+=str(i)\n    alpha=int(pre+st)\n    if alpha<=int(b):\n        maxi=max(maxi,int(pre+st))\n\n\na=input()\nb=input()\nmaxi=0\nd={}\nfor i in a:\n    if i not in d:\n        d[i]=1\n    else:\n        d[i]+=1\nmaxi=0\nnum=\"\"\ncount=0\nif len(a)<len(b):\n    check(d.copy(),max(d),'')\nelse:\n    for i in b:\n        if i in d and d[i]>0:\n            for j in range(int(i)-1,-1,-1):\n                if str(j) in d and d[str(j)]>0:\n                    check(d.copy(),j,num)\n                    break\n            check(d.copy(),i,num)\n            num+=i\n            d[i]-=1\n\n        else:\n            j=0\n            for j in range(int(i)-1,-1,-1):\n                if str(j) in d and d[str(j)]>0:\n                    check(d.copy(),j,num)\n                    break\n            break\nprint(maxi)",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n,k=map(int,input().split())\nfor i in range(10**5):\n  if (i*(i+1))//2-(n-i)==k:\n    print(n-i)",
    "complexity": "constant",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\ndef add(a,b):\n\treturn (a+b)%1000000007\n\ndef mul(a,b):\n\treturn (a*b)%1000000007\n\ndef sub(a,b):\n\treturn (a-b+1000000007)%1000000007\n\ndef qpow(a, b):\n\tr = 1\n\tk = a\n\tfor i in range(17):\n\t\tif b & (1<<i):\n\t\t\tr = mul(r, k)\n\t\tk = mul(k, k)\n\treturn r\n\nn, q = mints()\na = list(minp())\nc = [0]*(n+1)\nfor i in range(n):\n\tc[i+1] = c[i] + int(a[i])\nfor i in range(q):\n\tl, r = mints()\n\tk = (r-l+1)\n\to = c[r]-c[l-1]\n\tz = sub(qpow(2,o),1)\n\tprint(mul(z,qpow(2,k-o)))",
    "complexity": "linear",
    "problem": "1062_C",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)\nk = int(input())\na = 0\nfor i in T:\n    if i - k > 0:\n        a = T.index(i)\n        break\ntemp = T[a] - k\nx = temp % a\nres = (10 ** a) - 1 - int(temp / a)\nans = int((res % (10 ** (x+1))) / (10 ** x))\nprint(ans)\n",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# ------------------- fast io --------------------\nfrom bisect import bisect_left as bsl\ndef main():\n    cur=9;count=1;tot=0\n    num=[];cc=[]\n    for s in range(11):\n        num.append(cur*count)\n        tot+=cur\n        cc.append(tot)\n        cur*=10;count+=1\n    ans=[num[0]]\n    for s in range(1,11):\n        ans.append(ans[-1]+num[s])\n    k=int(input())\n    ind=min(bsl(ans,k),10)\n    left=k\n    if ind>0:\n        left-=ans[ind-1]\n    #sort out this bit below, might be ceil instead of //\n    nums=left//(ind+1);rem=left%(ind+1)\n    if left%(ind+1)!=0:\n        nums+=1\n    if ind>0:\n        nums+=cc[ind-1]\n    answer=[int(k) for k in str(nums)]\n    print(answer[rem-1])\nmain()",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "n,s=map(int,input().split())\nif s>=n:\n    print(\"0\")\n    exit()\nfor i in range(s,n+2):\n    cur=int(0)\n    for j in str(i):\n        cur+=int(j)\n    if i-cur>=s:\n        break\nprint(n-i+1)\n",
    "complexity": "logn",
    "problem": "0817_C",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,dp,math"
}
{
    "src": "import sys\ninput = sys.stdin.readline\nq = int( input() )\nrgb = \"RGB\"\nfor _ in range( q ):\n    n, k = map( int, input().split() )\n    s = input()\n    ans = n\n    for i in range( 3 ):\n        r = [ 0 ]\n        l = i\n        for c in s:\n            r.append( r[ -1 ] + ( 1 if c != rgb[ l ] else 0 ) )\n            l = ( l + 1 ) % 3\n            if len( r ) > k:\n                ans = min( ans, r[ -1 ] - r[ len( r ) - 1 - k ] )\n    print( ans )\n",
    "complexity": "linear",
    "problem": "1196_D2",
    "from": "CODEFORCES",
    "tags": "data structures,dp,implementation,two pointers"
}
{
    "src": "import sys\nimport math\nimport collections\nimport heapq\ninput=sys.stdin.readline\nk1,k2,k3=(int(i) for i in input().split())\nl=[k1,k2,k3]\nif(1 in l):\n    print(\"YES\")\nelif(l.count(2)>=2):\n    print(\"YES\")\nelif(l.count(3)==3):\n    print(\"YES\")\nelif(sorted(l)==[2,4,4]):\n    print(\"YES\")\nelse:\n    print(\"NO\")",
    "complexity": "constant",
    "problem": "0911_C",
    "from": "CODEFORCES",
    "tags": "brute force,constructive algorithms"
}
{
    "src": "n = int(input())\nA = list(map(int, input().split()))\nA.sort()\nB = [0] * n\nans = 0\nfor i in range(n):\n    if B[i] == 0:\n        ans += 1\n        B[i] = 1\n        for j in range(n):\n            if A[j] % A[i] == 0:\n                B[j] = 1\nprint(ans)",
    "complexity": "quadratic",
    "problem": "1209_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "# Problem G\n\nnum = input()\nnum_list = []\nfor i in range(len(num)):\n  num_list.append(int(num[i]))\nmyMod = (10 ** 9) + 7\nlength = len(num_list)\nf = [0] * (length + 1)\nt = [1] * (length + 1)\nfor i in range(length):\n    f[i+1] = (f[i] * 10 + 1) % myMod\n    t[i+1] = (t[i] * 10) % myMod\nans = 0\nfor i in range(1, 10):\n    dp = [0] * (length + 1)\n    for j in range(length):\n        dp[j+1] = (dp[j] * i + (10 - i) * (dp[j] * 10 + t[j])) % myMod\n    c = 0\n    ctr = 0\n    for k in num_list:\n        z = min(i, k)\n        o = k - z\n        ans += o * (dp[length-1-ctr] * t[c+1] + f[c+1] * t[length-1-ctr]) % myMod\n        ans += z * (dp[length-1-ctr] * t[c] + f[c] * t[length-1-ctr]) % myMod\n        ans %= myMod\n        c += k >= i\n        ctr += 1\n    ans += f[c]\n    if ans >= myMod:\n        ans -= myMod\nprint(ans)\n \t     \t \t\t\t\t   \t  \t \t\t \t  \t\t",
    "complexity": "quadratic",
    "problem": "0908_G",
    "from": "CODEFORCES",
    "tags": "dp,math"
}
{
    "src": "from math import sin\nn,r=[int(i) for i in input().split()]\npi=3.14159265359\nprint(r/((2*sin(pi*(1/2-1/n)))/(sin(2*pi/n))-1))",
    "complexity": "constant",
    "problem": "1100_C",
    "from": "CODEFORCES",
    "tags": "binary search,geometry,math"
}
{
    "src": "n = [int(x) for x in input().split(' ')]\nM = 1000000007\n\ndef a(k):\n\tM = 1000000007\n\tif(k>0):\n\t\tl = a(k//2)\n\t\treturn (l*l*(k%2+1))%M\n\telse:\n\t\treturn 1\n\n\nif n[0]==0:\n\tprint(0)\nelse:\n\tl = a(n[1])\n\tprint((2*(n[0]%M)*l-l+1)%M)\n\n\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "l,r=map(int,input().split())\nz=l^r\nc=0\nif(z==0):\n    print(0)\n    exit()\nwhile(z):\n\tc+=1;\n\tz>>=1;\nx='1'*c\nprint(int(x,2))\n\t   \t  \t   \t\t \t \t\t  \t \t  \t\t  \t\t",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "n, k = map(int, input().split())\ns = input()\nfail = [-1] * (len(s) + 1)\nfor i in range(1, len(s) + 1):\n    j = fail[i - 1]\n    while j != -1 and s[i - 1] != s[j]:\n        j = fail[j]\n    fail[i] = j + 1\n# print(fail)\n\nf1 = fail[-1]\nprint(s + s[f1:] * (k - 1))",
    "complexity": "quadratic",
    "problem": "1029_A",
    "from": "CODEFORCES",
    "tags": "implementation,strings"
}
{
    "src": "\nimport math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n    return d[s]\n \nn,x,y=map(int,input().split())\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))\ny+=x\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))",
    "complexity": "np",
    "problem": "1463_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,math"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\ns = set(a)\ns.discard(0)\nprint(len(s))\n",
    "complexity": "linear",
    "problem": "0992_A",
    "from": "CODEFORCES",
    "tags": "implementation,sortings"
}
{
    "src": "n,k=map(int,input().split())\nmod=998244353\ndp=[[0,0,0,0] for _ in range(k+1)]\n#dp[0][0]=dp[0][1]=dp[0][2]=dp[0][3]=\ndp[1][0]=dp[1][3]=1\nif k>1:\n    dp[2][2]=dp[2][1]=1\nfor x in range(1,n):\n    g=[[0,0,0,0] for _ in range(k+1)]\n    # 0 - bb\n    # 1 - bw\n    # 2 - wb\n    # 3 - ww\n    g[1][0]=g[1][3]=1\n    for i in range(2,k+1):\n        g[i][0]=(dp[i][0]+dp[i][1]+dp[i][2]+dp[i-1][3])%mod\n        g[i][1]=(dp[i-1][0]+dp[i][1]+dp[i-2][2]+dp[i-1][3])%mod\n        g[i][2]=(dp[i-1][0]+dp[i-2][1]+dp[i][2]+dp[i-1][3])%mod\n        g[i][3]=(dp[i-1][0]+dp[i][1]+dp[i][2]+dp[i][3])%mod\n    dp=g\nprint(sum(dp[-1])%mod)",
    "complexity": "np",
    "problem": "1051_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "n = int(input())\narr = list(map(int, input().split()))\n\nfor i in range(n):\n    arr[i] = (arr[i]-i)//n + (1 if (arr[i]-i)%n>0 else 0)\nprint(arr.index(min(arr))+1)\n",
    "complexity": "linear",
    "problem": "0996_B",
    "from": "CODEFORCES",
    "tags": "binary search,math"
}
{
    "src": "n = int(input())\nprint(25)\n",
    "complexity": "constant",
    "problem": "0630_A",
    "from": "CODEFORCES",
    "tags": "number theory"
}
{
    "src": "a = sorted(input())\nb = int(input())\na = a[::-1] #reverse a\np = ''\ncnt = [0]*10\n\nwhile a :\n    for i, d in enumerate(a):\n        n = p + d + \"\".join(sorted(a[:i]+a[i+1:]))\n        if int(n) <= b :\n            p += d\n            a.pop(i)\n            break\n        \nprint(p)",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import math\nfrom collections import defaultdict\nml=lambda:map(int,input().split())\nll=lambda:list(map(int,input().split()))\nii=lambda:int(input())\nip=lambda:list(input())\n\n\"\"\"========main code===============\"\"\"\n\nn,k=ml()\nans=0;\nfor i in range(1,1000001):\n    val=(i*(i+1))//2\n    if(val-(n-i)==k):\n        ans=n-i\nprint(ans)        ",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "n, k = map(int, input().split())\n\nm = 2 * (n - 1) - k * (k - 1)\n\nif m > 0: print(-1)\n\nelse:\n\n    x = int((1 + (1 - 4 * m) ** 0.5) / 2)\n\n    if x * (x - 1) + m > 0: x -= 1\n\n    print(k - x)\n\n\n\n# Made By Mostafa_Khaled",
    "complexity": "logn",
    "problem": "0287_B",
    "from": "CODEFORCES",
    "tags": "binary search,math"
}
{
    "src": "import sys\nfrom array import array  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\nn = int(input())\nprob = [tuple(map(float, input().split())) for _ in range(n)]\nfull_bit = (1 << n) - 1\ndp = [0.0] * full_bit + [1.0]\n\nfor bit in range(full_bit, 0, -1):\n    popcount = len([1 for i in range(n) if (1 << i) & bit])\n    if popcount == 1 or dp[bit] == 0.0:\n        continue\n    div = 1 / ((popcount * (popcount - 1)) >> 1)\n\n    for i in range(n):\n        if ((1 << i) & bit) == 0:\n            continue\n        for j in range(i + 1, n):\n            if ((1 << j) & bit) == 0:\n                continue\n            dp[bit - (1 << j)] += dp[bit] * prob[i][j] * div\n            dp[bit - (1 << i)] += dp[bit] * prob[j][i] * div\n\nprint(*(dp[1 << i] for i in range(n)))\n",
    "complexity": "np",
    "problem": "0016_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,probabilities"
}
{
    "src": "import sys, os.path\nif(os.path.exists('input.txt')):\n\tsys.stdin = open(\"input.txt\",\"r\")\n\t\n\nt = int(input())\nlast = []\ncurrent = []\n\nfor i in range(t):\n\tlast.append(str(input()))\nfor i in range(t):\n\tcurrent.append(str(input()))\n\nfor i in range(len(last)):\n\tif last[i] in current:\n\t\tcurrent[current.index(last[i])] = \"*\"\n\t\tlast[i] = \"*\"\n\nlast.sort()\ncurrent.sort()\n\ntotal = 0\nfor i in range(len(last)):\n\tif last[i] == current[i]:\n\t\tcontinue\n\telse:\n\t\ttotal+=1\n\t\nprint(total)\n\n\n",
    "complexity": "linear",
    "problem": "1000_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation"
}
{
    "src": "n,x = list(map(int, input().split()))\na = set(map(int, input().split()))\n\nif len(a) < n :\n    print(0)\nelse :\n    d = set()\n    p = 0\n    for i in a :\n        d.add(i&x)\n        if i&x != i and i&x in a :\n            print(1)\n            p = 1\n            break\n    if len(d) < n and p == 0 :\n        print(2)\n    elif p != 1 :\n        print(-1)\n",
    "complexity": "linear",
    "problem": "1013_B",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "t = input()\n\nn = len(t)\n\nmaxi = 0\n\nfor i in range(n):\n    s = t[i]\n    if t.count(s) > 1:\n        maxi = max(maxi, 1)\n    nr = 1\n    for j in range(i + 1, n):\n        s += t[j]\n        nr += 1\n        g = 0\n        for h in range(n - nr + 1):\n            if s == t[h:h + nr]:\n                g += 1\n        if g > 1:\n            maxi = max(nr,maxi)\n\nprint(maxi)",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "import sys\ndef ask(x,y,rev):\n\tif (rev==0):\n\t\tprint(\"? %d %d\"%(x,y))\n\telse:\n\t\tprint(\"? %d %d\"%(y,x))\n\tsys.stdout.flush()\n\tif (rev==1):\n\t\treturn -int(input())\n\telse:\n\t\treturn int(input())\n\ncomp=ask(0,0,0)\nnowa=0\nnowb=0\nrev=0\nfor i in range(29,-1,-1):\n\tif (comp<0):\n\t\trev^=1\n\t\tnowa,nowb=nowb,nowa\n\t\tcomp=-comp\n\tif comp>=0:\n\t\tcomp=ask(nowa|(1<<i),nowb|(1<<i),rev)\n\t\tif (comp<0):\n\t\t\tnowa|=1<<i\n\t\t\tcomp=ask(nowa,nowb,rev)\n\t\telse:\n\t\t\ttmp=ask(nowa|(1<<i),nowb,rev)\n\t\t\tif (tmp<0):\n\t\t\t\tnowa|=1<<i\n\t\t\t\tnowb|=1<<i\nif (rev==1):\n\tnowa,nowb=nowb,nowa\nprint(\"! %d %d\"%(nowa,nowb))\n\t\t\t\n\t\t",
    "complexity": "logn",
    "problem": "1088_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,constructive algorithms,implementation,interactive"
}
{
    "src": "\nn = int(input())\nfib = [0,1]\n\nfor x in range(1,200):\n\n\n    z = fib[x] + fib[x-1]\n    if z <= n:\n\n        fib.append(z)\n    else:\n        break\n\nfib = fib[::-1]\nlis = []\nfor y in range(len(fib)):\n\n    if fib[y] <= n:\n        if (sum(lis) + fib[y]) <= n:\n            if len(lis) < 3:\n                lis.append(fib[y])\nif sum(lis) == n:\n    if len(lis) == 1:\n        lis.append(0)\n        lis.append(0)\n        print(*lis)\n    elif len(lis) == 2:\n        lis.append(0)\n        print(*lis)\n    else:\n        print(*lis)\nelse:\n    print(\"I'm too stupid to solve this problem\")\n\n\n",
    "complexity": "constant",
    "problem": "0199_A",
    "from": "CODEFORCES",
    "tags": "brute force,constructive algorithms,implementation,number theory"
}
{
    "src": "#!/usr/bin/env python3\nn,m,k,l=map(int,input().split())\nq=(l+k-1)//m+1\nif q*m>n:print(-1)\nelse:print(q)\n",
    "complexity": "constant",
    "problem": "1068_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\n\ndef chain_reaction(n, beacons):\n    table = [0] * n\n    # table[i] represents the number of beacons destroyed if the first i beacons are used\n    for i in range(n):\n        position = beacons[i][0]\n        power = beacons[i][1]\n        destroyed = 0\n        r = position - power\n        b = 0\n        # use binary search to find the beacon that will be activated after the current one\n        lo = 0\n        hi = len(beacons) - 1\n        while lo <= hi:\n            mid = int(lo + (hi - lo) / 2)\n            pos = beacons[mid][0]\n            if beacons[mid][0] < r:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        # beacons destroyed by next activated one\n        destroyed += table[hi]\n        # beacons destroyed by currently activated one\n        destroyed += (i - (hi + 1))\n        table[i] = destroyed\n\n    # print(table)\n\n    # find first index of max # of beacons destroyed\n    max_val = max(table)\n    ind = 0\n    while ind < len(table):\n        if table[ind] == max_val:\n            break\n        ind += 1\n    cost = (len(table) - ind) + table[ind - 1]\n\n    options = []\n    for i in range(n):\n        cost = (n - i) + table[i - 1]\n        options.append(cost)\n    min_cost = min(options)\n\n    # options: add a beacon that doesn't destroy any or add a beacon that destroys the beacon at index ind\n    # return min(table[n - 1], cost)\n    return min(table[n - 1], min_cost)\n \nn = int(sys.stdin.readline().strip())\nbeacons = []\nfor i in range(n):\n    a, b = [int(x) for x in sys.stdin.readline().strip().split(\" \")]\n    beacons.append((a, b))\nbeacons.sort()\nprint(chain_reaction(n, beacons))",
    "complexity": "linear",
    "problem": "0608_C",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "def solve(a, b):\n    m = max(a, b)\n    n = min(a, b)\n    if n == 0:\n        return 0\n    if m == n:\n        return 1\n    elif m % n == 0:\n        return m // n\n    k = m // n\n    return k + solve(n, m - n * k)\n\n\nfor _ in range(int(input())):\n    a, b = map(int, input().split())\n    print(solve(a, b))",
    "complexity": "constant",
    "problem": "0267_A",
    "from": "CODEFORCES",
    "tags": "math,number theory"
}
{
    "src": "\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+1)\n\n    def to_sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, x):\n        while i <= self.n:\n            self.data[i] += x\n            i += (i & -i)\n\n    def get(self, i, j):\n        #[i,j](1<=i<=j<=N)\n        return self.to_sum(j) - self.to_sum(i - 1)\n\n\ndef f(x, V):\n    if x < V:\n        return -1\n    return 1\n\n\ndef calc_median(M):\n    b = [f(v, M) for v in a]\n    res = 0\n    c = [0]\n    for x in b:\n        c.append(c[-1] + x)\n    d = [(c[i], i) for i in range(n + 1)]\n    bit = BIT(2*n + 10)\n    for value, index in d:\n        if index == 0:\n            bit.add(value + n + 1, 1)\n            continue\n        res += bit.get(1, value + n)\n        bit.add(value + n + 1, 1)\n\n    return res\n\n\nprint(calc_median(m) - calc_median(m + 1))\n\n",
    "complexity": "nlogn",
    "problem": "1005_E1",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "\nfrom sys import stdin,stdout,setrecursionlimit\nstdin.readline\ndef mp(): return list(map(int, stdin.readline().strip().split()))\ndef it():return int(stdin.readline().strip())\nfrom collections import defaultdict as dd,Counter as C,deque\nfrom math import ceil,gcd,sqrt,factorial,log2,floor\t\nfrom bisect import bisect_right as br,bisect_left as bl\nimport heapq\n\ndef solve(a,b):\n\tif a == 0:\n\t\treturn 0\n\treturn b//a + solve(b%a,a)\nprint(solve(*mp()))\n\n",
    "complexity": "constant",
    "problem": "0343_A",
    "from": "CODEFORCES",
    "tags": "math,number theory"
}
{
    "src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n# sys.setrecursionlimit(111111) \n \ndef main():\n    \n\n  \n \n\n          \n                  \n    # mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n\n            \n\n\n    ###CODE\n    tc = 1\n    for _ in range(tc):\n        n,x=ria()\n        a=ria()\n        d=Counter(a)\n        sa=set(a)\n        if len(sa)<n:\n            print(0)\n        else:\n            c=0\n            for i in a:\n                k=i&x\n                if k!=i and k in d:\n                    c=1\n                    print(1)\n                    break            \n            if c==0:\n                z=[]\n                for i in a:\n                    z.append(i&x)\n                if len(set(z))<n:\n                    print(2)\n                else:\n                    print(\"-1\")\n        \n        \n                \n        \n            \n        \n                    \n                                    \n                \n        \n            \n                    \n                    \n        \n            \n        \n        \n        \n            \n            \n            \n            \n            \n        \n        \n                    \n            \n        \n        \n                    \n                \n        \n        \n            \n                \n        \n\n            \n        \n\n               \n            \n        \n              \n                \n        \n        \n            \n        \n        \n            \n            \n        \n        \n                \n                \n                \n                \n            \n        \n        \n            \n           \n        \n            \n                    \n\n                                 \n                \n                \n        \n\n                \n        \n        \n        \n            \n        \n        \n                \n            \n        \n        \n                    \n        \n        \n        \n            \n                    \n            \n\n                \n            \n            \n                \n            \n                \n            \n            \n            \n            \n                \n            \n        \n        \n        \n        \n        \n        \n        \n                    \n        \n        \n        \n                \n                \n        \n            \n            \n            \n        \n\n                    \n        \n                \n        \n        \n                        \n        \n                            \n\n        \n\n                \n            \n        \n\n                \n            \n                    \n                \n                \n        \n        \n         \n        \n\n                        \n                            \n                \n        \n                            \n                    \n\n                \n            \n        \n                \n            \n                \n        \n        \n        \n                             \n        \n            \n        \n        \n            \n                        \n                        \n                    \n            \n        \n        \n        \n        \n        \n                        \n       \n\n        \n                           \n        \n        \n        \n            \n        \n        \n        \n                      \n\n      \n                            \n            \n        \n        \n            \n            \n            \n            \n            \n        \n        \n        \n            \n        \n        \n        \n            \n        \n        \n        \n        \n            \n            \n        \n        \n        \n        \n        \n        \n        \n                \n                \n                    \n        \n        \n            \n            \n        \n                \n            \n            \n        \n        \n        \n        \n                \n        \n            \n        \n                \n        \n        \n            \n        \n       \n            \n\n                \n        \n        \n        \n   \n            \n        \n        \n        \n        \n            \n        \n                \n        \n        \n        \n            \n            \n        \n        \n            \n        \n        \n\n        \n        \n            \n        \n        \n            \n        \n                        \n\n        \n        \n            \n     \n        \n        \n            \n        \n        \n                \n            \n        \n        \n        \n                \n            \n        \n\n            \n             \n        \n            \n        \n        \n        \n                \n        \n            \n        \n        \n        \n        \n                \n        \n        \n            \n        \n        \n        \n        \n                \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    ",
    "complexity": "linear",
    "problem": "1013_B",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=998244353\nEPS=1e-6\ndef Ceil(a,b): return a//b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n\n\ndef ok(a,b,c):\n\n    # print(a[0],b,c)\n\n    n = a[0][-1]\n    ans = []\n    for i in range(a[0][0]): ans.append([a[1]]*n)\n\n    l = n\n    r = n - a[0][0]\n\n    for i in range(2):\n        for j in range(2):\n\n            l1,r1 = b[0]\n            l2,r2 = c[0]\n\n            if(i): l1,r1 = r1,l1\n            if(j): l2,r2 = r2,l2\n\n            if(l1 == l):\n                if(l2 != l or r1 + r2 != r): continue\n\n                for k in range(r1): ans.append([b[1]]*n)\n                for k in range(r2): ans.append([c[1]]*n)\n                return ans\n\n\n            if(l1 == r):\n                if(l2 != r or r1 + r2 != l): continue\n\n                for k in range(r): ans.append( [b[1]]*r1 + [c[1]]*r2)\n                return ans\n\n    return False\n\n\nl1,r1,l2,r2,l3,r3 = value()\n\na = [sorted((l1,r1)),'A']\nb = [sorted((l2,r2)),'B']\nc = [sorted((l3,r3)),'C']\n\nA = ok(a,b,c)\nB = ok(b,a,c)\nC = ok(c,a,b)\n\nif(A):\n    print(len(A))\n    for i in A: print(*i,sep=\"\")\nelif(B): \n    print(len(B))\n    for i in B: print(*i,sep=\"\")\nelif(C):\n    print(len(C))\n    for i in C: print(*i,sep=\"\")\nelse: \n    print(-1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "complexity": "np",
    "problem": "0581_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,constructive algorithms,geometry,implementation,math"
}
{
    "src": "# Fast IO Region\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# Get out of main function\ndef main():\n    pass\n# decimal to binary\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n# binary to decimal\ndef decimal(s):\n    return (int(s, 2))\n# power of a number base 2\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return (p)\n# if  number is prime in \u221an time\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n# list to string ,no spaces\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n# String to list\ndef stl(s):\n    # for each character in string to list with no spaces -->\n    l = list(s)\n    # for space in string  -->\n    # l=list(s.split(\" \"))\n    return l\n# Returns list of numbers with a particular sum\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n# Sieve for prime numbers in a range\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n            # print(p)\n    return (cnt)\n# for positive integerse only\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n# 1000000007\nmod = int(1e9) + 7\nimport math\n#import random\n#import bisect\n#from fractions import Fraction\n#from collections import OrderedDict\n#from collections import deque\n########################                         mat=[[0 for i in range(n)] for j in range(m)]                      ########################\n########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################\n########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################\n########################                         from collections import deque                              ########################\n########################                         ASCII of A-Z= 65-90                                        ########################\n########################                         ASCII of a-z= 97-122                                       ########################\n########################                         d1.setdefault(key, []).append(value)                       ########################\n#sys.setrecursionlimit(300000)          #Gives memory limit exceeded if used a lot\n#for ___ in range(int(input())):\ndef deep(node):\n    visited[node-1]=1\n    if(len(d[node])==1):\n        return node\n    for c in d[node]:\n        if(visited[c-1]!=1):\n            return(deep(c))\n\nn=int(input())\nd={}\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    d.setdefault(u,[]).append(v)\n    d.setdefault(v,[]).append(u)\nnode=1\nfor key in d:\n    if(len(d[key])>len(d[node])):\n        node=key\nans=[]\nvisited=[0]*n\nvisited[node-1]=1\nfor c in d[node]:\n    while(True):\n        visited[c-1]=1\n        if(len(d[c])==1):\n            ans.append([node,c])\n            break\n        for child in d[c]:\n            if(visited[child-1]!=1):\n                c=child\n                break\nif(sum(visited)==n):\n    print(\"Yes\")\n    print(len(ans))\n    for c in ans:\n        print(*c)\nelse:\n    print(\"No\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "complexity": "linear",
    "problem": "0981_C",
    "from": "CODEFORCES",
    "tags": "implementation,trees"
}
{
    "src": "s=input()\nans=0\nm=set()\nfor i in range(len(s)):\n    for j in range(i,-1,-1):\n        if(s[j:i+1] in m):\n            ans=max(ans,i-j+1)\n        else:\n            m.add(s[j:i+1])\nprint(ans)\n    ",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "import sys\nimport math\ninput = sys.stdin.readline\n\ntestcase=int(input())\nT=[list(map(int,input().split())) for i in range(testcase)]\n\ndef bi(n,k):\n    MIN=0\n    MAX=n\n\n    while MAX>MIN+1:\n        bn=(MIN+MAX)//2\n        if math.log2(k+2+bn)<bn+1:\n            MAX=bn\n        elif math.log2(k+2+bn)==bn+1:\n            return bn\n        else:\n            MIN=bn\n\n    if MAX+1<=math.log2(k+2+MAX):\n        return MAX\n\n    return MIN\n\nfor n,k in T:\n    if n==1:\n        if k==1:\n            print(\"YES\",0)\n        else:\n            print(\"NO\")\n        continue\n\n    if n==2:\n        if 1<=k<=2:\n            print(\"YES\",1)\n        elif k==3:\n            print(\"NO\")\n        elif 4<=k<=5:\n            print(\"YES\",0)\n        else:\n            print(\"NO\")\n        continue\n        \n    if n<=30 and k>(pow(4,n)-1)//3:\n        print(\"NO\")\n        continue\n\n    ANS=bi(n,k)\n\n    print(\"YES\",n-ANS)\n    \n    \n",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "# ---------------------------iye ha aam zindegi---------------------------------------------\nimport math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\n#threading.stack_size(10**8)\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\n# ------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n#sys.setrecursionlimit(300000)\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n        \"\"\"\n        Side effect!!! Changes node. Node should have exactly one child\n        \"\"\"\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\n\n# -----------------------------------------------binary seacrh tree---------------------------------------\nclass SegmentTree1:\n    def __init__(self, data, default=2**30, func=lambda a, b: min(a , b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b:a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------------------iye ha chutiya zindegi-------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\n\n# --------------------------------------iye ha combinations ka zindegi---------------------------------\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n // 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\n\n# --------------------------------------iye ha power ka zindegi---------------------------------\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\n\n# --------------------------------------------------product----------------------------------------\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\n\n# --------------------------------------------------binary----------------------------------------\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) / 2)\n\n        # Check if middle element is\n        # less than or equal to key\n        if (arr[mid] < key):\n            count = mid + 1\n            left = mid + 1\n\n        # If key is smaller, ignore right half\n        else:\n            right = mid - 1\n\n    return count\n\n\n# --------------------------------------------------binary----------------------------------------\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    # Stores the index of the left most element\n    # from the array which is greater than k\n    leftGreater = n\n\n    # Finds number of elements greater than k\n    while (l <= r):\n        m = int(l + (r - l) / 2)\n        if (arr[m] > k):\n            leftGreater = m\n            r = m - 1\n\n        # If mid element is less than\n        # or equal to k update l\n        else:\n            l = m + 1\n\n    # Return the count of elements\n    # greater than k\n    return (n - leftGreater)\n\n\n# --------------------------------------------------binary------------------------------------\nclass TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEndOfWord = False\nclass Trie:\n    def __init__(self):\n        self.root = self.getNode()\n    def getNode(self):\n        return TrieNode()\n    def _charToIndex(self, ch):\n        return ord(ch) - ord('a')\n    def insert(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n        pCrawl.isEndOfWord = True\n    def search(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return False\n            pCrawl = pCrawl.children[index]\n        return pCrawl != None and pCrawl.isEndOfWord\n#-----------------------------------------trie---------------------------------\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.count=0\n        self.left = None  # left node for 0\n        self.right = None  # right node for 1\nclass BinaryTrie:\n    def __init__(self):\n        self.root = Node(0)\n    def insert(self, pre_xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = pre_xor & (1 << i)\n            if val:\n                if not self.temp.right:\n                    self.temp.right = Node(0)\n                self.temp = self.temp.right\n                self.temp.count+=1\n            if not val:\n                if not self.temp.left:\n                    self.temp.left = Node(0)\n                self.temp = self.temp.left\n                self.temp.count += 1\n        self.temp.data = pre_xor\n    def query(self, xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = xor & (1 << i)\n            if not val:\n                if self.temp.left and self.temp.left.count>0:\n                    self.temp = self.temp.left\n                elif self.temp.right:\n                    self.temp = self.temp.right\n            else:\n                if self.temp.right and self.temp.right.count>0:\n                    self.temp = self.temp.right\n                elif self.temp.left:\n                    self.temp = self.temp.left\n            self.temp.count-=1\n        return xor ^ self.temp.data\n#-------------------------bin trie-------------------------------------------\nn,m=map(int,input().split())\nl=[]\npm=2**m-1\nfor i in range(n):\n    l.append(list(map(int,input().split())))\ndef find (x):\n    s=set()\n    d=defaultdict(int)\n    for i in range(n):\n        a=\"\"\n        for j in range(m):\n            if l[i][j]>=x:\n                a+='1'\n            else:\n                a+='0'\n        d[int(a,2)]=i\n        s.add(int(a,2))\n    s=list(s)\n    #print(s)\n    for i in range(len(s)):\n        for j in range(i,len(s)):\n            if s[i]|s[j]==pm:\n                return [d[s[i]]+1,d[s[j]]+1]\n    return [-1,-1]\nst=0\nend=10**9\nans=(0,0)\nwhile(st<=end):\n    mid=(st+end)//2\n    s=find(mid)\n    if s[0]!=-1:\n        ans=s\n        st=mid+1\n    else:\n        end=mid-1\nprint(*ans)",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\n# ------------------------------\n# f = open('./input.txt')\n# sys.stdin = f\n\ndef main():\n    n, k = RL()\n    cds = RLL()\n    fn = RLL()\n    sc = [0]+RLL()\n\n    rec = set(fn)\n    uses = 0\n    dic = defaultdict(int)\n    for i in cds:\n        if i in rec:\n            dic[i]+=1\n            uses+=1\n\n    dp = [[0]*(n*k+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(1, n*k+1):\n            for l in range(k+1):\n                if l>j: break\n                val = sc[l]\n                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)\n    res = 0\n\n    for i, v in Counter(fn).items():\n        res+=dp[v][dic[i]]\n    # for i in dp: print(i)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n\n",
    "complexity": "cubic",
    "problem": "0999_F",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "n = int(input())\nax, ay = map(int, input().split())\nbx, by = map(int, input().split())\ncx, cy = map(int, input().split())\n\nif bx < ax < cx:\n    print(\"NO\")\nelif cx < ax < bx:\n    print(\"NO\")\nelif by < ay < cy:\n    print(\"NO\")\nelif cy < ay < by:\n    print(\"NO\")\nelse:\n    print(\"YES\")",
    "complexity": "constant",
    "problem": "1033_A",
    "from": "CODEFORCES",
    "tags": "dfs and similar,graphs,implementation"
}
{
    "src": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\npoints = [(x1, y1), (x2, y2), (y3, x3)]\n\ndef gen_points(A, B):\n\t'''\n\t+--.\n\t|\n\t|\n\t.\n\t'''\n\n\treturn [(A[0], B[1]), (B[0], A[1])]\n\npoints += gen_points([x1, y1], [x2, y2])\npoints += gen_points([x2, y2], [x3, y3])\npoints += gen_points([x1, y1], [x3, y3])\n\npoints = list(set(points))\n\nans = 1e9\nans_l = []\n\ndef mark_points(A, B):\n\tA = list(A)\n\tB = list(B)\n\td = set()\n\tx_s = 1 if A[0] < B[0] else -1\n\ty_s = 1 if A[1] < B[1] else -1\n\td.add((A[0], A[1]))\n\twhile A[0] != B[0]:\n\t\tA[0] += x_s\n\t\td.add((A[0], A[1]))\n\twhile A[1] != B[1]:\n\t\tA[1] += y_s\n\t\td.add((A[0], A[1]))\n\treturn d\n\nfor el in points:\n\td = mark_points([x1, y1], el).union(mark_points([x2, y2], el))\n\td = d.union(mark_points([x3, y3], el))\n\tif len(d) < ans:\n\t\tans = len(d)\n\t\tans_l = d\n\nprint(ans)\nfor el in ans_l:\n\tprint(*el)",
    "complexity": "quadratic",
    "problem": "1086_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation"
}
{
    "src": "from itertools import combinations\n \nn,l,r,x = map(int,input().split())\na=list(map(int,input().split()))\n \nc=[]\nfor i in range(2,n+1):\n\tc+=list(combinations(a,i))\n \ncnt=0\n \nfor t in c:\n\tm=min(t)\n\tM=max(t)\n\ts=sum(t)\n\tif M-m >=x and (s>=l and s<=r):\n\t\tcnt+=1\n \nprint(cnt)",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "import sys\n \np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.buffer.readline())\ndef MI(): return map(int, sys.stdin.buffer.readline().split())\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef BI(): return sys.stdin.buffer.readline().rstrip()\ndef SI(): return sys.stdin.buffer.readline().rstrip().decode()\ndef li(): return [int(i) for i in input().split()]\ndef lli(rows): return [li() for _ in range(rows)]\ndef si(): return input()\ndef ii(): return int(input())\ndef ins(): return input().split()\n\n\nn,m=MI()\nposf=(n*(n-1))//2\nif(n%2!=0):\n    negf=(n//2)*(n//2+1)\nelse:\n    negf=(n//2)*(n//2-1)+n//2\nans=0\nfor i in range(m):\n    x,d=MI()\n    ans+=n*x\n    if(d>=0):\n        ans+=posf*d\n    else:\n        ans+=negf*d\nprint(ans/n)",
    "complexity": "linear",
    "problem": "1009_C",
    "from": "CODEFORCES",
    "tags": "greedy,math"
}
{
    "src": "n, k = map(int, input().split())\nr_n = n * 2\ng_n = n * 5\nb_n = n * 8\nt = 0\nt += r_n // k\nif r_n % k != 0:\n    t += 1\nt += g_n // k\nif g_n % k != 0:\n    t += 1\n\nt += b_n // k\nif b_n % k != 0:\n    t += 1\nprint(t)\n",
    "complexity": "constant",
    "problem": "1080_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "\n\n\n\nn,k = map(int,input().split())\n\n\nt  = list(map(int,input().split()))\n\nt.sort()\n\n\nf={}\n\nfor j in t:\n    if j not in f:\n        f[j]=1\n    else:\n        f[j]+=1\n\n\np=0\nfor j in range(n):\n    if j<n-1:\n        if t[j+1]>t[j] and t[j]+k >= t[j+1]:\n            p+=f[t[j]]\n    \nprint(n-p)\n",
    "complexity": "nlogn",
    "problem": "0990_B",
    "from": "CODEFORCES",
    "tags": "greedy,sortings"
}
{
    "src": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n = I()\n    aa = [LI() for _ in range(n)]\n    r = []\n    for a,b in aa:\n        al = a + (1-a%2)\n        ar = b - (1-b%2)\n        sa = (ar-al) // 2 + 1\n        tr = -(al+ar) * sa // 2\n\n        bl = a + (a%2)\n        br = b - (b%2)\n        sb = (br-bl) // 2 + 1\n        tr += (bl+br) * sb // 2\n        r.append(tr)\n\n    return \"\\n\".join(map(str,r))\n\n\nprint(main())\n",
    "complexity": "constant",
    "problem": "1080_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n, m = map(int, input().split())\na = 1\nfor i in range(n - 1):\n  a *= 10\n  a += 1\nb = 10 ** n - a\nprint(a)\nprint(b)",
    "complexity": "constant",
    "problem": "1028_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "s = input()\nwhile s!=\"\":\n\tif s==s[::-1]:\n\t\ts=s[:(len(s)-1)]\n\telse:\n\t\tbreak\nprint(len(s))",
    "complexity": "linear",
    "problem": "0981_A",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,strings"
}
{
    "src": "import os\nfrom io import BytesIO, IOBase\nimport sys\n \n \ndef main():\n    n = int(input())\n    a = list(map(int,input().split()))\n    a = set(a)\n    a = list(sorted(list(a)))\n    if len(a) == 1:\n        print(\"NO\")\n    else:\n        print(a[1])\n    return\n \n \n# region fastio\nBUFSIZE = 1048576\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip('\\r\\n')\n \n# endregion\n \n \nif __name__ == '__main__':\n    main()",
    "complexity": "nlogn",
    "problem": "0022_A",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "t=int(input())\nfor i in range(t):\n    n,k=map(int,input().split())\n    if n>32:\n        print(\"YES\",n-1)\n    else:\n        max_splits=(4**n-1)//3\n        if k>max_splits or (n,k)==(2,3):\n            print(\"NO\")\n        else:\n            done=False\n            for i in range(n):\n                if k<2**(i+2)-i-3:\n                    print(\"YES\",n-i)\n                    done=True\n                    break\n            if not done:\n                print(\"YES\",0)",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "# problem: https://codeforces.com/contest/903/problem/D\n# idea: https://www.programmersought.com/article/86646430026/\n# import numpy as np\n\n\n# def almost_difference():\n#     n = int(input())\n#     if n == 1:\n#         return 0\n#     # n = 5\n#     # array = [1,2,3,1,3]\n#     # n = 4\n#     # array = [6,6,4,4]\n#     x = np.zeros(1000000)\n#     # int from 1... -> 10^9\n#     # normal array declaration took over 3s. so used array from numpy\n#     count_equal = np.zeros(10**9+1)\n#     array = [int(el) for el in input().split()]\n#     ad_sum = 0\n#     prev_sum = 0\n#     for i in range(n):\n#         # formula from the: https://www.programmersought.com/article/86646430026/\n#         ad_sum = ad_sum + i * array[i] - prev_sum +count_equal[array[i]+1] - count_equal[array[i]-1]\n#         count_equal[array[i]] += 1\n#         prev_sum += array[i]\n \n#     return ad_sum\n \n \n# print(almost_difference())\n\n\n\ndef almost_difference():\n    n = int(input())\n    if n == 1:\n        return 0\n    # n = 5\n    # array = [1,2,3,1,3]\n    # n = 4\n    # array = [6,6,4,4]\n    # x = np.zeros(1000000)\n    # int from 1... -> 10^9\n    # normal array declaration took over 3s. so used array from numpy\n    dict_equal = dict()\n    array = [int(el) for el in input().split()]\n    ad_sum = 0\n    prev_sum = 0\n    for i in range(n):\n        if not array[i] in dict_equal.keys():\n            dict_equal[array[i]] = 0\n        if not array[i]-1 in dict_equal.keys():\n            dict_equal[array[i]-1] = 0\n        if not array[i]+1 in dict_equal.keys():\n            dict_equal[array[i]+1] = 0\n\n        # formula from the: https://www.programmersought.com/article/86646430026/\n        ad_sum = ad_sum + i * array[i] - prev_sum +dict_equal[array[i]+1] - dict_equal[array[i]-1]\n        dict_equal[array[i]] += 1\n        prev_sum += array[i]\n \n    return ad_sum\n\nprint(almost_difference())\n",
    "complexity": "nlogn",
    "problem": "0903_D",
    "from": "CODEFORCES",
    "tags": "data structures,math"
}
{
    "src": "n=int(input())\na=list(map(int,input().split()))\np=0\nwhile p+1<len(a) and a[p]==a[p+1]:\n    p+=2\nc=0\nwhile p<len(a):\n    if p+1<len(a):\n        i=a.index(a[p],p+1)\n        c+=i-p-1\n        tmp=a.pop(i)\n        a.insert(p,tmp)\n    while p+1<len(a) and a[p]==a[p+1]:\n        p+=2\nprint(c)",
    "complexity": "quadratic",
    "problem": "0995_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n + 1) for _ in range(3024)]\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n    e[v][i] = i\n    d[i].append(i)\nfor v in range(1, 3024):\n    for i in range(n):\n        j = e[v][i]\n        h = e[v][j + 1] if j != -1 else -1\n        if j != -1 and h != -1:\n            e[v + 1][i] = h\n            d[i].append(h)\n\na = [_ for _ in range(1, n + 1)]\nfor s in range(n):\n    for e in d[s]:\n        a[e] = min(a[e], a[s - 1] + 1 if s > 0 else 1)\nprint(a[n - 1])\n",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import math\n#t=int(input())\n#for i in range(t):\nn,m = map(int, input().strip().split(' '))\n#lst = list(map(int, input().strip().split(' ')))\ns=input()\nt=input()\nif '*' not in s:\n    if s==t:\n        print('YES')\n    else:\n        print('NO')\nelif n>m+1:\n    print('NO')\nelif n==1 and s=='*':\n    print('YES')\nelse:\n    s=list(s)\n    t=list(t)\n    if s[0]=='*':\n        if s[1:]==t[-(len(s[1:])):]:\n            print('YES')\n        else:\n            print('NO')\n    elif s[-1]=='*':\n        if s[:n-1]==t[:n-1]:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        ind=s.index('*')\n        #print(ind)\n        #print(s[ind+1:])\n        #print(t[-len(s[ind+1:]):])\n        if s[:ind]==t[:ind] and s[ind+1:]==t[-len(s[ind+1:]):]:\n            print('YES')\n        else:\n            print('NO')\n        \n\n",
    "complexity": "linear",
    "problem": "1023_A",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,strings"
}
{
    "src": "i=int(input())\nd=i%2+8;print(d,i-d)",
    "complexity": "constant",
    "problem": "0472_A",
    "from": "CODEFORCES",
    "tags": "math,number theory"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n\nn,T=map(int,input().split())\nS=[list(map(int,input().split())) for i in range(n)]\n\nDP=[[0]*(4) for i in range(T+1)]\nmod=10**9+7\n\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef calc(used,recent,time):\n    ANS=0\n    for i in range(n):\n        #print(i,used)\n        if i in used:\n            continue\n        if time+S[i][0]>T:\n            continue\n        if S[i][1]==recent:\n            continue\n        if time+S[i][0]==T:\n            ANS+=1\n        if time+S[i][0]<T:\n            used2=list(used)+[i]\n            used2.sort()\n            recent2=S[i][1]\n            time2=time+S[i][0]\n            ANS=(ANS+calc(tuple(used2),recent2,time2))%mod\n\n    return ANS\n\nprint(calc(tuple(),-1,0)%mod)\n    \n",
    "complexity": "np",
    "problem": "1185_G1",
    "from": "CODEFORCES",
    "tags": "bitmasks,combinatorics,dp"
}
{
    "src": "n, m = map(int, input().split())\na = []\narray = []\nfor i in range(n):\n    a.append(list(map(str, input())))\n    listt = []\n    for c in range(m):\n        if a[i][c] == '#':\n            listt.append(1)\n        else:\n            listt.append(0)\n    array.append(listt)\nfor y in range(1, n - 1):\n    for x in range(1, m - 1):\n        f = a[y + 1][x] == '#' and a[y + 1][x + 1] == '#' and a[y + 1][x - 1] == '#'\n        s = a[y][x + 1] == '#' and a[y][x - 1] == '#'\n        th = a[y - 1][x] == '#' and a[y - 1][x + 1] == '#' and a[y - 1][x - 1] == '#'\n        if f and s and th:\n            array[y + 1][x] -= 1\n            array[y + 1][x + 1] -= 1\n            array[y + 1][x - 1] -= 1\n            array[y][x + 1] -= 1\n            array[y][x - 1] -= 1\n            array[y - 1][x - 1] -= 1\n            array[y - 1][x] -= 1\n            array[y - 1][x + 1] -= 1\nmb = True\nfor y in range(n):\n    for x in range(m):\n        if array[y][x] == 1:\n            mb = False\n            break\nif mb:\n    print(\"YES\")\nelse:\n    print(\"NO\")",
    "complexity": "quadratic",
    "problem": "1059_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "\n\n\nn = int(input())\nd={}\nfor _ in range(n):\n    a,b = map(int,input().split())\n    d[a] = b\n\ns=0\nm = int(input())\nfor _ in range(m):\n    x,y = map(int,input().split())\n\n    if x in d:\n        d[x] = max(d[x],y)\n\n    else:\n        d[x] = y\n\nfor i in d:\n\n    s+=d[i]\nprint(s)\n\n",
    "complexity": "nlogn",
    "problem": "0981_B",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "import sys\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nN, M, K = map(int, input().split())\nP = []\nD_P = {}\n\nfor i in range(N):\n\tS = input()\n\tP.append(S)\n\tD_P[S] = i\n\nadj = [[] for _ in range(N)]\nindeg = [0] * N\n\nfor _ in range(M):\n\tS, mt = input().split()\n\tmt = int(mt)-1\n\n\tfp = P[mt]\n\n\tif any(fp[i] not in (S[i], '_') for i in range(K)):\n\t\tprint('NO')\n\t\traise SystemExit\n\n\tfor bs in range(1<<K):\n\t\tpat = ''.join(S[i] if bs & (1<<i) == 0 else '_' for i in range(K))\n\t\tif pat == fp: continue\n\t\tif pat in D_P:\n\t\t\tj = D_P[pat]\n\t\t\tindeg[j] += 1\n\t\t\tadj[mt].append(j)\n\nQ = [i for i in range(N) if indeg[i] == 0]\nfor i in Q:\n\tfor j in adj[i]:\n\t\tindeg[j] -= 1\n\t\tif indeg[j] == 0:\n\t\t\tQ.append(j)\n\nif len(Q) == N:\n\tprint('YES')\n\tprint(' '.join(str(v+1) for v in Q))\nelse:\n\tprint('NO')\n",
    "complexity": "np",
    "problem": "1476_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"
}
{
    "src": "#########################################################################################################\\\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\nimport sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math \n\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):  \n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n    \"\"\"\n    L is a list.\n    The function returns the power set, but as a list of lists.\n    \"\"\"\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n    \n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n        \n    #the function could stop here closing with\n    #return powerset\n\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n        \n    return powerset_orderred\ndef fastPlrintNextLines(a):\n    # 12\n    # 3\n    # 1\n    #like this\n    #a is list of strings\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\n#__________________________TEMPLATE__________________OVER_______________________________________________________\n\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\") \n# else:\n#     input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nt = 1\n# t = int(input())\nfor _ in range(t):\n    n,k = li()\n    s = list(si())\n    cnt = 0\n    ans = []\n    covered = 0\n    for i in range(n):\n        if (s[i]=='('):\n            cnt+=1\n            ans.append('(')\n        else:\n            ans.append(')')\n            covered+=1\n        if cnt==k//2:\n            break\n    ans+=[')']*(k//2-covered)\n    print(''.join(ans))",
    "complexity": "linear",
    "problem": "1023_C",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "n = int(input())\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\nif (x2 < x1 and x3 < x1 or x2 > x1 and x3 > x1) and (y2 < y1 and y3 < y1 or y2 > y1 and y3 > y1):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
    "complexity": "constant",
    "problem": "1033_A",
    "from": "CODEFORCES",
    "tags": "dfs and similar,graphs,implementation"
}
{
    "src": "import sys\nimport math\nimport collections\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n,k=get_ints()\n    arr=get_list()\n    ans=0\n    for i in range(n):\n        val=arr[i]\n        c=1\n        sol=0\n        if c >= k:\n            sol = max(sol, val / c)\n        for j in range(i+1,n):\n            val+=arr[j]\n            c+=1\n            if c>=k:\n                sol=max(sol,val/c)\n        ans=max(sol,ans)\n    print(ans)",
    "complexity": "quadratic",
    "problem": "1003_C",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,math"
}
{
    "src": "n=int(input())\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\nif l[0]!=0 or r[n-1]!=0:\n    print(\"NO\")\n    exit(0)\ns=[(l[i]+r[i]) for i in range(n)]\nm=max(s)+1\nk=[]\nfor i in s:\n    k.append(m-i)\nl1=[]\nr1=[]\n\nfor i in range(n):\n    c=0\n    d=0\n    for j in range(0,i):\n        if k[j]>k[i]:\n            c+=1\n    l1.append(c)\n    for j in range(i+1,n):\n        if k[j]>k[i]:\n            d+=1\n    r1.append(d)\nif l1!=l or r1!=r:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*k)\n        \n    \n    \n\n    ",
    "complexity": "quadratic",
    "problem": "1054_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation"
}
{
    "src": "import sys\n\n\nclass fenwick():\n    \"\"\"\n    This Tree Data Structure speeds up caliculating summations of partial sum \n    and also updating subsets of sequences. Both queries finish in logarithmic times.\n    \"\"\"\n    # 1-indexed\n\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+1)\n\n    def to_sum(self, i):\n        # return sigma(a_j) (0<=j<=i)\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, x):\n        #a_i -> a_i + x\n        while i <= self.n:\n            self.data[i] += x\n            i += (i & -i)\n\n    def get(self, i, j):\n        # return sigma(a_k) (i<=k<=j)\n        # assert 1<=i<=j<= N\n        return self.to_sum(j)-self.to_sum(i-1)\n\n\ndef input():\n    return sys.stdin.buffer.readline()\n\n\nn = int(input())\npermutation = list(map(int, input().split()))\nseq = [(permutation[i], i + 1) for i in range(n)]\nseq.sort(reverse=True)\n\nm = int(input())\nquery = [tuple(map(int, input().split())) for i in range(m)]\n\n#count whole inversion\n\nWHOLE_INVERSION = 0\nfenwick_1 = fenwick(n)\n\nfor value, index in seq:\n    WHOLE_INVERSION += fenwick_1.get(1, index)\n    fenwick_1.add(index, 1)\n\nfor l, r in query:\n    d = r - l + 1\n    WHOLE_INVERSION += d*(d-1)//2\n    if WHOLE_INVERSION % 2 != 0:\n        print(\"odd\")\n    else:\n        print(\"even\")\n\n",
    "complexity": "quadratic",
    "problem": "0911_D",
    "from": "CODEFORCES",
    "tags": "brute force,math"
}
{
    "src": "import math\nsone= list(input())\nstwo = list(input())\nsum1=0\nsum2=0\nm=0\nfor i in range(len(sone)):\n    if sone[i]=='+':\n        sum1=sum1 + 1\n        m=m+1\n    else:\n        sum1=sum1 - 1\nk=0        \nfor i in range(len(stwo)):\n    if stwo[i]=='+':\n        sum2=sum2 + 1\n        k=k\n    elif stwo[i]=='-':\n        sum2=sum2 - 1\n        k=k\n    elif stwo[i]=='?':\n        k=k+1\nn=0\nif (k-(abs(sum1-sum2)))<0:\n    print(float (0))\nelif (k-(abs(sum1-sum2)))==0:\n    if k==0:\n        print(float (1))\n    else:\n        print(float (pow(0.5,k)))\n             \nelse:\n    n=k-(abs(sum1-sum2))\n    n=abs(sum1-sum2)+n/2\n    if abs(sum1-sum2)==0:\n        print(float ((math.factorial(k)/(math.factorial(k/2)*math.factorial(k/2))) * pow(0.5,k)))\n    else:\n        print(float ((math.factorial(k)/(math.factorial(k-n) * math.factorial(n))) * pow(0.5,k)))",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "from sys import stdin\ninput = stdin.buffer.readline\n    \nn=int(input())\narr=[int(x) for x in input().split()]\n\narr.sort()\ns=set(arr)\nflag=False\nfor ele in arr:\n    for i in range(31):\n        if ((ele-2**i) in s) and ((ele+2**i) in s):\n            ans=[ele,ele-2**i,ele+2**i]\n            flag=True\n            break\n    if flag:\n        break\nif flag:\n    print(3) \n    print(*ans)    \n    exit()\nfor ele in arr:\n    for i in range(31):\n        if (ele+2**i) in s:\n            ans=[ele,ele+2**i]\n            flag=True\n            break\n    if flag:\n        break\nif flag:\n    print(2)\n    print(*ans)\nelse:\n    print(1)\n    print(arr[0])",
    "complexity": "nlogn",
    "problem": "0988_D",
    "from": "CODEFORCES",
    "tags": "brute force,math"
}
{
    "src": "l,r=tuple(map(int,input().split(\" \")))\nx=l^r\npow=1\nwhile(pow<=x) :\n    pow*=2\n    \nprint(pow-1)",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "n = int(input())\nm = int(input())\nif(n<=26):\n    print(m%(2**n))\nelse:\n    print(m)\n    ",
    "complexity": "constant",
    "problem": "0913_A",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "n,l,r,x = [int(x) for x in input().split(\" \")]\narr = [int(x) for x in input().split(\" \")]\nans = 0\nfor i in range(2**n):\n\tsubset = [] \n\tfor j in range(n): \n\t\tif (i & (1 << j)) != 0: \n\t\t\tsubset.append(arr[j])\n\tif len(subset)>1:\n\t    mx = max(subset)\n\t    mn = min(subset)\n\t    sm = sum(subset)\n\t    if l<=sm<=r and mx-mn>=x:\n\t        ans+=1\nprint(ans)",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "k = int(input())\ns = k\ni = 1\nnumber_digits = 1\nwhile s - (i * (9 * 10 ** (i - 1))) > 0:\n    number_digits = number_digits + 1\n    s = s - (i * (9 * 10 ** (i - 1)))\n    i += 1\nv = (s - 1) // number_digits\ns = s - v * number_digits\nans = 10 ** (number_digits - 1) + v\nans = str(ans)\nfans = ans[s - 1]\nprint(fans)\n",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "n,m,k=list(map(int,input().split()))\np=[]\nfor _ in range(n):\n    p.append(list(map(int,input().split())))\nq=[]\nfor _ in range(n-1):\n    q.append(list(map(int,input().split())))\ndef f(g):\n    r=[[0]*m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            l=[]\n            if i-1>=0:\n                l.append(g[i-1][j]+q[i-1][j])\n            if i+1<n:\n                #print(i,j)\n                l.append(g[i+1][j]+q[i][j])\n            if j-1>=0:\n                l.append(g[i][j-1]+p[i][j-1])\n            if j+1<m:\n                l.append(g[i][j+1]+p[i][j])\n            r[i][j]=min(l)\n    return r\ng=[[0]*m for _ in range(n)]\nif k%2!=0:\n    for i in range(n):\n        for j in range(m):\n            g[i][j]=-1\n        print(*g[i])\nelse:\n    for _ in range(k//2):\n       g=f(g)\n    for i in range(n):\n        for j in range(m):\n            g[i][j]*=2\n        print(*g[i])\n        ",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "r, g, b = map(int, input().split())\nR = list(map(int, input().split()))\nG = list(map(int, input().split()))\nB = list(map(int, input().split()))\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\n\nmemo = [[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]\n\ndef calc(ir, ig, ib):\n    if memo[ir][ig][ib] != -1:\n        return memo[ir][ig][ib]\n    ans = 0\n    if ir < r and ig < g:\n        ans = max(ans, calc(ir+1, ig+1, ib)+R[ir]*G[ig])\n    if ir < r and ib < b:\n        ans = max(ans, calc(ir+1, ig, ib+1)+R[ir]*B[ib])\n    if ig < g and ib < b:\n        ans = max(ans, calc(ir, ig+1, ib+1)+G[ig]*B[ib])\n    memo[ir][ig][ib] = ans\n    return ans\n\nprint(calc(0, 0, 0))\n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "candies = 0\nn, k = map(int,input().split())\nsumm = 0\nif k == 0:\n    for i in range (n-1,-1,-1):\n        summ = summ + 1\n        candies = candies + summ\n        if candies == i:\n            print(i)\n            break\n\nif k != 0:\n    for i in range (n-1,-1,-1):\n        summ = summ + 1\n        candies = candies + summ\n        if candies - i == k:\n            print(i)\n            break\n  \t\t\t \t\t \t\t\t \t \t\t\t\t\t\t  \t  \t\t\t",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "print(25)",
    "complexity": "constant",
    "problem": "0630_A",
    "from": "CODEFORCES",
    "tags": "number theory"
}
{
    "src": "n, m = map(int, input().split())\nu = []\nu1 = []\nfor i in range(n):\n    u.append(list(input()))\n    u1.append(['.'] * m)\nfor i in range(n - 2):\n    for j in range(m - 2):\n        ok = True\n        for k in range(3):\n            if u[i][j + k] != '#' or u[i + k][j] != '#':\n                ok = False\n                break\n##        print(ok)\n        if ok:\n            if u[i + 2][j + 1] != '#' or u[i + 2][j + 2] != '#' or u[i + 1][j + 2] != '#':\n                ok = False\n            else:\n                for k in range(3):\n                    u1[i][j + k] = '#'\n                    u1[i + k][j] = '#'\n                u1[i + 2][j + 1] = '#'  \n                u1[i + 2][j + 2] = '#'\n                u1[i + 1][j + 2] = '#'\nok = True\n##for i in u:\n##    print(i)\n##for i in u1:\n##    print(i)\nfor i in range(n):\n    for j in range(m):\n        if u[i][j] != u1[i][j]:\n            ok = False\n            break\n    if not ok:\n        break\nif ok:\n    print('YES')\nelse:\n    print('NO')\n",
    "complexity": "quadratic",
    "problem": "1059_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "from sys import stdin, stdout, exit\n\nn, m, k = map(int, stdin.readline().split())\na = list(map(int, stdin.readline().split()))\n\ndef bf(a):\n    best = 0\n    best_arg = (-1, -1)\n    for i in range(n):\n        for j in range(i, n):\n            cur = sum(a[i:j+1]) - k*((j - i) // m + 1)\n            if cur > best:\n                best = max(best, cur)\n                best_arg = (i,j)\n    return best, best_arg\n\ndef max_sum(a):\n    if len(a) == 0:\n        return 0\n    elif len(a) == 1:\n        return max(0, a[0] - k)\n    mid = len(a) // 2\n    l_rec = max_sum(a[:mid])\n    r_rec = max_sum(a[mid:])\n    l_bests = [0]*m\n    r_bests = [0]*m\n    l_sum = 0\n    for idx in range(1,mid+1):\n        l_sum += a[mid-idx]\n        if idx % m == 0:\n            l_sum -= k\n        l_bests[idx%m] = max(l_bests[idx%m], l_sum)\n    r_sum = 0\n    for idx in range(0, len(a)-mid):\n        r_sum += a[idx+mid]\n        if (idx+1) % m == 0:\n            r_sum -= k\n        r_bests[(idx+1)%m] = max(r_bests[(idx+1)%m], r_sum)\n\n #   print(\"Array:\", a, \"mid:\", mid)\n#    print(l_bests)\n  #  print(r_bests)\n    best_acr = 0\n    for i in range(m):\n        for j in range(m):\n            best_acr = max(best_acr, l_bests[i] + r_bests[j] - (k if i+j>0 else 0) - (k if i+j>m else 0))\n    ans = max(l_rec,r_rec, best_acr)\n   # print(\"Answer:\", ans)\n    return ans\n\n\nans = max_sum(a)\nstdout.write(str(ans) + \"\\n\")\n#stdout.write(str(bf(a))+\"\\n\")\n",
    "complexity": "quadratic",
    "problem": "1197_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,math"
}
{
    "src": "import sys,os,io\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import defaultdict\n\nn,m = [int(i) for i in input().split()]\na = []\nmi = -1\nma = 10**9\nfor i in range (n):\n    a.append([int(j) for j in input().split()])\n\nans = []\nwhile(mi<ma):\n    mid = (mi+ma+1)//2\n    masks = {}\n    for i in range (n):\n        currMask = 0\n        for j in range (m):\n            if a[i][j] >= mid:\n                currMask +=  1<<j\n        masks[currMask] = i\n    req = (1<<m) - 1\n    possible = 0\n    for i in masks:\n        for j in masks:\n            if i|j == req:\n                possible = 1\n                ans = [masks[i]+1,masks[j]+1]\n                break\n        if possible:\n            break\n    if possible:\n        mi = mid\n    else:\n        ma = mid - 1\nprint(*ans)",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "import math\nn=int(input())\nlst = list(map(int, input().strip().split(' ')))\n#n,r = map(int, input().strip().split(' '))\np=max(lst)\nind=lst.index(p)\nif p==1:\n    lst[ind]=2\nelse:\n    lst[ind]=1\nlst.sort()\nfor j in range(n):\n    print(lst[j],end=\" \")",
    "complexity": "nlogn",
    "problem": "0135_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "a, b = map(int, input().split())\nc = input()\nsu = 0\ncnt = 0\nj = -2\ni = 0\nlis = \"abcdefghijklmnopqrstuvwxyz\"\nwhile i < 26 and cnt < b:\n    if lis[i] in c and i-2 >= j:\n        su += i+1\n        cnt += 1\n        j = i\n    i += 1\nif cnt < b:\n    print(-1)\nelse:\n    print(su)\n    \t  \t\t\t \t\t \t \t\t \t \t\t\t \t\t\t",
    "complexity": "linear",
    "problem": "1011_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "n, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\n\nfrom itertools import combinations\nways_to_choose = 0\nfor length in range(2, n + 1):\n    for p in combinations(c, length):\n        problemset = sorted(p)\n        if l <= sum(problemset) <= r and problemset[-1] - problemset[0] >= x:\n            ways_to_choose += 1\n\nprint(ways_to_choose)\n",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport itertools\nimport bisect\nimport heapq\nsys.setrecursionlimit(100000)\n#^^^TAKE CARE FOR MEMORY LIMIT^^^\ndef main():\n    pass\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\n\ndef decimal(s):\n    return (int(s, 2))\n\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n //= 2\n        p += 1\n    return (p)\n\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\n\ndef countcon(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if (s[i] == ch):\n            c += 1\n        else:\n            break\n    return (c)\n\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\ndef isSubSequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\ndef maxfac(n):\n    root = int(n ** 0.5)\n    for i in range(2, root + 1):\n        if (n % i == 0):\n            return (n // i)\n    return (n)\ndef p2(n):\n    c=0\n    while(n%2==0):\n        n//=2\n        c+=1\n    return c\ndef seive(n):\n    primes=[True]*(n+1)\n    primes[1]=primes[0]=False\n    for i in range(2,n+1):\n        if(primes[i]):\n            for j in range(i+i,n+1,i):\n                primes[j]=False\n    p=[]\n    for i in range(0,n+1):\n        if(primes[i]):\n            p.append(i)\n    return(p)\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n            p - 2, p)) % p\ndef denofactinverse(n,m):\n    fac=1\n    for i in range(1,n+1):\n        fac=(fac*i)%m\n    return (pow(fac,m-2,m))\ndef numofact(n,m):\n    fac=1\n    for i in range(1,n+1):\n        fac=(fac*i)%m\n    return(fac)\ndef sod(n):\n    s=0\n    while(n>0):\n        s+=n%10\n        n//=10\n    return s\ndef getVal(x,y,sx,sy):\n    #print(x,y,sx,sy)\n    if (x == -1 or y == -1 or x == n or y == m):\n        return inF\n    elif(sx==x):\n        return hor[sx][min(sy,y)]\n    else:\n        return ver[min(sx,x)][sy]\ndef rec(k,x,y):\n    if(x==-1 or y==-1 or x>=n or y>=m):\n        return inF\n    elif (k == 0):\n        #print(x,y)\n        dp[k][x][y] = 0\n        return dp[k][x][y]\n    elif(dp[k][x][y]!=-1):\n        return dp[k][x][y]\n    else:\n        #print(getVal(x-1,y,x,y))\n        val1=rec(k-1,x-1,y)+getVal(x-1,y,x,y)\n        val2=rec(k-1,x+1,y)+getVal(x+1,y,x,y)\n        val3=rec(k-1,x,y+1)+getVal(x,y+1,x,y)\n        val4=rec(k-1,x,y-1)+getVal(x,y-1,x,y)\n        dp[k][x][y]=min(val1,val2,val3,val4)\n        return dp[k][x][y]\nn,m,k=map(int,input().split())\nadj=[[-1]*n for i in range(0,m)]\nif(k%2):\n    for i in range(0, n):\n        for j in range(0, m):\n            print(-1, end=\" \")\n        print(\"\")\nelse:\n    hor,ver=[],[]\n    inF=10**20\n    k//=2\n    for i in range(0,n):\n        hor.append(list(map(int,input().split())))\n    for i in range(0,n-1):\n        ver.append(list(map(int,input().split())))\n    dp=[[[-1]*(m+1) for i in range(0,n+1)]for j in range(0,k+1)]\n    for i in range(0,n):\n        for j in range(0,m):\n            print(2*rec(k,i,j),end=\" \")\n        print(\"\")\n    '''\n    print(\"\\n\",getVal(0,0,0,1))\n    print(\"\\n\\n\\n\\n\\n\")\n    for k in range(0,k+1):\n        print(\"page\",k)\n        for i in range(0,n):\n            for j in range(0,m):\n                print(dp[k][i][j],end=\" \")\n            print(\"\")\n    '''\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "from collections import Counter\n\ndef f(x):\n    return max(list(Counter(x).values()))\n\nn=int(input())\nz=input()\nl=len(z)\na=f(z)\nb=f(input())\nc=f(input())\n\ndef v(x):\n    if x==l:\n        return x-1\n    else:\n        return x+1\n\nif n==1:\n    a, b, c=v(a), v(b), v(c)\n    if a>b and a>c:\n        print(\"Kuro\")\n    elif b>a and b>c:\n        print(\"Shiro\")\n    elif c>a and c>b:\n        print(\"Katie\")\n    else:\n        print(\"Draw\")\nelif (l-a<=n)+(l-b<=n)+(l-c<=n)>=2:\n    print(\"Draw\")\nelif a>b and a>c:\n    print(\"Kuro\")\nelif b>a and b>c:\n    print(\"Shiro\")\nelif c>a and c>b:\n    print(\"Katie\")\nelse:\n    print(\"Draw\")\n#print((l-a<=n)+(l-b<=n)+(l-c<=n))\n#print(a, b, c)",
    "complexity": "linear",
    "problem": "0979_B",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "ch_0={0:[0,1,2],2:[2],1:[1],3:[1,2,3]}\nch_1={0:[3],3:[0],1:[0,3],2:[0,3]}\nch_2={0:[],3:[],2:[1],1:[2]}\nN=998244353\nn,k=map(int,input().strip().split(\" \"))\ndp=[[[0]*4 for j in range(k+5)] for i in range(n+5)]\ndp[0][1][3]=1\ndp[0][1][0]=1\ndp[0][2][1]=1\ndp[0][2][2]=1\n\nfor i in range(1,n):\n    for j in range(1,k+1):\n        for mask in range(4):\n            for t in ch_0[mask]:\n                dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j][t])%N\n            if j>1:\n                for t in ch_1[mask]:\n                    dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-1][t])%N\n                if j>2:\n                    for t in ch_2[mask]:\n                        dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-2][t])%N\nans=0\nfor mask in range(4):\n    ans=(ans+dp[n-1][k][mask])%N\nprint(ans)\n",
    "complexity": "np",
    "problem": "1051_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "\ndef maxXORInRange(L, R): \n\n\tLXR = L ^ R \n\tmsbPos = 0\n\twhile(LXR): \n\t\n\t\tmsbPos += 1\n\t\tLXR >>= 1\n\tmaxXOR, two = 0, 1\n\t\n\twhile (msbPos): \n\t\n\t\tmaxXOR += two \n\t\ttwo <<= 1\n\t\tmsbPos -= 1\n\n\treturn maxXOR \n\nL, R = [int(i) for i in input().split()]\nprint(maxXORInRange(L, R)) \n\n",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "def f(n,s):\n    d=[-n,-n];\n    d[s]=0;\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)];\n    return d[s];\nimport math;\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny=y+x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))",
    "complexity": "np",
    "problem": "1463_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,math"
}
{
    "src": "import io,os,bisect;input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline;prime = [2]\nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue \n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0: flag = True;break\n    if not flag:  prime.append(i)\ndef primefactor(num):\n    index = 0;output = []\n    while num>=prime[index]**2:\n        times = 0\n        while num%prime[index]==0:num = num // prime[index];times += 1\n        if times&1:  output.append(prime[index])\n        index += 1 \n    if num>1: output.append(num)\n    return tuple(output)\nfor _ in range(int(input())):\n    n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:            bisect.insort(stack,fact[factor]+1)            \n        fact[factor] = i\n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1)\n    print(dp[-1][-1])   ",
    "complexity": "cubic",
    "problem": "1497_E2",
    "from": "CODEFORCES",
    "tags": "data structures,dp,greedy,math,number theory,two pointers"
}
{
    "src": "from sys import stdin, stdout\nn=int(input())\ns=list(map(int,stdin.readline().strip().split()))\ndp=[[-1 for i in range(n+1)]for j in range(n+1)]\nfor i in range(n):\n    dp[0][i]=s[i]\nfor i in range(1,n):\n    for j in range(n-i):\n        dp[i][j]=dp[i-1][j]^dp[i-1][j+1]\nfor i in range(1,n):\n    for j in range(n-i):\n        dp[i][j]=max(dp[i-1][j],dp[i-1][j+1],dp[i][j])\nq=int(input())\nans=\"\"\nfor i in range(q):\n    l,r=map(int,stdin.readline().strip().split())\n    print(dp[r-l][l-1])\n",
    "complexity": "quadratic",
    "problem": "0983_B",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "# A. Find Square\n\nn, m = map(int, input().split())\n\ntop = [-1, -1]\nbottom = [-1, -1]\n\nmatrix = list()\nfor i in range(n):\n    s = input()\n    matrix.append(s)\n\nfor i in range(n):\n    left = matrix[i].find('B')\n    if left != -1:\n        top[0] = i\n        top[1] = left\n        break\n\nfor i in range(n-1, -1, -1):\n    right = matrix[i].rfind('B')\n    if right != -1:\n        bottom[0] = i\n        bottom[1] = right\n        break\n\nprint(1 + top[0] + (bottom[0] - top[0]) // 2, 1 + top[1] + (bottom[1] - top[1]) // 2)\n",
    "complexity": "quadratic",
    "problem": "1028_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "def search(arr,power):\n    lo=0\n    hi=len(arr)-1\n    ans=-1\n    while lo<=hi:\n        mid=(lo+hi)//2\n        if arr[mid]<=power:\n            ans=mid\n            lo=mid+1\n        else:\n            hi=mid-1\n    return ans\n\nn,q = list(map(int, input().split()))\na = list(map(int, input().split()))\nk = list(map(int, input().split()))\nfor i in range(1,n):\n    a[i]+=a[i-1]\npower = 0\nfor i in range(q):\n    power+=k[i]\n    pos = search(a,power)\n    if pos==n-1:\n        print(n)\n        power=0\n    elif pos==-1:\n        print(n)\n    else:\n        print(n-pos-1)",
    "complexity": "nlogn",
    "problem": "0975_C",
    "from": "CODEFORCES",
    "tags": "binary search"
}
{
    "src": "\nfrom bisect import bisect,bisect_left\n\nfrom collections import *\nfrom heapq import *\nfrom math import gcd,ceil,sqrt,floor,inf\n\nfrom itertools import *\nfrom operator import add,mul,sub,xor,truediv,floordiv\nfrom functools import *\n\n#------------------------------------------------------------------------\nimport os\nimport sys\n\nfrom io import BytesIO, IOBase\n# region fastio\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n\n#------------------------------------------------------------------------\ndef RL(): return map(int, sys.stdin.readline().split())\ndef RLL(): return list(map(int, sys.stdin.readline().split()))\ndef N(): return int(input())\ndef A(n):return [0]*n\ndef AI(n,x): return [x]*n\ndef A2(n,m): return [[0]*m for i in range(n)]\ndef G(n): return [[] for i in range(n)]\ndef GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]\n#------------------------------------------------------------------------\n\n\nfrom types import GeneratorType\n \n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n \n    return wrappedfunc\n\nmod=10**9+7\nfarr=[1]\nifa=[]\n \ndef fact(x,mod=0):\n    if mod:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr)%mod)\n    else:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr))\n    return farr[x]\n \ndef ifact(x,mod):\n    global ifa\n    fact(x,mod)\n    ifa.append(pow(farr[-1],mod-2,mod))\n    for i in range(x,0,-1):\n        ifa.append(ifa[-1]*i%mod)\n    ifa.reverse()\n \ndef per(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return fact(i)//fact(i-j)\n    return farr[i]*ifa[i-j]%mod\n    \ndef com(i,j,mod=0):\n    if i<j: return 0\n    if not mod:        \n        return per(i,j)//fact(j)\n    return per(i,j,mod)*ifa[j]%mod\n \ndef catalan(n):\n    return com(2*n,n)//(n+1)\n \ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef floorsum(a,b,c,n):#sum((a*i+b)//c for i in range(n+1))\n    if a==0:return b//c*(n+1)\n    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2\n    m=(a*n+b)//c\n    return n*m-floorsum(c,c-b-1,a,m-1)\n\ndef inverse(a,m):\n    a%=m\n    if a<=1: return a\n    return ((1-inverse(m,a)*m)//a)%m\n \ndef lowbit(n):\n    return n&-n\n \nclass BIT:\n    def __init__(self,arr):\n        self.arr=arr\n        self.n=len(arr)-1\n        \n    def update(self,x,v):\n        while x<=self.n:\n            self.arr[x]+=v\n            x+=x&-x\n \n    def query(self,x):\n        ans=0\n        while x:\n            ans+=self.arr[x]\n            x&=x-1\n        return ans\n\nclass ST:\n    def __init__(self,arr):#n!=0\n        n=len(arr)\n        mx=n.bit_length()#\u53d6\u4e0d\u5230\n        self.st=[[0]*mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0]=arr[i]\n        for j in range(1,mx):\n            for i in range(n-(1<<j)+1):\n                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])\n    def query(self,l,r):\n        if l>r:return -inf\n        s=(r+1-l).bit_length()-1\n        return max(self.st[l][s],self.st[r-(1<<s)+1][s])\n        \nclass DSU:#\u5bb9\u91cf+\u8def\u5f84\u538b\u7f29\n    def __init__(self,n):\n        self.c=[-1]*n\n \n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n \n    def find(self,x):\n        if self.c[x]<0:\n            return x\n        self.c[x]=self.find(self.c[x])\n        return self.c[x]\n \n    def union(self,u,v):\n        u,v=self.find(u),self.find(v)\n        if u==v:\n            return False\n        if self.c[u]>self.c[v]:\n            u,v=v,u\n        self.c[u]+=self.c[v]\n        self.c[v]=u\n        return True\n \n    def size(self,x): return -self.c[self.find(x)]\n    \nclass UFS:#\u79e9+\u8def\u5f84\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n \n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n\nclass UF:#\u79e9+\u8def\u5f84+\u5bb9\u91cf\uff0c\u8fb9\u6570\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n        self.size=AI(n,1)\n        self.edge=A(n)\n \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n \n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            self.edge[pu]+=1\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            self.edge[pu]+=self.edge[pv]+1\n            self.size[pu]+=self.size[pv]\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n            self.edge[pv]+=self.edge[pu]+1\n            self.size[pv]+=self.size[pu]\n \ndef Prime(n):\n    c=0\n    prime=[]\n    flag=[0]*(n+1) \n    for i in range(2,n+1):\n        if not flag[i]:\n            prime.append(i)\n            c+=1\n        for j in range(c):\n            if i*prime[j]>n: break\n            flag[i*prime[j]]=prime[j]\n            if i%prime[j]==0: break\n    return flag\n \ndef dij(s,graph):\n    d=AI(n,inf)\n    d[s]=0\n    heap=[(0,s)]\n    vis=A(n)\n    while heap:\n        dis,u=heappop(heap)\n        if vis[u]:\n            continue\n        vis[u]=1\n        for v,w in graph[u]:\n            if d[v]>d[u]+w:\n                d[v]=d[u]+w\n                heappush(heap,(d[v],v))\n    return d\n\ndef bell(s,g):#bellman-Ford\n    dis=AI(n,inf)\n    dis[s]=0\n    for i in range(n-1):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n    change=A(n)\n    for i in range(n):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n                change[v]=1\n    return dis\n\ndef lcm(a,b): return a*b//gcd(a,b)\ndef lis(nums):\n    res=[]\n    for k in nums:\n        i=bisect.bisect_left(res,k)\n        if i==len(res):\n            res.append(k)\n        else:\n            res[i]=k\n    return len(res)\n\ndef RP(nums):#\u9006\u5e8f\u5bf9\n    n = len(nums)\n    s=set(nums)\n    d={}\n    for i,k in enumerate(sorted(s),1):\n        d[k]=i\n    bi=BIT([0]*(len(s)+1))\n    ans=0\n    for i in range(n-1,-1,-1):\n        ans+=bi.query(d[nums[i]]-1)\n        bi.update(d[nums[i]],1)\n    return ans\n \nclass DLN:\n    def __init__(self,val):\n        self.val=val\n        self.pre=None\n        self.next=None\n\ndef nb(i,j,n,m):\n    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:\n        if 0<=ni<n and 0<=nj<m:\n            yield ni,nj\n\ndef topo(n):\n    q=deque()\n    res=[]\n    for i in range(1,n+1):\n        if ind[i]==0:\n            q.append(i)\n            res.append(i)\n    while q:\n        u=q.popleft()\n        for v in g[u]:\n            ind[v]-=1\n            if ind[v]==0:\n                q.append(v)\n                res.append(v)\n    return res\n\n@bootstrap\ndef gdfs(r,p):\n    for ch in g[r]:\n        if ch!=p:\n            yield gdfs(ch,r)\n    yield None\n\n        \n#from random import randint\n'''\ndef f(n):\n    s=set()\n    for order in permutations(range(n)):\n        res=A(n)\n        cur=[]\n        for i in order:\n            if res[i]==0:\n                res[i]=1\n                if i>=2 and res[i-2]==1 and res[i-1]==0:\n                    res[i-1]=1\n                if i<n-2 and res[i+2]==1 and res[i+1]==0:\n                    res[i+1]=1\n                cur.append(i)\n        s.add(tuple(cur))\n    print(len(s))\n    for x in s:\n        print(x)\n    #print(s)'''\n\nt=1\nfor i in range(t):\n    n,mod=RL()\n    #f(n)\n    ma=(n+1)//2\n    ifact(n,mod)\n    dp=A2(n+1,ma+1)\n    f=A(n+1)\n    f[1]=1\n    f[2]=2\n    f[3]=4\n    for i in range(4,n+1):\n        f[i]=f[i-1]*2%mod\n    dp[1][1]=1\n    dp[2][1]=2\n    dp[3][1]=4\n    dp[3][2]=2\n    for i in range(4,n+1):\n        dp[i][1]=f[i]\n        for k in range(2,(i+1)//2+1):\n            for x in range(1,i-2*k+3):\n                #print(k,x)\n                dp[i][k]+=dp[i-x-1][k-1]*f[x]%mod*ifa[x]%mod*fact(i-k+1,mod)%mod*ifa[i-k-x+1]%mod\n                dp[i][k]%=mod\n    ans=0\n    for k in range(1,ma+1):\n        ans=(ans+dp[n][k])%mod\n    print(ans)\n   \n\n        \n\n\n\n                 \n    \n    \n''' \nsys.setrecursionlimit(200000)\nimport threading\nthreading.stack_size(10**8)\nt=threading.Thr\nead(target=main)\nt.start()\nt.join()\n'''\n\n",
    "complexity": "cubic",
    "problem": "1515_E",
    "from": "CODEFORCES",
    "tags": "combinatorics,dp,math"
}
{
    "src": "# https://codeforces.com/problemset/problem/909/D\ndef process(a):\n    assert len(a) >= 2\n    \n    n    = len(a)\n    min_ = float('inf')\n\n    for i, [cnt, c] in enumerate(a):\n        if i == 0 or i == n-1:\n            min_ = min(min_, cnt)\n        else:\n            min_ = min(min_, (cnt+1) //2) \n    \n    b    = []\n    for i, [cnt, c] in enumerate(a):\n        if i == 0 or i == n-1:\n            remain = cnt - min_\n        else:\n            remain = cnt - min_ * 2\n        \n        if remain <= 0:\n            continue\n        \n        if len(b) == 0 or c != b[-1][1]:\n            b.append([remain, c])\n        else:\n            pre_cnt, pre_c  = b.pop()\n            b.append([pre_cnt+remain, c])\n    \n    return b, min_        \n\nS   = input() + ' '\ncur = []\n\ncnt = 0\npre = ''\nfor x in S:\n    if cnt == 0:\n        cnt+= 1\n        pre = x\n    elif x!=pre:\n        cur.append([cnt, pre])\n        cnt = 1\n        pre = x\n    else:\n        cnt+=1\n\ncnt = 0\nwhile len(cur) not in [0, 1]: \n    cur, min_ = process(cur)\n    cnt+=min_\n    \nprint(cnt)    ",
    "complexity": "linear",
    "problem": "0909_D",
    "from": "CODEFORCES",
    "tags": "data structures,greedy,implementation"
}
{
    "src": "import sys\nimport math\nimport itertools\nimport functools\nimport collections\nimport operator\nimport fileinput\nimport copy\n\n\nORDA = 97\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef revn(n): return str(n)[::-1]\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\ndef divs(n, start=2):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    return r\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\ndef prime(n):\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    return True\ndef convn(number, base):\n    newnumber = 0\n    while number > 0:\n        newnumber += number % base\n        number //= base\n    return newnumber\ndef cdiv(n, k): return n // k + (n % k != 0)\n\n\ns = input()\nlens = len(s)\nmax_ = 0\nfor i in range(1, lens):\n    d = {}\n    for j in range(lens - i + 1):\n        if s[j: j + i] in d:\n            d[s[j: j + i]] += 1\n        else:\n            d[s[j: j + i]] = 1\n    maxd = max(d.values())\n    if max(d.values()) > 1:\n        max_ = i\nprint(max_)\n",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "import sys\nif locals()['__file__'][-2:] == 'py':\n    sys.stdin = open('in.txt', 'r')\nn = int(input())\na = []\nfor i in range(1, n + 1):\n    l, r = map(int, input().split())\n    a.append([l, -r, i])\na.sort()\nma = a[0][1]\nnma = a[0][2]\nfor i in range(1, n):\n    if a[i][1] >= ma:\n        print(a[i][2], nma)\n        exit()\n    else:\n        ma = a[i][1]\n        nma = a[i][2]\nprint(-1, -1)\n",
    "complexity": "nlogn",
    "problem": "0976_C",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "n=int(raw_input())\n\nl=list(map(int,raw_input().split()))\n\nindex = []\nans=[]\nfor i in range(n):\n\tindex.append(i+1)\n\tans.append(0)\n\nl1,index1 = zip(*sorted(zip(l, index),reverse=True))\n#print('l1',l1)\n#print('index1',index1)\nfor i in range(n):\n\t#print(\"i\",i)\n\tk=1\n\tflag=False\n\twhile (index1[i]-k*l1[i])>0:\n\t\tif l[index1[i]-k*l1[i]-1]>l[index1[i]-1]:\n\t\t\tif ans[index1[i]-k*l1[i]-1]==\"B\":\n\t\t\t\tans[index1[i]-1]=\"A\"\n\t\t\t\tflag=True\n\t\t\t\tbreak\n\t\tk+=1\n\n\tk=1\n\tif flag==False:\n\t\twhile (index1[i]+k*l1[i])<=n:\n\t\t\tif l[index1[i]+k*l1[i]-1]>l[index1[i]-1]:\n\t\t\t\tif ans[index1[i]+k*l1[i]-1]==\"B\":\n\t\t\t\t\tans[index1[i]-1]=\"A\"\n\t\t\t\t\tflag=True\n\t\t\t\t\tbreak\n\t\t\tk+=1\n\n\n\tif flag==False:\n\t\tans[index1[i]-1]=\"B\"\n\nprint(''.join(ans))\n\n\n",
    "complexity": "nlogn",
    "problem": "1033_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,games"
}
{
    "src": "n, l, r, x = map(int, input().split())\narr = list(map(int, input().split()))\nres = 0\nfor j in range(1, 2**n):\n    a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)]\n    res += (max(a) - min(a) >= x and sum(a) >= l and sum(a) <= r)\nprint(res)\n",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "t = int(input())\nans = ''\nfor j in range(t):\n    ab = input().split()\n    a = int(ab[0])\n    b = int(ab[1])\n    k = 0\n    while a > 0 and b > 0:\n        if a >= b:\n            k += a // b\n            a %= b\n        else:\n            k += (b // a)\n            b %= a\n    ans += str(k) + '\\n'\nprint(ans)\n",
    "complexity": "constant",
    "problem": "0267_A",
    "from": "CODEFORCES",
    "tags": "math,number theory"
}
{
    "src": "import math\nn,k=map(int,input().split())\nn-=1\nk-=1\nif n>(k*(k+1))//2:\n    print(-1)\nelse:\n    l=-1\n    r=k+1\n    while r>l+1:\n        m=(l+r)//2\n        if n>(m*(2*k-m+1))//2:\n            l=m\n        else:\n            r=m\n    print(r)\n    ",
    "complexity": "logn",
    "problem": "0287_B",
    "from": "CODEFORCES",
    "tags": "binary search,math"
}
{
    "src": "import sys\nimport math\ninput = sys.stdin.readline\nfrom functools import cmp_to_key;\n\ndef pi():\n    return(int(input()))\ndef pl():\n    return(int(input(), 16))\ndef ti():\n    return(list(map(int,input().split())))\ndef ts():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\nmod = 998244353;\nf = [];\ndef fact(n,m):\n    global f;\n    f = [1 for i in range(n+1)];\n    f[0] = 1;\n    for i in range(1,n+1):\n        f[i] = (f[i-1]*i)%m;\n\ndef fast_mod_exp(a,b,m):\n    res = 1;\n    while b > 0:\n        if b & 1:\n            res = (res*a)%m;\n        a = (a*a)%m;\n        b = b >> 1;\n    return res;\n\ndef inverseMod(n,m):\n    return fast_mod_exp(n,m-2,m);\n\ndef ncr(n,r,m):\n    if r == 0: return 1;\n    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;\n\ndef main():\n    B();\n\ndp = [];\ndef D():\n    [n,k] = ti();\n    a = ti();\n    a = sorted(a);\n    cnt = [0 for i in range(n)];\n    for i in range(n):\n        c = 0;\n        for j in range(i,n):\n            if a[j]-a[i] <= 5: c+=1;\n            else:break;\n        cnt[i] = c;\n     \n    global dp;\n    dp = [[0 for j in range(k+1)] for i in range(n+1)];\n    ans = 0;\n    for i in range(n):\n        for j in range(k+1):\n            dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n            if j+1 <= k:\n                dp[i+cnt[i]][j+1] = max(dp[i+cnt[i]][j+1], dp[i][j]+cnt[i]);\n    print(dp[n][k]);\n\ndef B():\n    n = pi();\n    a = ti();\n    q = pi();\n\n    mat = [[0 for j in range(n)] for i in range(n)];\n    dp = [[0 for i in range(n)] for j in range(n)];\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                mat[i][j] = a[i];\n                dp[i][j] = a[i];\n    i = 0;\n    x = 1;\n    while x < n:\n        j = x;\n        i = 0;\n        while j < n:\n            mat[i][j] = mat[i][j-1] ^ mat[i+1][j];\n            j += 1;\n            i += 1;\n        x += 1;\n    \n    i = 0;\n    x = 1;\n    while x < n:\n        j = x;\n        i = 0;\n        while j < n:\n            dp[i][j] = max(mat[i][j], dp[i][j-1], dp[i+1][j]);\n            j += 1;\n            i += 1;\n        x += 1;\n        \n    for i in range(q):\n        [l,r] = ti();\n        print(dp[l-1][r-1]);\n\n            \n\n\nmain();",
    "complexity": "quadratic",
    "problem": "0983_B",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "import sys\ninput=sys.stdin.readline\nn=int(input())\na=list(map(int,input().split()))\nINF=10**9\ndp=[[INF]*(n+1) for i in range(n+1)]\nval=[[-1]*(n+1) for i in range(n+1)]\nfor i in range(n):\n  dp[i][i+1]=1\n  val[i][i+1]=a[i]\nfor l in range(2,n+1):\n  for i in range(n-l+1):\n    j=i+l\n    for k in range(i+1,j):\n      if dp[i][k]==dp[k][j]==1 and val[i][k]==val[k][j]:\n        dp[i][j]=1\n        val[i][j]=val[i][k]+1\n      else:\n        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])\nprint(dp[0][n])",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import sys\nfrom array import array  # noqa: F401\nfrom typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\ndef main():\n    n, m = map(int, input().split())\n    mat = [array('i', map(int, input().split())) for _ in range(n)]\n    bit = [1 << i for i in range(m)]\n    fullbit = (1 << m) - 1\n\n    def solve(x: int) -> Tuple[int, int]:\n        dp = {sum(bit[j] for j, y in enumerate(mat[i]) if y >= x): i for i in range(n)}\n        keys = tuple(dp.keys())\n\n        for i in range(len(keys)):\n            for j in range(i, len(keys)):\n                if keys[i] | keys[j] == fullbit:\n                    return dp[keys[i]], dp[keys[j]]\n\n        return -1, -1\n\n    ok, ng = 0, 10**9 + 1\n    ans_i, ans_j = 1, 1\n\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) >> 1\n        x, y = solve(mid)\n        if x == -1:\n            ng = mid\n        else:\n            ok = mid\n            ans_i, ans_j = x + 1, y + 1\n\n    print(ans_i, ans_j)\n\n\nif __name__ == '__main__':\n    main()\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "print(25)",
    "complexity": "constant",
    "problem": "0630_A",
    "from": "CODEFORCES",
    "tags": "number theory"
}
{
    "src": "import math\nk = int(input())\n\n\ndef cnt_digit_order(X):\n    res = 0\n    if X == 0:\n        return 0\n    for i in range(1, X+1):\n        res += i*(9*pow(10, i-1))\n    return res\n\n\nL = -1\nleftcnt = 0\nfor length in range(1, 100):\n    if cnt_digit_order(length - 1) < k <= cnt_digit_order(length):\n        L = length\n        leftcnt = k - cnt_digit_order(length - 1)\n        break\n\n#L = digits/length\nM = str(math.ceil(leftcnt/L) + (10**(L-1) - 1))\nleftcnt -= 1\nleftcnt %= L\nprint(M[leftcnt])\n",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "line = input()\nn = len(line)\ntemp = [0]\nfor i in range(1, n):\n    for j in range(n-i):\n        for k in range(1, n-i-j+1):\n            # print(line[j:j+i+1])\n            # print(line[j+k:j+k+i+1])\n            if line[j:j+i] == line[j+k:j+k+i]:\n                temp.append(i)\nprint(max(temp))",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "\ndef make_number(b,chars):\n\tif len(chars) == 0:\n\t\treturn \"\"\n\ttarget = chars[0]\n\tfor i in chars:\n\t\tif int(b[0]) <= int(i):\n\t\t\tbreak\n\t\ttarget = i\n\tchars.remove(target)\n\treturn target + \"\".join(chars[::-1])\n\n\ndef find_number(b,chars):\n\tbackup_chars = list(chars)\n\tif len(b) == 1:\n\t\treturn chars[0]\n\telif b[0] in chars:\n\t\tchars.remove(b[0])\n\t\tnum = b[0] + find_number(b[1:],chars)\n\t\tif min(num,b) == b and b != num:\n\t\t\treturn make_number(b,backup_chars)\n\t\telse:\n\t\t\treturn num\n\n\telse:\n\t\treturn make_number(b,backup_chars)\n\na,b = str(input()), str(input())\nchars = [i for i in a]\nchars.sort()\n\nif len(a) < len(b):\n\tprint(\"\".join(chars[::-1]))\nelse:\n\tprint(find_number(b,chars))",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "input_arr = [int(i) for i in input().split()]\na,b = input_arr\n\ndef dec_to_bin(N):\n    res=[0]*64\n    \n    pos=0\n    while N!=0:\n        last_bit = N & 1\n        res[pos] = last_bit\n        pos+=1\n        N=N>>1\n    return res\n\ndef max_xor(a,b):\n    a_bin = dec_to_bin(a)\n    b_bin = dec_to_bin(b)\n    #print(a_bin)\n    #print(b_bin)\n\n    res = \"\"\n    x = \"\"\n    y = \"\"\n    diff_pt_found = False\n\n    for i in range(len(a_bin)-1,-1,-1):\n\n        if diff_pt_found == False and a_bin[i] == b_bin[i]:\n            x+=str(a_bin[i])\n            y+=str(b_bin[i])\n\n        if diff_pt_found == False and a_bin[i] != b_bin[i]:\n            diff_pt_found = True\n            x+=str(a_bin[i])\n            y+=str(b_bin[i])\n            #print(\"Diff Pt.\",i)\n            res+=\"1\"\n            continue\n        \n        if diff_pt_found == True:\n            if a_bin[i] != b_bin[i]:\n                res+=\"1\"\n                x+=str(a_bin[i])\n                y+=str(b_bin[i])\n            elif b_bin[i]==1:\n                res+=\"1\"\n                # y+=\"0\"\n                x+=str(a_bin[i])\n                y+=str(0)\n            elif a_bin[i]==0:\n                res+=\"1\"\n                #x+=\"1\"\n                x+=str(1)\n                y+=str(b_bin[i])\n\n    #print(len(x))\n    return x,y,res\n\ndef bin_to_dec(bin):\n    bin = str(bin)\n    mul = 1\n    res=0\n    for i in range(len(bin)-1,-1,-1):\n        if bin[i]=='1':\n            res+=mul\n            \n        mul=mul*2\n        \n    return res\n\n\nx,y,res = max_xor(a,b)\n#print(\"X:\",x)\n#print(bin_to_dec(x))\n#print(\"Y:\",y)\n#print(bin_to_dec(y))\n#print(\"Res:\",res)\nprint(bin_to_dec(res))",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "import sys\n\ninput=sys.stdin.readline\ninf = 1e10\nmod = int(1e9 + 7)\nt=1;\n# t=int(input())\nfor _ in range(t):\n    # n, k= map(int, input().split())\n    # v=list(map(int, input().split()))\n    s=input()\n    c=s.count('1')\n    c1, i=0, 0\n    while(i<len(s) and s[i]!='2'):\n        if(s[i]=='0'):c1+=1\n        i+=1\n    print('0'*c1, end=\"\")\n    print('1'*c, end=\"\")\n    while(i<len(s)):\n        if(s[i]!='1'):\n            print(s[i], end=\"\")\n        i+=1",
    "complexity": "linear",
    "problem": "1009_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation"
}
{
    "src": "\nimport math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n    return d[s]\n\nn,x,y=map(int,input().split())\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))\ny+=x\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))",
    "complexity": "np",
    "problem": "1463_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,math"
}
{
    "src": "a=int(input())\nb=int(input())\nx=[0]*10\nwhile a:\n    x[a%10]+=1\n    a=a//10\nans=0\nfor i in range(9,-1,-1):\n    for j in range(x[i]):\n        ans=ans*10+i\nif ans<=b:\n    print(ans)\nelse:\n    ans=0\n    for j in str(b):\n        c=int(j)\n        while c>=0 and not x[c]:\n            c-=1\n        if c<0:\n            while True:\n                x[ans%10]+=1\n                d=ans%10\n                ans=ans//10\n                flag=0\n                for b in range(d-1,-1,-1):\n\n                    if x[b]:\n                        ans=ans*10+b\n                        x[b]-=1\n                        flag=1\n                        break\n                if flag:\n                    break\n            break\n                        \n                \n        else:\n            x[c]-=1\n            ans=ans*10+c\n            if c<int(j):\n                break\n\n    for j in range(9,-1,-1):\n        for i in range(x[j]):\n            ans=ans*10+j\n    print(ans)\n        \n",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n, p = map(int, input().split())\n\narr = [int(b) for b in input().split()]\n\nres = []\n\nprefsums = [arr[0]]\n\nfor i in range(1, n):\n    prefsums.append(prefsums[i - 1] + arr[i])\n\nallsum = sum(arr)\n\nif len(arr) == 2:\n    print(arr[0] % p + arr[1] % p)\n    exit()\n\nfor i in range(1, n - 1):\n    res.append((prefsums[i] % p) + ((allsum - prefsums[i]) % p))\n\n\nprint(max(res))\n\n",
    "complexity": "linear",
    "problem": "0958_C1",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "# http://codeforces.com/contest/992/problem/C\n\nx, k = map(int, input().split())\n\nmd = 10 ** 9 + 7\n\nres = x * pow(2, k + 1, md) - pow(2, k, md) + 1 if x > 0 else 0\nprint(res % md)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n = int(input())\nA = list(map(int, input().split()))\nk = 10 ** 10\nfor i in range(1, n - 1):\n    k = min(k, min(A[0], A[i]) // i)\n    k = min(k, min(A[-1], A[i]) // (n - i - 1))\nk = min(k, min(A[0], A[-1]) // (n - 1))\nprint(k)",
    "complexity": "linear",
    "problem": "1159_B",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "import sys\nimport math\ninput = sys.stdin.readline\nfrom functools import cmp_to_key;\n\ndef pi():\n    return(int(input()))\ndef pl():\n    return(int(input(), 16))\ndef ti():\n    return(list(map(int,input().split())))\ndef ts():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\nmod = 1000000007;\nf = [];\ndef fact(n,m):\n    global f;\n    f = [1 for i in range(n+1)];\n    f[0] = 1;\n    for i in range(1,n+1):\n        f[i] = (f[i-1]*i)%m;\n\ndef fast_mod_exp(a,b,m):\n    res = 1;\n    while b > 0:\n        if b & 1:\n            res = (res*a)%m;\n        a = (a*a)%m;\n        b = b >> 1;\n    return res;\n\ndef inverseMod(n,m):\n    return fast_mod_exp(n,m-2,m);\n\ndef ncr(n,r,m):\n    if n < 0 or r < 0 or r > n: return 0;\n    if r == 0: return 1;\n    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;\n\ndef main():\n    C();\n\ndef D():\n    [n,m,k] = ti();\n    w = [[] for i in range(n)];\n    for i in range(n):\n        w[i] = ts();\n\n    mn = [[0 for j in range(k+1)] for i in range(n+1)];\n    for i in range(1,n+1):\n        for j in range(k+1):\n            c = 0;\n            st,en = -1,-1;\n            for x in range(m):\n                if w[i-1][x] == '1':\n                    if c == j and st == -1: st = x;\n                    if c < j: c += 1;\n                    if c == j: en = x;\n            mn[i][j] = en-st+1 if st != -1 and en != -1 else 0;\n            st,en = -1,-1;\n            c = 0;\n            for x in range(m-1,-1,-1):\n                if w[i-1][x] == '1':\n                    if c == j and st == -1: st = x;\n                    if c < j: c += 1;\n                    if c == j: en = x;\n            if st != -1 and en != -1 >= 0:\n                mn[i][j] = min(mn[i][j], st-en+1);\n\n    dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)];\n    for i in range(k+1):\n        dp[0][i] = 0;\n    for i in range(1,n+1):\n        for j in range(k+1):\n            for x in range(k+1):\n                if j-x >= 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]);\n\n    print(dp[n][k]);\n\ndef C():\n    n = pi();\n    s = [];\n    mxI = 0;\n    for i in range(n):\n        c = input();\n        s.append(c[:len(c)-1]);\n        if s[len(s)-1] == 'f': mxI += 1;\n    dp = [[0 for j in range(mxI+1)] for i in range(n)];\n    dp[0][0] = 1;\n    preSum = [1 for i in range(mxI+1)];\n    pre = 1;\n    for i in range(1,n):\n        sm = 0;\n        pre = 0;\n        for j in range(mxI+1):\n            if s[i-1] == 'f':\n                dp[i][j] = dp[i-1][j-1]%mod;\n            else:\n                dp[i][j] = (preSum[mxI]%mod-(pre if j != 0 else 0)%mod)%mod;\n            pre = preSum[j];\n            preSum[j] = ((preSum[j-1] if j != 0 else 0)%mod+dp[i][j]%mod)%mod;\n\n    print(preSum[mxI]%mod);\n\nmain();",
    "complexity": "quadratic",
    "problem": "0909_C",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "n,k = map(int,input().split())\ns= input()\ns1=s\nc=0\nfor i in range(len(s)-1):\n    if(s[:i+1]==s[n-i-1:]):\n        c=i+1\nfor i in range(k-1):\n    s1+=s[c:]\nprint(s1)",
    "complexity": "quadratic",
    "problem": "1029_A",
    "from": "CODEFORCES",
    "tags": "implementation,strings"
}
{
    "src": "n, a, b = map(int, input().split())\nif min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:\n    print('NO')\n    exit()\nprint('YES')\nf = int(a == 1)\ng = [a, b][f]\nr = [[f] * n for i in range(n)]\nfor i in range(n):\n    r[i][i] = 0\nfor i in range(n - g):\n    r[i][i + 1] ^= 1\n    r[i + 1][i] ^= 1\nfor x in r:\n    print(*x, sep='')\njohnny=0\n \t \t \t \t\t\t   \t\t \t\t  \t\t\t\t \t\t\t\t",
    "complexity": "quadratic",
    "problem": "0990_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,graphs,implementation"
}
{
    "src": "n,k = map(int,input().split())\na = list(map(int,input().split()))\n\ncount = 0\nb = {}\nfor i in range(n):\n    if a[i] in b:\n        b[a[i]] += 1\n    else:\n        b[a[i]] =1\n    if b[a[i]] == 1:\n        count += 1\n    if count == k:\n        break\n#print(\"i=\", i)\n#print(b)\n\n\nfor j in range(n):\n  if a[j] in b:\n    b[a[j]] -= 1\n#    print(\"j=\", j)\n#    print(b)\n  if b[a[j]] == 0:\n    break \n#  print(\"j=\",j)\n        \nif count != k:\n    print(\"-1 -1\")\nelse:\n  if n == 1:\n    print(1,1)\n  elif n == 2 and count == 2:\n    print(1,2)\n  else:\n    print(j+1,i+1)  ",
    "complexity": "linear",
    "problem": "0224_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,implementation,two pointers"
}
{
    "src": "import math \n  \ndef countDigit(n): \n\treturn math.floor(math.log(n, 10)+1)\n\n\n\nn=int(input())\ncount=countDigit(n)\nif count==1:\n\tprint(n)\nelse:\n\tlow=1\n\thigh=9\n\tsum=[]\n\tdigit=0\n\tsum.append(0)\n\tsum.append(9)\n\tfor i in range(2,16):\n\t\tlow=low*10\n\t\thigh=high*10+9\n\t\t#print(countDigit(high))\n\t\tsum.append((high-low+1)*i+sum[i-1])\n\t\t\n\t\tif n<sum[i]:\n\t\t\tdigit=i\n\t\t\tbreak\n\tx=n-sum[digit-1]\n\tq=x/(digit)\n\tr=x%(digit)\n\tlow=math.pow(10,digit-1)\n\tlow=low+q-1\n\t#print(low)\n\tif r==0:\n\t\tprint(int(low%10))\n\telse:\n\t\tn=low+1\n\t\tstringnum=str(n)\n\t\tprint(int(stringnum[r-1]))",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nmask = (1 << m) - 1\n\nl = []\nfor i in range(n):\n    l.append(list(map(int,input().split())))\n\nlo = -1 #Possible\nhi = 10 ** 9 + 1 #Impossible\nwhile hi - lo > 1:\n    test = (hi + lo) // 2\n\n    things = dict()\n    for i in range(n):\n        curr = 0\n        for v in l[i]:\n            curr *= 2\n            if v >= test:\n                curr += 1\n        things[curr] = i\n\n    works = False\n    for v1 in things:\n        for v2 in things:\n            if v1 | v2 == mask:\n                outi = things[v1]\n                outj = things[v2]\n                works = True\n                break\n        if works:\n            break\n\n    if works:\n        lo = test\n    else:\n        hi = test\n\nprint(outi + 1, outj + 1)\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "import bisect\nimport copy\nimport decimal\nimport fractions\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import deque,defaultdict\nfrom functools import lru_cache,reduce\nfrom heapq import heappush,heappop,heapify,_heappop_max,_heapify_max\ndef _heappush_max(heap,item):\n    heap.append(item)\n    heapq._siftdown_max(heap,0,len(heap)-1)\nfrom math import gcd as Gcd\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\ndef Extended_Euclid(n,m):\n    stack=[]\n    while m:\n        stack.append((n,m))\n        n,m=m,n%m\n    if n>=0:\n        x,y=1,0\n    else:\n        x,y=-1,0\n    for i in range(len(stack)-1,-1,-1):\n        n,m=stack[i]\n        x,y=y,x-(n//m)*y\n    return x,y\n\nclass MOD:\n    def __init__(self,p,e=1):\n        self.p=p\n        self.e=e\n        self.mod=self.p**self.e\n\n    def Pow(self,a,n):\n        a%=self.mod\n        if n>=0:\n            return pow(a,n,self.mod)\n        else:\n            assert math.gcd(a,self.mod)==1\n            x=Extended_Euclid(a,self.mod)[0]\n            return pow(x,-n,self.mod)\n\n    def Build_Fact(self,N):\n        assert N>=0\n        self.factorial=[1]\n        self.cnt=[0]*(N+1)\n        for i in range(1,N+1):\n            ii=i\n            self.cnt[i]=self.cnt[i-1]\n            while ii%self.p==0:\n                ii//=self.p\n                self.cnt[i]+=1\n            self.factorial.append((self.factorial[-1]*ii)%self.mod)\n        self.factorial_inv=[None]*(N+1)\n        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)\n        for i in range(N-1,-1,-1):\n            ii=i+1\n            while ii%self.p==0:\n                ii//=self.p\n            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod\n\n    def Fact(self,N):\n        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod\n\n    def Fact_Inv(self,N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inv[N]\n\n    def Comb(self,N,K,divisible_count=False):\n        if K<0 or K>N:\n            return 0\n        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod\n        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]\n        if divisible_count:\n            return retu,cnt\n        else:\n            retu*=pow(self.p,cnt,self.mod)\n            retu%=self.mod\n            return retu\n\ndef Bell_Numbers(N,mod,prime=False):\n    bell_numbers=[0]*(N+1)\n    bell_numbers[0]=1\n    MD=MOD(mod)\n    if prime:\n        MD.Build_Fact(min(mod-2,N-1))\n        for i in range(1,min(mod,N+1)):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n        for i in range(mod,N+1):\n            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod\n    else:\n        MD.Build_Fact(N-1)\n        for i in range(1,N+1):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n    return bell_numbers\n\nM,N=map(int,readline().split())\nS=[readline().rstrip() for i in range(N)]\ndct=defaultdict(int)\nfor i in range(M):\n    tpl=()\n    for j in range(N):\n        tpl+=(S[j][i],)\n    dct[tpl]+=1\nans=1\nmod=10**9+7\nbell=Bell_Numbers(M,mod)\nfor c in dct.values():\n    ans*=bell[c]\n    ans%=mod\nprint(ans)",
    "complexity": "quadratic",
    "problem": "0908_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,combinatorics,dp,math"
}
{
    "src": "\n# this sequence is a bit scary\n# 8\n# 1 2 3 2 3 2 1 0\n\nimport sys\n#sys.stdin=open(\"data.txt\")\n#input=sys.stdin.readline\n\ngot=[10**18]*100005\n\ndef getnum(i):\n    if got[i]==10**18:\n        print(\"? %d\"%i)\n        sys.stdout.flush()\n        got[i]=int(input())\n    return got[i]\n\nn=int(input())\nif n%4==2:\n    # the opposite person has a different parity\n    print(\"! -1\")\nelse:\n    lo=1\n    hi=n//2+1\n    t1=getnum(lo)\n    t2=getnum(hi)\n    lo2=t1-t2\n    hi2=t2-t1\n    if lo2==0:\n        print(\"! 1\")\n    else:\n        # binary search\n        # let's hope that 1 <= mid <= n/2\n        while lo<hi:\n            mid=(lo+hi)//2\n            #print(lo,hi,mid)\n            mid2=getnum(mid)-getnum(mid+n//2)\n            if mid2==0:\n                print(\"! %d\"%mid)\n                break\n            if (lo2>0) == (mid2>0):\n                lo=mid+1\n            else:\n                hi=mid-1\n        else:\n            print(\"! %d\"%lo)\nsys.stdout.flush()\n",
    "complexity": "logn",
    "problem": "1019_B",
    "from": "CODEFORCES",
    "tags": "binary search,interactive"
}
{
    "src": "n = int(input())\nar = list(map(int, input().split()))\nrev = ar[::-1]\nfrom collections import Counter\ndef d(ar):\n\tme = Counter()\n\ts = 0 \n\tfor i in range (n) : \n\t\ts+=(i*ar[i])\n\t\ts-=(me[ar[i]] + me[ar[i]+1]*ar[i] + me[ar[i]-1]*ar[i])\n\t\tme[ar[i]]+=1\n\treturn s\nprint(d(ar) - d(rev))",
    "complexity": "nlogn",
    "problem": "0903_D",
    "from": "CODEFORCES",
    "tags": "data structures,math"
}
{
    "src": "n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2024)]\n\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n\nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])\n",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import sys\nfrom array import array  # noqa: F401\nimport typing as Tp  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\nT = Tp.TypeVar('T')\n\n\nclass FenwickSum(Tp.Generic[T]):\n    __slots__ = ['nodes', 'size', 'unit']\n\n    def __init__(self, size: int, default: T, unit: T):\n        self.nodes = [default] * (size + 1)\n        self.size = size + 1\n        self.unit = unit\n\n    def add(self, index: int, value: T):\n        while index < self.size:\n            self.nodes[index] += value\n            index += index & -index\n\n    def sum(self, right: int) -> T:\n        result = self.unit\n\n        while right:\n            result += self.nodes[right]\n            right -= right & -right\n\n        return result\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = [x for x in a if x != -1]\n    mod = 998244353\n    minus = n - len(b)\n    m_inv = pow(minus, mod - 2, mod)\n    ans = 0\n\n    bit = FenwickSum[int](n, 0, 0)\n    for x in reversed(b):\n        ans += bit.sum(x)\n        bit.add(x, 1)\n\n    ans += minus * (minus - 1) * pow(4, mod - 2, mod) % mod\n\n    acc_u, m = [0] * (n + 1), minus\n    for x in a:\n        if x == -1:\n            m -= 1\n        else:\n            acc_u[x] = m\n\n    for i in range(n - 1, 0, -1):\n        acc_u[i] += acc_u[i + 1]\n        if acc_u[i] >= mod:\n            acc_u[i] -= mod\n\n    acc_d, m = [0] * (n + 1), minus\n    for x in reversed(a):\n        if x == -1:\n            m -= 1\n        else:\n            acc_d[x] = m\n\n    for i in range(1, n + 1):\n        acc_d[i] += acc_d[i - 1]\n        if acc_d[i] >= mod:\n            acc_d[i] -= mod\n\n    for x in set(range(1, n + 1)) - set(b):\n        ans = (ans + (acc_u[x] + acc_d[x]) * m_inv) % mod\n\n    print(ans % mod)\n\n\nif __name__ == '__main__':\n    main()\n",
    "complexity": "nlogn",
    "problem": "1096_F",
    "from": "CODEFORCES",
    "tags": "dp,math,probabilities"
}
{
    "src": "import math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n    return d[s]\n\nn,x,y=map(int,input().split())\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))\ny+=x\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))",
    "complexity": "np",
    "problem": "1463_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,math"
}
{
    "src": "from collections import defaultdict\n\ndef f(b,d):\n    fi = int(b[0])\n    if len(b)==1:\n        j=fi\n        while(j>=0):\n            if d[j]:\n                return str(j)\n            j+=-1\n\n        return \"\"\n\n\n    fi=int(b[0])\n    s=\"\"\n    if d[fi]>0:\n        d1=defaultdict(lambda:0)\n        for j in d:\n            d1[j]=d[j]\n        d1[fi]+=-1\n        s=f(b[1:],d1)\n\n    if s!=\"\":\n        return str(fi)+s\n\n    else:\n        s1=\"\"\n        j=fi-1\n        while(j>=0):\n            if d[j]>0:\n                s1+=str(j)\n                d[j]+=-1\n                break\n            j+=-1\n        if s1==\"\":\n            return \"\"\n        else:\n            j=9\n            while(j>=0):\n                if d[j]==0:\n                    j+=-1\n\n                else:\n                    s1+=str(j)\n                    d[j]+=-1\n\n            return s1\n\n\n\n\n\n\n\n\n\n\n\n\na=input()\nb=input()\nd=defaultdict(lambda:0)\nres=[]\nfor j in a:\n    d[int(j)]+=1\n    res.append(int(j))\nres.sort(reverse=True)\nfor j in range(len(a)):\n    res[j]=str(res[j])\nif len(b)>len(a):\n    print(\"\".join(res))\n\nelse:\n    print(f(b,d))\n\n",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import sys\ndef read():\n    return int(input())\ndef reads():\n    return [int(x) for x in input().split()]\nN,M=reads()\ntable=[reads() for i in range(N)]\nA=[[0]*N for i in range(N)]\nB=[[0]*N for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        res=10**9+7\n        for k in range(M):\n            res=min(res,abs(table[i][k]-table[j][k]))\n        A[i][j]=res\n        A[j][i]=res\n        res=10**9+7\n        for k in range(M-1):\n            res=min(res,abs(table[i][k]-table[j][k+1]))\n        B[i][j]=res\n#print(table)\n#print(A)\n#print(B)\n#A=[[10**9,2,3],[2,10**9,8],[1,5,10**9]]\n#B=[[10**9,2,3],[2,10**9,8],[1,5,10**9]]\ndp=[[-1]*N for i in range((1<<N) )]\ndef calc(mask,v):\n    if dp[mask][v]!=-1:\n        return dp[mask][v]\n    res =0\n    for u in range(N):\n        if (mask & 1<<u) and u!=v:\n            res =max(res,min(calc(mask^(1<<v),u),A[u][v]))\n    dp[mask][v]=res\n    return dp[mask][v]\nans=0\nfor i in range(N):\n    dp = [[-1] * N for i in range((1 << N))]\n    for k in range(N):\n        if k==i:\n            dp[1<<k][k]=10**9+7\n        else:\n            dp[1<<k][k]=0\n    for j in range(N):\n        ans=max(ans,min(B[j][i],calc((1<<N)-1,j)))\n    #print(dp,ans)\nprint(ans)",
    "complexity": "np",
    "problem": "1102_F",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,brute force,dp,graphs"
}
{
    "src": "import sys\ninput = sys.stdin.readline\nx,y = map(int, input().split())\nif y-x<2:\n\tprint(-1)\nelif x%2 != 0 and y-x==2:\n\tprint(-1)\nelif x%2==0:\n\tprint(x, x+1, x+2)\nelse:\n\tprint(x+1, x+2, x+3)",
    "complexity": "constant",
    "problem": "0483_A",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,math,number theory"
}
{
    "src": "n, values, wrong = int(input()), [int(i) for i in input().split()], 0\nsorted_values = list(sorted(values))\nfor i in range(n):\n    if values[i] != sorted_values[i]:\n        wrong += 1\nif wrong > 2:\n    print(\"NO\")\nelse:\n    print(\"YES\")",
    "complexity": "nlogn",
    "problem": "0220_A",
    "from": "CODEFORCES",
    "tags": "implementation,sortings"
}
{
    "src": "n=input()\nans=0\nr,c=0,0\nfor i in range(len(n)):\n    r+=int(n[i])\n    c+=1\n    if int(n[i])%3==0 or r%3==0 or c==3:\n        ans+=1\n        r,c=0,0\nprint(ans)",
    "complexity": "linear",
    "problem": "1005_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,number theory"
}
{
    "src": "def main():\n    import sys\n    input = sys.stdin.readline\n    \n    n, k = map(int, input().split())\n    \n    l = 1\n    r = n + 1\n    \n    while r - l != 1:\n        m = l + r >> 1\n        candies = m * (m + 1) // 2\n        eat = n - m\n        \n        if candies - eat <= k:\n            l = m\n        else:\n            r = m\n    \n    print(n - l)\n    \n    return 0\n\nmain()",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "def givestringsk(k):\n    t=[\"R\",\"G\",\"B\"]\n    ans=[]\n    for i in range(3):\n        temp=\"\"\n        for j in range(i,i+k):\n            temp+=t[j%3]\n        ans.append(temp)\n    return ans\ndef countdifferences(a,b):\n    cnt=0\n    for i in range(len(a)):\n        if a[i]!=b[i]:cnt+=1\n    return cnt\nfor _ in range(int(input())):\n    n,k=list(map(int,input().split()))\n    s=input()\n    temp=givestringsk(k)\n    ans=10000000000000\n    for i in range(k,n+1):\n        for j in range(3):\n            ans=min(ans,countdifferences(s[i-k:i],temp[j]))\n    print(ans)\n    ",
    "complexity": "quadratic",
    "problem": "1196_D1",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "#########################################################################################################\\\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\n\nimport sys,os,io\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom sys import stdin\n\nimport math \n\n\n\ndef ncr(n, r, p):  #using fermat's little theorem\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\n  \ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n          \n    for i in range(3,int(math.sqrt(n))+1,2): \n          \n\n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    return list(set(l))\n    \ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \n\n\ndef si():\n    return input()\n\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\n\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\n\ndef ii():\n    return int(input())\n\ndef li():\n    return list(map(int,input().split()))\n\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\n\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\")\n    sys.stdout = open(\"output.txt\",\"w\")\n\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nt = int(input())\nfor _ in range(t):\n    n = ii()\n    l = li()\n    l1 = l[:]\n    arr = defaultdict(lambda:0)\n    for i in l:\n        arr[i]+=1\n    l = []\n    graterthan4 = 0\n    isgraterthan4 = False\n    for i in list(arr.keys()):\n        if (arr[i]>=4):\n            isgraterthan4 = True\n            graterthan4 = i\n        if (arr[i]>=2):\n            l.append(i)\n    n = len(l)\n    l.sort()\n    m = 1000000000000\n    mi = []\n    # print(l)\n    for i in range(n-1):\n        a = l[i]\n        b = l[i+1]\n        # print(a/b+b/a)\n        if (a/b+b/a<m):\n            m = a/b+b/a\n            # print(\"m\",m)\n            mi = [a,b]\n    if (isgraterthan4==True):\n        print(graterthan4,graterthan4,graterthan4,graterthan4)\n    else:\n        a,b = mi\n        print(a,a,b,b)\n    \n\n    ",
    "complexity": "nlogn",
    "problem": "1027_C",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "#########################################################################################################\\\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\nimport sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math \n\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):  \n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n    \"\"\"\n    L is a list.\n    The function returns the power set, but as a list of lists.\n    \"\"\"\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n    \n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n        \n    #the function could stop here closing with\n    #return powerset\n\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n        \n    return powerset_orderred\ndef fastPlrintNextLines(a):\n    # 12\n    # 3\n    # 1\n    #like this\n    #a is list of strings\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\n#__________________________TEMPLATE__________________OVER_______________________________________________________\n\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\") \nelse:\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nt = 1\n# t = int(input())\nfor _ in range(t):\n    n,k = li()\n    if k<=n:\n        print((k-1)//2)\n    else:\n        print(max((2*n-k+1)//2,0))\n    \n    \n",
    "complexity": "constant",
    "problem": "1023_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "for _ in range(int(input())):\n    n,m = sorted(map(int,input().split()))\n    count = 0\n    while n> 0:\n        count+= m//n\n        m = m%n\n        n,m = sorted([n,m])\n    print(count)\n",
    "complexity": "constant",
    "problem": "0267_A",
    "from": "CODEFORCES",
    "tags": "math,number theory"
}
{
    "src": "n,a,b=map(int,input().split())\nalist=list(map(int,input().split()))\nalist.sort(reverse=True)\np=alist[a-1]\nq=alist[a]\nprint(p-q)",
    "complexity": "nlogn",
    "problem": "0169_A",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "n, k = map(int, input().split(' '))\ns = input()\nm = 10 ** 10\nfor i in range(k):\n    c = chr(ord('A') + i)\n    m = min(m, s.count(c))\nprint(m * k)",
    "complexity": "linear",
    "problem": "1038_A",
    "from": "CODEFORCES",
    "tags": "implementation,strings"
}
{
    "src": "n,k=map(int,input().strip().split())\nd=(n-k)//2+1\nx=['1' if (i+1)%d==0 else '0' for i in range(n)]\nprint(''.join(x))",
    "complexity": "linear",
    "problem": "1159_D",
    "from": "CODEFORCES",
    "tags": "brute force,greedy,constructive algorithms,math,strings"
}
{
    "src": "\ndef naiveSolve():\n    \n    \n    \n    return\n\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\nclass OrderedList(SortedList): #Codeforces, Ordered Multiset\n    def __init__(self, arg):\n        super().__init__(arg)\n    def rangeCountByValue(self, leftVal, rightVal): #returns number of items in range [leftVal,rightVal] inclusive\n        leftCummulative = self.bisect_left(leftVal)\n        rightCummulative = self.bisect_left(rightVal + 1)\n        return rightCummulative - leftCummulative\n\nfrom collections import Counter\n\ndef main():\n    \n    n=int(input())\n    a=readIntArr()\n    \n    cnts=Counter(a)\n    ol=OrderedList([v for v in cnts.values()])\n    ol.add(0) # might have to remove 0 counts for x-1\n    canMakeFirstMove=False\n    for x in a:\n        if x>0:\n            c=cnts[x]\n            ol.remove(c)\n            ol.add(c-1)\n            d=cnts[x-1]\n            ol.remove(d)\n            ol.add(d+1)\n            # check\n            if ol[-1]==1:\n                canMakeFirstMove=True\n                break\n            ol.add(c)\n            ol.remove(c-1)\n            ol.add(d)\n            ol.remove(d+1)\n    if canMakeFirstMove==False:\n        print('cslnb')\n    else:\n        # first to make 0,1,2,3,4... loses\n        target=(n*(n-1))//2\n        if (sum(a)-target)%2==0:\n            print('cslnb')\n        else:\n            print('sjfnb')\n    \n    return\n\n\nimport sys\n# input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\ninput=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(l,r):\n    print('? {} {}'.format(l,r))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(x):\n    print('! {}'.format(x))\n    sys.stdout.flush()\n \ninf=float('inf')\nMOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n \nfor _abc in range(1):\n    main()\n",
    "complexity": "nlogn",
    "problem": "1190_B",
    "from": "CODEFORCES",
    "tags": "games"
}
{
    "src": "n = int(input())\nnums = [int(x) for x in input().split()]\nans = 10 ** 12\nfor idx, num in enumerate(nums):\n    dist = max(idx, n - idx - 1)\n    curr = num // dist\n    ans = min(ans, curr)\nprint(ans)",
    "complexity": "linear",
    "problem": "1159_B",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\n \n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------game starts now-----------------------------------------------------\n\nx,k=map(int,input().split())\nres=0\nmod=1000000007\nres=pow(2,k,mod)*(2*x-1)+1\nres%=mod\nif x==0:\n    res=0\nprint(res)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Dec 15 23:11:30 2020\n\nLCM Challenge\n\n@author --> yashodeep\n@Link --> https://codeforces.com/problemset/problem/235/A\n@status --> Accepted in first attempt\n\"\"\"\nn = int(input())\nans = 1\nif n == 1:\n    ans = 1\nelif n == 2:\n    ans = 2\nelif n == 3:\n    ans = 6\nelif n%2 == 0:\n    if n%3 == 0:\n        ans = (n-1)*(n-2)*(n-3)\n    else:\n        ans = n*(n-1)*(n-3)\nelse:\n    ans = n*(n-1)*(n-2)\n\nprint(ans)",
    "complexity": "constant",
    "problem": "0235_A",
    "from": "CODEFORCES",
    "tags": "number theory"
}
{
    "src": "a,b=input().split()\nif(a==b):\n    print(\"0\")\nelse:\n    xor=bin(int(a)^int(b))[2:]\n    a=bin(int(a))[2:]\n    b=bin(int(b))[2:]\n    ans=\"\"\n    if a[0]==b[0]:\n        ans+=\"0\"\n    else:\n        ans+=\"1\"\n    for i in range(len(xor)):\n        ans+=\"1\"\n    print(int(ans,2))\n",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "n = int(input())\na = list(map(int,input().split()))\nmod = 10**9+7\nb = [0 for i in range(1<<20)]\nfor i in range(n):\n  b[a[i]] += 1\nfor i in range(20):\n  for j in range(1<<20):\n    if j&1<<i == 0:\n      b[j] += b[j|1<<i]\nans = 0\nfor i in range(1<<20):\n  cnt = str(bin(i)).count(\"1\")\n  if cnt%2 == 0:\n    ans += pow(2,b[i],mod)-1\n  else:\n    ans -= pow(2,b[i],mod)-1\n  ans %= mod\nprint(ans)",
    "complexity": "np",
    "problem": "0449_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,combinatorics,dp"
}
{
    "src": "import io, sys\ninput = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()\n \nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nn, k = mi()\nans = None\nfor x in range(1, n + 1):\n    if x * (x + 3) == 2 * (k + n):\n        ans = n - x\n        break\nprint(ans)",
    "complexity": "linear",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\nmax_el = -1;\ner = -1;\nfor i in range(len(a)):\n    if a[i] - max_el > 1:\n        er = i + 1;\n        break\n    if a[i] > max_el:\n        max_el = a[i]\n\nprint(er)\n",
    "complexity": "linear",
    "problem": "1054_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import sys\ninput=sys.stdin.readline\nal=list(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nn=int(input())\ns=[input().rstrip() for i in range(3)]\nl=len(s[0])\nans=[0]*3\nfor c in al:\n    for i in range(3):\n        cnt_c=s[i].count(c)\n        if cnt_c+n<=l:\n            ans[i]=max(ans[i],cnt_c+n)\n        else:\n            if n==1 and l==cnt_c:\n                ans[i]=max(ans[i],l-1)\n            else:\n                ans[i]=l\nif (ans[0]==ans[1] and max(ans)==ans[0]) or (ans[1]==ans[2] and max(ans)==ans[1]) or (ans[0]==ans[2] and max(ans)==ans[2]):\n    print(\"Draw\")\nelif max(ans)==ans[0]:\n    print(\"Kuro\")\nelif max(ans)==ans[1]:\n    print(\"Shiro\")\nelse:\n    print(\"Katie\")",
    "complexity": "linear",
    "problem": "0979_B",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "import sys\nfrom collections import deque\nn=int(input())\nvisited=[False for i in range(n+1)]\ndp=[0 for i in range(n+1)]\nl=[[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    l[a].append(b)\n    l[b].append(a)\nb=list(map(int,input().split()))\ns=[1]\nvisited[1]=True\nc=1\nc1=0\nt=True\nwhile len(s)!=n :\n    aux=0\n    for i in l[s[c1]]:\n        if not visited[i]:\n            visited[i]=True\n            dp[i]=1\n            aux+=1\n    for i in range(c,c+aux):\n        if dp[b[i]]==1:\n            s.append(b[i])\n            dp[b[i]]=0\n        else:\n            print(\"No\")\n            t=False\n            break\n    else:\n        c+=aux\n        c1+=1\n        continue\n    break\nif t:\n    print(\"Yes\")\n",
    "complexity": "nlogn",
    "problem": "1037_D",
    "from": "CODEFORCES",
    "tags": "dfs and similar,graphs,shortest paths,trees"
}
{
    "src": "from collections import Counter\nfrom math import *\nimport sys\nmod=1000000007\n\ndef pro(arr,q):\n    n=len(arr)\n    ans=0\n    for i in range(n):\n        for j in range(i+1,n):\n            if(arr[i]>arr[j]):\n                ans+=1\n    \n    res=ans%2\n    for x,y in q:\n        k= y-x + 1\n        k=k//2\n        k=k%2\n        res= k^res\n        if(res):\n            print('odd')\n        else:\n            print('even')\nn=int(input())\narr=list(map(int,input().split()))\nt=int(input())\nque=[]\nfor i in range(t):\n    que.append(list(map(int,input().split())))\npro(arr,que)",
    "complexity": "quadratic",
    "problem": "0911_D",
    "from": "CODEFORCES",
    "tags": "brute force,math"
}
{
    "src": "n=int(input())\na=[int(x) for x in input().split()]\npro=n*(n-1)//2\ndic={}\nfor item in a:\n    if item not in dic:\n        dic[item]=1\n    else:\n        dic[item]+=1\ncounter=0\nfor item in dic:\n    if 0 in dic and dic[0]>=2:\n        print('cslnb')\n        break\n    if dic[item]>2:\n        print('cslnb')\n        break\n    elif dic[item]==2:\n        if counter==1 or item-1 in dic:\n            print('cslnb')\n            break\n        else:\n            counter=1\nelse:\n    if (sum(a)-pro)%2==1:\n        print('sjfnb')\n    else:\n        print('cslnb')\n",
    "complexity": "linear",
    "problem": "1191_D",
    "from": "CODEFORCES",
    "tags": "games"
}
{
    "src": "import sys,io,os,math\ntry:yash=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nexcept:yash=lambda:sys.stdin.readline().encode()\nI=lambda:[*map(int,yash().split())]\nimport __pypy__;an=__pypy__.builders.StringBuilder()\nn,=I();lis=I();N=22;dp=[-1]*(1<<22)\nfor i in range(n):\n    dp[lis[i]]=lis[i]\n    for j in range(22):\n        lis[i]^=(1<<j)\nfor mask in range(1<<22):\n    for i in range(22):\n        if (mask&(1<<i)) and dp[mask^(1<<i)]!=-1:dp[mask]=dp[mask^(1<<i)]\nfor num in lis:\n    an.append(\"%s \"%(dp[num]))\nan.append(\"\\n\")\nos.write(1, an.build().encode())",
    "complexity": "np",
    "problem": "0165_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,dfs and similar,dp"
}
{
    "src": "'''input\n5 25 35 10\n10 10 20 10 20\n'''\nfrom sys import stdin, stdout, setrecursionlimit\nfrom collections import deque, defaultdict\nfrom bisect import bisect_left\n\n\n\ndef check(temp):\n\tif len(temp) < 2:\n\t\treturn False\n\telse:\n\t\ts = sum(temp)\n\t\tif s >= l and s <= r:\n\t\t\tif temp[-1] - temp[0] >= x:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\t\telse:\n\t\t\treturn False\n \ndef brute(index, temp):\n\tglobal count\n\n\tif index == n:\n\t\tif check(temp):\n\t\t\tcount += 1\n\n\telse:\n\t\ttemp.append(arr[index])\n\t\tbrute(index + 1, temp)\n\t\ttemp.pop()\n\t\tbrute(index + 1, temp)\n\n\n# main starts\nn, l, r, x = list(map(int, stdin.readline().split()))\narr = list(map(int, stdin.readline().split()))\narr.sort()\ncount = 0\ntemp = []\nbrute(0, temp)\nprint(count)\n\t    \t\t\t\t\t\t\t    \t\t\t \t\t\t   \t\t \t",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "def isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\nn=int(input());d=0\nif n%2==0:\n    print('4 '+str(n-4))\nelse:\n    i=4\n    while i<=int(n//2)+1:\n        k=n-i\n        if isPrime(k)==False:\n            print(str(i)+' '+str(k))\n            break\n        i+=2\n\n            \n        \n            \n",
    "complexity": "constant",
    "problem": "0472_A",
    "from": "CODEFORCES",
    "tags": "math,number theory"
}
{
    "src": "# cook your dish here\nn=int(input())\narr=[int(x) for x in input().split()]\nli=arr[:]\nli.sort()\nc=0\nfor i in range(n):\n    if(arr[i]!=li[i]):\n        c+=1\n    if(c>2):\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")",
    "complexity": "nlogn",
    "problem": "0220_A",
    "from": "CODEFORCES",
    "tags": "implementation,sortings"
}
{
    "src": "import sys\ninput=sys.stdin.readline\ndef read():return list(map(int,input().split()))\nn,m=read()\na=[]\nfor i in range(n):\n    a.append(read())\nsm=0\ncur=0\nfor x, y in a:\n    sm+=y\n    cur+=x\nif sm>m:\n    print(-1)\n    quit()\ncnt=0\na.sort(key=lambda x: -x[0]+x[1])\ni = 0\nwhile cur>m and i < n:\n    cur -= a[i][0]-a[i][1]\n    cnt += 1\n    i += 1\nprint(cnt)",
    "complexity": "nlogn",
    "problem": "1015_C",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "import sys\n\nn, m, k = map(int, input().split())\ntable = [input() for _ in range(n)]\n\ndp = [0]*(k+1)\n\nfor a in table:\n    one = []\n    for i in range(m):\n        if a[i] == '1':\n            one.append(i)\n\n    if not one:\n        continue\n\n    ni = len(one)\n    subdp = [10**9] * (ni+1)\n    subdp[-1] = 0\n\n    for i in range(ni):\n        for j in range(i, ni):\n            subdp[ni-(j-i+1)] = min(subdp[ni-(j-i+1)], one[j]-one[i]+1)\n\n    next_dp = [10**9]*(k+1)\n    for i in range(k, -1, -1):\n        for j in range(ni+1):\n            if i+j > k:\n                break\n            next_dp[i+j] = min(next_dp[i+j], dp[i] + subdp[j])\n    dp = next_dp\n\nprint(min(dp))\n",
    "complexity": "cubic",
    "problem": "0946_D",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "n,k =  map(int,input().split())\n\ndef tonny(i) :\n\treturn (ord(i)-96)\na= sorted(input())\na=list(map(tonny,a))\na=sorted(list(set(a)))\nans=[a.pop(0)]\nk-=1\nfor j in a :\n\tif j-ans[-1] >1 and k>0 :\n\t\tk-=1\n\t\tans.append(j)\n\tif k==0 :\n\t\tbreak\nif k!=0 :\n\tprint(-1)\nelse:\n\tprint(sum(ans))\n",
    "complexity": "linear",
    "problem": "1011_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nstate = [list(map(int, input().split())) for _ in range(N)]\n\nAns = {}\n\nl = -1\nr = 10**9+1\nwhile r-l > 1:\n    m = (l+r)//2\n    T = {}\n    for j, S in enumerate(state):\n        bit = 0\n        for i, s in enumerate(S):\n            if s >= m:\n                bit += 1<<i\n        T[bit] = j\n    \n    ok = False\n    for bit1 in range(1<<M):\n        for bit2 in range(1<<M):\n            if bit1|bit2 == (1<<M)-1 and bit1 in T and bit2 in T:\n                ok = True\n                Ans[m] = [T[bit1], T[bit2]]\n                break\n        if ok: break\n    if ok:\n        l = m\n    else:\n        r = m\nprint(Ans[l][0]+1, Ans[l][1]+1)",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "n, m = map(int, input().split())\na = (n * (n - 1)) // 2\nn2 = n // 2\nb = n2 * (n2 + 1)\nif n % 2 == 0:\n    b -= n2\ns = 0\nfor i in range(m):\n    x, d = map(int, input().split())\n    s += x * n\n    s += d * (a if d > 0 else b)\n\nprint(s / n)\n",
    "complexity": "linear",
    "problem": "1009_C",
    "from": "CODEFORCES",
    "tags": "greedy,math"
}
{
    "src": "import math\n\ndef solutions(a,b,c):\n    d = (b**2) - (4*a*c)\n    sol1 = (-b-math.sqrt(d))/(2*a)\n    sol2 = (-b+math.sqrt(d))/(2*a)\n    if sol1<0 and sol2>0:\n        return sol2\n    elif sol1>0 and sol2<0:\n        return sol1\n    else:\n        return 0\n    \n    \n    \n\nx = input()\nx=x.split(\" \")\nc = int(x[0])\nm = int(x[1])\n\nprint(int(c-solutions(1,3,-(2*c+2*m))))\n\n\t\t\t\t  \t \t \t  \t   \t    \t\t\t  \t\t\t\t",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\n#from math import *\nfrom collections import defaultdict as dd, deque\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return map(int, data().split())\n#sys.setrecursionlimit(1000000)\nmod=int(1e9+7)\n\ndef bfs(x):\n    cnt=0\n    for i in tree[x]:\n        bfs(i)\n        cnt+=a[i]\n    if len(tree[x])==0:\n        cnt=1\n    a[x]=cnt\n\nn=int(data())\ntree=[{} for i in range(n)]\nif n>1:\n    P=list(mdata())\n    for i in range(n-1):\n        tree[P[i]-1][i+1]=0\n    a=[0]*n\n    for i in range(n-1,-1,-1):\n        if len(tree[i])==0:\n            a[i]=1\n        else:\n            for j in tree[i]:\n                a[i]+=a[j]\n    a.sort()\nelse:\n    a=[1]\nprint(*a)",
    "complexity": "nlogn",
    "problem": "1056_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"
}
{
    "src": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Feb 15 19:45:38 2019\n\n@author: avina\n\"\"\"\n\nn = int(input())\n\nl = []\nfor _ in range(n):\n    k,m = map(int, input().strip().split())\n    l.append((k,m))\n\nl.sort(key=lambda x:x[0]+x[1])\n\nlast = 0\nans = 1\n\nfor i in range(1,n):\n   if l[i][0] - l[i][1] >= l[last][0] - l[last][1] and abs(l[i][0] - l[last][0]) >= l[i][1] + l[last][1] :\n       last = i\n       ans = ans + 1\n       \nprint(ans)",
    "complexity": "nlogn",
    "problem": "0528_B",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n=int(input())\nd,l,m,a=[0]*(n+1),[0]*2,[0]*(n+1),0\nfor _ in range(n-1):\n    a=int(input())\n    l.append(a)\n    m[a]+=1\nfor i in range(1,n+1):\n    if m[i]==0:\n        d[l[i]]+=1\nfor i in range(1,n+1):\n    if m[i]>0 and d[i]<3:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")",
    "complexity": "linear",
    "problem": "0913_B",
    "from": "CODEFORCES",
    "tags": "implementation,trees"
}
{
    "src": "MAXN = 200001\nn, m = map(int, input().split(' '))\ns = list(map(int, input().split(' ')))\n\nf = [0 for i in range(n+1)]\ncount = [0 for i in range(-MAXN, MAXN+1)]\n\nf[0] = 0\n\nlast = 0\nres = 0\n\n#print(n, m, s)\n\nfor i in range(1, n+1):\n    if s[i-1] == m:\n        for j in range(last, i):\n            count[f[j]] += 1\n        last = i\n\n    if s[i-1] > m:\n        f[i] = f[i-1] - 1\n    else:\n        f[i] = f[i-1] + 1\n\n    #print(i, last, count[f[i]] + count[f[i]-1])\n    res += count[f[i]] + count[f[i]-1]    \n\n#print(f)\nprint(res)\n\n\n\n",
    "complexity": "nlogn",
    "problem": "1005_E1",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "import sys\nimport math\ninput = sys.stdin.readline\n\nn,q=map(int,input().split())\n\narr=list(map(int,input().split()))\nfor i in range(n):\n\tarr.append(0)\nmaxx=0\n\nind=arr.index(max(arr))\nans=[]\nptr1=0\nptr2=n\nfor i in range(ind):\n\tans.append([arr[ptr1],arr[ptr1+1]])\n\tif arr[ptr1]>arr[ptr1+1]:\n\t\tarr[ptr2]=arr[ptr1+1]\n\t\tarr[ptr1+1]=arr[ptr1]\n\telse:\n\t\tarr[ptr2]=arr[ptr1]\n\tptr1+=1\n\tptr2+=1\n#print(arr)\nfor i in range(q):\n\tm=int(input())\n\n\tif m<=ind:\n\t\tprint(*ans[m-1])\n\telse:\n\t\tm-=ind\n\t\tm=m%(n-1)\n\t\tif m==0:\n\t\t\tm+=n-1\n\t\tprint(arr[ind],arr[ind+m])",
    "complexity": "linear",
    "problem": "1180_C",
    "from": "CODEFORCES",
    "tags": "data structures,implementation"
}
{
    "src": "\ndef naiveSolve():\n    \n    \n    \n    return\n\n\n\ndef main():\n    \n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n,m=readIntArr()\n        grid=[]\n        for __ in range(n):\n            grid.append(readIntArr())\n        columns=[]\n        for col in range(m):\n            temp=[grid[i][col] for i in range(n)]\n            columns.append(temp)\n        \n        valCol=[] # (value, column)\n        for i in range(n):\n            for j in range(m):\n                valCol.append((grid[i][j],j))\n        valCol.sort(reverse=True)\n        \n        # try all possible shifts for top n columns\n        topCols=set()\n        for val,col in valCol:\n            topCols.add(col)\n            if len(topCols)==n:\n                break\n        \n        # try all configurations\n        m2=len(topCols)\n        grid2=[[-1 for __ in range(m2)] for ___ in range(n)]\n        topColsList=list(topCols)\n        for j in range(m2):\n            col=topColsList[j]\n            for i in range(n):\n                grid2[i][j]=grid[i][col]\n        ans=-inf\n        for mask in range(n**m2):\n            grid3=[[-1 for __ in range(m2)] for ___ in range(n)]\n            for col in range(m2):\n                shift=mask%n\n                for row in range(n):\n                    grid3[row][col]=grid2[(shift+row)%n][col]\n                mask//=n\n            tempAns=0\n            for row in range(n):\n                maxx=-inf\n                for col in range(m2):\n                    maxx=max(maxx,grid3[row][col])\n                tempAns+=maxx\n            ans=max(ans,tempAns)\n        allans.append(ans)\n        \n    multiLineArrayPrint(allans)\n    \n    return\n\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(r):\n    print('? {}'.format(r))\n    sys.stdout.flush()\n    return readIntArr()\n \ndef answerInteractive(adj,n):\n    print('!')\n    for u in range(1,n+1):\n        for v in adj[u]:\n            if v>u:\n                print('{} {}'.format(u,v))\n    sys.stdout.flush()\n \ninf=float('inf')\nMOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()",
    "complexity": "np",
    "problem": "1209_E1",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,dp,greedy,sortings"
}
{
    "src": "n = int(input())\n\nd = {}\n\nfor i in range(n-1):\n\ta,b = map(int,input().split())\n\n\ttry:\n\t\td[a].append(b);\n\texcept:\n\t\td[a] = [b]\n\ttry:\n\t\td[b].append(a);\n\texcept:\n\t\td[b] = [a]\n\narray = list(map(int,input().split()))\nflag=0;\n\nif array[0]==1:\n\n\ti = 1;\n\tj = 0;\n\n\twhile ( j < n and i < n ):\n\t\tif ( array[j] in d[array[i]] ):\n\t\t\ti+=1;\n\t\telse:\n\t\t\tj+=1;\n\tif j==n and i!=n:\n\t\tflag=1;\nelse:\n\tflag=1;\n\nif flag==1:\n\tprint(\"No\")\nelse:\n\tprint(\"Yes\")",
    "complexity": "linear",
    "problem": "1037_D",
    "from": "CODEFORCES",
    "tags": "dfs and similar,graphs,shortest paths,trees"
}
{
    "src": "\nimport sys\ninput = sys.stdin.readline\nq=int(input())\nfor i in range(q):\n  n,k=map(int,input().split())\n  s=input()\n  a=k\n  for j in range(n-k+1):\n    a1,a2,a3=0,0,0\n    for jj in range(k):\n      if jj%3==0:\n        if s[j+jj]==\"R\":\n          a2+=1\n          a3+=1\n        elif s[j+jj]==\"G\":\n          a1+=1\n          a3+=1\n        else:\n          a1+=1\n          a2+=1\n      elif jj%3==1:\n        if s[j+jj]==\"R\":\n          a1+=1\n          a2+=1\n        elif s[j+jj]==\"G\":\n          a2+=1\n          a3+=1\n        else:\n          a3+=1\n          a1+=1\n      else:\n        if s[j+jj]==\"R\":\n          a1+=1\n          a3+=1\n        elif s[j+jj]==\"G\":\n          a1+=1\n          a2+=1\n        else:\n          a3+=1\n          a2+=1\n    a=min(a,a1,a2,a3)\n  print(a)\n      \n\n\n",
    "complexity": "quadratic",
    "problem": "1196_D1",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n=int(input())\na=(n//2)*3\nprint(a)",
    "complexity": "constant",
    "problem": "0084_A",
    "from": "CODEFORCES",
    "tags": "math,number theory"
}
{
    "src": "a = input()\nb = input()\nla = [int(x) for x in a]\nres = []\nla.sort()\nla = la[::-1]\nlb = [int(x) for x in b]\ncnt = [0] * 20\n\ndef check():\n    tres = 0\n    for x in range(len(res)):\n        tres *= 10\n        tres += int(res[x])\n    return tres <= int(b)\nif len(a) < len(b):\n    for i in range(len(la)):\n        print(la[i], end = '')\n    print()\nelse:\n    for i in range(len(la)):\n        cnt[la[i]] += 1\n    flag = 0\n    for i in range(len(lb)):\n        if flag == 0 and cnt[lb[i]]:\n            res.append(lb[i])\n            cnt[lb[i]] -= 1\n        else:\n            flag = i - 1\n            for j in range(lb[i] - 1, -1, -1):\n                if cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n                    break\n            for j in range(9, -1, -1):\n                while cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n            break\n    while not check():\n        temp = []\n        cnt = [0] * 20\n        for x in range(flag):\n            temp.append(res[x])\n            cnt[res[x]] -= 1\n        for i in la:\n            cnt[i] += 1\n        ##print(\"cnt = \", cnt)\n        res = temp\n        ##print(flag, res)\n        for v in range(lb[flag] - 1, -1, -1):\n            if cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n                break\n        for v in range(9, -1, -1):\n            while cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n        ##print(flag, res)\n        flag -= 1\n    for i in range(len(res)):\n        print(res[i], end = '')\n    print()",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import math\nfrom decimal import Decimal, ROUND_FLOOR\n\ndef sum2(s, e):\n    return sum1(e) - sum1(s - 1) - (e - s)\n\ndef sum1(i):\n    return i * (i + 1) / 2\n\nn, k = map(Decimal, input().split())\n\nif(n == 1):\n    print(0)\nelif(k > n):\n    print(1)\nelif(sum2(Decimal(2),k) < n):\n    print(-1)\nelse:\n    c = 2 * n + k - k * k\n    discriminant = (9 - 4 * c).sqrt()\n    res1 = int(((3 + discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))\n    res2 = int(((3 - discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))\n    res1 = max(res1, res2)\n    print(k - res1 + 1);",
    "complexity": "logn",
    "problem": "0287_B",
    "from": "CODEFORCES",
    "tags": "binary search,math"
}
{
    "src": "l,r = [int(i) for i in input().split()]\nbitafter=-1;\nfor i in range(60,-1,-1):\n    if(l&(1<<i)!=r&(1<<i)):\n        bitafter = i\n        break\nres = 0\nwhile(bitafter>=0):\n    res+=1<<bitafter\n    bitafter-=1\nprint(res)",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "n = int(input())\nb = list(map(int, input().split()))\nff = []\nss = []\nfor i in  b[::-1]:\n    q = i\n    f = q // 2\n    if q % 2:\n        s = f + 1\n    else:\n        s = f\n    if len(ff) == 0:\n        ff = [f]\n        ss = [s]\n    else:\n        if f > ff[-1] or s < ss[-1]:\n            d = max(f - ff[-1], ss[-1] - s)\n            f -= d\n            s += d\n        ff.append(f)\n        ss.append(s)\nprint(*(ff[::-1] + ss))",
    "complexity": "linear",
    "problem": "1093_C",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "modulo = 1000 ** 3 + 7\n\n\ndef mat_oz(x, k):\n    if k == 0:\n        return (2 * x) % modulo\n    if x == 0:\n        return 0\n    b = (pow(2, k, modulo) * (2 * x - 1) + 1) % modulo\n    return b\n\n\ny, m = [int(i) for i in input().split()]\nprint(mat_oz(y, m))\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n,m=map(int,input().split())\nl=list()\nr=list()\nfor _ in range(m):\n    a,b=map(int,input().split())\n    l.append(a)\n    r.append(b)\nfor i in range(n):\n    if(i%2==0):\n        print(0,end='')\n    else:\n        print(1,end='')\n",
    "complexity": "linear",
    "problem": "1004_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,greedy,implementation,math"
}
{
    "src": "x, k = map(int, input().split())\nmod = 1000000007\nif (k == 0):\n    print((2 * x) % mod)\nelif (x == 0):\n    print(0)\nelse:\n    ans = ((2 * x - 1) * pow(2, k, mod) + 1) % mod\n    print(ans)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import math\nk,n,s,p=[int(x) for x in input().split()]\nx=math.ceil(n/s)\ny=math.ceil(x*k/p)\nprint(y)",
    "complexity": "constant",
    "problem": "0965_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n = int(input())\nlst = list(map(int,input().split()))\nlst.sort()\nlst.reverse()\nm = 0\nfor i in range(n):\n  if sum(lst[:i]) > sum(lst[i:]):\n    break\n  else:\n    m+=1\nprint(m)",
    "complexity": "nlogn",
    "problem": "0160_A",
    "from": "CODEFORCES",
    "tags": "greedy,sortings"
}
{
    "src": "import sys;\ndef transform(c):\n\tif c == '.': return 0;\n\tif c == '#': return 1;\n\treturn 2;\n\ndef take_care(board,n,m):\n\tif n + 2 >= N:\n\t\treturn;\n\tif m + 2 >= M:\n\t\treturn;\n\tif board[n][m+1] == 0 or board[n][m+2] == 0 or board[n+1][m] == 0 or board[n+1][m+2] == 0 or board[n+2][m] == 0 or board[n+2][m+1] == 0 or board[n+2][m+2] == 0:\n\t\treturn;\n\tboard[n][m] = 2\n\tboard[n][m+1] = 2\n\tboard[n][m+2] = 2\n\tboard[n+1][m] = 2\n\tboard[n+1][m+2] = 2\n\tboard[n+2][m] = 2\n\tboard[n+2][m+1] = 2\n\tboard[n+2][m+2] = 2\n\treturn False,board;\n\nN,M = [int(i) for i in input().strip().split()];\nboard = [];\nfor n in range(N):\n\trow = input().strip();\n\trow = [ transform(c) for c in row];\n\tboard.append(row);\n#print('board = ');\n#print(board);\nfor n in range(N):\n\tfor m in range(M):\n\t\ttake_care(board,n,m);\nfor row in board:\n\tif 1 in row:\n\t\tprint('NO');\n\t\tsys.exit();\nprint('YES');\n",
    "complexity": "quadratic",
    "problem": "1059_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n, k = map( int, input().split() )\n\nd = n - k\nd = d // 2\n\nl = []\n\nwhile n > 0:\n    i = min(n,d)\n    while i>0:\n        l.append('1')\n        i -= 1\n        n -= 1\n    if n > 0:\n        l.append('0')\n        n -= 1\n\nprint( \"\".join( l ) )",
    "complexity": "quadratic",
    "problem": "1159_D",
    "from": "CODEFORCES",
    "tags": "brute force,greedy,constructive algorithms,math,strings"
}
{
    "src": "x, y, z, t1, t2, t3 = map( int, input().split() )\nelevator = t2 * ( abs( x - y ) + abs( z - x ) ) + 3 * t3\nstairs = t1 * abs( x - y )\nif elevator > stairs:\n    print( 'NO' )\nelse:\n    print( 'YES' )\n",
    "complexity": "constant",
    "problem": "1054_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "from itertools import combinations\nn, l, r, x = map(int,input().split())\na = list(map(int,input().split()))\nprint(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\ndef main():\n    # mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n   \n\n    tc=1\n    for _ in range(tc):\n        n=ri()\n        ans=[]\n        i=1\n        k=1\n        t=0\n        while True:\n            k=i*i\n            if k<=n:\n                t=i\n            else:\n                break\n            i+=1\n        a=[]\n        z=[]\n        for i in range(n):\n            z+=[i+1]\n            if len(z)==t:\n                a=z+a\n                z=[]\n        a=z+a\n        wia(a)\n        \n        \n\n            \n                    \n                \n        \n        \n            \n                \n        \n\n            \n        \n\n               \n            \n        \n              \n                \n        \n        \n            \n        \n        \n            \n            \n        \n        \n                \n                \n                \n                \n            \n        \n        \n            \n           \n        \n            \n                    \n\n                                 \n                \n                \n        \n\n                \n        \n        \n        \n            \n        \n        \n                \n            \n        \n        \n                    \n        \n        \n        \n            \n                    \n            \n\n                \n            \n            \n                \n            \n                \n            \n            \n            \n            \n                \n            \n        \n        \n        \n        \n        \n        \n        \n                    \n        \n        \n        \n                \n                \n        \n            \n            \n            \n        \n\n                    \n        \n                \n        \n        \n                        \n        \n                            \n\n        \n\n                \n            \n        \n\n                \n            \n                    \n                \n                \n        \n        \n         \n        \n\n                        \n                            \n                \n        \n                            \n                    \n\n                \n            \n        \n                \n            \n                \n        \n        \n        \n                             \n        \n            \n        \n        \n            \n                        \n                        \n                    \n            \n        \n        \n        \n        \n        \n                        \n       \n\n        \n                           \n        \n        \n        \n            \n        \n        \n        \n                      \n\n      \n                            \n            \n        \n        \n            \n            \n            \n            \n            \n        \n        \n        \n            \n        \n        \n        \n            \n        \n        \n        \n        \n            \n            \n        \n        \n        \n        \n        \n        \n        \n                \n                \n                    \n        \n        \n            \n            \n        \n                \n            \n            \n        \n        \n        \n        \n                \n        \n            \n        \n                \n        \n        \n            \n        \n       \n            \n\n                \n        \n        \n        \n   \n            \n        \n        \n        \n        \n            \n        \n                \n        \n        \n        \n            \n            \n        \n        \n            \n        \n        \n\n        \n        \n            \n        \n        \n            \n        \n                        \n\n        \n        \n            \n     \n        \n        \n            \n        \n        \n                \n            \n        \n        \n        \n                \n            \n        \n\n            \n             \n        \n            \n        \n        \n        \n                \n        \n            \n        \n        \n        \n        \n                \n        \n        \n            \n        \n        \n        \n        \n                \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    ",
    "complexity": "linear",
    "problem": "1017_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,greedy"
}
{
    "src": "n=int(input())\nl=list(map(lambda x:int(x)*2,input().split(\" \")))\nt=list(map(lambda x:\"GWL\".index(x),input()))\nmins=[0 for i in range(0,n+1)]\nfor i in range(n-1,-1,-1):\n\tif t[i]!=2:mins[i]=max(mins[i+1]-l[i],0)\n\telse:mins[i]=mins[i+1]+l[i]\ncurs=ans=st=0\nfor i in range(0,n):\n\tif(t[i]==0):\n\t\tcurs+=l[i];ans+=l[i]*5\n\t\tif(curs>mins[i+1]):\n\t\t\tol=(curs-mins[i+1])//2\n\t\t\tol=min(ol,l[i])\n\t\t\tans-=4*ol;curs-=2*ol\n\tif(t[i]==1):\n\t\tst=1;curs+=l[i];ans+=l[i]*3\n\tif(t[i]==2):\n\t\tif(curs<l[i]):\n\t\t\tol=l[i]-curs;curs=l[i]\n\t\t\tans+=ol*(3 if st else 5)\n\t\tcurs-=l[i];ans+=l[i]\nif curs>0:ans-=curs//2*2\nprint(ans//2)",
    "complexity": "linear",
    "problem": "1091_F",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,greedy"
}
{
    "src": "def get_input_list():\n\treturn list(map(int, input().split()))\n\nn = int(input())\nl = get_input_list()\nr = get_input_list()\n\na = [0 for _ in range(n)]\nm = []\nm_ = []\nfor i in range(n):\n\tm.append(l[i] + r[i])\n\tm_.append(l[i] + r[i])\nm.sort()\nma = m[-1] + 1\n\nfor i in range(n):\n\ta[i] = ma - m_[i]\n\nl_ = []\nr_ = []\nfor i in range(n):\n\tc = 0\n\td = 0\n\tfor j in range(i+1):\n\t\tif a[j] > a[i]:\n\t\t\tc += 1\n\tfor j in range(i,n):\n\t\tif a[j] > a[i]:\n\t\t\td += 1\n\tl_.append(c)\n\tr_.append(d)\nres = True\nfor i in range(n):\n\tif l[i] != l_[i] or r[i] != r_[i]:\n\t\tres = False\n\t\tbreak\nif res:\n\tprint(\"YES\")\n\tfor i in range(n):\n\t\ta[i] = str(a[i])\n\tprint(\" \".join(a))\nelse:\n\tprint(\"NO\")",
    "complexity": "quadratic",
    "problem": "1054_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation"
}
{
    "src": "a,b,c,n=list(map(int,input().split()))\np=(a+b-c)\nf=n-p\nif p>=n or c>a or c>b:\n\tprint(\"-1\")\nelse:\n\tprint(f)",
    "complexity": "constant",
    "problem": "0991_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "q = int(input())\nfor i in range(q):\n    x, y, k = map(int, input().split())\n    if x > y: x, y = y, x\n    m = y\n    d = y\n    if (y - x) % 2 == 1:\n        d -= 1\n    if k < m:\n        print(-1)\n        continue\n    r = k - m\n    if r % 2 != 0:\n        r -= 1\n        if d != m:\n            d += 1\n        else:\n            d -= 1\n    d += r\n    print(d)\n",
    "complexity": "constant",
    "problem": "1036_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nfor t in range(ii()):\n    n, k = mi()\n    if n == 1:\n        ans = 'YES 0' if k == 1 else 'NO'\n    elif n == 2:\n        if k <= 2:\n            ans = 'YES 1'\n        elif k == 3 or k > 5:\n            ans = 'NO'\n        else:\n            ans = 'YES 0'\n    elif n <= 32 and k > (4 ** n - 1) // 3:\n        ans = 'NO'\n    else:\n        c, x = 0, n\n        p2 = 2\n        while x > 0:\n            if c + p2 - 1 > k:\n                break\n            c += p2 - 1\n            x -= 1\n            p2 *= 2\n        ans = 'YES %d' % (x,)\n    print(ans)\n",
    "complexity": "linear",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "print(25)",
    "complexity": "constant",
    "problem": "0630_A",
    "from": "CODEFORCES",
    "tags": "number theory"
}
{
    "src": "import math,sys,bisect,heapq\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\nfrom functools import lru_cache\n#sys.setrecursionlimit(200000000)\nint1 = lambda x: int(x) - 1\n#def input(): return sys.stdin.readline().strip()m\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\naj = lambda: list(map(int, input().split()))\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n#MOD = 1000000000 + 7\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\ndef fun(A):\n    for i in range(len(A)):\n        if A[i] == 0:\n            return i\n    return 1\n    \n    \ndp = [0]*10\nA = aj();A.sort()\nk1,k2,k3 = A\nfor i in range(0,10,k1):\n    dp[i] = 1\nfor i in range(fun(dp),10,k2):\n    dp[i] = 1\nfor i in range(fun(dp),10,k3):\n    dp[i] = 1\nY(0 not in dp)\n    \n    ",
    "complexity": "constant",
    "problem": "0911_C",
    "from": "CODEFORCES",
    "tags": "brute force,constructive algorithms"
}
{
    "src": "def pwr(a,n,m):\n    if n==0:return 1\n    ans=pwr(a,n//2,m)\n    ans=ans*ans\n    ans%=m\n    if n%2==1:return (ans*a)%m\n    else: return ans\nM=1000000007\ntx,tn=input().split()\nx=int(tx)\nn=int(tn)\nans=pwr(2,n+1,M)*x\nans%=M\nans=ans-pwr(2,n,M)+1\nans=(ans+M)%M\nif x==0: ans=0\nprint(ans)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\n\ndef sol(a,b):\n\tfor square in [a,b]:\n\t\tfor i1 in range(4):\n\t\t\ti2 = (i1 + 1)%4\n\t\t\tp1,p2 = square[i1],square[i2]\n\t\t\t\n\t\t\tnorm = (p2[1]-p1[1],p1[0]-p2[0])\n\n\t\t\tminA = maxA = minB = maxB = None\n\t\t\tfor p in a:\n\t\t\t\tproj = norm[0] * p[0] + norm[1] * p[1]\n\t\t\t\tif minA == None or proj < minA:\n\t\t\t\t\tminA = proj\n\t\t\t\tif maxA == None or proj > maxA:\n\t\t\t\t\tmaxA = proj\n\t\t\tfor p in b:\n\t\t\t\tproj = norm[0] * p[0] + norm[1] * p[1]\n\t\t\t\tif minB == None or proj < minB:\n\t\t\t\t\tminB = proj\n\t\t\t\tif maxB == None or proj > maxB:\n\t\t\t\t\tmaxB = proj\n\n\t\t\tif maxA < minB or maxB < minA:\n\t\t\t\treturn False\n\treturn True\n\nx11,y11,x12,y12,x13,y13,x14,y14 = list(map(int,sys.stdin.readline().strip().split(' ')))\nx21,y21,x22,y22,x23,y23,x24,y24 = list(map(int,sys.stdin.readline().strip().split(' ')))\n\na = [(x11,y11), (x12,y12), (x13,y13), (x14,y14)]\nb = [(x21,y21), (x22,y22), (x23,y23), (x24,y24)]\n\nprint([\"NO\",\"YES\"][sol(a,b)])",
    "complexity": "constant",
    "problem": "0994_C",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "N = 10**5+5\nMOD = 10**9+7\n\nfreq = [0 for i in range(N)]\n\n# Calculating {power(2,i)%MOD} and storing it at ith pos in p2 arr\np2 = [0 for i in range(N)]\np2[0] = 1\nfor i in range(1,N):\n    p2[i] = p2[i-1]*2\n    p2[i]%=MOD\n\ndef Calculate_Mobius(N):\n    arr = [1 for i in range(N+1)]\n    prime_count = [0 for i in range(N+1)]\n\n    mobius_value = [0 for i in range(N+1)]\n    for i in range(2,N+1):\n        if prime_count[i]==0:\n            for j in range(i,N+1,i):\n                prime_count[j]+=1\n                arr[j] = arr[j] * i\n\n    for i in range(1, N+1):\n        if arr[i] == i:\n            if (prime_count[i] & 1) == 0:\n                mobius_value[i] = 1\n            else:\n                mobius_value[i] = -1\n        else:\n            mobius_value[i] = 0\n\n    return mobius_value\n\n# Caluclating Mobius values for nos' till 10^5\nmobius = Calculate_Mobius(N)\nn = int(input())\nb = [int(i) for i in input().split()]\n\n# Storing freq of I/p no.s in array  \nfor i in b:\n    freq[i]+=1\n\nans = 0\nfor i in range(1,N):\n    # Count no of I/p no's which are divisible by i\n    cnt = 0\n    for j in range(i,N,i):\n        cnt += freq[j]\n    \n    total_subsequences = p2[cnt] - 1\n    ans = (ans + (mobius[i] * total_subsequences)%MOD)%MOD\n\n# Dealing if ans is -ve due to MOD\nans += MOD\nprint(ans%MOD)\n\n",
    "complexity": "np",
    "problem": "0803_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,combinatorics,number theory"
}
{
    "src": "n = int(input())\nl = list(map(int, input().split()))\nansl = ['sjfnb', 'cslnb']\nans = -1\nd = dict()\nval = 0\nif n == 1:\n    ans = (l[0] + 1) % 2\nelse:\n    l.sort()\n    for elem in l:\n        d[elem] = d.get(elem, 0) + 1\n    hm = 0\n    which = -1\n    i = 0\n    for elem in d.values():\n        if elem >= 2:\n            hm += 1\n            which = i\n        i += 1\n    which = list(d.keys())[which]\n    if max(d.values()) >= 3 or d.get(0, 0) >= 2 or hm > 1:\n        ans = 1\n    elif hm == 1 and d.get(which - 1, 0) > 0:\n        ans = 1\n    else:\n        for i in range(n):\n            val += l[i] - i\n        ans = (val + 1) % 2\nprint(ansl[ans])",
    "complexity": "nlogn",
    "problem": "1191_D",
    "from": "CODEFORCES",
    "tags": "games"
}
{
    "src": "import sys\nn,m=map(int,input().split())\nfor i in range(n//2):\n    for j in range(m):\n        sys.stdout.write('{} {}\\n'.format(*[i+1,j+1]))\n        sys.stdout.write('{} {}\\n'.format(*[n-i,m-j]))\nif n%2:\n    for j in range(m//2):\n        sys.stdout.write('{} {}\\n'.format(*[n//2+1,j+1]))\n        sys.stdout.write('{} {}\\n'.format(*[n//2+1,m-j]))\n    if m%2:\n        sys.stdout.write('{} {}\\n'.format(*[n//2+1,m//2+1]))",
    "complexity": "quadratic",
    "problem": "1179_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms"
}
{
    "src": "n,k = list(map(int,input().split()))\n\n# modulo divisor\nlimit = 998244353\n\n\nif k > 2*n:\n    print(0)\nelif k == 1 or k == 2*n:\n    print(2)\nelse:\n    same = [0] * (k+1)\n    same[1] = 2\n\n    diff = [0] * (k+1)\n    diff[2] = 2\n\n    for i in range(2, n+1):\n        for j in range(min(k, 2*i), 1, -1):\n\n            same[j] = same[j] + 2*diff[j] + same[j-1]\n            same[j] %= limit\n\n            diff[j] = diff[j] + 2*same[j-1] + diff[j-2]\n            diff[j] %= limit\n\n    print((same[k] + diff[k]) % limit)",
    "complexity": "np",
    "problem": "1051_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "def wzor(n):\n    return (n*(n+1))/2\n\ndef mafia():\n    pom = [int(x) for x in input().split()]\n    n = pom[0]\n    c = pom[1]\n\n    po = 1\n    ko = n\n    sr = (po + ko)//2\n    while po != ko:\n        if wzor(sr)-(n-sr) >= c:\n            ko = sr\n        else:\n            po = sr+1\n        sr = (po+ko)//2\n\n        \n    print(int(wzor(po)-c))\n\nmafia()\n",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "k,n,s,p = map(int,input().split())\nx = (n+s-1)//s\nx *= k\nprint((x+p-1)//p)\n\n\n",
    "complexity": "constant",
    "problem": "0965_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\nimport math\ninput=sys.stdin.readline\na=list(input())\nb=list(input())\nx=a.count('+')-b.count('+')\ny=a.count('-')-b.count('-')\nif x<0 or y<0:\n    print(0)\nelse:\n    fact=math.factorial(x+y)/(math.factorial(x)*math.factorial(y))\n    total=2**(x+y)\n    print(fact/total)\n\n\t\t\t \t    \t  \t  \t\t    \t   \t \t  \t",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "from itertools import chain, combinations, permutations\n\ndef powerset(iterable):\n    \"\"\"\n    powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\n    \"\"\"\n    xs = list(iterable)\n    # note we return an iterator rather than a list\n    return chain.from_iterable(combinations(xs,n) for n in range(len(xs)+1))\n\nn = int(input())\ncl1 = []\ncl2 = []\nfor i in range(n):\n  s = input()\n  a = []\n  for j in range(n):\n    a.append(s[j])\n  cl1.append(a)\n\nfor i in range(n):\n  s = input()\n  a = []\n  for j in range(n):\n    a.append(s[j])\n  cl2.append(a)\n\ndef copy(m):\n  res = []\n  for i in range(n):\n    a = []\n    for j in range(n):\n      a.append(m[i][j])\n    res.append(a)\n  return res\n\ndef pow(m):\n  res = []\n  for i in range(n):\n    a = []\n    for j in range(n):\n      a.append(m[n-1-j][i])\n    res.append(a)\n  return res\n  \ndef vert(m):\n  res = []\n  for i in range(n):\n    res.append(m[i][::-1])\n  return res\n  \ndef gor(m):\n  res = []\n  for i in range(n):\n    a = []\n    for j in range(n):\n      a.append(m[i][n-1-j])\n    res.append(a)\n  return res\n\ncomblist = [[1], []]\ncm = [pow, pow, pow, vert, gor]\ncm = list(powerset(cm))\nres = False\nif cl1 == cl2:\n  res = True\nelse:\n  for x in cm:\n    for y in permutations(x):\n      t = copy(cl1)\n      for z in y:\n        t = z(t)\n      if t==cl2:\n        res = True\n      \nif res:\n  print('Yes')\nelse:\n  print('No')",
    "complexity": "quadratic",
    "problem": "0958_A1",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "# Author : nitish420 --------------------------------------------------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\n\ndef main():\n    a=list(map(int,input()))\n    b=list(map(int,input()))\n    dff=len(b)-len(a)\n    if dff<0:\n        print(0)\n        exit()\n    lb=len(b)\n    c=[0]*(lb+1)\n    for i in range(lb):\n        c[i+1]=c[i]+b[i]\n    ans=0\n    for i in range(len(a)):\n        item=a[i]\n        if item:\n            ans+=(dff+1-(c[dff+i+1]-c[i]))\n        else:\n            ans+=(c[dff+i+1]-c[i])\n\n    print(ans)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\n\n\n\n# endregion\n\nif __name__ == '__main__':\n    main()",
    "complexity": "linear",
    "problem": "0608_B",
    "from": "CODEFORCES",
    "tags": "combinatorics,strings"
}
{
    "src": "def bs(n, k, lo, hi):\n    \n    while lo <= hi: \n        mid = (hi + lo)//2\n        # print(lo, hi, mid)\n        # print('start')\n        # ks = range(mid, k+1)\n        # print('end')\n        # print('start')\n        # summ = (mid + k) * ((k - mid +1)/2) - (k-2)\n        # summ = (-mid * (mid -1) + k * (k + 1))/2 - (k-2)\n        summ = ((k * (k + 1))//2 - 1) - (((mid-1) * (mid))//2 -1) - (k-2)\n        # kk = k\n        # summ = 0\n        # while kk > 0:\n        #     summ += summ\n        #     kk -=1\n        # summ = summ - (k-2)\n        # summ = sum(ks) - (len(ks) - 1)\n        # print('end')\n        # print(list(range(mid, k+1)))\n        # print(summ, n)\n        # print(mid, k, (summ), 'mid')\n        if summ == n: \n            # print('done')\n            return k - mid + 1\n            # print(f'result: {k - mid + 1}')\n            # break\n        if summ > n: \n            # print('hi')\n            lo = mid + 1\n            # print(lo, hi, (hi + lo)//2)\n            \n        elif summ < n:\n            hi = mid - 1\n            # print((hi + lo)//2 , 'yarab', lo, hi)\n            # print('lala')\n            # print(summ)\n    # print(lo, 'i am the mid')\n    # if n - summ == 1:\n    #     print('there') \n    #     return -1\n    # summ = ((k * (k + 1))//2 - 1) - ((((mid+1)-1) * ((mid+1)))//2 -1) - (k-2)\n    # print(summ, 'yalla')\n    # print(mid, 'lol')\n    # print(k - mid)\n    # print('yo')\n    if summ > n: \n       mid += 1\n    return k - mid + 1\n    # print(f'result: {k - mid + 2}')\n\n\n\ndef solve():\n    n, k = map(int, input().split())\n    # n, k = 499999999500000000, 1000000000\n    # n, k = 8, 4\n    if n == 1: return 0\n    elif (k * (k + 1)//2) - (k-2) <= n: \n        # print('here')\n        return -1\n    elif k >= n: return 1\n    else: \n        return bs(n, k, 2, k)\n\nprint(solve())",
    "complexity": "logn",
    "problem": "0287_B",
    "from": "CODEFORCES",
    "tags": "binary search,math"
}
{
    "src": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Dec 14 13:18:46 2020\n\n@author: yash\n\"\"\"\n\"\"\"\n __  __ _                   \n|  \\/  (_)_ __ ___  _ __    \n| |\\/| | | '__/ _ \\| '_ \\  \n| |  | | | | | (_) | | | | \n|_|  |_|_|_|  \\___/|_| |_|  \n\"\"\"\n\"\"\"\n \n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u258c\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u25d0\u25d0\u25d0\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580\u2580\u2580\u2580\ud83d\udd25\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u258c\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u258c\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2584\u2588\u2588\u2588\u2588\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u25d0\u25d0\u25d0\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580\u2580\u2580\u2580\ud83d\udd25\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\"\"\"\n\"\"\"\n \n \n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@#@@#@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##@M@M # #@@@M@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@#@@ @@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@### #@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@B@@#@@@@@#M@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@##@@M@#@@##@##@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#M@@@@@##@M@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##@@@@@@#@##@#@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#  @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@  #\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @# @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @# @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@  #\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#  @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@ @@#@@#@@@@@@@@@@@@@@@@@#@@#@#@@@@@@@@@@@@@@@@@@@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@\n @ #@@@@@@@@@@@@@@@@@@@@#@@@@@@#@@@@@@@@@@@@@@@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@ @@#@#@@@@@@@@@@@@@@@@@@#@####@@@@@@@@@@@@@@@@@M@#@@#@#@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@#@#M@@@M@@@@@@@@@@@@@@@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n#@M@#@#@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@M@@M@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@#@@#@@@@@@@@@@@@@@@@@@@@M@M@#@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@\n@@#@@#@@@@@@@@@@@@@@@@@@@@@@@M@                   @M@@#@@@@@@@@@@@@@@@@@@@@@@@@@\n@#@@@@@#@@@@@@@@@@@@@@@@@@@#@@                     @@@@M@@@@@@@@@@@@@@@@@@@@@@@@\n@@@#@@@##@@@#@@@@@#@@@@@##@@@@                     #@#@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@####@@####@@@@#@@@@M@@@#@@#                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@#@          @#@@#@@@       #@             @       #@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                            @#           @@#@@     #@@#@@@@@@@@@@@@@@@@@@@@@@@@@\n                     ##@#@@ #M           @# @@     @@M  @@@@@@@@@@@@@@@@@@@@@@@@\n                     @#@@@M #@           #@   #    @@   @@@@@@@@@@@@@@@@@@@@@@@@\n                      @@ @@#@@           ##    @##@@    @@@@@@@@@@@@@@@@@@@@@@@@\n                      @#  @@M@           @@             @@@@@@@@@@@@@@@@@@@@@@@@\n    @@@##@@@          @@@@ @@@          @@               #@#@@#@@@@@@@@@@@@@@@@@\n@@@@###@@###@@@@#@#@@@@#@@@ M@          #@    @       B  @@@#@@@@@@@@@@@@@@@@@@@\n@M@@@@@MM@@@@@M@@#@##@@@#@@M@B          @#   M@   @# #@  #@@#@@@@@@@@@@@@@@@@@@@\n@#@#@@M@@M@@#@#@#@#@@#@#@#@@@@          @#   @@   #  @M  @#@@@@@@@@@@@@@@@@@@@@@\n@@@          @@@@#@##@     #@#          @M    #  @   @   @@@@@#@@@@@@@@@@@@@@@@@\n                            @@          @@   @#@@#@@#M   #@@@@#@@@@@@@@@@@@@@@@@\n                           M@#           #@   @@@@##@@ @M@#M@@@#@@@@@@@@@@@@@@@@\n                           @@@@           @@          @@@#@@@#@#@@@@@@@@@@@@@@@@\n                          @#  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                          @@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n   @M@H@@  @#        @#@@@@#@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@#@#@##@M@@@M@ @M#@@@@@#@@#@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n#M@@@##@@@@@@@@M@@@@#@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@#@@@@@M@#@M@@B#M@@M@###@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n###@@@@@@@@@# @#@@@@@@@#@@@#@##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@#@@M@@@#@@#@#@@@@@@#@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@M@#@# \n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@#\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@##\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@M\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n \n \n\"\"\"\n\"\"\"\n                          / \\  //\\\n            |\\___/|      /   \\//  \\\\\n            /0  0  \\__  /    //  | \\ \\    \n           /     /  \\/_/    //   |  \\  \\  \n           @_^_@'/   \\/_   //    |   \\   \\ \n           //_^_/     \\/_ //     |    \\    \\\n        ( //) |        \\///      |     \\     \\\n      ( / /) _|_ /   )  //       |      \\     _\\\n    ( // /) '/,_ _ _/  ( ; -.    |    _ _\\.-~        .-~~~^-.\n  (( / / )) ,-{        _      `-.|.-~-.           .~         `.\n (( // / ))  '/\\      /                 ~-. _ .-~      .-~^-.  \\\n (( /// ))      `.   {            }                   /      \\  \\\n  (( / ))     .----~-.\\        \\-'                 .~         \\  `. \\^-.\n             ///.----..>        \\             _ -~             `.  ^-`  ^-_\n               ///-._ _ _ _ _ _ _}^ - - - - ~                     ~-- ,.-~\n                                                                  /.-~\n \n\"\"\"\n\"\"\"\n  ____          _      _____                       \n / ___|___   __| | ___|  ___|__  _ __ ___ ___  ___ \n| |   / _ \\ / _` |/ _ \\ |_ / _ \\| '__/ __/ _ \\/ __|\n| |__| (_) | (_| |  __/  _| (_) | | | (_|  __/\\__ \\\n \\____\\___/ \\__,_|\\___|_|  \\___/|_|  \\___\\___||___/\n\"\"\"\n\"\"\"\n\u2591\u2591\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\n\u2591\u2584\u2580\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2591\u2588\u2591\n\u2591\u2588\u2591\u2584\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2584\u2591\u2588\u2591\n\u2591\u2588\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2588\u2591\n\u2591\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2591\n\u2584\u2588\u2580\u2588\u2580\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2580\u2580\u2588\u2588\u2588\n\u2588\u2588\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2588\u2588\n\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2580\u2591\u2591\u2591\u2591\u2580\u2588\u2591\u2591\u2591\u2591\u2588\u2588\n\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\u2588\n\u2591\u2580\u2588\u2588\u2588\u2584\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2588\u2588\u2588\u2580\u2591\n\u2591\u2591\u2591\u2580\u2588\u2588\u2584\u2591\u2580\u2588\u2588\u2580\u2591\u2584\u2588\u2588\u2580\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\"\"\"\n\"\"\"\u2591\u2591\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\n\u2591\u2584\u2580\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2591\u2588\u2591\n\u2591\u2588\u2591\u2584\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2584\u2591\u2588\u2591\n\u2591\u2588\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2588\u2591\n\u2591\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2591\n\u2584\u2588\u2580\u2588\u2580\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2580\u2580\u2588\u2588\u2588\n\u2588\u2588\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2588\u2588\n\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2580\u2591\u2591\u2591\u2591\u2580\u2588\u2591\u2591\u2591\u2591\u2588\u2588\n\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\u2588\n\u2591\u2580\u2588\u2588\u2588\u2584\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2588\u2588\u2588\u2580\u2591\n\u2591\u2591\u2591\u2580\u2588\u2588\u2584\u2591\u2580\u2588\u2588\u2580\u2591\u2584\u2588\u2588\u2580\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\"\"\"\n\"\"\"\n# Codeforces Round #186 (Div. 2), problem: (A) Ilya and Bank Account\n\n    n = int(input())\n    if n > 0:\n        print(n)\n    else:\n        s = str(n)\n        if s[len(s)-1] < s[len(s)-2] and s[len(s)-2] != '0':\n            print(int(s[:len(s)-2] + s[len(s)-1:]))\n        elif s[len(s)-1] > s[len(s)-2] and s[len(s)-1] != '0':\n            print(int(s[:len(s)-1]))\n        else:\n            print(int(s[:len(s)-1]))\n\"\"\"\n\n\n\"\"\"\n# Codeforces Round #261 (Div. 2), problem: (A) Pashmak and Garden,\n\nx1, y1, x2, y2=map(int,input().split())\nl=abs(x1-x2)\nm=abs(y1-y2)\nif x1==x2:\n    print(x1+m,y1,x2+m,y2)\nelif y1==y2:\n    print(x1,y1+l,x2,y2+l)\nelif l!=m: \n    print(-1)\nelse: \n    print(x1,y2,x2,y1)\n\"\"\"\n\n\n\"\"\"\n# Codeforces Round #142 (Div. 2), problem: (A) Dragons\n\ndef solve():\n    s, n = map(int, input().split())\n    sets = []\n    for _ in range(n):\n        ith, bonus = map(int, input().split())\n        sets.append([ith, bonus])\n    sets.sort(key=lambda x: x[0])\n    for i in sets:  \n        if i[0] < s:\n                s += i[1]\n        else:\n            return \"NO\"\n    return \"YES\"\nprint(solve())\n\"\"\"\n\"\"\"\n# Codeforces Round #690 (Div. 3)\n\n# (A) Favorite Sequence-\n\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        ans = []\n        k = n//2\n        start = 0\n        end = len(l)-1\n        while start <= end:\n            if start != end:\n                ans.append(l[start])\n                ans.append(l[end])\n            else:\n                ans.append(l[end])\n            start += 1\n            end -= 1\n        for i in ans:\n            print(i, end=\" \")\n        print()\n\n# B) Last Year's Substring-\n\n    for _ in range(int(input())):\n        n = int(input())\n        s = input()\n        if s[0]+s[1] == '20' and s[-2]+s[-1] == '20':\n            print(\"YES\")\n        elif s[0] == '2' and s[-3]+s[-2]+s[-1] == '020':\n            print(\"YES\")\n        elif s[0]+s[1]+s[2] == '202' and s[-1] == '0':\n            print(\"YES\")\n        elif s[0]+s[1]+s[2]+s[3] == '2020':\n            print(\"YES\")\n        elif s[-4]+s[-3]+s[-2]+s[-1] == '2020':\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\"\"\"\n\"\"\"\n# Codeforces Round #251 (Div. 2)\n   \n    n, d = map(int, input().split())\n    l = list(map(int, input().split()))\n    if (sum(l) + (n-1)*10) > d:\n        print(-1)\n    else:\n        print((d-sum(l))//5)\n\"\"\"\n\"\"\"\n# Codeforces Round #290 (Div. 2)\n\nn,m=map(int,input().split())\nfor i in range(n):\n    if i % 4 == 0:\n        print('#'*m)\n    elif i % 4 == 1:\n        print('.'*(m-1)+'#')\n    elif i % 4 == 2:\n        print('#'*m)\n    else:\n        print('#'+'.'*(m-1))\n        \n        \nn,m=map(int,input().split())\nfor i in range(n):\n    print(['#'*m,'.'*(m-1)+'#','#'*m,'#'+'.'*(m-1)][i%4])\n\n\"\"\"     \n\"\"\"\n# Educational Codeforces Round 100 (Rated for Div. 2)\n\n\n# problem: (A) Dungeon\n    def solve(a, b, c):\n        s = a+b+c\n        k = s//9\n        if s % 9 == 0 and a >= k and b >=k and c >= k:\n            return \"YES\"\n        else:\n            return \"NO\"\n            \n    for _ in range(int(input())):\n        a, b, c = map(int, input().split())\n        print(solve(a, b, c)) \n\n\n# problem: (B) Find The Array\n\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        even = 0\n        odd = 0\n        for i in range(len(l)):\n            if i % 2 == 0:\n                even += l[i]\n            else:\n                odd += l[i]\n        \n        if even < odd:\n            for i in range(len(l)):\n                if i % 2 == 0:\n                    l[i] = 1\n                    print(l[i], end=\" \")\n                else:\n                    print(l[i], end=\" \")\n        else:\n             for i in range(len(l)):\n                if i % 2 == 0:\n                    print(l[i], end=\" \")\n                else:\n                    l[i] = 1\n                    print(l[i], end=\" \")\n\n\"\"\"\n\n\n\n\"\"\"\n# Codeforces Beta Round #25 (Div. 2 Only), problem: (A) IQ test\n    n = int(input())\n    nums = list(map(int, input().split()))\n    even = 0\n    odd = 0\n    counter1 = 0\n    counter2 = 0\n    for i in range(len(nums)):\n        if nums[i]%2 == 0:\n            counter1+=1\n            even = i+1\n        else:\n            counter2+=1\n            odd = i+1\n        \n    if counter1 == 1:\n        print(even)\n    else:\n        print(odd)\n\"\"\"\n\n\"\"\"\n# Codeforces Round #246 (Div. 2), problem: (A) Choosing Teams\n\n    n, k = map(int, input().split())\n    l = list(map(int, input().split()))\n    counter = 0\n    for i in range(len(l)):\n        if (5-l[i]) >= k:\n            counter += 1\n    print(counter//3)\n\"\"\"\n\n\"\"\"\n # Codeforces Round #192 (Div. 2), problem: (A)   \n    r, c = map(int, input().split())\n    a = set()\n    b = set()\n    for i in range(r):\n        d = input()\n        for j in range(len(d)):\n            if d[j] == 'S':\n                a.add(j)\n                b.add(i)\n    \n    print(r*c - len(a)*len(b))\n\"\"\"\n\n\n# n, m = map(int, input().split())\n# b = []\n# for i in range(n):\n#     if min(list(map(int, input().split()))[1:]) < m:\n#         b.append(i + 1)\n# print(len(b), '\\n', *b)\n        \n\"\"\"\n # Codeforces Round #691 (Div. 2), problem: (A) Red-Blue Shuffle,\n    for i in range(int(input())):\n        n = int(input())\n        a = input()\n        b = input()\n        counter_a = 0\n        counter_b = 0\n        for j in range(len(a)):\n            if a[j] > b[j]:\n                counter_a += 1\n            elif a[j] < b[j]:\n                counter_b += 1\n        \n        if counter_a > counter_b:\n            print(\"RED\")\n        elif counter_a < counter_b:\n            print(\"BLUE\")\n        else:\n            print(\"EQUAL\")\n    \n\"\"\"\n\"\"\"\n# Codeforces Round #263 (Div. 2), problem: (A) Appleman and Easy Task\n    x = ''\n    for _ in range(int(input())):\n        x += input()\n        \n    if x == x[::-1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\"\"\"\n\"\"\"\n # Codeforces Round #226 (Div. 2), problem: (A) Bear and Raspberry\n    n, c = map(int, input().split())\n    l = list(map(int, input().split()))\n    ans = l[0] - l[1]\n    for i in range(1, len(l)-1):\n        ans = max(ans, l[i] - l[i+1])\n    if ans - c < 0:\n        print(0)\n    else:\n        print(ans-c)\n\"\"\"\n\n# n, k = map(int, input().split())\n# joy = float(\"-inf\")\n# for _ in range(n):\n#     f, t = map(int, input().split())\n#     if t >= k:\n#         joy = max(joy, f - (t - k))\n#     else:\n#         joy =  max(joy, f)\n# print(joy)\n\n\n\"\"\"\n# Codeforces Round #260 (Div. 2), problem: (A) Laptops,   \n    for _ in range(int(input())):\n        a,b=input().split()\n        if a!=b:\n            print('Happy Alex')\n            exit()\n    print('Poor Alex')\n\"\"\"\n\"\"\"\n# Technocup 2021 - Elimination Round 3:\n    \n    problem: (A) In-game Chat\n        for _ in range(int(input())):\n            n = int(input())\n            s = input()\n            j = len(s)-1\n            count = 0\n            while j >= 0:\n                if s[j] != ')':\n                    break\n                count += 1\n                j -= 1\n        \n            if count > len(s)-count:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\"\"\"\n\n\n# def solve(x):\n#     for i in str(x):\n#         if i != '0' and x % int(i) != 0:\n#             return False\n#     return True\n     \n# t = int(input())\n# for _ in range(t):\n#     n = int(input())\n#     while not solve(n):\n#         n += 1\n#     print(n)\n    \n\"\"\"\n # Codeforces Round #222 (Div. 2), problem: (A) Playing with Dice\n    a, b = map(int, input().split())\n    a_w = 0\n    b_w = 0\n    draw = 0\n    for i in range(1, 7):\n        if abs(i-a) < abs(i-b):\n            a_w += 1\n        elif  abs(i-a) > abs(i-b):\n            b_w += 1\n        else:\n            draw += 1\n    print(a_w, draw, b_w)\n\"\"\"\n\"\"\"\n# Codeforces Round #283 (Div. 2), problem: (A) Minimum Difficulty\n    n=int(input())\n    l=list(map(int,input().split()))\n    x=max([l[i+1]-l[i] for i in range(n-1)])\n    y=min([l[i+2]-l[i] for i in range(n-2)])\n    print(max(x,y))\n\"\"\"\n\"\"\"\n # Codeforces Round #156 (Div. 2), problem: (A) Greg's Workout\n        n = int(input())\n        arr = list(map(int, input().split()))\n        chest_count = 0\n        biceps_count = 0\n        back_count = 0\n        for i in range(len(arr)):\n            if i%3 == 0:\n                chest_count += arr[i]\n            elif i%3 == 1:\n                biceps_count += arr[i]\n            elif i%3 == 2:\n                back_count += arr[i]\n            \n        ans = max(chest_count, biceps_count, back_count)\n        \n        if chest_count == ans:\n            print(\"chest\")\n        elif biceps_count == ans:\n            print(\"biceps\")\n        else:\n            print(\"back\")\n            \n               OR\n\n        input()\n        arr = [int(i) for i in input().split()]\n        b = [sum(arr[::3]), sum(arr[1::3]), sum(arr[2::3])]\n        c = ['chest', 'biceps', 'back']\n        print(c[b.index(max(b))])\n    \n\"\"\"\n\nl, r = map(int, input().split())\nif r - l + 1 < 3:\n    print(-1)\n    exit()\nif l % 2 == 0:\n    print(l, l+1, l+2)\n    exit()\nif r - l + 1 > 3:\n    print(l+1, l+2, l+3)\n    exit()\nprint(-1)\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            \n\n        \n    \n            \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n ",
    "complexity": "constant",
    "problem": "0483_A",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,math,number theory"
}
{
    "src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n,m=map(int,input().split())\n    s,e,ans=[1,1],[n,m],[]\n    for i in range(n*m//2):\n        ans.append(s[:])\n        ans.append(e[:])\n        s[1],e[1]=s[1]+1,e[1]-1\n        if s[1]==m+1:\n            s=[s[0]+1,1]\n        if not e[1]:\n            e=[e[0]-1,m]\n    if (n*m)&1:\n        ans.append([s[0],s[1]])\n    for i in ans:\n        print(*i)\n\n     \n\n\n# FASTIO REGION\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()",
    "complexity": "quadratic",
    "problem": "1179_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms"
}
{
    "src": "# 803F\nimport math\nimport collections\ndef do():\n    n = int(input())\n    nums = map(int, input().split(\" \"))\n    count = collections.defaultdict(int)\n    for num in nums:\n        for i in range(1, int(math.sqrt(num))+1):\n            cp = num // i\n            if num % i == 0:\n                count[i] += 1\n            if cp != i and num % cp == 0:\n                count[cp] += 1\n    maxk = max(count.keys())\n    freq = {k: (1 << count[k]) - 1 for k in count}\n    for k in sorted(count.keys(), reverse=True):\n        for kk in range(k << 1, maxk+1, k):\n            freq[k] -= freq[kk] if kk in freq else 0\n    return freq[1] % (10**9 + 7)\n\nprint(do())",
    "complexity": "np",
    "problem": "0803_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,combinatorics,number theory"
}
{
    "src": "import sys\n\ninput = sys.stdin.readline\n\n\ndef intersection(segs):\n    end = float('inf')\n    start = - float('inf')\n    for l, r in segs:\n        end = min(end, r)\n        start = max(start, l)\n    return start, end\n\n\ndef solve():\n    n = int(input())\n    segs = [tuple([int(x) for x in input().split(' ')]) for s in range(n)]\n    starts = {}\n    ends = {}\n    x = intersection(segs)\n    for l, r in segs:\n        if r in starts:\n            starts[r] = max(starts[r], l)\n        else:\n            starts[r] = l\n        if l in ends:\n            ends[l] = min(ends[l], r)\n        else:\n            ends[l] = r\n\n    b = segs.copy()\n    b.remove((x[0], ends[x[0]]))\n    y = intersection(b)\n\n    c = segs.copy()\n    c.remove((starts[x[1]], x[1]))\n    z = intersection(c)\n\n    return max(x[1] - x[0], y[1] - y[0], z[1] - z[0], 0)\n\nprint(solve())\n",
    "complexity": "linear",
    "problem": "1029_C",
    "from": "CODEFORCES",
    "tags": "greedy,math,sortings"
}
{
    "src": "n = int(input())\n\npairs = [int(i) for i in input().split(\" \")]\n\nN=len(pairs)\nN//=2\nvisited = [False] * (N + 1)  \n  \nminimumSwaps = 0\n\nfor i in range(2 * N) :   \n    if (visited[pairs[i]] == False) :  \n        visited[pairs[i]] = True \n        count = 0 \n        for j in range( i + 1, 2 * N) :   \n            if (visited[pairs[j]] == False) : \n                count += 1 \n            elif (pairs[i] == pairs[j]) : \n                minimumSwaps += count \nprint(minimumSwaps)\n       \t\t\t  \t\t\t \t  \t\t \t \t   \t\t\t",
    "complexity": "quadratic",
    "problem": "0995_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "def main():\n\tl, r = map(int , input().split())\n\tif l == r :\n\t\tprint(0)\n\telse :\n\t\trs = \"\"\n\t\twhile (r):\n\t\t\trs += '1' if r%2 else '0'\n\t\t\tr //= 2\n\t\tfor i in range(len(rs), 65):\n\t\t\trs += '0' \n\t\t# rs = rs[::-1]\n\t\tls = \"\"\n\t\twhile (l):\n\t\t\tls += '1' if l%2 else '0'\n\t\t\tl //= 2\n\t\tfor i in range(len(ls), 65):\n\t\t\tls += '0'\n\t\t# ls = ls[::-1]\n\t\tpos = -1\n\t\tfor i in range(64, -1, -1):\n\t\t\t# print(rs[i], '#', ls[i])\n\t\t\tif (rs[i] == '1' and ls[i] == '0'):\n\t\t\t\tpos = i\n\t\t\t\tbreak\n\n\t\tans = 2**(pos+1) - 1\n\t\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "N = int(input())\nsrc = [tuple(map(int,input().split() + [i])) for i in range(N)]\nsrc.sort()\n\nprev_l = max_r = 0\nprev_i = outer = -1\nfor l,r,i in src:\n    if prev_l == l:\n        print(prev_i+1, i+1)\n        exit()\n    if r <= max_r:\n        print(i+1, outer+1)\n        exit()\n    else:\n        max_r = r\n        outer = i\n    prev_l = l\n    prev_i = i\nprint(-1,-1)\n",
    "complexity": "nlogn",
    "problem": "0976_C",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "def suma_o_resta(a, b):\n\treturn (a & (1<<b))\n\ndef diferencia(s1, d):\n\tif s1:\n\t\ts1.sort()\n\t\t#print(*s1, sep=\" - \")\n\t\tif s1[-1] - s1[0] >= d:\n\t\t\t#print(str(s1[-1]) + \" - \" + str(s1[0]) + \" = \" + str(s1[-1] - s1[0]))\n\t\t\treturn s1\n\t\telse:\n\t\t\treturn diferencia(s1.remove(s1[-1]), d)\t\n\treturn s1\n\ndef no_sets(v, n, l, r, d):\n\ts = []\n\tcont = 0\n\tfor x in range(1<<n):\n\t\tfor i in range(n):\n\t\t\t#print(\"(\" + str(x) + \", \" + str(i) + \")\")\n\t\t\tif suma_o_resta(x, i) > 0:\n\t\t\t\t#print(str(suma_o_resta(x, i)))\n\t\t\t\ts.append(v[i])\n\t\ts = diferencia(s, d)\n\t\tif s:\n\t\t\tif sum(s) >= l and sum(s) <= r:\n\t\t\t\tcont += 1\n\t\ts = []\n\treturn cont;\n\t\n\nn, l, r, x = map(int, input().split())\n\nv = list(map(int, input().split()))\n\nprint(str(no_sets(v, n, l, r, x)))\n\n\n\t\t\t\t \t\t\t  \t\t\t\t   \t  \t \t\t \t",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "R = lambda: map(int, input().split())\nfor _ in range(int(input())):\n    n,k = R()\n    s = input()\n    p = (k+2)//2\n    l = \"RGB\"*p\n    res = n\n    for i in range(n-k+1):\n        c = 0\n        #print(l[0:k])\n        for j in range(0,k):\n            c += (s[i+j] != l[j])\n        res = min(res,c)\n        #print(c)\n        c = 0\n        #print(l[1:k+1])\n        for j in range(1,k+1):\n            c += (s[i+j-1] != l[j])\n        res = min(res,c)\n        #print(c)\n        c = 0\n        #print(l[2:k+2])\n        for j in range(2,k+2):\n            c += (s[i+j-2] != l[j])\n        res = min(res,c)\n        #print(c)\n    print(res)",
    "complexity": "quadratic",
    "problem": "1196_D1",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n,l,r,x = map(int,input().split())\nA = list(map(int,input().split()))\ncount = 0\nfor i in range(1<<n):\n    total = 0\n    mn = 1e6\n    mx = -1e6\n    for k in range(n):\n        if (i & (1<<k)):\n            total += A[k]\n            mn = min(A[k],mn)\n            mx = max(A[k],mx)\n    if total<=r and total>=l and mx-mn>=x:\n        count += 1\nprint(count)",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "n = int(input())\narr = list(map(int, input().split()))\nres = float('inf')\nfor i in range(1, n):\n    res = min(res, min(arr[i], arr[0]) // i)\nfor i in range(n - 1):\n    res = min(res, min(arr[i], arr[n - 1]) // (n - 1 - i))\nprint(res)\n",
    "complexity": "linear",
    "problem": "1159_B",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "n=int(input())\nls=list(map(int,input().split()))\nls.sort()\nif ls.count(min(ls))==len(ls):\n\tprint('NO')\nfor i in range(n):\n\tif ls[i]!=min(ls):\n\t\tprint(ls[i])\n\t\tbreak\n\t   \t \t\t    \t\t\t \t  \t  \t\t \t\t\t  \t",
    "complexity": "nlogn",
    "problem": "0022_A",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "a = list(map(int,input().split()))\nif a.count(1)>=1 or a.count(2)>=2 or a.count(3)==3 or (a.count(2)==1 and a.count(4)==2):\n    print(\"YES\")\nelse:\n    print(\"NO\")",
    "complexity": "constant",
    "problem": "0911_C",
    "from": "CODEFORCES",
    "tags": "brute force,constructive algorithms"
}
{
    "src": "from collections import defaultdict\n\ndef E1():\n\n    mod = 10 ** 9 + 7\n\n    comb = [[1]]\n    for i in range(1, 1010):\n        x = [1]\n        for j in range(1, i):\n            x.append((comb[i - 1][j - 1] + comb[i - 1][j]) % mod)\n        x.append(1)\n        comb.append(x)\n\n    dp = [1]\n    for i in range(1, 1010):\n        r = 0\n        for k in range(i):\n            r += dp[k] * comb[i - 1][k]\n            r %= mod\n        dp.append(r)\n\n    m, n = map(int, input().split())\n\n    ns = [0 for __ in range(m)]\n    for j in range(n):\n        temp = input()\n        s = [int(i) for i in temp]\n        for i in range(m):\n            ns[i] |= s[i] << j\n\n    dd = defaultdict(int)\n    for e in ns:\n        dd[e] += 1\n\n    ans = 1\n    for b in dd.values():\n        ans = ans * dp[b] % mod\n\n    print(ans)\n\nif __name__=='__main__':\n    E1()\n\t \t \t   \t   \t\t\t  \t\t\t\t  \t \t \t \t",
    "complexity": "quadratic",
    "problem": "0908_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,combinatorics,dp,math"
}
{
    "src": "n = int(input())\nans = 0\nif n==1:\n    print(1)\n    exit()\nif n==2:\n    print(2)\n    exit()\nif n==3:\n    print(6)\n    exit()\nif n%2==0:\n    if n%3==0:\n        ans=(n-1)*(n-2)*(n-3)\n    else:\n        ans=n*(n-1)*(n-3)\nelse:\n    ans=n*(n-1)*(n-2)\n\nprint(ans)",
    "complexity": "constant",
    "problem": "0235_A",
    "from": "CODEFORCES",
    "tags": "number theory"
}
{
    "src": "i = input()\ni = int(i)\nv = 0\ng = 2\ns = 4\nwhile g <= i:\n\twhile s <= i:\n\t\tv = v + int(s / g * 4)\n\t\ts = s + g\n\tg = g + 1\n\ts = g * 2\nprint(str(v))",
    "complexity": "quadratic",
    "problem": "1062_D",
    "from": "CODEFORCES",
    "tags": "dfs and similar,graphs,implementation,math"
}
{
    "src": "x, k = map(int, input().strip().split())\nMOD = 10**9 + 7\n\ndef pow2(k):\n    if k == 0:\n        return 1\n    if k == 1:\n        return 2\n    r = pow2(k // 2)\n    r = r * r\n    if k % 2 != 0:\n        r *= 2\n    return r % MOD\n\ndef calc(x, k):\n    if x == 0:\n        return 0\n    if k == 0:\n        return (2 * x) % MOD\n    r = pow2(k) * (2 * x - 1) + 1\n    return r % MOD\n\nprint(calc(x, k))",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "def main():\n    n = int(input())\n    left = [int(x) for x in input().strip().split()]\n    right = [int(x) for x in input().strip().split()]\n    rank = [x + y for (x,y) in zip(left,right)]\n    arr = [(n - r) for r in rank]\n\n    # check left\n    for i in range(n):\n        more = 0\n        for j in range(i):\n            if arr[j] > arr[i]:\n                more += 1\n        if more != left[i]:\n            print('NO')\n            return\n    \n    # check right\n    for i in range(n):\n        more = 0\n        for j in range(i+1,n):\n            if arr[j] > arr[i]:\n                more += 1\n        if more != right[i]:\n            print('NO')\n            return\n\n    print('YES')\n    for x in arr:\n        print(x, end=' ')\n    print()\n\n\nif __name__ == '__main__':\n    main()",
    "complexity": "quadratic",
    "problem": "1054_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation"
}
{
    "src": "\nimport sys\n\n\ndef query(c, d):\n    print('? %d %d' % (c, d))\n    sys.stdout.flush()\n    res = int(input())\n    return res\n\na = 0\nb = 0\nbig = query(0, 0)\n\nfor i in range(29, -1, -1):\n    p = query(a ^ (1 << i), b)\n    q = query(a, b ^ (1 << i))\n    if p == q:\n        if big == 1:\n            a ^= 1 << i\n        else:\n            b ^= 1 << i\n        big = p\n    elif p == -1:\n        a ^= 1 << i\n        b ^= 1 << i\n\nprint('! %d %d' % (a, b))\nsys.stdout.flush()\n",
    "complexity": "constant",
    "problem": "1088_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,constructive algorithms,implementation,interactive"
}
{
    "src": "import io\nimport os\n\nfrom collections import Counter, defaultdict, deque\n\n\ndef solveBFS(NR, NG, NB, R, G, B):\n    def pack(i, j, k):\n        return i * 256 * 256 + j * 256 + k\n\n    def unpack(ijk):\n        i, jk = divmod(ijk, 256 * 256)\n        j, k = divmod(jk, 256)\n        return i, j, k\n\n    R.sort(reverse=True)\n    G.sort(reverse=True)\n    B.sort(reverse=True)\n    dp = [0 for i in range(256 ** 3)]\n    q = deque([0])\n    while q:\n        ijk = q.popleft()\n        d = dp[ijk]\n        i, j, k = unpack(ijk)\n\n        if i < NR:\n            r = R[i]\n\n        if j < NG:\n            g = G[j]\n        if k < NB:\n            b = B[k]\n        if i + 1 <= NR and j + 1 <= NG:\n            rg = pack(i + 1, j + 1, k)\n            dp[rg] = max(dp[rg], r * g + d)\n            q.append(rg)\n\n        if i + 1 <= NR and k + 1 <= NB:\n            rb = pack(i + 1, j, k + 1)\n            dp[rb] = max(dp[rb], r * b + d)\n            q.append(rb)\n\n        if j + 1 <= NG and k + 1 <= NB:\n            gb = pack(i, j + 1, k + 1)\n            dp[gb] = max(dp[gb], g * b + d)\n            q.append(gb)\n\n    return max(dp)\n\n\ndef solve(NR, NG, NB, R, G, B):\n    assert NR == len(R)\n    R.sort(reverse=True)\n    G.sort(reverse=True)\n    B.sort(reverse=True)\n\n    R += [0]\n    G += [0]\n    B += [0]\n\n    NR1 = NR + 2\n    NG1 = NG + 2\n    NB1 = NB + 2\n    dp = [0 for i in range((NR1) * (NG1) * (NB1))]\n\n    def pack(i, j, k):\n        return i * NG1 * NB1 + j * NB1 + k\n\n    inf = float(\"inf\")\n    for i in range(NR + 1):\n        for j in range(NG + 1):\n            dp[pack(i, j, -1)] = -inf\n    for i in range(NR + 1):\n        for k in range(NB + 1):\n            dp[pack(i, -1, k)] = -inf\n\n    for j in range(NG + 1):\n        for k in range(NB + 1):\n            dp[pack(-1, j, k)] = -inf\n\n    for l in range(2, NR + NG + NB + 1, 2):\n        for j in range(NG + 1):\n            for k in range(NB + 1):\n                i = l - j - k\n                if i < 0 or i > NR:\n                    continue\n                r = R[i - 1]\n                g = G[j - 1]\n                b = B[k - 1]\n                dp[pack(i, j, k)] = max(\n                    r * g + dp[pack(i - 1, j - 1, k)],\n                    r * b + dp[pack(i - 1, j, k - 1)],\n                    b * g + dp[pack(i, j - 1, k - 1)],\n                )\n\n    return max(dp)\n\n\nif False:\n    import random\n\n    random.seed()\n    N = 5\n    for t in range(100):\n        R = [random.randint(1, 10) for i in range(random.randint(1, N))]\n        G = [random.randint(1, 10) for i in range(random.randint(1, N))]\n        B = [random.randint(1, 10) for i in range(random.randint(1, N))]\n        ans1 = solveBFS(len(R), len(G), len(B), R, G, B)\n        ans2 = solve(len(R), len(G), len(B), R, G, B)\n        if ans1 != ans2:\n            print(ans1, ans2)\n            print(R, G, B)\n        exit()\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    NR, NG, NB = [int(x) for x in input().split()]\n    R = [int(x) for x in input().split()]\n    G = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n    ans = solve(NR, NG, NB, R, G, B)\n    print(ans)\n\n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "n, k = list( map( int, input().split()))\np = list( map( int, input().split()))\nc = list( map( int, input().split()))\n\nm = {}\nfor i in range( n ):\n    if p[ i ] not in m:\n        m[ p[ i ] ] = list()\n    m[ p[ i ] ].append( c[ i ] )\n\na = {}\nt = []\nfor key, val in sorted( m.items() ):\n    a[ key ] = sum( t )\n    t += val\n    t.sort()\n    t = t[ max( 0, len( t ) - k ) : len( t ) ]\n\nprint( \" \".join( [ str( a[ p[ i ] ] + c[ i ] ) for i in range( n )]))\n",
    "complexity": "nlogn",
    "problem": "0994_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "M = 10**9+7\nx,k=[int(i) for i in input().split()]\nif(x==0):\n    print(0)\nelif(k==0):\n    print((x*2)%M)\nelse:\n    top_sum = ((pow(2,k,M)%M)*((2*x-1)%M))%M+1\n    print(top_sum%M)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "from collections import defaultdict\nfrom sys import stdout,stdin\nn,m,K=map(int,input().split())\ndp=[[[0 for h in range(11)]for j in range(m+1)] for i in range(n+1)]\nl1=[list(map(int,stdin.readline().split())) for i in range(n)]#i,j i,j+1\nl2=[list(map(int,stdin.readline().split())) for i in range(n-1)]#i,j i+1,j\nif K%2:\n    for i in range(n):\n        for j in range(m):\n            print('-1',end=' ')\n        print()\nelse:\n    for k in range(1,K//2+1):\n     for i in range(n):\n        for j in range(m):\n                res=100000000\n                if i-1>=0 and j>=0:\n                     res=min(res,l2[i-1][j]+dp[i-1][j][k-1])\n                if i+1<n and j>=0:\n                     res=min(res,l2[i][j]+dp[i+1][j][k-1])\n                if 0<=i and j+1<m:\n                     res=min(res,l1[i][j]+dp[i][j+1][k-1])\n                if 0<=i and j-1>=0:\n                     res=min(res,l1[i][j-1]+dp[i][j-1][k-1])\n                dp[i][j][k]=res\n    for i in range(n):\n        for j in range(m):\n            stdout.write(str(2*dp[i][j][K//2])+' ')\n        stdout.write('\\n')",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "n, m, k, l = map(int, input().split())\nif m > n or (l + k + m - 1) // m * m > n:\n    print(-1)\nelse:\n    x = (l + k + m - 1) // m\n    print(x)",
    "complexity": "constant",
    "problem": "1068_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n = int(input())\ns = input()\n \nfor sum in range(9 * n + 1):\n    cnt = 0\n    cursum = 0\n    for i in s:\n        cursum += int(i)\n        if cursum == sum:\n            cnt += 1\n            cursum = 0\n \n    if cursum == 0 and cnt > 1:\n        print(\"YES\")\n        exit(0)\n \nprint(\"NO\")",
    "complexity": "quadratic",
    "problem": "1030_C",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n = int(input())\ncoins = list(map(int, input().split()))\ncoins.sort(reverse=True)\ntarget = (sum(coins)+2)//2\n\ncount = 1\ntotal = coins[count-1]\nwhile total < target:\n    count += 1\n    total += coins[count-1]\n\nprint(count)\n\n",
    "complexity": "nlogn",
    "problem": "0160_A",
    "from": "CODEFORCES",
    "tags": "greedy,sortings"
}
{
    "src": "\nif __name__ == '__main__':\n    a = [int(c) for c in str(input())]\n    b = [int(c) for c in str(input())]\n    b_len = len(b)\n    a_len = len(a)\n    carCountPrefix = [[ 0 for c in range(2)] for _ in range(b_len+1)]\n    b_zero_count = 0\n    b_one_count = 0\n    for b_i in range(b_len):\n        if b[b_i] == 0:\n            b_zero_count += 1\n        elif b[b_i] == 1:\n            b_one_count += 1\n        carCountPrefix[b_i+1][1] = b_one_count\n        carCountPrefix[b_i+1][0] = b_zero_count\n    res = 0\n    for cur in range(0, a_len):\n        for dig in range(2):\n            res += (carCountPrefix[b_len - a_len + cur + 1][dig] - carCountPrefix[cur][dig]) * abs(a[cur] -dig)\n    print(res)\n\n \t \t\t \t\t\t\t\t  \t \t \t  \t\t \t\t    \t",
    "complexity": "linear",
    "problem": "0608_B",
    "from": "CODEFORCES",
    "tags": "combinatorics,strings"
}
{
    "src": "import sys\ninput=sys.stdin.readline\ndef read():return list(map(int,input().split()))\nn=int(input())\ns=input()\nt=input()\nif sorted(s)!=sorted(t):\n    print(-1)\n    quit()\ns=list(s)\nt=list(t)\nans=[]\nfor i in range(n):\n    for j in range(i,n-1):\n        if s[j+1] == t[i]:\n            for k in range(j,i-1,-1):\n                ans.append(k+1)\n                s[k+1], s[k] = s[k], s[k+1]\n            break\nprint(len(ans))\nprint(*ans)",
    "complexity": "quadratic",
    "problem": "1015_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "from math import sin\npi = 3.141592653589793238462643383279502884197\nn, r = map(int,input().split())\ntheta = 2*pi / n\nR = r / (1-sin(theta/2))\nprint(R-r)",
    "complexity": "constant",
    "problem": "1100_C",
    "from": "CODEFORCES",
    "tags": "binary search,geometry,math"
}
{
    "src": "a, b = map(int, input().split(\" \"))\n\na, b = min(a, b), max(a, b)\n\nbina = str(bin(a))[2:]\nbinb = str(bin(b))[2:]\n\nlena = len(bina)\nlenb = len(binb)\n\nans = 0\nif lena != lenb:\n\tans = 2**lenb-1\nelse:\n\ta = '0'*(lena-lenb) + bina\n\tfor i in range(lenb):\n\t\tif (bool(int(bina[i])) != bool(int(binb[i]))):\n\t\t\tans = 2**(lenb-i) - 1\n\t\t\tbreak\n\t\n\t\t\nprint(ans)",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "x, k = map(int, input().split())\nmod = 10**9+7\ne = (x * pow(2, k, mod)) % mod\ns = (e - pow(2, k, mod)) % mod\nf = lambda x: (x*(x+1))%mod\nans = ((f(e) - f(s)) * pow(2, k*(mod-2), mod))%mod\nprint(ans if x != 0 else 0)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import bisect\nn,q=map(int,input().split())\nstrength=list(map(int,input().split()))\narrows=list(map(int,input().split()))\nfor i in range(1,n):\n    strength[i]+=strength[i-1]\nNo_arrows=0\nn-=1\nfor i in range(q):\n    No_arrows+=arrows[i]\n    if(No_arrows>=strength[-1]):\n        No_arrows=0\n        print(n+1)\n    else:\n        it=bisect.bisect_left(strength,No_arrows)\n        if(strength[it]==No_arrows):\n            print(n-it)\n        else:\n            print(n-it+1)\n",
    "complexity": "nlogn",
    "problem": "0975_C",
    "from": "CODEFORCES",
    "tags": "binary search"
}
{
    "src": "#!/usr/bin/python3\nimport sys\ninput = sys.stdin.readline\nn, m = map(int, input().split())\n\nMOD = m\nMAX_N = 10**3\n\n# Construct factorial table\nfac = [1] + [0] * MAX_N\nfor i in range(1, MAX_N+1):\n    fac[i] = fac[i-1] * (i) % MOD\n\nfac_inv = [1] + [0] * MAX_N\n# Femrmat's little theorem says a**(p-1) mod p == 1\n# then, a * a**(p-2) mod p == 1\n# it means that a**(p-2) is the inverse element\n# Here, Get 1 / n! first\nfac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)\nfor i in range(MAX_N, 1, -1):\n    fac_inv[i-1] = fac_inv[i] * i % MOD\n\ndef mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD\n\npow2 = [0] * (n+1)\npow2[0] = 1\nfor i in range(1, n+1):\n    pow2[i] = pow2[i-1] * 2 % MOD\n\ntable = [[0] * 500 for _ in range(500)]\nfor i in range(500):\n    for j in range(i+1):\n        table[i][j] = mod_nCr(i, j)\n\n# dp[i-th][j used]\ndp = [[0] * (n+1) for _ in range(n)]\nfor i in range(n):\n    dp[i][i+1] = pow2[i]\nfor i in range(n-1):\n    for j in range(i // 2 + 1, n-1):\n        if dp[i][j] == 0:\n            continue\n        dp[i][j] %= MOD\n        for k in range(1, n-j):\n            if i + k + 1 >= n:\n                break\n            # create new\n            dp[i+k+1][j+k] += dp[i][j] * pow2[k-1] * table[k + j][k]\n\nans = sum(dp[-1]) % MOD\nprint(ans)",
    "complexity": "cubic",
    "problem": "1515_E",
    "from": "CODEFORCES",
    "tags": "combinatorics,dp,math"
}
{
    "src": "from operator import itemgetter\nn = int(input())\nai = list(map(int,input().split()))\nai2 = [[ai[i], i] for i in range(n)]\nanswer = [0] * n\nai2.sort(key = itemgetter(0))\nanswer[ai2[0][1]] = 1\nanswer[ai2[-1][1]] = 0\nfor i in range(n-2,0,-1):\n    num = ai2[i][1] % ai2[i][0]\n    for j in range(num,n,ai2[i][0]):\n        if ai[j] > ai2[i][0] and answer[j] == 0:\n            answer[ai2[i][1]] = 1\n            break\nfor i in range(n):\n    if answer[i] == 1:\n        print(\"A\",end=\"\")\n    else:\n        print(\"B\",end=\"\")\n",
    "complexity": "quadratic",
    "problem": "1033_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,games"
}
{
    "src": "import sys\nimport math\ninput = sys.stdin.readline\n\n############ ---- Input Functions ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s.rstrip()))\ndef invr():\n    return(map(int,input().split()))\nn, m, k=inlt()\nM=[[[] for i in range(m)] for j in range(n)]\nS=[[-1]*m for i in range(n)]\nfor y in range(n):\n\tL=inlt()\n\tfor x in range(m-1):\n\t\tM[y][x].append(((y, x+1), L[x]))\n\t\tM[y][x+1].append(((y, x), L[x]))\n\nfor y in range(n-1):\n\tL=inlt()\n\n\tfor x in range(m):\n\t\tM[y][x].append(((y+1, x), L[x]))\n\t\tM[y+1][x].append(((y, x), L[x]))\nif k%2==0:\n\tfor l in range(k//2):\n\t\tS2=[[0]*m for i in range(n)]\n\t\tfor y in range(n):\n\t\t\tfor x in range(m):\n\t\t\t\tMi=10000000000000000000000\n\t\t\t\tfor ((a, b), p) in M[y][x]:\n\t\t\t\t\tMi=min(Mi,max(0,S[a][b])+p)\n\t\t\t\tS2[y][x]=Mi\n\t\tS=S2\n\tfor y in range(n):\n\t\tfor x in range(m):\n\t\t\tS[y][x]*=2\n\nfor y in range(n):\n\tprint(' '.join(list(map(str, S[y]))))",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "# https://codeforces.com/contest/913/problem/D\nimport heapq\nfrom heapq import heappush as push_\nfrom heapq import heappop  as pop_\n\nclass heapT():\n    def __init__(self, T):\n        self.Q     = []\n        self.curT  = 0\n        self.maxT  = T\n        self.his   = []\n        \n    def push(self, t, index):\n        push_(self.Q, (-t, index))\n        self.his.append(index)\n        self.curT += t\n        \n        while self.curT > self.maxT:\n            self.pop()\n            \n    def pop(self):\n        t, ind     = pop_(self.Q)\n        self.his.append(ind) \n        self.curT -= t * -1\n        \n    def normalize(self, length):\n        while len(self.Q) > length:\n            self.pop()\n\ndef solve(a, n, T):\n    a    =  sorted(a, key=lambda x:x[0], reverse=True) \n    H    =  heapT(T)\n\n    max_ = -1\n    pos  = None\n    \n    for ak, t, ind in a:\n        H.push(t, ind)\n        H.normalize(ak)\n    \n        if len(H.Q) >  max_:\n            max_ = len(H.Q)\n            pos  = len(H.his)  \n            \n    d = {}\n    if pos is not None:\n        for x in H.his[:pos]:\n            if x not in d:\n                d[x] = 1\n            else:\n                del d[x]\n\n    if len(d) > 0:\n        print(len(d))\n        print(len(d))\n        print(' '.join([str(x+1) for x in d]))\n    else:\n        print('0'+'\\n'+'0')\n\nn, T =  map(int, input().split())\na    =  [list(map(int, input().split())) + [_] for _ in range(n)]\nsolve(a, n, T)\n\n#5 300\n#3 100\n#4 150\n#4 80\n#2 90\n#2 300        \n\n#7 100\n#5 30\n#5 40\n#6 20\n#2 50 \n#2 40\n#3 10\n#4 10\n\n#2 100\n#1 787\n#2 788",
    "complexity": "nlogn",
    "problem": "0913_D",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,data structures,greedy,sortings"
}
{
    "src": "x,k=map(int,input().split())\nif x==0:\n  print(0)\n  exit()\nmod=10**9+7\np=pow(2,k,mod)\nprint((2*p*x-p+1)%mod)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "MOD=1000000007\n\ndef powr(n,N):\n    temp=1\n    while(N>0):\n        if(N%2!=0):\n            temp=(temp*n)%MOD\n        n=(n*n)%MOD\n        N=N//2\n    return (temp%MOD)\n \n\"\"\"def powr(n,N):\n    if(N==1):\n        ans=n\n        return ans\n    else:\n        ans=powr(n,N//2)\n        if(N%2==0):\n            return ((ans*ans)%MOD)\n        else:\n            return ((((ans*ans)%MOD)*n)%MOD)\"\"\"\n \ndef MODI(a,b):\n    ans=(powr(a,b)%MOD)\n    return ans\n \n\n\nx,k=map(int,input().split())\nif(x==0):\n    print(0)\nelse:\n    t1=powr(2,k+1)%MOD\n    t1=(t1*x)%MOD\n    t2=powr(2,k)%MOD\n    t2=(t2-1)%MOD\n    ans=(t1-t2)%MOD\n    print(ans)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "l,r = [int(x) for x in input().split()]\nif l==r or l+1==r:\n    print(-1)\nelif l%2==0:\n    print(l,l+1,l+2)\nelif l%2!=0 and r-l+1>3:\n    print(l+1,l+2,l+3)\nelse:\n    print(-1)",
    "complexity": "constant",
    "problem": "0483_A",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,math,number theory"
}
{
    "src": "n=int(raw_input())\narr=list(map(int,raw_input().split()))\ndict1={}\narr1=[0]*n\nfor i in range(n):\n\tarr1[arr[i]-1]=i\nfor i in range(n):\n\tdict1[i+1]=[]\nfor i in range(n):\n\tfor j in range(i-arr[i],-1,-arr[i]):\n\t\tif(arr[j]>arr[i]):\n\t\t\tdict1[arr[i]].append(arr[j])\n\tfor j in range(i+arr[i],n,arr[i]):\n\t\tif(arr[j]>arr[i]):\n\t\t\tdict1[arr[i]].append(arr[j])\nstrarr=['.']*n\n#print(dict1)\nfor i in range(n-1,-1,-1):\n\tif(len(dict1[arr[arr1[i]]])==0):\n\t\tstrarr[arr1[i]]='B'\n\telse:\n\t\tif(len(dict1[arr[arr1[i]]])==1 and len(dict1[dict1[arr[arr1[i]]][0]])==0):\n\t\t\tstrarr[arr1[i]]='A'\n\t\telse:\n\t\t\tflag=0\n\t\t\tfor j in dict1[arr[arr1[i]]]:\n\t\t\t\t#print(j)\n\t\t\t\t#print(arr1[j-1])\n\t\t\t\tif(strarr[arr1[j-1]]=='B'):\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\n\t\t\tif(flag==1):\n\t\t\t\tstrarr[arr1[i]]='A'\n\t\t\telse:\n\t\t\t\tstrarr[arr1[i]]='B'\n\t#print(*strarr)\nprint(\"\".join(x for x in strarr))\n\n",
    "complexity": "quadratic",
    "problem": "1033_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,games"
}
{
    "src": "n,k=map(int,input().split())\nprint(max(min(n,k-1)-k//2,0))",
    "complexity": "constant",
    "problem": "1023_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "from sys import stdin,stdout\nn,q=map(int,input().split())\nmod=1000000007\no=[]\ns=[]\nr=m=0\na=input()\nfor i in a:\n    if i=='0':\n        r+=1\n    else:\n        m+=1\n    o.append(r)\n    s.append(m)\nz=[1]\n#print(o)\nfor i in range(100000):\n    z.append((z[-1]*2)%mod)\nfor j in range(q):\n    l,r=(int(j) for j in stdin.readline().split())\n    m=r-l+1\n    zs=o[r-1]-o[l-1]+(a[l-1]=='0')\n    os=m-zs\n    #print(zs,os)\n    if zs!=0:\n        print((((z[os]-1)%mod)*((z[zs])%mod))%mod)\n    else:\n        print(((z[os]-1)%mod))\n    \n    \n    \n",
    "complexity": "linear",
    "problem": "1062_C",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "x=int(input())\nd=x//2\nprint(d+1)\n",
    "complexity": "constant",
    "problem": "0964_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\ninput=sys.stdin.buffer.readline\nn=int(input())\narr=list(map(int,input().split()))\ngap=n//2\ncount =0\nwhile gap >=1:\n    for j in range(gap ,n):\n        i= j-gap\n        while i >=0:\n            if arr[i +gap] >arr[i]:\n                break\n            else:\n                arr[i +gap],arr[i] =arr[i] ,arr[i +gap]\n                count +=1\n            i-=gap\n    gap//=2\nif count % 2== 3*n %2:\n    print(\"Petr\")\nelse:\n    print(\"Um_nik\")\n",
    "complexity": "nlogn",
    "problem": "0986_B",
    "from": "CODEFORCES",
    "tags": "combinatorics,math"
}
{
    "src": "import sys\ninput=sys.stdin.readline\nn,m,k=map(int,input().strip().split(\" \"))\n#s=input().strip()\n#n=int(input().strip())\n#a=list(map(int,input().strip().split(\" \")))\nlr=[]\nfor i in range(n):\n\tlr.append([100000001]+list(map(int,input().strip().split(\" \")))+[100000001])\nud=[[100000001]*m]\nfor i in range(n-1):\n\tud.append(list(map(int,input().strip().split(\" \"))))\nud.append([100000001]*m)\no=[[1000000001]*(m+2)]\nfrom copy import deepcopy\nif k%2:\n\tfor i in range(n):\n\t\tsys.stdout.write(\" \".join([\"-1\"]*m)+\"\\n\")\n\tsys.exit()\nfor _ in range(n):\n\too=[100000001]\n\tfor _ in range(m):\n\t\too.append(0)\n\too.append(100000001)\n\to.append(oo)\no.append([100000001]*(m+2))\nfor _ in range(k//2):\n\too=deepcopy(o)\n\tfor i in range(1,n+1):\n\t\tfor j in range(1,m+1):\n\t\t\too[i][j]=min(lr[i-1][j-1]+o[i][j-1],lr[i-1][j]+o[i][j+1],ud[i-1][j-1]+o[i-1][j],ud[i][j-1]+o[i+1][j])\n\to=deepcopy(oo)\nfor i in o[1:n+1]:\n\tsys.stdout.write(\" \".join(map(str,[j*2 for j in i[1:m+1]]))+\"\\n\")\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "def mus(x):\n    c = 0\n    while(x>0):\n        c += x%10\n        x = x//10\n    return c\nn,s=map(int,input().split())\nans = s + 10 - s%10\nwhile(ans - mus(ans) < s):\n    ans += 10\nif ans > n:\n    print(0)\nelse:\n    print(n-ans+1)\n",
    "complexity": "logn",
    "problem": "0817_C",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,dp,math"
}
{
    "src": "m, a = map(int, input().split())\nif (a % m == 0):\n    print(a // m)\nelse:\n    print(a//m + 1)",
    "complexity": "constant",
    "problem": "1061_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "# http://codeforces.com/contest/23/problem/A\n\nstring = input()\nsize = len(string)\n\nans_got = 0\nfor s in range(1,size)[::-1]:\n    dic = {}\n    for i in range(0,size-s+1):\n        if(string[i:i+s] in dic):\n            print(s)\n            ans_got = 1\n            break\n        else:\n            dic[string[i:i+s]] = 1\n    if(ans_got == 1):\n        break\nif(ans_got == 0):\n    print(0)",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "a = int(input())\nprint(25)",
    "complexity": "constant",
    "problem": "0630_A",
    "from": "CODEFORCES",
    "tags": "number theory"
}
{
    "src": "\ndef solve():\n    n = int(input())\n    max_degs = [int(x) for x in input().split()]\n\n    B = [[i+1, x] for i, x in enumerate(max_degs) if x >= 2]\n    S = [[i+1, x] for i, x in enumerate(max_degs) if x < 2]\n\n    if 2 + sum(b - 2 for _, b in B) < len(S):\n        print('NO')\n        return\n\n    print('YES', len(B) + min(len(S), 2) - 1)\n    print(n-1)\n\n    # B edges\n    for k in range(len(B) - 1):\n        i, x = B[k]\n        i_n, _ = B[k+1]\n        print(i, i_n)\n        B[k][1] -= 1\n        B[k+1][1] -= 1\n\n    k = 0\n    for i, (s_idx, _) in enumerate(S):\n        if i == 0:\n            print(B[0][0], s_idx)\n            B[0][1] -= 1\n        elif i == 1:\n            print(B[-1][0], s_idx)\n            B[-1][1] -= 1\n        else:\n            while B[k][1] == 0:\n                k += 1\n            print(B[k][0], s_idx)\n            B[k][1] -= 1\n\n\nsolve()\n",
    "complexity": "linear",
    "problem": "1082_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,graphs,implementation"
}
{
    "src": "import sys\nimport string\n\nfrom collections import Counter, defaultdict\nfrom math import fsum, sqrt, gcd, ceil, factorial\nfrom operator import *\nfrom itertools import accumulate, count\n\ninf = float(\"inf\")\n# input = sys.stdin.readline\nflush = lambda: sys.stdout.flush\ncomb = lambda x, y: (factorial(x) // factorial(y)) // factorial(x - y)\n\n\n# inputs\n# ip = lambda : input().rstrip()\nip = lambda: input()\nii = lambda: int(input())\nr = lambda: map(int, input().split())\nrr = lambda: list(r())\n\n\narr = ip()\nn = len(arr)\nms = \"\"\nmn = 0\n\n\ndef counter(s, x):\n    p = len(x)\n    px = 0\n    for i in range(len(s)):\n        if s[i : i + p] == x:\n            px += 1\n\n    return px\n\n\nfor i in range(n):\n    s = \"\"\n    for j in range(i, n):\n        s += arr[j]\n        c = counter(arr, s)\n        if c > 1 and len(s) > mn:\n            ms = s\n            mn = len(s)\n\nprint(mn)",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "import sys\nimport os.path\nfrom collections import *\nimport math\nimport bisect\n\nif (os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\nelse:\n    input = sys.stdin.readline\n\n############## Code starts here ##########################\n\nn = int(input())\n\nif(n == 2 or n == 3 or n == 4 or n == 5):\n    print(-1)\nelse:\n    print(1,2)\n    print(2,3)\n    print(2,4)\n    for i in range(5,n + 1):\n        print(4,i)\n\nfor i in range(2,n + 1):\n    print(1,i)\n\n############## Code ends here ############################\n",
    "complexity": "linear",
    "problem": "0959_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,trees"
}
{
    "src": "x=list(map(int,input().split()))\npos=x[1]\nn=x[0]\nl=x[2]\nr=x[3]\nstep=0\nif pos<l :\n    step=l-pos+1\n    \n    if r< n :\n        step+=r-l+1\nelif pos>r:\n    step=pos-r+1\n    \n    if l> 1 :\n        step+=r-l+1\nelse:\n    if l>1 and n>r:\n        step+=min(pos-l,r-pos)+r-l+2\n    elif l==1 and n>r:\n        step=r-pos+1\n    elif l>1 and n==r:\n        step+=pos-l+1\n    else:\n        step=0\n\n\n\nprint(step)",
    "complexity": "constant",
    "problem": "0915_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "def pow2(n):\n    j=0\n    while(n%2==0):\n        n//=2\n        j+=1\n    return j    \nn,q=map(int,input().split())\nfor j in range(q):\n    u=int(input())\n    s=input()\n    for k in range(len(s)):\n        num=pow2(u)\n        if(s[k]==\"R\" and num!=0):\n            u=u+2**(num-1)\n        elif(s[k]==\"L\" and num!=0):\n            u=u-2**(num-1)\n        elif(s[k]==\"U\" and u!=(n+1)//2):\n            m1=u+2**(num)\n            m2=u-2**(num)\n            if(pow2(m1)==(num+1)):\n                u=m1\n            else:\n                u=m2\n    print(u)                ",
    "complexity": "np",
    "problem": "0792_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,trees"
}
{
    "src": "n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2002)]\n\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n\nfor v in range(1, 2002):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])\n",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n, m, k = map(int, input().strip().split())\n\na = list(map(int, input().strip().split()))\na = [0] + a\ndp = [0] * 300005\nans = 0\nfor i in range(1, n + 1):\n    a[i] += a[i - 1]\n    for j in range(1, m + 1):\n        if i - j >= 0:\n            dp[i] = max(dp[i], a[i] - a[i - j] - k)\n    if i - m >= 0:\n        dp[i] = max(dp[i], a[i] - a[i - m] + dp[i - m] - k)\n    ans = max(ans, dp[i])\n\nprint(ans)\n",
    "complexity": "quadratic",
    "problem": "1197_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,math"
}
{
    "src": "n=int(input())\na=[*map(int,input().split())]\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=range(i%x,n,x)\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))",
    "complexity": "quadratic",
    "problem": "1033_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,games"
}
{
    "src": "# https://codeforces.com/problemset/problem/313/A\n\nn = int(input())\n\nif n > 0:\n    print(n)\nelse:\n    n = n * -1\n    x = n % 10\n    y = (n // 10) % 10\n\n    if x > y:\n        print(-(n // 10))\n    else:\n        print(-((n // 100)* 10 + x))\n",
    "complexity": "constant",
    "problem": "0313_A",
    "from": "CODEFORCES",
    "tags": "implementation,number theory"
}
{
    "src": "n,d,k=map(int,input().split())\nif n==1:\n  print(\"NO\")\n  exit()\nif k==1:\n  if n==2 and d==1:\n    print(\"YES\")\n    print(1,2)\n  else:\n    print(\"NO\")\n  exit()\nif n<d+1:\n  print(\"NO\")\n  exit()\nco=1\nans=[]\nfor i in range(1,d+1):\n  ans.append((i,i+1))\n  co+=1\ndef dfs(r,dist,co):\n  if 2<=r<=d:\n    t=k-2\n  else:\n    t=k-1\n  if co==n:\n    return co\n  for _ in range(t):\n    if dist==d:\n      return co\n    if co==n:\n      return co\n    co+=1\n    ans.append((r,co))\n    co=dfs(co,dist+1,co)\n  return co\nfor i in range(2,d+1):\n  co=dfs(i,max(i-1,d-i+1),co)\nif co==n:\n  print(\"YES\")\n  for j in ans:\n    print(*j)\nelse:\n  print(\"NO\")",
    "complexity": "quadratic",
    "problem": "1003_E",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,graphs"
}
{
    "src": "yellow,blue = map(int,input().split())\nx,y,z = map(int,input().split())\nry = x*2+y\nrb =z*3+y\nr1,r2 = 0,0\nif ry-yellow < 0:\n    r1 = 0\nelse:\n    r1 = ry-yellow\nif rb - blue < 0:\n    r2 = 0\nelse:\n    r2 = rb-blue\nprint(r1+r2)\n",
    "complexity": "constant",
    "problem": "0912_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "q = int(input())\nfor _ in range(q):\n\tl, r = map(int, input().split())\n\tsign = -1 if l % 2 else 1\n\tif (r-l) % 2:\n\t\tprint(-sign*(r-l+1)//2)\n\telse:\n\t\tprint(sign*(l+(r-l)//2))\n\n",
    "complexity": "constant",
    "problem": "1080_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "x,k = map(int,input().split())\nif(x==0):\n    print(0)\n    exit(0)\nm = 10**9+7\np = pow(2,k+1,m)\nq = pow(2,k,m)\na = (x*p-q+1)%m\nprint(a)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import itertools\n\nn = int(input())\na = []\nfor i in range(4):\n    a.append([input() for _ in range(n)])\n    if i < 3:\n        assert input() == ''\n\nbest = 4*n*n\nfor p in itertools.permutations(a):\n    for s in range(2):\n        count = 0\n        for i in range(4):\n            for r in range(n):\n                for c in range(n):\n                    if p[i][r][c] != str((s + (i//2 + r) + (i % 2 + c)) % 2):\n                        count += 1\n        best = min(best, count)\nprint(best)\n",
    "complexity": "quadratic",
    "problem": "0961_C",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,implementation"
}
{
    "src": "people,n=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nd={}\ntmp=[]\nfor i in range(n):\n    if a[i] in d:\n        d[a[i]]+=1\n    else:\n        d[a[i]]=1\nd1={}\nfor i in d:\n    if d[i] in d1:\n        d1[d[i]]+=1\n    else:\n        d1[d[i]]=1\n    tmp.append(d[i])\ntmp.sort()\nans=0\nfor i in range(1,10001):\n    x=people\n    try:\n        x-=d1[i]\n    except:\n        pass\n    for j in d1:\n        if j>i:\n            x-=(j//i)*d1[j]\n    if x<=0:\n        ans=max(ans,i)\nprint(ans)",
    "complexity": "nlogn",
    "problem": "1011_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,implementation"
}
{
    "src": "T = int(input())\nfor _ in range(T):\n    N = int(input())\n\n    if N%2 == 1:\n        print(\"NO\")\n    else:\n        N //= 2\n        if N**(1/2) == int(N**(1/2)):\n            print(\"YES\")\n        else:\n            if N%2 == 1:\n                print(\"NO\")\n            else:\n                N //= 2\n                if N**(1/2) == int(N**(1/2)):\n                    print(\"YES\")\n                else:\n                    print(\"NO\")",
    "complexity": "constant",
    "problem": "1515_B",
    "from": "CODEFORCES",
    "tags": "brute force,geometry,math,number theory"
}
{
    "src": "N = 1010\n\ndp = [[[0] * 4 for j in range(N*2)] for i in range(N)]\ndp[0][1][0] = dp[0][1][1] = dp[0][2][2] = dp[0][2][3] = 1\nm = 998244353\nfor i in range(N-1):\n    for j in range(1,N*2-5):\n        for me in range(4):\n            for he in range(4):\n                if me <= 1:\n                    if he <= 1:\n                        dp[i+1][j+(he!=me)][he] = (dp[i+1][j+(he!=me)][he] + dp[i][j][me]) % m\n                    else:\n                        dp[i+1][j+1][he] = (dp[i+1][j+1][he] + dp[i][j][me]) % m\n                else:\n                    if he <= 1:\n                        dp[i+1][j][he] = (dp[i+1][j][he] + dp[i][j][me]) % m\n                    else:\n                        dp[i+1][j + (he != me)*2][he] = (dp[i+1][j+(he!=me)*2][he] + dp[i][j][me]) % m\nn,k = map(int,input().split())\nprint(sum(dp[n-1][k])%m)                        \n",
    "complexity": "np",
    "problem": "1051_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "# make sure the king never crosses the row or column the queen is in\n\nn = int(input())\nax, ay = map(int, input().split())\nbx, by = map(int, input().split())\ncx, cy = map(int, input().split())\n\nif bx < ax < cx or bx > ax > cx or by < ay < cy or cy < ay < by:\n    print('NO')\nelse:\n    print('YES')\n",
    "complexity": "constant",
    "problem": "1033_A",
    "from": "CODEFORCES",
    "tags": "dfs and similar,graphs,implementation"
}
{
    "src": "mass = list(input())\nb = int(input())\nmass.sort()\nmass = mass[::-1]\np = ''\nwhile(len(mass)>0):\n\tfor i in range(len(mass)):\n\t\tn = p + mass[i] + ''.join(sorted(mass[:i] + mass[i + 1:]))\n\t\tif int(n) <= b:\n\t\t\tp += mass[i]\n\t\t\tmass = mass[:i] + mass[i + 1:]\n\t\t\tbreak\nprint(p)",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "#!/bin/python3\nfrom itertools import*\n\nmoves =[(x*mx,y*my) for mx,my,(x,y) in product( (-1,1),(-1,1), ( (1,2),(2,1) ) )]\n\ndef ac(l,x):\n\tif l==0: return 0\n\treturn l[x] if 0<=x<len(l) else 0\n\ndef work():\n\tx=1\n\twhile x:\n\t\tx=0\n\t\tfor r in range(len(a)):\n\t\t\tfor c in range(len(a[0])):\n\t\t\t\tif not a[r][c] and sum(ac(ac(a,r+dr),c+dc) for dr,dc in moves)>=4:\n\t\t\t\t\ta[r][c]=1\n\t\t\t\t\tx=1\n\nfor n in [int(input())]:\n\t#print(' ===== n=',n)\n\tcand=set()\n\n\t#for x in (0,1):\n\t#\tfor y in range(-1000,1000):\n\t#\t\tif y%3!=0: cand.add((x,y))\n\t#\n\t#for y in [0]:\n\t#\tfor x in range(-1000,1000):\n\t#\t\tcand.add((x,y))\n\n\tfor i in range(1000):\n\t\tfor x,y in ( (0,i),(i,0),(i,1),(-i,0),(-i,1),(0,-i) ):\n\t\t\tif x==0 or x%3!=1:\n\t\t\t\tif n==len(cand): break\n\t\t\t\tcand.add((x,y))\n\n\tassert len(cand)==n\n\n\t#NN=25\n\t#a=[[0]*(NN*2) for x in range(NN*2)]\n\t#for x,y in sorted(cand,key=lambda a:abs(a[0])+abs(a[1]))[:n]:\n\t#\ta[x+NN][y+NN]=1\n\n\t#for r in a: print(''.join('-#'[x] for x in r))\n\t#print('===')\n\t#nn=sum(sum(r) for r in a)\n\t#print(nn)\n\n\t#work()\n\n\t#for r in a: print(''.join('-#'[x] for x in r))\n\t#print('===')\n\n\t#have=sum(sum(r) for r in a)\n\t#print(have)\n\t#need=nn**2//10\n\t#print('need',need)\n\n\t#assert have>=need, n\n\n\tfor x,y in cand: print(x,y)\n",
    "complexity": "constant",
    "problem": "1067_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms"
}
{
    "src": "import os, sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef getInt(): return int(input())\ndef getStrs(): return input().split()\ndef getInts(): return list(map(int,input().split()))\ndef getStr(): return input()\ndef listStr(): return list(input())\ndef getMat(n): return [getInts() for _ in range(n)]\ndef isInt(s): return '0' <= s[0] <= '9'\n\nsquares = set([i*i for i in range(1,4000)])\n\np = [i for i in range(10**7+1)]\nfor i in range(1,10**7+1):\n    if p[i] == i:\n        for sq in squares:\n            if i*sq > 10**7: break\n            p[i*sq] = i\n\nfor _ in range(getInt()):\n    N, K = getInts()\n    A = getInts()\n    new = 10**8\n    A = [p[A[i]] for i in range(N)]\n    dp = [N]*(K+1)\n    dp[0] = 0\n    used = [set()]*(K+1)\n    for i in range(N):\n        for j in range(K,-1,-1):\n            if dp[j] == N: continue\n            if A[i] in used[j]:\n                if j < K and dp[j+1] > dp[j]:\n                    dp[j+1] = dp[j]\n                    used[j+1] = used[j]\n                dp[j] += 1\n                used[j] = set([A[i]])\n            else:\n                used[j].add(A[i])\n    print(min(dp)+1)\n",
    "complexity": "cubic",
    "problem": "1497_E2",
    "from": "CODEFORCES",
    "tags": "data structures,dp,greedy,math,number theory,two pointers"
}
{
    "src": "class Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Vector:\n\n    def __init__(self, start, end):\n        self.x = end.x - start.x\n        self.y = end.y - start.y\n\n    def mult(self, a):\n        return self.y * a.x - self.x * a.y\n\nn = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append(Point(x, y))\n\nif n <= 3:\n    print('YES')\n    exit()\n\n\ndef onLine(points):\n    n = len(points)\n    if n < 3:\n        return True\n    a = Vector(points[0], points[1])\n    for i in range(2, n):\n        b = Vector(points[0], points[i])\n        if a.mult(b) != 0:\n            return False\n    return True\n\ntmp = [points[0], points[1]]\noth = []\nfor i in range(2, n):\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    exit()\n\ntmp = [points[0], points[2]]\noth = []\nfor i in range(1, n):\n    if i == 2:\n        continue\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    exit()\n\ntmp = [points[1], points[2]]\noth = []\nfor i in range(0, n):\n    if i == 2 or i == 1:\n        continue\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    exit()\n\nprint('NO')\n",
    "complexity": "nlogn",
    "problem": "0961_D",
    "from": "CODEFORCES",
    "tags": "geometry"
}
{
    "src": "l = list(sorted(list(map(int,input().split()))))\nif min(l) == 1 or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==4 and l[2]==4) or(l[0]==2 and l[1] == 2):\n    print(\"Yes\")\nelse:\n    print(\"No\")",
    "complexity": "constant",
    "problem": "0911_C",
    "from": "CODEFORCES",
    "tags": "brute force,constructive algorithms"
}
{
    "src": "n = int(input())\nA = map(int, input().split())\na = []\nfor x in A:\n\ta.append(x)\ntot = 0\nfor i in range(n):\n\tl = i\n\tr = n - i - 1\n\ttot += a[i] * l + -a[i] * r\n\nfrom collections import defaultdict\n\n# d = defaultdict(int)\n\nfor_cnt = defaultdict(int)\n\nfor i in range(n):\n\tfault = for_cnt[a[i] - 1] + for_cnt[a[i] + 1] + for_cnt[a[i]]\n\ttot -= a[i] * fault\n\tfor_cnt[a[i]] += 1\n\nback_cnt = defaultdict(int)\n\ni = n - 1\nwhile i >= 0:\n\tfault = back_cnt[a[i] - 1] + back_cnt[a[i] + 1] + back_cnt[a[i]]\n\ttot -= -a[i] * fault\n\tback_cnt[a[i]] += 1\n\ti -= 1\n\nprint(tot) \t\n\n",
    "complexity": "nlogn",
    "problem": "0903_D",
    "from": "CODEFORCES",
    "tags": "data structures,math"
}
{
    "src": "def ch_x(stri, n):\n    res = ''\n    for i in range(len(stri)):\n        if i != n:\n            res += stri[i]\n        else:\n            res += 'x'\n    return res\n\n\na = input()\nb = input()\nn = 0\nfor i in range(0, len(a)):\n    if a[i] == '0' and b[i] == '0':\n        c = [i-1, i+1]\n        for e in c:\n            if 0 <= e < len(a):\n                if a[e] == '0':\n                    n += 1\n                    a = ch_x(a, e)\n                    break\n                if b[e] == '0':\n                    n += 1\n                    b = ch_x(b, e)\n                    break\n        a = ch_x(a, i)\n        b = ch_x(b, i)\nprint(n)",
    "complexity": "constant",
    "problem": "0991_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import sys\n\nn,m=map(int,sys.stdin.readline().split())\nX=[int(sys.stdin.readline()) for i in range(n)]\nY=[list(map(int,sys.stdin.readline().split())) for i in range(m)]\nZ=[]\n\nANS=0\nfor y in Y:\n    if y[0]==1 and y[1]==10**9:\n        ANS+=1\n    elif y[0]==1:\n        Z.append(y[1])\nX.sort(reverse=True)\nZ.sort(reverse=True)\n\nXCOUNT=[0]*n#X[i]\u3088\u308a\u5927\u304d\u3044Z\u306e\u500b\u6570\n\ni=0\nj=0\nl=len(Z)\nX.append(0)\nZ.append(0)\nwhile i<l+1 and j<n:\n    if Z[i]>=X[j]:\n        i+=1\n    else:\n        XCOUNT[j]=i\n        j+=1\n\ncount=n\nXCOUNT.reverse()\nfor i in range(n):\n    if count>i+XCOUNT[i]:\n        count=i+XCOUNT[i]\n\nprint(count+ANS)\n\n\n    \n",
    "complexity": "nlogn",
    "problem": "1075_C",
    "from": "CODEFORCES",
    "tags": "two pointers"
}
{
    "src": "a=''.join(reversed(sorted(input())))\nb=int(input())\nr=''\nwhile len(a)>0:\n    for i in range(len(a)):\n        n=r+a[i]+''.join(sorted(a[:i]+a[i+1:]))\n        if int(n)<=b:\n            r+=a[i]\n            a=a[:i]+a[i+1:]\n            break\nprint(r)",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n=int(input())\ns=[c=='1' for c in input()]\nm=len(s)\nz=[[0,0]]\nfor c in s:\n ind = z[-1][c]\n z[-1][c] = len(z)\n z.append(z[ind][:])\nassert(len(z) == m+1)\nz[m][0] = z[m][1] = m # make it sticky\n\n# how many things match directly\ndp = [0 for _ in range(m+1)]\ndp[0] = 1\nfor i in range(n):\n ndp = [0 for _ in range(m+1)]\n for i in range(m+1):\n  ndp[z[i][0]] += dp[i]\n  ndp[z[i][1]] += dp[i]\n dp = ndp\nres = dp[m]\n\nfor k in range(1, m):\n s0 = 0\n for c in s[-k:]:\n  s0 = z[s0][c]\n dp = [0 for _ in range(m+1)]\n dp[s0] = 1\n for i in range(n - k):\n  ndp = [0 for _ in range(m+1)]\n  for i in range(m+1):\n   ndp[z[i][0]] += dp[i]\n   ndp[z[i][1]] += dp[i]\n  dp = ndp\n for s1 in range(m): # skip m\n  v = dp[s1]\n  for c in s[-k:]:\n   if s1 == m: v = 0\n   s1 = z[s1][c]\n  if s1 == m: res += v\nprint(res)",
    "complexity": "np",
    "problem": "1038_F",
    "from": "CODEFORCES",
    "tags": "dp,strings"
}
{
    "src": "def solve(n,k):\n    print(1*k,end = ' ')\n    if n==2:\n        print(2*k,end = ' ')\n    if n == 3:\n        print(k,3*k,end = ' ')\n    else:\n        temp = n//2\n        if(n%2 == 0): temp -= 1\n        print((str(k)+' ')*temp,end='')\n        if(n>3):\n            solve(n//2,k*2)\n\nn = int(input())\nsolve(n,1)",
    "complexity": "linear",
    "problem": "1059_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "n = int(input())\ns = input()\nwant = len(set(s))\nd = {}\nj = 0\ncount = 0\nans = float(\"inf\")\nfor i in range(n):\n    if s[i] not in d:\n        d[s[i]] = 0\n        count+=1\n    d[s[i]]+=1\n    if count==want:\n        while d[s[j]]>1:\n            d[s[j]]-=1\n            j+=1\n        ans = min(ans,i-j+1)\nprint(ans)",
    "complexity": "linear",
    "problem": "0701_C",
    "from": "CODEFORCES",
    "tags": "binary search,strings,two pointers"
}
{
    "src": "#!/usr/bin/env python\n'''\n' Author:   Cheng-Shih Wong\n' Email:    mob5566@gmail.com\n' Date:     2017-08-08\n'''\n\nfrom itertools import chain\nfrom time import time\n\ndef main():\n\n    BITS = [1 << sh for sh in range(24)]\n    B2N = {v: u for u, v in enumerate(BITS)}\n\n    def getPt():\n        return tuple(map(int, input().split()))\n\n    def dist(ptA, ptB):\n        return sum(((u-v)**2 for u, v in zip(ptA, ptB)))\n\n    def getBits(val):\n        return tuple(filter(lambda x: x&val, BITS))\n\n    def chooseTwo(pool):\n        n = len(pool)\n        for i in range(n):\n            for j in range(i+1, n):\n                yield (pool[i], pool[j])\n\n    ori = getPt()\n    pts = []\n    N = int(input())\n\n    for _ in range(N):\n        pts.append(getPt())\n\n    vis = set([0])\n    mint = [0]+[1e8]*(1<<N) # minimal time for dp\n    pres = [None]*(1<<N) # previous step for reconstruct path\n    allb = (1 << N)-1 # all objects contained state\n    B2P = {BITS[u]: v for u, v in enumerate(pts)}\n    B2P[0] = ori\n    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}\n\n    getDP = lambda x: mint[x]\n    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \\\n                                + alld[p[0]][0] \\\n                                + alld[p[1]][0] \n\n    for stt in range(1<<N):\n        if stt not in vis:\n            continue\n\n        bits = getBits(~stt&allb)\n\n        sb = bits[0] if bits else None\n\n        for bit in bits:\n\n            newstt = stt | sb | bit\n            nd = newDist(stt, (sb, bit))\n            if getDP(newstt) > nd:\n                mint[newstt] = nd\n                pres[newstt] = sb | bit\n                vis.add(newstt)\n\n    print(mint[allb])\n    path = ['0']\n    stt = allb\n\n    while stt:\n\n        bits = getBits(pres[stt])\n        for bit in bits:\n            path.append(str(B2N[bit]+1))\n        path.append('0')\n\n        stt ^= pres[stt]\n\n    print(' '.join(path))\n\nif __name__ == '__main__':\n    import sys\n    st = time()\n    main()\n    print('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)",
    "complexity": "np",
    "problem": "0008_C",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO,IOBase\nfrom collections import defaultdict,Counter\nfrom copy import deepcopy\n\ndef main():\n    n,c = map(int,input().split())\n    a = list(map(int,input().split()))\n    nums = defaultdict(lambda :[0])\n    freq,minus = Counter(),0\n    for i in a:\n        if i == c:\n            minus += 1\n        else:\n            freq[i] += 1\n            nums[i].append(freq[i]-minus)\n    tot = minus\n    suff = deepcopy(nums)\n    for i in nums:\n        for j in range(len(nums[i])-2,0,-1):\n            suff[i][j] = max(suff[i][j],suff[i][j+1])\n    freq,ans = Counter(),tot\n    for i in a:\n        if i == c:\n            continue\n        freq[i] += 1\n        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)\n    print(ans)\n\n# Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self,file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            self.newlines = b.count(b\"\\n\")+(not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd,self.buffer.getvalue())\n            self.buffer.truncate(0),self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self,file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s:self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda:self.buffer.read().decode(\"ascii\")\n        self.readline = lambda:self.buffer.readline().decode(\"ascii\")\nsys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)\ninput = lambda:sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()",
    "complexity": "constant",
    "problem": "1082_E",
    "from": "CODEFORCES",
    "tags": "binary search,dp,greedy"
}
{
    "src": "n,v=[int(x) for x in input().split()]\nif v>=(n-1):\n    print(n-1)\nelse:\n    print(int((((n-v)*(n-v+1))/2)-1+v))\n    \n    ",
    "complexity": "constant",
    "problem": "1113_A",
    "from": "CODEFORCES",
    "tags": "dp,greedy,math"
}
{
    "src": "n = int(input())\na = [int(i) for i in input().split()]\nc = 0\nfor i in range(n):\n    if a[i] > c:\n        print(i+1)\n        break\n    else:\n        c = max(a[i]+1, c)\nelse:\n    print(-1)\n",
    "complexity": "linear",
    "problem": "1054_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "a=list(input())\nb=list(input())\nnum=int(''.join(b))\na.sort()\na.reverse()\nal=len(a)\nans=[]\nif(len(a)==len(b) and len(a)!=1):\n\tc=[]\n\tcount=0\n\thogya=0\n\tfor i in range(al):\n\t\tif(hogya==1):\n\t\t\to.reverse()\n\t\t\tf=list(c+o)\n\t\t\tans.append(''.join(f))\n\t\t\tcount+=1\n\t\t\tbreak\n\t\tt=len(a)\n\t\tj=0\n\t\tmittal=t\n\t\tabhinhi=0\n\t\twhile(t):\n\t\t\t#print(\"hello\")\n\t\t\tif(j>len(a)-1):\n\t\t\t\tbreak\n\t\t\tif(int(a[j])<=int(b[i])):\n\t\t\t\tc.append(a[j])\n\t\t\t\ttemp=a[j]\n\t\t\t\ta.remove(a[j])\n\t\t\t\to=a.copy()\n\t\t\t\to.sort()\n\t\t\t\tf=list(c+o)\n\t\t\t\t#if(i==8):\n\t\t\t\t#\tprint(c,a)\n\t\t\t\t#print(num,a)\n\t\t\t\tif(temp<b[i]):\n\t\t\t\t\t#print(i,temp,j,f)\n\t\t\t\t\t#print(\"hello\")\n\t\t\t\t\t#print(\"hello\",hogya)\n\t\t\t\t\thogya=1\n\t\t\t\t\tbreak\n\t\t\t\tif(int(''.join(f))<=num):\n\t\t\t\t\tans.append(''.join(f))\n\t\t\t\t\tcount+=1\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\ta.append(temp)\n\t\t\t\t\tc=c[:len(c)-1]\n\t\t\t\t\t#c.remove(c[len(c)-1])\n\t\t\t\t\t#print(c,a)\n\t\t\t\t\t\n\t\t\t\tt-=1\n\t\t\telse:\n\t\t\t\tj+=1\n\t\t\t\tt-=1\n\t\tif(mittal==len(a)):\n\t\t\t#print(mittal,i)\n\t\t\t#print(\"hello\")\n\t\t\tbreak\n\t#print(count)\n\tprint(ans[count-1])\nelif(len(a)==1):\n\tprint(''.join(a))\nelse:\n\tprint(''.join(a))\n#print(ans)",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n = int(input())\na = list(map(int, input().strip().split()))\n\namin = min(a)\nfor i in range(n):\n    a[i] -= amin\nans = amin % n\ncnt = 0\nwhile True:\n    if a[ans] <= cnt:\n        break\n    ans = (ans + 1) % n\n    cnt += 1\nprint(ans + 1)\n\n",
    "complexity": "linear",
    "problem": "0996_B",
    "from": "CODEFORCES",
    "tags": "binary search,math"
}
{
    "src": "# Fast IO Region\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# Get out of main function\ndef main():\n    pass\n# decimal to binary\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n# binary to decimal\ndef decimal(s):\n    return (int(s, 2))\n# power of a number base 2\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return (p)\n# if  number is prime in \u221an time\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n# list to string ,no spaces\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n# String to list\ndef stl(s):\n    # for each character in string to list with no spaces -->\n    l = list(s)\n    # for space in string  -->\n    # l=list(s.split(\" \"))\n    return l\n# Returns list of numbers with a particular sum\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n# Sieve for prime numbers in a range\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n            # print(p)\n    return (cnt)\n# for positive integerse only\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n# 1000000007\nmod = int(1e9) + 7\nimport math\n#import random\n#import bisect\n#from fractions import Fraction\n#from collections import OrderedDict\n#from collections import deque\n########################                         mat=[[0 for i in range(n)] for j in range(m)]                      ########################\n########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################\n########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################\n########################                         from collections import deque                              ########################\n########################                         ASCII of A-Z= 65-90                                        ########################\n########################                         ASCII of a-z= 97-122                                       ########################\n########################                         d1.setdefault(key, []).append(value)                       ########################\n#sys.setrecursionlimit(300000)          #Gives memory limit exceeded if used a lot\n#for ___ in range(int(input())):\nn=int(input())\nd={}\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    d.setdefault(u,[]).append(v)\n    d.setdefault(v,[]).append(u)\nnode=1\nfor key in d:\n    if(len(d[key])>len(d[node])):\n        node=key\nans=[]\nvisited=[0]*n\nvisited[node-1]=1\nfor c in d[node]:\n    while(True):\n        visited[c-1]=1\n        if(len(d[c])==1):\n            ans.append([node,c])\n            break\n        for child in d[c]:\n            if(visited[child-1]!=1):\n                c=child\n                break\nif(sum(visited)==n):\n    print(\"Yes\")\n    print(len(ans))\n    for c in ans:\n        print(*c)\nelse:\n    print(\"No\")",
    "complexity": "linear",
    "problem": "0981_C",
    "from": "CODEFORCES",
    "tags": "implementation,trees"
}
{
    "src": "# Fast IO Region\nimport os\nimport sys\nfrom io import BytesIO ,IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# Get out of main functoin\ndef main():\n    pass\n# decimal to binary\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n# binary to decimal\ndef decimal(s):\n    return (int(s, 2))\n# power of a number base 2\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return (p)\n# if  number is prime in \u221an time\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n# list to string ,no spaces\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n# String to list\ndef stl(s):\n    # for each character in string to list with no spaces -->\n    l = list(s)\n    # for space in string  -->\n    # l=list(s.split(\" \"))\n    return l\n# Returns list of numbers with a particular sum\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n# Sieve for prime numbers in a range\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n            # print(p)\n    return (cnt)\n# for positive integerse only\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n# 1000000007\nmod = int(1e9) + 7\ndef ssinp(): return input()\n# s=input()\ndef iinp(): return int(input())\n# n=int(input())\ndef nninp(): return map(int ,input().split())\n# a,b,c=map(int,input().split())\ndef llinp(): return list(map(int ,input().split()))\n# a=list(map(int,input().split()))\ndef p(xyz): print(xyz)\ndef p2(a ,b): print(a ,b)\nimport math\n\n# import random\n# sys.setrecursionlimit(300000)\n# from fractions import Fraction\nfrom collections import OrderedDict\n# from collections import deque\n########################                         mat=[[0 for i in range(n)] for j in range(m)]                      ########################\n########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################\n########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################\n########################                         from collections import deque                              ########################\n########################                         ASCII of A-Z= 65-90                                        ########################\n########################                         ASCII of a-z= 97-122                                       ########################\n########################                         d1.setdefault(key, []).append(value)                       ########################\n#for __ in range(iinp()):\na=llinp()\nans=0\nfor i in range(14):\n    temp=a.copy()\n    nos=temp[i]\n    temp[i]=0\n    for j in range(i+1,14):\n        temp[j]+=1\n        nos-=1\n    for j in range(0,14):\n        temp[j]+=nos//14\n    nos=nos%14\n    j=0\n    while(nos!=0):\n        temp[j]+=1\n        nos-=1\n        j+=1\n    ans1=0\n    for c in temp:\n        if(c%2==0):\n            ans1+=c\n    ans=max(ans,ans1)\np(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "complexity": "constant",
    "problem": "0975_B",
    "from": "CODEFORCES",
    "tags": "brute force,implementation"
}
{
    "src": "input()\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nu = [0] * len(a)\n\nans = 0\n\nfor i in range(len(a)):\n    if u[i] != 0:\n        continue\n    idx = i\n    while u[idx] == 0:\n        u[idx] = 1\n        idx = a[idx] - 1\n    \n    if (u[idx] == 2):\n        idx = i\n        while u[idx] == 1:\n            u[idx] = 2\n            idx = a[idx] - 1\n        continue\n\n    start = idx\n    mn = c[idx]\n    u[idx] = 2\n    while a[idx] - 1 != start:\n        idx = a[idx] - 1\n        mn = min(mn, c[idx])\n        u[idx] = 2\n\n    idx = i\n    while u[idx] == 1:\n        u[idx] = 2\n        idx = a[idx] - 1\n    ans += mn\nprint(ans)\n",
    "complexity": "linear",
    "problem": "1027_D",
    "from": "CODEFORCES",
    "tags": "dfs and similar,graphs"
}
{
    "src": "n=input();print(max(map(int,(n,n[:-1],n[:-2]+n[-1]))))",
    "complexity": "constant",
    "problem": "0313_A",
    "from": "CODEFORCES",
    "tags": "implementation,number theory"
}
{
    "src": "import sys\nimport math\n\n\ndef readlines(type=int):\n    return list(map(type, sys.stdin.readline().split()))\n\n\ndef read(type=int):\n    return type(sys.stdin.readline().strip())\n\n\njoint = lambda it, sep=\" \": sep.join(\n    [str(i) if type(i) != list else sep.join(map(str, i)) for i in it])\n\n\ndef solve_naive(n, k):\n    taken = set()\n    current_cap = 0\n    found = False\n    while current_cap != n:\n        for c in range(k, 1, -1):\n            found = False\n            if current_cap == 0:\n                if c <= n:\n                    current_cap += c\n                    taken.add(c)\n                    found = True\n                    break\n            else:\n                if c not in taken and c - 1 <= n - current_cap:\n                    current_cap += c - 1\n                    taken.add(c)\n                    found = True\n                    break\n        if not found:\n            break\n    return len(taken) if found else -1\n\n\ndef solve(n, k):\n    if n == 1:\n        return 0\n    if k >= n:\n        return 1\n    else:\n        if (3 - 2 * k) ** 2 - 8 * (n - k) < 0:\n            return -1\n        t = (-math.sqrt((3 - 2 * k) ** 2 - 8 * (n - k)) + (2 * k) - 3) / 2\n        if t == 0.0:\n            return 2\n        if t % 1 == 0:\n            return 1 + int(t)\n        else:\n            # print(f\"{t=}\")\n            return 2 + int(t)\n\n\ndef main():\n    n, k = readlines()\n    print(solve(n, k))\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "complexity": "logn",
    "problem": "0287_B",
    "from": "CODEFORCES",
    "tags": "binary search,math"
}
{
    "src": "tmp = input().split()\nn = int(tmp[0])\nm = int(tmp[1])\n\na = list()\nb = list()\ndiff = list()\nfor i in range(n):\n    tmp = input().split()\n    a.append(int(tmp[0]))\n    b.append(int(tmp[1]))\n    diff.append(a[i] - b[i])\n\ndiff.sort(reverse=True)\n\nsum_a = sum(a)\ni = 0 \nwhile sum_a > m and i < n:\n    sum_a = sum_a - diff[i]\n    i = i + 1 \n\nif i >= n and sum_a > m:\n    print(-1)\nelse:\n    print(i)",
    "complexity": "nlogn",
    "problem": "1015_C",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "n = int(input())\na = list(map(int, input().split(' ')))\n\nnew_a = [[0] * 600 for i in range(600)]\ndp = [[0x7fffffff] * 600 for i in range(600)]\n\nfor i in range(n):\n\tnew_a[i+1][i+1] = a[i]\n\tdp[i+1][i+1] = 1\n\nfor i in range(1, n + 1):\n\tfor j in range(i + 1, n + 1):\n\t\tdp[i][j] = j - i + 1\n\nfor llen in range(2, n + 1):\n\tfor left in range(1, n - llen + 2):\n\t\tright = left + llen - 1\n\t\tfor middle in range(left, right):\n\t\t\tdp[left][right] = min(dp[left][right], dp[left][middle] + dp[middle+1][right])\n\t\t\tif dp[left][middle] == 1 and dp[middle+1][right] == 1 and new_a[left][middle] == new_a[middle+1][right]:\n\t\t\t\tdp[left][right] = 1\n\t\t\t\tnew_a[left][right] = new_a[left][middle] + 1\n\nprint(dp[1][n])",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "N, K = list(map(int, input().split()))\nS = input().strip()\nS = [-1 if _ == '?' else ord(_) - ord('a') for _ in S]\n\ndef check(x):\n    p = [[N for i in range(N+1)] for k in range(K)]\n\n    for k in range(K):\n        keep = 0\n        for i in range(N-1, -1, -1):\n            keep += 1\n            if S[i] != -1 and S[i] != k:\n                keep = 0\n            p[k][i] = p[k][i+1]\n            if keep >= x:\n                p[k][i] = i + x - 1\n\n    d = [N for s in range(1<<K)]\n    d [0] = -1\n    for s in range(1, 1<<K):\n        for k in range(K):\n            if (s&(1<<k)) and (d[s^(1<<k)]<N):\n                d[s] = min(d[s], p[k][d[s^(1<<k)]+1])\n                # print('d[%d%d]=%d'%(s//2, s%2, d[s]))\n    return d[(1<<K)-1] < N\n    \nl, r = 0, N//K\n\nwhile l < r:\n    mid = (l + r + 1) // 2\n    if check(mid):\n        l = mid\n    else:\n        r = mid - 1\nprint(l)\n",
    "complexity": "np",
    "problem": "1550_E",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,brute force,dp,strings,two pointers"
}
{
    "src": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\n\nr, g, b = rints()\nar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]\nmem = [[[0 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]\nans = 0\n\nfor r1 in range(r + 1):\n    for g1 in range(g + 1):\n        for b1 in range(b + 1):\n            if r1 < r:\n                if g1 < g:\n                    mem[r1 + 1][g1 + 1][b1] = max(mem[r1 + 1][g1 + 1][b1], (ar[r1] * ag[g1]) + mem[r1][g1][b1])\n                if b1 < b:\n                    mem[r1 + 1][g1][b1 + 1] = max(mem[r1 + 1][g1][b1 + 1], (ar[r1] * ab[b1]) + mem[r1][g1][b1])\n\n            if g1 < g and b1 < b:\n                mem[r1][g1 + 1][b1 + 1] = max(mem[r1][g1 + 1][b1 + 1], (ag[g1] * ab[b1]) + mem[r1][g1][b1])\n\n            ans = max(ans, mem[r1][g1][b1])\n\nprint(ans)",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\nidx = list(range(n))\nidx.sort(key=lambda i: a[i], reverse=True)\nimin = imax = idx[0]\nfor i in idx[1:]:\n    if i == imin - 1 or i == imax + 1:\n        imin = min(imin, i)\n        imax = max(imax, i)\n    else:\n        print('NO')\n        exit(0)\nprint('YES')\n",
    "complexity": "nlogn",
    "problem": "1197_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation"
}
{
    "src": "from sys import stdin, stdout\nfrom math import sin, tan, cos\n\nn, m, k, l = map(int, stdin.readline().split())\n\nlb, rb = 0, n // m + 1\nwhile rb - lb > 1:\n    mid = (lb + rb) >> 1\n    \n    if mid * m - k >= l:\n        rb = mid\n    else:\n        lb = mid\n\nif lb != n // m:\n    stdout.write(str(rb))\nelse:\n    stdout.write('-1')",
    "complexity": "logn",
    "problem": "1068_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\ninput=sys.stdin.readline\nn=int(input())\na=list(map(int,input().split()))\nf=[[0]*n for i in range(n)]\nfor i in range(n):\n    f[0][i]=a[i]\nfor i in range(1,n):\n    for j in range(n-i):\n        f[i][j]=f[i-1][j]^f[i-1][j+1]\nfor i in range(1,n):\n    for j in range(n-i):\n        f[i][j]=max(f[i][j],f[i-1][j],f[i-1][j+1])\nq=int(input())\nfor _ in range(q):\n    l,r=map(int,input().split())\n    print(f[r-l][l-1])",
    "complexity": "quadratic",
    "problem": "0983_B",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "import math\ndef nCr(n,r):\n\tf = math.factorial\n\treturn f(n) / f(r) / f(n-r)\ndict1 = {'+':0,'-':0,'?':0}\nfor i in input():\n\tdict1[i]+=1\nfor i in input():\n\tif(i=='?'):\n\t\tdict1[i]+=1\n\telse:\n\t\tdict1[i]-=1\nif dict1['+']<0 or dict1['-']<0:\n\tprint(0.000000000000)\nelif dict1['+']==0 and dict1['-']==0:\n\tprint(1.000000000000)\nelif dict1['+'] and dict1['-']:\n\tans = (nCr(dict1['?'], dict1['+'])/(2**dict1['?']))\n\tprint(\"%.12f\" %ans)\nelse:\n\tans = (1 / (2 ** dict1['?']))\n\tprint(\"%.12f\" % ans)",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "n = int(input())\n\nstring = input()\ni = 0\nj = 0\ntotal = 0\n\nwhile j < len(string):\n    bool = False\n    count = 0\n    while j < len(string) and string[i] == 'x' and string[j] == 'x':\n        count += 1\n        bool = True\n        j += 1\n\n    if count >= 3:\n        total += (count-3)+1\n    if bool:\n        i = j\n    else:\n        i += 1\n        j += 1\n\n\n\nprint(total)\n",
    "complexity": "linear",
    "problem": "0978_B",
    "from": "CODEFORCES",
    "tags": "greedy,strings"
}
{
    "src": "from collections import defaultdict, Counter\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd\n \ndef read(): return list(map(int, input().strip().split()))\n \nans_ = []\n\n \n# for _ in range(int(input())):\nt_p = [2**i for i in range(31)]\nn = int(input()); \narr = Counter(read())\nd = defaultdict(int)\nm = 1; ans_lis = [[list(arr.keys())[0], 1]]\n\nfor i in arr:\n    for j in t_p:\n        a, b, c = i, i+j, i+2*j\n        s = arr[a] + arr[b] + arr[c]\n        if s > m:\n            m = s\n            ans_lis = [[x, arr[x]] for x in [a, b, c]]\n\n\nans_.append(m)\nt = \"\"\nfor i in ans_lis:t += (str(i[0])+\" \")*i[1]\nans_.append(t)\n\n\n\n\n\n \n \n# print(ans_)\nfor i in ans_:\n    print(i)\n \n \n\"\"\"\n0 2 4 \n3 5 7\n\n\n0 8 16\n\n\n\"\"\"",
    "complexity": "nlogn",
    "problem": "0988_D",
    "from": "CODEFORCES",
    "tags": "brute force,math"
}
{
    "src": "str1,str2=map(str,input(\"\").split())\nlst=[]\nlst_ans=[]\nl_count=0\ncount=0\nfor i in str2:\n    if(count<1):\n        lst.append(i)\n    else:\n        break\nfor i in str1:\n    if(count==0):\n        lst_ans.append(i)\n        count+=1\n    elif(ord(i)<ord(lst[0])):\n        lst_ans.append(i)\n    else:\n        lst_ans.append(lst[0])\n        break\nelse:\n    lst_ans.append(lst[0])\nprint(''.join(lst_ans))  ",
    "complexity": "linear",
    "problem": "0909_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy,sortings"
}
{
    "src": "def problem(s, p):\n    for i in range(len(p)):\n        l = p[:i] + ' '\n        r = p[i:] + ' '\n \n        dp = [0] + [None] * i\n \n        for x in s:\n            for j in range(i, -1, -1):\n                if dp[j] is None:\n                    continue\n \n                if l[j] == x:\n                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])\n \n                temp = r[dp[j]]\n                if r[dp[j]] == x:\n                    dp[j] += 1\n \n        if dp[-1] == len(r) - 1:\n            return 'YES'\n \n    return 'NO'\n \n \nfor _ in range(int(input())):\n    print(problem(input(), input()))\n\n\t\t\t \t \t   \t  \t     \t\t\t    \t\t\t \t",
    "complexity": "cubic",
    "problem": "1303_E",
    "from": "CODEFORCES",
    "tags": "dp,strings"
}
{
    "src": "\ndef main():\n    k = int(input())\n    n = []\n    a = []\n    for i in range(k):\n        line = [int(x) for x in input().split()]\n        ni = line[0]\n        ai = []\n        n.append(ni)\n        a.append(ai)\n        for j in range(ni):\n            ai.append(line[1 + j])\n    answer, c, p = solve(k, n, a)\n    if answer:\n        print(\"Yes\")\n        for i in range(k):\n            print(c[i], p[i] + 1)\n    else:\n        print(\"No\")\n\n\ndef solve(k, n, a):\n    asum, sums = calc_sums(k, n, a)\n    if asum % k != 0:\n        return False, None, None\n    tsum = asum / k\n    num_map = build_num_map(k, n, a)\n    masks = [None]*(1 << k)\n    simple = [False]*(1 << k)\n    answer = [False]*(1 << k)\n    left = [0]*(1 << k)\n    right = [0]*(1 << k)\n    by_last_one = [[] for _ in range(k)]\n    for i in range(k):\n        for j in range(n[i]):\n            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, [])\n            if found and not answer[mask]:\n                answer[mask] = True\n                masks[mask] = path\n                simple[mask] = True\n                by_last_one[calc_last_one(mask)].append(mask)\n    if answer[(1 << k) - 1]:\n        return build_answer(k, masks, left, right)\n    for mask_right in range(2, 1 << k):\n        if not simple[mask_right]:\n            continue\n        last_one = calc_last_one(mask_right)\n        zeroes_count = 0\n        alternative_sum = 0\n        zero_list = []\n        for u in range(last_one):\n            if (mask_right & (1 << u)) == 0:\n                zeroes_count += 1\n                alternative_sum += len(by_last_one[u])\n                zero_list.append(u)\n        if zeroes_count == 0:\n            continue\n        if alternative_sum < (1 << zeroes_count):\n            for fill_last_zero in zero_list:\n                for mask_left in by_last_one[fill_last_zero]:\n                    if (mask_left & mask_right) != 0:\n                        continue\n                    joint_mask = mask_left | mask_right\n                    if not answer[joint_mask]:\n                        answer[joint_mask] = True\n                        left[joint_mask] = mask_left\n                        right[joint_mask] = mask_right\n                        by_last_one[last_one].append(joint_mask)\n                        if joint_mask == ((1 << k) - 1):\n                            return build_answer(k, masks, left, right)\n        else:\n            for mask_mask in range(1 << zeroes_count):\n                mask_left = 0\n                for u in range(zeroes_count):\n                    if (mask_mask & (1 << u)) != 0:\n                        mask_left = mask_left | (1 << zero_list[u])\n                joint_mask = mask_left | mask_right\n                if answer[mask_left] and not answer[joint_mask]:\n                    answer[joint_mask] = True\n                    left[joint_mask] = mask_left\n                    right[joint_mask] = mask_right\n                    by_last_one[last_one].append(joint_mask)\n                    if joint_mask == ((1 << k) - 1):\n                        return build_answer(k, masks, left, right)\n    return False, None, None\n\n\ndef calc_last_one(x):\n    result = -1\n    while x > 0:\n        x = x >> 1\n        result = result + 1\n    return result\n\n\ndef build_answer(k, masks, left, right):\n    c = [-1] * k\n    p = [-1] * k\n    pos = (1 << k) - 1\n    while not masks[pos]:\n        for i, a, j in masks[right[pos]]:\n            c[i] = a\n            p[i] = j\n        pos = left[pos]\n    for i, a, j in masks[pos]:\n        c[i] = a\n        p[i] = j\n    return True, c, p\n\n\ndef build_num_map(k, n, a):\n    result = dict()\n    for i in range(k):\n        for j in range(n[i]):\n            result[a[i][j]] = (i, j)\n    return result\n\n\ndef find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):\n    if (mask & (1 << i)) != 0:\n        if i == i_origin and j == j_origin:\n            return True, mask, path\n        else:\n            return False, None, None\n    mask = mask | (1 << i)\n    a_needed = tsum - (sums[i] - a[i][j])\n    if a_needed not in num_map:\n        return False, None, None\n    i_next, j_next = num_map[a_needed]\n    path.append((i_next, a[i_next][j_next], i))\n    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)\n\n\ndef calc_sums(k, n, a):\n    sums = [0] * k\n    for i in range(k):\n        for j in range(n[i]):\n            sums[i] = sums[i] + a[i][j]\n    asum = 0\n    for i in range(k):\n        asum = asum + sums[i]\n    return asum, sums\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "complexity": "np",
    "problem": "1242_C",
    "from": "CODEFORCES",
    "tags": "bitmasks,dfs and similar,dp,graphs"
}
{
    "src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nimport bisect\nT = int(input())\nr = 1\nprime = [2]\n\nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue \n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0: \n            flag = True \n            break\n    if not flag:  prime.append(i)\n\ndef primefactor(num):\n\n    index = 0\n    output = []\n\n    while num>=prime[index]**2:\n\n        times = 0\n        while num%prime[index]==0:\n            num = num // prime[index]\n            times += 1\n        if times&1:  output.append(prime[index])\n        index += 1 \n\n    if num>1: output.append(num)\n\n\n    return tuple(output)\n\nwhile r<=T:\n    n,k = map(int,input().split())\n    arr = list(map(int,input().split()))\n\n    seg = 1\n    fact = {}\n    left = [[0 for j in range(k+1)] for i in range(n)]\n    dp = [[300000 for j in range(k+1)] for i in range(n)]\n\n    stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:\n            bisect.insort(stack,fact[factor]+1)\n            \n        fact[factor] = i\n\n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n\n\n\n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):\n                l = left[i][t]\n                if l>0:\n                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])\n                else:\n                    dp[i][j] = 1\n\n    print(dp[-1][-1])   \n    r += 1",
    "complexity": "cubic",
    "problem": "1497_E2",
    "from": "CODEFORCES",
    "tags": "data structures,dp,greedy,math,number theory,two pointers"
}
{
    "src": "from collections import Counter as C\nn, m = map(int, input().split())\nl = [*map(int, input().split())]\nc = sorted(C(l).items())\n\nres = 0\nj = 0\nfor hi, ni in c:\n    # print(hi, ni, j)\n    h = min(hi - j, ni) + j\n    res += (hi - 1) * ni \n    if h > j:\n        j = h\nm = max(l)\nif j < m:\n    res -= m - j\nprint(res)",
    "complexity": "nlogn",
    "problem": "1061_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "n,m=map(int,input().strip().split())\nv=[0]*51\nleft=1\nright=n\nfor i in range(1,n+1):\n\tif(n-i-1<=0):\n\t\tpw=1\n\telse:\n\t\tpw=(1<<(n-i-1))\n\n\tif(m<=pw):\n\t\tv[left]=i\n\t\tleft+=1\n\telse:\n\t\tv[right]=i\n\t\tright-=1\n\t\tm-=pw\nfor i in range(1,n):\n\tprint(v[i], end=' ')\nprint(v[n])\n\t\t\t   \t\t\t   \t  \t\t \t\t \t \t\t\t\t\t\t\t",
    "complexity": "np",
    "problem": "0513_B2",
    "from": "CODEFORCES",
    "tags": "bitmasks,divide and conquer,math"
}
{
    "src": "n = int(input())\ndp = [1]\nfor IND in range(n):\n    c = input()\n    if c == \"f\":\n        dp.insert(0,0)\n    else:\n        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007\nprint(dp[0])\n",
    "complexity": "quadratic",
    "problem": "0909_C",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "n, a, b = map(int, input().split())\nz, o = ('01', '10')[a < b]\nn *= not (a > 1 < b or 1 < n * a * b < 4)\nl = [[z] * n for _ in range(n)]\nfor i in range(n):\n    l[i][i] = '0'\nfor i in range(n - a * b):\n    l[i][i + 1] = l[i + 1][i] = o\nprint(('YES', 'NO')[not n])\nprint('\\n'.join(map(''.join, l)))",
    "complexity": "quadratic",
    "problem": "0990_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,graphs,implementation"
}
{
    "src": "# template begins\n#####################################\nfrom io import BytesIO, IOBase\nimport sys\nimport math\nimport os\nfrom collections import defaultdict\nfrom math import ceil\nfrom bisect import bisect_left, bisect_left\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\ndef mint(): return map(int, input().split())\ndef mfloat(): return map(float, input().split())\n\n\n#####################################\n# template ends\n# Use the recursion snippet if heavy recursion is needed (depth>1000)\ndef solve():\n    n, m, k = mint()\n    horizontal = [list(mint()) for i in range(n)]\n    vertical = [list(mint()) for i in range(n-1)]\n    if k%2 or max(n, m)==1:\n        for i in range(n):\n            print(*[-1]*m)\n        return\n    \"\"\"\n    does it make sense to double back on a path if k is large enough?\n    or are there cases when you need to make a loop?\n\n    proof:\n    if you have a path of length k that does not visit any edge more than once,\n    we can split it into 2 paths of length k/2\n    if one of them was cheaper than the other, we should have just back tracked on that\n    hence, both must be the same\n    in that case, you can just double any one\n\n    should ideally double back on the same path if k is big enough\n    just find the cheapest path of length k/2 and double it?\n\n    how do you find the cheapest path of length k/2?\n\n    dp?\n    store the cheapest path of length x from every node,\n    where x will be from 1 to k/2\n    yeah should work\n    dp[i][j][x] represents the cheapest path of length from g[i][j] of length x\n    \"\"\"\n    dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]\n    for length in range(1, k//2+1):\n        for i in range(n):\n            for j in range(m):\n                \"\"\"\n                we want cost_to_neighbour + dp[neigbour][length-1] to be min\n                \"\"\"\n                left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]\n                right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]\n                top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]\n                bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]\n                dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])\n    for i in range(n):\n        for j in range(m):\n            print(dp[i][j][k//2]*2, end=' ')\n        print()\n\n    \n\ndef main():\n    # t = int(input())\n    t = 1\n    for _ in range(t):\n        solve()\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res//x * (x-1)\n            while n%x==0:\n                n //= x\n    if n!=1:\n        res = res//n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n//=b\n    return res\n\ndef isPrimeMR(n):\n    if n==1:\n        return 0\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):#\u6392\u4ed6\u7684\u8ad6\u7406\u548c\u306e\u968e\u4e57\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\n#O(|S|)\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=0):\n        self.BIT = [0]*(n+1)\n        self.num = n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matridigit[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matridigit[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matridigit[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matridigit[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m//=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matridigit[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn,mod = mi()\n\nN = 1000\ng1 = [1]*(N+1)\ng2 = [1]*(N+1)\ninverse = [1]*(N+1)\n\nfor i in range( 2, N + 1 ):\n    g1[i]=( ( g1[i-1] * i ) % mod )\n    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2[i]=( (g2[i-1] * inverse[i]) % mod )\ninverse[0]=0\n\npow_2 = [1 for i in range(1001)]\nfor i in range(1,1001):\n    pow_2[i] = (pow_2[i-1] * 2) % mod\n\ndp = [[1]]\n\nfor i in range(n):\n    ndp = [[0] + [dp[s][k] for k in range(i+1)] for s in range(i+1)] + [[0 for k in range(i+2)]]\n    for s in range(i+1):\n        for k in range(i+1):\n            if not dp[s][k]:\n                continue\n            #auto\n            if k!=0:\n                ndp[s+k][0] += (dp[s][k] * g2[k] % mod) * pow_2[k-1] % mod\n                ndp[s+k][0] %= mod\n\n    dp = ndp\n\nres = 0\nfor s in range(n+1):\n    for k in range(1,n+1):\n        res += (pow_2[k-1] * g1[s+k] % mod) * (dp[s][k] * g2[k] % mod) % mod\n        res %= mod\n\nprint(res)\n",
    "complexity": "cubic",
    "problem": "1515_E",
    "from": "CODEFORCES",
    "tags": "combinatorics,dp,math"
}
{
    "src": "n = int(input())\nb = list(map(int, input().split(' ')))\ne = [[-1] * (n+1) for _ in range(2048)]\n \nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n \nfor v in range(1, 2048):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\tif j != -1:\n\t\t\th = e[v][j+1]\n\t\telse:\n\t\t\th = -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n \na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\tif s > 0:\n\t\t\ttemp = a[s-1]+1\n\t\telse :\n\t\t\ttemp = 1\n\t\ta[e] = min(a[e], temp)\nprint(a[n-1])",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "d4i=[0,-1,0,1]\nd4j=[-1,0,1,0]\n\ndef main():\n    \n    n,m,k=readIntArr()\n    horizontalEdges=[] # [i,j] represents [i,j] to [i,j+1]\n    for _ in range(n):\n        horizontalEdges.append(readIntArr())\n    verticalEdges=[] # [i,j] represents [i,j] to [i+1,j]\n    for _ in range(n-1):\n        verticalEdges.append(readIntArr())\n    \n    if k%2==1: # impossible\n        ans=makeArr(-1,[n,m])\n    else:\n        dp=makeArr(inf,[n,m,k//2+1]) # dp[i][j][nMoves] is the minimum possible boredom\n        for i in range(n):\n            for j in range(m):\n                dp[i][j][0]=0\n        for nM in range(1,k//2+1): # nM is nMoves\n            for i in range(n):\n                for j in range(m):\n                    # move right\n                    if j+1<m:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i][j+1][nM-1]+horizontalEdges[i][j])\n                    # move left\n                    if j-1>=0:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i][j-1][nM-1]+horizontalEdges[i][j-1])\n                    # move down\n                    if i+1<n:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i+1][j][nM-1]+verticalEdges[i][j])\n                    # move up\n                    if i-1>=0:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i-1][j][nM-1]+verticalEdges[i-1][j])\n        ans=makeArr(0,[n,m])\n        for i in range(n):\n            for j in range(m):\n                ans[i][j]=dp[i][j][k//2]*2\n    \n    multiLineArrayOfArraysPrint(ans)\n    \n    return\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n \ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n\ndef makeArr(defaultVal,dimensionArr): # eg. makeArr(0,[n,m])\n    dv=defaultVal;da=dimensionArr\n    if len(da)==1:return [dv for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(x,y):\n    print('? {} {}'.format(x,y))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\n# MOD=10**9+7\nMOD=998244353\n \n \nfor _abc in range(1):\n    main()",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "#   Author: yumtam\n#   Created at: 2021-05-02 23:39\n\ndef is_square(x):\n    sq = int(x**0.5)\n    return sq * sq == x\n\nfor _ in range(int(input())):\n    n = int(input())\n\n    if ((n % 2 == 0 and is_square(n//2))\n            or (n % 4 == 0 and is_square(n//4))):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
    "complexity": "constant",
    "problem": "1515_B",
    "from": "CODEFORCES",
    "tags": "brute force,geometry,math,number theory"
}
{
    "src": "N, K = map(int, input().split())\nif N == K:\n    print(\"0\"*N)\nelif K == 1:\n    print(\"0\"*(N-1) + \"1\")\nelif K == 3:\n    print(\"1\" + \"0\"*(N-4) + \"101\")\nelse:\n    res = [\"0\"]*N\n    for i in range(0, N, N//2-K//2+1):\n        res[i] = \"1\"\n    print(''.join(res))",
    "complexity": "linear",
    "problem": "1159_D",
    "from": "CODEFORCES",
    "tags": "brute force,greedy,constructive algorithms,math,strings"
}
{
    "src": "from sys import stdout\n\nn = int(input())\n\nif n % 4 == 2:\n    print('!', -1)\n    exit(0)\n\nl = 1\nr = l + n // 2\n\nmemo = [-1] * (n + 1)\n\ndef check(i):\n    if memo[i] == -1:\n        print('?', i)\n        stdout.flush()\n\n        memo[i] = int(input())\n\n    return memo[i]\n\nwhile r >= l:\n    a = check(l)\n    b = check(l + n // 2)\n    \n    if a == b:\n        print('!', l)\n        exit(0)\n\n    mid = (l + r) >> 1\n\n    c = check(mid)\n    d = check(mid + n // 2)\n\n    if c == d:\n        print('!', mid)\n        exit(0)\n\n    if (a < b and c < d) or (a > b and c > d):\n        l = mid + 1\n\n    else:\n        r = mid\n\n    \n\n",
    "complexity": "logn",
    "problem": "1019_B",
    "from": "CODEFORCES",
    "tags": "binary search,interactive"
}
{
    "src": "def binary_search(n, k):\n    left = -1\n    right = n\n    while left < right - 1:\n        middle = (left + right) // 2\n        if middle % 2 != 0:\n            s = (1 + middle) * (middle // 2) + ((1 + middle) // 2)\n        else:\n            s = (1 + middle) * (middle // 2)\n        if s - (n - middle) >= k:\n            right = middle\n        else:\n            left = middle\n    return right\n\n\nn, k = map(int, input().split())\ni = 1\ncount = 0\nprint(n - binary_search(n, k))",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "# Fonte https://cs.stackexchange.com/questions/29508/finding-the-max-xor-of-two-numbers-in-an-interval-can-we-do-better-than-quadrat\nl, r = [int(x) for x in input().split()]\n\nq = l ^ r\na = 1\nwhile q:\n    q //=2\n    a <<= 1\nprint(a-1)\n\n \t \t\t\t \t \t\t\t    \t \t\t\t \t\t\t \t\t \t\t",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "n = int(input())\nmod = 10**9+7\ndp = [0]*(n+1)\ndp[0] = 1\nfor i in range(n):\n    nx = [0]*(n+1)\n    s = str(input())\n    if s == 'f':\n        nx[0] = 0\n        for j in range(1, n+1):\n            nx[j] = dp[j-1]\n            nx[j] %= mod\n    else:\n        nx[n] = dp[n]\n        for j in reversed(range(n)):\n            nx[j] = nx[j+1]\n            nx[j] += dp[j]\n            nx[j] %= mod\n    if i != n-1:\n        dp = nx\nprint(sum(dp)%mod)\n",
    "complexity": "quadratic",
    "problem": "0909_C",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "#n=int(input())\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\ndef next(k,a):\n    i=k+1\n    while a[i]!=1: i+=1\n    return i\n\nans=[0]*(m+1)\n\nk=-1\nk=next(k,b)\nans[1]=k\nfor i in range(2,m+1):\n    kk=next(k,b)\n    for j in range(k+1,kk):\n        if a[j]-a[k]<=a[kk]-a[j]:\n            ans[i-1]+=1\n        else:\n            ans[i]+=1\n    k=kk\n    \n\nans[m]+=(n+m-1-k)\n\nfor i in range(1,m+1):\n    print(ans[i],end=' ')\n",
    "complexity": "quadratic",
    "problem": "1075_B",
    "from": "CODEFORCES",
    "tags": "implementation,sortings"
}
{
    "src": "n = int(input())\nprint(n, 0, 0)",
    "complexity": "constant",
    "problem": "0199_A",
    "from": "CODEFORCES",
    "tags": "brute force,constructive algorithms,implementation,number theory"
}
{
    "src": "import sys\n\nn, m, k = list(map(int, sys.stdin.readline().strip().split()))\na = list(map(int, sys.stdin.readline().strip().split()))\nb = [0] * (n+1)\nfor i in range (1, n+1):\n    b[i] = b[i-1] + m * a[i-1] - k\nM = [10 ** 20] * m\nans = 0\nfor i in range (0, n+1):\n    M[i % m] = min([M[i % m], b[i]])\n    for j in range (0, m):\n        if i > j:\n            ans = max([ans, b[i]-M[j]-k*((m*i+m-(i-j))%m)])\n    # print(j, M, ans)\nprint(ans // m)\n",
    "complexity": "quadratic",
    "problem": "1197_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,math"
}
{
    "src": "n, k= map(int, input().split())\nA = list(map(int, input().split()))\nC = [0] * 100001\n\nl = 0\nr = 0\np = 0\n\nwhile r<n and p < k:\n    C[A[r]] += 1\n    if C[A[r]] == 1:\n        p += 1\n    r += 1\nif p != k:\n    print('-1', '-1')\nelse:\n    while p == k:\n        C[A[l]] -= 1\n        if C[A[l]] == 0:\n            p -= 1\n        l +=1\n        \n    l -= 1\n    \n    print(l+1,r)",
    "complexity": "linear",
    "problem": "0224_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,implementation,two pointers"
}
{
    "src": "\nfrom sys import stdout\na, b = 0, 0\n\n\nmp = 29\n\nc, d = 0,0\n\npowers = [1]\nfor i in range(32):\n    powers.append(powers[-1]*2)\n\nqqq = 0\n\ndef get_ans(c, d):\n    global qqq\n    qqq += 1\n    a, b = 1073741823, 1073741821\n    a, b = 3, 1\n\n    print(c, d)\n\n    if (a^c) > (b^d): \n        print(1)\n        return -1\n    elif (a^c) < (b^d):\n        print(-1)\n        return 1\n    print(0)\n    return 0\n\ndef get_ans(c, d):\n    print('? {} {}'.format(c, d))\n    stdout.flush()\n    return -int(input())\n\nq = get_ans(0, 0)\n\nfor i in range(mp+1):\n    cp = mp - i\n    c += powers[cp]\n    d += powers[cp]\n    #print('cp, q', cp, q)\n    if q == 0:\n        continue\n    t = get_ans(c, d)\n    #print('t', t)\n\n    if t != q:\n    #    print('t != q')\n    #    print(a, b,c,d)\n        if t == 1:\n            a += powers[cp]\n            c -= powers[cp]\n        elif t == -1:\n            b += powers[cp]\n            d -= powers[cp]\n        q = get_ans(c, d)\n\n    #print(a, b, c, d)\n\n#print('qwe', a, b, c, d)\n\n\nfor i in range(mp+1):\n    cp = mp - i\n    #print(c, powers[cp], d)\n    if c & powers[cp] > 0 and d & powers[cp] > 0:\n        c -= powers[cp]\n        t = get_ans(c, d)\n\n        if t < 0:\n            a += powers[cp]\n            b += powers[cp]\n\n        c += powers[cp]\n\nprint('!', a, b)\n\n\n",
    "complexity": "logn",
    "problem": "1088_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,constructive algorithms,implementation,interactive"
}
{
    "src": "# qumeric\nn, m = map(int, input().split())\na = [int(input(), 2) for _ in range(n)]\n\ns = t = 0\nfor x in a:\n    t |= s & x\n    s |= x\nprint((\"YES\", \"NO\")[all(x & s & ~t for x in a)])\n",
    "complexity": "quadratic",
    "problem": "0985_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "def A(n):\n\treturn (4**n-1)//3\n\nL = 31\n\nT = int(input())\nfor _ in range(T):\n\tn,k = [int(_) for _ in input().split()]\n\n\tif n > L:\n\t\tprint(\"YES\",n-1)\n\t\tcontinue\n\n\tif k > A(n):\n\t\tprint(\"NO\")\n\t\tcontinue\n\n\tE = 1\n\tM = 0\n\tR = 0\n\twhile n >= 0:\n\t\tM += E\n\n\t\tI = 2*E-1\n\t\tE = 2*E+1\n\n\t\tn -= 1\n\t\tR += I*A(n)\n\n\t\tif M <= k and k <= M+R: break\n\n\tif n >= 0: print(\"YES\",n)\n\telse: print(\"NO\")\n",
    "complexity": "linear",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "import sys\n\ninput = sys.stdin.buffer.readline\n\ndef find_pair(candidate,data,m):\n    ans = (-1,-1)\n    binary_bit = [False for i in range(1 << m)]\n    for i in data:\n        bit_tmp = 0\n        for j in range(len(i)):\n            if i[j] >= candidate: bit_tmp |= 1 << j\n        binary_bit[bit_tmp] = True\n    \n    for i in range(1 << m):\n        for j in range(1 << m):\n            if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]:\n                ans = i , j\n                break\n    return ans\n\ndef backtracking(candidate,ans,data):\n    idx_i = -1 ; idx_j = -1\n    for i in range(len(data)):\n        bit_tmp = 0\n        for j in range(len(data[i])):\n            if data[i][j] >= candidate: bit_tmp |= 1 << j\n        if bit_tmp == ans[0]: idx_i = i\n        if bit_tmp == ans[1]: idx_j = i\n\n    print(str(idx_i + 1) + \" \" + str(idx_j + 1))\n\ndef main():\n    n , m = [int(i) for i in input().split()]\n    data = [[int(i) for i in input().split()] for i in range(n)]\n    a = 0 ; b = 10**9 + 7\n    ans = (-1,-1)\n    candidate = -1\n    while a <= b:\n        mid = (a + b)//2\n        bin_ans = find_pair(mid,data,m)\n        if bin_ans[0] != -1 and bin_ans[1] != -1:\n            ans = bin_ans\n            candidate = mid\n            a = mid + 1\n        else:\n            b = mid - 1\n    backtracking(candidate,ans,data)\n\nmain()\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "#------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n#-------------------game starts now----------------------------------------------------\nn,m=map(int,input().split())\ns=0\ne=n-1\nfor i in range(n//2):\n    for j in range(m):\n        print(s+1,j+1)\n        print(e+1,m-j)\n    s+=1\n    e-=1\nif n%2==1:\n    s=n//2\n    for j in range(m//2):\n            print(s+1,j+1)\n            print(s+1,m-j)\n    if m%2==1:\n            print(s+1,m//2+1)",
    "complexity": "quadratic",
    "problem": "1179_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms"
}
{
    "src": "n = int(input())\ns = input()\nt = 0\nfor i in s:\n    if i == '+':\n        t += 1\n    else:\n        t = max(t - 1, 0)\n\nprint(max(t, 0))\n",
    "complexity": "linear",
    "problem": "1159_A",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "n,k = map(int,input().split())\na = list(map(int,input().split()))\np = sorted(a)\np = p[-k:]\ns = sum(p)\nprint(s)\nidx = 0\ni = 0\ncount = 0\nans = []\nwhile len(ans)<k-1:\n    idx+=1\n    count+=1\n    if a[i] in p:\n        p.remove(a[i])\n        ans.append(count)\n        count = 0\n    i+=1\nfor i in ans:\n    print(i,end = \" \")\nprint(n-idx)\n        \n",
    "complexity": "nlogn",
    "problem": "1006_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "n, p=map(int, input().split())\narr=list(map(int, input().split()))\nsu=0\nfor i in range(n):\n\tsu+=arr[i]\nmaxi, f=0, 0\nfor i in range(n-1):\n\tf+=arr[i]\n\tmaxi=max(maxi, f%p+(su-f)%p)\nprint(maxi)",
    "complexity": "linear",
    "problem": "0958_C1",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nQ, = getIntList()\nfor _ in range(Q):\n    N, M, K  = getIntList()\n    if max(N,M) >K:\n        print(-1)\n        continue\n    r = K\n    if N%2!= K%2:\n        r-=1\n    if M%2!= K%2:\n        r-=1\n    print(r)\n\n\n\n\n\n\n",
    "complexity": "constant",
    "problem": "1036_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n=int(input())\na=list(map(int,input().split()))\na.sort()\nlose=False\npair=False\nfor i in range(n-1):\n  if a[i]==a[i+1]==0:\n    lose=True\n  if a[i]==a[i+1]:\n    if pair:\n      lose=True\n    pair=True\n    if i>=1:\n      if a[i]==a[i-1]+1:\n        lose=True\nif lose:\n  print(\"cslnb\")\nelse:\n  eventual=n*(n-1)//2\n  curr=sum(a)\n  if (curr-eventual)%2==0:\n    print(\"cslnb\")\n  else:\n    print(\"sjfnb\")\n",
    "complexity": "nlogn",
    "problem": "1190_B",
    "from": "CODEFORCES",
    "tags": "games"
}
{
    "src": "n, k = map(int, input().split())\nnums = list(map(int, input().split()))\ncounts = [{} for _ in range(11)]\nfor n in nums:\n    a = n\n    for i in range(11):\n        r = a % k\n        try:\n            counts[i][r] += 1\n        except KeyError:\n            counts[i][r] = 1\n        a *= 10\nres = 0\nfor i in nums:\n    wo = str(i)\n    le = len(wo)\n    mimo = (k-(i % k)) % k\n    if mimo in counts[le]:\n        res += counts[le][mimo]\n        if int(wo+wo) % k == 0:\n            res -= 1\nprint(res)",
    "complexity": "nlogn",
    "problem": "1029_D",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "import sys\n\ndef ask(x):\n    print('? %d'%x)\n    sys.stdout.flush()\n    x=int(input())\n    return x\n\nn=int(input())\nt=n//2\nif t&1:\n    print('! -1')\n    sys.stdout.flush()\n    sys.exit()\nl=1\nr=n\nwhile l<r:\n    mid=(l+r)>>1\n    if ask(mid)>=ask((mid+t-1)%n+1):\n        r=mid\n    else:\n        l=mid+1\nprint('! %d'%l)\nsys.stdout.flush()\n",
    "complexity": "logn",
    "problem": "1019_B",
    "from": "CODEFORCES",
    "tags": "binary search,interactive"
}
{
    "src": "from math import log2\nimport sys\nout = sys.stdout\nn = int(input())\nif n == 3:\n    print(1, 1, 3)\nelse:\n    tmp = n\n    current = 1\n    while n != 1:\n        if n % 2 != 0:\n            z = (n//2) + 1\n        else:\n            z = n//2\n        for i in range(z):\n            out.write(str(current) + ' ')\n        n -= z\n        current *= 2\n    step = int(log2(tmp))\n    if tmp % 2**(step - 1) == 0:\n        out.write(str(tmp))\n    else:\n        q = 2**(step - 1)\n        ans = 0\n        for i in range(1, 1000):\n            if q*i <= tmp:\n                ans = max(ans, q*i)\n            else:\n                break\n        out.write(str(ans))",
    "complexity": "nlogn",
    "problem": "1059_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "from math import gcd\nimport sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dd\nm=int(input())\nd=dd(int)\nl=[]\nfor i in range(m):\n    s=input().split()[0]\n    a=0\n    b=0\n    c=0\n    n=len(s)\n    ind=0\n    for i in range(1,n):\n        if(s[i]=='+'):\n            ind=i+1\n            break\n        a=a*10+int(s[i])\n    for i in range(ind,n):\n        if(s[i]==')'):\n            ind1=i+2\n            break\n        b=b*10+int(s[i])\n    for i in range(ind1,n):\n        c=c*10+int(s[i])\n    a=a+b\n    g=gcd(a,c)\n    a=a//g\n    c=c//g\n    d[(a,c)]+=1\n    l.append((a,c))\nfor i in l:\n    print(d[i],end=\" \")\n",
    "complexity": "linear",
    "problem": "0958_D1",
    "from": "CODEFORCES",
    "tags": "expression parsing,math"
}
{
    "src": "a = input()\nb = input()\nl = a.count(\"+\")-a.count(\"-\")\nk = b.count(\"?\")\nif k==0:\n    if (b.count(\"+\")-b.count(\"-\"))==l:\n        print(1)\n    else:\n        print(0)\nelse:\n    n=2**k\n    r=k\n    c=[]\n    t=0\n    while r>=0:\n        c.append(r-t)\n        t+=1\n        r-=1\n    import math\n    d=[]\n    for i in range(k+1):\n        d.append((math.factorial(k))//(math.factorial(i)*math.factorial(k-i)))\n    f = b.count(\"+\")-b.count(\"-\")\n    if l-f in c:\n        print((d[c.index(l-f)])/sum(d))\n    else:\n        print(0)",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "n = int(input())\na = tuple(map(int, input().split()))\nif n * 2 > sum(a) + 2:\n\tprint(\"NO\")\nelse:\n\tn1 = []\n\ton = []\n\tfor i in range(n):\n\t\tif a[i] != 1:\n\t\t\tn1.append(i)\n\t\telse:\n\t\t\ton.append(i)\n\tprint(\"YES\", len(n1) + min(2, len(on)) - 1)\n\tprint(n - 1)\n\tn1it = iter(n1)\n\tnext(n1it)\n\tfor v, u in zip(n1, n1it):\n\t\tprint(v + 1, u + 1)\n\tif on:\n\t\tprint(on.pop() + 1, n1[-1] + 1)\n\tif on:\n\t\tprint(on.pop() + 1, n1[0] + 1)\n\ton = iter(on)\n\tfor n11 in n1:\n\t\tfor i in range(a[n11] - 2):\n\t\t\ttry:\n\t\t\t\tprint(n11 + 1, next(on) + 1)\n\t\t\texcept StopIteration:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tcontinue\n\t\tbreak\n",
    "complexity": "linear",
    "problem": "1082_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,graphs,implementation"
}
{
    "src": "n,m = map(int, input().split())\na = []\nfor i in range(n):\n    s = input()\n    a.append(s)\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == '.':\n            continue\n        if i >= 2 and j >= 2:\n            if a[i-2][j-2] == '#' and a[i-2][j-1] == '#' and a[i-2][j] == '#' \\\n                    and a[i-1][j] == '#' and a[i-1][j-2] == '#' and a[i][j-1] == '#' and a[i][j-2] == '#':\n                continue\n        if i >= 1 and i <= n-2 and j >= 2 and a[i-1][j-2] == '#' and a[i-1][j-1] == '#' and a[i-1][j] == '#' \\\n                and a[i][j-2] == '#' and a[i+1][j-2] == '#' and a[i+1][j-1] == '#' and a[i+1][j] == '#':\n            continue\n        if i <= n-3 and j >= 2 and a[i][j-1] == '#' and a[i][j-2] == '#' and a[i+1][j] == '#' \\\n                and a[i+1][j-2] == '#' and a[i+2][j] == '#' and a[i+2][j-1] == '#' and a[i+2][j-2] == '#':\n            continue\n        if i <= n-3 and j >= 1 and j <= m-2 and a[i][j-1] == '#' and a[i][j+1] == '#' and a[i+1][j-1] == '#' \\\n                and a[i+1][j+1] == '#' and a[i+2][j] == '#' and a[i+2][j-1] == '#' and a[i+2][j+1] == '#':\n            continue\n        if i <= n-3 and j <= m-3 and a[i][j+1] == '#' and a[i][j+2] == '#' and a[i+1][j] == '#' \\\n                and a[i+1][j+2] == '#' and a[i+2][j] == '#' and a[i+2][j+1] == '#' and a[i+2][j+2] == '#':\n            continue\n        if i <= n-2 and i >= 1 and j <= m-3 and a[i-1][j] == '#' and a[i-1][j+1] == '#' and a[i-1][j+2] == '#' \\\n                and a[i][j+2] == '#' and a[i+1][j] == '#' and a[i+1][j+1] == '#' and a[i+1][j+2] == '#':\n            continue\n        if i >= 2 and j <= m-3 and a[i-2][j] == '#' and a[i-2][j+1] == '#' and a[i-2][j+2] == '#' \\\n                and a[i-1][j] == '#' and a[i-1][j+2] == '#' and a[i][j+1] == '#' and a[i][j+2] == '#':\n            continue\n        if i >= 2 and j <= m-2 and j >= 1 and a[i-2][j-1] == '#' and a[i-2][j] == '#' and a[i-2][j+1] == '#' \\\n                and a[i-1][j-1] == '#' and a[i-1][j+1] == '#' and a[i][j-1] == '#' and a[i][j+1] == '#':\n            continue\n        print('NO')\n        exit()\nprint('YES')",
    "complexity": "quadratic",
    "problem": "1059_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n = int(input())\nfor _ in range(n):\n    l, r = map(int, input().split())\n    if (l - r) % 2 == 1:\n        if l % 2:\n            print((r-l+1)//2)\n        else:\n            print(-((r-l+1)//2))\n    else:\n        ans = 0\n        if l % 2:\n            ans = ans + (r-l)//2\n        else:\n            ans = ans + -(r-l)//2\n        if r % 2:\n            ans = ans - r\n        else:\n            ans = ans + r\n        print(ans)",
    "complexity": "constant",
    "problem": "1080_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n \nn = int(input())\nli = []\n \nfor i in range(n):\n    x,w = map(int,input().split())\n    li.append((x-w,x+w))\n \nli.sort(key = lambda x: x[1])\n \na = -10 ** 9\nans = 0\n \nfor i in range(n):\n     if a <= li[i][0]:\n         ans += 1\n         a = li[i][1]\n \nprint(ans)",
    "complexity": "nlogn",
    "problem": "0528_B",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n,s = [int(x) for x in input().split()]\nv=[ [] ]\nfor i in range(n):\n\tv.append([])\n\t\nfor i in range(n-1):\n\ta, b =[int(x) for x in input().split()]\n\tv[a].append(b)\n\tv[b].append(a)\n\nans =0\nfor i in range(1,n+1):\n\tif len(v[i])==1:\n\t\tans+=1\n\t\nprint(2*s/ans)\n",
    "complexity": "linear",
    "problem": "1086_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,trees"
}
{
    "src": "n, m = map(int, input().split())\narr = list(map(int, input().split()))\nd = {}\ni = 1\nfor x in arr:\n\tif len(d) == m:\n\t\tbreak\n\td[x] = i\n\ti += 1\nif len(d) == m:\n\tprint(min(d.values()), max(d.values()))\nelse:\n\tprint(-1,-1)\n",
    "complexity": "linear",
    "problem": "0224_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,implementation,two pointers"
}
{
    "src": "import math as mt\nimport sys\ninput=sys.stdin.readline\nI=lambda:list(map(int,input().split()))\nn,m=I()\na=[I() for i in range(n)]\nans=[]\nlo=0\nhi=10**9\ndef vanguda(mid: int) -> bool:\n    global ans\n    f={}\n    for i in range(n):\n        bi=0\n        for j in range(m):\n            if a[i][j]>=mid:\n                bi+=1\n            bi<<=1\n        f[bi>>1]=i\n    for aa,bb in f.items():\n        for cc,dd in f.items():\n            if aa|cc==(2**m-1):\n                ans =bb+1,dd+1\n                return True\n    return False\n\nwhile lo<=hi:\n\tmid=(lo+hi)//2\n\tif vanguda(mid):\n\t\tlo=mid+1\n\telse:\n\t\thi=mid-1\nprint(*ans)\n\n\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "n,k=list(map(int,input().split()))\narr=list(map(int,input().split()))\nnewarr=[0]\n\nfor num in arr:\n  newarr+=[newarr[-1]^num]\ndic={}\nfor num in newarr:\n  x=(min(num,2**k-1-num),max(num,2**k-1-num))\n  if x in dic:\n    dic[x]+=1\n  else:\n    dic[x]=1\nans=0\nfor elem in dic:\n  m=dic[elem]\n  half=m//2\n  ans+=half*(half-1)/2\n  half=m-half\n  ans+=half*(half-1)/2\nans=n*(n+1)/2-ans\nprint(int(ans))\n  \n    \n",
    "complexity": "linear",
    "problem": "1054_D",
    "from": "CODEFORCES",
    "tags": "greedy,implementation"
}
{
    "src": "import sys\n\nn = int(sys.stdin.readline())\na = list(map(int, sys.stdin.readline().split(' ')))\nArray = [a]\n \nfor i in range(n - 1):\n    aux = []\n    for j in range(1, len(Array[-1])):\n        aux.append(Array[-1][j-1] ^ Array[-1][j])\n    Array.append(aux)\n \nfor j in range(1, len(Array)):\n    for k in range(len(Array[j])):\n        Array[j][k] = max(Array[j][k], Array[j-1][k], Array[j - 1][k + 1])\n \nq = int(sys.stdin.readline())\nfor i in range(q):\n    l, r = map(int, sys.stdin.readline().split(' '))\n    sys.stdout.write(str(Array[r - l][l - 1]) + '\\n')\n \t\t\t\t\t \t \t\t\t  \t\t  \t\t\t \t\t  \t  \t",
    "complexity": "quadratic",
    "problem": "0983_B",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "def maxXORInRange(L, R): \n    LXR = L ^ R \n    msbPos = 0\n    while(LXR): \n      \n        msbPos += 1\n        LXR >>= 1\n    maxXOR, two = 0, 1\n      \n    while (msbPos): \n      \n        maxXOR += two \n        two <<= 1\n        msbPos -= 1\n  \n    return maxXOR \nL, R = map(int,input().split())\nprint(maxXORInRange(L, R)) \n",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "n = int(input())\np = list(map(lambda x: int(x) - 1, input().split()))\n\nvis = [False] * n\nodd = 0\nfor x in range(n):\n    if vis[x]:\n        continue\n    odd ^= 1\n    while not vis[x]:\n        odd ^= 1\n        vis[x] = True\n        x = p[x]\n\nprint('Petr' if (n + odd) % 2 == 0 else 'Um_nik')\n",
    "complexity": "nlogn",
    "problem": "0986_B",
    "from": "CODEFORCES",
    "tags": "combinatorics,math"
}
{
    "src": "x,k=map(int,input().split())\nm=10**9+7\nprint((x*pow(2,k+1,m) -pow(2,k,m) +1) %(m)) if x >0 else print(0)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import math\n\nn=int(input())\nk=1\nwhile(n > 9*k*(10**(k-1))):\n    n = n - 9*k*(10**(k-1))\n    k = k + 1\nremainder = n%k\nif remainder == 0:\n    remainder = k\nif k==1:\n    quoteint = math.ceil(n/k)\nelse:\n    adder = \"9\"*(k-1)\n    adder = int(adder)\n    quoteint = math.ceil(n/k) + adder\nprint(str(quoteint)[remainder-1])\n\n\n\n\n    \n    \n    \n        \n        \n        \n    \n\n        \n        \n        \n        \n        \n        \n    \n\n\n                        \n                        \n                    \n        \n \n        \n  \n    \n    \n                \n                \n                \n            \n            \n     \n                \n    \n            \n            \n        \n    \n  \n\n\n    \n   \n        \n\n  \n            \n  \n    \n    \n    \n\n\n\n            \n            \n            \n    \n    \n            \n   \n    \n\n    \n\n            \n            \n    \n    \n\n    \n    \n\n        \n\n\n    \n\n    \n    \n    \n\n\n\n\n\n\n\n\n\n            \n            \n        \n        \n        \n        \n    \n        ",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "d = {\"purple\":\"Power\", \"green\":\"Time\", \"blue\":\"Space\", \"orange\":\"Soul\", \"red\":\"Reality\", \"yellow\":\"Mind\"}\ns = set()\nn = int(input())\nfor _ in range(n):\n\tw = input()\n\ts.add(w)\nprint(6 - n)\nfor (key, value) in d.items():\n\tif key not in s:\n\t\tprint(value)",
    "complexity": "constant",
    "problem": "0987_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "a = int(input())\nlister = input().split()\nlister = [int(i) for i in lister]\n\nans = dict()\n\t\ndef findans(n):\n\tif n in ans:\n\t\treturn ans[n]\n\tmod = n%lister[n]\n\tok = True\n\tif n + lister[n] >= a and n - lister[n] < 0:\n\t\tok = False\n\telse:\n\t\tfor i in range(mod, a, lister[n]):\n\t\t\tif i != n and lister[i] > lister[n]:\n\t\t\t\tok = ok and findans(i) \n\t\t\t\t\n\t\tok = not(ok)\n\t\t\n\tans[n] = ok\n\treturn ok\n\t\nfor i in range(len(lister)):\n\tfindans(i)\n\t\nlevel = []\nfor i in range(a):\n\tif ans[i] == True:\n\t\tlevel.append('A')\n\telse:\n\t\tlevel.append('B')\n\t\t\nprint(''.join(level))",
    "complexity": "quadratic",
    "problem": "1033_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,games"
}
{
    "src": "# cook your dish here\ndef power(x, y, p) : \n    res = 1     # Initialize result \n  \n    # Update x if it is more \n    # than or equal to p \n    x = x % p  \n  \n    while (y > 0) : \n          \n        # If y is odd, multiply \n        # x with result \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n  \n        # y must be even now \n        y = y >> 1      # y = y/2 \n        x = (x * x) % p \n          \n    return res \n    \nd,n=map(int,input().split())\nans =power(2,n+1,1000000007);\nans1=power(2,n,1000000007);\nif(d==0):\n    print(0)\nelse:\n    print(((ans*(d%1000000007))%1000000007 - ans1 +1)%1000000007)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n = int(input())\nl = [*map(int, input().split())]\n\np = [0] * n\nfor i in range(n): p[l[i] - 1] = i\n\nres = ['?'] * n\n\nfor e in range(n, 0, -1):\n    i = p[e - 1]\n    res[i] = 'B'\n    for j in range(i % e, n, e):\n        if i != j and l[i] <= l[j] and res[j] == 'B':\n            res[i] = 'A'\n            break \nprint(''.join(res))",
    "complexity": "quadratic",
    "problem": "1033_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,games"
}
{
    "src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nimport bisect\nT = int(input())\nr = 1\n \nprime = [2]\n \nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue \n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0: \n            flag = True \n            break\n    if not flag:  prime.append(i)\n \n \n#print(prime)\n \n \ndef primefactor(num):\n \n    index = 0\n    output = []\n \n    while num>=prime[index]**2:\n \n        times = 0\n        while num%prime[index]==0:\n            num = num // prime[index]\n            times += 1\n        if times&1:  output.append(prime[index])\n        index += 1 \n \n    if num>1: output.append(num)\n \n \n    return tuple(output)\n \n \n \n \n \nwhile r<=T:\n    n,k = map(int,input().split())\n    \n \n    arr = list(map(int,input().split()))\n \n#    arr = [5*i+1 for i in range(n)]\n#    print(arr)\n \n \n    seg = 1\n    fact = {}\n    left = [[0 for j in range(k+1)] for i in range(n)]\n    dp = [[300000 for j in range(k+1)] for i in range(n)]\n \n    stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:\n            bisect.insort(stack,fact[factor]+1)\n            \n        fact[factor] = i\n \n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n \n \n \n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):\n                l = left[i][t]\n                if l>0:\n                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])\n                else:\n                    dp[i][j] = 1\n \n \n \n    \n \n \n \n#    print(left)\n#    print(dp)\n    print(dp[-1][-1])   \n \n    \n    \n  \n \n    \n \n \n \n    r += 1\n",
    "complexity": "cubic",
    "problem": "1497_E2",
    "from": "CODEFORCES",
    "tags": "data structures,dp,greedy,math,number theory,two pointers"
}
{
    "src": "import sys\ninput = sys.stdin.readline\nimport math\nimport copy\nimport collections\nfrom collections import deque\nimport heapq\nimport itertools\nfrom collections import defaultdict\nfrom collections import Counter\n\nn,k = map(int,input().split())\nmod = 998244353\ndp = [[[0 for z in range(2)] for j in range(k+1)] for i in range(n)]\n# z= 0: bb, 1:bw, 2:wb, 3=ww\ndp[0][1][0] = 1\nif k>=2:\n    dp[0][2][1] = 1\nfor i in range(1,n):\n    for j in range(1,k+1):\n        dp[i][j][0] += dp[i-1][j-1][0]+dp[i-1][j][0]+2*dp[i-1][j][1]\n        dp[i][j][0]%=mod\n        if j-2>=0:\n            dp[i][j][1] += 2*dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i-1][j-2][1]\n        else:\n            dp[i][j][1] += dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i][j-1][0]\n        dp[i][j][1]%=mod\nans = 0\nfor z in range(2):\n    ans+=dp[n-1][k][z]\nans*=2\nprint(ans%mod)\n# for row in dp:\n#     print(row)",
    "complexity": "np",
    "problem": "1051_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "import sys\ninput = sys.stdin.buffer.readline\n \nn,k=map(int,input().split())\narr=[int(x) for x in input().split()]\n \nx=0\ndp=[]\nfor i in range(n):\n    x=x+arr[i]\n    dp.append(x)\n \nans=0\nfor i in range(n):\n    for j in range(i+k-1,n):\n        ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1))\nprint(ans) ",
    "complexity": "quadratic",
    "problem": "1003_C",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,math"
}
{
    "src": "n=int(input())\np=[0,0]+list(map(int,input().split()))\nd=[0]*(n+1)\nfor i in range(n,1,-1):\n    if d[i]==0:\n        d[i]=1\n    d[p[i]]+=d[i]\nif n==1:\n    d[1]=1\nd=d[1:]\nd.sort()\nprint(*d)",
    "complexity": "linear",
    "problem": "1056_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"
}
{
    "src": "#CF-E-00\nimport sys\nfrom collections import deque, defaultdict\ninput = lambda: sys.stdin.readline().rstrip()\ndef topological_sort(In, Out):\n    dq, L = deque(), []\n    for i, I in enumerate(In):\n        if not I:\n            dq.append(i)\n    while dq:\n        v = dq.popleft()\n        L.append(v)\n        for w in Out[v]:\n            In[w].remove(v)\n            if not In[w]:\n                dq.append(w)\n    if len(L) < len(In):\n        return False\n    return L\n\ndef main():\n    n, m, k = map(int,input().split())  #k: length of following inputs\n\n    def edges(s):\n        Ans = set()\n        for i in range(2**k):\n            ans = [s[j] if i>>j&1 else '_' for j in range(k)]\n            Ans.add(''.join(ans))\n        return Ans\n\n    D = defaultdict(lambda : -1)\n    for i in range(n):\n        D[input()] = i\n\n    flag = 1\n    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]\n    for _ in range(m):\n        S, t = input().split()\n        t = int(t)\n\n        for e in edges(S):\n            if D[e]+1:\n                Out[t-1].add(D[e])\n                In[D[e]].add(t-1)\n        if t-1 not in Out[t-1]:\n            flag = 0\n            break\n        else:\n            Out[t-1].remove(t-1)\n            In[t-1].remove(t-1)\n\n    T = topological_sort(In, Out)\n    if flag and T:\n        print('YES')\n        print(*[t+1 for t in T], sep = ' ')\n    else:\n        print('NO')\n        \nmain()",
    "complexity": "np",
    "problem": "1476_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"
}
{
    "src": "import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n########################################################################\n\nn=ri()\na=ris()\nfreq=Counter(a)\nans=0\nfor x in freq:\n  for i in range(32):\n    c=(1<<i)-x\n    if c not in freq:\n      continue\n    if c==x and freq[x]==1:\n      continue\n    break\n  else:\n    ans+=freq[x]\n\nprint(ans)\n",
    "complexity": "nlogn",
    "problem": "1005_C",
    "from": "CODEFORCES",
    "tags": "brute force,greedy,implementation"
}
{
    "src": "n = int(input())\nif n == 0:\n    print(0)\nelse:\n    if n % 2 == 0:\n        print(n+1) \n    else:\n        print((n+1)//2)\n\n \t \t\t  \t  \t \t\t\t\t\t     \t\t\t\t \t \t\t",
    "complexity": "constant",
    "problem": "0979_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "pw = [1, 4]\nfor i in range(2, 32):\n    pw.append(pw[i - 1] * 4)\nt = int(input())\nfor cas in range(t):\n    n, k = map(int, input().split())\n    last = 1\n    path = 1\n    ans = n\n    i = 0\n    while True:\n        if((pw[i + 1] - 1) // 3 > k):\n            ans -= i\n            last = k - (pw[i] - 1) // 3\n            break\n        i = i + 1\n        path *= 2\n    sp = path * 2 - 1\n    if((ans < 0) or ((ans == 0) and (last > 0))):\n        print(\"No\")\n        continue\n    sq = path * path - sp\n    if (ans == 1) and (last > sq) and (last < sp):\n        print(\"No\")\n        continue\n    elif (ans == 1) and (last >= sp):\n        ans = ans - 1\n    print(\"Yes\", ans)\n",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "n=int(input())\n\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\n\na=[[l[i]+r[i],i] for i in range(n)]\na.sort()\n#print(a)\ncandies=[0 for i in range(n)]\n\nif(a[0][0] != 0):\n    \n    print('NO')\n    exit()\nelse:\n    candies[a[0][1]] = n - a[0][0]\n\nfor i in range(1,n):\n    if(a[i][0] != a[i-1][0] and a[i][0]!=i):\n        print('NO')\n #       print(i,a[i])\n        exit()\n  #  print(a[i][1],n-a[i][0],i)\n    candies[a[i][1]] = n - a[i][0]\n#print(candies)\nfor i in range(n):\n    l1=0\n    r1=0\n    for j in range(i):\n        if(candies[j]>candies[i]):\n            l1+=1\n    for j in range(i+1,n):\n        if(candies[j]>candies[i]):\n            r1+=1\n #   print(l1,r1)\n    if(l1 != l[i] or r1 != r[i]):\n        print('NO')\n        exit()\nprint('YES')\nprint(*candies)\n\n",
    "complexity": "quadratic",
    "problem": "1054_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation"
}
{
    "src": "\n_=input()\nn=input()\nnum=int(n)\n\nlist_n=list(n)\nlist_n_int=list(map(int,n))\n\n\nlower=max(list_n_int)\ntotal=sum(list_n_int)\nupper=int(total/2)\n\nflag=False\nif lower == 0:\n    print(\"YES\")\nelse:\n    for i in range(lower,upper+1):\n        flag=True\n        p=0\n        temp=0\n        each=i\n        seg=total/each\n        if seg.is_integer():\n            while p < len(n):\n\n                temp+=list_n_int[p]\n                if temp < each:\n                    p+=1\n                elif temp == each:\n                    temp=0\n                    p+=1\n                else:\n                    flag=False\n                    break\n            if flag:\n                print(\"YES\")\n                break\n        else:\n            flag=False\n    if not flag:\n        print(\"NO\")\n",
    "complexity": "quadratic",
    "problem": "1030_C",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "from collections import namedtuple\nvertex = namedtuple('vertex', ['degree', 'id'])\na, b, c = [], [], 0\n\nn = int(input())\nrr = list(map(int, input().split()))\n\nfor i in range(n):\n    if rr[i] > 1:\n        a.append(vertex(rr[i], i + 1))\n    else:\n        b.append(vertex(rr[i], i + 1))\n    c += rr[i]\n\nif c < (n - 1)*2:\n    print('NO')\nelse:\n    print('YES', len(a) - 1 + min(2, len(b)))\n    print(n - 1)\n    for i in range(1,len(a)):\n        print(a[i - 1].id, a[i].id)\n    if len(b) > 0:\n        print(b[0].id, a[0].id)\n    if len(b) > 1:\n        print(b[1].id, a[-1].id)\n    j, yes = 2, 0\n    for i in range(len(a)):\n        k = a[i].degree - 2\n        for t in range(k):\n            if j >= len(b):\n                yes = 1\n                break\n            print(a[i].id, b[j].id)\n            j += 1\n        if yes == 1:\n            break",
    "complexity": "quadratic",
    "problem": "1082_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,graphs,implementation"
}
{
    "src": "mod = 10 ** 9 + 7\nx, k = map(int, input().split())\nif x != 0:\n    print((pow(2, k + 1, mod) * x - pow(2, k, mod) + 1) % mod)\nelse:\n    print(0)\n\n        \n\n\n\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import os, sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    n = rint()\n    deg, edges = [0] * n, rints_2d(n - 1)\n    if n == 2:\n        exit(print(f'Yes\\n1\\n1 2'))\n\n    for u, v in edges:\n        deg[u - 1] += 1\n        deg[v - 1] += 1\n\n    ix = deg.index(max(deg))\n\n    if deg[ix] < 3 or deg.count(1) + deg.count(2) == n - 1:\n        print(f'Yes\\n{deg.count(1)}')\n\n        for i in range(n):\n            if deg[i] == 1:\n                print(i + 1, ix + 1)\n    else:\n        print('No')\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\nif __name__ == '__main__':\n    main()\n",
    "complexity": "linear",
    "problem": "0981_C",
    "from": "CODEFORCES",
    "tags": "implementation,trees"
}
{
    "src": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nn, d, k = map(int, input().split())\nif n == 1 or n <= d:\n    ans = \"NO\"\nelif k == 1:\n    ans = \"YES\" if n == 2 and d == 1 else \"NO\"\n    e = [(1, 2)]\nelse:\n    e = [(i + 1, i + 2) for i in range(d)]\n    q = deque()\n    l, r = 1, d + 1\n    if k > 2:\n        for i in range(2, d + 1):\n            q.append((i, 2, min(i - l, r - i)))\n    ans = \"YES\"\n    for i in range(d + 2, n + 1):\n        if not q:\n            ans = \"NO\"\n            break\n        j, k0, d0 = q.popleft()\n        e.append((j, i))\n        if k0 + 1 < k:\n            q.append((j, k0 + 1, d0))\n        if d0 - 1 > 0:\n            q.append((i, 1, d0 - 1))\nprint(ans)\nif ans == \"YES\":\n    for u, v in e:\n        print(u, v)",
    "complexity": "quadratic",
    "problem": "1003_E",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,graphs"
}
{
    "src": "n=int(input())\nd={}\nfor _ in range(n):\n    a,x=map(int, input().split())\n    d[a]=x\nm=int(input())\nfor _ in range(m):\n    b,y=map(int, input().split())\n    d[b]=max(y, d.get(b,0))\nprint(sum(d.values()))\n    \n",
    "complexity": "nlogn",
    "problem": "0981_B",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "def main():\n    n, m = map(int, input().split())\n    a = []\n    for i in range(n):\n        s = input()\n        b = []\n        for l in s:\n            b.append(l)\n        a.append(b)\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            may = True\n            if (a[i][j - 1] == '.' or a[i][j + 1] == '.' or a[i + 1][j - 1] == '.' or a[i + 1][j + 1] == '.' or a[i + 1][j] == '.' or a[i - 1][j - 1] == '.' or a[i - 1][j + 1] == '.' or a[i - 1][j] == '.'):\n                may = False\n            if (may):\n                a[i][j - 1] = a[i][j + 1] = a[i + 1][j - 1] = a[i + 1][j + 1] = a[i + 1][j] = a[i - 1][j - 1] = a[i - 1][j + 1] = a[i - 1][j] = '?'\n    for i in range(n):\n        for j in range(m):\n            if (a[i][j] == '#'):\n                print(\"NO\")\n                return\n    print(\"YES\")\nmain()",
    "complexity": "quadratic",
    "problem": "1059_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import math\nn, r = [int(x) for x in input().split()]\nx = [int(x) for x in input().split()]\nans = []\nfor i in range(n):\n    t = r\n    for j in range(i):\n        a = abs(x[i] - x[j])\n        if a <= 2 * r:\n            t2 = (2 * r)**2\n            t2 -= a**2\n            t2 = math.sqrt(t2) + ans[j]\n            t = max(t, t2)\n    ans.append(t)\nfor k in ans:\n    print(k)\n\t \t\t\t\t \t\t\t \t\t  \t\t\t \t\t\t\t   \t\t\t\t\t",
    "complexity": "quadratic",
    "problem": "0908_C",
    "from": "CODEFORCES",
    "tags": "brute force,geometry,implementation,math"
}
{
    "src": "a, b = map(int, input().split())\nprint(\"1\"*a)\nprint(int(\"1\" + (\"0\" * a)) - int(\"1\" * a))",
    "complexity": "constant",
    "problem": "1028_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque \n\n \nn, k = map(int,input().split())\ns = input()\n\n \n \nmaxconseq = [[0 for j in range(k)] for i in range(n+1)]\nfor i in range(n):\n    if s[i]==ord('?'):\n        for j in range(k):\n            maxconseq[i][j] = maxconseq[i-1][j] + 1\n    else:\n        j = s[i]-97\n        maxconseq[i][j] = maxconseq[i-1][j] + 1\n \n \n \ndef judge(needed):\n \n    \n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n \n    effect = [[inf]*(n+1) for j in range(k)]\n \n    \n    for j in range(k):\n        for i in range(n)[::-1]:\n            if maxconseq[i][j]>=needed:\n                effect[j][i-needed+1] = i+1\n            effect[j][i] = min(effect[j][i], effect[j][i+1])\n\n\n   \n                \n             \n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index]) \n\n\n\n        minstate[state] = minimum \n   \n \n#    print(minstate) \n \n \n \n    if minstate[-1]<=n:  return True\n    return False\n \n \nfront = 0\nrear = n//k+1\n \nwhile front < rear:\n    mid = (front+rear)//2\n    flag = judge(mid)\n#    print(mid,flag)\n \n    if flag:  \n        front = mid + 1\n    else:\n        rear = mid \n \nprint(front-1)\n",
    "complexity": "np",
    "problem": "1550_E",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,brute force,dp,strings,two pointers"
}
{
    "src": "print('4'*1131+'\\n'+'5'*1130+'6')",
    "complexity": "constant",
    "problem": "1028_B",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "\n\n\nn,s = map(int,input().split())\nt=[[0,0]]\nfor j in range(n):\n\n    a,b = map(int,input().split())\n\n\n    total = a*60+b\n\n\n    last = t[-1][0]*60+t[-1][1]+1\n\n    t.append([a,b])\n\n    if j==0:\n        if total>= s+1:\n            print(0,0)\n            break\n    if total-last > 2*s:\n        u = last+s\n        print(u//60, u%60)\n        break\n\n    if j==n-1:\n        x = t[-1][0]*60+t[-1][1]\n        print((x+s+1)//60 ,(x+s+1)%60 )\n        break\n\n\n    \n    \n",
    "complexity": "linear",
    "problem": "0967_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "from string import digits\nfrom collections import Counter\na = input()\nb = input()\nca = Counter(a)\nl = list()\nif len(b) > len(a):\n    for i in digits[::-1]:\n        if i in ca:\n            l.extend(i * ca[i])\nelse:\n    def asd(i, s):\n        if i == len(b):\n            return True\n        if s:\n            for j in digits[::-1]:\n                if j in ca and ca[j] > 0:\n                    l.extend(j * ca[j])\n            return True\n        else:\n            for j in digits[:int(b[i])+1][::-1]:\n                if j in ca and ca[j] > 0:\n                    ca[j] -= 1\n                    l.append(j)\n                    if asd(i + 1, j != b[i]):\n                        return True\n                    ca[j] += 1\n                    l.pop()\n            return False\n    asd(0, False)\nprint(\"\".join(l))\n\n       \t\t  \t \t  \t \t \t \t \t   \t\t\t",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "d = [list(map(int, input().split())) for i in range(int(input()))]\n\ns = 0\n\nfor k in range(1, 10001):\n\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n\n    u = v = 1\n\n    for r in p: u *= r\n\n    for r in p:\n\n        v *= r\n\n        s += (u - v) * (r - 1) / r\n\nprint(s)\n\n\n\n\n# Made By Mostafa_Khaled",
    "complexity": "np",
    "problem": "0513_C",
    "from": "CODEFORCES",
    "tags": "bitmasks,probabilities"
}
{
    "src": "\ndef func(u,v,a,l):\n    if (v**2-u**2)>=2*a*l:\n        return ((u**2+2*a*l)**(1/2)-u)/a\n    else:\n        t1=(v-u)/a\n        t2=(l-(u*t1+a*t1*t1/2))/v\n        return t1+t2\ndef efficient(v,a,w,d):\n    if 2*v*v-w*w<=2*a*d:\n        t1=v/a\n        t2=(v-w)/a\n        t3=(d-0.5*a*t1*t1-v*t2+0.5*a*t2*t2)/v\n        return t1+t2+t3\n    else:\n        bound=((2*a*d+w*w)/2)**0.5\n        t1=bound/a\n        t2=(bound-w)/a\n        t3=func(0,w,a,d)\n        return t1+t2\n        return min(t1+t2,t3)\ndef main():\n    string1=input()\n    string2=input()\n    arr1=string1.split(\" \")\n    arr2=string2.split(\" \")\n    a=int(arr1[0])\n    v=int(arr1[1])\n    l=int(arr2[0])\n    d=int(arr2[1])\n    w=int(arr2[2])\n    if 2*a*d<=w**2 or v<=w:\n        t1=func(0,v,a,l)\n        print(\"%.8f\"%(t1))\n    else:\n        t1=efficient(v,a,w,d)\n        t2=func(w,v,a,l-d)\n        print(\"%.8f\"%(t1+t2))\nmain()\n",
    "complexity": "constant",
    "problem": "0005_D",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "def solve(a):\n    aa = sorted(a)\n    maxr = aa[0]\n    for ai in aa:\n        if ai[2] != maxr[2]:\n            if ai[1] <= maxr[1] and ai[0] >= maxr[0]:\n                return(ai[2], maxr[2])\n            if ai[1] >= maxr[1] and ai[0] <= maxr[0]:\n                return(maxr[2], ai[2])\n        if ai[1] > maxr[1]:\n            maxr = ai\n    return(-1, -1)\n\nn = int(input())\na = []\nfor i in range(n):\n    l,r = [int(s) for s in input().split()]\n    a.append((l, r, i+1))\ni,j = solve(a)\nprint(i,j)\n",
    "complexity": "nlogn",
    "problem": "0976_C",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "\ndef sm(n):\n    return int(int(n*(n+1))/int(2));\ndef summ(en, st):\n    if(st <= 1):\n        return sm(en);\n    return sm(en) - sm(st-1);\n\ndef bs(n, k):\n    st = 1;\n    en = k;\n    while (st < en):\n        md = int(int((st+en)) /int(2));\n        s = summ(k,md);\n        if(s == n):\n            return k - md + 1;\n        elif (s>n):\n            st = md + 1;\n        else :\n            en = md;\n    return k - st + 2;\nn, k = input().split();\nn = int(n);\nk = int(k);\n\nif(n == 1):\n    print(0);\nelif (n <= k):\n    print(1);\nelse:\n    n -= 1;\n    k -= 1;\n    if(sm(k) < n ):\n        print(-1);\n    else:\n        print(int(bs(n,k)));\n",
    "complexity": "logn",
    "problem": "0287_B",
    "from": "CODEFORCES",
    "tags": "binary search,math"
}
{
    "src": "n = int(input())\np = [0,0] + [int(w) for w in input().split()]\n\nd = [0] * (n+1)\n\nfor i in range(n, 1, -1):\n    if d[i] == 0:\n        d[i] = 1\n    d[p[i]] += d[i]\n\nif n == 1:\n    d[1] = 1\n\nd = d[1:]\nd.sort()\n\nprint(*d)\n",
    "complexity": "linear",
    "problem": "1056_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"
}
{
    "src": "n, k = map(int, input().split())\nl = list(map(int, input().split()))\ncost = l[n - 1] - l[0]\nif k == 1:\n\tprint(cost)\nelse:\n\tdiff = [0 for _ in range(n - 1)]\n\tfor i in range(n - 1):\n\t\tdiff[i] = l[i + 1] - l[i]\n\t#print(diff)\n\tdiff = sorted(diff)\n\tdiff.reverse()\n\tprint(cost - sum(diff[:k - 1]))",
    "complexity": "nlogn",
    "problem": "1197_C",
    "from": "CODEFORCES",
    "tags": "greedy,sortings"
}
{
    "src": "dict={\"Power\":\"purple\",\n      \"Time\":\"green\",\n      \"Space\":\"blue\",\n      \"Soul\":\"orange\",\n      \"Reality\":\"red\",\n      \"Mind\":\"yellow\"}\ndict1={}\nn=(int(input()))\nwhile n:\n    str=input()\n    if str==\"purple\":\n        dict1[\"Power\"]=str\n    elif str==\"green\":\n        dict1[\"Time\"]=str\n    elif str==\"blue\":\n        dict1[\"Space\"]=str\n    elif str==\"orange\":\n        dict1[\"Soul\"]=str\n    elif str==\"red\":\n        dict1[\"Reality\"]=str\n    elif str==\"yellow\":\n        dict1[\"Mind\"]=str\n    n-=1\n\nval=list(dict.keys())\nval_list=list(dict1.keys())\nl=[key for key in val if key not in val_list]\nprint(len(l))\nfor i in range(len(l)):\n    print(l[i])",
    "complexity": "constant",
    "problem": "0987_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n, l, r, x = list(map(int, input().split(\" \")))\nc = sorted(list(map(int, input().split(\" \"))))\nways = 0\n\nfor i in range(0, 2 ** n):\n    temp = 0\n    m = 10 ** 9 + 1\n    M = -1\n    for j in range(0, n):\n        if i & 1 << j:\n            temp += c[j]\n            m = min(m, c[j])\n            M = max(M, c[j])\n    if temp >= l and temp <= r and (M - m) >= x:\n        ways += 1\n\nprint(ways)\n\n\n\t\t  \t \t\t\t       \t\t \t \t\t   \t\t \t",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "import sys\na,b,c=sys.stdin.readline().strip().split()\nif a==b and b==c:\n    print(0)\nelif a==b or b==c or a==c:\n    print(1)\nelse:\n    na = int(a[0])\n    nb = int(b[0])\n    nc = int(c[0])\n    if (a[1]==b[1] and a[1]==c[1]):\n        cp=[na,nb,nc]\n        cp.sort()\n        cp[0]+=2\n        cp[1]+=1\n        if (cp[0]==cp[1] and cp[1]==cp[2]):\n            print(\"0\")\n        elif (cp[0]==cp[1] or cp[1]==cp[2] or cp[0]==cp[1] or (cp[0]+1)==cp[1] or (cp[1]+1)==cp[2]):\n            print(\"1\")\n        else:\n            print(\"2\")\n    elif(a[1]==b[1]):\n        mi=min(na,nb)\n        ma=max(na,nb)\n        if (mi==(ma-1) or mi==(ma-2)):\n            print(\"1\")\n        else: print(\"2\")\n    elif(a[1]==c[1]):\n        mi=min(na,nc)\n        ma=max(na,nc)\n        if (mi==(ma-1) or mi==(ma-2)):\n            print(\"1\")\n        else: print(\"2\")\n    elif(b[1]==c[1]):\n        mi = min(nb,nc)\n        ma = max(nb,nc)\n        if (mi==(ma-1) or mi==(ma-2)):\n            print(\"1\")\n        else: print(\"2\")\n    else:\n        print(\"2\")\n",
    "complexity": "nlogn",
    "problem": "1191_B",
    "from": "CODEFORCES",
    "tags": "brute force,implementation"
}
{
    "src": "import sys\n# from bisect import bisect_right\n# gcd\n# from fractions import gcd\n# from math import ceil, floor\n# from copy import deepcopy\n# from itertools import accumulate\n# l = ['a', 'b', 'b', 'c', 'b', 'a', 'c', 'c', 'b', 'c', 'b', 'a']\n# print(S.most_common(2))  # [('b', 5), ('c', 4)]\n# print(S.keys())  # dict_keys(['a', 'b', 'c'])\n# print(S.values())  # dict_values([3, 5, 4])\n# print(S.items())  # dict_items([('a', 3), ('b', 5), ('c', 4)])\n# from collections import Counter\n# import math\n# from functools import reduce\n#\n# fin = open('./test/in_1.txt', 'r')\n# sys.stdin = fin\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef mi(): return map(int, input().rstrip().split())\ndef lmi(): return list(map(int, input().rstrip().split()))\ndef li(): return list(input().rstrip())\n# template\n\n\n\nif __name__ == '__main__':\n\n    # write code\n    n,q = mi()\n    a = lmi()\n    i = 0\n    max_a = max(a)\n    t = a.index(max_a)\n    last = a[0]\n    Lis = []\n    tmp = []\n    for i in range(1, t + 1):\n        Lis.append((last,a[i]))\n        if last < a[i]:\n            tmp.append(last)\n            last = a[i]\n        else:\n            tmp.append(a[i])\n    # print(Lis)\n    anslist = a[t+1:] + tmp\n    # print(last)\n    # print(anslist)\n    # print(tmp)\n    for i in range(q):\n        tm = ii()\n        if 1 <= tm <= t:\n            print(Lis[tm - 1][0],Lis[tm - 1][1])\n        else:\n            print(max_a,anslist[(tm-t-1)%len(anslist)])",
    "complexity": "linear",
    "problem": "1180_C",
    "from": "CODEFORCES",
    "tags": "data structures,implementation"
}
{
    "src": "MAX = 1000\nf = [0]\nfor i in range(1, MAX):\n    f.append(f[i - 1] + (1 << (2 * i - 2)))\n\ng = [0]\nfor i in range(1, MAX):\n    g.append(g[i - 1] + (1 << i) - 1)\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split(' '))\n    ans = False\n    for i in range(1, n + 1):\n        if k >= g[i]:\n            if n >= MAX:\n                print(\"YES %d\" % (n - i))\n                ans = True\n            elif k <= f[n] - ((1 << (i + 1)) - 1) * f[n - i]:\n                print(\"YES %d\" % (n - i))\n                ans = True\n        if ans == True:\n            break\n    if ans == False:\n        print(\"NO\")\n        \n    ",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "n,l,r,x = map(int,input().split())\nc = [int(i) for i in input().split()]\nans = 0\nfor bit in range(2,1<<n):\n    probs = []\n    t = 0\n    for i in range(n):\n        if bit&(1<<i):\n            probs.append(c[i])\n            t += c[i]\n    \n    a = min(probs)\n    b = max(probs)\n\n    if t >= l and t <= r and abs(a-b) >= x:\n        ans += 1\nprint(ans)",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "turns, candies = map(int, input().split())\nsumm = 0\nturn = 0\nwhile candies != summ - (turns - turn):\n    turn += 1\n    summ += turn\nprint(turns - turn)",
    "complexity": "linear",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "from sys import stdin\n\nadd = lambda a, b: (a + b) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, i * 2 + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])\n\nprint(sum(mem[-1][k]) % mod)\n",
    "complexity": "np",
    "problem": "1051_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "'''     Design by Dinh Viet Anh(JOKER)\n//_____________________________________$$$$$__\n//___________________________________$$$$$$$$$\n//___________________________________$$$___$\n//___________________________$$$____$$$$\n//_________________________$$$$$$$__$$$$$$$$$$$\n//_______________________$$$$$$$$$___$$$$$$$$$$$\n//_______________________$$$___$______$$$$$$$$$$\n//________________$$$$__$$$$_________________$$$\n//_____________$__$$$$__$$$$$$$$$$$_____$____$$$\n//__________$$$___$$$$___$$$$$$$$$$$__$$$$__$$$$\n//_________$$$$___$$$$$___$$$$$$$$$$__$$$$$$$$$\n//____$____$$$_____$$$$__________$$$___$$$$$$$\n//__$$$$__$$$$_____$$$$_____$____$$$_____$\n//__$$$$__$$$_______$$$$__$$$$$$$$$$\n//___$$$$$$$$$______$$$$__$$$$$$$$$\n//___$$$$$$$$$$_____$$$$___$$$$$$\n//___$$$$$$$$$$$_____$$$\n//____$$$$$$$$$$$____$$$$\n//____$$$$$__$$$$$___$$$\n//____$$$$$___$$$$$$\n//____$$$$$____$$$\n//_____$$$$\n//_____$$$$\n//_____$$$$\n'''\nfrom math import *\nfrom cmath import *\nfrom itertools import *\nfrom decimal import *  # su dung voi so thuc\nfrom fractions import *  # su dung voi phan so\nfrom sys import *\nfrom types import CodeType, new_class\n#from numpy import *\n\n'''getcontext().prec = x # lay x-1 chu so sau giay phay (thuoc decimal)\nDecimal('12.3') la 12.3 nhung Decimal(12.3) la 12.30000000012\nFraction(a) # tra ra phan so bang a (Fraction('1.23') la 123/100 Fraction(1.23) la so khac (thuoc Fraction)\na = complex(c, d) a = c + d(i) (c = a.real, d = a.imag)\na.capitalize() bien ki tu dau cua a(string) thanh chu hoa, a.lower() bien a thanh chu thuong, tuong tu voi a.upper()\na.swapcase() doi nguoc hoa thuong, a.title() bien chu hoa sau dau cach, a.replace('a', 'b', slg)\nchr(i) ki tu ma i ord(c) ma ki tu c\na.join['a', 'b', 'c'] = 'a'a'b'a'c, a.strip('a') bo dau va cuoi ki tu 'a'(rstrip, lstrip)\na.split('a', slg = -1) cat theo ki tu 'a' slg lan(rsplit(), lsplit()), a.count('aa', dau = 0, cuoi= len(a)) dem slg\na.startswith('a', dau = 0, cuoi = len(a)) co bat dau bang 'a' ko(tuong tu endswith())\na.index(\"aa\") vi tri dau tien xuat hien (rfind())\ninput = open(\".inp\", mode='r')  a = input.readline()\nout = open(\".out\", mode='w') a.index(val) '''\n#inn = open(\".inp\", \"r\")\n\na = []\nn, m = map(int, input().split())\nminx, miny, maxx, maxy = n, m, 0, 0\nfor x in range(n):\n    a.append(input())\n    for y in range(m):\n        if a[x][y] == 'B':\n            minx = min(minx, x + 1)\n            miny = min(miny, y + 1)\n            maxx = max(maxx, x + 1)\n            maxy = max(maxy, y + 1)\nprint((maxx + minx) // 2 , (maxy + miny) // 2)\n",
    "complexity": "quadratic",
    "problem": "1028_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\nm,n=[int(ele) for ele in input().split()]\na=[]\nfor i in range(m):\n    a.append(list(map(int, input().split())))\n\n\nina,mo=0,10**9+1\npos1,pos2=0,0\nmask=(1<<n)-1\ndef check(tang):\n    key=set()\n    dic=dict()\n    for i in range(m):\n        temp=0 \n        for j in range(n):\n            if a[i][j]>=tang:\n                #print(\"ya\")\n                temp+=(1<<j)\n        #print(bin(temp),a[i],tang)\n        if temp in key:\n            continue\n        key.add(temp)\n        tempk=temp\n        while tempk>=0:\n            tempk &= temp\n            dic[tempk]=i\n            tempk-=1\n            \n        tocheck = mask ^ temp\n        #print(bin(tocheck),bin(temp),bin(mask),a[i],tang)\n\n        if tocheck in dic:\n            return dic[tocheck],i,True\n\n    #print(dic)\n    return -1,-1,False\n        \nwhile ina<mo-1:\n    #print(ina,mo)\n    tang=(ina+mo)//2\n    #print(ina,mo,tang)\n    temppos1,temppos2,status=check(tang)\n    #print(status)\n    if status:\n        pos1,pos2=temppos1,temppos2\n        ina=tang\n    else:\n        mo=tang\nprint(pos1+1,pos2+1)\n    \n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "from collections import defaultdict as dd\nfrom collections import deque, Counter\nimport bisect\nimport heapq\nfrom math import inf\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef ri():\n    return int(input())\n \ndef rl():\n    return list(map(int, input().split()))\n\n\n \nn, m = rl()\naa = rl()\n\n#convert aa to array of [+,-,-,-,+,-,+,....]\nbb = [-1]*n\nfor i in range(n):\n\tif aa[i] == m:\n\t    bb[i] = 1\n\telif aa[i] < m:\n\t    bb[i] = -1\n\telse: # aa[i] > m\n\t    bb[i] = 1\n\nprefix_sum= [0]*(n+1)\nfor i in range(1, n+1):\n    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]\n\n\n#now if we choose l and r, we have to compare:\n# median on [l,r] more or equal to m iff (prefix_sum[r+1] - prefix_sum[l]) > 0  (1)\n\n#if we do the same thing with m+1 instead of m\n#median on [l,r] more or equal to m +1 ...\n\n#we can deduct second result from first\\\n#to get the number of pairs [l,r] such as \\\n#median on [l,r] exactly equal to m\n\n\n#we can rewrite (1)  as prefix_sum[r+1] > prefix_sum[l]\n#this is linked to counting the number of inversions in the prefix sum!!\n#classic problem, can be done by merge sort\n\n#we need to be a bit carefull, because we want only the inversions\\\n# with l on left of median and r on the right\n# can count inversion on 3 parts:\n#-whole array\n#-begin of array to median\n#-median to end\n#then deduct the last two from the first\n\ndef mergeSortGoodOrder(arr):\n    \"\"\"\n    this doesn t count the number of inversions, but quite the opposite\n    it counts the number of pairs i < j such as arr[i] < arr[j]\n    \"\"\"\n    if len(arr) == 1:\n        return arr, 0\n    else:\n        a = arr[:len(arr)//2]\n        b = arr[len(arr)//2:]        \n\n        a, ai = mergeSortGoodOrder(a)\n        b, bi = mergeSortGoodOrder(b)\n        c = []        \n\n        i = 0\n        j = 0\n        good = 0 + ai + bi    \n\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            c.append(a[i])\n            i += 1\n            good += (len(b)-j)\n        else:\n            c.append(b[j])\n            j += 1\n               \n\n    c += a[i:]\n    c += b[j:]\n\n    return c, good\n\n\n\n#step1: with m\n\n\n#we want prefix_sum[l] < prefix_sum[r+1]\n#ie : prefix_sum[l] < prefix_sum[r], and r stricly on the right of median\n\n\n#find position of median\nidx = 0\nfor i in range(n):\n    if aa[i] == m:\n        idx = i\n\n\n_, good = mergeSortGoodOrder(prefix_sum)\n\n_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])\n\n_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])\n\n\nfirst_count = good - bad_left - bad_right\n\n#step2: with m + 1\nbb = [-1]*n\nfor i in range(n):\n\tif aa[i] == m + 1:\n\t    bb[i] = 1\n\telif aa[i] < m + 1:\n\t    bb[i] = -1\n\telse: # aa[i] > m + 1\n\t    bb[i] = 1\n\nprefix_sum= [0]*(n+1)\nfor i in range(1, n+1):\n    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]\n\n\n\n##BE CAREFUL: here we need to keep idx as the one of aa[idx] = m, NOT aa[idx = m+1]\n# #find position of m + 1\n# idx = 0\n# for i in range(n):\n#     if aa[i] == m + 1:\n#         idx = i\n\n\n_, good = mergeSortGoodOrder(prefix_sum)\n\n_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])\n\n_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])\n\nsecond_count = good - bad_left - bad_right\n\n\n#step3: combine\n\nans   = first_count - second_count\n\nprint(ans)\n\n\n",
    "complexity": "nlogn",
    "problem": "1005_E1",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "[n, k]=[int(i) for i in input().split()]\nprint((k+n-1)//n)",
    "complexity": "constant",
    "problem": "1036_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\nfrom math import floor\n\nif __name__ == '__main__':\n\n    entrada = input()\n    entrada_str = list(entrada.split(\" \"))\n    entrada_int = list(map(int, entrada_str))\n\n    a = entrada_int[0]\n    b = entrada_int[1]\n\n    if a == b:\n        print(0)\n        sys.exit()\n\n    string_1 = \"\"\n    string_2 = \"\"\n    while a:\n        if a%2 == 0:\n            string_1 = string_1 + \"0\"\n        else:\n            string_1 = string_1 + \"1\"\n        a = floor(a/2)\n\n    while b:\n        if b%2 == 0:\n            string_2 = string_2 + \"0\"\n        else:\n            string_2 = string_2 + \"1\"\n        b = floor(b/2)\n\n    lista_1 = list(string_1)\n    lista_1.reverse()\n    contrario_1 = \"\".join(lista_1)\n\n    lista_2 = list(string_2)\n    lista_2.reverse()\n    contrario_2 = \"\".join(lista_2)\n\n    if len(string_1) != len(string_2):\n        resposta = pow(2, len(string_2)) - 1\n    else:\n        potencia = 0\n        for i in range(len(string_1)):\n            if contrario_1[i] != contrario_2[i]:\n                break\n            potencia += 1\n\n        potencia = len(string_1) - potencia\n        resposta = pow(2, potencia)-1\n\n    print(resposta)\n\n\n\n\t\t    \t\t \t\t\t  \t\t\t\t \t \t   \t\t \t\t",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "import sys\nsys.setrecursionlimit(2000)\nfrom collections import Counter\n\nif __name__ == \"__main__\":\n\n    # single variables\n    n = [int(val) for val in input().split()][0]\n    b = [int(val) for val in input().split()]\n\n    l = 0\n    r = b[0]\n    a = [0] * n\n    for i in range(n//2):\n        a[i] = l\n        a[n-1-i] = r\n        if(i != n//2-1):\n            val = b[i+1]\n            summ = l + r\n            if(summ == val):\n                continue\n            elif(summ > val):\n                diff = summ - val\n                r -= diff\n            elif(summ < val):\n                diff = val - summ\n                l += diff\n\n    for i in a:\n        print(i, end=' ')\n    print('')\n       \n\n\n",
    "complexity": "linear",
    "problem": "1093_C",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "\"\"\"\n#If FastIO not needed, use this and don't forget to strip\n#import sys, math\n#input = sys.stdin.readline\n\"\"\"\n\nimport os, sys, heapq as h, time\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport math, string\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#start_time = time.time()\n\ndef getInt(): return int(input())\ndef getStrs(): return input().split()\ndef getInts(): return list(map(int,input().split()))\ndef getStr(): return input()\ndef listStr(): return list(input())\ndef getMat(n): return [getInts() for _ in range(n)]\ndef isInt(s): return '0' <= s[0] <= '9'\n\nMOD = 10**9 + 7 \n\n\"\"\"\n\n\"\"\"\n\nsquares = set([i*i for i in range(1,4000)])\n\np = [i for i in range(10**7+1)]\nfor i in range(1,10**7+1):\n    if p[i] == i:\n        for sq in squares:\n            if i*sq > 10**7: break\n            p[i*sq] = i\n\ndef solve():\n    N, K = getInts()\n    A = getInts()\n    new = 10**8\n    A = [p[A[i]] for i in range(N)]\n    dp = [N]*(K+1)\n    dp[0] = 0\n    used = [set()]*(K+1)\n    for i in range(N):\n        for j in range(K,-1,-1):\n            if dp[j] == N: continue\n            if A[i] in used[j]:\n                if j < K and dp[j+1] > dp[j]:\n                    dp[j+1] = dp[j]\n                    used[j+1] = used[j]\n                dp[j] += 1\n                used[j] = set([A[i]])\n            else:\n                used[j].add(A[i])\n    return min(dp)+1\n    \nfor _ in range(getInt()):\n    print(solve())\n#solve()\n\n#print(time.time()-start_time)",
    "complexity": "cubic",
    "problem": "1497_E2",
    "from": "CODEFORCES",
    "tags": "data structures,dp,greedy,math,number theory,two pointers"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\nd = set(a)\nif (0 in a): \n    print(len(d)-1)\nelse:\n    print(len(d))",
    "complexity": "linear",
    "problem": "0992_A",
    "from": "CODEFORCES",
    "tags": "implementation,sortings"
}
{
    "src": "import sys;input = sys.stdin.readline\ndef topological_sorted(digraph):\n    n = len(digraph);indegree = [0] * n\n    for v in range(n):\n        for nxt_v in digraph[v]:indegree[nxt_v] += 1\n    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]\n    while stack:\n        v = stack.pop()\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] -= 1\n            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)\n    return len(tp_order) == n, tp_order\nn, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {};graph = [[] for i in range(n)]\nfor idx, ptn in enumerate(p):val = sum([(ord(ptn[i]) - 96) * (27 ** i) for i in range(k) if ptn[i] != \"_\"]);memo[val] = idx\nfor i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)\nfor string, idx in s:\n    idxs = []\n    idx -= 1\n    for bit_state in range(1 << k):\n        val = 0\n        for i in range(k):\n            if (bit_state >> i) & 1:\n                continue\n            val += (string[i] - 96) * (27 ** i)\n        if val in memo:\n            idxs.append(memo[val])\n    if idx not in idxs:print(\"NO\");exit()\n\n    for idx_to in idxs:\n        if idx == idx_to:\n            continue\n        graph[idx].append(idx_to)\n\nflag, res = topological_sorted(graph)\nif flag:print(\"YES\");print(*[i + 1 for i in res])\nelse:print(\"NO\")",
    "complexity": "np",
    "problem": "1476_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"
}
{
    "src": "nr, ng, nb = map(int, input().split())\nr = sorted([int(i) for i in input().split()])\ng = sorted([int(i) for i in input().split()])\nb = sorted([int(i) for i in input().split()])\n\ndp = [[[0 for _ in range(nb + 1)] for _ in range(ng + 1)] for _ in range(nr + 1)]\nfor i in range(nr + 1):\n    for j in range(ng + 1):\n        for k in range(nb + 1):\n            val = 0\n            if i - 1 >= 0 and j - 1 >= 0:\n                val = max(val, r[i - 1] * g[j - 1] + dp[i - 1][j - 1][k])\n            if i - 1 >= 0 and k - 1 >= 0:\n                val = max(val, r[i - 1] * b[k - 1] + dp[i - 1][j][k - 1])\n            if j - 1 >= 0 and k - 1 >= 0:\n                val = max(val, g[j - 1] * b[k - 1] + dp[i][j - 1][k - 1])\n            dp[i][j][k] = val\n\nprint(dp[nr][ng][nb])\n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "n = int(input())\nfor i in range(n):\n    a, b, c = [int(el) for el in input().split()]\n    if ( a > c or b > c):\n        print(-1)\n    else:\n        if (a% 2 + b % 2 == 1):\n            print(c - 1)\n        elif (a%2 == b%2 == c%2):\n            print(c)\n        else:\n            print(c - 2)\n",
    "complexity": "constant",
    "problem": "1036_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\n\ndef inn(a,b):\n\treturn (a[0] <= b[0] and b[1] <= a[1])\n\nn = int(input())\n\nseg = []\n\na,b = map(int,input().split())\nseg.append((a,b,1))\n\nfor i in range(2,n+1):\n\ta,b = map(int,input().split())\n\tseg.append((a,b,i))\n\t\nseg.sort(key=lambda x : (x[0],-x[1]))\n\nmain = seg.pop(0)\n\t\nfor i in seg:\n\tif inn(main,i):\n\t\tprint(i[2],main[2])\n\t\tsys.exit(0)\n\tif main[1] < i[1]:\n\t\tmain = i\n\nprint(-1,-1)",
    "complexity": "nlogn",
    "problem": "0976_C",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "num=int(input())\nlist_=sorted(set(map(int,input().split())))\nif len(list_)==1:\n    print(\"NO\")\nelse:\n    \n    print(list_[1])\n",
    "complexity": "nlogn",
    "problem": "0022_A",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "s=input()\nn=len(s)\nl=[[0,0,0] for i in range(n)]\nans=0\nx=int(s[0])%3\nif(x==0):\n    ans+=1\nelse:\n    l[0][x]=1\nfor i in range(1,n):\n    x=int(s[i])%3\n    if(x==0):\n        ans+=1\n        continue\n    \n    if(l[i-1][3-x]>0):\n        ans+=1\n        l[i][3-x]=0\n        l[i][x]=0\n    else:\n        if(l[i-1][x]!=0):\n            l[i][1]=1\n            l[i][2]=1\n        else:\n            l[i][x]=1\n\nprint(ans)",
    "complexity": "linear",
    "problem": "1005_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,number theory"
}
{
    "src": "x, k = map(int,input().split())\nif x==0:\n  print(0)\nelse:\n  print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n,M=map(int,input().split())\na=[0]+[int(x) for x in input().split()]+[M]\n\nt1=[]\nt2=[]\nfor i in range(n+1):\n    if i%2==0:\n        t1.append(a[i+1]-a[i])\n    else:\n        t2.append(a[i+1]-a[i])\nt2.append(0)\n\nimport math\nans=sum(t1)\np=0\nq=sum(t2)\nfor i in range(math.ceil(n/2)):\n    p=p+t1[i]\n    q=q-t2[i-1]\n    ans=max(ans,p+q-1)\nprint(ans)\n",
    "complexity": "linear",
    "problem": "1000_B",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "from sys import stdin\nfrom operator import xor\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, a, m = int(input()), [rints()], int(input())\nqur, out = [rints() for _ in range(m)], []\n\nfor i in range(1, n):\n    a.append(list(map(xor, a[-1][:-1], a[-1][1:])))\n\nfor i in range(n - 1):\n    a[i + 1] = list(map(max, a[i][:-1], a[i][1:], a[i + 1]))\n\nfor l, r in qur:\n    out.append(a[r - l][l - 1])\n\nprint('\\n'.join(map(str, out)))\n",
    "complexity": "quadratic",
    "problem": "0983_B",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "n, m, k = list(map(int, input().split()));\na = list(map(int, input().split()));\n\nvalues = list()\n\nfor j in range(n):\n    result = a[j];\n    sum1 = 0;\n    for i in range(m):\n        if j-i>=0:\n            sum1 = sum1 + a[j-i];\n            if sum1 > result:\n                result = sum1;\n        else:\n            continue;\n    if j-m>=0:\n        result = max(result, sum1 + values[j-m]);\n    values.append(max(0, result-k));\nprint(max(values));\n",
    "complexity": "quadratic",
    "problem": "1197_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,math"
}
{
    "src": "n,l,r,x = map(int,input().split())\na = list(map(int,input().split()))\ncount=0\nfor i in range(2**n):\n    maxc=-1\n    minc=-1\n    c=0\n    for j in range(n):\n        if i>>j&1==1:\n            c+=a[j]\n            maxc=max(maxc,a[j])\n            if minc==-1:\n                minc=a[j]\n            else:\n                minc=min(a[j],minc)\n    if c>=l and c<=r and maxc - minc >=x:\n        count+=1\nprint(count)\n\n",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "#B. Pair of Toys\nn,k=map(int,input().split())\nif n>=k: \n    print((k-1)//2)\nelif n*2>k: \n    print(n-k//2)\nelse: \n    print(0)",
    "complexity": "constant",
    "problem": "1023_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "from collections import defaultdict, deque, Counter\nfrom sys import stdin, stdout\nfrom heapq import heappush, heappop\nimport math\nimport io\nimport os\nimport math\nimport bisect\n\n#?############################################################\n\n\ndef isPrime(x):\n    for i in range(2, x):\n        if i*i > x:\n            break\n        if (x % i == 0):\n            return False\n    return True\n\n#?############################################################\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p\n\n\n#?############################################################\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            l.append(int(i))\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\n\n#?############################################################\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n#?############################################################\n\n\ndef sieve(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\n#?############################################################\n\ndef digits(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\n\n#?############################################################\n\n\ndef ceil(n, x):\n    if (n % x == 0):\n        return n//x\n    return n//x+1\n\n#?############################################################\n\n\ndef mapin():\n    return map(int, input().split())\n\n#?############################################################\ndef solve(final, n):\n    fifi = [[final[j][i] for j in range(n)] for i in range(n)] \n \n    k = []\n    for i in range(n):\n        k.append(sum(final[i]))\n    a = max(k)-min(k)\n    \n    a = a*a\n    k = []\n    for i in range(n):\n        k.append(sum(fifi[i]))\n    b = max(k)-min(k)\n    \n    b = b*b\n    \n    \n    return a+b\n    \n    \ndef inte(a, b, c, d):\n    a = max(a, c)\n    b = min(b, d)\n    \n    return [a, b]\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n# python3 15.py<in>op\nn = int(input())\nl = []\nfor i in range(n):\n    a, b = mapin()\n    l.append([a, b])\n    \n    \nf= []\nff = []\na = 0\nb = 10000000000000\nf.append([a, b])\nfor i in range(n):\n    x = inte(a, b, l[i][0], l[i][1])\n    a = x[0]\n    b = x[1]\n    f.append([a, b])\na = 0\nb = 10000000000000\nff = [[] for i in range(n)]\nfor i in reversed(range(n)):\n    x = inte(a, b, l[i][0], l[i][1])\n    a = x[0]\n    b = x[1]\n    ff[i] = [a, b]\nff.append([0, 100000000000000])\nans = 0  \nfor i in range(n):\n    a = f[i]\n    b = ff[i+1]\n    y = inte(a[0], a[1], b[0], b[1])\n    if(y[1]>= y[0]):\n        ans = max(ans, y[1]-y[0])\n    \n    \n# print(f, ff)/\nprint(ans)\n\n    \n    ",
    "complexity": "linear",
    "problem": "1029_C",
    "from": "CODEFORCES",
    "tags": "greedy,math,sortings"
}
{
    "src": "n, m, k = map(int, input().split())\na = list(map(int, input().split()))\nsa = [0]*n\n\nans = 0\n\nfor i in range(n):\n    sa[i] = a[i] - k\n    s = a[i]\n    for j in range(i-1, max(-1, i-m-1), -1):\n        sa[i] = max(sa[i], sa[j] + s - k)\n        s += a[j]\n    if i < m:\n        sa[i] = max(sa[i], s - k)\n    sa[i] = max(sa[i], 0)\n    ans = max(ans, sa[i])\n\nprint(ans)\n",
    "complexity": "quadratic",
    "problem": "1197_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,math"
}
{
    "src": "import sys\nimport math\nimport collections\nimport bisect\nimport string\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n=int(input())\n    s1=list(get_string())\n    s2=list(get_string())\n    count=0\n    ans=[]\n    lower=string.ascii_lowercase\n    np=0\n    for i in lower:\n        if s1.count(i)!=s2.count(i):\n            np+=1\n            break\n    if np>0:\n        print(-1)\n        continue\n    pos=dict()\n    for i in range(n):\n        if s1[i] in pos:\n            pos[s1[i]].append(i)\n        else:\n            pos[s1[i]]=[i]\n    for i in range(n):\n        if s1[i]==s2[i]:\n            continue\n        else:\n            row=pos[s2[i]]\n            no=0\n            for j in range(len(row)):\n                if row[j]>i:\n                    no=row[j]\n                    break\n            for j in range(no,i,-1):\n                ans.append(j)\n            s1.pop(no)\n            s1.insert(i,s2[i])\n            #print(s1)\n            pos = dict()\n            for j in range(n):\n                if s1[j] in pos:\n                    pos[s1[j]].append(j)\n                else:\n                    pos[s1[j]] = [j]\n    print(len(ans))\n    print(*ans)",
    "complexity": "quadratic",
    "problem": "1015_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\nfrom collections import Counter\n\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\nn, k = mi()\ns = input().strip()\nc = Counter(s)\nmn = 10 ** 9\nfor ch in alpha[:k]:\n    mn = min(mn, c[ch])\nprint(mn * k)\n",
    "complexity": "linear",
    "problem": "1038_A",
    "from": "CODEFORCES",
    "tags": "implementation,strings"
}
{
    "src": "import math\n\ndef gaosi(x):\n    if (x==1):\n        return 1\n    else:\n        return ((1+x)*x)/2\n\ndef calc(mid, total, left):\n    return gaosi(mid) - (total - mid) - left\n\ndef main(): \n    x, left = map(int, input().split())\n    if (x == 1 and left == 1):\n        print(0)\n    else:\n        l = 1\n        r = x\n        while (True):\n            mid = math.floor((l + r) / 2)\n            result = calc(mid, x, left)\n            if (result == 0):\n                print(x - mid)\n                break\n            elif (result > 0):\n                r = mid\n            elif (result  < left):\n                l = mid\n\n    \nif __name__ == \"__main__\":\n    main()",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "# problem http://codeforces.com/contest/1100/problem/E\nimport copy\nimport sys\n\n\ndef find_loop(g, w, k, n):\n    visited = [False] * n\n    visited_int = [False] * n\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        visited_int[i] = True\n        while stack:\n            if not stack[-1]:\n                stack.pop()\n                visited_int[path[-1]] = False\n                path.pop()\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited_int[nxt]:\n                return True\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            visited_int[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n    return False\n\n\ndef top_sort(g, w, k, n):\n    visited = [False] * n\n    order = [-1] * n\n    cnt = 0\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        while stack:\n            if not stack[-1]:\n                order[path[-1]] = cnt\n                path.pop()\n                stack.pop()\n                cnt += 1\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n\n    to_reverse = []\n    for a, b in w.items():\n        if b > k:\n            continue\n        if order[a[0]] < order[a[1]]:\n            to_reverse.append(a)\n    return to_reverse\n\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    w = {}\n    g = [[] for _ in range(n)]\n    w_tmp = {}\n    c_m = 0\n    kk = [0]\n    lines = sys.stdin.readlines()\n    for i, line in enumerate(lines): #range(1, m + 1):\n        u, v, c = map(int, line.split())\n        g[u - 1].append(v - 1)\n        if (u - 1, v - 1) in w.keys():\n            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)\n        else:\n            w[(u - 1, v - 1)] = c\n        if (u - 1, v - 1) in w_tmp.keys():\n            w_tmp[(u - 1, v - 1)].append(str(i + 1))\n        else:\n            w_tmp[(u - 1, v - 1)] = [str(i + 1)]\n        kk.append(c)\n        # c_m = max(c, c_m)\n\n    # print(find_loop(copy.deepcopy(g), copy.deepcopy(w), 0, n))\n\n    kk.sort()\n    l, r = 0, len(kk)\n    if not find_loop(g, w, kk[l], n):\n        print(0, 0)\n        exit(0)\n    if find_loop(g, w, kk[-1], n):\n        kkk = kk[-1]\n    else:\n        while l + 1 != r:\n            m = int((l + r) / 2)\n            # if find_loop(copy.deepcopy(g), copy.deepcopy(w), kk[m], n):\n            if find_loop(g, w, kk[m], n):\n                l = m\n            else:\n                r = m\n        kkk = kk[l+1]\n\n    to_reverse = top_sort(g, w, kkk, n)\n    num = 0\n    s = []\n    for t in to_reverse:\n        num += len(w_tmp[t])\n        s.extend(w_tmp[t])\n\n    print(kkk, num)\n    print(\" \".join(s))\n\n\n\n\n\n",
    "complexity": "nlogn",
    "problem": "1100_E",
    "from": "CODEFORCES",
    "tags": "binary search,dfs and similar,graphs"
}
{
    "src": "import collections\nimport random\nimport heapq\nimport bisect\nimport math\nimport time\n# import operator as op\n# from functools import reduce\n\nclass Solution2:\n\n    def solve(self, s):\n        pass\n        \n\nclass Solution:\n\n    def solve(self, n, k):\n        \n        grow = 1\n        tot = 0\n\n        while n != tot - k:\n            tot += grow\n            grow += 1\n            n -= 1\n        return tot - k\n\n\nsol = Solution()\nsol2 = Solution2()\n\n\n#TT = int(input())\nfor test_case in range(1):\n    N, K = input().split()\n    # s = []\n    # for _ in range(int(N)):\n    #     s.append(int(input()))\n\n    out = sol.solve(int(N),int(K))\n    print(str(out))\n    #print(\"Case #\" + str(test_case+1) + \": \" + str(out))\n\n    # out2 = sol2.solve(s)\n    # print(\"Case #\" + str(i+1) + \": \" + str(out2))\n\n\n# for _ in range(100000):\n#     rand = [random.randrange(60) for _ in range(10)]\n#     out1 = sol.solve(rand)\n#     out2 = sol2.solve(rand)\n#     if out1 != out2: \n#         print(rand, out1, out2)\n#         break",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "import sys\nimport bisect\n\nls2int = lambda ls: int(''.join(map(str,ls)))\ndef candidates(digs, num):\n    if not digs:\n        return [[]]\n    \n    res = []\n    i = bisect.bisect_left(digs, num[0])\n    \n    # lead with same digit\n    if num[0] in digs:\n        for suffix in candidates(digs[:i]+digs[i+1:], num[1:]):\n            res.append([digs[i]] + suffix)\n    \n    # lead with next smallest digit:\n    if i > 0:\n        i -= 1\n        res.append([digs[i]] + list(reversed(digs[:i]+digs[i+1:])))\n    \n    return res\n    \ndef solution(a, b):\n    digits = [int(x) for x in sorted(a)]\n    ceiling = [int(x) for x in b]\n    \n    assert(len(digits) <= len(ceiling), 'solution does not exist')\n    if len(digits) < len(ceiling):\n        return ls2int(digits[::-1])\n    return max(ls2int(ls) for ls in candidates(digits, ceiling))\n    \na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\nprint(solution(a, b))",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "def pow1(n, k):\n    if k == 0:\n        return 1\n    if k == 1:\n        return n\n    else:\n        if k % 2 == 0:\n            a = pow1(n, k // 2) % mod\n            return a * a % mod\n        else:\n            return pow1(n, k - 1) % mod * n % mod\n\n \nmod = 10 ** 9 + 7\nn, k = map(int, input().split())\nif n == 0:\n    print(0)\nelse:\n    x = pow1(2, k + 1) % mod\n    print(((n * x - pow1(2, k) + 1)) % mod)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "k = int(input())\n\nmul = 1\nd = 1\n\nwhile k>mul*9*d:\n    k-=mul*9*d\n    d+=1\n    mul*=10\n    \n\nx = k%d\ny = k//d\ny+=mul\n\nif x==0:\n    print((y-1)%10)\nelse:\n    y = y//pow(10,d-x)\n    print(y%10)\n    ",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "import copy\n\nn,m,k=map(int,input().split())\nA=list(map(int,input().split()))\n\nANS=0\n\nfor i in range(m):\n    B=copy.deepcopy(A)\n    for j in range(i,n,m):\n        B[j]-=k\n\n    NOW=0\n\n    for j in range(i,n):\n        if j%m==i:\n            NOW=max(NOW+B[j],B[j])\n        else:\n            NOW+=B[j]\n\n        ANS=max(ANS,NOW)\n\nprint(ANS)\n        \n    \n",
    "complexity": "quadratic",
    "problem": "1197_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,math"
}
{
    "src": "n = int(input())\nif n%2==0:\n    a = n - 8\n    print(a,8)\nelse:\n    a = n-9\n    print(a,9)\n",
    "complexity": "constant",
    "problem": "0472_A",
    "from": "CODEFORCES",
    "tags": "math,number theory"
}
{
    "src": "n = int(input())\narr = list(map(int, input().split()))\ntracker = [[-1] * (n+1) for _ in range(2024)]\n \nd = [[] for _ in range(n)]\nfor j, v in enumerate(arr):\n\ttracker[v][j] = j\n\td[j].append(j)\n \nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = tracker[v][i]\n\t\th = tracker[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\ttracker[v+1][i] = h\n\t\t\td[i].append(h)\n \na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor tracker in d[s]:\n\t\ta[tracker] = min(a[tracker], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n, m = map(int,input().split())\nb = []\nd = []\nfor x in range(n):\n\tif x == 0:\n\t\ta,c = map(int,input().split())\n\t\tif (a * 60) + c > m:b.append(\"0 0\")\n\t\td.append((a * 60) + c)\n\telse:\n\t\ta ,c = map(int,input().split())\n\t\tif ((a * 60) + c) - d[-1] > (m * 2) + 1:\n\t\t\tf = d[-1] + m + 1\n\t\t\tb.append(str(f // 60) + \" \" + str((f % 60)))\n\t\td.append((a * 60) + c)\nif len(b) == 0:\n\tf = d[-1] + m + 1\n\tb.append(str(f // 60) + \" \" + str((f % 60)))\nprint(b[0])",
    "complexity": "linear",
    "problem": "0967_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import math\nn  = int(input())\n\nfor i in range(n):\n    l,r = [*map(int, input().split())]\n    l-=1\n    war1 = math.ceil(l/2)\n    if(l%2 == 1):\n        war1 = -1*war1\n    \n    war2 = math.ceil(r/2)\n    if(r%2 == 1):\n        war2 = -1*war2\n\n    print(war2-war1)",
    "complexity": "constant",
    "problem": "1080_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "def black_count(x, y):\n\ttotal = x * y\n\treturn total // 2\n\n\ndef black_count2(a, b, c, d):\n\treturn black_count(c, d) - black_count(a-1, d) - black_count(c, b-1) + black_count(a-1, b-1)\n\ndef white_count2(a, b, c, d):\n\ttotal = (c - a + 1) * (d - b + 1)\n\treturn total - black_count2(a, b, c, d)\n\n\ndef intersection(a, b, c, d, x, y):\n\tif x < a or y < b:\n\t\treturn None\n\tx = min(x, c)\n\ty = min(y, d)\n\treturn (a, b, x, y)\n\ndef intersection2(a1, b1, c1, d1, a2, b2, c2, d2):\n\tif b1 > d2 or a1 > c2:\n\t\treturn None\n\tif b2 > d1 or a2 > c1:\n\t\treturn None\n\n\ta = max(a1, a2)\n\tb = max(b1, b2)\n\tc = min(c1, c2)\n\td = min(d1, d2)\n\treturn (a, b, c, d)\n\n\ndef solve(n, m, W, B):\n\ttotal = n * m\n\twhites = total - black_count(n, m)\n\twhites += black_count2(*W)\n\twhites -= white_count2(*B)\n\tI = intersection2(*W, *B)\n\tif I:\n\t\twhites -= black_count2(*I)\n\tblacks = n * m - whites\n\treturn whites, blacks\n\ndef main():\n\tt = int(input())\n\tfor _ in range(t):\n\t\tn, m = map(int, input().split())\n\t\tW = list(int(i) for i in input().split())\n\t\tB = list(int(i) for i in input().split())\n\t\tw, b = solve(n, m, W, B)\n\t\tprint(w, b)\n\n\nif __name__ == '__main__':\n\tmain()\n",
    "complexity": "constant",
    "problem": "1080_C",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "def max_profit(n,k,l,d):\n    a=[]\n    s,p,i=0,0,-1\n    while(len(a)!=k-1):\n        p+=1\n        i+=1\n        if l[i] in d:\n            s+=l[i]\n            a.append(p)\n            p=0\n            d.remove(l[i])\n    print(s+d[0])\n    a.append(n-sum(i for i in a))\n    print(*a)\n\n\nn,k=map(int,input().split())\nl=list(map(int,input().split()))\nm=[]\nm[:]=l[:]\nd=[]\nm.sort(reverse=True)\nfor i in range(k):\n    d.append(m[i])\nmax_profit(n,k,l,d)",
    "complexity": "nlogn",
    "problem": "1006_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "def f(k):\n    res = 1\n    a = 2\n    while k:\n        if k % 2 == 1:\n            res *= a\n            k -= 1\n        else:\n            a *= a\n            k //= 2\n        res = res % (1000000007)\n        a = a % (1000000007)\n    return res\n\n\nn, k = map(int, input().split())\nif n == 0:\n    print(0)\nelif k == 0:\n    print((n * 2) % 1000000007)\nelse:\n    first = (2 * n - 1) % 1000000007\n    first *= f(k)\n    first = (first + 1) % 1000000007\n    print(first)\n\n\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque \n\n \nn, k = map(int,input().split())\ns = input()\n\n \n \n \ndef judge(needed):\n \n    \n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n \n    effect = [[inf]*(n+1) for j in range(k)]\n \n\n    \n    for j in range(k):\n        accu = 0\n        index = inf\n        for i in range(n)[::-1]:\n            if s[i]==ord('?') or s[i]==97+j:\n                accu += 1\n            else:\n                accu = 0\n\n   \n\n            if accu>=needed:\n                index = i + needed\n            effect[j][i] = index\n            effect[j][i] = min(effect[j][i],inf)\n\n\n   \n#    print(effect)                \n             \n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index]) \n\n\n\n        minstate[state] = minimum \n   \n \n#    print(minstate) \n \n \n \n    if minstate[-1]<=n:  return True\n    return False\n \n \nfront = 0\nrear = n//k+1\n \nwhile front < rear:\n    mid = (front+rear)//2\n    flag = judge(mid)\n#    print(mid,flag)\n \n    if flag:  \n        front = mid + 1\n    else:\n        rear = mid \n \nprint(front-1)\n",
    "complexity": "np",
    "problem": "1550_E",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,brute force,dp,strings,two pointers"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n\nn,m,k=map(int,input().split())\nYOKO=[list(map(int,input().split())) for i in range(n)]\nTATE=[list(map(int,input().split())) for i in range(n-1)]\n\nif k%2==1:\n    for i in range(n):\n        print(*[-1]*m)\n    exit()\n\nDP=[[0]*m for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n\n        MIN=1<<30\n\n        if j-1>=0:\n            MIN=min(MIN,YOKO[i][j-1]*2)\n        if j<m-1:\n            MIN=min(MIN,YOKO[i][j]*2)\n\n        if i-1>=0:\n            MIN=min(MIN,TATE[i-1][j]*2)\n        if i<n-1:\n            MIN=min(MIN,TATE[i][j]*2)\n\n        DP[i][j]=MIN\n\nDP0=DP[:]\n#print(DP)\n\nfor tests in range(k//2-1):\n    NDP=[[0]*m for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            MIN=DP[i][j]+DP0[i][j]\n\n            if 0<=i+1<n:\n                MIN=min(MIN,TATE[i][j]*2+DP[i+1][j])\n\n            if 0<=i-1<n:\n                MIN=min(MIN,TATE[i-1][j]*2+DP[i-1][j])\n\n            if 0<=j+1<m:\n                MIN=min(MIN,YOKO[i][j]*2+DP[i][j+1])\n\n            if 0<=j-1<m:\n                MIN=min(MIN,YOKO[i][j-1]*2+DP[i][j-1])\n\n            NDP[i][j]=MIN\n    DP=NDP\n\nfor dp in DP:\n    print(*dp)\n        \n\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "\nfrom bisect import bisect,bisect_left\n\nfrom collections import *\nfrom math import gcd,ceil,sqrt,floor,inf\nfrom heapq import *\nfrom itertools import *\nfrom operator import add,mul,sub,xor,truediv,floordiv\nfrom functools import *\n\n#------------------------------------------------------------------------\nimport os\nimport sys\n\nfrom io import BytesIO, IOBase\n# region fastio\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n\n#------------------------------------------------------------------------\ndef RL(): return map(int, sys.stdin.readline().split())\ndef RLL(): return list(map(int, sys.stdin.readline().split()))\ndef N(): return int(input())\ndef A(n):return [0]*n\ndef AI(n,x): return [x]*n\ndef A2(n,m): return [[0]*m for i in range(n)]\ndef G(n): return [[] for i in range(n)]\ndef GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]\n#------------------------------------------------------------------------\n\n\nfrom types import GeneratorType\n \n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n \n    return wrappedfunc\n\nmod=10**9+7\nfarr=[1]\nifa=[]\n \ndef fact(x,mod=0):\n    if mod:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr)%mod)\n    else:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr))\n    return farr[x]\n \ndef ifact(x,mod):\n    global ifa\n    fact(x,mod)\n    ifa.append(pow(farr[-1],mod-2,mod))\n    for i in range(x,0,-1):\n        ifa.append(ifa[-1]*i%mod)\n    ifa.reverse()\n \ndef per(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return fact(i)//fact(i-j)\n    return farr[i]*ifa[i-j]%mod\n    \ndef com(i,j,mod=0):\n    if i<j: return 0\n    if not mod:        \n        return per(i,j)//fact(j)\n    return per(i,j,mod)*ifa[j]%mod\n \ndef catalan(n):\n    return com(2*n,n)//(n+1)\n \ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef floorsum(a,b,c,n):#sum((a*i+b)//c for i in range(n+1))\n    if a==0:return b//c*(n+1)\n    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2\n    m=(a*n+b)//c\n    return n*m-floorsum(c,c-b-1,a,m-1)\n\ndef inverse(a,m):\n    a%=m\n    if a<=1: return a\n    return ((1-inverse(m,a)*m)//a)%m\n \ndef lowbit(n):\n    return n&-n\n \nclass BIT:\n    def __init__(self,arr):\n        self.arr=arr\n        self.n=len(arr)-1\n        \n    def update(self,x,v):\n        while x<=self.n:\n            self.arr[x]+=v\n            x+=x&-x\n \n    def query(self,x):\n        ans=0\n        while x:\n            ans+=self.arr[x]\n            x&=x-1\n        return ans\n\nclass ST:\n    def __init__(self,arr):#n!=0\n        n=len(arr)\n        mx=n.bit_length()#\u53d6\u4e0d\u5230\n        self.st=[[0]*mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0]=arr[i]\n        for j in range(1,mx):\n            for i in range(n-(1<<j)+1):\n                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])\n    def query(self,l,r):\n        if l>r:return -inf\n        s=(r+1-l).bit_length()-1\n        return max(self.st[l][s],self.st[r-(1<<s)+1][s])\n        \nclass DSU:#\u5bb9\u91cf+\u8def\u5f84\u538b\u7f29\n    def __init__(self,n):\n        self.c=[-1]*n\n \n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n \n    def find(self,x):\n        if self.c[x]<0:\n            return x\n        self.c[x]=self.find(self.c[x])\n        return self.c[x]\n \n    def union(self,u,v):\n        u,v=self.find(u),self.find(v)\n        if u==v:\n            return False\n        if self.c[u]>self.c[v]:\n            u,v=v,u\n        self.c[u]+=self.c[v]\n        self.c[v]=u\n        return True\n \n    def size(self,x): return -self.c[self.find(x)]\n    \nclass UFS:#\u79e9+\u8def\u5f84\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n \n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n \ndef Prime(n):\n    c=0\n    prime=[]\n    flag=[0]*(n+1) \n    for i in range(2,n+1):\n        if not flag[i]:\n            prime.append(i)\n            c+=1\n        for j in range(c):\n            if i*prime[j]>n: break\n            flag[i*prime[j]]=prime[j]\n            if i%prime[j]==0: break\n    return flag\n \ndef dij(s,graph):\n    d={}\n    d[s]=0\n    heap=[(0,s)]\n    seen=set()\n    while heap:\n        dis,u=heappop(heap)\n        if u in seen:\n            continue\n        seen.add(u)\n        for v,w in graph[u]:\n            if v not in d or d[v]>d[u]+w:\n                d[v]=d[u]+w\n                heappush(heap,(d[v],v))\n    return d\n\ndef bell(s,g):#bellman-Ford\n    dis=AI(n,inf)\n    dis[s]=0\n    for i in range(n-1):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n    change=A(n)\n    for i in range(n):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n                change[v]=1\n    return dis\n\ndef lcm(a,b): return a*b//gcd(a,b)\ndef lis(nums):\n    res=[]\n    for k in nums:\n        i=bisect.bisect_left(res,k)\n        if i==len(res):\n            res.append(k)\n        else:\n            res[i]=k\n    return len(res)\n\ndef RP(nums):#\u9006\u5e8f\u5bf9\n    n = len(nums)\n    s=set(nums)\n    d={}\n    for i,k in enumerate(sorted(s),1):\n        d[k]=i\n    bi=BIT([0]*(len(s)+1))\n    ans=0\n    for i in range(n-1,-1,-1):\n        ans+=bi.query(d[nums[i]]-1)\n        bi.update(d[nums[i]],1)\n    return ans\n \nclass DLN:\n    def __init__(self,val):\n        self.val=val\n        self.pre=None\n        self.next=None\n\ndef nb(i,j,n,m):\n    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:\n        if 0<=ni<n and 0<=nj<m:\n            yield ni,nj\n\ndef topo(n):\n    q=deque()\n    res=[]\n    for i in range(1,n+1):\n        if ind[i]==0:\n            q.append(i)\n            res.append(i)\n    while q:\n        u=q.popleft()\n        for v in g[u]:\n            ind[v]-=1\n            if ind[v]==0:\n                q.append(v)\n                res.append(v)\n    return res\n\n@bootstrap\ndef gdfs(r,p):\n    for ch in g[r]:\n        if ch!=p:\n            yield gdfs(ch,r)\n    yield None\n\n\n    \n\nt=1\nfor i in range(t):\n    n,m,k=RL()\n    h=[]\n    v=[]\n    for i in range(n):\n        h.append(RLL())\n    for i in range(n-1):\n        v.append(RLL())\n    if k&1:\n        for i in range(n):\n            print(*AI(m,-1))\n        exit()\n    k//=2\n    dp=[[[inf]*m for i in range(n)]for j in range(k+1)]\n    for i in range(n):\n        for j in range(m):\n            dp[0][i][j]=0\n    for i in range(1,k+1):\n        for j in range(n):\n            for a in range(m):\n                if j:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j-1][a]+2*v[j-1][a])\n                if j+1<n:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j+1][a]+2*v[j][a])\n                if a:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a-1]+2*h[j][a-1])\n                if a+1<m:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a+1]+2*h[j][a])\n    for i in range(n):\n        res=[]\n        for j in range(m):\n            res.append(dp[k][i][j])\n        print(*res)\n    #print(ans)\n\n\n    \n''' \nsys.setrecursionlimit(200000)\nimport threading\nthreading.stack_size(10**8)\nt=threading.Thr\nead(target=main)\nt.start()\nt.join()\n'''\n\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "from itertools import combinations\nn,l,r,x=map(int,input().split())\narr=list(map(int,input().split()))\nans=0\nfor i in range(2,n+1):\n\tbrr=list(combinations(arr,i))\n\tfor j in brr:\n\t\ts=sum(j)\n\t\tif l<=s<=r and max(j)-min(j)>=x:\n\t\t\tans+=1\nprint(ans)\n",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "import os\nimport sys\nfrom math import *\nfrom collections import *\n\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\n\n\ndef vsInput():\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA = \"abcdefghijklmnopqrstuvwxyz/\"\nM = 1000000007\nEPS = 1e-6\n\n\ndef Ceil(a, b):\n    return a // b + int(a % b > 0)\n\n\ndef value():\n    return tuple(map(int, input().split()))\n\n\ndef array():\n    return [int(i) for i in input().split()]\n\n\ndef Int():\n    return int(input())\n\n\ndef Str():\n    return input()\n\n\ndef arrayS():\n    return [i for i in input().split()]\n\n\n# -------------------------code---------------------------#\n\nn = int(input())\nif n == 0:\n    print(0)\nelse:\n    print(n // 2 + 1 if n % 2 != 0 else n + 1)\n",
    "complexity": "constant",
    "problem": "0979_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n    if a[i]>=0:\n        a[i] = -a[i]-1\nx = min(a)\n\nif len(a)%2==1:\n    for i in range(n):\n        if a[i]==x:\n            a[i] = -a[i]-1\n            break\nprint(*a)",
    "complexity": "linear",
    "problem": "1180_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation"
}
{
    "src": "n = int(input())\np = [list(map(int, input().split())) for _ in range(n)]\nf = lambda a, b, c: (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\ndef g(fi, se, p):\n    q = []\n    for x in p:\n        if f(fi, se, x):\n            if len(q) < 2:\n                q.append(x)\n            else:\n                if f(q[0], q[1], x):\n                    return 1\n    return 0\nprint('NO' if n > 4 and all([g(p[0], p[1], p), g(p[0], p[2], p), g(p[1], p[2], p)]) else 'YES')\n\n",
    "complexity": "nlogn",
    "problem": "0961_D",
    "from": "CODEFORCES",
    "tags": "geometry"
}
{
    "src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\n# B. Minimum Diameter Tree\n\nfrom collections import Counter\n\nn, s = mi()\nd = Counter()\nfor i in range(n - 1):\n    u, v = mi()\n    d[u] += 1\n    d[v] += 1\n\nl = sum(v == 1 for v in d.values())\nans = s / l * 2\nprint('%.10f' % (ans,))\n",
    "complexity": "linear",
    "problem": "1086_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,trees"
}
{
    "src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\n\nfor _ in range(N):\n    l,r = getIntList()\n    n = (r-l+1)\n    z = n//2\n    if l%2==0:\n        z*=-1\n    if n%2==1:\n        if r%2==0:\n            z += r\n        else:\n            z-=r\n    print(z)\n\n    \n\n\n\n\n",
    "complexity": "constant",
    "problem": "1080_B",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "from sys import stdin\n\nadd = lambda a, b: (a + b) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, k + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])\n\nprint(sum(mem[-1][k]) % mod)\n",
    "complexity": "np",
    "problem": "1051_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "n = int(input())\n*a, = map(int, input().split())\ndp = [[0 for i in range(n + 1)] for j in range(n + 1)]\nfor i in range(n):\n    dp[0][i] = a[i]\nfor i in range(1, n):\n    for j in range(n - i + 1):\n        dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1]\nfor i in range(1, n):\n    for j in range(n - i):\n        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1])\nfor i in range(int(input())):\n    l, r = map(int, input().split())\n    print(dp[r - l][l - 1])",
    "complexity": "quadratic",
    "problem": "0983_B",
    "from": "CODEFORCES",
    "tags": "dp"
}
{
    "src": "n = int(input())\n\nfirst = list(input())\nsecond = list(input())\n\nswap = list()\ncan = True\n\nfor i in range(n):\n    if first[i] != second[i]:\n        cont = -1\n        for j in range(i,n): \n            if first[j] == second[i]:\n                cont = j \n                break\n            \n        if cont != -1:\n            for j in range(cont, i, -1 ):\n                first[j], first[j-1] = first[j-1], first[j]\n                swap.append(j)\n        else:\n            can = False\n\nif can: \n    print(len(swap))\n    print(*swap, end=' ')\n\nelse: \n    print(-1)",
    "complexity": "quadratic",
    "problem": "1015_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import io, sys\ninput = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()\n\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nn, m, k = mi()\na = [None] + li()\np = [0] * (n + 1)\nfor i in range(1, n + 1):\n    p[i] = p[i - 1] + a[i]\ns = [10 ** 16 for _ in range(m)]\ns[0] = k\nans = 0\nfor i in range(1, n + 1):\n    ans = max(ans, p[i] - min(s))\n    s[i % m] = min(s[i % m], p[i])\n    s[i % m] += k\nprint(ans)\n",
    "complexity": "linear",
    "problem": "1197_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,math"
}
{
    "src": "R, G, B = map(int, input().split())\nL = [sorted(map(int, input().split())) for _ in range(3)]\nDP = [0] * ((R+1) * (G+1) * (B+1))\n\ndef idx(r, g, b):\n  return r * (G+1) * (B+1) + g * (B+1) + b\n\nfor r in range(R+1):\n  for g in range(G+1):\n    for b in range(B+1):\n      best = 0\n      if r:\n        if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]\n        if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])\n      if g and b:\n        best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])\n      DP[idx(r, g, b)] = best\nprint(max(DP))\n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "import sys\nimport heapq\ninput = sys.stdin.readline\nn = int(input())\nw = [int(z) for z in input().split()]; s = input(); idx = []\nfor i in range(n):\n    idx.append((w[i], i+1))\n\nidx.sort()\nheapq.heapify(idx)\nones = []\nheapq.heapify(ones)\nres = []\nfor i in range(2*n):\n    if s[i] == '0':\n        l = idx[0]\n        heapq.heappop(idx)\n        res.append(l[1])\n        heapq.heappush(ones, [-l[0], l[1]])\n    else:\n        l = ones[0]\n        heapq.heappop(ones)\n        res.append(l[1])\nres = ' '.join([str(i) for i in res])\nsys.stdout.write(res)",
    "complexity": "nlogn",
    "problem": "0982_B",
    "from": "CODEFORCES",
    "tags": "data structures,greedy,implementation"
}
{
    "src": "n, k = map(int, input().split())\nc = n + k\np = int(0.5 * ((8 * c + 9) ** 0.5 - 3))\nprint(n - p)\n",
    "complexity": "constant",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "x, y, z, t1, t2, t3 = map(int, input().split())\nlift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3\nstairs = t1 * abs(x - y)\nif lift <= stairs:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
    "complexity": "constant",
    "problem": "1054_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "\ndef combine(n, k, w=1, out=[], result=[]):\n    if k == 0:\n        result.append(out)\n\n    for i in range(w, n + 1):\n        new_out = out[:]\n        new_out.append(i)\n        combine(n, k-1, i+1, new_out)\n\n    return result\n\n\ndef main():\n\n    n, l, r, x = [int(i) for i in input().split()]\n    c = [int(i) for i in input().split()]\n\n    if n < 2:\n        print(0)\n        return\n\n    result = None\n    for i in range(2, n + 1):\n        if i == n:\n            result = combine(n, i)\n        else:\n            combine(n, i)\n\n    for i in range(len(result)):\n        comb = result[i]\n        for j in range(len(comb)):\n            comb[j] = c[comb[j] - 1]\n\n    cnt = 0\n    for i in range(len(result)):\n        sm = sum(result[i])\n        if sm >= l and sm <= r and (max(result[i]) - min(result[i]) >= x):\n            cnt += 1\n\n    print(cnt)\n\n\n\nif __name__ == '__main__':\n    main()\n\n\n",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "if __name__ == '__main__':\n\tn = int(input())\n\tnum = n + n//2\n\tprint(num)",
    "complexity": "constant",
    "problem": "0084_A",
    "from": "CODEFORCES",
    "tags": "math,number theory"
}
{
    "src": "#by Nick \"LordVader\" Proshin.\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(set(a)) == 1:\n        print(a[0],a[0],a[0],a[0])\n    else:\n        a.sort()\n        g1 = False\n        d = {}\n        mx = 10001\n        for i in a:\n            if i not in d.keys():\n                d[i] = 1\n            else:\n                d[i] += 1\n            if d[i] == 4:\n                g1 = True\n                if i < mx:\n                    mx = i\n        if g1:\n            print(mx, mx, mx, mx)\n        else:\n            res = []\n            for k in d.keys():\n                if d[k] >= 2:\n                    res.append(k)\n            m = len(res)\n            minj = 0\n            for j in range(m - 1):\n                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):\n                    minj = j\n            print(res[minj],res[minj],res[minj+1],res[minj+1])",
    "complexity": "nlogn",
    "problem": "1027_C",
    "from": "CODEFORCES",
    "tags": "greedy"
}
{
    "src": "X, K = map(int, input().split())\nmod = 1000000007\nres = X*pow(2, K+1, mod)-pow(2, K, mod)+1;\nwhile(res < 0):\n   res += mod\nif(X == 0):\n   print(0)\nelse:\n   print(res%mod)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n=int(input())\nprint(2*n*n-2*n+1)",
    "complexity": "constant",
    "problem": "1180_A",
    "from": "CODEFORCES",
    "tags": "dp,implementation,math"
}
{
    "src": "#!/usr/bin/env python\nimport os\nimport re\nimport sys\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom collections import Counter, defaultdict, deque\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom fractions import gcd\nfrom io import BytesIO, IOBase\nfrom itertools import (\n    accumulate, combinations, combinations_with_replacement, groupby,\n    permutations, product)\nfrom math import (\n    acos, asin, atan, ceil, cos, degrees, factorial, hypot, log2, pi, radians,\n    sin, sqrt, tan)\nfrom operator import itemgetter, mul\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\n\ndef inp():\n    return(int(input()))\n\n\ndef inlist():\n    return(list(map(int, input().split())))\n\n\ndef instr():\n    s = input()\n    return(list(s[:len(s)]))\n\n\ndef invr():\n    return(map(int, input().split()))\n\n\ndef getReamin(action, n):\n    n -= action\n    ans = (n*(n+1) // 2) - action\n    return ans\n\n\ndef main():\n    # sys.stdin = open('input.txt', 'r')\n    # sys.stdout = open('output.txt', 'w')\n\n    n, k = invr()\n    l = 1\n    r = n\n    res = 0\n    while l <= r:\n        mid = l + (r-l)//2\n        remain = getReamin(mid, n)\n        if remain == k:\n            res = mid\n            break\n        if remain > k:\n            l = mid + 1\n        else:\n            r = mid - 1\n    print(res)\n\n\n    # region fastio\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "complexity": "logn",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n#sys.setrecursionlimit(111111) \nINF=99999999999999999999999999999999\n\ndef main():\n    \n    mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n    ###CODE\n    tc = 1\n    for _ in range(tc):\n        n=ri()\n        s=ria()\n        c=ria()\n        ans=INF\n        for i in range(n):\n            mid=s[i]\n            mcl=INF\n            mrl=INF\n            for j in range(i-1,-1,-1):\n                if s[j]<mid:\n                    mcl=min(mcl,c[j])\n            for j in range(i+1,n):\n                if s[j]>mid:\n                    mrl=min(mrl,c[j])\n            ans=min(ans,c[i]+mcl+mrl)\n        if ans==INF:\n            wi(-1)\n        else:\n            wi(ans)\n                    \n            \n            \n        \n                        \n                \n                \n            \n                    \n                    \n                     \n                \n        \n                        \n\n            \n            \n                    \n                \n                \n        \n                \n                          \n            \n        \n    \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    ",
    "complexity": "quadratic",
    "problem": "0987_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,implementation"
}
{
    "src": "def wins(mem, l, pos):\n\t# print(pos)\n\tif mem[pos] != 0:\n\t\treturn mem[pos] == 1\n\n\tval = l[pos]\n\n\tlo = pos - val\n\twhile lo >= 0:\n\t\tif l[lo] > val and not wins(mem, l, lo):\n\t\t\tmem[pos] = 1\n\t\t\treturn True\n\t\tlo -= val\n\n\thi = pos + val\n\twhile hi < len(l):\n\t\tif l[hi] > val and not wins(mem, l, hi):\n\t\t\tmem[pos] = 1\n\t\t\treturn True\n\t\thi += val\n\n\tmem[pos] = 2\n\treturn False\n\n\n\nn = int(input())\nl = list(map(int, raw_input().split()))\n\nmem = [0 for i in range(n)]\nans = \"\"\nfor i in range(n):\n\tans += \"A\" if wins(mem, l, i) else \"B\"\n\nprint(ans)\n",
    "complexity": "linear",
    "problem": "1033_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,games"
}
{
    "src": "from sys import stdin\n\nn = int(stdin.readline())\n\nstones = sorted([int(x) for x in stdin.readline().split()])\n\nif n == 1:\n    if stones[0]%2 == 0:\n        print('cslnb')\n    else:\n        print('sjfnb')\n\nelse:\n    chilly = -1\n    chill = 2\n    prev = stones[0]\n    \n    for x in stones[1:]:\n        if x == prev:\n            chill -= 1\n            chilly = x\n        else:\n            streak = 1\n            prev = x\n    \n    s = sum(stones)\n\n    if n%4 == 0 or n%4 == 1:\n        s += 1\n\n    if chill <= 0 or stones.count(0) > 1:\n        print('cslnb')\n    elif chill == 1 and chilly-1 in stones:\n        print('cslnb')\n    elif s%2 == 1:\n        print('cslnb')\n    else:\n        print('sjfnb')\n",
    "complexity": "nlogn",
    "problem": "1190_B",
    "from": "CODEFORCES",
    "tags": "games"
}
{
    "src": "def checksq(n):\n    m = int(n**0.5)\n    if m * m == n:\n        return m\n    m += 1\n    if m * m == n:\n        return m\n    return -1\n\ndef main():\n    # n, m = map(int, input().split())\n    n = int(input())\n    # arr = list(map(int, input().split()))\n    # s = input()\n    if n % 2 == 1:\n        print(\"NO\")\n        return\n    if checksq(n // 2) != -1:\n        print('YES')\n        return\n    n //= 2\n    if n % 2 == 1:\n        print('NO')\n        return\n    if checksq(n // 2) != -1:\n        print('YES')\n    else:\n        print('NO')\n\n\n\n\n# for i in range(1):\nfor i in range(int(input())):\n    main()",
    "complexity": "constant",
    "problem": "1515_B",
    "from": "CODEFORCES",
    "tags": "brute force,geometry,math,number theory"
}
{
    "src": "\ndef aburrimin(x, y, n, m, costder, costaba, dp):\n    dists = []\n    vals = []\n    if x != 0: # izq\n        dis = costder[y][x-1]\n        dists.append(dis)\n        vals.append(dis+dp[y][x-1])\n    if y != 0: # arri\n        dis = costaba[y-1][x]\n        dists.append(dis)\n        vals.append(dis+dp[y-1][x])\n    if y < n-1: # aba\n        dis = costaba[y][x]\n        dists.append(dis)\n        vals.append(dis+dp[y+1][x])\n    if x < m-1: # der\n        dis = costder[y][x]\n        dists.append(dis)\n        vals.append(dis+dp[y][x+1])\n    \n    mindis = min(dists)\n    return min(mindis+dp[y][x],min(vals))\n        \n\ndef solvecaso():\n    n,m,k = map(int,input().split())\n    costder = [[int(x) for x in input().split()] for _ in range(n)]\n    costaba = [[int(x) for x in input().split()] for _ in range(n-1)]\n    if k%2:\n        for i in range(n):\n            for j in range(m):\n                print(-1, end=' ')\n            print()\n        return -1\n    k //= 2\n    \n    for ren in range(len(costder)):\n        for col in range(len(costder[ren])):\n            costder[ren][col] *= 2\n    for ren in range(len(costaba)):\n        for col in range(len(costaba[ren])):\n            costaba[ren][col] *= 2\n    \n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    dptemp = [[0 for _ in range(m)] for _ in range(n)]\n    # print(dp) # debug\n    \n    for i in range(k):\n        for y in range(n):\n            for x in range(m):\n                dptemp[y][x] = aburrimin(x, y, n, m, costder, costaba, dp)\n        dp, dptemp = dptemp, dp\n        # print(dp) # debug\n    \n    for ren in dp:\n        for num in ren:\n            print(num, end=' ')\n        print()\n    \n    return 0\n\n\nif __name__ == \"__main__\":\n    # casos = int(input()) #dbug\n    # for caso in range(1,casos+1):#dbug\n        # result = solvecaso()#dbug\n    solvecaso() #dbug\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "import sys\nimport threading\n\ndef dfs(g, i, p):\n    global ans\n    count = 0\n    for j in g[i]:\n        if j == p:\n            continue\n        count += dfs(g, j, i)\n    if count == 0:\n        count = 1\n    ans.append(count)\n    return count\n\ndef solve():\n    \n    n = int(input())\n    l = list(map(int, input().split()))\n    g = [[] for i in range(n+1)]\n\n    for i in range(1, n):\n        g[i+1].append(l[i-1])\n        g[l[i-1]].append(i+1)\n\n    dfs(g, 1, 0)\n    ans.sort()\n    st = ' '.join(map(str, ans))\n    print(st)\n\nans = []\nmax_recur_size = 10**5*2 + 1000\nmax_stack_size = max_recur_size*500\n \nsys.setrecursionlimit(max_recur_size)\nthreading.stack_size(max_stack_size)\nthread = threading.Thread(target=solve)\nthread.start()",
    "complexity": "quadratic",
    "problem": "1056_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"
}
{
    "src": "a, b = map(int, input().split())\nx, y, z = map(int, input().split())\nneeda = 2 * x + y\nneedb = y + 3 * z\nprint(max(0, needa - a) + max(0, needb - b))",
    "complexity": "constant",
    "problem": "0912_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "l,r = map(int,input().split())\n\np = l\nlp = -1\nwhile p:\n    p = p>>1\n    lp+=1\n\nq = r\nrp = -1\nwhile q:\n    q = q>>1\n    rp+=1\n\ns = max(lp,rp)\n\nn=0\n\nwhile s>=0:\n    if l>>s&1!=r>>s&1:\n        n |= (r>>s&1)<<s\n        break\n    s-=1\n\ns-=1\n\nwhile s>=0:\n    n |= 1<<s\n    s-=1\n\nprint(n)\n",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "n = int(input())\nl = list( map( int, input().split() ) )\nans = max(l)\nfor i in range(n):\n    ans = min( ans, l[ i ] // max( i, n - i - 1 ))\nprint( ans )",
    "complexity": "linear",
    "problem": "1159_B",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "from collections import Counter\n\nn, k = map(int, input().split())\n\nfor p in range(n+1):\n    if p*(p+1)//2 - (n-p) == k:\n        print(n-p)\n        break\n",
    "complexity": "linear",
    "problem": "1195_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,math"
}
{
    "src": "def onseg(p,q,r):\n    return min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and \\\n           min(p[1], r[1]) <= q[1] <= max(p[1], r[1])\n\ndef orientation(p,q,r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n          (q[0] - p[0]) * (r[1] - q[1])\n \n    if (val == 0): return 0  # colinear\n    return 1 if val > 0 else 2 # clock or counterclock wise\n\ndef doint(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n \n    if o1 != o2 and o3 != o4:\n        return True\n \n    if o1 == 0 and onseg(p1, p2, q1): return True\n    if o2 == 0 and onseg(p1, q2, q1): return True\n    if o3 == 0 and onseg(p2, p1, q2): return True\n    if o4 == 0 and onseg(p2, q1, q2): return True\n \n    return False\n\nx0,y0,x1,y1,x2,y2,x3,y3 = map(int,input().split())\nx4,y4,x5,y5,x6,y6,x7,y7 = map(int,input().split())\n\nA = x0,y0\nB = x1,y1\nC = x2,y2\nD = x3,y3\na = x4,y4\nb = x5,y5\nc = x6,y6\nd = x7,y7\n\nif doint(A,B,a,b) or doint(A,C,a,b) or doint(A,D,a,b) or doint(B,C,a,b) or doint(B,D,a,b) or doint(C,D,a,b) or \\\n   doint(A,B,a,c) or doint(A,C,a,c) or doint(A,D,a,c) or doint(B,C,a,c) or doint(B,D,a,c) or doint(C,D,a,c) or \\\n   doint(A,B,a,d) or doint(A,C,a,d) or doint(A,D,a,d) or doint(B,C,a,d) or doint(B,D,a,d) or doint(C,D,a,d) or \\\n   doint(A,B,b,c) or doint(A,C,b,c) or doint(A,D,b,c) or doint(B,C,b,c) or doint(B,D,b,c) or doint(C,D,b,c) or \\\n   doint(A,B,b,d) or doint(A,C,b,d) or doint(A,D,b,d) or doint(B,C,b,d) or doint(B,D,b,d) or doint(C,D,b,d) or \\\n   doint(A,B,c,d) or doint(A,C,c,d) or doint(A,D,c,d) or doint(B,C,c,d) or doint(B,D,c,d) or doint(C,D,c,d):\n    print('YES')\nelse:\n    print('NO')\n\n",
    "complexity": "constant",
    "problem": "0994_C",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "# pylint: disable=unused-variable\n# pylint: enable=too-many-lines\n# * Just believe in yourself\n\n\n# @ Author @CAP\n# import numpy\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport math as M\nimport itertools as ITR\nfrom collections import defaultdict as D\nfrom collections import Counter as C\nfrom collections import deque as Q\nimport threading\nfrom functools import lru_cache, reduce\nfrom functools import cmp_to_key as CMP\nfrom bisect import bisect_left as BL\nfrom bisect import bisect_right as BR\nimport random as R\nimport string\nimport cmath, time\n\nenum = enumerate\nstart_time = time.time()\n\n# * Variables\n\nMOD = 1_00_00_00_007\nMA = float(\"inf\")\nMI = float(\"-inf\")\n\n# * Graph 8 direction\ndi8 = ((1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1))\n\n# * Graph 4 direction\ndi4 = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n# * Stack increment\n\n\ndef increase_stack():\n    sys.setrecursionlimit(2 ** 32 // 2 - 1)\n    threading.stack_size(1 << 27)\n    # sys.setrecursionlimit(10**6)\n    # threading.stack_size(10**8)\n    # t = threading.Thread(target=main)\n    # t.start()\n    # t.join()\n\n\n# * Region Funtions\n\n\ndef binary(n):\n    return bin(n)[2:]\n\n\ndef decimal(s):\n    return int(s, 2)\n\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return p\n\n\ndef maxfactor(n):\n    q = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            q.append(i)\n    if q:\n        return q[-1]\n\n\ndef factors(n):\n    q = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            q.append(i)\n            q.append(n // i)\n    return list(sorted(list(set(q))))\n\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(M.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    l.sort()\n    return l\n\n\ndef isPrime(n):\n    if n == 1:\n        return False\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if n % i == 0:\n                return False\n        return True\n\n\ndef seive(n):\n    a = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = False\n        p = p + 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            a.append(p)\n    prime[0] = prime[1] = False\n    return a, prime\n\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(M.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\n\ndef countchar(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if s[i] == ch:\n            c += 1\n        else:\n            break\n    return c\n\n\ndef str_counter(a):\n    q = [0] * 26\n    for i in range(len(a)):\n        q[ord(a[i]) - 97] = q[ord(a[i]) - 97] + 1\n    return q\n\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    maximum = 0\n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n                maximum = max(maximum, lis[i])\n    return maximum\n\n\ndef lcm(arr):\n    a = arr[0]\n    val = arr[0]\n\n    for i in range(1, len(arr)):\n\n        gcd = gcd(a, arr[i])\n        a = arr[i]\n        val *= arr[i]\n\n    return val // gcd\n\n\ndef ncr(n, r):\n    return M.factorial(n) // (M.factorial(n - r) * M.factorial(r))\n\n\ndef npr(n, r):\n    return M.factorial(n) // M.factorial(n - r)\n\n\n# * Make work easy funtions\n\n\ndef IF(c, t, f):\n    return t if c else f\n\n\ndef YES(c):\n    print(IF(c, \"YES\", \"NO\"))\n\n\ndef Yes(c):\n    print(IF(c, \"Yes\", \"No\"))\n\n\ndef yes(c):\n    print(IF(c, \"yes\", \"no\"))\n\n\ndef JA(a, sep=\" \"):\n    print(sep.join(map(str, a)))\n\n\ndef JAA(a, s=\"\\n\", t=\" \"):\n    return s.join(t.join(map(str, b)) for b in a)\n\n\ndef PS(a, s=\" \"):\n    print(str(a), end=s)\n\n\n# * Region Taking Input\n\n\ndef I():\n    return int(inp())\n\n\ndef F():\n    return float(inp())\n\n\ndef LI():\n    return list(map(int, inp().split()))\n\n\ndef LF():\n    return list(map(float, inp().split()))\n\n\ndef MATI(n):\n    return [LI() for i in range(n)]\n\n\ndef MATS(n):\n    return [list(inp()) for i in range(n)]\n\n\ndef IV():\n    return map(int, inp().split())\n\n\ndef FV():\n    return map(float, inp().split())\n\n\ndef LS():\n    return list(inp())\n\n\ndef S():\n    return inp()\n\n\n# * Region Fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# <==================================== Write The Useful Code Here ============================\n\n# < Make it one if there is some test cases\nTestCases = 0  # <=====================\n# < =======================================\n\"\"\"\n> Sometimes later becomes never. Do it now.\n! Be Better than yesterday.\n* Your limitation\u2014it\u2019s only your imagination.\n> Push yourself, because no one else is going to do it for you.\n? The harder you work for something, the greater you\u2019ll feel when you achieve it.\n! Great things never come from comfort zones.\n* Don\u2019t stop when you\u2019re tired. Stop when you\u2019re done.\n> Do something today that your future self will thank you for.\n? It\u2019s going to be hard, but hard does not mean impossible.\n! Sometimes we\u2019re tested not to show our weaknesses, but to discover our strengths.\n\"\"\"\n# @  Goal is to get Candidate Master\n\n\ndef solve():\n    a, b = IV()\n\n    if b - a + 1 < 3:\n        print(\"-1\")\n\n    elif a % 2 == 0:\n        print(a, a + 1, a + 2)\n\n    elif b - a + 1 > 3:\n        print(a + 1, a + 2, a + 3)\n    else:\n        print(-1)\n\n\n# * This is the Main Function\n\n\ndef main():\n    flag = 1\n    #! Checking we are offline or not\n    try:\n        sys.stdin = open(\n            \"c:/Users/Manoj Chowdary/Documents/python/CodeForces/contest-div-2/input.txt\",\n            \"r\",\n        )\n        sys.stdout = open(\n            \"c:/Users/Manoj Chowdary/Documents/python/CodeForces/contest-div-2/output.txt\",\n            \"w\",\n        )\n    except:\n        flag = 0\n\n    t = 1\n    if TestCases:\n        t = I()\n    for _ in range(1, t + 1):\n        solve()\n\n    if flag:\n        print(\"Time: %.4f sec\" % (time.time() - start_time))\n        localtime = time.asctime(time.localtime(time.time()))\n        print(localtime)\n        sys.stdout.close()\n\n\n# * End Region\n\n\nif __name__ == \"__main__\":\n\n    # ? Incresing Stack Limit\n    # increase_stack()\n\n    #! Calling Main Function\n    main()",
    "complexity": "constant",
    "problem": "0483_A",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,math,number theory"
}
{
    "src": "n,s=map(int,input().split())\nx=s//n\nif x*n<s:\n    x+=1\nprint(x)",
    "complexity": "constant",
    "problem": "1061_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\nsys.setrecursionlimit(111111) \nINF=999999999999999999999999\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n \n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n \n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n \n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n \n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n \n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n \n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n \n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n \n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n \n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n \n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n \n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n \n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n \n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n \n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n \n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n \n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n \n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n \n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n \n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n \n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n \n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\ndef main():\n\n    mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n    ###CODE\n    tc = 1\n    for _ in range(tc):\n        n,k=ria()\n        a=ria()\n        a=sorted(a)\n        d=Counter(a)\n        ans=0\n        for i in a:\n            if d[i]:\n                ans+=1\n                d[i*k]=0\n        wi(ans)\n        \n           \n                     \n            \n        \n                \n        \n        \n            \n        \n        \n        \n        \n        \n\n    \n        \n        \n        \n                \n                \n        \n        \n        \n    \n\n        \n        \n        \n\n        \n                             \n        \n        \n        \n            \n        \n        \n                     \n        \n        \n                    \n        \n                     \n                    \n                    \n                \n                \n                    \n                \n        \n        \n            \n                   \n        \n                    \n\n        \n        \n                \n            \n            \n    \n            \n                        \n        \n    \n\n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    ",
    "complexity": "nlogn",
    "problem": "0274_A",
    "from": "CODEFORCES",
    "tags": "binary search,greedy,sortings"
}
{
    "src": "\"\"\"\n    Template written to be used by Python Programmers.\n    Use at your own risk!!!!\n    Owned by enraged(rating - 5 star at CodeChef and Specialist at Codeforces).\n\"\"\"\nimport sys\nimport bisect\nimport heapq\n# from math import *\nfrom collections import defaultdict as dd  # defaultdict(<datatype>) Free of KeyError.\nfrom collections import deque  # deque(list) append(), appendleft(), pop(), popleft() - O(1)\nfrom collections import Counter as c  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations as comb\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\n# sys.setrecursionlimit(2*pow(10, 6))\n# sys.stdin = open(\"input.txt\", \"r\")\n# sys.stdout = open(\"output.txt\", \"w\")\nmod = pow(10, 9) + 7\nmod2 = 998244353\ndef data(): return sys.stdin.readline().strip()\n\n\ndef out(var): sys.stdout.write(var)\n\n\ndef l(): return list(map(int, data().split()))\n\n\ndef sl(): return list(map(str, data().split()))\n\n\ndef sp(): return map(int, data().split())\n\n\ndef ssp(): return map(str, data().split())\n\n\ndef l1d(n, val=0): return [val for i in range(n)]\n\n\ndef l2d(n, m, val=0): return [[val for i in range(n)] for j in range(m)]\n\n\nn = int(data())\narr = l()\ndp = [[0 for j in range(500)] for i in range(500)]\ndp2 = [0 for i in range(501)]\nfor i in range(n):\n    dp[i][i] = arr[i]\ni = n-2\nwhile ~i:\n    j = i+1\n    while j < n:\n        dp[i][j] = -1\n        for k in range(i, j):\n            if (~dp[i][k] and dp[i][k]) == dp[k+1][j]:\n                dp[i][j] = dp[i][k]+1\n        j += 1\n    i -= 1\nfor i in range(1, n+1):\n    dp2[i] = pow(10, 9)\n    for j in range(i):\n        if ~dp[j][i-1]:\n            dp2[i] = min(dp2[i], dp2[j]+1)\nout(str(dp2[n]))\n",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "def check(x, y):\n    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])\n\nre = int(input())\na = [list(input()) for i in range(re)]\nb = [list(input()) for i in range(re)]\nfor i in range(4):\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = b[::-1]\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = [s[::-1] for s in b]\n    c = [['' for t in range(re)] for u in range(re)]\n    for t in range(re):\n        for u in range(re):\n            c[t][u] = b[u][re - t - 1]\n    b = c[:]\n    if check(a, b):\n        print('Yes')\n        exit(0)\nprint('No')",
    "complexity": "quadratic",
    "problem": "0958_A1",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n = int(input())\na = iter(map(int, input().split()))\nprev_type = 3\nprev_res = 2\ncurr_a = next(a)\nres = []\nfor _ in range(1):\n\tfor next_a in a:\n\t\tif next_a > curr_a:\n\t\t\tif prev_type == 1 or prev_res == 1:\n\t\t\t\tprev_res += 1\n\t\t\t\tif prev_res == 5:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tprev_res = 1\n\t\t\tprev_type = 1\n\t\telif next_a < curr_a:\n\t\t\tif prev_type == 2 or prev_res == 5:\n\t\t\t\tprev_res -= 1\n\t\t\t\tif prev_res == 1:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tprev_res = 5\n\t\t\tprev_type = 2\n\t\telse:\n\t\t\tif prev_type == 1:\n\t\t\t\tprev_res += 1\n\t\t\telif prev_type == 2:\n\t\t\t\tprev_res -= 1\n\t\t\telif prev_res != 2:\n\t\t\t\tprev_res = 2\n\t\t\telse:\n\t\t\t\tprev_res = 3\n\t\t\tprev_type = 3\n\t\tres.append(prev_res)\n\t\tcurr_a = next_a\n\telse:\n\t\tif prev_type == 1:\n\t\t\tres.append(prev_res + 1)\n\t\telif prev_type == 2:\n\t\t\tres.append(prev_res - 1)\n\t\telif prev_res != 1:\n\t\t\tres.append(1)\n\t\telse:\n\t\t\tres.append(2)\n\t\tprint(*res)\n\t\tbreak\nelse:\n\tprint('-1')\n",
    "complexity": "linear",
    "problem": "1032_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,dp"
}
{
    "src": "n, m = map(int, input().split())\na = list(map(int, input().split()))\nh = max(a)\na.sort()\na.reverse()\na.append(0)\nans = sum(a)\nfor i in range(n):\n    if a[i + 1] >= a[i]:\n        a[i + 1] = a[i] - 1\n    ans -= max(a[i] - a[i + 1], 1)\nprint(ans)",
    "complexity": "nlogn",
    "problem": "1061_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "import os\nimport sys\nfrom math import *\nfrom collections import *\n\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\n\n\ndef vsInput():\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA = \"abcdefghijklmnopqrstuvwxyz/\"\nM = 1000000007\nEPS = 1e-6\n\n\ndef Ceil(a, b):\n    return a // b + int(a % b > 0)\n\n\ndef value():\n    return tuple(map(int, input().split()))\n\n\ndef array():\n    return [int(i) for i in input().split()]\n\n\ndef Int():\n    return int(input())\n\n\ndef Str():\n    return input()\n\n\ndef arrayS():\n    return [i for i in input().split()]\n\n\n# -------------------------code---------------------------#\n\nn = int(input())\ns = input()\nans = 0\ncnt = 0\nfor x in s:\n    if x == \"x\":\n        cnt += 1\n        if cnt >= 3:\n            ans += 1\n    else:\n        cnt = 0\nprint(ans)\n",
    "complexity": "linear",
    "problem": "0978_B",
    "from": "CODEFORCES",
    "tags": "greedy,strings"
}
{
    "src": "from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom math import inf\n\n\ndef solve():\n    n, m = map(int, input().split())\n    cnt = defaultdict(int)\n    res = []\n    for i in range(n):\n        A = list(map(int, list(input())))\n        res.append(A)\n        for j in range(m):\n            if A[j]:\n                cnt[j] += 1\n    valid = False\n    for r in res:\n        j = [i for i in range(m) if r[i]]\n        if all(cnt[i] > 1 for i in j):\n            valid = True\n            break\n    if valid:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = 1\n# t = int(input())\nwhile t:\n    t -= 1\n    solve()\n\n",
    "complexity": "quadratic",
    "problem": "0985_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "M = 1000000007\nx, k  = map(int,input().split())\nif x==0:\n    print(0)\nelse:\n    print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)    \n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "import sys\n\ndef dp(ri, gi, bi):\n    if ri>r or gi>g or bi>b:\n        return 0\n\n    if not list_memo[ri][gi][bi]==-1:\n        return list_memo[ri][gi][bi]\n    \n    list_memo[ri][gi][bi] = max(dp(ri+1, gi+1, bi)+r_c[ri]*g_c[gi], dp(ri+1, gi, bi+1)+r_c[ri]*b_c[bi], dp(ri, gi+1, bi+1)+g_c[gi]*b_c[bi])\n    return list_memo[ri][gi][bi]\n\n\nr, g, b = map(int, sys.stdin.readline().split())\n\nr_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)\ng_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)\nb_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)\n\n\nlist_memo = [[[-1]*(b+1) for _ in range(g+1)] for _ in range(r+1)]\n\nprint(dp(0, 0, 0))",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\nb = sorted(a,reverse=True)\ntotal = sum(a)\ngain = 0\nnum = 0\nfor x in range(len(b)):\n    gain += b[x]\n    num += 1\n    if gain>total/2:\n        break\nprint(num)",
    "complexity": "nlogn",
    "problem": "0160_A",
    "from": "CODEFORCES",
    "tags": "greedy,sortings"
}
{
    "src": "# from typing import List, Set, Dict, Tuple, Text, Optional\nfrom collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__  # type: ignore\n\n#########\n# INPUT #\n#########\n\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n    # type: () -> str\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\n##########\n# OUTPUT #\n##########\n\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n    # type: (str) -> None\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n    # type: (str) -> None\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\n###########\n# LIBRARY #\n###########\n\n\ndef bootstrap(f, stack=[]):\n  # Deep Recursion helper.\n  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst\n  # Usage:\n\n  # @bootstrap\n  # def recur(n):\n  #   if n == 0:\n  #     yield 1\n  #   yield (yield recur(n-1)) * n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\n\n'''\narrayInit([3, 4, 5], 0):\nInitialize 3-dim array with [3][4][5] with 0 as its initial value\n\nTested with:\nhttps://codeforces.com/contest/625/problem/B\n'''\n\n\nclass MDArray(object):\n  # Faster implementation of md array, using a single array and a lot of math.\n  '''\n  >>> x = MDArray([1, 2, 5], 5)\n  >>> x.get([0, 0, 0])\n  5\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.set([0, 1, 2], 3)\n  3\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.set([0, 1, 3], 1)\n  1\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.get([0, 1, 3])\n  1\n  '''\n\n  def __init__(self, dimensions, initial_value=0):\n    # type: (Iterable[int], Any) -> None\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n    # type: (Iterable[int]) -> Any\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n    # type: (Iterable[int], Any) -> Any\n    self.arr[self._index(indexes)] = value\n    return value\n\n\n#########\n# LOGIC #\n#########\n\ndef encode(row, col, n, m):\n  return row * m + col\n\n\ndef main(inp, out):\n  # type: (Input, Output) -> any\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = [-1] * (n*m*(k/2+1))\n\n  @bootstrap\n  def solve(node, remain):\n    if remain == 0:\n      yield 0\n\n    key = (node + remain * n * m)\n    mem = dp[key]\n    if mem != -1:\n      yield mem\n\n    result = []\n    for x in adj[node]:\n      result.append((yield solve(x[0], remain-1)) + x[1])\n    ans = min(result)\n    dp[key] = ans\n    yield ans\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(solve(node, k/2) * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\n\n###############\n# BOILERPLATE #\n###############\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "\"\"\"\n    Second Order Statistics\n\"\"\"\nn = int(input())\nsequence = [int(x) for x in input().split()]\nfirstOrderStatistics = min(sequence)\nif sequence.count(firstOrderStatistics) == len(sequence):\n    print(\"NO\")\nelse:\n    sequence = sorted(sequence)\n    secondOrderStatistics = sequence[0]\n    for i in sequence:\n        if(i > secondOrderStatistics):\n            secondOrderStatistics = i\n            break\n    print(secondOrderStatistics)",
    "complexity": "nlogn",
    "problem": "0022_A",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "from sys import stdin, setrecursionlimit, stdout\n#setrecursionlimit(1000000) #use \"python\" instead of \"pypy\" to avoid MLE\nfrom collections import deque\nfrom math import sqrt, floor, ceil, log, log2, log10, pi, gcd, sin, cos, asin\nfrom heapq import heapify, heappop, heappush, heapreplace, heappushpop\nfrom bisect import bisect_right, bisect_left\ndef ii(): return int(stdin.readline())\ndef fi(): return float(stdin.readline())\ndef mi(): return map(int, stdin.readline().split())\ndef fmi(): return map(float, stdin.readline().split())\ndef li(): return list(mi())\ndef si(): return stdin.readline().rstrip()\ndef lsi(): return list(si())\nmod=1000000007\nres=['NO', 'YES']\n\n\n#######################################################################################\n###########################    M Y     F U N C T I O N S    ###########################\n#######################################################################################\n\n\n\n\n#######################################################################################\n###########################    M A I N     P R O G R A M    ###########################\n#######################################################################################\n\naa=[9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, 9999999999]\na=[9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889]\n\ntest=1\ntest_case=1\nwhile test<=test_case:\n    test+=1\n\n\n\n    n=ii()\n    if n in a:\n        n=9\n    if n<10:\n        print(n)\n        exit()\n    x=1\n    while a[x]<n:\n        x+=1\n    v=n-a[x-1]\n    z=v//(x+1)\n    z+=aa[x-1]\n    v%=x+1\n    #print(v, x, z)\n    if not v:\n        p=z%10\n    else:\n        z+=1\n        p=int(str(z)[v-1])\n    print(p)",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n\n\nn = int(input())\na = list(map(int,input().split()))\n\n\n#[i,j)\ndp = [[1000]*(n+1) for i in range(n+1)]\nval = [[0]*(n+1) for i in range(n+1)]\n\nfor i in range(n):\n    dp[i][i+1] = 1\n    val[i][i+1] = a[i]\n\n\nfor p in range(2,n+1):\n    for i in range(n-p+1):\n        j = i+p\n        for k in range(i+1,j):\n            if dp[i][k] == dp[k][j] == 1 and val[i][k] == val[k][j]:\n                dp[i][j] = 1\n                val[i][j] = val[i][k] + 1\n            else:\n                dp[i][j] = min(dp[i][j] , dp[i][k]+dp[k][j])\nprint(dp[0][n])\n\n",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n, m, k, l = map(int, input().split())\nif m > n:\n    print(-1)\nelif l + k > n:\n    print(-1)\nelse:\n    s = (l + k) // m + bool((l + k) % m)\n    if s * m > n:\n        print(-1)\n    else:\n        print(s)\n",
    "complexity": "constant",
    "problem": "1068_A",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "n = int(input())\ns = list(str(input()))\nt = list(str(input()))\n \nfrom collections import Counter\ncs = Counter(s)\nct = Counter(t)\nif cs != ct:\n    print(-1)\n    exit()\n \nxs = [[] for _ in range(26)]\nxt = [[] for _ in range(26)]\nfor i in range(n):\n    j = ord(s[i])-ord('a')\n    xs[j].append(i)\n \nfor i in range(n):\n    j = ord(t[i])-ord('a')\n    xt[j].append(i)\n \nx = [-1]*n\nfor i in range(26):\n    for j, k in zip(xs[i], xt[i]):\n        x[j] = k\n \nans = []\nfor i in range(n):\n    for j in reversed(range(i+1, n)):\n        if x[j-1] > x[j]:\n            x[j-1], x[j] = x[j], x[j-1]\n            ans.append(j)\nprint(len(ans))\nprint(*ans)",
    "complexity": "quadratic",
    "problem": "1015_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "from copy import deepcopy\ndef sol(n,m,k,aa,bb):\n    if k&1:\n        return [[-1] * m] * n\n    ans = [[float('inf')]*(m+2) for _ in range(n+2)]\n    k >>= 1\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            ans[i][j] = min(aa[i][j], aa[i][j-1], bb[i][j], bb[i-1][j])\n    for _ in range(k-1):\n        oans = deepcopy(ans)\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                ans[i][j] = min(\n                    aa[i][j]+oans[i][j+1],\n                    aa[i][j-1]+oans[i][j-1],\n                    bb[i][j]+oans[i+1][j],\n                    bb[i-1][j]+oans[i-1][j])\n\n    ans = ans[1:-1]\n    ans = [x[1:-1] for x in ans]\n    ans = [[2*x for x in a] for a in ans]\n    return ans\n\nn,m,k = map(int, input().split())\naa = [list(map(int, input().split())) for _ in range(n)]\ninf = float('inf')\nbb = [list(map(int, input().split())) for _ in range(n-1)]\naa = [[inf, *x, inf] for x in aa]\nbb = [[inf, *x, inf] for x in bb]\npad = [inf] * (m+1)\naa = [pad, *aa, pad]\npad = [inf] * (m+2)\nbb = [pad, *bb, pad]\nans = sol(n,m,k,aa,bb)\nprint('\\n'.join(' '.join(map(str, a)) for a in ans))\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "n = int(input())\na = [int(_) & 1 for _ in input().split()]\nv = [a[0]]\nfor i in range(1, n):\n    if v and v[-1] == a[i]:\n        v.pop()\n    else:\n        v.append(a[i])\nprint(\"NO\" if len(v) > 1 else \"YES\")\n",
    "complexity": "linear",
    "problem": "1092_D1",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "n = int(input())\nlimit_int = limit = decimal = 9\ncount = 0\nwhile True:\n    count += 1\n    if n <= limit:\n        difference = limit - n\n        position = difference % count\n        difference = difference // count\n        difference = decimal - difference\n        print(''.join(list(reversed(str(difference))))[position])\n        break\n    else:\n        decimal = int(str(limit_int) * (count + 1))\n        limit += int(str(limit_int) + '0' * count) * (count + 1)\n",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "import sys\n\nn,a,b = map(int, sys.stdin.readline().strip().split(' '))\n\nans = []\ng = {i:set({}) for i in range(n)}\n\nif a > 1 and b > 1:\n\tprint(\"NO\")\nelif a == 1 and b == 1:\n\tif n == 1:\n\t\tprint(\"YES\")\n\t\tprint(\"0\")\n\telif n < 4:\n\t\tprint(\"NO\")\n\telse:\n\t\tfor i in range(n-1):\n\t\t\tg[i].add(i+1)\n\t\t\tg[i+1].add(i) \n\t\tfor i in range(n):\n\t\t\ttmp = []\n\t\t\tfor j in range(n):\n\t\t\t\tif i in g[j]:\n\t\t\t\t\ttmp.append('1')\n\t\t\t\telse:\n\t\t\t\t\ttmp.append('0')\n\t\t\tans.append(''.join(tmp))\n\t\tprint(\"YES\")\n\t\tprint('\\n'.join(ans))\nelse:\n\tswap = False\n\tif a == 1:\n\t\ta, b = b, a\n\t\tswap = True\n\tfor i in range(a-1,n-1):\n\t\tg[i].add(i+1)\n\t\tg[i+1].add(i) \n\tif swap:\n\t\tfor i in range(n):\n\t\t\ttmp = []\n\t\t\tfor j in range(n):\n\t\t\t\tif i == j:\n\t\t\t\t\ttmp.append('0')\n\t\t\t\telif i not in g[j]:\n\t\t\t\t\ttmp.append('1')\n\t\t\t\telse:\n\t\t\t\t\ttmp.append('0')\n\t\t\tans.append(''.join(tmp))\n\telse:\n\t\tfor i in range(n):\n\t\t\ttmp = []\n\t\t\tfor j in range(n):\n\t\t\t\tif i in g[j]:\n\t\t\t\t\ttmp.append('1')\n\t\t\t\telse:\n\t\t\t\t\ttmp.append('0')\n\t\t\tans.append(''.join(tmp))\n\tprint(\"YES\")\n\tprint('\\n'.join(ans))",
    "complexity": "quadratic",
    "problem": "0990_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,graphs,implementation"
}
{
    "src": "n,m=map(int,input().split())\na=[int(input(),2)for _ in range(n)]\n \ns=t=0\nfor x in a:\n    t|=s&x\n    s|=x\nprint(('YES','NO')[all(x&s&~t for x in a)])",
    "complexity": "quadratic",
    "problem": "0985_B",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nif n <= 4:\n    print(\"YES\")\n    exit()\n\nA = [None]*n\n\nfor i in range(n):\n    A[i] = list(map(int,input().split()))\n\ndef is_colinear(a1,a2,a3):\n    if a1 == a2 or a2 == a3 or a1 == a3:\n        return True\n\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = a3\n\n    if x1 == x2 or x1 == x3 or x2 == x3:\n        return x1 == x2 == x3\n    if y1 == y2 or y1 == y3 or y2 == y3:\n        return y1 == y2 == y3\n    return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)\n\nX,Y,Z = A[0],A[1],A[2]\n\ndef good(X,Y):\n    # are X,Y on the same line?\n    bad = []\n    for i in range(n):\n        if not is_colinear(X,Y,A[i]):\n            bad.append(A[i])\n\n    if len(bad) <= 2:\n        return True\n\n    U,V = bad[0],bad[1]\n    for i in range(len(bad)):\n        if not is_colinear(U,V,bad[i]):\n            return False\n    return True\n\nif good(X,Y) or good(Y,Z) or good(X,Z):\n    print(\"YES\")\n    exit()\n\nprint(\"NO\")\nexit()\n",
    "complexity": "nlogn",
    "problem": "0961_D",
    "from": "CODEFORCES",
    "tags": "geometry"
}
{
    "src": "n, k = list(map(int, input().split()))\n\nteams = []\nfor _ in range(n):\n    teams.append(list(map(int, input().split())))\n\nteams.sort(key=lambda x: x[0]*100 - x[1], reverse=True)\n\ncount = 0\n\nkth = teams[k-1][0]*100 + teams[k-1][1]\nfor t in teams:\n    if t[0]*100 + t[1] == kth:\n        count += 1\nprint(count)\n",
    "complexity": "nlogn",
    "problem": "0166_A",
    "from": "CODEFORCES",
    "tags": "binary search,implementation,sortings"
}
{
    "src": "#Winners never quit, quiters never win............................................................................\nfrom collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\n\ndef factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()    \ndef decimalToBinary(n): \n    return bin(n).replace(\"0b\", \"\")\n\ndef isPrime(n) : \n\tif (n <= 1) : \n\t\treturn False\n\tif (n <= 3) : \n\t\treturn True\n\n\t\n\tif (n % 2 == 0 or n % 3 == 0) : \n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) : \n\t\tif (n % i == 0 or n % (i + 2) == 0) : \n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number / 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number / i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x): \n    return (math.log10(x) / \n            math.log10(2)); \n\ndef isPowerOfTwo(n): \n    return (math.ceil(Log2(n)) == math.floor(Log2(n))); \n\n   \n#here we go......................\n#Winners never quit, Quitters never win\nn,m=map(int,input().split())\nc=list(map(int,input().split()))\nkk=get_frequency(c)\nif len(set(c))==n:\n    print(min(kk.values()))\nelse:\n    print(0)\n\n\n\n    \n",
    "complexity": "quadratic",
    "problem": "0961_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "import sys\n\ndef ask(x):\n    print('? %d'%x)\n    sys.stdout.flush()\n    x=int(input())\n    return x\n\nn=int(input())\nt=n//2\nif t&1:\n    print('! -1')\n    sys.stdout.flush()\n    sys.exit()\nl=1\nr=n\nwhile l<r:\n    mid=(l+r)>>1\n    if ask(mid)>=ask((mid+t-1)%n+1):\n        r=mid\n    else:\n        l=mid+1\nprint('! %d'%l)\nsys.stdout.flush()\n",
    "complexity": "logn",
    "problem": "1019_B",
    "from": "CODEFORCES",
    "tags": "binary search,interactive"
}
{
    "src": "S = input()\n\nans = 0\nmet = set()\n\nfor i in range(len(S)):\n    for j in range(i, -1, -1):\n        if S[j:i+1] in met:\n            ans = max(ans, i - j + 1)\n        else:\n            met.add(S[j:i+1])\n            \nprint(ans)",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "from sys import exit\nx, k = map(int, input().split())\nif x == 0:\n    print(0)\n    exit(0)\nx = 2 * x - 1\nmod = 10**9 + 7\n\ndef pot(r, k):\n    if k == 0: return 1\n    if k % 2 == 1:\n        return r * pot(r, k - 1) % mod\n    y = pot(r, k // 2)\n    return y * y % mod\n\nprint((pot(2, k) * x + 1) % mod)\n",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "def main():\n  n, k = map(int, input().split())\n  v = list(map(int, input().split()))\n \n  d = {}\n  ans = 0\n \n  for x in v:\n    num_d, mod_k = len(str(x)), x % k\n    d.setdefault(num_d, {}).setdefault(mod_k, []).append(x)\n \n  for x in v:\n    num_d, mod_k = len(str(x)), x % k\n    for add, mods in d.items():\n      val_mod = (mod_k * 10 ** add) % k\n      need_mod = (k - val_mod) % k\n      ans += len(mods.get(need_mod, []))\n      if need_mod == mod_k and add == num_d:\n        ans -= 1\n \n  print(ans)\n\n\nif __name__ == \"__main__\":\n  main()\n",
    "complexity": "nlogn",
    "problem": "1029_D",
    "from": "CODEFORCES",
    "tags": "implementation,math"
}
{
    "src": "import sys\ninput = sys.stdin.readline\nmaxn = int(1e5 + 10)\nST = [0] * (4 * maxn)\ndef update(id, l, r, val):\n    if l == r == val:\n        ST[id] = 1\n        return\n    if l > val or r < val:\n        return\n    mid = int((l + r) / 2)\n    update(id * 2, l, mid, val)\n    update(id * 2 + 1, mid + 1, r, val)\n    ST[id] = ST[id * 2] + ST[id * 2 + 1]\n    return\ndef get(id, l, r, x, y):\n    if l > y or r < x:\n        return 0\n    if x <= l and r <= y:\n        return ST[id]\n    mid = int((l + r) / 2)\n    return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y)\nn, res = int(input()), 0\nfor x in list(map(int, input().split())):\n    res ^= get(1, 1, n, x + 1, n) % 2\n    update(1, 1, n, x)\nfor i in range (int(input())):\n    x, y = list(map(int, input().split()))\n    if int((y - x) * (y - x + 1) / 2) & 1:\n        res ^= 1\n    if res:\n        print(\"odd\")\n    else:\n        print(\"even\")",
    "complexity": "quadratic",
    "problem": "0911_D",
    "from": "CODEFORCES",
    "tags": "brute force,math"
}
{
    "src": "n = int(input())\nx, y = 1, 9\nn -= 1\nwhile n > x * y:\n    n -= x * y\n    x += 1\n    y *= 10\na = 10 ** (x - 1) + n // x\nprint(str(a)[n % x])",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n\n'''\n\n'''\n\nn = int(input())\na = list(map(int, input().split()))\nswaps = 0\nfor i in range(0, 2*n, 2):\n    if a[i] == a[i+1]:\n        continue\n    \n    c = a[i]\n    j = i + 2\n    while c != a[j]:\n        j += 1\n    \n    MIN = i+1\n    while j > MIN:\n        a[j], a[j-1] = a[j-1], a[j]\n        j -= 1\n        swaps += 1\n\nprint(swaps)\n",
    "complexity": "quadratic",
    "problem": "0995_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,math"
}
{
    "src": "t=int(input())\nfor ca in range(t):\n    asd=input().split()\n    n=int(asd[0])\n    k=int(asd[1])\n    if n>=40:\n        print(\"YES \"+str(n-1))\n    else:\n        ans=-1\n        for m in range(1,n+1):\n            asd=(4**m-1)//3\n            asd2=(2**m-1)**2\n            asd2*=(4**(n-m)-1)//3\n            asd+=asd2\n            if asd>=k and m*m<=k:\n                ans=n-m\n                break\n        if ans==-1:\n            print(\"NO\")\n        else:\n            print(\"YES \"+str(ans))\n",
    "complexity": "logn",
    "problem": "1080_D",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation,math"
}
{
    "src": "#winners never quit, quiters never win\nfrom collections import deque as de\nimport math\nfrom collections import Counter as cnt\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()    \n# A optimized school method based \n# Python3 program to check \n# if a number is prime \n\n\ndef isPrime(n) : \n\n\t# Corner cases \n\tif (n <= 1) : \n\t\treturn False\n\tif (n <= 3) : \n\t\treturn True\n\n\t# This is checked so that we can skip \n\t# middle five numbers in below loop \n\tif (n % 2 == 0 or n % 3 == 0) : \n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) : \n\t\tif (n % i == 0 or n % (i + 2) == 0) : \n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    # create an empty list and later I will\n    # run a for loop with range() function using the append() method to add elements to the list.\n    prime_factors = []\n\n    # First get the number of two's that divide number\n    # i.e the number of 2's that are in the factors\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number / 2\n\n    # After the above while loop, when number has been\n    # divided by all the 2's - so the number must be odd at this point\n    # Otherwise it would be perfectly divisible by 2 another time\n    # so now that its odd I can skip 2 ( i = i + 2) for each increment\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number / i\n\n\n    # Here is the crucial part.\n    # First quick refreshment on the two key mathematical conjectures of Prime factorization of any non-Prime number\n    # Which is - 1. If n is not a prime number AT-LEAST one Prime factor would be less than sqrt(n)\n    # And - 2. If n is not a prime number - There can be AT-MOST 1 prime factor of n greater than sqrt(n).\n    # Like 7 is a prime-factor for 14 which is greater than sqrt(14)\n    # But if the above loop DOES NOT go beyond square root of the initial n.\n    # Then how does that greater than sqrt(n) prime-factor\n    # will be captured in my prime factorization function.\n    # ANS to that is - in my first for-loop I am dividing n with the prime number if that prime is a factor of n.\n    # Meaning, after this first for-loop gets executed completely, the adjusted initial n should become\n    # either 1 or greater than 1\n    # And if n has NOT become 1 after the previous for-loop, that means that\n    # The remaining n is that prime factor which is greater that the square root of initial n.\n    # And that's why in the next part of my algorithm, I need to check whether n becomes 1 or not,\n    #This code is taken by rohan paul's github\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\n#here we go......................\n#winners never quit, quitters never win\nn,k=map(int,input().split())\na=list(map(int,input().split()))\nl=sorted(a, reverse=True)\ndic={}\ntotalprofit=0\nfor i in range(k):\n    totalprofit+=l[i]\n    if l[i] in dic:\n        dic[l[i]]+=1\n    else:\n        dic[l[i]]=1\nans=[]\ncount=0\nfor i in range(n):\n    if a[i] in dic:\n        count+=1\n        if dic[a[i]]==1:\n            del dic[a[i]]\n        else:\n            dic[a[i]]-=1\n        if not dic:\n            count-=1\n            ans.append(count+ n-i)\n            break\n        else:\n            ans.append(count)\n        count=0\n    else:\n        count+=1\nprint(totalprofit)\nprint(*ans) \n\n",
    "complexity": "nlogn",
    "problem": "1006_B",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "def gns():\n    return  list(map(int,input().split()))\nn=int(input())\nns=gns()\na='cslnb'\nb='sjfnb'\nns.sort()\nans=[]\nfor i in range(1,n):\n    if ns[i]==ns[i-1]:\n        ans.append(i)\nif len(ans)>=2 or sum(ns)==0:\n    print(a)\n    quit()\nif len(ans)==1:\n    i=ans[0]\n    if ns[i]==0 or ns[i]-1 in ns:\n        print(a)\n        quit()\n    r=sum(ns)-n*(n-1)//2\n    if r%2==0:\n        print(a)\n        quit()\n    else:\n        print(b)\n        quit()\nelse:\n    r=sum(ns)-n*(n-1)//2\n    if r%2==0:\n        print(a)\n        quit()\n    else:\n        print(b)\n\n",
    "complexity": "nlogn",
    "problem": "1191_D",
    "from": "CODEFORCES",
    "tags": "games"
}
{
    "src": "n = int(input())\nans = []\nmult = 1\nwhile n > 3:\n    ans += [mult]*(n-n//2)\n    n //= 2\n    mult *= 2\nif n == 3:\n    ans += [mult, mult, mult*3]\nelif n == 2:\n    ans += [mult, mult*2]\nelse:\n    ans += [mult]\nprint(*ans)",
    "complexity": "logn",
    "problem": "1059_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,math"
}
{
    "src": "a=[int(x) for x in input().split()]\nn=a[0]^a[1]\nx=bin(n)[2:]\n#print(x)\nf=0\nfor i in range(len(x)):\n    if x[i]=='1':\n        f=1\n        break\nl=len(x)-i\nsum=0\nfor i in range(l):\n   sum+=2**i\nif f==0:\n    sum=0\nprint(sum)",
    "complexity": "logn",
    "problem": "0276_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,greedy,implementation,math"
}
{
    "src": "n = int(input())\na = list(map(int,input().split()))\ncost = list(map(int,input().split()))\nans  = float(\"inf\")\nfor i in range(n):\n    m,r = float(\"inf\"),float(\"inf\")\n    for j in range(i):\n        if a[j]<a[i]:\n            m = min(m,cost[j])\n    for k in range(i+1,n):\n        if a[k]>a[i]:\n            r = min(r,cost[k])\n    ans = min(ans,cost[i]+m+r)\nprint(ans if ans!=float(\"inf\") else -1)\n",
    "complexity": "quadratic",
    "problem": "0987_C",
    "from": "CODEFORCES",
    "tags": "brute force,dp,implementation"
}
{
    "src": "import sys\n\nMOD = 10**9 + 7\n\nx,k = list(map(int,sys.stdin.readline().strip().split(' ')))\n\na = x*pow(2,k+1,MOD) % MOD \nb = (a - pow(2,k,MOD) + 1) % MOD\nprint(b if x != 0 else 0)",
    "complexity": "logn",
    "problem": "0992_C",
    "from": "CODEFORCES",
    "tags": "math"
}
{
    "src": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Feb 15 19:45:38 2019\n\n@author: avina\n\"\"\"\n\nn = int(input())\n\nl = []\nfor _ in range(n):\n    k,m = map(int, input().strip().split())\n    l.append((k,m))\n\nl.sort(key=lambda x:x[0]+x[1])\n\nlast = 0\nans = 1\n\nfor i in range(1,n):\n   if  abs(l[i][0] - l[last][0]) >= l[i][1] + l[last][1] :\n       last = i\n       ans = ans + 1\n       \nprint(ans)\n\n#l[i][0] - l[i][1] >= l[last][0] - l[last][1] and",
    "complexity": "nlogn",
    "problem": "0528_B",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "def subsets(S):\n    sets = []\n    len_S = len(S)\n    for i in range(1 << len_S):\n        subset = [S[bit] for bit in range(len_S) if i & (1 << bit)]\n        sets.append(subset)\n    return sets\n    \nn, l, r, x = list(map(int, input().split()))\nproblems = list(map(int, input().split()))\nres = 0\nfor m in subsets(problems):\n    if l <= sum(m) <= r and (max(m) - min(m)) >= x:\n        res += 1\nprint(res)",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn,m = map(int,input().split())\n\nA = [None]*n\nlo,hi = 1<<32,-1<<32\nfor i in range(n):\n    A[i] = list(map(int,input().split()))\n    lo = min(min(A[i]), lo)\n    hi = max(max(A[i]), hi)\n\nbest = -1\nans = [-1,-1]\n\ndef possible(x):\n    global best, ans\n    # is the answer at least x?\n    M = [-1]*(1<<m)\n\n    for i in range(n):\n        mask = 0\n        for j in range(m):\n            if A[i][j] >= x:\n                mask += (1<<j)\n        M[mask] = i\n\n    for m0 in range(1<<m):\n        if M[m0] == -1:\n            continue\n\n        for m1 in range(1<<m):\n            if M[m1] == -1:\n                continue\n\n            if m0 | m1 == (1<<m) - 1:\n                if best < x:\n                    best = x\n                    ans = [M[m0]+1, M[m1]+1]\n\n                return True\n    return False\n\npossible(hi)\npossible(lo)\n\nwhile lo+1 < hi:\n    mid = (lo+hi)//2\n    if possible(mid):\n        lo = mid\n    else:\n        hi = mid\n\nprint(*ans)\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "import math\ndef C1():\n    n, r = map(int, input().split())\n    x_cord = [int(x) for x in input().split()]\n\n    y_cord = []\n    # y cordinate of contacted Disk\n    contactedDisk = 0\n    for i, x in enumerate(x_cord):\n        if len(y_cord) == 0:\n            y_cord.append(r)\n        else:\n            y_cord.append(r)\n            for j in range(i):\n                diff = abs(x_cord[i] - x_cord[j])\n                if diff <= 2 * r:\n                    y_cord[i] = max(y_cord[i], math.sqrt(4*r*r - diff ** 2) + y_cord[j])\n\n\n    for i in y_cord:\n        print(i, end= \" \")\n\n\nif __name__=='__main__':\n    C1()\n\t   \t\t\t\t    \t\t\t\t\t\t\t\t \t\t  \t  \t \t",
    "complexity": "quadratic",
    "problem": "0908_C",
    "from": "CODEFORCES",
    "tags": "brute force,geometry,implementation,math"
}
{
    "src": "n = int(input())-1\nx = 1\ny = 9\nwhile n > x * y:\n    n -= x * y\n    y *= 10\n    x += 1\na = 10 ** (x - 1)\na += n // x\nprint(str(a)[n % x])",
    "complexity": "logn",
    "problem": "1177_B",
    "from": "CODEFORCES",
    "tags": "binary search,divide and conquer,implementation"
}
{
    "src": "import os, sys\nfrom io import BytesIO, IOBase\nfrom copy import deepcopy\n\n\ndef main():\n    n = rint()\n    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []\n    for i in range(4):\n        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])\n    print(['No', 'Yes'][a2.mat in ans])\n\n\nclass Matrix:\n    def __init__(self, r, c, mat=None, id=None):\n        self.r, self.c = r, c\n\n        if mat != None:\n            self.mat = deepcopy(mat)\n        else:\n            self.mat = [[0 for i in range(c)] for j in range(r)]\n\n    def rotate(self):\n        mat0 = Matrix(self.c, self.r)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]\n\n        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r\n        return self.mat\n\n    def flipv(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def fliph(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n\n\n# FASTIO REGION\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [list(rstr()) for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\nif __name__ == '__main__':\n    main()\n",
    "complexity": "quadratic",
    "problem": "0958_A1",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "\n# Problem: B. Bus of Characters\n# Contest: Codeforces - Codeforces Round #484 (Div. 2)\n# URL: https://codeforces.com/contest/982/problem/B\n# Memory Limit: 256 MB\n# Time Limit: 2000 ms\n# Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\nfrom sys import stdin\ndef get_ints(): return list(map(int, stdin.readline().strip().split()))\n\nn = int(input())\nar = get_ints()\n\nbus = sorted([ (ar[i], i+1) for i in range(n) ])\npa = [int(x) for x in input()]\nseq = []\n# print(bus)\ntail = 0\nfor p in pa:\n\tif p == 0:\n\t\tprint(bus[tail][1], end=\" \")\n\t\tseq.append(tail)\n\t\ttail+=1\n\telse:\n\t\tv = seq.pop()\n\t\tprint(bus[v][1],end=\" \")\n",
    "complexity": "nlogn",
    "problem": "0982_B",
    "from": "CODEFORCES",
    "tags": "data structures,greedy,implementation"
}
{
    "src": "s = input()\nn = len(s)\nm = n - 1;\nwhile m > 0:\n    find = False\n    for i in range(0, n - m):\n        for j in range(i + 1, n - m + 1):\n            match = True\n            for k in range(0, m):\n                if s[i+k] != s[j+k]:\n                    match = False\n                    break\n            if match:\n                find = True\n                break\n        if find:\n            break\n    if find:\n        break\n    m -= 1\nprint(m)",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "n, a, b = [int(i) for i in input().split()]\nlst = sorted([int(i) for i in input().split()])\nprint(lst[b]-lst[b-1])\n",
    "complexity": "nlogn",
    "problem": "0169_A",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "\ndef STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nimport string\nimport sys\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter , defaultdict\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n#visited = [[False for i in range(m)] for j in range(n)]\n#sys.stdin = open(r'input.txt' , 'r')\n#sys.stdout = open(r'output.txt' , 'w')\n#for tt in range(INT()):\n\n\n#CODE\n\n\nn = INT()\nl  = []\nd = {}\nsm = 0\n\nfor i in range(n):\n    indx , y  = MAP()\n    #l.append([indx , y])\n    d[indx] = y\n    sm += y\n\nm = INT()\nfor i in range(m):\n    indx , y = MAP()\n    if indx in d :\n        sm -= d[indx]\n        sm += max(y , d[indx])\n    else:\n        sm += y\n\nprint(sm)\n\n\n\n",
    "complexity": "nlogn",
    "problem": "0981_B",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\nfrom math import factorial\nfrom collections import Counter, defaultdict\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\n\n# ------------------------------\n\ndef main():\n    n, k = RLL()\n    dp = [[0]*4 for _ in range(k+2)]\n    dp[1][0] = 1\n    dp[1][3] = 1\n    dp[2][1] = 1\n    dp[2][2] = 1\n\n    for i in range(2, n+1):\n        new = [[0]*4 for _ in range(k+2)]\n        for j in range(1, k+2):\n            for l in range(4):\n                new[j][l] += dp[j][l]\n                if l==0 or l==3:\n                    new[j][l]+=dp[j-1][l^3]\n                    new[j][l]+=(dp[j][1]+dp[j][2])\n                elif l==1 or l==2:\n                    new[j][l]+=(dp[j-1][0]+dp[j-1][3])\n                    if j-2>=0: new[j][l]+=dp[j-2][l^3]\n                new[j][l] = new[j][l]%mod\n        dp = new\n    print(sum(dp[k])%mod)\n\nif __name__ == \"__main__\":\n    main()\n\n",
    "complexity": "np",
    "problem": "1051_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "n, a, b = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nend_b = arr[b-1]\nstart_a = arr[b]\nif end_b < start_a:\n    print(start_a - end_b)\nelse:\n    print(0)\n",
    "complexity": "nlogn",
    "problem": "0169_A",
    "from": "CODEFORCES",
    "tags": "sortings"
}
{
    "src": "import sys\n\ninput = sys.stdin.readline\n\nr, g, b = map(int, input().split())\nsticks = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)]\ndp, ans = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 # dp[i][j][k] is i largest red, j largest green, k largest blue\nfor i in range(r + 1):\n    for j in range(g + 1):\n        for k in range(b + 1):\n            if i < r and j < g:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])\n            if i < r and k < b:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])\n            if j < g and k < b:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)\n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "n, t = [int(item) for item in input().split(' ')]\ncont, ans = list(), 2\nfor i in range(n):\n    hCenter, hLen = [float(item) for item in input().split(' ')]\n    # subArr = [hCenter - hLen / 2, hCenter + hLen / 2]\n    # cont.append(subArr)\n    cont.append([hCenter - hLen / 2, hCenter + hLen / 2])\n\n#print(f'before=> {cont}')\ncont.sort(key=lambda item: item[0])\n#print(f'after=> {cont}')\nfor i in range(n - 1):\n    gap = cont[i+1][0] - cont[i][1]\n    if gap > t:\n        ans += 2\n    elif gap == t:\n        ans += 1\n\nprint(ans)\n",
    "complexity": "nlogn",
    "problem": "0015_A",
    "from": "CODEFORCES",
    "tags": "implementation,sortings"
}
{
    "src": "#from collections import defaultdict\n#DPL=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]\nri,gi,bi=map(int,input().split())\nrr=sorted(list(map(int,input().split())))\ngr=sorted(list(map(int,input().split())))\nbr=sorted(list(map(int,input().split())))\ndp=[[[-1]*(bi+1) for i in range(gi+1)] for j in range(ri+1)]\ndef area(r,g,b):\n\tif dp[r+1][g+1][b+1]!=-1:\n\t\treturn dp[r+1][g+1][b+1]\n\tans=0\n\tif r>=0 and g>=0:\n\t\tans=max(ans,rr[r]*gr[g]+area(r-1,g-1,b))\n\tif r>=0 and b>=0:\n\t\tans=max(ans,rr[r]*br[b]+area(r-1,g,b-1))\t\n\tif b>=0 and g>=0:\n\t\tans=max(ans,br[b]*gr[g]+area(r,g-1,b-1))\t\n\tdp[r+1][g+1][b+1]=ans\n\treturn ans\nprint(area(ri-1,gi-1,bi-1))",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "import sys\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nMAP=[list(input().strip()) for i in range(n)]\n\nT0=[[0]*(m+1) for i in range(n+1)]\nT1=[[0]*(m+1) for i in range(n+1)]\nY0=[[0]*(m+1) for i in range(n+1)]\nY1=[[0]*(m+1) for i in range(n+1)]\n\nfor i in range(n):\n    for j in range(m):\n        if MAP[i][j]==\"*\":\n            T0[i][j]=T0[i-1][j]+1\n            Y0[i][j]=Y0[i][j-1]+1\n\nfor i in range(n-1,-1,-1):\n    for j in range(m-1,-1,-1):\n        if MAP[i][j]==\"*\":\n            T1[i][j]=T1[i+1][j]+1\n            Y1[i][j]=Y1[i][j+1]+1\n\nANS=[[0]*m for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        score=min(T0[i][j],T1[i][j],Y0[i][j],Y1[i][j])\n        if score>=2:\n            ANS[i][j]=score\n\nT0=[[0]*(m+1) for i in range(n+1)]\nT1=[[0]*(m+1) for i in range(n+1)]\nY0=[[0]*(m+1) for i in range(n+1)]\nY1=[[0]*(m+1) for i in range(n+1)]\n\nfor i in range(n):\n    for j in range(m):\n        T0[i][j]=max(ANS[i][j],T0[i-1][j]-1)\n        Y0[i][j]=max(ANS[i][j],Y0[i][j-1]-1)\n\nfor i in range(n-1,-1,-1):\n    for j in range(m-1,-1,-1):\n        T1[i][j]=max(ANS[i][j],T1[i+1][j]-1)\n        Y1[i][j]=max(ANS[i][j],Y1[i][j+1]-1)\n\n\n\nSUF=[[\".\"]*m for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if T0[i][j] or T1[i][j] or Y0[i][j] or Y1[i][j]:\n            SUF[i][j]=\"*\"\n\nif SUF!=MAP:\n    print(-1)\nelse:\n    ANSLIST=[]\n    for i in range(n):\n        for j in range(m):\n            if ANS[i][j]!=0:\n                ANSLIST.append((i+1,j+1,ANS[i][j]-1))\n\n    print(len(ANSLIST))\n    for ans in ANSLIST:\n        print(*ans)\n",
    "complexity": "quadratic",
    "problem": "1015_E2",
    "from": "CODEFORCES",
    "tags": "binary search,dp,greedy"
}
{
    "src": "n,k=map(int,input().split())\n\nar=[-1 for i in range(256)]\nls=list(map(int,input().split()))\n\nfor e in ls:\n    if ar[e]==-1:\n        tmp=max(0,e-k+1)\n        for i in range(tmp,e+1):\n            if ar[i]!=-1 and ar[i]!=i:\n                tmp+=1\n                continue\n            else:\n                while i<=e:\n                    ar[i]=tmp\n                    i+=1\n    print(ar[e],end=\" \")\n",
    "complexity": "quadratic",
    "problem": "0980_C",
    "from": "CODEFORCES",
    "tags": "games,greedy"
}
{
    "src": "from decimal import *\nar = [list(map(float, input().split())) for i in range(int(input()))]\ndp = [[0 for i in range(1 << 18)] for j in range(18)]\nn, ans = len(ar), 0\ndp[0][(1 << n) - 1] = 1\nfor i in range((1 << n) - 1, 0, -1):\n    for j in range(n):\n        if i & (1 << j) == 0:\n            continue\n        for k in range(n):\n            if i & (1 << k) != 0 or j == k:\n                continue\n            dp[j][i] = max(dp[j][i], dp[k][i ^ (1 << k)] * ar[k][j] + dp[j][i ^ (1 << k)] * ar[j][k])\nfor i in range(n):\n    ans = max(ans, dp[i][1 << i])\nprint('{:.6f}'.format(ans))",
    "complexity": "np",
    "problem": "0678_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,math,probabilities"
}
{
    "src": "from itertools import chain\nfrom time import time\n\ndef main():\n\n    BITS = [1 << sh for sh in range(24)]\n    B2N = {v: u for u, v in enumerate(BITS)}\n\n    def getPt():\n        return tuple(map(int, input().split()))\n\n    def dist(ptA, ptB):\n        return sum(((u-v)**2 for u, v in zip(ptA, ptB)))\n\n    def getBits(val):\n        return tuple(filter(lambda x: x&val, BITS))\n\n    def chooseTwo(pool):\n        n = len(pool)\n        for i in range(n):\n            for j in range(i+1, n):\n                yield (pool[i], pool[j])\n\n    ori = getPt()\n    pts = []\n    N = int(input())\n\n    for _ in range(N):\n        pts.append(getPt())\n\n    vis = set([0])\n    mint = [0]+[1e8]*(1<<N) \n    pres = [None]*(1<<N) \n    allb = (1 << N)-1 \n    B2P = {BITS[u]: v for u, v in enumerate(pts)}\n    B2P[0] = ori\n    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}\n\n    getDP = lambda x: mint[x]\n    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \\\n                                + alld[p[0]][0] \\\n                                + alld[p[1]][0] \n\n    for stt in range(1<<N):\n        if stt not in vis:\n            continue\n\n        bits = getBits(~stt&allb)\n\n        sb = bits[0] if bits else None\n\n        for bit in bits:\n\n            newstt = stt | sb | bit\n            nd = newDist(stt, (sb, bit))\n            if getDP(newstt) > nd:\n                mint[newstt] = nd\n                pres[newstt] = sb | bit\n                vis.add(newstt)\n\n    print(mint[allb])\n    path = ['0']\n    stt = allb\n\n    while stt:\n\n        bits = getBits(pres[stt])\n        for bit in bits:\n            path.append(str(B2N[bit]+1))\n        path.append('0')\n\n        stt ^= pres[stt]\n\n    print(' '.join(path))\n\n\nimport sys\nst = time()\nmain()\nprint('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)",
    "complexity": "np",
    "problem": "0008_C",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\ncat=''.join\ncatn='\\n'.join\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n########################################################################\n\ns=rl()\nn=len(s)\nans=0\nfor i in range(n-1):\n  for j in range(i+1,n):\n    for k in range(n-j):\n      if s[i+k]!=s[j+k]:\n        break\n      ans=max(ans,1+k)\n\nprint(ans)\n",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "def countall(string, substring):\n    total = 0\n    for i in range(len(string)-len(substring)+1):\n        if string[i:i+len(substring)] == substring:\n            total += 1\n    return total\n\nn = input()\nallvalues = []\nfor i in range(len(n)):\n    for j in range(len(n)-1, i-1, -1):\n        if countall(n, n[i:j+1]) > 1:\n            allvalues.append(j-i+1)\n            break\n\ntry:\n    print(max(allvalues))\nexcept:\n    print(0)",
    "complexity": "cubic",
    "problem": "0023_A",
    "from": "CODEFORCES",
    "tags": "brute force,greedy"
}
{
    "src": "n = int(input())\nd = []\nfor i in range(n):\n    xx, ww = [int(i) for i in input().split()]\n    d.append([xx-ww, xx+ww])\nd.sort(key=lambda x:x[0])\nlast = -100000000000\nans = 0\nfor i in range(n):\n    if last <= d[i][0]:\n        last = d[i][1]\n        ans += 1\n    elif last > d[i][1]:\n        last = d[i][1]\nprint(ans)\n\n\n\n\n\n",
    "complexity": "nlogn",
    "problem": "0528_B",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "# import os\n\nn,m = map(int,input().split())\n\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nr = []\n\nfor i in a:\n    if i in b:\n        r.append(i)\nprint(' '.join(map(str, r)))\n\n\n",
    "complexity": "quadratic",
    "problem": "0994_A",
    "from": "CODEFORCES",
    "tags": "implementation"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\na = sorted(a, reverse=True)\ns1 = 0\ns2 = sum(a)\n\nfor i in range(len(a)):\n    s1 += a[i]\n    s2 -= a[i]\n    if s1 > s2:\n        break\n\nprint(i + 1)",
    "complexity": "nlogn",
    "problem": "0160_A",
    "from": "CODEFORCES",
    "tags": "greedy,sortings"
}
{
    "src": "N, MOD = map(int, input().split())\ndp = [[0]*(N+2) for i in range(N+2)]\ndp[0][0] = 1\nlimit = 1000\nfrac = [1]*limit\nfor i in range(2,limit):\n    frac[i] = i * frac[i-1]%MOD\nfraci = [None]*limit\nfraci[-1] = pow(frac[-1], MOD -2, MOD)\nfor i in range(-2, -limit-1, -1):\n    fraci[i] = fraci[i+1] * (limit + i + 1) % MOD\nbb = [1, 2]\nfor i in range(1000):\n    bb.append(bb[-1] *2 %MOD)\nfor ln in range(N+1):\n    for cnt in range(ln//2, ln+1):\n        for k in range(1, N-ln+1):\n            cmb = frac[cnt+k] * (fraci[cnt]*fraci[k]%MOD)%MOD\n            dp[ln+k+1][cnt+k] += dp[ln][cnt] * (bb[k-1] * cmb % MOD) %MOD\n            dp[ln+k+1][cnt+k] %= MOD\nR = 0\nfor x in dp[N+1][:N+1]:\n    R = (R+x)%MOD\nprint(R)\n",
    "complexity": "cubic",
    "problem": "1515_E",
    "from": "CODEFORCES",
    "tags": "combinatorics,dp,math"
}
{
    "src": "import math\nimport sys\nfrom collections import deque,defaultdict\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\ndef Extended_Euclid(n,m):\n    stack=[]\n    while m:\n        stack.append((n,m))\n        n,m=m,n%m\n    if n>=0:\n        x,y=1,0\n    else:\n        x,y=-1,0\n    for i in range(len(stack)-1,-1,-1):\n        n,m=stack[i]\n        x,y=y,x-(n//m)*y\n    return x,y\n\nclass MOD:\n    def __init__(self,p,e=1):\n        self.p=p\n        self.e=e\n        self.mod=self.p**self.e\n\n    def Pow(self,a,n):\n        a%=self.mod\n        if n>=0:\n            return pow(a,n,self.mod)\n        else:\n            assert math.gcd(a,self.mod)==1\n            x=Extended_Euclid(a,self.mod)[0]\n            return pow(x,-n,self.mod)\n\n    def Build_Fact(self,N):\n        assert N>=0\n        self.factorial=[1]\n        self.cnt=[0]*(N+1)\n        for i in range(1,N+1):\n            ii=i\n            self.cnt[i]=self.cnt[i-1]\n            while ii%self.p==0:\n                ii//=self.p\n                self.cnt[i]+=1\n            self.factorial.append((self.factorial[-1]*ii)%self.mod)\n        self.factorial_inv=[None]*(N+1)\n        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)\n        for i in range(N-1,-1,-1):\n            ii=i+1\n            while ii%self.p==0:\n                ii//=self.p\n            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod\n\n    def Fact(self,N):\n        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod\n\n    def Fact_Inv(self,N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inv[N]\n\n    def Comb(self,N,K,divisible_count=False):\n        if K<0 or K>N:\n            return 0\n        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod\n        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]\n        if divisible_count:\n            return retu,cnt\n        else:\n            retu*=pow(self.p,cnt,self.mod)\n            retu%=self.mod\n            return retu\n\ndef Bell_Numbers(N,mod,prime=False):\n    bell_numbers=[0]*(N+1)\n    bell_numbers[0]=1\n    MD=MOD(mod)\n    if prime:\n        MD.Build_Fact(min(mod-2,N-1))\n        for i in range(1,min(mod,N+1)):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n        for i in range(mod,N+1):\n            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod\n    else:\n        MD.Build_Fact(N-1)\n        for i in range(1,N+1):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n    return bell_numbers\n\nM,N=map(int,readline().split())\nS=[readline().rstrip() for i in range(N)]\ndct=defaultdict(int)\nfor i in range(M):\n    tpl=()\n    for j in range(N):\n        tpl+=(S[j][i],)\n    dct[tpl]+=1\nans=1\nmod=10**9+7\nbell=Bell_Numbers(M,mod)\nfor c in dct.values():\n    ans*=bell[c]\n    ans%=mod\nprint(ans)",
    "complexity": "quadratic",
    "problem": "0908_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,combinatorics,dp,math"
}
{
    "src": "n=int(input())\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\n\ncost=[(l[i]+r[i],i) for i in range(n)]\n\ncost.sort()\n\nCANDIES=[None]*n\nCANDIES[cost[0][1]]=n\n\ncandy=n\nfor i in range(1,n):\n    if cost[i][0]==cost[i-1][0]:\n        CANDIES[cost[i][1]]=candy\n    else:\n        candy-=1\n        CANDIES[cost[i][1]]=candy\n\n#print(CANDIES)\n\ncheck=1    \nfor i in range(n):\n    lc=0\n    rc=0\n    for j in range(i):\n        if CANDIES[j]>CANDIES[i]:\n            lc+=1\n    for j in range(i+1,n):\n        if CANDIES[j]>CANDIES[i]:\n            rc+=1\n\n    #print(i,lc,rc)\n\n    if lc!=l[i] or rc!=r[i]:\n        check=0\n\nif check==1:\n    print(\"YES\")\n    for c in CANDIES:\n        print(c,end=\" \")\n    #print(CANDIES)\nelse:\n    print(\"NO\")\n    #print(CANDIES)\n          \n    \n",
    "complexity": "quadratic",
    "problem": "1054_C",
    "from": "CODEFORCES",
    "tags": "constructive algorithms,implementation"
}
{
    "src": "a = input()\nb = input()\n\nif len(a) < len(b):\n    a = sorted(a)[::-1]\n    print(''.join(a))\n    exit(0)\n\n\ndef check(res, j, a):\n    added = False\n    tmp = \"\"\n    for i in a:\n        if i == j and not added:\n            added = True\n        else:\n            tmp += i\n    tmp = res + j + tmp[::-1]\n    return tmp <= b\n\n\n# len(a) == len(b)\nres = \"\"\nn = len(a)\na = sorted(list(a))[::-1]\nfor i in range(n):\n    for j in a:\n        if check(res, j, a):\n            res += j\n            a.remove(j)\n            break\nprint(res)\n",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "a=[i for i in input()]\nb=int(input())\na.sort(reverse=True)\nans = ''\nwhile len(a) > 0:\n    for i in range(len(a)):\n        tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:]))\n        if int(tmp) <= b:\n            ans += a[i]\n            a = a[:i] + a[i + 1:]\n            break\nprint(ans)\n",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "n, q = map(int, input().split())\nA = list(map(int, input().split()))\nK = list(map(int, input().split()))\nfrom itertools import accumulate\nC = [0]+A\nC = list(accumulate(C))\ntotal = 0\nans = [0]*q\nimport bisect\nfor i, k in enumerate(K):\n    total += k\n    j = bisect.bisect_right(C, total)\n    if j != n+1:\n        ans[i] = n-(j-1)\n    else:\n        ans[i] = n\n        total = 0\nprint(*ans, sep='\\n')\n",
    "complexity": "nlogn",
    "problem": "0975_C",
    "from": "CODEFORCES",
    "tags": "binary search"
}
{
    "src": "import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right \nfrom heapq import heappop,heappush,heapify, nlargest\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n\nn = inp()\na = inpl()\nres = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        if a[i] > a[j]:\n            res = 1-res\nfor _ in range(inp()):\n    l,r = inpl(); m = r-l+1\n    swap = m*(m-1)//2\n    if swap%2: res = 1-res\n    print('odd' if res else 'even')",
    "complexity": "quadratic",
    "problem": "0911_D",
    "from": "CODEFORCES",
    "tags": "brute force,math"
}
{
    "src": "import sys, copy\n \n \nn, m = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\nres = [0] * (max(arr) + 1)\nfor i in arr:\n    res[i] += 1\nans = 0\nfor d in range(1, m + 1):\n    temp = copy.deepcopy(res)\n    cnt = 0\n    for i in range(len(temp)):\n        while temp[i] >= d:\n            temp[i] -= d\n            cnt += 1\n    if cnt >= n:\n        ans = max(ans, d)\nprint(ans)",
    "complexity": "nlogn",
    "problem": "1011_B",
    "from": "CODEFORCES",
    "tags": "binary search,brute force,implementation"
}
{
    "src": "def nr(): return nrs()[0]\ndef nrs(): return [int(i) for i in input().split()]\n\nn = 10**7\nsquares = [i * i for i in range(1, 3162)]\n\np = list(range(n + 1))\nfor i in range(1, n + 1):\n\tif p[i] == i:\n\t\tfor sq in squares:\n\t\t\tif i * sq > n: break\n\t\t\tp[i * sq] = i\n\nfor _ in range(nr()):\n\tN, K = nrs()\n\tA = [p[a] for a in nrs()]\n\tdp = [N] * (K + 1)\n\tdp[0] = 1\n\tused = [{}] * (K + 1)\n\tfor a in A:\n\t\tfor j in range(K, -1, -1):\n\t\t\tif dp[j] == N: continue\n\t\t\tif a in used[j]:\n\t\t\t\tif j < K and dp[j + 1] > dp[j]:\n\t\t\t\t\tdp[j + 1] = dp[j]\n\t\t\t\t\tused[j + 1] = used[j]\n\t\t\t\tdp[j] += 1\n\t\t\t\tused[j] = {}\n\t\t\tused[j][a] = 1\n\tprint(min(dp))\n",
    "complexity": "cubic",
    "problem": "1497_E2",
    "from": "CODEFORCES",
    "tags": "data structures,dp,greedy,math,number theory,two pointers"
}
{
    "src": "n,m=map(int,input().split())\nlst=list(map(int,input().split()))\nmaxx=0\narr=[0]*(n+1)\nfor i in range(n):\n    summ=0\n    for j in range(i,n):\n        summ+=lst[j]\n        arr[j-i]=max(arr[j-i], summ/(j-i+1))\nprint(max(arr[m-1:]))",
    "complexity": "quadratic",
    "problem": "1003_C",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,math"
}
{
    "src": "def func(k, a):\n    if len(a) == 1:\n        return 1\n    if k == 1:\n        return len(a)\n    s = set(a)\n    for x in sorted(a):\n        if x in s and k * x in s:\n            s.remove(k * x)\n    return len(s)\n\n\ndef read_ints():\n    return [int(x) for x in input().split(' ')]\n\n\ndef main():\n    n, k = read_ints()\n    a = read_ints()\n    assert n == len(a)\n    print(func(k, a))\n\n\nif __name__ == '__main__':\n    main()\n",
    "complexity": "nlogn",
    "problem": "0274_A",
    "from": "CODEFORCES",
    "tags": "binary search,greedy,sortings"
}
{
    "src": "import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\nimport pprint\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n# sys.stdout = open('output.txt', 'w')\n\n\nn, m = ria()\nar = ria()\narc = []\nart = []\nres = []\nfor n, i in enumerate(ria()):\n    if i == 1:\n        art.append(ar[n])\n        res.append(0)\n    else:\n        arc.append(ar[n])\nnt = 0\nfor i in arc:\n    while nt != len(art) - 1 and abs(art[nt] - i) > abs(art[nt + 1] - i):\n        nt += 1\n    res[nt] += 1\n\nfor i in res:\n    print(i,end= ' ')",
    "complexity": "nlogn",
    "problem": "1075_B",
    "from": "CODEFORCES",
    "tags": "implementation,sortings"
}
{
    "src": "\nr,g,b=map(int,input().split())\ns1=[int(x) for x in input().split()]\ns2=[int(x) for x in input().split()]\ns3=[int(x) for x in input().split()]\ns1.sort()\ns2.sort()\ns3.sort()\ns1=s1[::-1]\ns2=s2[::-1]\ns3=s3[::-1]\ns1=[0]+s1\ns2=[0]+s2\ns3=[0]+s3\n\ndp=[]\nfor i in range(r+5):\n    H=[]\n    for j in range(g+5):\n        h=[]\n        for k in range(b+5):\n            h.append(0)\n        H.append(h)\n    dp.append(H)\n\nfor i in range(0,r+1):\n    for j in range(0,g+1):\n        for k in range(0,b+1):\n            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0\n            if(i-1>=0 and j-1>=0):\n                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])\n            if(i-1>=0 and k-1>=0):\n                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])\n            if(k-1>=0 and j-1>=0):\n                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])\n            if(i-1>=0):\n                t4 = dp[i-1][j][k]\n            if(j-1>=0):\n                t5 = dp[i][j-1][k]\n            if(k-1>=0):\n                t6 = dp[i][j][k-1]\n\n            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)\n\n\n\nprint(dp[r][g][b])\n\n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "import math\n\np2 =[1] * 64\n\nfor i in range(1, 64):\n    p2[i] = p2[i-1] * 2\n    \ndef find_level(x):\n    x0 = 1\n    \n    for i in range(max_level+1):\n        if (x-x0) % (x0*2) == 0:\n            return i\n        x0 *=2\n    \ndef move_U(number):\n    cur_lv    =  find_level(number)\n    \n    if cur_lv == max_level:\n        return number\n    \n    x0      =   p2[cur_lv]\n    seg     =   x0 * 2 \n    index   =  (number - x0) // seg\n    \n    return (x0*2) + (index // 2) * (seg * 2) \n    \ndef move_L(number):\n    cur_lv    =  find_level(number)\n    \n    if cur_lv == 0:\n        return number\n    \n    x0      =   p2[cur_lv]\n    seg     =   x0 * 2 \n    index   =  (number - x0) // seg\n    \n    return (x0 // 2) + (index * 2) * (seg // 2)\n\ndef move_R(number):\n    cur_lv    =  find_level(number)\n    \n    if cur_lv == 0:\n        return number\n    \n    x0      =   p2[cur_lv]\n    seg     =   x0 * 2 \n    index   =  (number - x0) // seg\n    \n    return (x0 // 2) + (index * 2 + 1) * (seg // 2)\n\ndef move(s,num):\n    if s == 'U':\n        return move_U(num)\n    \n    if s == 'L':\n        return move_L(num)\n    \n    return move_R(num)\n    \ndef process(S, num):\n    for s in S:\n        num = move(s, num)\n    return num\n\nn, q = map(int, input().split())\nmax_level = int(math.log2(n+1)) - 1\nans  = ''\n\nfor _ in range(q):\n    num  = int(input())\n    S    = input()\n    ans += str(process(S, num)) + '\\n'\n    \nprint(ans)    \n\n#15 2\n#4\n#UURL\n#8\n#LRLLLLLLLL",
    "complexity": "np",
    "problem": "0792_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,trees"
}
{
    "src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef check(mid: int) -> bool:\n    global ans\n    dic = {}\n    for i in range(n):\n        bit = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                bit += 1\n            bit <<= 1\n        dic[bit >> 1] = i\n    for x, idx in dic.items():\n        for y, idy in dic.items():\n            if x | y == 2**m-1:\n                ans = idx + 1, idy + 1\n                return True\n    return False\n\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nans = []\nle = 0\nri = int(1e9)\nwhile le <= ri:\n    mid = (le + ri) >> 1\n    if check(mid):\n        le = mid + 1\n    else:\n        ri = mid - 1\nprint(ans[0], ans[1])\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "from sys import *\n\nn, k = map(int, stdin.readline().split())\narr = list(map(int, stdin.readline().split()))\navg = 0\nfor i in range(n):\n\tcnt = 0\n\tsum = 0\n\tfor j in range(i, n):\n\t\tsum += arr[j]\n\t\tcnt += 1\n\t\tif cnt >= k:\n\t\t\tavg = max(avg, sum / cnt)\nprint(avg)",
    "complexity": "quadratic",
    "problem": "1003_C",
    "from": "CODEFORCES",
    "tags": "brute force,implementation,math"
}
{
    "src": "from math import factorial\ndef C(m,n):\n    return factorial(n) // (factorial(m) * factorial(n - m))\n\ncommand_1, command_2 = input(), input()\nnum = command_2.count('?')\ni = command_1.count('+') - command_1.count('-') -\\\ncommand_2.count('+') + command_2.count('-') + num\nif i % 2 == 0 and 0 <= i//2 <= num:\n    print(\"%.9f\"%(C(i//2, num) / 2**num))\nelse:\n    print(\"0.000000000\")",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\na = sorted(a)\n\ncur_v = a[0]\ncur_count = 1\nans = 0\n\n# print(a)\nfor i in range(1, len(a)):\n\n    if a[i] > a[i-1] and a[i] > a[i-1]+k:\n        ans += cur_count\n        cur_count = 1\n    elif a[i] == a[i-1]:\n        cur_count += 1\n    elif a[i] > a[i-1]:\n        cur_count = 1\n        \nans += cur_count\n\n        \nprint(ans)",
    "complexity": "nlogn",
    "problem": "0990_B",
    "from": "CODEFORCES",
    "tags": "greedy,sortings"
}
{
    "src": "for _ in range(int(input())):\n    s = input()\n    t = input()\n    if len(t) == 1:\n        print(\"YES\" if t in s else \"NO\")\n        continue\n    nxt = [[-1] * 26 for _ in range(len(s) + 1)]\n    nxt[-2][ord(s[-1]) - ord('a')] = len(s) - 1\n    for i in range(len(s) - 2, -1, -1):\n        for c in range(26):\n            nxt[i][c] = nxt[i + 1][c]\n        nxt[i][ord(s[i]) - ord('a')] = i\n    ans = \"NO\"\n    for p in range(len(t)):\n        a = t[:p]\n        b = t[p:]\n        dp = [[-1] * (len(b) + 1) for _ in range(len(a) + 1)]\n        dp[0][0] = 0\n        for la in range(len(a) + 1):\n            for lb in range(len(b) + 1):\n                if dp[la][lb] != -1:\n                    if la < len(a):\n                        if dp[la + 1][lb] != -1:\n                            if nxt[dp[la][lb]][ord(a[la]) - ord('a')] != -1:\n                                if nxt[dp[la][lb]][ord(a[la]) - ord('a')] < dp[la + 1][lb] - 1:\n                                    dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]\n                                    dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])\n                        else:\n                            dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]\n                            dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])\n                    if lb < len(b):\n                        if dp[la][lb + 1] != -1:\n                            if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] != -1:\n                                if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] < dp[la][lb + 1] - 1:\n                                    dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]\n                                    dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])\n                        else:\n                            dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]\n                            dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])\n                if dp[len(a)][len(b)] != -1:\n                    ans = \"YES\"\n                    break\n    print(ans)\n",
    "complexity": "cubic",
    "problem": "1303_E",
    "from": "CODEFORCES",
    "tags": "dp,strings"
}
{
    "src": "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\n# from math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ntry:\n    # sys.setrecursionlimit(int(pow(10,6)))\n    sys.stdin = open(\"input.txt\", \"r\")\n    # sys.stdout = open(\"../output.txt\", \"w\")\nexcept:\n    pass\ndef pmat(A):\n    for ele in A:\n        print(*ele,end=\"\\n\")\n\n\nn=L()[0]\nA=sorted(L())\nif A==[1]*n:\n    print(*A[:n-1],2)\nelse:\n    print(1,*A[:-1])\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\nendtime = time.time()\n# print(f\"Runtime of the program is {endtime - starttime}\")",
    "complexity": "nlogn",
    "problem": "0135_A",
    "from": "CODEFORCES",
    "tags": "greedy,implementation,sortings"
}
{
    "src": "from itertools import chain, combinations\ndef powerset(iterable):\n    xs = list(iterable)\n    # note we return an iterator rather than a list\n    return list(chain.from_iterable(combinations(xs,n) for n in range(2,len(xs)+1)))\nn,l,r,x=map(int,input().split())\nsett=list(map(int,input().split()))\npsett=powerset(sett)\ncount=0\nfor i in psett:\n    k=sorted(i)\n    j=sum(k)    \n    if j>=l and j<=r and k[-1]-k[0]>=x:\n        count+=1\nprint(count)\n\n\n",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "from math import factorial\ns=input()\ns1=input()\nplus=s.count('+')-s1.count('+')\nminus=s.count('-')-s1.count('-')\nn=s1.count('?')\nif plus<0 or minus<0:\n    print(0)\nelse:\n    print((factorial(n)/factorial(n-plus)/factorial(plus))*(0.5**n))",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "import os, sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nn,m,k=map(int,input().split())\nrow=[]\nfor _ in range(n):\n    row.append([10**6+2]+list(map(int,input().split()))+[10**6+2])\ncol=[[10**6+2]*(m+2)]\nfor _ in range(n-1):\n    col.append([10**6+2]+list(map(int,input().split()))+[10**6+2])\ncol.append([10**6+2]*(m+2))\nif  k%2:\n    dp=[[-1 for i in range(m)] for j in range(n)]\nelse:\n    k=k//2\n    dp = [[0 for i in range(m)] for j in range(n)]\n    for i in range(n):\n        for j in range(m):\n            dp[i][j]=2*min(row[i][j],row[i][j+1],col[i][j+1],col[i+1][j+1])\n    k-=1\n    while k:\n       # print(row,col)\n        k-=1\n        temp = [[0 for i in range(m)] for j in range(n)]\n        for i in range(n):\n            for j in range(m):\n                ck=dp[i][j]*8\n                if i>=1:\n                    ck=min(ck,dp[i-1][j]+2*col[i][j+1])\n                if i<n-1:\n                    ck=min(ck,dp[i+1][j]+2*col[i+1][j+1])\n                if j>=1:\n                    ck=min(ck,dp[i][j-1]+2*row[i][j])\n                if j<m-1:\n                    ck=min(ck,dp[i][j+1]+2*row[i][j+1])\n                temp[i][j]=ck\n\n\n        dp=temp\n\nfor i in dp:\n    print(*i)\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "import pprint\nnr, ng, nb = map(int, input().split())\n*r, = map(int, input().split())\n*g, = map(int, input().split())\n*b, = map(int, input().split())\ndp = []\nfor _ in range(nr + 1):\n    dp.append([[0] * (nb + 1) for _ in range(ng + 1)])\n\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\n\nmx = 0\nfor i in range(nr + 1):\n    for j in range(ng + 1):\n        for k in range(nb + 1):\n            if i and j:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])\n            if i and k:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])\n            if j and k:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])\n\n\nmx_i = mx_j = mx_k = -1\n\nfor i in range(nr + 1):\n    for j in range(ng + 1):\n        for k in range(nb + 1):\n            if dp[i][j][k] > mx:\n                mx_i = i\n                mx_j = j\n                mx_k = k\n                mx = dp[i][j][k]\n\nprint(mx)\n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "import math\nimport sys\nfrom bisect import bisect_right, bisect_left, insort_right\nfrom collections import Counter, defaultdict\nfrom heapq import heappop, heappush\nfrom itertools import accumulate\nfrom sys import stdout\n\nR = lambda: map(int, input().split())\nt = input()\ns = input()\nk = t.count('+') - s.count('+')\nn = s.count('?')\nif k > n or k < 0:\n    print('0.0')\nelse:\n    print(math.factorial(n) / (math.factorial(k) * math.factorial(n - k)) / 2**n)",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "def f(n,s):\n    d=[-n,-n];\n    d[s]=0;\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)];\n    return d[s];\nimport math;\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny=y+x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))",
    "complexity": "np",
    "problem": "1463_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,math"
}
{
    "src": "# binary search answer\n# O((nm+4^m)logA)\nimport sys\nreader = (s.rstrip() for s in sys.stdin)\ninp = reader.__next__\n\nn, m = map(int, inp().split())\narr = tuple(tuple(map(int, inp().split())) for i in range(n))\nlower_bound = 0\nupper_bound = int(1e9) + 1\nmask = (1 << m) - 1\n\nans = (0, 0)\n\n\ndef can_upper(mid):\n\tglobal ans\n\t\"\"\" return exist answer that >= m (boolean)\n\tO(nm + 4^m)\n\t\"\"\"\n\t# O(nm)\n\td = dict()\n\tfor i in range(n):\n\t\tbit = 0\n\t\tfor j in range(m):\n\t\t\tif arr[i][j] >= mid:\n\t\t\t\tbit += 1 << j\n\t\td[bit] = i\n\n\t# O(m * (2^m)^2) = O(4^m)\n\tkeys = tuple(d.keys())\n\tfor i in range(len(keys)):\n\t\ta1 = keys[i]\n\t\tfor j in range(i, len(keys)):\n\t\t\ta2 = keys[j]\n\t\t\tif a1 | a2 == mask:\n\t\t\t\tans = (d[a1], d[a2])\n\t\t\t\treturn True\n\treturn False\n\n\nwhile upper_bound - lower_bound > 1:\n\tmiddle = (upper_bound + lower_bound) >> 1\n\tif can_upper(middle):\n\t\tlower_bound = middle\n\telse:\n\t\tupper_bound = middle\n\nprint(ans[0] + 1, ans[1] + 1)",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "a,b,c = input().split()\nif a[1] == b[1] == c[1]:\n    t = sorted([int(a[0]),int(b[0]),int(c[0])])\n    if (t[1] == t[0] + 1 == t[2] - 1) or (t[0] == t[2]):print(0)\n    elif t[0] == t[1] or t[1] == t[2]:print(1)\n    elif t[0] + 1 == t[1] or t[1] + 1 == t[2] or t[0] + 2 == t[1] or t[1] + 2 == t[2]:print(1)\n    else:print(2)\nelif a[1] == b[1]:\n    s,t = int(a[0]),int(b[0])\n    if s == t:print(1)\n    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)\n    else:print(2)\nelif c[1] == b[1]:\n    s,t = int(c[0]),int(b[0])\n    if s == t:print(1)\n    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)\n    else:print(2)\nelif a[1] == c[1]:\n    s,t = int(a[0]),int(c[0])\n    if s == t:print(1)\n    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)\n    else:print(2)\nelse:print(2)\n",
    "complexity": "nlogn",
    "problem": "1191_B",
    "from": "CODEFORCES",
    "tags": "brute force,implementation"
}
{
    "src": "import math\nfrom math import factorial\n\ndef combination(n,r):\n    return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r))\n\na = input()\nap = a.count('+')\nam = a.count('-')\nb = input()\nbp = b.count('+')\nbm = b.count('-')\nn = b.count('?')\nx = float(ap - bp)\ny = float(am - bm)\nif (x < 0 or y < 0 or x+y != n):\n    print(0.0)\nelse:\n    print(combination(n,x)/(1<<n))\n",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    s = list(input().rstrip())\n    t = input().rstrip()\n    ok = False\n    for i in range(len(t)):\n        t1 = list(t[:i]) + [\"#\"]\n        t2 = list(t[i:]) + [\"#\"] \n        # dp[seen i-th index][match j in front] = match in back\n        dp = [[-1] * (len(t) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = 0\n        for j, ch in enumerate(s):\n            for k in range(len(t1)):\n                if dp[j][k] == -1:\n                    continue\n                dp[j+1][k] = max(dp[j+1][k], dp[j][k])\n                if ch == t1[k]:\n                    dp[j+1][k+1] = max(dp[j+1][k+1], dp[j][k])\n                if ch == t2[dp[j][k]]:\n                    dp[j+1][k] = max(dp[j+1][k], dp[j][k] + 1)\n        for k in range(len(t) + 1):\n            if dp[len(s)][k] + k >= len(t):\n                ok = True\n\n    if ok:\n        print(\"YES\")\n    else:\n        print(\"NO\")",
    "complexity": "cubic",
    "problem": "1303_E",
    "from": "CODEFORCES",
    "tags": "dp,strings"
}
{
    "src": "n = [int(x) for x in input().split()]\na = []\nfor i in range(3):\n\ta.append([int(x) for x in input().split()])\n\ta[i].sort(reverse=True)\n\ndp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]\nans = 0\nfor i in range(n[0] + 1):\n\tfor j in range(n[1] + 1):\n\t\tfor k in range(n[2] + 1):\n\t\t\tif i < n[0] and j < n[1]:\n\t\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])\n\t\t\tif i < n[0] and k < n[2]:\n\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])\n\t\t\tif j < n[1] and k < n[2]:\n\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])\n\t\t\tans = max(ans, dp[i][j][k])\n\nprint(ans)",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "def nr(): return nrs()[0]\ndef nrs(): return [int(i) for i in input().split()]\n\ndef get_prime(n):\n\tres = []\n\tfor i in range(2,n):\n\t\tis_prime = True\n\t\tfor x in res:\n\t\t\tif i % x == 0:\n\t\t\t\tis_prime = False\n\t\t\t\tbreak\n\t\tif is_prime: res.append(i)\n\treturn res\n\nprime = get_prime(3162)\n\n#cache = {}\ndef get_mask (num):\n\t#key = num\n\t#if key in cache: return cache[key]\n\tdv = []\n\tfor p in prime:\n\t\tc = 0\n\t\twhile num % p == 0:\n\t\t\tc += 1\n\t\t\tnum = num // p\n\t\tif c % 2 == 1:\n\t\t\tdv.append(p)\n\t\tif num < p * p:\n\t\t\tbreak\n\n\tfor x in dv:\n\t\tnum *= x\n\n\t#cache[key] = num\n\treturn num\n\nfor _ in range(nr()):\n\tN, K = nrs()\n\tA = nrs()\n\tdp = [N] * (K + 1)\n\tdp[0] = 1\n\tused = [{}] * (K + 1)\n\tfor a in A:\n\t\ta = get_mask(a)\n\t\tfor j in range(K, -1, -1):\n\t\t\tif dp[j] == N: continue\n\t\t\tif a in used[j]:\n\t\t\t\tif j < K and dp[j + 1] > dp[j]:\n\t\t\t\t\tdp[j + 1] = dp[j]\n\t\t\t\t\tused[j + 1] = used[j]\n\t\t\t\tdp[j] += 1\n\t\t\t\tused[j] = {}\n\t\t\tused[j][a] = 1\n\tprint(min(dp))\n",
    "complexity": "cubic",
    "problem": "1497_E2",
    "from": "CODEFORCES",
    "tags": "data structures,dp,greedy,math,number theory,two pointers"
}
{
    "src": "import sys\nfrom collections import defaultdict\n \ninput = sys.stdin.readline\n \nn, m = map(int, input().split())\n# n, m = 3 * 10 ** 5, 8\nvals = set()\nlocs = defaultdict(list)\nfor i in range(n):\n    inp = map(int, input().split())\n    for pos, v in enumerate(inp):\n        vals.add(v)\n        locs[v].append((pos, i))\n\nmasks = [0] * n\nfull = (1<<m) - 1\nmet = {0:0}\nfor v in sorted(vals, reverse=True):\n    for pos, i in locs[v]:\n        curr_mask = masks[i] = masks[i] | (1<<pos)\n        met[curr_mask] = i\n        complement = full ^ curr_mask\n        if complement in met:\n            print(i+1, met[complement]+1)\n            sys.exit()",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Sep 18 08:45:24 2020\n\n@author: Dark Soul\n\"\"\"\ndef comp(a,b):\n    x=len(a)\n    s1=''\n    s2=''\n    for i in range(x):\n        s1+=str(a[i])\n        s2+=str(b[i])\n    if s1>s2:\n        return 1\n    else:\n        return 0\n        \na=list(input(''))\nb=list(input(''))\ncnt=[0]*10\nn=len(a)\nm=len(b)\nsol=''\nfor i in range(n):\n    a[i]=int(a[i])\n    cnt[a[i]]+=1\n\nif n!=m:\n    a.sort(reverse=True)\n    for i in a:\n        sol+=str(i)\n    print(sol)\nelse:\n    a.sort()\n    \n    for i in range(n):\n        b[i]=int(b[i])\n    for i in range(n-1):\n        for j in range(i,n):\n            if a[i]<a[j]:\n                temp=a[i]\n                a[i]=a[j]\n                a[j]=temp\n                if comp(a,b):\n                    temp=a[i]\n                    a[i]=a[j]\n                    a[j]=temp\n                \n    \n    for i in a:\n        sol+=str(i)\n    print(sol)",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import math,sys,bisect,heapq\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\n#sys.setrecursionlimit(200000000)\nint1 = lambda x: int(x) - 1\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nilele = lambda: map(int,input().split())\nalele = lambda: list(map(int, input().split()))\nilelec = lambda: map(int1,input().split())\nalelec = lambda: list(map(int1, input().split()))\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n#MOD = 1000000000 + 7\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n    \nMOD = 998244353\n\nN,K = ilele()\nif K == 1 or K == 2*N:\n    print(2)\n    exit(0)\ndp = list3d(N+1,4,K+1,0)\ndp[1][0][1] = 1\ndp[1][3][1] = 1\ndp[1][1][2] = 1\ndp[1][2][2] = 1\n\nfor n in range(2,N+1):\n    for k in range(1,K+1):\n        dp[n][0][k] = ((dp[n-1][0][k]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD\n        dp[n][3][k] = ((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k])%MOD)%MOD\n        if k > 1:\n            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k-2] +dp[n-1][3][k-1])%MOD)%MOD\n            dp[n][2][k]=((dp[n-1][0][k-1]+dp[n-1][1][k-2])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD\n        else:\n            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][3][k-1])%MOD)%MOD\n            dp[n][2][k]=((dp[n-1][0][k-1])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD\n\nprint(((dp[N][0][K]+dp[N][1][K])%MOD+(dp[N][2][K]+dp[N][3][K])%MOD)%MOD)\n            ",
    "complexity": "np",
    "problem": "1051_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "m = int(input())\nvalues = []\nidx = []\nfor i in range(m):\n    x = int(input())\n    ans = 0\n    for xx,ii in zip(values,idx):\n        if (xx^x) < x:\n            x^=xx\n            ans^=ii\n    if x == 0:\n        anss = []\n        for j in range(i):\n            if (ans&1)!=0:\n                anss.append(j)\n            ans>>=1\n        print(len(anss),*anss)\n    else:\n        print(0)\n        values.append(x)\n        idx.append(ans^(2**i))\n",
    "complexity": "np",
    "problem": "0504_D",
    "from": "CODEFORCES",
    "tags": "bitmasks"
}
{
    "src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nn,m=map(int,input().split())\na=[list(map(int,input().split())) for i in range(n)]\nl=-1;r=10**9+1\nans1,ans2=-1,-1\nwhile r-l>1:\n    x=(l+r)//2\n    idx={}\n    for i in range(n):\n        v=0\n        for j in range(m):\n            if a[i][j]>=x:\n                v+=1\n            v<<=1\n        idx[v>>1]=i\n    ok=False\n    idx1,idx2=0,0\n    for aa,bb in idx.items():\n        for cc,dd in idx.items():\n            for d in range(m):\n                if (aa|cc)==(2**m)-1:\n                    ok=True\n                    idx1=bb+1\n                    idx2=dd+1\n    if ok:\n        l=x\n        ans1=idx1\n        ans2=idx2\n    else:\n        r=x\nprint(ans1,ans2)",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "from math import factorial\nn, mod = map(int, input().split())\ndef binom(n, m):    return factorial(n) // factorial(m) // factorial(n-m)\ndef foo(x, k):\n    ans = 0\n    for i in range(k, 0, -1):sign = 1 if (i-k)%2 == 0 else -1;ans += sign * binom(k, i) * (i**x);ans %= mod\n    return ans\ndef f(x, k):    return (foo(x, k) * pow(2, x-k, mod)) % mod\nans = 0\nfor i in range((n+1)//2):ans = (ans + f(n-i, i+1));ans %= mod\nprint(ans)",
    "complexity": "cubic",
    "problem": "1515_E",
    "from": "CODEFORCES",
    "tags": "combinatorics,dp,math"
}
{
    "src": "def c(a, b, l, ans, pro):\n    if l != 0:\n        n = a[:]\n        mx = None\n        pro1 = pro\n        prosh = set()\n        for i in range(l):\n            pro = pro1\n            if a[i] == prosh:\n                continue\n            elif (a[i] <= b[0] and pro):\n                n.pop(i)\n                prosh = a[i]\n                if pro == True:\n                    if a[i] < b[0]:\n                        pro = False\n                m = c(n, b[1:], l-1, ans+str(a[i]), pro)\n                n = a[:]\n                if m != None:\n                    if mx == None:\n                        mx = int(m)\n                    elif mx < int(m):\n                        mx = int(m)\n            elif not(pro):\n                a.sort(reverse = True)\n                a = list(map(str, a))\n                return ans +''.join(a)\n            else:\n                break\n        return mx            \n    else:\n        return ans\na = input()\nb = input()\nl = len(a)\nif len(a) != len(b):\n    a = list(a)\n    a.sort()\n    print(''.join(a[::-1]))\nelse:    \n    a = list(map(int, a))\n    b = list(map(int, b))\n    a.sort()\n    n = a[:]\n    mx = 0\n    prosh = -1\n    for i in range(l):\n        if a[i] == prosh:\n            continue\n        elif a[i] != 0 and a[i] <= b[0]:\n            n.pop(i)\n            prosh = a[i]\n            pro = False\n            if a[i] == b[0]:\n                pro = True\n            m = c(n, b[1:], l-1, str(a[i]), pro)\n            n = a[:]\n            if m != None:\n                if mx < int(m):\n                    mx = int(m)\n        elif a[i] > b[0]:\n            break\n    print(mx)",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import deque\n\ndef main():\n    with open('input.txt') as fp:\n        input=fp.readline\n        n, m = map(int, input().split())\n        dx = [1, -1, 0, 0]\n        dy = [0, 0, -1, 1]\n        q =deque()\n        k = int(input())\n        a = list(map(int, input().split()))\n        v = [[1] * (m + 2) for _ in range(n + 2)]\n        for i in range(m + 2):\n            v[0][i] = 0\n            v[-1][i] = 0\n        for i in range(n + 2):\n            v[i][0] = 0\n            v[i][-1] = 0\n        for i in range(0, 2 * k, 2):\n            q.append((a[i],a[i + 1]))\n            v[a[i]][a[i + 1]] = 0\n        while 1:\n            x, y =q.popleft()\n            for i in range(4):\n                xx, yy = x + dx[i], y + dy[i]\n                if v[xx][yy]:\n                    q.append((xx, yy))\n                    v[xx][yy] = 0\n            if not q:\n                with open('output.txt', mode='w') as fpp:\n                    fpp.write(f'{x} {y}')\n                break\n\n# region fastio\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()",
    "complexity": "cubic",
    "problem": "0035_C",
    "from": "CODEFORCES",
    "tags": "brute force,dfs and similar,shortest paths"
}
{
    "src": "n = int(input())\na = list(map(int, input().split()))\n\ndp = [[False] * (n + 1) for i in range(n + 1)]\n\ndef solve(l, r):\n    if dp[l][r]:\n        return dp[l][r]\n    if r - l == 1:\n        dp[l][r] = (a[l], 1)\n        return dp[l][r]\n    tmp = 10 ** 9\n    for i in range(l + 1, r):\n        if solve(l, i)[0] == -1 or solve(i, r)[0] == -1:\n            tmp = min(tmp, dp[l][i][1] + dp[i][r][1])\n        elif solve(l, i) == solve(i, r):\n            tmp = solve(l, i)[0] + 1\n            dp[l][r] = (tmp, 1)\n            return dp[l][r]\n        else:\n            tmp = min(tmp, 2)\n    dp[l][r] = (-1, tmp)\n    return dp[l][r]\n\nsolve(0, n)\nprint(dp[0][n][1])",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "from itertools import combinations\n\np, minn, maxn, dif = map(int, input().split())\n(*lst,) = map(int, input().split())\nc = 0\nfor i in range(2, p + 2):\n    for j in combinations(lst, i):\n        if (maxn >= sum(j) >= minn) and (max(j) - min(j) >= dif):\n            c += 1\nprint(c)",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "a = input()\nb = input()\ndigits = {}\ndef greedy(digits,s):\n    for i in range(9,-1,-1):\n        d = str(i)\n        if d in digits:\n            while digits[d] > 0:\n                s += d\n                digits[d] -= 1\n    return s\nfor d in a:\n    if d in digits:\n        digits[d] += 1\n    else:\n        digits[d] = 1\nif len(a) < len(b):\n    print(greedy(digits,\"\"))\nelse:\n    ind = 0\n    cur = \"\"\n    back = False\n    done = False\n    while 1:\n        if ind == len(a) or done == True:\n            break\n        found = False\n        for i in range(9,-1,-1):\n            x = str(i)\n            if i == int(b[ind]) and x in digits and digits[x] > 0:\n                found = True\n                digits[x] -= 1\n                cur += x\n                break\n            elif i < int(b[ind]) and x in digits and digits[x] > 0:\n                found = True\n                done = True\n                digits[x] -= 1\n                cur += x\n                print(greedy(digits,cur))\n                break\n        if found == False:\n            back = True\n            break\n        ind += 1\n    \n    if back == False and done == False:\n        print(cur)\n    elif done == False:\n        for i in range(ind-1,-1,-1):\n            digits[cur[i]] += 1\n            for j in range(9,-1,-1):\n                d = str(j)\n                if j < int(b[i]) and d in digits and digits[d] > 0:\n                    done = True\n                    s = cur[:i]\n                    s += d\n                    digits[d] -= 1\n                    print(greedy(digits,s))\n                    break\n            if done:\n                break",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "#!/usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef S(): return input().rstrip()\ndef LS(): return S().split()\ndef IR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = II()\n    return res\ndef LIR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LI()\n    return res\ndef FR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = IF()\n    return res\ndef LIR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = IF()\n    return res\ndef LIR_(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LI_()\n    return res\ndef SR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = S()\n    return res\ndef LSR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LS()\n    return res\nmod = 1000000007\ninf = float('INF')\n\n#solve\ndef solve():\n    n = II()\n    a = LI()\n    dp = [[None for i in range(n + 1)] for i in range(n + 1)]\n    for i in range(n):\n        dp[i][i + 1] = [a[i], a[i], 1]\n        dp[i + 1][i] = [a[i], a[i], 1]\n    for i in range(2, n + 1):\n        for l in range(n - i + 1):\n            tmp = [-inf, inf, inf]\n            r = l + i\n            dpl = dp[l]\n            dpr = dp[r]\n            for m in range(l + 1, r):\n                lm = dpl[m]\n                mr = dpr[m]\n                lr = lm[2] + mr[2] - (lm[1] == mr[0])\n                if lr < tmp[2]:\n                    tmp[2] = lr\n                    if lm[1] == mr[0]:\n                        if lm[2] == 1:\n                            tmp[0] = lm[0] + 1\n                        else:\n                            tmp[0] = lm[0]\n                        if mr[2] == 1:\n                            tmp[1] = mr[1] + 1\n                        else:\n                            tmp[1] = mr[1]\n                    else:\n                        tmp[0] = lm[0]\n                        tmp[1] = mr[1]\n            dp[l][r] = tmp\n            dp[r][l] = tmp\n    print(dp[0][n][2])\n    return\n\n\n#main\nif __name__ == '__main__':\n    solve()\n",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "import sys\nfrom array import array  # noqa: F401\nfrom typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\ndef main():\n    n, m = map(int, input().split())\n    mat = [array('i', map(int, input().split())) for _ in range(n)]\n    bit = [1 << i for i in range(m)]\n    max_bit = 1 << m\n    fullbit = max_bit - 1\n\n    def solve(x: int) -> Tuple[int, int]:\n        dp = array('i', [-1]) * max_bit\n        for i in range(n):\n            dp[sum(bit[j] for j, y in enumerate(mat[i]) if y >= x)] = i\n\n        for i in range(max_bit):\n            if dp[i] == -1:\n                continue\n            for j in range(i, max_bit):\n                if dp[j] != -1 and i | j == fullbit:\n                    return dp[i], dp[j]\n\n        return -1, -1\n\n    ok, ng = 0, 10**9 + 1\n    ans_i, ans_j = 1, 1\n\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) >> 1\n        x, y = solve(mid)\n        if x == -1:\n            ng = mid\n        else:\n            ok = mid\n            ans_i, ans_j = x + 1, y + 1\n\n    print(ans_i, ans_j)\n\n\nif __name__ == '__main__':\n    main()\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "#!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport threading \nfrom bisect import bisect_right\nfrom math import gcd,log\nfrom collections import Counter,defaultdict,deque\nfrom pprint import pprint\nfrom itertools import permutations \nfrom bisect import bisect_right\nfrom random import randint as rti \n# import deque\nn,m=0,0\n\n\n    \n\n\n\ndef main(tnum):\n    global n,m,d\n    n,m,k=map(int,input().split())\n    if k%2:\n        ans=[[-1]*m for i in range(n)]\n        for li in ans:\n            print(*li)\n        return \n    cost=dict()\n    dp=[[float('inf')]*m for i in range(n)] \n    crr=[]\n    rrr=[]\n    for i in range(n):\n        arr=list(map(int,input().split()))\n        for j in range(m-1):\n            dp[i][j]=min(dp[i][j],arr[j])\n            dp[i][j+1]=min(dp[i][j+1],arr[j])\n        crr.append(arr)\n\n\n    for i in range(n-1):\n        arr=list(map(int,input().split())) \n        for j in range(m):\n            dp[i][j]=min(dp[i][j],arr[j])\n            dp[i+1][j]=min(dp[i+1][j],arr[j])\n\n\n        rrr.append(arr)\n\n    for i in range(1,k//2):\n        ndp=[[float('inf')]*m for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                x,y=i,j\n                if x>0:\n                    ndp[i][j]=min(ndp[i][j],dp[x-1][y]+rrr[x-1][y])\n                if x<n-1:\n                    ndp[i][j]=min(ndp[i][j],dp[x+1][y]+rrr[x][y])\n                if y>0:\n                    ndp[i][j]=min(ndp[i][j],dp[x][y-1]+crr[x][y-1])\n                if y<m-1:\n                    ndp[i][j]=min(ndp[i][j],dp[x][y+1]+crr[x][y])\n        dp=ndp\n    for li in dp:\n        li=[2*x for x in li]\n        print(*li)  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n        \n\n\n\n\n    \n\n    \n\n\n\n\n\n\n\n\n        \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \nif __name__ == \"__main__\":\n\n    for _ in range(1): \n        main(_+1)\n\n\n\n",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "from math import factorial,pow\ns1=list(input())\ns2=list(input())\nS1={\"+\":0, \"-\":0}\nS2={\"+\":0, \"-\":0, \"?\":0}\nfor i in s1:\n    S1[i]+=1\nfor i in s2:\n    S2[i]+=1\nif S1[\"+\"]-S2[\"+\"]>=0 and S1[\"-\"]-S2[\"-\"]>=0:\n    pos=S1[\"+\"]-S2[\"+\"]\n    neg=S1[\"-\"]-S2[\"-\"]\n    ques=S2[\"?\"]\n    res=(factorial(pos+neg)/(factorial(pos)*factorial(neg)))/pow(2,ques)\n    print(\"%.12f\"%res)\nelse:\n    print(\"%.12f\" % 0)",
    "complexity": "np",
    "problem": "0476_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"
}
{
    "src": "def search(current, digits, target, idx, bulk):\n    if len(current) == len(target) and int(current) <= int(target):\n        print(current)\n        exit(0)\n\n    possibilities = [char for char in digits if bulk or (char <= target[idx] and char in digits)]\n\n    if len(possibilities) == 0:\n        return None\n\n    for possible_digit in sorted(set(possibilities), reverse=True):\n        tmp_digits = list(digits)\n        tmp_digits.remove(possible_digit)\n        if not bulk:\n            bulk = True if possible_digit != target[idx] else False\n        search(current + possible_digit, tmp_digits, target, idx + 1, bulk)\n\n\ndef main():\n    digits = sorted(list(input()), reverse=True)\n    target = input()\n\n    if len(digits) < len(target):\n        print(''.join(digits))\n        exit(0)\n\n    entries = [char for char in digits if char <= target[0]]\n\n    for current in sorted(set(entries), reverse=True):\n        tmp_digits = list(digits)\n        tmp_digits.remove(current)\n        search(current, tmp_digits, target, 1, True if current != target[0] else False)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "R,G,B=map(int,input().split())\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr.sort()\ng.sort()\nb.sort()\n\ndp=[[[0 for i in range(B+1)] for j in range(G+1)] for i in range(R+1)]\n\nfor i in range(1,R+1):\n    for j in range(1,G+1):\n        dp[i][j][0]=dp[i-1][j-1][0]+r[i-1]*g[j-1]\n\nfor j in range(1,G+1):\n    for k in range(1,B+1):\n        dp[0][j][k]=dp[0][j-1][k-1]+b[k-1]*g[j-1]\n\nfor i in range(1,R+1):\n    for k in range(1,B+1):\n        dp[i][0][k]=dp[i-1][0][k-1]+r[i-1]*b[k-1]\n\nfor i in range(1,R+1):\n    for j in range(1,G+1):\n        for k in range(1,B+1):\n            if max(r[i-1],g[j-1],b[k-1])==r[i-1]:\n                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])\n            elif max(r[i-1],g[j-1],b[k-1])==g[j-1]:\n                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i][j-1][k-1]+g[j-1]*b[k-1])\n            else:\n                dp[i][j][k]=max(dp[i][j-1][k-1]+b[k-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])\n\n\n\nprint(dp[R][G][B])\n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\ndef getMul(x):\n    a = 1\n    for xi in x:\n        a *= xi\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\nd = {}\nfor ai in a:\n    if ai in d: d[ai] += 1\n    else: d[ai] = 1\n\nf = [[] for i in range(max(a)+10)]\nfor i in range(1, len(f)):\n    for j in range(i, len(f), i):\n        f[j].append(i)\n\nseq = [0 for i in range(max(a)+10)]\nfor ai in d:\n    for fi in f[ai]:\n        seq[fi] += d[ai]\nfor i in range(len(seq)):\n    seq[i] = (pow(2, seq[i], MOD) -1 +MOD) % MOD\n\npf = [[] for i in range(max(a)+10)]\npf[0] = None\npf[1].append(1)\nfor i in range(2, len(f)):\n    if len(pf[i]) == 0:\n        for j in range(i, len(pf), i):\n            pf[j].append(i)\nfor i in range(1, len(pf)):\n    mul = getMul(pf[i])\n    if mul == i:\n        if len(pf[i])&1 == 1: pf[i] = -1\n        else: pf[i] = 1\n    else:\n        pf[i] = 0\npf[1] = 1\n\nans = 0\nfor i in range(1, len(seq)):\n    ans += seq[i]*pf[i]\n    ans = (ans + MOD) % MOD\nprint(ans)",
    "complexity": "np",
    "problem": "0803_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,combinatorics,number theory"
}
{
    "src": "from sys import stdin, stdout\nimport heapq\nfrom collections import defaultdict\nimport math\nimport bisect\n\n\n\n\ndef main():\n    n,m,k = list(map(int, stdin.readline().split()))\n    right = []\n    for _ in range(n):\n        right.append(list(map(int, stdin.readline().split())))\n    down = []\n    for _ in range(n-1):\n        down.append(list(map(int, stdin.readline().split())))\n    if k % 2 == 1:\n        for _ in range(n):\n            stdout.write(\" \".join([\"-1\" for _ in range(m)])+\"\\n\")\n        return\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    for x in range(1, (k//2) + 1):\n        tmp = [[math.inf for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i:\n                    tmp[i][j] = min(tmp[i][j], dp[i-1][j] + 2 * down[i-1][j])\n                if i < n-1:\n                    tmp[i][j] = min(tmp[i][j], dp[i + 1][j] + 2 * down[i][j])\n                if j:\n                    tmp[i][j] = min(tmp[i][j], dp[i][j - 1] + 2 * right[i][j - 1])\n                if j < m-1:\n                    tmp[i][j] = min(tmp[i][j], dp[i][j + 1] + 2 * right[i][j])\n        dp = tmp\n        #print(dp)\n    for i in range(n):\n        stdout.write(\" \".join([str(x) for x in dp[i]]) + \"\\n\")\n\nmain()",
    "complexity": "cubic",
    "problem": "1517_D",
    "from": "CODEFORCES",
    "tags": "dp,graphs,shortest paths"
}
{
    "src": "import sys\ninput=sys.stdin.buffer.readline\n\nnr,ng,nb=[int(x) for x in input().split()]\nr=[int(x) for x in input().split()]\ng=[int(x) for x in input().split()]\nb=[int(x) for x in input().split()]\n\nr.sort()\ng.sort()\nb.sort()\n\nmemo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]\nmemo[0][0][0]=0 #starting point when i==-1,j==-1,k==-1\nfor i in range(nr):\n    memo[i+1][0][0]=0\nfor j in range(ng):\n    memo[0][j+1][0]=0\nfor k in range(nb):\n    memo[0][0][k+1]=0\ndef dp(i,j,k): #dp(i,j,k) is the max value including r[i],g[j],b[k]\n    if i<-1 or j<-1 or k<-1:\n        return -float('inf')\n    if memo[i+1][j+1][k+1]==-1: #offset by 1 because i,j,k can be -1\n        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],\n                   dp(i-1,j-1,k)+r[i]*g[j],\n                   dp(i-1,j,k-1)+r[i]*b[k]\n                )\n    return memo[i+1][j+1][k+1]\n\nfor i in range(max(nr,ng,nb)):\n    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))\n\n\nprint(dp(nr-1,ng-1,nb-1))",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
{
    "src": "import sys\nfrom math import gcd\nfrom collections import defaultdict as dd\ninput=sys.stdin.readline\nn=int(input())\nl=list(map(int,input().split()))\nc=list(map(int,input().split()))\ndp=dict()\nfor i in range(n):\n    if dp.get(l[i]):\n        dp[l[i]]=min(dp[l[i]],c[i])\n    else:\n        dp[l[i]]=c[i]\nfor ll in l:\n    keys=list(dp.keys())\n    for j in keys:\n        g=gcd(j,ll)\n        if dp.get(g):\n            dp[g]=min(dp[g],dp[ll]+dp[j])\n        else:\n            dp[g]=dp[ll]+dp[j]\nif 1 in dp:\n    print(dp[1])\nelse:\n    print(-1)",
    "complexity": "np",
    "problem": "0510_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force,dp,math"
}
{
    "src": "n,k = [int(x) for x in input().split()]\ndp = [[[0 for _ in range(4)] for _ in range(k+2)] for _ in range(2)]\ndp[1][2][0] = 1\ndp[1][2][1] = 1\ndp[1][1][2] = 1\ndp[1][1][3] = 1\n\n\n\nfor n1 in range(1,n):\n    for k1 in range(1,k+1):\n        \n        dp[0][k1][0] = dp[1][k1][0]\n        dp[0][k1][1] = dp[1][k1][1]\n        dp[0][k1][2] = dp[1][k1][2]\n        dp[0][k1][3] = dp[1][k1][3]\n        \n        dp[1][k1][0] = (dp[0][k1][0] + (dp[0][k1-2][1] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353 \n        \n        dp[1][k1][1] = (dp[0][k1][1] + (dp[0][k1-2][0] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353 \n        \n        dp[1][k1][2] = (dp[0][k1][2] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][3])% 998244353 \n        \n        dp[1][k1][3] = (dp[0][k1][3] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][2])% 998244353 \ntotal = 0\n#print(dp)\nfor i in range(4):\n    total += dp[1][k][i] % 998244353 \n#print(dp)\nprint(total% 998244353 )\n        \n        \n                        \n",
    "complexity": "np",
    "problem": "1051_D",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "# import builtins\n\ndebug = 0\nBIG = 10 ** 9 + 1\n\ninput = raw_input\n\n\ndef prof(f):\n    return f\n    # if 'profile' in dir(builtins):\n    #     return profile(f)\n    # else:\n    #     return f\n\n\ndef report(f):\n    def new_f(x):\n        res = f(x)\n        # print(f\"{x}  --> {res}\")\n        return res\n\n    return new_f if debug else f\n\n\ndef mcheck(a, pairs):\n    m = len(a[0])\n    allm = 2 ** m - 1\n\n    subs = {i: {i} for i in range(allm + 1)}\n\n    for i in range(allm + 1):\n        for j in range(i):\n            if i | j == i:  # 11 1  10 1   00 0  01 1\n                subs[i].add(j)\n\n    mx = [max(aa) for aa in a]\n\n    @prof\n    def check(v):\n        masks = {0: -1}\n        done = [False] * (allm + 1)\n        for i, aa in enumerate(a):\n            if mx[i] < v:\n                continue\n            c = sum(1 << b for b in range(len(aa)) if aa[b] >= v)\n            # if c == allm:\n            #     pairs[v] = i, i\n            #     return True\n            if not done[c]:\n                for cc in subs[c]:\n                    if allm - cc in masks:\n                        other = masks[allm - c]\n                        pairs[v] = i, other\n                        return True\n                    masks[cc] = i\n                    done[cc] = True\n                # masks[c] = i\n        # for ma, mb in itertools.combinations(masks, 2):\n        #     if ma | mb == allm:\n        #         pairs[v] = masks[ma], masks[mb]\n        #         return True\n        return False\n\n    return check\n\n\n@prof\ndef go():\n    n, m = map(int, input().split())\n\n    a = []\n    # mx = 0\n    # mnmx = 0\n    uniq = set()\n    for _ in range(n):\n        aa = tuple(map(int, input().split()))\n        # mx = max(mx, max(aa))\n        # mnmx = max(mnmx, min(aa))\n        a.append(aa)\n        uniq.update(aa)\n\n    uniq = sorted(uniq)\n    pairs = {0: (0, 0)}\n    check = mcheck(a, pairs)\n    l = 0\n    r = len(uniq) - 1\n    while l != r:\n        if debug: print(l, r)\n        if l + 1 == r:\n            if check(uniq[r]):\n                l = r\n            else:\n                r = l\n            continue\n        c = (l + r) // 2\n        if check(uniq[c]):\n            l = c\n        else:\n            r = c\n\n    l = uniq[l]\n    if debug: print(l, pairs[l])\n    if l not in pairs:\n        check(l)\n    a = pairs[l][0]\n    b = pairs[l][1]\n    if b == -1:\n        b = a\n\n    print(\"%d %d\" % (a + 1, b + 1))\n\n\ngo()\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "import sys\nfrom itertools import chain, combinations\n\ndef powerset(iterable):\n\ts = list(iterable)\n\treturn chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n\ndef diff(s, x):\n\treturn True if (max(s)-min(s))>=x else False\n\ndef solve(problemset, l, r, x):\n\tmultiset = powerset(problemset)\n\tcnt = 0\n\tfor s in multiset:\n\t\tif sum(s)>=l and sum(s)<=r and diff(s, x):\n\t\t\tcnt += 1\n\treturn cnt\n\n\nsys.setrecursionlimit(10**7)\n\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI():return map(int, sys.stdin.readline().rstrip().split())\ndef LI():return list(map(int, sys.stdin.readline().rstrip().split()))\ndef LI2():return list(map(int, sys.stdin.readline().rstrip()))\ndef S():return sys.stdin.readline().rstrip()\ndef LS():return list(sys.stdin.readline().rstrip().split())\ndef LS2():return list(sys.stdin.readline().rstrip())\n\nn, l, r, x = MI()\n\nproblemset = LI()\n\nprint(solve(problemset, l, r, x))",
    "complexity": "np",
    "problem": "0550_B",
    "from": "CODEFORCES",
    "tags": "bitmasks,brute force"
}
{
    "src": "import bisect\ndef solve(l,d,s2,r):\n    ans=\"\"\n    lol=0\n    i=0\n    lo=0\n    while i<(len(s2)):\n        if(lo==1):\n            #print(\"lol\",i)\n            \n            a=s2[i]\n            ind=bisect.bisect_left(l,a)\n            #print(ind,a)\n            for x in range(ind,-1,-1):\n                if(l[x]<l[ind]):\n                    ind=x\n                    #print(\"lol\")\n                    break\n            ans+=str(l[ind])\n            d[l.pop(ind)]-=1\n            \n            lol=1\n            break\n\n        a=s2[i]\n        ind=bisect.bisect_left(l,a)\n        #print(l,ind,a)\n        \n        if(ind==len(l)):\n            ind-=1\n            ans+=str(l[ind])\n            d[l[ind]]-=1\n            lol=1\n            break\n        elif(l[ind]>a):\n            if(ind==0):\n                while ind==0:\n                    \n                    l.append(int(ans[-1]))\n                    d[int(ans[-1])]+=1\n                    l.sort()\n                    ans=ans[:len(ans)-1]\n                    lo=1\n                    i-=1\n                    a=s2[i]\n                    ind=bisect.bisect_left(l,a)\n                #print(i)\n                #i+=1\n                continue\n            lol=1\n            ans+=str(l[ind-1])\n            #print(ans,i)\n            d[l[ind-1]]-=1\n            l.pop(ind-1)\n            break\n        else:\n            ans+=str(l[ind])\n            d[l[ind]]-=1\n            l.pop(ind)\n        i+=1\n    ll=[]\n    #print(\"lol\",d)\n    if(lol):\n        for i in d:\n            if(d[i]!=0):\n                ll.append(i)\n        ll.sort(reverse=True)\n        co=0\n        #print(ll)\n        for i in ll:\n            for j in range(d[i]):\n                if(i==0):\n                    co+=1\n                    if(co>r):\n                        break\n                ans+=str(i)\n                \n    print(ans)\nfrom math import gcd\nimport sys\nfrom collections import defaultdict as dd\ninput=sys.stdin.readline\ns1=list(map(int,input().strip()))\ns2=list(map(int,input().strip()))\nz=s1.count(0)\nd=dd(int)\nn=len(s1)\nm=len(s2)\nl=sorted(s1)\nfor i in s1:\n    d[i]+=1\nif len(s1)<len(s2):\n    for i in range(len(s1)-1,-1,-1):\n        print(l[i],end=\"\")\nelif(len(s1)>len(s2)):\n    r=m-(n-z)\n    #print(l,m,n,z)\n    l=l[z-r:]\n    #print(l,r)\n    solve(l,d,s2,r)\nelse:\n    solve(l,d,s2,100)\n    ",
    "complexity": "cubic",
    "problem": "0915_C",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "def f(n,s):\n d=[-n,-n];d[s]=0\n for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n return d[s]\nimport math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",
    "complexity": "np",
    "problem": "1463_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,math"
}
{
    "src": "n,m=map(int, input().split())\nout=[n]\ni=n-1\nm-=1\nfor _ in range(n-1):\n    if m%2:\n        out.append(i)\n    else:\n        out=[i]+out\n    \n    m//=2\n    i-=1\n\nfor i in out:\n    print(i, end=\" \")\nprint()\n",
    "complexity": "np",
    "problem": "0513_B1",
    "from": "CODEFORCES",
    "tags": "brute force"
}
{
    "src": "class edge(object):\n\tdef __init__(self,ne,to,fl):\n\t\tself.ne=ne\n\t\tself.to=to\n\t\tself.fl=fl\n\ndef add(x,y,z):\n\tglobal tot\n\ttot+=1\n\te.append(edge(he[x],y,z))\n\the[x]=tot\n\ndef addedge(x,y,z):\n\tadd(x,y,z)\n\tadd(y,x,0)\n\ndef bfs():\n\tglobal deep\n\tdeep=[0 for i in range(T+1)]\n\tq=[]\n\tq.append(S)\n\tdeep[S]=1\n\twhile (len(q)>0):\n\t\tx=q[0]\n\t\tdel(q[0])\n\t\ti=he[x]\n\t\twhile (i):\n\t\t\ty=e[i].to\n\t\t\tif ((deep[y]==0)and(e[i].fl!=0)):\n\t\t\t\tdeep[y]=deep[x]+1\n\t\t\t\tq.append(y)\n\t\t\ti=e[i].ne\n\treturn deep[T]!=0\n\ndef dfs(x,flow):\n\tglobal deep\n\tif ((x==T)or(flow==0)):\n\t\treturn flow\n\tused=0\n\ti=he[x]\n\twhile (i):\n\t\ty=e[i].to\n\t\tif ((deep[y]==deep[x]+1)and(e[i].fl!=0)):\n\t\t\tnow=dfs(y,min(flow-used,e[i].fl))\n\t\t\tused+=now\n\t\t\te[i].fl-=now\n\t\t\te[i^1].fl+=now\n\t\t\tif (flow==used):\n\t\t\t\tbreak;\n\t\ti=e[i].ne\n\tif (used==0):\n\t\tdeep[x]=-1\n\treturn used\n\ndef dinic():\n\tres=0\n\twhile (bfs()):\n\t\tres+=dfs(S,INF)\n\treturn res\n\nn,m=map(int,input().split())\nans=0\nweight=[0]+list(map(int,input().split()))\n\ne=[0,0]\ntot=1\nS=n+m+1\nT=S+1\nhe=[0 for i in range(T+1)]\nINF=1000000007\n\nfor i in range(1,n+1):\n\taddedge(S,i,weight[i]);\nfor i in range(1,m+1):\n\tx,y,w=map(int,input().split())\n\taddedge(n+i,T,w)\n\taddedge(x,n+i,INF)\n\taddedge(y,n+i,INF)\n\tans+=w\nans-=dinic()\nprint(ans)",
    "complexity": "cubic",
    "problem": "1082_G",
    "from": "CODEFORCES",
    "tags": "flows,graphs"
}
{
    "src": "import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nINF = 10**9\n\nn, m = [int(item) for item in input().split()]\ns = input().rstrip()\n\ncount = [[0] * m for _ in range(m)]\nord_a = ord(\"a\")\nfor c1, c2 in zip(s, s[1:]):\n    c1 = ord(c1) - ord_a\n    c2 = ord(c2) - ord_a\n    if c1 != c2:\n        count[c1][c2] += 1\n\nsum_of_subset = [[0] * (1 << m) for _ in range(m)]\nfor i in range(m):\n    for j in range(1 << m):\n        if j == 0:\n            continue\n        lsb = j & -j\n        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n\nadj_in_subset = [0] * (1 << m)\nfor i in range(1 << m):\n    for j in range(m):\n        if i & (1 << j):\n            adj_in_subset[i] += sum_of_subset[j][i]\n\ntotal_adj = adj_in_subset[-1]\ndp = [INF] * (1 << m)\ndp[0] = 0\n\nfor i in range(1 << m):\n    for j in range(m):\n        if i & 1 << j:\n            continue\n        not_i = ((1 << m) - 1) ^ i\n        val = dp[i] + (total_adj - adj_in_subset[i] - adj_in_subset[not_i])\n        dp[i | (1 << j)] = min(dp[i | (1 << j)], val)\nprint(dp[-1])",
    "complexity": "np",
    "problem": "1238_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp"
}
{
    "src": "import sys\ninput=sys.stdin.readline\n\ndef count_bits(x):\n    cnt=0\n    for i in range(n):\n        if((1<<i)&x):\n            cnt+=1\n    return(cnt)\n\nn=int(input())\na=[list(map(float,input().split())) for i in range(n)]\ndp=[0 for i in range(1<<n)] #Probabilty a particular permutation of (alive) fish are acheived.\ndp[-1]=1 #We start with all fish, so the probability they all together is 1(base case)\n#We will calculate the probability of acheiving a particular permutation of k alive fish from all possible permutations of k+1 alive fish for all values of k.\nfor mask in range((1<<n)-1,-1,-1):\n    val=count_bits(mask)\n    total=val*(val-1)//2 #Used to calculate the probability of choosing two fish among the alive fish. We will take the case the first fish eats the second fish(the opposite case is dealt again in another loop, won't increase efficiency much), and add to the new permutation the probability of obtaiining it from the current permutation.\n    for i in range(n):\n        if(mask&(1<<i)==0): #We can't choose a dead/eaten fish\n            continue\n        for j in range(n): #Second fish of the pair for the above choosen fish among all other alive fish\n            if(mask&(1<<j)==0 or i==j):\n                continue\n            dp[mask^(1<<j)]+=dp[mask]*a[i][j]/total #considering ith fish eats jth fish\nfor i in range(n):\n    print(dp[1<<i])\n",
    "complexity": "np",
    "problem": "0016_E",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,probabilities"
}
{
    "src": "import math;\ndef f(n,s):\n    d=[-n,-n];\n    d[s]=0\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n    return d[s]\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny+=x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))",
    "complexity": "np",
    "problem": "1463_F",
    "from": "CODEFORCES",
    "tags": "bitmasks,dp,math"
}
{
    "src": "def get_ans(x, a, n, m):\n\n    lim = 1<<m\n    match = lim-1\n    track = [-1 for i in range(lim)]\n\n    for i in range(n):\n        mask = 0\n        for j in range(m):\n            if(a[i][j] >= x):\n                mask |= 1 << j\n        track[mask] = i\n\n    for i in range(lim):\n        for j in range(lim):\n            if(i|j == match and track[i] != -1 and track[j] != -1):\n                return track[i], track[j]\n    \n    return -1, -1\n\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\n\nlo = 0\nhi = 1000000000\nwhile(lo < hi-1):\n    mid = (lo+hi)/2\n    i, j = get_ans(mid,a,n,m)\n    if(i == -1):\n        hi = mid-1\n    else:\n        lo = mid\n\ni,j = get_ans(hi,a,n,m)\nif(i != -1):\n    print(\"{} {}\".format(i+1,j+1))\nelse:\n    i,j = get_ans(lo,a,n,m)\n    print(\"{} {}\".format(i+1,j+1))\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "'''input\n6 5\n5 0 3 1 2\n1 8 9 1 3\n1 2 3 4 5\n9 1 0 3 7\n2 3 0 6 3\n6 4 1 7 0\n'''\n# A coding delight\nfrom sys import stdin, stdout\nimport gc\ngc.disable()\ninput = stdin.readline\nfrom collections import defaultdict\n\n\ndef check(num):\n\tbitmask = set()\n\tfor i in range(n):\n\t\tb = 0\n\t\tfor j in range(m):\n\t\t\tif arr[i][j] >= num:\n\t\t\t\tb ^= 1 << j\n\t\tbitmask.add(b)\n\t# print(num, bitmask)\n\ttarget = 2** m  - 1\n\tfor i in bitmask:\n\t\tfor j in bitmask:\n\t\t\tif i | j ==  target:\n\t\t\t\treturn True\n\treturn False\n\n\n# main starts\nn, m = list(map(int, input().split()))\narr = []\nfor _ in range(n):\n\tarr.append(list(map(int, input().split())))\n\n# print(check(3))\n\nstart = 0\nend = 10 ** 9\nans = -1\nwhile start <= end:\n\tmid = (start + end) // 2\n\tif check(mid):\n\t\tans = mid\n\t\tstart = mid + 1\n\telse:\n\t\tend = mid - 1\n\nbitmask = defaultdict(list)\nfor i in range(n):\n\tb = 0\n\tfor j in range(m):\n\t\tif arr[i][j] >= ans:\n\t\t\tb  += 1<< j\n\tbitmask[b].append(i + 1)\ntarget = 2 ** m - 1\nfor i in bitmask:\n\tfor j in bitmask:\n\t\tif i | j == target:\n\t\t\tprint(bitmask[i][0], bitmask[j][0])\n\t\t\texit()\n",
    "complexity": "np",
    "problem": "1288_D",
    "from": "CODEFORCES",
    "tags": "binary search,bitmasks,dp"
}
{
    "src": "import sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\nmod = 998244353\na.sort()\ndp = [1] + [0] * n\nfor i in range(1, n + 1):\n    x, pt = 1, i - 2\n    while pt >= 0 and 2 * a[pt] > a[i - 1]:\n        x = x * (n - pt - 2) % mod\n        pt -= 1\n    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod\nprint(dp[-1])",
    "complexity": "cubic",
    "problem": "1437_F",
    "from": "CODEFORCES",
    "tags": "combinatorics,dp,math,two pointers"
}
{
    "src": "N = int(input())\nX = list(map(int, input().split()))\nfrom collections import defaultdict\ndp1 = defaultdict(lambda :-1)\nM=1001\ndef ec(i,j):\n    return i*M+j\n\nfor i in range(N):\n    dp1[ec(i,i+1)] = X[i]\nfor i in range(2, N+1):\n    for j in range(N-i+1):\n        for k in range(1, i):\n            u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)]\n            if u != -1 and v != -1 and u == v:\n                dp1[ec(j,j+i)] = u+1\n                break\n\ndp2 = [10**18]*(N+1)\ndp2[0] = 0\nfor i in range(N):\n    for j in range(i+1):\n        if dp1[ec(j,i+1)] == -1:\n            continue\n        dp2[i+1] = min(dp2[i+1], dp2[j]+1)\nprint(dp2[-1])\n",
    "complexity": "cubic",
    "problem": "1312_E",
    "from": "CODEFORCES",
    "tags": "dp,greedy"
}
{
    "src": "r,g,b=map(int,input().split())\ns1=[int(x) for x in input().split()]\ns2=[int(x) for x in input().split()]\ns3=[int(x) for x in input().split()]\ns1.sort()\ns2.sort()\ns3.sort()\ns1=s1[::-1]\ns2=s2[::-1]\ns3=s3[::-1]\ns1=[0]+s1\ns2=[0]+s2\ns3=[0]+s3\n\ndp=[]\nfor i in range(r+5):\n    H=[]\n    for j in range(g+5):\n        h=[]\n        for k in range(b+5):\n            h.append(0)\n        H.append(h)\n    dp.append(H)\n\n\nfor i in range(0,r+1):\n    for j in range(0,g+1):\n        for k in range(0,b+1):\n            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0\n            if(i-1>=0 and j-1>=0):\n                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])\n            if(i-1>=0 and k-1>=0):\n                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])\n            if(k-1>=0 and j-1>=0):\n                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])\n            if(i-1>=0):\n                t4 = dp[i-1][j][k]\n            if(j-1>=0):\n                t5 = dp[i][j-1][k]\n            if(k-1>=0):\n                t6 = dp[i][j][k-1]\n\n            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)\n\nprint(dp[r][g][b])\n\n",
    "complexity": "cubic",
    "problem": "1398_D",
    "from": "CODEFORCES",
    "tags": "dp,greedy,sortings"
}
