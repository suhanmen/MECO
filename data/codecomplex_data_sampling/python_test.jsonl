{"src": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nimport io\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nimport threading\n\n#sys.setrecursionlimit(300000)\n#threading.stack_size(10**8)\n\nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------game starts now-----------------------------------------------------\n#mod = 9223372036854775807  \nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: max(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nclass SegmentTree1:\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n \n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n \n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n \n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n \n \nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n \n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n#-------------------------------------------------------------------------\nprime = [True for i in range(11)] \nprime[0]=prime[1]=False\n#pp=[0]*10\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c=0\n    while (p <= n): \n          \n        if (prime[p] == True):\n            c+=1\n            for i in range(p, n+1, p): \n                #pp[i]=1\n                prime[i] = False\n        p += 1\n#-----------------------------------DSU--------------------------------------------------\nclass DSU:\n    def __init__(self, R, C):\n        #R * C is the source, and isn't a grid square\n        self.par = range(R*C + 1)\n        self.rnk = [0] * (R*C + 1)\n        self.sz = [1] * (R*C + 1)\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        if self.rnk[xr] < self.rnk[yr]:\n            xr, yr = yr, xr\n        if self.rnk[xr] == self.rnk[yr]:\n            self.rnk[xr] += 1\n\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\n    def top(self):\n        # Size of component at ephemeral \"source\" node at index R*C,\n        # minus 1 to not count the source itself in the size\n        return self.size(len(self.sz) - 1) - 1\n#---------------------------------Lazy Segment Tree--------------------------------------\n# https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp\nclass LazySegTree:\n    def __init__(self, _op, _e, _mapping, _composition, _id, v):\n        def set(p, x):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            _d[p] = x\n            for i in range(1, _log + 1):\n                _update(p >> i)\n \n        def get(p):\n            assert 0 <= p < _n\n            p += _size\n            for i in range(_log, 0, -1):\n                _push(p >> i)\n            return _d[p]\n \n        def prod(l, r):\n            assert 0 <= l <= r <= _n\n \n            if l == r:\n                return _e\n \n            l += _size\n            r += _size\n \n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push(r >> i)\n \n            sml = _e\n            smr = _e\n            while l < r:\n                if l & 1:\n                    sml = _op(sml, _d[l])\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    smr = _op(_d[r], smr)\n                l >>= 1\n                r >>= 1\n \n            return _op(sml, smr)\n \n        def apply(l, r, f):\n            assert 0 <= l <= r <= _n\n            if l == r:\n                return\n \n            l += _size\n            r += _size\n \n            for i in range(_log, 0, -1):\n                if ((l >> i) << i) != l:\n                    _push(l >> i)\n                if ((r >> i) << i) != r:\n                    _push((r - 1) >> i)\n \n            l2 = l\n            r2 = r\n            while l < r:\n                if l & 1:\n                    _all_apply(l, f)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    _all_apply(r, f)\n                l >>= 1\n                r >>= 1\n            l = l2\n            r = r2\n \n            for i in range(1, _log + 1):\n                if ((l >> i) << i) != l:\n                    _update(l >> i)\n                if ((r >> i) << i) != r:\n                    _update((r - 1) >> i)\n \n        def _update(k):\n            _d[k] = _op(_d[2 * k], _d[2 * k + 1])\n \n        def _all_apply(k, f):\n            _d[k] = _mapping(f, _d[k])\n            if k < _size:\n                _lz[k] = _composition(f, _lz[k])\n \n        def _push(k):\n            _all_apply(2 * k, _lz[k])\n            _all_apply(2 * k + 1, _lz[k])\n            _lz[k] = _id\n \n        _n = len(v)\n        _log = _n.bit_length()\n        _size = 1 << _log\n        _d = [_e] * (2 * _size)\n        _lz = [_id] * _size\n        for i in range(_n):\n            _d[_size + i] = v[i]\n        for i in range(_size - 1, 0, -1):\n            _update(i)\n \n        self.set = set\n        self.get = get\n        self.prod = prod\n        self.apply = apply\n \n \nMIL = 1 << 20\n \n \ndef makeNode(total, count):\n    # Pack a pair into a float\n    return (total * MIL) + count\n \n \ndef getTotal(node):\n    return math.floor(node / MIL)\n \n \ndef getCount(node):\n    return node - getTotal(node) * MIL\n \n \nnodeIdentity = makeNode(0.0, 0.0)\n \n \ndef nodeOp(node1, node2):\n    return node1 + node2\n    # Equivalent to the following:\n    return makeNode(\n        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)\n    )\n \n \nidentityMapping = -1\n \n \ndef mapping(tag, node):\n    if tag == identityMapping:\n        return node\n    # If assigned, new total is the number assigned times count\n    count = getCount(node)\n    return makeNode(tag * count, count)\n \n \ndef composition(mapping1, mapping2):\n    # If assigned multiple times, take first non-identity assignment\n    return mapping1 if mapping1 != identityMapping else mapping2\n#---------------------------------Pollard rho--------------------------------------------\ndef memodict(f):\n    \"\"\"memoization decorator for a function taking a single argument\"\"\"\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n \n    return memodict().__getitem__\n \n \ndef pollard_rho(n):\n    \"\"\"returns a random factor of n\"\"\"\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n \n    s = ((n - 1) & (1 - n)).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = (p * p) % n\n            if p == 1:\n                return math.gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                x, y = i, (i * i + 1) % n\n                f = math.gcd(abs(x - y), n)\n                while f == 1:\n                    x, y = (x * x + 1) % n, (y * y + 1) % n\n                    y = (y * y + 1) % n\n                    f = math.gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n \n \n@memodict\ndef prime_factors(n):\n    \"\"\"returns a Counter of the prime factorization of n\"\"\"\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n \n \ndef distinct_factors(n):\n    \"\"\"returns a list of all distinct factors of n\"\"\"\n    factors = [1]\n    for p, exp in prime_factors(n).items():\n        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]\n    return factors\n \n \ndef all_factors(n):\n    \"\"\"returns a sorted list of all distinct factors of n\"\"\"\n    small, large = [], []\n    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):\n        if not n % i:\n            small.append(i)\n            large.append(n // i)\n    if small[-1] == large[-1]:\n        large.pop()\n    large.reverse()\n    small.extend(large)\n    return small\n\n#---------------------------------Binary Search------------------------------------------\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res = n\n    while (left <= right):\n        mid = (right + left)//2\n        if (arr[mid] > key):\n            res=mid\n            right = mid-1\n        else:\n            left = mid + 1\n    return res\n\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=-1\n    while (left <= right):\n        mid = (right + left)//2\n        if (arr[mid] > key):\n            right = mid-1\n        else:\n            res=mid\n            left = mid + 1\n    return res\n#---------------------------------running code------------------------------------------\nt=1\n#t=int(input())\nfor _ in range (t):\n    n=int(input())\n    #n,m=map(int,input().split())\n    a=list(map(int,input().split()))\n    #b=list(map(int,input().split()))\n    #s=input()\n    #n=len(s)\n    twopow = [1]*(10**5+69)\n    for i in range(1, 10**5+69):\n        twopow[i] = (twopow[i-1] * 2) % mod\n    count = [0]*100069\n    for i in a:\n        count[i] += 1\n    multiples = [0]*100069\n    for i in range(1, 10**5+1):\n        for j in range(i, 10**5+1, i):\n            multiples[i] += count[j]\n    gcd_of = [0]*100069\n    for i in range(10**5, 0, -1):\n        gcd_of[i] = (twopow[multiples[i]] - 1) % mod\n        for j in range(2*i, 10**5+1, i):\n            gcd_of[i] -= gcd_of[j]\n    print(gcd_of[1] % mod)", "complexity": "np", "problem": "0803_F", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,number theory"}
{"src": "# https://codeforces.com/problemset/problem/1030/C\n\nimport sys\n\nlines = sys.stdin.readlines()\n\n\ndef read_a_num(line):\n    n = int(line.strip())\n    return n\n\n\ndef read_a_str(line):\n    line = line.strip()\n    return line\n\n\ndef check_ticket(digits):\n    for target in range(900):\n        seg_i = 0\n        seg_sum = 0\n        next_flag = False\n        for d in digits:\n            int_d = int(d)\n            if int_d > target:\n                next_flag = True\n                break\n            elif seg_sum + int_d > target:\n                if next_flag:\n                    break\n                next_flag = True\n                continue\n            elif int_d == target or seg_sum + int_d == target:\n                seg_i += 1\n                seg_sum = 0\n            else:\n                seg_sum += int_d\n\n        if next_flag:\n            continue\n\n        if seg_i >= 2 and seg_sum == 0:\n            return True\n\n    return False\n\n\ndigits = read_a_str(lines[1])\nif check_ticket(digits):\n    print(\"yes\")\nelse:\n    print(\"no\")\n", "complexity": "quadratic", "problem": "1030_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h \nfrom bisect import bisect_left\n\nfrom types import GeneratorType\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \nimport time\nstart_time = time.time()\n\nimport collections as col\nimport math, string\nfrom functools import reduce\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\n\n\"\"\"\nThe max XOR comes from finding the longest *distinct* lengths\nWithin those sets, find the longest distinct lengths again\nEtc\n\nSuppose the max is \n10011110010111\n\nAnd the min is\n00000101011010\n\nThen we have everything between\n\nSo the max would be\n11111111111111\n\nFill the bits greedily\nCan we fill bit one?\nCan we fill bit two with that subset? Etc\n\nAre L and R distinct lengths? If not, substract the largest bit from each\nIf so, add that bit to our answer, and subtract the largest bit from R\nRepeat\n\"\"\"\n\n\ndef solve():\n    L, R = getInts()\n    if L == R:\n        return 0\n    l = len(bin(L)[2:])\n    r = len(bin(R)[2:])\n    while l == r:\n        L -= pow(2,r-1)\n        R -= pow(2,r-1)\n        l = len(bin(L)[2:])\n        r = len(bin(R)[2:])\n    return pow(2,r)-1\n\n#for _ in range(getInt()):    \nprint(solve())\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nfrom itertools import accumulate\nfrom functools import lru_cache\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\na = val()\nb = val()\n\nn = len(str(a))\n\na = [int(i) for i in str(a)]\na.sort()\nif len(str(b)) > n:\n    \n    print(*sorted(a, reverse = 1), sep = '')\n    exit()\n\nb = str(b)\nb = [int(i) for i in b]\n\n\ndef makenum(s):return int(''.join(str(e) for e in s))\n\ndef givemax(a, b):\n    if len(a) > len(b):return a\n    elif len(b) > len(a):return b\n    else:\n        for j in range(len(a)):\n            if a[j] > b[j]:return a\n            elif b[j] > a[j]:return b\n        return a\n\n\n@lru_cache(None)\ndef dp(l, equal = 1):\n\n    if len(l) == 1:return str(-float('inf')) if l[0] > b[-1] and equal else str(l[0])\n    if not equal:return ''.join(str(e) for e in sorted(l, reverse = 1))\n    ans = ''\n    l = list(l)\n    curr = b[n - len(l)]\n    for i in range(len(l)):\n        if l[i] < curr and dp(tuple(l[:i] + l[i + 1:]), 0) != '-inf':\n            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 0))\n        elif l[i] == curr and dp(tuple(l[:i] + l[i + 1:]), 1) != '-inf':\n            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 1))\n\n    return str(ans)\n\nprint(dp(tuple(a), 1))", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n = int(input())\nl = sorted(map(int, input().split()))\nseen = [False] * n\nres = 0\nfor i in range(n):\n    if seen[i]: continue\n    res += 1\n    for j in range(i, n):\n        seen[j] |= l[j] % l[i] == 0\nprint(res)", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n = int(input())\n    p = [list(map(float,input().split())) for _ in range(n)]\n    y = 1<<n\n    dp = [[0]*y for _ in range(n)]\n    # dp[i][j] is prob of 0 win when j fought and i left\n    dp[0][y-1] = 1\n    for i in range(y-2,-1,-1):\n        mask = 1\n        for j in range(n):\n            if not mask&i:\n                mask <<= 1\n                continue\n            mask1 = 1\n            for k in range(n):\n                if i&mask1:\n                    mask1 <<= 1\n                    continue\n                dp[j][i] = max(dp[j][i],\n                    dp[j][i|mask1]*p[j][k]+dp[k][i|mask1]*p[k][j])\n                mask1 <<= 1\n            mask <<= 1\n    print(max(dp[i][1<<i] for i in range(n)))\n\n# Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()", "complexity": "np", "problem": "0678_E", "from": "CODEFORCES", "tags": "bitmasks,dp,math,probabilities"}
{"src": "n = int(raw_input())\na = sorted(list(map(int, raw_input().split())))\nduplicates = {}\nd = None\ndelta = 0\nfor i, el in enumerate(a, 1):\n    if el not in duplicates:\n        duplicates[el] = 0\n    else:\n        d = el\n        duplicates[el] += 1\n    min_value = i-1\n    delta += el - min_value\nif sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates):\n    print('cslnb')\nelif delta == 0:\n    print('cslnb')\nelif delta % 2 == 1:\n    print('sjfnb')\nelse:\n    print('cslnb')", "complexity": "linear", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "s=input().strip()\ns=s+s\n\nn=len(s)\nan=1\nm=1\n#print(s)\nfor i in range(1,n):\n    if s[i]!=s[i-1]:\n        m+=1\n        an = max(an, m)\n    else:\n        an = max(an, m)\n        m=1\n    #print(an)\nprint(min(an,n//2))", "complexity": "linear", "problem": "1025_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "s = input()\nfor i in range(len(s), 0, -1):\n\tfor j in range(len(s) - i + 1):\n\t\tif s[j: j + i] in s[j + 1:]:\n\t\t\tprint(i)\n\t\t\texit()\nprint(0)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "input()\na=list(map(int,input().split()))\nn=len(a)\nu=n\nfor i in range(n):\n\tj=i\n\tk=0\n\twhile a[j]>0:\n\t\tk+=1\n\t\tt=j\n\t\tj=a[j]-1\n\t\ta[t]=0\n\tif k>0:\n\t\tu+=1-k%2\ns='Petr'\nif u%2>0:\n\ts='Um_nik'\nprint(s)\n", "complexity": "nlogn", "problem": "0986_B", "from": "CODEFORCES", "tags": "combinatorics,math"}
{"src": "from collections import defaultdict\nfrom sys import stdin\ninput=stdin.readline\nt=int(input())\nfor _ in range(t):\n  n=int(input())\n  a=list(map(int,input().split()))\n  dd=defaultdict(int)\n  for i in range(n):\n    dd[a[i]]+=1\n  l=[]\n  for aa in a:\n    if dd[aa]>=2:\n      l.append(aa)\n      dd[aa]-=2\n  l.sort()\n  ans=[-1,-1,-1,-1]\n  m=10**18\n  for i in range(len(l)-1):\n    x=(4*(l[i]+l[i+1])**2)/(l[i]*l[i+1])\n    if x<m:\n      ans=[l[i],l[i],l[i+1],l[i+1]]\n      m=x\n  print(*ans)", "complexity": "nlogn", "problem": "1027_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "n=int(input())\nif n<3:\n    print(n)\nelse:\n    if n%2!=0:\n        print(n*(n-1)*(n-2))\n    else:\n        if n==6:\n            print(60)\n        elif n%3==0:\n            print((n-1)*(n-2)*(n-3))\n        else:\n            print(n*(n-1)*(n-3))\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\nd = {\"purple\":\"Power\", \"green\":\"Time\", \"blue\":\"Space\",\"orange\":\"Soul\", \"red\":\"Reality\",\"yellow\":\"Mind\"}\n\ni = int(input())\nl = []\nfor x in range(i):\n    d.pop(input())\n\nprint(len(d))\nfor i in d.values() : print(i)", "complexity": "constant", "problem": "0987_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "k = int(input())\nn = 1\nup_bnd = 9\nwhile(k > up_bnd):\n    n += 1\n    up_bnd += (9*n)*(10**(n-1))\nlow_bnd = 0\nlb_val = 0\nfor i in range(1, n):\n    low_bnd += (9*i)*(10**(i-1))\n    lb_val = (lb_val*10)+9\nnum = int((k-low_bnd)/n) + lb_val\nrm = (k-low_bnd) % n\nif(rm != 0):\n    num += 1\nans = 0\nif(rm == 0):\n    ans = num % 10\nelse:\n    for i in range(n-rm+1):\n        j = (num % 10)\n        num = int(num/10)\n        ans = j\nprint(int(ans))", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import math\nsend=input()\nrcv=input()\nd={}\nd['+']=0\nd['-']=0\nfor i in range(len(send)):\n\td[send[i]]=d[send[i]]+1\n\nflag=1\nc=0\nfor i in range(len(rcv)):\n\tif rcv[i] in d:\n\t\tif d[rcv[i]]==0:\n\t\t\tflag=0\n\t\telse:\n\t\t\td[rcv[i]]=d[rcv[i]]-1\ntot=d['+']+d['-']\ntotComb=2**tot\nn=tot\nr=d['+']\nnpr=math.factorial(n)/math.factorial(n-r)\nreqComb=npr/math.factorial(r)\n#print(totComb)\n#print(reqComb)\nif flag==0:\n\tprint('0.00000000')\nelse:\n\tprint(float(reqComb)/totComb)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "s = input()\n\n\ndef check_x(mid):\n    ans = 'no'\n    d = {}\n    for i in range(len(s)-mid+1):\n        #print(s[i:i+mid])\n        if s[i:i+mid] in d.keys():\n            ans = 'yes'\n            break\n        d[s[i:i+mid]] = 1\n        \n    return ans\n\n    \nl = 0\nr = len(s) - 1\nwhile r-l > 1:\n    mid = (r+l) // 2\n\n    ans = check_x(mid)\n    if ans == 'yes':\n        l = mid\n    else:\n        r = mid\n        \nif check_x(r) == 'yes':\n    print(r)\nelse:\n    print(l)\n        ", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "n = int(input())\ni = 1\nwhile n:\n    if i > 1:\n        print(' ', end='')\n    if n == 3:\n        print(*[i, i, i * 3], end='')\n        break\n    print(' '.join([str(i)] * ((n + 1) // 2)), end='')\n    i <<= 1\n    n >>= 1\n\nprint()\n", "complexity": "nlogn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "def detect_cycle(n,edges):\n        visited = [False]*n\n        stack = []\n        color = [0]*n\n        for v in range(n):\n            if not visited[v]:\n                if dfs_visit(v,edges,visited,stack,color):\n                    return stack\n        return None \n     \ndef dfs_visit(v,edges,visited,stack,color):\n        visited[v] = True\n        stack.append(v)\n        color[v] = 1\n        for u in edges[v]:\n            if not visited[u]:\n               if dfs_visit(u,edges,visited,stack,color):\n                   return True\n                    \n            elif color[u] == 1:\n                stack.append(u)\n                return True\n        \n        color[v] = 2\n        stack.pop(stack.index(v))\n        return False\n     \nif __name__ == '__main__':\n        n,m = map(int,input().split())\n        edges = [[] for i in range(n)]\n        for _ in range(m):\n            u,v  = map(int,input().split())\n            edges[u - 1].append(v - 1)\n     \n        inCycle = detect_cycle(n,edges)   \n        if inCycle:\n            possible = False\n            index = inCycle.index(inCycle[-1])\n            inCycle = inCycle[index:]\n            for v in range(len(inCycle) - 1):\n                edges[inCycle[v]].remove(inCycle[v + 1])\n                if detect_cycle(n,edges) is None:\n                    possible = True\n                    break\n                else:\n                    edges[inCycle[v]].append(inCycle[v + 1])\n        else: possible = True\nprint('YES' if possible else 'NO')\n", "complexity": "quadratic", "problem": "0915_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs"}
{"src": "def f(x): #including x\n\tdig, cnt = 1, 9\n\tans = 0\n\twhile dig != len(str(x)):\n\t\tans += dig * cnt\n\t\tdig += 1\n\t\tcnt *= 10\n\tans += (x - (cnt // 9) + 1) * dig\n\treturn ans\nk = int(input())\nl, r = 1, 1000000000000\nif k == 1:\n    print(1)\n    exit(0)\nwhile l < r:\n\tmid = (l + r + 1) >> 1\n\tif f(mid) < k:\n\t\tl = mid\n\telse:\n\t\tr = mid - 1\nk -= f(l)\nl += 1\nprint(str(l)[k - 1])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "for _ in range(int(input())):\n    n,m=map(int,input().split())\n\n    a=[[int(x) for x in input().split()] for j in range(n)]\n\n    x=[[a[i][j] for i in range(n)] for j  in range(m)]\n    x.sort(key=lambda xx:-max(xx))\n    dp=[[0 for i in range(1<<n)] for j in range(m+1)]\n    an=0\n\n    for i in range(m):\n        for prev in range(1<<n):\n            for pres in range(1<<n):\n\n                for j in range(n):\n\n                    ma=0\n                    if prev^pres!=prev+pres:\n                        continue\n                    for st in range(n):\n\n                        if pres&(1<<st):\n                            ma+=x[i][(st+j)%n]\n\n                    dp[i+1][pres^prev]=max(dp[i+1][pres^prev],dp[i][prev]+ma)\n\n    print(dp[m][(1<<n)-1])", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \np0 = getIntList()\np1 = getIntList()\np2 = getIntList()\n#print(N)\n\nzp = [p0, p1, p2]\n\n\n\ndef getpath( p0, p1):\n    if p0[0] < p1[0]:\n        sp = 1\n    elif p0[0] > p1[0]:\n        sp = -1\n    else:\n        sp =0\n    zz = [tuple(p0), tuple(p1)]\n    if sp!=0:\n        for x in range(p0[0], p1[0]+ sp, sp):\n            tp = (x, p0[1])\n            zz.append(tp)\n    if p0[1] < p1[1]:\n        sp = 1\n    elif p0[1] > p1[1]:\n        sp = -1\n    else:\n        sp = 0\n    if sp!=0:\n        for y in range(p0[1], p1[1] + sp, sp):\n            tp = (p1[0], y)\n            zz.append(tp)\n    return zz\n\nnr = 1000000;\nzr = set()\nfor i in range(3):\n    for j in range(3):\n        cx = zp[i][0]\n        cy = zp[j][1]\n        cp = (cx, cy)\n        z1 = getpath(cp, zp[0])\n        z2 =getpath(cp, zp[1])\n        z3 =getpath(cp, zp[2])\n        \n        z0 = z1+z2+z3\n        s1 = set(z0)\n        dprint(cp,s1)\n        if len(s1) < nr:\n            nr = len(s1)\n            zr = s1\n        \nprint(len(zr))\nfor x in zr:\n    print(x[0], x[1])\n\n\n\n", "complexity": "constant", "problem": "1086_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "'''input\n3\n5 2\nBGGGG\n5 3\nRBRGR\n5 5\nBBBRR\n'''\nimport sys\nfrom collections import defaultdict as dd\n\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\n\nfor _ in range(int(input())):\n\tn,k = ri()\n\ta = input()\n\trgb= [0 for i in range(n)]\n\tgbr= [0 for i in range(n)]\n\tbrg= [0 for i in range(n)]\n\n\tfor i in range(n):\n\t\tif i%3==0:\n\t\t\tif a[i]!=\"R\":\n\t\t\t\trgb[i]+=1\n\t\tif i%3==1:\n\t\t\tif a[i]!=\"G\":\n\t\t\t\trgb[i]+=1\n\t\tif i%3==2:\n\t\t\tif a[i]!=\"B\":\n\t\t\t\trgb[i]+=1\n\n\tfor i in range(n):\n\t\tif i%3==0:\n\t\t\tif a[i]!=\"G\":\n\t\t\t\tgbr[i]+=1\n\t\tif i%3==1:\n\t\t\tif a[i]!=\"B\":\n\t\t\t\tgbr[i]+=1\n\t\tif i%3==2:\n\t\t\tif a[i]!=\"R\":\n\t\t\t\tgbr[i]+=1\n\n\tfor i in range(n):\n\t\tif i%3==0:\n\t\t\tif a[i]!=\"B\":\n\t\t\t\tbrg[i]+=1\n\t\tif i%3==1:\n\t\t\tif a[i]!=\"R\":\n\t\t\t\tbrg[i]+=1\n\t\tif i%3==2:\n\t\t\tif a[i]!=\"G\":\n\t\t\t\tbrg[i]+=1\n\n\tfor i in range(1,n):\n\t\trgb[i]+=rgb[i-1]\n\t\tbrg[i]+=brg[i-1]\n\t\tgbr[i]+=gbr[i-1]\n\n\n\tans = 999999999\n\t#print(rgb,gbr,brg)\n\tfor i in range(k-1,n):\n\t\t#print(i,i-k)\n\t\tif i-k ==-1:\n\t\t\tans = min(ans,rgb[i],gbr[i],brg[i])\n\t\telse:\n\t\t\tans = min(ans, rgb[i]- rgb[i-k] , gbr[i]- gbr[i-k], brg[i]- brg[i-k] )\n\n\tprint(ans)\n\n\n\n\n\n\n", "complexity": "linear", "problem": "1196_D1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from collections import Counter\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = map(int, input().split())\nmod = 998244353\nd = Counter(a)\nd[0] = 0\nb = list(d.items())\nb.sort()\nm = len(b)\nba = [0] * m\ncn = [0] * (m + 1)\nk = h = 0\nfor i, x in enumerate(b):\n    while h < m and x[0] >= b[h][0] * 2:\n        h += 1\n    ba[i] = h - 1\n    while k < m and x[0] * 2 > b[k][0]:\n        k += 1\n    cn[k] += x[1]\nfor i in range(m):\n    cn[i+1] += cn[i]\ndp = [0] * m\ndp[0] = 1\nb = [x[1] for x in b]\nfor i in range(n):\n    ndp = [0] * m\n    for j in range(1, m):\n        if cn[j] >= i - 1:\n            ndp[j] = dp[j] * (cn[j] - i + 1) % mod\n        dp[j] += dp[j-1]\n        if dp[j] >= mod:\n            dp[j] -= mod\n    for j in range(1, m):\n        ndp[j] += dp[ba[j]] * b[j]\n        ndp[j] %= mod\n    dp = ndp\nprint(sum(dp) % mod)", "complexity": "cubic", "problem": "1437_F", "from": "CODEFORCES", "tags": "combinatorics,dp,math,two pointers"}
{"src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\ndef main():\n    # mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n    tc=1\n    for _ in range(tc):\n        \n        s=2*rs()+\"333\"\n        le=(len(s)-3)//2\n        a=[]\n        for i in s:\n            if i=='b':\n                a.append(0)\n            if i=='w':\n                a.append(1)\n            if i=='3':\n                a.append(3)\n        pehla=[0,1]*len(s)\n        \n        doosra=[1,0]*len(s)\n        # print(*a)\n        # print(*pehla)\n        # print(*doosra)\n        k=[0]*len(s)\n        for i in range(len(s)):\n            if a[i]==pehla[i]:\n                k[i]=1\n        ans=0\n        t=0\n        for i in k:\n            if i==1:\n                t+=1\n                # print(t)\n            else:\n                ans=max(t,ans)\n                t=0\n        # print(*k)\n        k=[0]*len(s)\n        for i in range(len(s)):\n            if a[i]==doosra[i]:\n                k[i]=1\n        \n        t=0\n        for i in k:\n            if i==1:\n                t+=1\n                # print(t)\n            else:\n                ans=max(t,ans)\n                t=0\n        # print(*k)\n        \n        print(min(le,ans))\n        \n                    \n                \n        \n        \n            \n                \n        \n\n            \n        \n\n               \n            \n        \n              \n                \n        \n        \n            \n        \n        \n            \n            \n        \n        \n                \n                \n                \n                \n            \n        \n        \n            \n           \n        \n            \n                    \n\n                                 \n                \n                \n        \n\n                \n        \n        \n        \n            \n        \n        \n                \n            \n        \n        \n                    \n        \n        \n        \n            \n                    \n            \n\n                \n            \n            \n                \n            \n                \n            \n            \n            \n            \n                \n            \n        \n        \n        \n        \n        \n        \n        \n                    \n        \n        \n        \n                \n                \n        \n            \n            \n            \n        \n\n                    \n        \n                \n        \n        \n                        \n        \n                            \n\n        \n\n                \n            \n        \n\n                \n            \n                    \n                \n                \n        \n        \n         \n        \n\n                        \n                            \n                \n        \n                            \n                    \n\n                \n            \n        \n                \n            \n                \n        \n        \n        \n                             \n        \n            \n        \n        \n            \n                        \n                        \n                    \n            \n        \n        \n        \n        \n        \n                        \n       \n\n        \n                           \n        \n        \n        \n            \n        \n        \n        \n                      \n\n      \n                            \n            \n        \n        \n            \n            \n            \n            \n            \n        \n        \n        \n            \n        \n        \n        \n            \n        \n        \n        \n        \n            \n            \n        \n        \n        \n        \n        \n        \n        \n                \n                \n                    \n        \n        \n            \n            \n        \n                \n            \n            \n        \n        \n        \n        \n                \n        \n            \n        \n                \n        \n        \n            \n        \n       \n            \n\n                \n        \n        \n        \n   \n            \n        \n        \n        \n        \n            \n        \n                \n        \n        \n        \n            \n            \n        \n        \n            \n        \n        \n\n        \n        \n            \n        \n        \n            \n        \n                        \n\n        \n        \n            \n     \n        \n        \n            \n        \n        \n                \n            \n        \n        \n        \n                \n            \n        \n\n            \n             \n        \n            \n        \n        \n        \n                \n        \n            \n        \n        \n        \n        \n                \n        \n        \n            \n        \n        \n        \n        \n                \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    ", "complexity": "linear", "problem": "1025_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "from __future__ import division\nfrom sys import stdin, stdout\nfrom math import ceil\n\ndef write(x):\n    stdout.write(str(x) + \"\\n\")\n\n\nn, k = map(int, stdin.readline().split())\n\nred = 2 * n\n\ngreen = 5 * n\n\nblue = 8 * n\n\n\nneed = int(ceil(red / k)) + int(ceil(green / k)) + int(ceil(blue / k))\n\nwrite(need)\n", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nn = int(input())\nabove = n // 3\nbelow = n - above\nfor i in range(above):\n    print(2 * i + 1, 3)\nfor i in range(below):\n    print(i, 0)\n", "complexity": "linear", "problem": "1067_C", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "n,k=map(int,input().split())\na=list(map(int,input().split()))\nd={}\nfor chr in a:\n     if chr not in d:\n        d[chr]=1\n     else:\n        d[chr]+=1\np=list(d.values())\nz=k//n\nif z==0 :\n     print(0)\nelse:\n     o=[]\n     if len(a)>=n:\n        o.append(1)\n     for i in range(2,z+1):\n         c=0\n         for j in range(len(p)):\n             c+=p[j]//i\n         if c>=n:\n             o.append(i)\n     print(max(o))", "complexity": "nlogn", "problem": "1011_B", "from": "CODEFORCES", "tags": "binary search,brute force,implementation"}
{"src": "\t# https://vjudge.net/contest/381017#problem/W\n\nx=input();l=len(x);m=0\nfor i in range(l-1):\n    f=i\n    while 1 : \n        idx = x[f+1:].find(x[f])         \n        if idx == -1 :\n            break\n        else:\n            idx += f+1 ; c=ans=0\n            for j in range(idx , l) :\n               if x[j] == x[i+c]:\n                    ans+=1\n                    c+=1  \n               else:\n                   break\n               \n            if m < ans :\n                m=ans\n            f = idx              \nprint(m)\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "a, b  = map(int, input().split())\n\nk = 2**(a^b).bit_length()-1\nprint(k)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n=int(input())\ns=list()\nfor i in range(n):\n    x=input()\n    s.append(x)\na=sorted(s,key=len)\nc=1\nfor i in range(n-1):\n    if(a[i] not in a[i+1]):\n        c=0\n        break\nif(c==0):\n    print('NO')\nelse:\n    print('YES')\n    for i in range(n):\n        print(a[i])", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "def solve():\n    k = [int(x) for x in input().split(' ')]\n    k.sort()\n    if min(k) == 1:\n        return \"YES\"\n    elif k.count(2) >= 2:\n        return \"YES\"\n    elif k.count(3) == 3:\n        return \"YES\"\n    elif k == [2, 4, 4]:\n        return \"YES\"\n    return \"NO\"\n\n\nprint(solve())", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "import io, os, sys\n\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\ndef read():\n    n, m, k = map(int, input().split() )    \n\n    h = [list(map(int, input().split() ) )+ [float(\"+inf\")] for _ in range(n)]\n\n\n    v = [list(map(int, input().split() ) ) for _ in range(n-1)]\n    v.append( [float(\"+inf\")] * m )\n\n    solve(n, m, k, h, v)\n\ndef solve(n, m, k, h, v):\n    if k % 2:\n        ans = \"-1 \" * m\n        for _ in range(n):\n            print(ans)\n        return\n    \n    #inf = float(\"+inf\")\n\n    dp = [ [0] * (m+1) for _ in range(n+1)]\n\n    nxt = [ [0] * (m+1) for  _ in range(n+1)]\n\n    for _ in range(2, k + 1, 2):\n\n        for i in range(n):\n            for j in range(m):\n                l = 2 * h[i][j-1] + dp[i][j-1]\n                r = 2 * h[i][j]  + dp[i][j+1]\n                u = 2 * v[i-1][j] + dp[i-1][j]\n                d = 2 * v[i][j]  + dp[i+1][j]\n\n                hor = min(l, r)\n                ver = min(u, d)\n\n                nxt[i][j] = min(hor, ver)\n\n        dp, nxt = nxt, dp\n\n    for l in dp[:-1]:\n        print(\" \".join(map(str, l[:-1])))\n\n\n\n\nif __name__ == \"__main__\":\n    read()", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "a,b = map(int, input().split())\nx, y, z = map(int, input().split())\n\nans = max(0, 2*x+y-a)+max(0, 3*z+y-b)\nprint(ans)\n", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "a,b,c,n=map(int, input().split())\np=n-(a+b-c)\nif c>a or c>b or p<=0:\n    print(-1)\n    exit()\nif p<1:\n    print(-1)\nelse:\n    print(p)", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "MOD = int(1e9 + 7)\nx, k = map(int, input().split())\nif x == 0: print(0)\nelse: print((x * pow(2, k+1, MOD) - pow(2, k, MOD) + 1) % MOD)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "from math import *\nn = int(input())\nif n%2==0:\n    print(n-8,n-(n-8))\nelse:\n    print((n-9),n-(n-9))\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "a,b = (map(int,input().split()))\nprint((b+a-1)//a)\n", "complexity": "constant", "problem": "1036_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n= int(input())\nb = [int(_) for _ in input().split()]\nd = [[-1 if i != j else b[i] for i in range(n)] for j in range(n)]\nfor l in range(1, n):\n\tfor s in range(n-l):\n\t\te = s + l\n\t\tfor m in range(s, e):\n\t\t\tif d[s][m] == d[m+1][e] and d[s][m] != -1:\n\t\t\t\td[s][e] = d[s][m] + 1\na = [1]\nfor e in range(1, n):\n\tt = 4096\n\tfor s in range(e+1):\n\t\tif d[s][e] != -1:\n\t\t\tt = min(t, ((a[s-1]+1) if s > 0 else a[s]))\n\ta.append(t)\nprint(a[-1])\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "k = int(input())\na = 9\nfor i in range(1,12):\n    if k<=a*i:\n        a = (a//9)+(k//i)-1\n        if k%i!=0:\n            b = str(a+1)\n            c = (k%i)-1\n            print(b[c])\n        else:\n            b = str(a)\n            print(b[-1])\n        break\n    else:\n        k = k-a*i\n        a = a*10\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "a=str(input())\nb=str(input())\ncount=0\nal=len(a)\nbl=len(b)\ns=b[:bl-al+1].count('1')\nfor i in range(al-1):\n    if a[i]=='0':\n        count+=s\n    else:\n        count+=bl-al+1-s\n    s+=int(b[bl-al+i+1])-int(b[i])\n \nif a[-1]=='0':\n    count+=s\nelse:\n    count+=bl-al+1-s\nprint(count)", "complexity": "linear", "problem": "0608_B", "from": "CODEFORCES", "tags": "combinatorics,strings"}
{"src": "w,h,n=map(int,input().split())\nl=[-1]*(w+1)\nr=[-1]*(w+1)\nt=[-1]*(h+1)\nb=[-1]*(h+1)\n\nl[0]=0\nb[0]=0\nt[h]=h\nr[w]=w\n\n\nV=[0]*(n)\nH=[0]*(n)\nfor i in range(n):\n    line,index=input().split()\n    index=int(index)\n    if line==\"V\":\n        r[index]=w\n        V[i]=index\n    else:\n        t[index]=h\n        H[i]=index\n        \nleft=0\nmxw=0\nfor i in range(1,w+1):\n    if r[i]!=-1:\n        l[i]=left\n        r[left]=i\n        mxw=max(mxw,i-left)\n        left=i\n        \nbottom=0\nmxh=0\nfor i in range(1,h+1):\n    if t[i]!=-1:\n        b[i]=bottom\n        t[bottom]=i\n        mxh=max(mxh,i-bottom)\n        bottom=i\n        \nans=[0]*(n)\nans[n-1]=mxh*mxw\n\n\nfor i in range(n-1,0,-1):\n    if V[i]!=0:\n        mxw=max(mxw,r[V[i]]-l[V[i]])\n        r[l[V[i]]]=r[V[i]]\n        l[r[V[i]]]=l[V[i]]\n        \n    else:\n        mxh=max(mxh,t[H[i]]-b[H[i]])\n        b[t[H[i]]]=b[H[i]]\n        t[b[H[i]]]=t[H[i]]\n    \n    ans[i-1]=mxh*mxw\n\nfor i in range(n):\n    print(ans[i]) ", "complexity": "nlogn", "problem": "0527_C", "from": "CODEFORCES", "tags": "binary search,data structures,implementation"}
{"src": "import sys\ninput = sys.stdin.readline\n\nt=int(input())\nfor testcases in range(t):\n    n,m=map(int,input().split())\n    A=[list(map(int,input().split())) for i in range(n)]\n\n    B=[]\n    for j in range(m):\n        B.append([A[i][j] for i in range(n)])\n\n    B.sort(key=lambda x:max(x),reverse=True)\n\n    B=B[:n]\n\n    #print(B)\n    LEN=len(B)\n\n    if LEN==1:\n        print(sum(B[0]))\n\n    elif LEN==2:\n        ANS=0\n        for i in range(n):\n            A=0\n            for k in range(n):\n                A+=max(B[0][k],B[1][(i+k)%n])\n\n            ANS=max(ANS,A)\n\n        print(ANS)\n\n    elif LEN==3:\n\n        ANS=0\n        for i in range(n):\n            for j in range(n):\n                    \n                A=0\n                for k in range(n):\n                    A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n])\n\n                ANS=max(ANS,A)\n\n        print(ANS)\n\n    elif LEN==4:\n\n        ANS=0\n        for i in range(n):\n            for j in range(n):\n                for l in range(n):\n                    \n                    A=0\n                    for k in range(n):\n                        A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n],B[3][(l+k)%n])\n\n                    ANS=max(ANS,A)\n\n        print(ANS)\n        \n            \n\n    \n            \n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "M = 998244353 \nn = int(input())\nl = sorted(map(int, input().split()))[::-1]\nout = [0] * n\nbig = 0\nif l[0] >= 2 * l[1]:\n    out[1] = 1\n    big = 1\nfor i in range(2, n):\n    new = [0] * n\n    bigN = 0\n    for j in range(i):\n        if l[j] >= 2 * l[i]:\n            big += out[j]\n        else:\n            new[j] += out[j] * (i - 1)\n            new[j] %= M\n    \n    new[i] = big\n    bigN = (i * big) % M \n        \n    out = new\n    big = bigN\nprint((big + sum(out))%M)", "complexity": "cubic", "problem": "1437_F", "from": "CODEFORCES", "tags": "combinatorics,dp,math,two pointers"}
{"src": "import os,sys,math \nfrom io import BytesIO, IOBase\nfrom collections import defaultdict,deque,OrderedDict\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\ndef I():return (int(input()))\ndef In():return(map(int,input().split()))\ndef ln():return list(map(int,input().split()))\ndef Sn():return input().strip()\nBUFSIZE = 8192\n#complete the main function with number of test cases to complete greater than x\ndef find_gt(a, x):\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:            \n        return len(a)\n\ndef solve():\n    n=I()\n    points,l=[],[]\n    for i in range(n):\n        a,b=In()\n        l.append((a,b))\n        points.append(a)\n        points.append(b)\n    points.sort()\n    k=0 \n    d={}\n    l1=[]\n    for i in range(2*n):\n        if d.get(points[i],-1)==-1:\n            d[points[i]]=k\n            l1.append(points[i])\n            k+=1\n    # print(l1)\n    n1=len(d)\n    dp=[[0,0] for i in range(n1)]\n    for a,b in l:\n        dp[d[a]][0]+=1\n        dp[d[b]][1]-=1\n\n    ans={}\n    last=dp[0][0]\n    ans[last]=1\n    last+=dp[0][1]\n    for i in range(1,n1):\n        cnts=l1[i]-l1[i-1]-1\n        if ans.get(last,-1)!=-1:\n            ans[last]+=cnts\n        else:\n            ans[last]=cnts\n        last+=dp[i][0]\n        if ans.get(last,-1)!=-1:\n            ans[last]+=1\n        else:\n            ans[last]=1\n        last+=dp[i][1]\n    if ans.get(last,-1)!=-1:\n        ans[last]+=1\n    else:\n        ans[last]=1\n    for i in range(1,n+1):\n        print(ans.get(i,0),end=' ')\n    print()\n    pass\ndef main():\n    T=1\n    for i in range(T):\n        solve()\n        \nM = 998244353\nP = 1000000007\n \n\n\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == '__main__':\n    main()", "complexity": "nlogn", "problem": "1000_C", "from": "CODEFORCES", "tags": "data structures,implementation,sortings"}
{"src": "def candy_eaten(n, k):\n\n    choco = 1\n    last = 1\n    eat = 0\n    # for i in range(n - 1):\n    i = n - 1\n    while i > 0:\n        if choco > k:\n            temp = choco - k\n            choco -= temp\n            eat += temp\n            i -= temp\n        else:\n            last += 1\n            choco += last\n            i -= 1\n    return eat\n\n\nif __name__ == '__main__':\n    n, k = map(int, input().strip().split())\n    print(candy_eaten(n, k))\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n=int(input())\nl=[int(x) for x in input().split()]\nif l==sorted(l):\n\tprint(\"Yes\")\nelse:\n\tcnt=0;\n\tg=sorted(l)\n\tfor i in range(len(l)):\n\t\tif l[i]!=g[i]:\n\t\t\tcnt+=1\n\tif cnt<=2:\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "from sys import stdin\n\nadd = lambda a, b: (a % mod + b % mod) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, k + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])\n\nprint(sum(mem[-1][k]) % mod)\n", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "from sys import stdout\nm = 30\na, b = 0, 0\nfle = 1\nfor i in range(m):\n    if fle:\n        print('? {} {}'.format(a, b))\n        stdout.flush()\n        resp1 = int(raw_input())\n        fle = 0\n    print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i)))\n    stdout.flush()\n    resp2 = int(raw_input())\n    #print(resp1,resp2,a,b)\n    if resp1 == -1 and resp2 == 1:\n        b += 2**(m-1-i)\n        fle = 1\n    elif resp1 == 1 and resp2 == -1:\n        a += 2**(m-1-i)\n        fle = 1\n    else:\n        fle = 0\n        print('? {} {}'.format(a + 2**(m-1-i), b))\n        stdout.flush()\n        resp3 = int(raw_input())\n        if resp3 == -1:\n            b += 2**(m-1-i)\n            a += 2**(m-1-i)\n        #print(resp1,resp2,resp3,a,b)\nprint('! {} {}'.format(a,b))\nstdout.flush()", "complexity": "constant", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "a = input()\nb = input()\nla = [int(x) for x in a]\nres = []\nla.sort()\nla = la[::-1]\nlb = [int(x) for x in b]\ncnt = [0] * 20\n\ndef check():\n    tres = 0\n    for x in range(len(res)):\n        tres *= 10\n        tres += int(res[x])\n    return tres <= int(b)\nif len(a) < len(b):\n    for i in range(len(la)):\n        print(la[i], end = '')\n    print()\nelse:\n    for i in range(len(la)):\n        cnt[la[i]] += 1\n    flag = 0\n    for i in range(len(lb)):\n        if flag == 0 and cnt[lb[i]]:\n            res.append(lb[i])\n            cnt[lb[i]] -= 1\n        else:\n            flag = i - 1\n            for j in range(lb[i] - 1, -1, -1):\n                if cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n                    break\n            for j in range(9, -1, -1):\n                while cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n            break\n    while not check():\n        temp = []\n        cnt = [0] * 20\n        for x in range(flag):\n            temp.append(res[x])\n            cnt[res[x]] -= 1\n        for i in la:\n            cnt[i] += 1\n        ##print(\"cnt = \", cnt)\n        res = temp\n        ##print(flag, res)\n        for v in range(lb[flag] - 1, -1, -1):\n            if cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n                break\n        for v in range(9, -1, -1):\n            while cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n        ##print(flag, res)\n        flag -= 1\n    for i in range(len(res)):\n        print(res[i], end = '')\n    print()\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "from math import*\nn,k=map(int,input().split())\ns=1\ndob=2\nfor i in range(1,n):\n    s+=dob\n    dob+=1\n    if s-(n-i-1)==k:\n        print(n-i-1)\n        exit()\nprint(0)\n\n", "complexity": "linear", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import math\n\nn, k = input().split()\nn = int(n)\nk = int(k)\n\nsolfound = 0\nm = 0\nx0 = 0\n\n# while not solfound:\n#     x0 = k + m - ((n-m)*(n-m+1))/2\n    \n#     if x0 >=0 and x0%1==0:\n#         solfound = 1\n#     elif m == 100000000000000:\n#         break\n#     else:\n#         m += 1\n        \nif (3+2*n+math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2 < n:\n    m1 = (3+2*n+math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2\nelse:\n    m1 = (3+2*n-math.sqrt((3+2*n)**2-4*(n+n**2-2*k)))/2\n\n    \nprint(int(m1))\n\n#Check:\n# print(k,(n-m)*(n-m+1)/2-m)\n# # print(k,m^2-(2*n+3)*m+n+n^2)\n# print(2*k,(n*(n-m+1)-m*(n-m+1))-2*m)\n# print(2*k,m**2-(2*n+3)*m+n+n**2)\n# # print((n-m1)*(n-m1+1)/2-m1)", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "a = int(input())\ns = input()\nd = s.count('H')\np = []\nfor i in range(len(s)):\n\tif i+d > len(s):\n\t\tn = d+i - len(s)\n\t\tm = d - n\n\t\th = s[:m] + s[-n:]\n\t\tk = h.count(\"T\")\n\t\tp.append(k)\n\telse:\n\t\th = s[i:d+i]\n\t\tk = h.count(\"T\")\n\t\tp.append(k)\nmi = a\nfor i in range(len(p)):\n\tif p[i] < mi:\n\t\tmi = p[i]\nif s.count(\"H\") == 1 or s.count(\"T\") == 0:\n\tprint(0)\nelse:\n\tprint(mi)\n\n", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "n, m, k =map(int, input().split())\nhorizontal = [list(map(int, input().split())) for i in range(n)]\nvertical = [list(map(int, input().split())) for i in range(n-1)]\nif k%2 or max(n, m)==1:print(*[\" \".join(['-1']*m) for i in range(n)], sep='\\n');exit()\ndp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]\nfor length in range(1, k//2+1):\n    for i in range(n):\n        for j in range(m):\n            left_path = 10e7 if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]\n            right_path = 10e7 if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]\n            top_path = 10e7 if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]\n            bottom_path = 10e7 if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]\n            dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])\nfor i in range(n):print(*[dp[i][j][k//2]*2 for j in range(m)])\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from collections import defaultdict\nn, k = map(int, input().split())\na = [0] + list(map(int, input().split()))\nh = defaultdict(int)\nfor i in range(n):\n\ta[i + 1] ^= a[i]\nfor i in range(n + 1):\n\th[min(a[i] ^ ((1 << k) - 1), a[i])] += 1\nans = 0\nfor x, t in h.items():\n\ta = t // 2\n\tb = t - a\n\tans += a * (a - 1) // 2 + b * (b - 1) // 2\nans = (n * (n + 1)) // 2 - ans\nprint(ans)\n", "complexity": "linear", "problem": "1054_D", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "arr = []\nd = {}\nfor _ in range(int(input())):\n    s = input()\n    a,b,c = tuple(map(int, s.replace(\"(\",\"\").replace(\")\",\"\").replace(\"/\",\".\").replace(\"+\",\".\").split(\".\")))\n    x = (a+b)/c\n    arr.append(x)\n    if x not in d:\n        d[x] = 0\n    d[x] += 1\n\nfor i in arr:\n    print(d[i], end = \" \")", "complexity": "linear", "problem": "0958_D1", "from": "CODEFORCES", "tags": "expression parsing,math"}
{"src": "#!/usr/bin/env python3\nfrom sys import stdin\n\n\ndef solve(tc):\n    k = int(stdin.readline().strip())\n    cmp = 9\n    ndigit = 1\n\n    while k>(cmp*ndigit):\n        k -= cmp*ndigit\n        cmp *= 10\n        ndigit += 1\n    \n    num = (10**(ndigit-1)) + ((k-1) // ndigit)\n    pos = (k-1) % ndigit\n\n    print(str(num)[pos])\n    pass\n\n\nLOCAL_TEST = not __debug__\nif LOCAL_TEST:\n    infile = __file__.split('.')[0] + \"-test.in\"\n    stdin = open(infile, 'r')\n\ntcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1)\ntc = 1\nwhile tc <= tcs:\n    solve(tc)\n    tc += 1", "complexity": "constant", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "A, B = map(int, input().split())\nx, y, z = map(int, input().split())\nnA = 2*x+y\nnB = 3*z+y\nr = 0\nif nA > A:\n    r += nA-A\nif nB > B:\n    r += nB-B\nprint(r)\n", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n, S = map(int, input().split())\nprint((S + n - 1) // n);\n", "complexity": "constant", "problem": "1061_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "from heapq import *\n\nn,k=map(int,input().split())\np=[int(X) for X in input().split()]\nc=[int(x) for x in input().split()]\np=[[p[i],c[i],i] for i in range(n)]\np.sort()\nj=0\nan=[0]*n\nan[p[0][2]]=p[0][1]\nz=[]\nheapify(z)\n#print(p)\nfor i in range(1,n):\n\n     s=p[i][1]\n     if p[i][0]!=p[i-1][0]:\n         while (j<i):\n\n             heappush(z,(-1)*p[j][1])\n             j+=1\n\n     tt=[]\n     for __ in range(k):\n\n         tt.append(heappop(z))\n         if not z:\n             break\n     #print(tt,i,j)\n     for v in tt:\n         s+=abs(v)\n         heappush(z, v )\n     #print(s)\n     an[p[i][2]]=s\n\nprint(*an)\n\n", "complexity": "nlogn", "problem": "0994_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "print(int(input())//2 + 1)\n", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import math\n\nn = int(input())\n\n# Assumption = they give it to me sorted by A\n\nbeacons = {}\nsortedKeys = [0]*n\n\nfor i in range(n):\n    a, b = map(int, input().split(' '))\n    sortedKeys[i] = a\n    beacons[a] = b\n\nsortedKeys.sort()\nmaxA = sortedKeys[-1]\n\nsumBeacons = [0]*(maxA+1)\ncount = 0\nfor a in range(maxA+1):\n    sumBeacons[a] = count\n    # Exclusive on the end value\n    if a in beacons:\n        count += 1\n\nf = [0]*(n+1)\nminF = math.inf\nfor i in range(1, n+1):\n    a = sortedKeys[i-1]\n    b = beacons[a]\n    end = max(0, a-b)\n    numDestroyed = sumBeacons[a] - sumBeacons[end]\n    f[i] = numDestroyed\n    if i-numDestroyed > 0:\n        f[i] += f[(i-1)-numDestroyed]\n    # Our answer is the minF of this value + all the ones before it we would have to destroy\n    minF = min(minF, f[i]+n-i)\n\nprint(minF)", "complexity": "linear", "problem": "0608_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "n, m = (int(x) for x in input().split())\nboys_out = sorted([int(x) for x in input().split()], reverse=True)\ngirls_in = sorted([int(x) for x in input().split()])\nmax_boy = max(boys_out)\nans = 0\nfor boy in boys_out:\n    ans += boy * m\n\ncount = 0\ni = 0\nfor girl in girls_in:\n    if girl < max_boy:\n        print(-1)\n        quit()\n        \n    if girl > max_boy:\n        if count == m - 1:\n            count = 0\n            i += 1\n        if i >= n:\n            print(-1)\n            quit()\n        ans += girl - boys_out[i]\n        count += 1\n\nprint(ans)              ", "complexity": "nlogn", "problem": "1159_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "a, v = list(map(int, input().split(\" \")))\nl, d, w = list(map(int, input().split(\" \")))\n \nif(v <= w or w * w > 2 * a * d):\n    if(v * v > 2 * a * l):\n        print((2 * l / a) ** 0.5)\n    else:\n        print(l / v + v / 2 / a)\nelse:\n    u = (w * w / 2 + a * d) ** 0.5\n    if(u > v):\n        m =  v / a + (v - w) / a + (d - (v * v / 2 / a) - (v * v - w * w) / 2 / a) / v\n    else:\n        m = (2 * u - w) / a\n        \n    if(v * v > 2 * a * (l - d + w * w / 2 / a)):\n        print(m - w / a + (2 * (l - d + (w * w / 2 / a)) / a) ** 0.5)\n    else:\n        print(m - w / a + (l - d + w * w / 2 / a) / v + v / 2 / a)", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n, m, q = map(int, input().split())\na = sorted(map(int, input().split()), reverse=True)\nb = sorted(map(int, input().split()), reverse=True)\nc = sorted(map(int, input().split()), reverse=True)\ndp = [[[0] * 201 for _ in range(201)] for _ in range(201)]\nfor ijk in range(n + m + q + 1):\n    for i in range(min(n + 1, ijk + 1)):\n        for j in range(min(m + 1, ijk - i + 1)):\n            k = ijk - i - j\n            if k < 0 or k > q:\n                continue\n            if i + 1 <= n:\n                dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k])\n            if j + 1 <= m:\n                dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k])\n            if k + 1 <= q:\n                dp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k])\n            if i + 1 <= n and j + 1 <= m:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[i] * b[j])\n            if i + 1 <= n and k + 1 <= q:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[i] * c[k])\n            if j + 1 <= m and k + 1 <= q:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + b[j] * c[k])\nprint(dp[n][m][q])", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "# -*- coding: utf-8 -*-\n# @Time    : 2021/1/12 10:14 \u4e0a\u5348\n# @Author  : qu\n# @Email   : quzhenqing@zju.edu.cn\n# @File    : A. Fly.py\nfrom sys import stdin\n\nEPS = 1e-6\nn = int(stdin.readline())\nm = int(stdin.readline())\na = list(map(int, stdin.readline().split()))\nb = list(map(int, stdin.readline().split()))\nb.append(b[0])\n\n\ndef check(f):\n    fuel_left = f\n    total_weight = float(m + fuel_left)\n    for i in range(n):\n        cost = total_weight / a[i]\n        fuel_left = fuel_left - cost\n        total_weight = total_weight - cost\n\n        cost = total_weight / b[i + 1]\n        fuel_left = fuel_left - cost\n        total_weight = total_weight - cost\n        if fuel_left < 0:\n            return False\n    return True\n\n\ndef binary_search(left, right):\n    mid = (left + right) / 2\n    if abs(left - right) < EPS:\n        return mid\n    if check(mid):\n        return binary_search(left, mid)\n    else:\n        return binary_search(mid, right)\n\n\nres = binary_search(0, 1e9 + 1)\n# if (n == 196):\n#     print(res)\nif res - 1e9 > EPS:\n    print(-1)\nelse:\n    print(\"%.10f\" % res)\n", "complexity": "linear", "problem": "1010_A", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "n = int(input())\na = [int(i) for i in input().split()]\n\ntotal = sum(a)\nfinal = n * (n-1) // 2\nrepeated = []\ncount = {}\n\nfor i in a:\n    try:\n        count[i] += 1\n        repeated.append(i)\n    except KeyError:\n        count[i] = 1\n\n\n# for i, num in enumerate(a):\n#     if i in a[:i]:\n#         repeated.append(i)\n\nmoves = total - final\n\nif len(repeated) > 1:\n    print('cslnb')\n\nelif 0 in repeated:\n    print('cslnb')\n\nelif len(repeated) == 1 and repeated[0] - 1 in a:\n    print('cslnb')\n\nelse:\n    if moves % 2 == 0 or moves <= 0:\n        print('cslnb')\n    else:\n        print('sjfnb')\n", "complexity": "linear", "problem": "1191_D", "from": "CODEFORCES", "tags": "games"}
{"src": "n,k = map(int,input().split())\nprint(-(-k//n))\n", "complexity": "constant", "problem": "1036_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n,k = list(map(int, input().split()))\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\nx = 0\nsumm = 0\nmaxx = 0\nfor i in range(n):\n  summ += a[i]*t[i]\nfor i in range(k):\n  if not t[i]:\n    x+=a[i]\nmaxx = max(maxx,x)\nfor i in range(n-k):\n  x+=a[i+k]*(1-t[i+k])\n  x-=a[i]*(1-t[i])\n  if x>maxx:\n    maxx=x\n  #maxx = max(x, maxx)\nprint(summ+maxx)", "complexity": "linear", "problem": "0961_B", "from": "CODEFORCES", "tags": "data structures,dp,implementation,two pointers"}
{"src": "\"\"\"\n$ pylint calderonsin.py\nGlobal evaluation\n-----------------\nYour code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)\n\n\"\"\"\ndef maxlen():\n    string = input()\n    maxi = 0;\n    for x in range(len(string)):\n        substring = \"\"\n        for y in string[x:]:\n            substring +=y;\n            if string[x:].rfind(substring) != string[x:].find(substring):\n                maxi = max(maxi, len(substring))\n                continue\n    print(maxi)\n\nmaxlen()\n# $ python3 calderonsin.py build\n# remember the output\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "n = int(input())\na = list(map(int, input()))\nb = list(map(int, input()))\n\nans = sum(q != w for q, w in zip(a, b))\ni = 1\nwhile i < n:\n    aii = a[i - 1]\n    ai = a[i]\n    bii = b[i - 1]\n    bi = b[i]\n    if aii + ai == 1 and bii + bi == 1 and aii != bii and ai != bi:\n        ans -= 1\n        i += 1\n    i += 1\n\nprint(ans)\n", "complexity": "linear", "problem": "1037_C", "from": "CODEFORCES", "tags": "dp,greedy,strings"}
{"src": "from sys import stdin,stdout\nfrom math import ceil\nnmbr = lambda: int(stdin.readline())\nlst = lambda: list(map(int, stdin.readline().split()))\nfor _ in range(1):#nmbr()):\n    k,n,s,p=lst()\n    spp=ceil(n/s)\n    tots=spp*k\n    print(ceil(tots/p))\n\t\t\t\t\t\t\t\t\t \t \t \t  \t   \t    \t\t \t\t", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\ninput = sys.stdin.readline\n\n'''\n\n'''\n\nfrom heapq import heapify, heappush, heappop\n\nn, k = map(int, input().split())\nplst = list(map(int, input().split()))\nclst = list(map(int, input().split()))\n\nif k == 0:\n    print(*clst)\n    sys.exit()\n\npc = sorted(((p, c, i) for i, (p, c) in enumerate(zip(plst, clst))), key=lambda t: (t[0], t[2]))\nres = [0] * n\npq = []\npq_sum = 0\npq_size = 0\n\nfor p, c, i in pc:\n    if i > 0 and plst[i] == plst[i-1]:\n        res[i] = res[i-1]\n    else:\n        res[i] = pq_sum + c\n\n    # Update pq\n    if pq_size < k:\n        heappush(pq, c)\n        pq_sum += c\n        pq_size += 1\n    else:\n        alt = heappop(pq)\n        if alt < c:\n            heappush(pq, c)\n            pq_sum += c - alt\n        else:\n            heappush(pq, alt)\n\nprint(*res)\n", "complexity": "nlogn", "problem": "0994_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "from sys import stdin\nfrom bisect import *\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrints_2d = lambda n: [rints() for _ in range(n)]\nn, mem, pos, power = int(input()), [1], [], []\na = sorted(rints_2d(n))\n\nfor x, y in a:\n    pos.append(x)\n    power.append(y)\n\nfor i in range(1, n):\n    ix = bisect_left(pos, pos[i] - power[i]) - 1\n    if ix == -1:\n        mem.append(1)\n    else:\n        mem.append(mem[ix] + 1)\n\nprint(n - max(mem))\n", "complexity": "linear", "problem": "0608_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "a = int(input())\nprint((a // 2) * 3)", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "from collections import deque\n \nm, k = list(map(int, input().split()))\n \nG = [set() for _ in range(m + 1)]\n \nq, nq = deque(), deque()\n \nfor _ in range(m - 1):\n    u, v = list(map(int, input().split()))\n    G[u].add(v)\n    G[v].add(u)\n \nfor u in range(1, m + 1):\n    if len(G[u]) == 1:\n        q.append(u)\n \nstep = 0\nremoved = 0\nok = True\n \nwhile removed < m - 1:\n    each = {}\n    for u in q:\n        nxt = G[u].pop()\n        G[nxt].remove(u)\n        each[nxt] = each.get(nxt, 0) + 1\n        removed += 1\n        if len(G[nxt]) == 0:\n            break\n        if len(G[nxt]) == 1:\n            nq.append(nxt)\n    if any(v < 3 for k,v in each.items()):\n        ok = False\n        break\n    q, nq = nq, deque()\n    step += 1\n \nif ok and step == k and removed == m - 1:\n    print('Yes')\nelse:\n    print('No')\n", "complexity": "nlogn", "problem": "1067_B", "from": "CODEFORCES", "tags": "dfs and similar,graphs,shortest paths"}
{"src": "r, g, b = map(int, input().split())\na = [[], [], []]\ndp = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)]\nfor x in range(3):\n    a[x] = sorted([int(x) for x in input().split()])\nodp = 0\nfor i in range(r + 1):\n    for j in range(g + 1):\n        for k in range(b + 1):\n            if i < r and j < g:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])\n            if i < r and k < b:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])\n            if j < g and k < b:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])\n            odp = max(odp, dp[i][j][k])\nprint(odp)", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "\ndef d(n):\n    ret = 0\n    n = list(str(n))\n    for i in range(len(n)):\n        ret += int(n[i])\n    return ret\n\ndef main():\n    n, s = map(int, input().split())\n\n    l, h = 0, n\n    for i in range(2000):\n        m = (l + h) // 2\n        if m - d(m) >= s:\n            h = m\n        else:\n            l = m\n\n    for i in range(-100, 100):\n        t = m + i\n        if t < 0 or t > n:\n            continue\n        if abs(t - d(t)) >= s:\n            print(n - t + 1)\n            exit()\n    print(0)\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "n = int(input())\nx, y = map(int, input().split())\n\ndef d(a, b):\n    return a + b\n\nif d(x-1, y-1) <= d(n-x, n-y):\n    print(\"White\")\nelse:\n    print(\"Black\")", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n=int(input())\na=[-1]+list(map(int,input().split()))\ns=set()\ns.add(-1)\na.sort()\ncount,add=0,0\nflag=0\nfor i in range(1,n+1):\n    if a[i] in s and a[i]-1 in s:\n        flag=1\n        break\n    if a[i] in s:\n        add+=1\n    if(add==2):\n        flag=1\n        break\n    s.add(a[i])\n    count+=a[i]-(i-1)\nif(flag==0 and count%2==1):\n    print(\"sjfnb\")\nelse:\n    print(\"cslnb\")", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "\nimport string\n\nn, s, t = int(input()), input(), input()\nx, i, j = 0, -1, -1\nsc_dict = {c: set() for c in string.ascii_lowercase}\ntc_dict = {c: set() for c in string.ascii_lowercase}\nsti_dict, tsi_dict = dict(), dict()\n\nfor ci, sc, tc in zip(range(n), s, t):\n    if sc == tc:\n        continue\n    sc_dict[sc].add(tc)\n    tc_dict[tc].add(sc)\n    sti_dict[sc + tc] = ci\n    tsi_dict[tc + sc] = ci\n    x += 1\n\nfor c in string.ascii_lowercase:\n    cs = sc_dict[c] & tc_dict[c]\n    if not cs:\n        continue\n    c2 = cs.pop()\n    x -= 2\n    i = sti_dict[c + c2] + 1\n    j = tsi_dict[c + c2] + 1\n    break\nelse:\n    for c in string.ascii_lowercase:\n        if not sc_dict[c] or not tc_dict[c]:\n            continue\n        x -= 1\n        i = sti_dict[c + sc_dict[c].pop()] + 1\n        j = tsi_dict[c + tc_dict[c].pop()] + 1\n        break\n\nprint(x)\nprint(i, j)", "complexity": "linear", "problem": "0527_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import sys\nn,m,k = map(int,input().split())\n\nif k%2:\n    ans = [[-1]*m for _ in range(n)]\n    for row in ans:\n        print(*row)\n    exit()\nA = []\nB = []\ninf = float('inf')\nfor _ in range(n):\n    A.append(list(map(int,input().split())))\nfor _ in range(n-1):\n    B.append(list(map(int,input().split())))\n\n# dp = [[[inf for _ in range(k//2+1)] for _ in range(m)] for _ in range(n)]\n\n# new\ndp = [[inf]*m for _ in range(n)]\nans = [[None]*m for _ in range(n)]\n\nfor l in range(k//2+1):\n    new_dp = [[inf]*m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if l == 0:\n                new_dp[i][j] = 0\n                continue\n\n            up = B[i-1][j]*2 + dp[i-1][j] if i-1>=0 else inf\n            right = A[i][j]*2 + dp[i][j+1] if j+1<m else inf\n            left = A[i][j-1]*2 + dp[i][j-1] if j-1>=0 else inf\n            down = B[i][j]*2 + dp[i+1][j] if i+1<n else inf\n\n            new_dp[i][j] = min(up,right,left,down)\n            if l == k//2:\n                ans[i][j] = new_dp[i][j]\n    dp = new_dp\nfor row in ans:\n    print(*row)\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from collections import defaultdict\nfrom sys import stdin\n\ninput = stdin.readline\n\ndct = defaultdict(int)\nn = int(input())\nlst = [0] * n\nfor i in range(n):\n    t = input().strip()\n    a, b, c = map(int, (t[1:t.index('+')], t[t.index('+') + 1:t.index(')')], t[t.index('/') + 1:]))\n    x = (a + b) / c\n    lst[i] = x\n    dct[x] += 1\nfor i in lst:\n    print(dct[i], end=' ')\n", "complexity": "linear", "problem": "0958_D1", "from": "CODEFORCES", "tags": "expression parsing,math"}
{"src": "from collections import Counter\n\n\ndef mx(f):\n    res = []\n    for k in sorted(f.keys(), reverse=True):\n        for _ in range(f[k]):\n            res.append(k)\n    return res\n\n\ndef solve(n, a, b):\n    res = None\n    for k in range(n + 1):\n        aa = Counter(a)\n        cur = []\n        for i in range(k):\n            if aa[b[i]] == 0:\n                return res\n            cur.append(b[i])\n            aa[b[i]] -= 1\n        if k < n:\n            for e in range(b[k] - 1, -1, -1):\n                if aa[e] > 0:\n                    cur.append(e)\n                    aa[e] -= 1\n                    cur.extend(mx(aa))\n                    break\n            if len(cur) < n:\n                continue\n        res = cur\n    return res\n\n\na = Counter(map(int, input()))\nb = list(map(int, input()))\nif sum(a.values()) < len(b):\n    res = mx(a)\nelse:\n    res = solve(len(b), a, b)\nprint(''.join(map(str, res)))", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\nsys.setrecursionlimit(111111) \nINF=99999999999999999999999999999999\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n \n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n \n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n \n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n \n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n \n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n \n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n \n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n \n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n \n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n \n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n \n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n \n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n \n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n \n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n \n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n \n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n \n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n \n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n \n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n \n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n \n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\ndef main():\n\n    mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n    ###CODE\n    tc = 1\n    for _ in range(tc):\n        n=ri()\n        s=rs()\n        \n        d={}\n        for i in range(n):\n            # print(i,s[i])\n            d[s[i]]=1\n        l=0\n        r=0\n        td={}\n        ans=INF\n        while l<=r and r<n:\n            while len(td)!=len(d):\n                if r==n:\n                    print(ans)\n                    exit()\n                if s[r] in td:\n                    td[s[r]]+=1\n                else:\n                    td[s[r]]=1\n                r+=1\n                \n            if len(td)==len(d):\n                r-=1\n                ans=min(ans,r-l+1)\n            while l<=r:\n                # g=(s[l],l)\n                td[s[l]]-=1\n                if td[s[l]]==0:\n                    del td[s[l]]\n                    ans=min(ans,r-l+1)\n                    l+=1\n                    break\n                l+=1\n            r+=1\n        wi(ans)\n        \n                \n        \n        \n            \n        \n        \n                     \n        \n        \n                    \n        \n                     \n                    \n                    \n                \n                \n                    \n                \n        \n        \n            \n                   \n        \n                    \n\n        \n        \n                \n            \n            \n    \n            \n                        \n        \n    \n\n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    \n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "print(int(input()) // 2 + 1)", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "xa, ya = map(int, input().split())\nxb, yb = map(int, input().split())\nxc, yc = map(int, input().split())\nif (xb, yb) < (xa, ya):\n    xa, ya, xb, yb = xb, yb, xa, ya\nif (xc, yc) < (xa, ya):\n    xa, ya, xc, yc = xc, yc, xa, ya\nif xb > xc:\n    xb, yb, xc, yc = xc, yc, xb, yb\nd = 1 if ya <= yc else -1\nif ya <= yb <= yc or ya >= yb >= yc:\n    print(xc - xa + abs(yc - ya) + 1)\n    for x in range(xa, xb):\n        print(x, ya)\n    for y in range(ya, yc, d):\n        print(xb, y)\n    for x in range(xb, xc + 1):\n        print(x, yc)\nelif yb < min(ya, yc):\n    print(xc - xa + max(ya, yc) - yb + 1)\n    for x in range(xa, xc + 1):\n        print(x, min(ya, yc))\n    for y in range(yb, min(ya, yc)):\n        print(xb, y)\n    if ya < yc:\n        for y in range(ya + 1, yc + 1):\n            print(xc, y)\n    else:\n        for y in range(yc + 1, ya + 1):\n            print(xa, y)\nelse:\n    print(xc - xa + yb - min(ya, yc) + 1)\n    for x in range(xa, xc + 1):\n        print(x, max(ya, yc))\n    for y in range(max(ya, yc) + 1, yb + 1):\n        print(xb, y)\n    if ya < yc:\n        for y in range(ya, yc):\n            print(xa, y)\n    else:\n        for y in range(yc, ya):\n            print(xc, y)\n", "complexity": "constant", "problem": "1086_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import math\na=input()\nb=input()\ni=a.count('+')\nj=a.count('-')\nk=b.count('+')\nl=b.count('-')\nm=b.count('?')\nc1=(i-j)\nc2=(k-l)\nc=abs(c1-c2)\nw=m-c\nx=w//2\ny=w//2+c\nif(c==0 and m==0):\n    print(1)\nelif((c)>m):\n    print(0)\nelse:\n    x=math.factorial(m)//(math.factorial(x)*math.factorial(y))\n    print(x/pow(2,m))\n    \n    \n\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "mod = 10**9 + 7\nx, k = list(map(int, input().split()))\nif x == 0:\n    print(0)\n    exit()\nans = (x*pow(2, k+1, mod) - (pow(2, k, mod)-1) + mod)%mod\nprint(ans)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nm = int(input())\nparity = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if a[i] > a[j]:\n            parity ^= 1\nres = []\nfor _ in range(m):\n    l, r = map(int, input().split())\n    s = r - l + 1\n    parity ^= (s * (s - 1) // 2) % 2\n    res.append(\"odd\" if parity else \"even\")\nprint(\"\\n\".join(res))", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "a , b = input(), input()\nans = 0\n \nones = [0 for i in range(len(b)+1)]\nzeros = [0 for i in range(len(b)+1)]\n \nfor i in range(len(b)):\n    ones[i] = ones[i-1] + int(b[i])\n    zeros[i] = i + 1 - ones[i]\n    \nfor i in range(len(a)):\n    if a[i] == '1':\n        ans += zeros[len(b)-len(a)+i] - zeros[i-1]\n \n    else:\n        ans += ones[len(b)-len(a)+i] - ones[i-1]\n \nprint(ans)\n  \t \t   \t     \t \t\t\t\t \t     \t\t\t", "complexity": "linear", "problem": "0608_B", "from": "CODEFORCES", "tags": "combinatorics,strings"}
{"src": "n,m=[int(i) for i in input().split(\" \")]\narrmv=[]\nfor i in range(n):\n    arrmv.append([int(i) for i in input().split(\" \")])\nx=0\ny=int(1e9+1)\nsucls=[0,0]\n\ntols=[]\nmstr=\"\"\n\npowls=[int(pow(2,i)) for i in range(10)]\ntwodarray=[0  for i in range(257)]\nwhile x+1<y:\n    mid = x+(y-x)//2\n    # print(x,y,mid)\n    for idx,ele in enumerate(twodarray):twodarray[idx]=0\n    tols.clear()\n    for topidx, eletop in enumerate(arrmv):\n        tmp=0\n        for idx,ele in enumerate(eletop):\n            if ele>=mid:tmp+=powls[idx]\n        \n        if not twodarray[tmp]:\n            # print(eletop,tmp,mid)\n            twodarray[tmp]=1\n            tols.append((tmp,topidx))\n    sz=len(tols)\n    suc=0\n    no=int(pow(2,m))\n    for i in range(sz):\n        for j in range(i,sz):\n            if tols[i][0] | tols[j][0] == no-1:\n                sucls[0],sucls[1]=tols[i][1],tols[j][1]\n                # print(sucls[0],sucls[1],mid)\n                suc=1;\n                break;\n        if suc:break\n    if suc:x=mid\n    else:y=mid\n\nprint(sucls[0]+1,sucls[1]+1)\n\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "\nimport bisect\nfrom itertools import accumulate\nimport os\nimport sys\nimport math\nfrom decimal import *\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\ndef SieveOfEratosthenes(n): \n    prime=[]\n    primes = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n          \n        if (primes[p] == True): \n            prime.append(p)\n            for i in range(p * p, n+1, p): \n                primes[i] = False\n        p += 1\n    return prime\ndef factors(n):\n    fac=[]\n    while(n%2==0):\n        fac.append(2)\n        n=n//2\n    for i in range(3,int(math.sqrt(n))+2):\n        while(n%i==0):\n            fac.append(i)\n            n=n//i\n    if n>1:\n        fac.append(n)\n    return fac\n#--------------------------------------------------------\na = input()\nb = a.count('1')\na = a.replace('1','')\nc = a.find('2')\nif c==-1:\n    a = (a+ '1'*b)\nelse:\n    a = a[:c]+ '1'*b + a[c:]\nprint(a)\n", "complexity": "linear", "problem": "1009_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import time\nfrom decimal import Decimal\nn,k = map(int,raw_input().split())\n\ncomputeSum = lambda x: Decimal(((Decimal(x)/Decimal(2)) * Decimal(k-x+1 + k)) - (x-1))\n\ndef minSplitters():\n    if n == 1:\n        return 0\n    elif n <= k:\n        return 1\n    max_sum = computeSum(k)\n    if n > max_sum:\n        return -1\n    else:\n        low = 0\n        high = k\n        while low < high:\n            mid = (low+high)/2\n            previousSum = computeSum(mid-1)\n            currentSum = computeSum(mid)\n            if currentSum == n:\n                return mid\n            elif currentSum < n:\n                low = mid + 1\n            elif currentSum > n:\n                if previousSum >= n:\n                    high = mid-1\n                else:\n                    return mid\n        return low\nprint(minSplitters())", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------- fast io --------------------\nfrom math import gcd, ceil\n\ndef prod(a, mod=10**9+7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\nfor _ in range(int(input()) if not True else 1):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [[False]*(n+2) for i in range(n+2)]\n    # dp[i][j] -> Can a[i-j] be reduced to a single element.\n    # If yes, then dp[i][j] contains value of that element. Else, false.\n    dp2 = [[600]*(n+2) for i in range(n+2)]\n    for i in range(n):\n        dp[i][i] = a[i]\n        dp2[i][i] = 1\n    for diff in range(1, n):\n        for i in range(n-diff):\n            # i -> i+diff\n            for j in range(i, i+diff):\n                if dp[i][j] == dp[j+1][i+diff] and dp[i][j]:\n                    dp[i][i+diff] = dp[i][j] + 1\n                    dp2[i][i+diff] = 1\n                dp2[i][i+diff] = min(dp2[i][i+diff], dp2[i][j]+dp2[j+1][i+diff])\n            if not dp2[i][i+diff]:\n                dp2[i][i+diff] = min(dp2[i+1][i+diff]+1, dp2[i][i+diff-1] + 1)\n    print(dp2[0][n-1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n,m = map(int,input().split())\nans = 0\ntemp = [0 for i in range(n)]\nfor i in range(n):\n    l,r = map(int,input().split())\n    ans += l\n    temp[i] = l-r\ntemp.sort(reverse=True)\n\nif ans<=m:\n    print(0)\nelse:\n    for i in range(n):\n        ans -= temp[i]\n        if ans<=m:\n            print(i+1)\n            break\n    else:\n        print(-1)\n", "complexity": "nlogn", "problem": "1015_C", "from": "CODEFORCES", "tags": "sortings"}
{"src": "print(\"? 0 0\")\nt = int(input())\nA=[]\nB=[]\na=0\nb=0\nfor i in range(30):\n    A.append(-1)\n    B.append(-1)\ni = 29\nd = 2**i\nwhile i>=0:\n    a+=d\n    b+=d\n    print(\"?\", end=' ')\n    print(a, end=' ')\n    print(b)\n    s=int(input())\n    if s == -t:\n        if s==1:\n            A[i]=0\n            B[i]=1\n            b-=d\n            print(\"?\", end=' ')\n            print(a, end=' ')\n            print(b)\n            t=int(input())\n        elif s==-1:\n            A[i]=1\n            a-=d\n            B[i]=0\n            print(\"?\", end=' ')\n            print(a, end=' ')\n            print(b)\n            t=int(input())\n    i-=1\n    d//=2\nd=1\nfor j in range(30):\n    if A[j]==-1:\n        a = a^d\n        print(\"?\", end=' ')\n        print(a, end=' ')\n        print(b)\n        s = int(input())\n        if s==1:\n            A[j]=1\n            B[j]=1\n        else:\n            A[j]=0\n            B[j]=0\n        a = a^d\n    d*=2\nd=1\na=0\nb=0\nfor i in range(30):\n    a+=d*A[i]\n    b+=d*B[i]\n    d*=2\nprint(\"!\", end=' ')\nprint(a, end=' ')\nprint(b)\n", "complexity": "logn", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\n        \nmod = pow(10, 9) + 7\nmod2 = 998244353\n        \ndef inp(): return stdin.readline().strip()\ndef iinp(): return int(inp())\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)//b\nS1 = 'abcdefghijklmnopqrstuvwxyz'\nS2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n \nn, m, k = mp()\nhor = [lmp() for i in range(n)]\nver = [lmp() for i in range(n-1)]\nif k%2:\n    ml = l2d(n, m, -1)\n    for i in ml: print(*i)\n    exit()\nk//=2\ndp = [l2d(n, m) for i in range(k+1)]\nfor f in range(1, k+1):\n    for i in range(n):\n        for j in range(m):\n            a = inf\n            if i!=0:\n                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])\n            if i!=n-1:\n                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])\n            if j!=0:\n                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])\n            if j!=m-1:\n                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])\n            dp[f][i][j] = a\nfor i in dp[-1]:\n    print(*i)", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import sys;input = sys.stdin.readline;n, k = map(int, input().split());s = input()[:-1];left, right = 0, n\nwhile left < right:\n    mid = right - (right - left) // 2;A = [[0] * (n + 2) for _ in range(k)]\n    for c in range(k):\n        A[c][n] = A[c][n + 1] = n + 1;L = 0\n        for i in range(n - 1, -1, -1):L = (L + 1 if s[i] == '?' or ord(s[i]) - ord('a') == c else 0);A[c][i] = i + mid if L >= mid else A[c][i + 1]\n    dp = [n + 1] * (1 << k);dp[0] = 0\n    for mask in range(1 << k):\n        for i in range(k):\n            if mask >> k & 1: continue\n            t = mask | 1 << i;dp[t] = min(dp[t], A[i][dp[mask]])\n    if dp[-1] <= n: left = mid\n    else: right = mid - 1\nprint(left)", "complexity": "np", "problem": "1550_E", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,strings,two pointers"}
{"src": "n, m, k = map(int, input().split());\na = list(map(int, input().split()));\na.sort(reverse = True);\nif sum(a)+k-n < m:\n    print(-1);\nelif k >= m:\n    print(0);\nelse:\n    for i in range (1, n+1):\n        if sum(a[:i])+k-i >= m:\n            print(i)\n            break;\n\n", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "n = int(input())\nd1 = {}\nfor _ in range(n):\n  a, x = map(int, input().split())\n  d1[a] = x\nd2 = {}\nm = int(input())\nfor _ in range(m):\n  b, y = map(int, input().split())\n  d2[b] = y\nans = 0\nfor key in set(d1.keys()) | set(d2.keys()):\n  ans += max(d1.get(key, 0), d2.get(key, 0))\nprint(ans)", "complexity": "nlogn", "problem": "0981_B", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import collections, bisect\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\ncs = collections.Counter(arr)\nprint(min(cs[x] for x in range(1, n + 1)))\n", "complexity": "quadratic", "problem": "0961_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\n\na=[[],[],[]]\n\ns=input().split(\" \")\n\nfor i in range(len(s)):\n\tif(s[i][1]=='m'):\n\t\ta[0].append(int(s[i][0]))\n\telif(s[i][1]=='p'):\n\t\ta[1].append(int(s[i][0]))\n\telse:\n\t\ta[2].append(int(s[i][0]))\n\nko=10\n\nfor i in range(len(a)):\n\ta[i]=sorted(a[i])\n\tc=0\n\n\tfor j in range(1,len(a[i])):\n\t\tif(a[i][j]==a[i][j-1]):\n\t\t\tc+=1\n\tif(c==1):\n\t\tko=min(ko,1)\n\telif(c==2):\n\t\tko=min(ko,0)\n\telse:\n\t\tif(len(a[i])>0):\n\t\t\tko=min(ko,2)\n\nans=ko\nko=10\n\nfor i in range(len(a)):\n\ta[i]=sorted(a[i])\n\tc=0\n\n\tfor j in range(1,len(a[i])):\n\t\tif(a[i][j]==a[i][j-1]+1):\n\t\t\tc+=1\n\tif(c==1):\n\t\tko=min(ko,1)\n\telif(c==2):\n\t\tko=min(ko,0)\n\telif(len(a[i])>1 and (a[i][0]+2==a[i][1])):\n\t\tko=min(ko,1)\n\telif(len(a[i])>2 and (a[i][1]+2==a[i][2])):\n\t\tko=min(ko,1)\n\telse:\n\t\tif(len(a[i])>0):\n\t\t\tko=min(ko,2)\n\n\nprint(min(ans,ko))\n\n\n\n", "complexity": "nlogn", "problem": "1191_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "import sys\nimport heapq\ninput = sys.stdin.readline\n\nn,x,y = map(int,input().split())\nMOD_NUM = 10**9+7\n\nevents = dict()\nfor i in range(n):\n    l,r = map(int,input().split())\n    if l not in events:\n        events[l] = []\n    events[l].append(r)\n\ntv = []\npq = []\ncost = 0\n\nfor t in sorted(events):\n    while tv and tv[0] < t:\n        heapq.heappush(pq, -(x + heapq.heappop(tv)*y))\n\n    for ri in sorted(events[t],reverse=True):\n        if pq and -pq[0] > t*y:\n            val = -heapq.heappop(pq)\n            rj = (val-x)//y\n\n            cost += (ri-rj)*y\n            heapq.heappush(tv, ri)\n        else:\n            cost += x + (ri-t)*y\n            heapq.heappush(tv, ri)\n    cost %= MOD_NUM\n\nprint(cost)\n", "complexity": "nlogn", "problem": "1061_D", "from": "CODEFORCES", "tags": "data structures,greedy,implementation,sortings"}
{"src": "from copy import copy\n\na = list(map(int, input().split()))\n\nans = 0\nfor i in range(14):\n    b = copy(a)\n    b[i] = 0\n\n    for j in range(1, 14 + 1):\n        b[(i + j) % 14] += (a[i] - 1) // 14 + ((a[i] - 1) % 14 + 1 > j - 1)\n\n    ans = max(ans, sum(el * (el % 2 == 0) for el in b))\n\nprint(ans)\n", "complexity": "constant", "problem": "0975_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "a=sorted(input())\n\nb=int(input())\n\na=a[::-1]\n\np=\"\"\n\nwhile a:\n\n\tfor i, z in enumerate(a):\n\n\t\tn=p+a[i]+\"\".join(sorted(a[:i]+a[i+1:]))\n\n\t\tif int(n)<=b:\n\n\t\t\tp+=z\n\n\t\t\ta.pop(i)\n\n\t\t\tbreak\n\nprint(p)\n\n\n\n# Made By Mostafa_Khaled", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "string = input()\ntotalmax = 0;\nfor x in range(len(string)):\n    curr = \"\"\n    for y in string[x:]:\n        curr +=y;\n        if string[x:].rfind(curr) != string[x:].find(curr):\n            totalmax = max(totalmax, len(curr))\n            continue\nprint(totalmax)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "n=int(input())\nprint((n+2)//2)", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "list1=list(input())\nlist2=list(input())\nplus1=list1.count('+')\nplus2=list2.count('+')\nminus1=list1.count('-')\nminus2=list2.count('-')\nwths=list2.count('?')\ndef giveFactorial(n,x):\n    if x==0 or x==n or x>n or n==0:\n        return 1\n    else:\n        return giveFactorial(n-1,x-1)+giveFactorial(n-1,x)\na=(giveFactorial(wths,plus1-plus2))\n#print(wths,plus1-plus2)\nif plus1==plus2 and wths==0:\n    print(1)\nelif wths==0 :\n    print(0)\nelif plus1-plus2>wths or minus1-minus2>wths:\n    print(0)\nelse:\n    print((0.5**(plus1-plus2+minus1-minus2))*a)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "def arr_inp():\n    return [int(x) for x in stdin.readline().split()]\n\n\ndef nCr(n, r):\n    f, m = factorial, 1\n    for i in range(n, n - r, -1):\n        m *= i\n    return int(m // f(r))\n\n\nfrom math import factorial\nfrom sys import stdin\n\nn, a, ans, tem = int(input()), arr_inp(), [], 0\nmem = [0] * (n + 1)\n\nfor i in range(n):\n    for j in range(a[i] - 1, 0, -1):\n        if not mem[j]:\n            tem += 1\n    mem[a[i]] = 1\n\nfor i in range(int(input())):\n    l, r = arr_inp()\n    tem += nCr(r - l + 1, 2)\n    ans.append('odd' if tem % 2 else 'even')\n\nprint('\\n'.join(ans))\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "input = __import__('sys').stdin.readline\n\nn,m,k = map(int, input().split())\nhor = [[int(x) for x in input().split()] for _ in ' ' * n]\nver = [[int(x) for x in input().split()] for _ in ' ' * (n - 1)]\n\nif k % 2:\n  for i in ' ' * n: print('-1 ' * m)\n  exit()\n\nmtx_old = [[0] * m for _ in ' ' * n]\n\ndef neighbours(x, y):\n  a = 1e18\n  b = 1e18\n  c = 1e18\n  d = 1e18\n  if x > 0: a = hor[y][x - 1] * 2 + mtx_old[y][x - 1]\n  if x < m - 1: b = hor[y][x] * 2 + mtx_old[y][x + 1]\n  if y > 0: c = ver[y - 1][x] * 2 + mtx_old[y - 1][x]\n  if y < n - 1: d = ver[y][x] * 2 + mtx_old[y + 1][x]\n  return min(a, b, c, d)\n\nfor i in range(k // 2):\n  mtx_new = [[0] * m for _ in ' ' * n]\n\n  for x in range(m):\n    for y in range(n):\n      mtx_new[y][x] = neighbours(x, y)\n\n  mtx_old = mtx_new\n\nfor row in mtx_old: print(*row)", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "def prime(n):\n    if n < 2:\n        return False\n    elif n % 2 == 0 and n != 2:\n        return False\n    for j in range(3, int(pow(n, 0.5) + 1), 2):\n        if n % j == 0:\n            return False\n    return True\nn = int(input())\nfor j in range(2, int(n / 2) + 1):\n    if prime(j) == False and prime(n - j) == False:\n        print(j, n - j)\n        break\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "n, m, k, l = map(int, input().split())\nif k + l > n:\n    print(-1)\nelse:\n    x = (k + l) // m + (1 if (k + l) % m != 0 else 0)\n    if x * m > n:\n        print(-1)\n    else:\n        print(x)\n", "complexity": "constant", "problem": "1068_A", "from": "CODEFORCES", "tags": "math"}
{"src": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\nc = list(map(int, input().split()))\nf = list(map(int, input().split()))\nh = [0] + list(map(int, input().split()))\ncnt1 = defaultdict(lambda : 0)\nfor i in c:\n    cnt1[i] += 1\ncnt2 = defaultdict(lambda : 0)\nfor i in f:\n    cnt2[i] += 1\nans = 0\nfor i in cnt2:\n    c1, c2 = cnt1[i], cnt2[i]\n    dp0 = [0]\n    l = 1\n    for _ in range(c2):\n        dp = [0] * (l + k)\n        for i in range(l):\n            dp0i = dp0[i]\n            for j in range(k + 1):\n                dp[i + j] = max(dp[i + j], dp0i + h[j])\n        l += k\n        dp0 = dp\n    ans += dp[min(c1, k * c2)]\nprint(ans)", "complexity": "cubic", "problem": "0999_F", "from": "CODEFORCES", "tags": "dp"}
{"src": "import math\n\n\nn=int(input())\n\nfor _ in range(n):\n    a,b=map(int,input().split())\n    ans=0\n    while a>0 and b>0:\n        if a>=b:\n            ans+=a//b\n            a=a%b\n        else:\n            ans+=b//a\n            b=b%a\n    print(ans)\n        ", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import math\nn,t=map(int,input().split())\nl=[]\nfor _ in range(n):\n    a,b=map(int,input().split())\n    x=a-b/2\n    y=a+b/2\n    l.append([x,y])\nl.sort()\nc=0\n \nfor i in range(n-1):\n    if(l[i+1][0]-l[i][1]>t):\n        c+=2\n    elif(l[i+1][0]-l[i][1]==t):\n        c+=1\nprint(c+2)\n    ", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "n,m=input().split()\ni=j=-1\nwhile(j<0):\n    mat=input()\n    j=mat.find('B')\n    i+=1\n    c=mat.count('B')//2+1\nprint(i+c,j+c)", "complexity": "quadratic", "problem": "1028_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n, m = map(int, input().split())\na = [int(i) for i in input().split()]\nb = [0] * n\nfor i in a:\n    b[i - 1] += 1\nb.sort()\nprint(b[0])\n", "complexity": "quadratic", "problem": "0961_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "if __name__ == '__main__':\n    cin = input\n    n = int(cin())\n    s, t = [*cin()], cin()\n    i, r = 0, list()\n\n    if sorted(s) != sorted(t):\n        print(-1)\n    else:\n        while i < n:\n            j = i\n            while j < n and s[j] != t[i]:\n                j += 1\n            s[i:j + 1] = s[j:j + 1] + s[i:j]\n            r.extend(range(j, i, -1))\n            i += 1\n        print(len(r))\n        print(*r)", "complexity": "quadratic", "problem": "1015_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys, math\n\ndef mp():\n    return list(map(int, input().split()))\n\ndef quer(x1, y1, x2, y2):\n    if x1 > x2 or y1 > y2:\n        return [0, 0]\n    s = (x2 - (x1 - 1)) * (y2 - (y1 - 1))\n    if s % 2 == 0:\n        return [s // 2, s // 2]\n    if (x1 + y1) & 1:\n        return [s // 2 + 1, s // 2]\n    return [s // 2, s // 2 + 1]\n        \n\ndef main():\n    q = int(input())\n    for i in range(q):\n        n, m = mp()\n        x1, y1, x2, y2 = mp()\n        s = quer(1, 1, n, m)\n        s1 = quer(x1, y1, x2, y2)\n        s[0] -= s1[0]\n        s[1] += s1[0]\n        \n        # print(s[::-1])\n        x3, y3, x4, y4 = mp()\n        xmn = max(x1, x3)\n        xmx = min(x2, x4)\n        ymn = max(y1, y3)\n        ymx = min(y2, y4)\n        s1 = quer(x3, y3, x4, y4)\n        s[0] += s1[1]\n        s[1] -= s1[1]\n        s1 = quer(xmn, ymn, xmx, ymx)\n        s[0] += s1[0]\n        s[1] -= s1[0]\n        print(*s[::-1])\n        \ndebug = 0\nif debug:\n    file = open(\"input.txt\", \"r\")\n    input = file.readline\nmain()\nif debug:\n    file.close()", "complexity": "constant", "problem": "1080_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "# import sys \n# sys.stdin = open('input.txt', 'r')  \n# sys.stdout = open('output.txt', 'w')\n\na = [int(i) for i in list(input())]\nb = [int(i) for i in list(input())]\n\nif (len(a)<len(b)):\n\ta.sort(reverse=True)\n\tans = 0\n\tfor i in range(len(a)):\n\t\tans = ans*10+a[i]\n\tprint(ans)\nelse:\n\t# ans = [0]*len(a)\n\tans = 0\n\tn = len(a)\n\tcount = [0]*10\n\tfor i in range(n):\n\t\tcount[a[i]] += 1\n\ti = 0\n\twhile (i<n):\n\t\tx = b[i]\n\t\tif (count[x]>0):\n\t\t\tans = ans*10+x\n\t\t\tcount[x] -= 1\n\t\t\ti += 1\n\t\telse:\n\t\t\tbreak\n\tif (i==n):\n\t\tprint(ans)\n\t\texit(0)\n\tx = b[i]\n\tflag = False\n\tfor j in range(x-1,-1,-1):\n\t\tif (count[j]>0):\n\t\t\tans = ans*10+j\n\t\t\tcount[j] -= 1\n\t\t\tflag = True\n\t\t\tbreak\n\tif (flag) :\n\t\tfor j in range(9,-1,-1):\n\t\t\twhile (count[j]>0):\n\t\t\t\tans = ans*10+j\n\t\t\t\tcount[j] -= 1\n\telse:\n\t\twhile (not flag):\n\t\t\tt = ans%10\n\t\t\tans = ans//10\n\t\t\tcount[t] += 1\n\t\t\tfor i in range(t-1,-1,-1):\n\t\t\t\tif (count[i]>0):\n\t\t\t\t\tcount[i] -= 1\n\t\t\t\t\tflag = True\n\t\t\t\t\tans = ans*10 + i\n\t\t\t\t\tbreak\n\t\tfor j in range(9,-1,-1):\n\t\t\twhile (count[j]>0):\n\t\t\t\tans = ans*10+j\n\t\t\t\tcount[j] -= 1\n\tprint(ans)\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys\n\nnext(sys.stdin)\n\nq_x, q_y = map(int, next(sys.stdin).rstrip().split())\nk_x, k_y = map(int, next(sys.stdin).rstrip().split())\ndest_x, dest_y = map(int, next(sys.stdin).rstrip().split())\n\ndef sign(x):\n    return 1 if x >= 0 else -1\n\ndef which_square(x, y):\n    return sign(x - q_x), sign(y - q_y)\n\nif which_square(k_x, k_y) == which_square(dest_x, dest_y):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n", "complexity": "constant", "problem": "1033_A", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation"}
{"src": "n = int(input())\n\nnums = list(map(int, input().split()))\ncosts = list(map(int, input().split()))\n\n\nk = -1\n\nfor i in range(n):\n    \n    kc = -1\n    for c in range(i + 1, n):\n        if nums[i] < nums[c] and (kc == -1 or kc > costs[c]):\n            if kc == -1:\n                kc = costs[c]\n            kc = costs[c]\n     \n    if kc > -1:\n        nat = kc\n        kc = -1\n        for c in range(i):\n            if nums[i] > nums[c] and (kc == -1 or kc > costs[c]):\n                if kc == -1:\n                    kc = costs[c]\n              \n                kc = costs[c]\n        \n        if kc > -1:\n            if k == -1:\n                k = nat + kc + costs[i]\n            k = min(nat + kc + costs[i], k)\n\nprint(k)    \n\n    \n    \n    \n", "complexity": "quadratic", "problem": "0987_C", "from": "CODEFORCES", "tags": "brute force,dp,implementation"}
{"src": "n = int(input())\nprint(n + n // 2)", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import math\nfor _ in range(1):\n    n,k=map(int,input().split())\n    l=list(map(int,input().split()))\n    ans=0\n    for i in range(n):\n\t    c=0\n\t    sum1=0\n\t    for j in range(i, n):\n\t\t    sum1 += l[j]\n\t\t    c+=1\n\t\t    if c >= k:\n\t\t\t    ans=max(ans,sum1/c)\nprint(ans)    \n                \n            \n        ", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "n, m, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nret = 0\nfor i in range(m):\n\tcur = 0\n\tfor j in range(i, n):\n\t\tif j % m == i:\n\t\t\tcur = max(0, cur)\n\t\t\tcur -= k\n\t\tcur += a[j]\n\t\tret = max(ret, cur)\nprint(ret)\n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "n, k = map(int, input().strip().split())\ndata = map(int, input().strip().split())\nsol = []\nmapping = [(-1,1000)]*256\nfor x in data:\n    if mapping[x][0] == -1:\n        for i in range(max(x-k+1,0), x+1):\n            if mapping[i][0] == -1:\n                if i > 0 and mapping[i-1][1]+(x-i+1) <= k:\n                    p = mapping[i-1][1]+1\n                    for j in range(i, x+1):\n                        mapping[j] = (mapping[i-1][0], p)\n                        p += 1\n                else:                    \n                    p = 1\n                    for j in range(i, x+1):\n                        mapping[j] = (i, p)\n                        p += 1\n                break\n    sol.append(mapping[x][0])\nprint(' '.join(map(str, sol)))", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "import sys\n\nsys.setrecursionlimit(10**5)\nint1 = lambda x: int(x)-1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.buffer.readline())\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LI1(): return list(map(int1, sys.stdin.buffer.readline().split()))\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\ndef BI(): return sys.stdin.buffer.readline().rstrip()\ndef SI(): return sys.stdin.buffer.readline().rstrip().decode()\ninf = 10**16\n# md = 10**9+7\n# md = 998244353\n\nn, md = LI()\n\ndef nHr(hn, hr):\n    return nCr(hn+hr-1, hr-1)\n\ndef nPr(com_n, com_r):\n    if com_r < 0: return 0\n    if com_n < com_r: return 0\n    return fac[com_n]*ifac[com_n-com_r]%md\n\ndef nCr(com_n, com_r):\n    if com_r < 0: return 0\n    if com_n < com_r: return 0\n    return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md\n\nn_max = 405\nfac = [1]\nfor i in range(1, n_max+1): fac.append(fac[-1]*i%md)\nifac = [1]*(n_max+1)\nifac[n_max] = pow(fac[n_max], md-2, md)\nfor i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md\npw = [1]\nfor i in range(400): pw.append(pw[-1]*2%md)\n\n# dp[i][j]...i\u306bj\u500b\u76ee\u306e\u767d\u3092\u7f6e\u3044\u305f\u3068\u304d\u306e\u5834\u5408\u306e\u6570\ndp = [[0]*(n//2+2) for _ in range(n+2)]\ndp[0][0] = 1\nfor i in range(1, n+2):\n    for j in range(1, n//2+2):\n        v = 0\n        for k in range(i-2, -1, -1):\n            v += dp[k][j-1]*pw[i-k-2]*nCr(i-j, i-k-1)%md\n        dp[i][j] = v%md\n# p2D(dp)\n\nans = sum(dp[-1])%md\nprint(ans)\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "n = [int(x) for x in input().split()]\na = []\nfor i in range(3):\n\ta.append([int(x) for x in input().split()])\n\ta[i].sort(reverse=True)\n\ndp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]\nans = 0\nfor i in range(n[0] + 1):\n\tfor j in range(n[1] + 1):\n\t\tfor k in range(n[2] + 1):\n\t\t\tif i < n[0] and j < n[1]:\n\t\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])\n\t\t\tif i < n[0] and k < n[2]:\n\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])\n\t\t\tif j < n[1] and k < n[2]:\n\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])\n\t\t\tans = max(ans, dp[i][j][k])\n\nprint(ans)", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "(x, y, z, t1, t2, t3) = map(int, input().split())\n\n\nif 3 * t3 + t2 * (abs(z - x) + abs(x - y)) <= t1 * abs(x - y):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n", "complexity": "constant", "problem": "1054_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from sys import exit\nn = int(input())\narr = [int(x) for x in input().split()]\ntmp = 0\nfor i in range(len(arr)):\n    tmp += (arr[i] - i)\narr.sort()\nc = 0\nfor i in range(1, n):\n    if arr[i] == arr[i - 1]:\n        c += 1\n    if i != 1 and arr[i] == arr[i - 1] and arr[i - 1] == arr[i - 2] + 1:\n        print(\"cslnb\")\n        exit()\nif c > 1 or (len(arr) >= 2 and arr[0] == arr[1] == 0):\n    print(\"cslnb\")\n    exit()\nprint(\"cslnb\" if tmp % 2 == 0 else \"sjfnb\")", "complexity": "nlogn", "problem": "1191_D", "from": "CODEFORCES", "tags": "games"}
{"src": "import sys\nfrom enum import Enum\n\nclass flag(Enum):\n    UNVISITED = -1\n    EXPLORED = -2\n    VISITED = -3\n\ndef match(p, s):\n    for i in range(len(p)):\n        if p[i] != \"_\" and p[i] != s[i]:\n            return False\n    return True\n\ndef cycleCheck(u):\n    global AL\n    global dfs_num\n    global dfs_parent\n    global sol\n\n    dfs_num[u] = flag.EXPLORED.value\n    for v in AL[u]:\n        if dfs_num[v] == flag.UNVISITED.value:\n            dfs_parent[v] = u\n            cycleCheck(v)\n        elif dfs_num[v] == flag.EXPLORED.value:\n            sol = False\n    dfs_num[u] = flag.VISITED.value\n\ndef toposort(u):\n    global AL\n    global dfs_num\n    global ts\n\n    dfs_num[u] = flag.VISITED.value\n    for v in AL[u]:\n        if dfs_num[v] == flag.UNVISITED.value:\n            toposort(v)\n    ts.append(u)\n\nsol = True\nn, m, k = map(int, sys.stdin.readline().strip().split())\npd = {}\nps = set()\npa = []\nfor i in range(n):\n    p = sys.stdin.readline().strip()\n    pd[p] = i + 1\n    ps.add(p)\n    pa.append(p)\n\nAL = [[] for _ in range(n)]\n\nfor _ in range(m):\n    s, fn = sys.stdin.readline().strip().split()\n    fn = int(fn)\n    if not match(pa[fn-1], s):\n        sol = False\n        \n    mm = [\"\"]\n    for i in s:\n        mm = list(map(lambda x: x + \"_\", mm)) + list(map(lambda x: x + i, mm))\n    for i in mm:\n        if i in ps:\n            if pd[i] != fn:\n                AL[fn-1].append(pd[i]-1)\n\ntry:    \n    if not sol:\n        print(\"NO\")\n    else:\n        dfs_num = [flag.UNVISITED.value] * n\n        dfs_parent = [-1] * n\n        for u in range(n):\n            if dfs_num[u] == flag.UNVISITED.value:\n                cycleCheck(u)\n        if not sol:\n            print(\"NO\")\n        else:\n            dfs_num = [flag.UNVISITED.value] * n\n            ts = []\n            for u in range(n):\n                if dfs_num[u] == flag.UNVISITED.value:\n                    toposort(u)\n            ts = ts[::-1]\n            print(\"YES\")\n            print(' '.join(map(lambda x: str(x+1), ts)))\nexcept:\n    print(\"NO\")", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "n=int(input())\nprint(2*n**2-2*n+1)", "complexity": "constant", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "'''\n    Auther: ghoshashis545 Ashis Ghosh\n    College: jalpaiguri Govt Enggineering College\n\n'''\nfrom os import path\nimport sys\nfrom heapq import heappush,heappop\nfrom functools import cmp_to_key as ctk\nfrom collections import deque,defaultdict as dd\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input().rstrip()\ndef mi():return map(int,input().split())\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\n# mod=1000000007\nmod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef bo(i):\n    return ord(i)-ord('a')\n\n\n    \ndef sod(n):\n    s = 0 \n    while n:\n        s += (n%10)\n        n //= 10\n    return s\n\n    \ndef solve():\n\n\n\n    n,s = mi()\n\n    def fun(mid):\n        return mid - sod(mid) >= s\n    \n    l = 0\n    r = n\n    ans = -1\n    while l <= r:\n        m = l+(r-l)//2\n        if fun(m):\n            ans = m\n            r = m-1\n        else:\n            l = m+1\n    if ans == -1:\n        ans = n+1\n    print(n-ans+1)\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n        \nif __name__ ==\"__main__\":\n\n    \n    if path.exists('input.txt'):\n        sys.stdin=open('input.txt', 'r')\n        sys.stdout=open('output.txt','w')\n    else:\n        input=sys.stdin.readline\n    solve()", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "from sys import stdin, gettrace\n\nif not gettrace():\n    def input():\n        return next(stdin)[:-1]\n\n\n# def input():\n#    return stdin.buffer.readline()\n\nINF = 10000\n\n\ndef main():\n    n = int(input())\n    aa = [int(a) for a in input().split()]\n\n    dp = [[0] * (n+1) for _ in range(n)]\n\n    def calc_dp(i, j):\n        if i + 1 == j:\n            dp[i][j] = aa[i]\n        if dp[i][j] != 0:\n            return dp[i][j]\n        dp[i][j] = -1\n        for k in range(i+1, j):\n            lf = calc_dp(i, k)\n            rg = calc_dp(k, j)\n            if lf > 0 and lf == rg:\n                dp[i][j] = lf + 1\n                break\n        return dp[i][j]\n\n    dp2 = list(range(0,n+1))\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if calc_dp(i, j) > 0:\n                dp2[j] = min(dp2[j], dp2[i] + 1)\n    print(dp2[n])\n\n\n\n\n\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "a = list(map(int,input().split()))\nb = list(map(int,input().split()))\nc = list(map(int,input().split()))\na,b,c= sorted([a,b,c])\n\npath = []\nfor i in range(min(a[1],b[1],c[1]) , max(a[1],b[1],c[1]) + 1):\n    path.append((b[0],i))\nfor i in range(a[0],b[0]+1):\n    path.append((i,a[1]))\nfor i in range(b[0],c[0]+1):\n    path.append((i,c[1]))\n\nprint(len(set(path)))\nfor i in set(path):\n    print(*i)\n", "complexity": "constant", "problem": "1086_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import sys\n\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\n\ndef solve():\n    s = list(map(lambda x: x-97, ns()))\n    t = list(map(lambda x: x-97, ns()))\n    n, m = len(s), len(t)\n    nxt = [[n+1]*26 for _ in range(n+2)]\n    for i in range(n-1, -1, -1):\n        nxt[i] = nxt[i+1][:]\n        nxt[i][s[i]] = i\n    for b in range(m):\n        t1 = t[:b]\n        t2 = t[b:]\n        dp = [[n+1]*(m-b+1) for _ in range(b+1)]\n        dp[0][0] = 0\n        for j in range(b+1):\n            for k in range(m-b+1):\n                if j:\n                    dp[j][k] = min(dp[j][k], nxt[dp[j-1][k]][t1[j-1]] + 1)\n                if k:\n                    dp[j][k] = min(dp[j][k], nxt[dp[j][k-1]][t2[k-1]] + 1)\n        # print(s, t1, t2)\n        # prn(dp)\n        if dp[b][m-b] <= n:\n            print('YES')\n            return\n    print('NO')\n    return\n\n# solve()\n\nT = ni()\nfor _ in range(T):\n    solve()\n", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nP=list(map(int,input().split()))\nmod=998244353\n\nINV=[None]*(n+1)#1/a\u306e\u30ea\u30b9\u30c8\u3092\u4e88\u3081\u4f5c\u3063\u3066\u304a\u304f.\nfor i in range(1,n+1):\n    INV[i]=pow(i,mod-2,mod)\n\nBLA=P.count(-1)\n\nif BLA==0 or BLA==1:\n    ANS=0\nelse:\n    LEFT=BLA*(BLA-1)//2*INV[BLA]%mod#\u5de6\u5074\u306e\u500b\u6570\u306e\u5e73\u5747\n    AVEP=BLA*(BLA-1)//2*pow(BLA-1,mod-2,mod)#\u5de6\u5074\u306b\u3042\u308b\u3082\u306e\u304c\u81ea\u5206\u3088\u308a\u5927\u304d\u3044\u78ba\u7387\u306e\u548c\n\n    ANS=LEFT*AVEP%mod\n\n\n#print(ANS,LEFT,AVEP)\ny=1\nfor i in range(BLA):\n    y=y*(BLA-i)%mod\n\nKOSUU=pow(y,mod-2,mod)\nBLALIST=[1]*(n+1)\nNONBLA=[]\nBLANUM=[0]*n\nfor i in range(n):\n    if P[i]!=-1:\n        BLALIST[P[i]]=0\n        BLANUM[i]=BLANUM[i-1]\n        NONBLA.append(P[i])\n        \n    else:\n        BLANUM[i]=BLANUM[i-1]+1\n\n#print(BLALIST)\nBLALIST[0]=0\nfor i in range(1,n+1):\n    BLALIST[i]=BLALIST[i-1]+BLALIST[i]\n    \nif BLA!=0:\n    for i in range(n):\n        if P[i]!=-1:\n            ANS=(ANS+(BLANUM[i]*(BLA-BLALIST[P[i]])+(BLA-BLANUM[i])*BLALIST[P[i]])*INV[BLA])%mod\n\n#print(ANS)\n\nA=NONBLA\n\nif A==[]:\n    print(ANS)\n    sys.exit()\n\n\nn=len(A)\nMAXA=max(A)\nMINA=min(A)\n\n\nBIT=[0]*(MAXA-MINA+2)#\u51fa\u73fe\u56de\u6570\u3092bit indexed tree\u306e\u5f62\u3067\u3082\u3063\u3066\u304a\u304f.\n\nfor i in range(n):#A[0],A[1],...\u3068BIT\u3092\u66f4\u65b0\n    bitobje=A[i]-MINA+1\n\n    x=bitobje\n    while x!=0:\n        ANS=(ANS-BIT[x])%mod\n        x-=(x&(-x))\n\n    #print(ANS)\n\n    x2=MAXA-MINA+1\n    #print(x2)\n    while x2!=0:\n        #print(x2,BIT)\n        ANS=(ANS+BIT[x2])%mod\n        x2-=(x2&(-x2))\n\n    #print(ANS)\n\n    y=bitobje\n    while y<=MAXA-MINA+1:\n        BIT[y]+=1\n        y+=(y&(-y))\n\n    #print(ANS,BIT)\n\nprint(ANS)\n\n", "complexity": "nlogn", "problem": "1096_F", "from": "CODEFORCES", "tags": "dp,math,probabilities"}
{"src": "#!/usr/bin/python\n# encoding:UTF-8\n# Filename:Base.py\n\nimport sys\nimport random\nimport copy\nfrom itertools import permutations, combinations\nfrom math import sqrt, fabs, ceil\nfrom collections import namedtuple\n\n# ------Util Const--------\n\nin_file_path = \"input.txt\"\noutput_file_path = \"output.txt\"\n\nSUBMIT = True\n\n\ndef get_array(x, initial=None):\n    dimension = len(x)\n    if dimension == 1:\n        return [copy.deepcopy(initial) for _ in range(x[0])]\n    else:\n        return [get_array(x[1:], initial) for _ in range(x[0])]\n\n\ndef read_num(fin, num_type=int):\n    tmp_list = [num_type(x) for x in fin.readline().strip().split()]\n    if len(tmp_list) == 1:\n        return tmp_list[0]\n    else:\n        return tuple(tmp_list)\n\ndef read_num_list(fin, num_type=int):\n    return [num_type(x) for x in fin.readline().strip().split()]\n\n\n# def solve(fin):\n#     n = read_num(fin)\n#     ans_set = None\n#     for i in range(n):\n#         tmp_list = read_num_list(fin)\n#         if ans_set == None:\n#             ans_set = set(tmp_list[1:])\n#         else:\n#             ans_set &= set(tmp_list[1:])\n#\n#     print(' '.join([str(x) for x in ans_set]))\n\n# def solve(fin):\n#     n, m = read_num(fin)\n#     a = [0] * m\n#     b = [0] * int(sqrt(n))\n#     for i in range(1, n + 1):\n#         a[i * i % m] += 1\n#\n#     ans = 0\n#     for x in range(m):\n#         y = (m - x) % m\n#         ans += a[x] * a[y]\n#     print(ans)\n\n# def BFS_count(x, chs, count):\n#     q = []\n#     q.append(x)\n#     while (q)\n#     return count[x]\n\ndef solve(fin):\n    n = read_num(fin)\n    f = read_num_list(fin)\n    new_f = [0] + f\n    for i in range(0, n):\n        new_f[i] -= 1\n    f = new_f\n    # print(f)\n    chs = get_array([n], [])\n    for i, p in enumerate(f):\n        if p >= 0:\n            chs[p].append(i)\n    # print(chs)\n    q = [x for x in range(0, n) if not chs[x]]\n    vis = [0] * n\n    count = [0] * n\n    while q:\n        x = q.pop(0)\n        if not chs[x]:\n            count[x] = 1\n        if f[x] >= 0:\n            vis[f[x]] += 1\n            # print(vis[f[x]], len(chs[f[x]]))\n            if vis[f[x]] == len(chs[f[x]]):\n                q.append(f[x])\n            count[f[x]] += count[x]\n\n\n    # print(chs)\n    count = sorted(count)\n    print(' '.join([str(x) for x in count]))\n\nif __name__ == '__main__':\n    if SUBMIT:\n        solve(sys.stdin)\n    else:\n        solve(open(in_file_path, 'r'))\n", "complexity": "linear", "problem": "1056_D", "from": "CODEFORCES", "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"}
{"src": "import string\nfrom collections import deque, Counter\nfrom functools import lru_cache\nimport math\n\nDEBUG = 0\n\ndef main():\n    # @lru_cache(400*2*2)\n    # def search(n, l_on, r_on):\n    #     nonlocal M\n    #     if n == 0: return 1\n    #     if l_on and r_on and n == 1: return 1\n    #     if n == 1: return 1\n    #     if r_on and not l_on: return search(n, r_on, l_on)\n\n    #     total = 0\n    #     for i in range(n):\n    #         total += search(n=i, l_on=l_on, r_on=True) * search(n=n-i-1, l_on=True, r_on=r_on) * comb(n-1, i) % M\n    #     # print(l_on,  n, r_on, '=>', total)\n    #     return total\n\n\n\n    T = 1\n    while T:\n        n, M = Input.read_typed(int)\n        N = n\n\n\n        f = [[0 for _ in range(n+1)] for _ in range(n+1)]\n        comb = [[0 for _ in range(n+1)] for _ in range(n+1)]\n        fact = [0] * (n+1)\n        inv = [0] * (n+1)\n        fact[0] = inv[0] = 1\n\n        for i in range(1, n+1):\n            fact[i] = (fact[i-1] * i) % M\n            inv[i] = pow(fact[i], M-2, M)\n\n        for i in range(0, n+1):\n            for j in range(0, i+1):\n                # comb[i][j] = fact[i]//(fact[j] * fact[i-j]) % M;\n                comb[i][j] = ((fact[i] * inv[j]) % M * inv[i-j]) % M\n                # print(i, j, '=>', math.comb(i, j) %M, comb[i][j])\n                # assert math.comb(i, j) % M == comb[i][j]\n\n        pow2 = [0] * (n+1)\n        pow2[0] = 1\n        for i in range(1, n+1):\n            pow2[i] = pow2[i-1]*2 % M \n            f[i][i] = pow2[i-1]\n\n        for total in range(1, n+1):\n            for manual in range(1, total):\n                if total > manual * 2 or total < manual: continue\n                for l in range(1, manual):\n                    f[total][manual] += f[total-l-1][manual-l] * pow2[l-1] * comb[manual][l]\n                    # f[total][manual] += f[total-l-1][manual-l] * pow(2, l-1, mod=M) * math.comb(manual, l)\n                    f[total][manual] %= M\n\n        c = 0\n        for i in range(1, n+1):\n            c += f[n][i]\n            # print(n, i)\n            # print(f[n][i])\n        print(c % M)\n        T -= 1 \n\n\n# Helper classes\nclass Input:\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def read_typed(cls):\n        return list(map(cls, input().split()))\n\n    @staticmethod\n    def read():\n        return input()\n\nclass Debug():\n    def __init__(self):\n        import sys\n        sys.stdout = open('output.out', 'w')\n        sys.stdin = open('input.in', 'r')\n\n    def __delete__(self):\n        sys.stdout.close()\n        sys.stdin.close()\n\ndef run():\n    if DEBUG: _ = Debug()\n    main()\n\nrun()\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import sys;input = sys.stdin.readline;n, k = map(int, input().split());s = input()[:-1];left, right = 0, n\nwhile left < right:\n    mid = right - (right - left) // 2;A = [[0] * (n + 2) for _ in range(k)]\n    for c in range(k):\n        A[c][n] = A[c][n + 1] = n + 1;L = 0\n        for i in range(n - 1, -1, -1):L = (L + 1 if s[i] == '?' or ord(s[i]) - ord('a') == c else 0);A[c][i] = i + mid if L >= mid else A[c][i + 1]\n    dp = [n + 1] * (1 << k);dp[0] = 0\n    for mask in range(1 << k):\n        for i in range(k):\n            if mask >> k & 1: continue\n            t = mask | 1 << i;dp[t] = min(dp[t], A[i][dp[mask]])\n    if dp[-1] <= n: left = mid\n    else: right = mid - 1\nprint(left)", "complexity": "np", "problem": "1550_E", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,strings,two pointers"}
{"src": "from sys import stdin\n\nmemo = {}\ndef max_splits(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n in memo:\n        return memo[n]\n    result = 4 * max_splits(n - 1) + 1\n    memo[n] = result\n    return result\n\nt = int(stdin.readline())\nfor i in range(t):\n    n, k = [int(s) for s in stdin.readline().strip().split()]\n\n    min_splits = 1\n    path_count = 3\n\n    if n > 75:\n        print(\"YES\", n - 1)\n        continue\n\n    square_size = n - 1\n    max_buffer = max_splits(square_size)\n\n    while min_splits + path_count <= k and square_size > 0:\n        min_splits += path_count\n        max_buffer += (4 * path_count - (2 * path_count + 1)) * max_splits(square_size - 1)\n        path_count = 2 * path_count + 1\n        square_size -= 1\n\n    if min_splits <= k <= min_splits + max_buffer:\n        print(\"YES\", square_size)\n    else:\n        print(\"NO\")\n", "complexity": "quadratic", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import sys\ninput=sys.stdin.readline\nn=int(input())\nc=[\" \"]+[input().rstrip() for i in range(n)]\nmod=10**9+7\ndp=[[0]*(n+1) for i in range(n+1)]\ndp[1][0]=1\nsdp=[0]*(n+1)\nsdp[0]=1\nfor i in range(1,n+1):\n    if i>=2 and c[i-1]==\"f\":\n        for j in range(1,n+1):\n            dp[i][j]=dp[i-1][j-1]\n            dp[i][j]%=mod\n        dp[i][0]=0\n    else:\n        for j in range(n+1):\n            dp[i][j]=sdp[j]\n            dp[i][j]%=mod\n    sdp=[dp[i][j] for j in range(n+1)]\n    for j in range(1,n+1)[::-1]:\n        sdp[j-1]+=sdp[j]\n        sdp[j-1]%=mod\nprint(sdp[0]%mod)", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "import sys,bisect,string,math,time,functools,random,fractions\nfrom heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nfrom itertools import permutations,combinations,groupby\nrep=range;R=range\ndef Golf():n,*t=map(int,open(0).read().split())\ndef I():return int(input())\ndef S_():return input()\ndef IS():return input().split()\ndef LS():return [i for i in input().split()]\ndef MI():return map(int,input().split())\ndef LI():return [int(i) for i in input().split()]\ndef LI_():return [int(i)-1 for i in input().split()]\ndef NI(n):return [int(input()) for i in range(n)]\ndef NI_(n):return [int(input())-1 for i in range(n)]\ndef StoLI():return [ord(i)-97 for i in input()]\ndef ItoS(n):return chr(n+97)\ndef LtoS(ls):return ''.join([chr(i+97) for i in ls])\ndef RA():return map(int,open(0).read().split())\ndef RLI(n=8,a=1,b=10):return [random.randint(a,b)for i in range(n)]\ndef RI(a=1,b=10):return random.randint(a,b)\ndef Rtest(T):\n    case,err=0,0\n    for i in range(T):\n        inp=INP()\n        a1,ls=naive(*inp)\n        a2=solve(*inp)\n        if a1!=a2:\n            print((a1,a2),inp)\n            err+=1\n        case+=1\n    print('Tested',case,'case with',err,'errors')\ndef GI(V,E,ls=None,Directed=False,index=1):\n    org_inp=[];g=[[] for i in range(V)]\n    FromStdin=True if ls==None else False\n    for i in range(E):\n        if FromStdin:\n            inp=LI()\n            org_inp.append(inp)\n        else:\n            inp=ls[i]\n        if len(inp)==2:\n            a,b=inp;c=1\n        else:\n            a,b,c=inp\n        if index==1:a-=1;b-=1\n        aa=(a,c);bb=(b,c);g[a].append(bb)\n        if not Directed:g[b].append(aa)\n    return g,org_inp\ndef GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1):\n    #h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1) # sample usage\n    mp=[boundary]*(w+2);found={}\n    for i in R(h):\n        s=input()\n        for char in search:\n            if char in s:\n                found[char]=((i+1)*(w+2)+s.index(char)+1)\n                mp_def[char]=mp_def[replacement_of_found]\n        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]\n    mp+=[boundary]*(w+2)\n    return h+2,w+2,mp,found\ndef TI(n):return GI(n,n-1)\ndef accum(ls):\n    rt=[0]\n    for i in ls:rt+=[rt[-1]+i]\n    return rt\ndef bit_combination(n,base=2):\n    rt=[]\n    for tb in R(base**n):s=[tb//(base**bt)%base for bt in R(n)];rt+=[s]\n    return rt\ndef gcd(x,y):\n    if y==0:return x\n    if x%y==0:return y\n    while x%y!=0:x,y=y,x%y\n    return y\ndef YN(x):print(['NO','YES'][x])\ndef Yn(x):print(['No','Yes'][x])\ndef show(*inp,end='\\n'):\n    if show_flg:print(*inp,end=end)\n\nmo=10**9+7\ninf=float('inf')\nFourNb=[(-1,0),(1,0),(0,1),(0,-1)];EightNb=[(-1,0),(1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)];compas=dict(zip('WENS',FourNb));cursol=dict(zip('LRUD',FourNb))\nl_alp=string.ascii_lowercase\n#sys.setrecursionlimit(10**9)\nread=sys.stdin.buffer.read;readline=sys.stdin.buffer.readline;input=lambda:sys.stdin.readline().rstrip()\n\n\nshow_flg=False\nshow_flg=True\n\nans=0\n\n#for _ in range(I()):\nx,y,z=LI()\nR=sorted(LI())[::-1]\nG=sorted(LI())[::-1]\nB=sorted(LI())[::-1]\n\ndp=[[[0]*(z+1) for j in range(y+1)]for i in range(x+1)]\n\nn=x+y+z\nfor t in range(0,n+1,2):\n    for i in range(x+1):\n        for j in range(y+1):\n            k=t-i-j\n            if 0<=k<=z:\n                if i+1<=x and j+1<=y:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])\n                if i+1<=x and k+1<=z:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])\n                if j+1<=y and k+1<=z:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])\n                #show((i,j,k),dp)\nans=max([dp[i][y][z]for i in range(x+1)])\nans=max(max([dp[x][i][z]for i in range(y+1)]),ans)\nans=max(max([dp[x][y][i]for i in range(z+1)]),ans)\n\nprint(ans)\n\n\n    \n    \n    \n    ", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "a,b=map(int,input().split())\nif max(a,b)-min(a,b) +1<=2:\n    print(-1)\nelif max(a,b)-min(a,b) +1==3:\n    if a % 2==1 and b %2==1:\n        print(-1)\n    else:\n        print(min(a,b),min(a,b)+1,min(a,b)+2)\nelse:\n    ans=0\n    for i in range(a,b+1):\n        if i%2==0:\n            ans=i\n            break\n    print(ans,ans+1,ans+2)", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO,IOBase\nfrom math import inf,isinf\n\ndef solve(s,t):\n    if len(t) == 1:\n        if s.count(t[0]):\n            return 'YES'\n        return 'NO'\n    for i in range(1,len(t)):\n        dp = [[-inf]*(i+1) for _ in range(len(s)+1)]\n        dp[0][0] = 0\n        for j in range(len(s)):\n            dp[j+1] = dp[j][:]\n            for k in range(i+1):\n                if k != i and s[j] == t[k]:\n                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])\n                if dp[j][k]+i != len(t) and not isinf(dp[j][k]) and s[j] == t[dp[j][k]+i]:\n                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)\n        # print(*dp,sep='\\n')\n        # print('-----')\n        for l in range(len(s)+1):\n            if dp[l][-1] == len(t)-i:\n                return 'YES'\n    return 'NO'\n\ndef main():\n    for _ in range(int(input())):\n        s = input().strip()\n        t = input().strip()\n        print(solve(s,t))\n\n#Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "n, m=[int(k) for k in input().split()]\nw=[int(k) for k in input().split()]\nw=[0]+w+[m]\nc, d=[], []\nres=0\nfor j in range(n+1):\n    c.append(res)\n    if j%2==0:\n        res+=w[j+1]-w[j]\nres=0\nfor j in range(n+1, -1, -1):\n    if j%2==0 and j!=n+1:\n        res+=w[j+1]-w[j]\n    d.append(res)\nd=d[::-1]\nmx=d[0]\nfor j in range(n+1):\n    mx=max(c[j]+(w[j+1]-w[j]-1)+(m-w[j+1]-d[j+1]), mx)\n#print(c)\n#print(d)\nprint(mx)", "complexity": "linear", "problem": "1000_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import sys\nfrom math import floor, ceil\n\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\n\nprint(ceil((n*2)/k) + ceil((n*5)/k) + ceil((n*8)/k))", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\n\nnew_arr = []\nfor i in range(n - 1):\n\tnew_arr.append(arr[i + 1] - arr[i])\n\nnew_arr.sort()\nprint(sum(new_arr[:n - k]))\n", "complexity": "nlogn", "problem": "1197_C", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import atexit\nimport io\nimport sys\n\n# Buffering IO\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\n\ndef main():\n    n, a, b = [int(x) for x in input().split()]\n    dc = {}\n    for i in range(n):\n        x, vx, vy = [int(x) for x in input().split()]\n        nx = x + vx\n        ny = a * x + b + vy\n        dd = a * nx - ny + b\n        if dd not in dc:\n            dc[dd] = {}\n        if (vx, vy) not in dc[dd]:\n            dc[dd][(vx, vy)] = 0\n        dc[dd][(vx, vy)] += 1\n\n    tot = 0\n    for v, k in dc.items():\n        tt = 0\n        pp = 0\n        for _, cc in k.items():\n            tt -= cc * (cc + 1) // 2\n            pp += cc\n        tt += pp * (pp + 1) // 2\n        tot += tt * 2\n    print(tot)\n\n\nif __name__ == '__main__':\n    main()", "complexity": "linear", "problem": "0975_D", "from": "CODEFORCES", "tags": "geometry,math"}
{"src": "line = input().split()\nline.sort()\na,b,c = line\nif a == b and a == c:\n    print(0)\nelif a == b:\n    print(1)\nelif b == c:\n    print(1)\nelse:\n    if a[1] == b[1] and b[1] == c[1] \\\n        and int(b[0])-int(a[0]) == 1 and int(c[0])-int(b[0]) == 1:\n        print(0)\n    elif a[1] == b[1] and int(b[0])-int(a[0]) in [1,2]:\n        print(1)\n    elif b[1] == c[1] and int(c[0])-int(b[0]) in [1,2]:\n        print(1)\n    elif a[1] == c[1] and int(c[0])-int(a[0]) in [1,2]:\n        print(1)\n    else:\n        print(2)\n\n", "complexity": "nlogn", "problem": "1191_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "s = input()\nl = list(map(int,input().split()))\nl.sort(reverse = True)\ns = sum(l)\nx = 0 \nc = 0\nfor i in l:\n    if x <= s:\n        c+=1\n        x+=i\n        s-=i\n    else:\n        break\nprint(c)", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "class vec():\n    def __init__(self, x, y=None):\n        if y is None:\n            x, y = x\n        self.x = x\n        self.y = y  \n    def __mod__(self, other):\n        return self.x*other.y - self.y*other.x\n    def __sub__(self, other):\n        return vec(self.x - other.x, self.y - other.y)\n    def __repr__(self):\n        return 'vec({}, {})'.format(self.x, self.y)\n\ndef lines_cross(a, b, c, d):\n    ab, ac, ad = b - a, c - a, d - a\n    cd, ca, cb = d - c, a - c, b - c\n    return (ab % ac) * (ab % ad) <= 0 and (cd % ca) * (cd % cb) <= 0\n\ndef rot(a):\n    return vec(a.x-a.y, a.x+a.y)\n\nax, ay, bx, by, cx, cy, dx, dy = map(int, input().split())\nkx, ky, lx, ly, mx, my, nx, ny = map(int, input().split())\nc, b, d, a = map(vec, sorted([(ax, ay), (bx, by), (cx, cy), (dx, dy)]))\nm, n, l, k = map(vec, sorted([(kx, ky), (lx, ly), (mx, my), (nx, ny)]))\nres = False\ns1 = [a, b, c, d]\ns2 = [k, l, m, n]\nfor i in range(4):\n    for j in range(4):\n        if lines_cross(s1[i], s1[(i+1)%4], s2[j], s2[(j+1)%4]):\n            res = True\n            break\n    if res:\n        break\nif all([b.x <= p.x <= a.x and c.y <= p.y <= b.y for p in [k, l, m ,n]]):\n    res = True\nif all([rot(l).x <= rot(p).x <= rot(k).x and rot(m).y <= rot(p).y <= rot(l).y for p in [a, b, c ,d]]):\n    res = True\nprint('YES' if res else 'NO')", "complexity": "constant", "problem": "0994_C", "from": "CODEFORCES", "tags": "brute force"}
{"src": "#!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    n,k = map(int, input().split())\n    l = list(map(int, input().split()))\n    d = dict()\n    c = set()\n    l.sort()\n    for i in range (n):\n        if not d.get(l[i]):\n            c.add(l[i])\n            d.setdefault(l[i]*k,1)\n    print(len(c))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "n = int(input())\nT = input().split(' ')\nfor i in range(n):\n    T[i]=int(T[i])\nL=[]\nM=[]\nt=0\nip=0\nIP=[]\nfor i in range(n):\n    if T[i]>=2:\n        L.append(i+1)\n        M.append(T[i])\n        t+=T[i]\n    else:\n        ip+=1\n        IP.append(i+1)\nif t-(2*len(L)-2)<ip:\n    print(\"NO\")\nelse:\n    for i in range(1, len(L)-1):\n        M[i]-=2\n    if len(L)>=2:\n        M[0]-=1\n        M[-1]-=1\n    print(\"YES\",end=' ')\n    if ip==0:\n        print(len(L)-1)\n    elif ip==1:\n        print(len(L))\n    else:\n        print(len(L)+1)\n    print(len(L)-1+ip)\n    if ip>=1:\n        print(IP[0], end=' ')\n        print(L[0])\n        M[0]-=1\n    if ip>=2:\n        print(IP[-1], end=' ')\n        print(L[-1])\n        M[-1]-=1\n    k=1\n    ind=0\n    while k < ip-1:\n        if M[ind]==0:\n            ind+=1\n        else:\n            print(IP[k], end=' ')\n            print(L[ind])\n            M[ind]-=1\n            k+=1\n    for i in range(len(L)-1):\n        print(L[i], end=' ')\n        print(L[i+1])\n", "complexity": "linear", "problem": "1082_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "def main():\n    a, b = map(int, input().split())\n    K = 60\n    if a == b:\n        ans = 0\n    else:\n        curr = K\n        while (b & (1 << curr)) == (a & (1 << curr)):\n            curr -= 1\n        ans = (1 << curr)\n        curr -= 1\n        lb = False\n        ga = False\n        for i in range(curr, -1, -1):\n            if (b & (1 << i)) == 0 and (a & (1 << i)) == 0:\n                if not lb:\n                    ans += (1 << i)\n                    ga = True\n                else:\n                    ans += (1 << i)\n            elif (b & (1 << i)) == 0 and (a & (1 << i)) == 1:\n                ans += (1 << i)\n            elif (b & (1 << i)) == 1 and (a & (1 << i)) == 0:\n                if not lb:\n                    ans += (1 << i)\n                    ga = True\n                    lb = True\n                else:\n                    ans += (1 << i)\n            else:\n                if not lb:\n                    ans += (1 << i)\n                    lb = True\n                else:\n                    ans += (1 << i)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "from __future__ import division\nfrom sys import stdin, stdout\nfrom collections import *\n\nrstr = lambda: stdin.readline().strip()\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint = lambda: int(stdin.readline())\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\nceil1, out = lambda a, b: (a + b - 1) // b, []\n\nn, s = rints()\na, ans = rints_2d(n), -1\n\nfor i in range(26):\n    for j in range(60):\n        tem = i * 60 + j\n        ans = (i, j)\n        for h, m in a:\n            tem2 = h * 60 + m\n            if tem <= tem2:\n                if tem2 - (tem + 1) < s:\n                    ans = -1\n                    break\n            else:\n                if tem - (tem2 + 1) < s:\n                    ans = -1\n                    break\n\n        if ans != -1:\n            print('%d %d' % (ans[0], ans[1]))\n            exit()\n", "complexity": "linear", "problem": "0967_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import os,sys\nfrom io import BytesIO, IOBase\n\nfrom collections import deque, Counter,defaultdict as dft\nfrom heapq import heappop ,heappush\nfrom math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor\nfrom bisect import bisect,bisect_left,bisect_right\nfrom decimal import *\nimport sys,threading\nfrom itertools import permutations, combinations\nfrom copy import deepcopy\ninput = sys.stdin.readline\n\n\nii = lambda: int(input())\nsi = lambda: input().rstrip()\nmp = lambda: map(int, input().split())\nms=  lambda: map(str,input().strip().split(\" \"))\nml = lambda: list(mp())\nmf = lambda: map(float, input().split())\n\n\nalphs = \"abcdefghijklmnopqrstuvwxyz\"\n\n\n\n\ndef solve():\n    n,m,k=map(int,input().split())\n    dct={}\n    global case\n    case=0\n    iput=[]\n    for i in range(n):\n        word=input()\n        dct[word]=i+1\n        iput.append(word)\n    d=[[] for i in range(n+1)]\n    size=[0]*(n+1)\n    for _ in range(m):\n        \n        word,idx=input().split()\n        idx=int(idx)\n        temp=1\n        w=iput[idx-1]\n        \n        for x in range(k):\n            if w[x]!='_' and w[x]!=word[x]:\n                temp=0\n                print(\"NO\")\n                exit()\n                break\n        \n        \n        res=[]\n        for i in range(1<<k):\n            s=\"\".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)])\n            #print(s)\n            \n            if s in dct:\n                j=dct[s]\n                if j!=idx:\n                    d[idx].append(j)\n                    size[j]+=1\n    \n    \n    \n    \n    st=[nd  for nd in range(1,n+1) if size[nd]==0]\n    \n    for i in st:\n        #print(st)\n        for j in d[i]:\n            size[j]-=1\n            if size[j]==0:\n                st.append(j)\n    \n    \n    if len(st)==n:\n        print(\"YES\")\n        print(*st)\n    else:\n        print(\"NO\")\n        \n    \n\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \n \nif __name__ == \"__main__\":\n    tc=1\n    #tc = ii()\n    for i in range(tc):\n    \tsolve()", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "import sys\n\n\nif __name__ == '__main__':\n    cin = sys.stdin\n\n    n = int(next(cin))\n    a = list(map(int, next(cin).split()))\n\n    n2idx = {a[i]: i for i in range(n)}\n\n    f = [False] * (n+1)\n\n    for i in range(n, 0, -1):\n        idx_lg = n2idx[i]\n\n        win_flag = False\n        for j in range(idx_lg%i, n, i):\n            if a[j] > i and not f[a[j]]:\n                win_flag = True\n                break\n        f[i] = win_flag\n        \n    f = ''.join(['A' if f[a_i] else 'B' for a_i in a])\n    print(f, flush=True)\n", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "def roll(i,j):\n    ways = []\n    if j:\n        ways.append(2*hor[i][j-1] + grid[i][j-1])\n    if m-1-j:\n        ways.append(2*hor[i][j] + grid[i][j+1])\n    if i:\n        ways.append(2*ver[i-1][j] + grid[i-1][j])\n    if n-1-i:\n        ways.append(2*ver[i][j] + grid[i+1][j])\n    return min(ways)\n\nn , m , k = map(int, input().split())\nhor = [list(map(int, input().split())) for _ in range(n)]\nver = [list(map(int, input().split())) for _ in range(n-1)]\n\n\ngrid = [[0]*m for _ in range(n)]\nif k%2:\n    for _ in range(n):\n        print(\" \".join([\"-1\"]*m))\nelse:\n    for _ in range(k//2):\n        new_grid = [[roll(i,j) for j in range(m)] for i in range(n)]\n        grid = new_grid[:]\n    for i in range(n):\n        print(\" \".join(map(str,grid[i])))", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import math\n\nn, r = map(int, input().split())\nangle = math.pi / n\ns = math.sin(angle)\n#rad = 1 / math.sin(angle) - 1\n#print('%.8f' % (r / rad))\nprint('%.8f' % (r * s / (1 - s)))\n", "complexity": "constant", "problem": "1100_C", "from": "CODEFORCES", "tags": "binary search,geometry,math"}
{"src": "k=int(input())\nx=0\nc=0\nwhile(x<k):\n    x+=9*(10**c)*(c+1)\n    c+=1\np=(x-k)%c\nk=((10**c)-int(((x-k)/c))-1)\nk=str(k)\nprint(k[len(k)-(p)-1])", "complexity": "constant", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "s=input()\nlength=len(s)\nanswer=[ ]\nfor i in range (0,length):\n    for j in range(i+1,length+1):\n        k=s[i:j]\n        co=0\n        for u in range (0,length):\n            if(s[u:].startswith(k)):\n                co+=1\n        if(co>=2):\n            #answer=max(answer,len(k))\n            answer.append(len(k))\nif(len(set(s))==length):\n    print('0')\nelse:\n    print(max(answer))\n\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "I=lambda:[*map(int,input().split())]\nR=range;m=min;N,M,K=I();r=R(N)\nif K&1:\n\tfor _ in r:print(*[-1]*M)\n\texit()\nA=[I()for _ in r]\nB=[I()for _ in R(N-1)]\nX=[M*[0]for _ in r]\nfor k in R(1,K//2+1):\n\tY=[M*[9**9]for _ in r]\n\tfor i in r:\n\t\tfor j in R(M):\n\t\t\tif i:Y[i][j]=X[i-1][j]+2*B[i-1][j]\n\t\t\tif i<N-1:Y[i][j]=m(Y[i][j],X[i+1][j]+2*B[i][j])\n\t\t\tif j:Y[i][j]=m(Y[i][j],X[i][j-1]+2*A[i][j-1])\n\t\t\tif j<M-1:Y[i][j]=m(Y[i][j],X[i][j+1]+2*A[i][j])\n\tX=Y\nfor x in X:print(*x)", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "n, k = [int(a) for a in input().split()]\npower = [int(a) for a in input().split()]\ncoins = [int(a) for a in input().split()]\n\ndp = [0 for i in range(n)]\n\n\ndef takeSecond(elem):\n    return elem[1]\n\n\ndef takeFirst(elem):\n    return elem[0]\n\n\npeople = [(power[i], coins[i], i) for i in range(n)]\n\npeople.sort(key=takeFirst)\n\ndp[0] = []\n\nfor i, p in enumerate(people):\n    if i == 0:\n        continue\n    kills = [i for i in dp[i - 1]]\n    kills.append(people[i - 1][1])\n    x = []\n\n    if len(kills) > k:\n        kills.remove(min(kills))\n\n    dp[i] = kills\n\nx = [(people[i][2], str(sum(dp[i]) + people[i][1])) for i in range(n)]\n\nx.sort(key=takeFirst)\n\nprint(\" \".join([z[1] for z in x]))\n", "complexity": "nlogn", "problem": "0994_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import sys\ninput = sys.stdin.readline\n\nR,G,B = map(int,input().split())\n\nr = list(map(int,input().split()))\ng = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nr.sort(reverse = True)\ng.sort(reverse = True)\nb.sort(reverse = True)\nr = [0] + r\ng = [0] + g\nb = [0] + b\nR += 1\nG += 1\nB += 1\ndp = [[[0]*B for _ in range(G)] for __ in range(R)]\n\nres = 0\n\nfor i in range(R):\n    for j in range(G):\n        for k in range(B):\n\n            tmp = 0\n            if i > 0 and j > 0:\n                tmp = max(tmp,dp[i-1][j-1][k]+r[i]*g[j])\n            if i > 0 and k > 0:\n                tmp = max(tmp,dp[i-1][j][k-1]+r[i]*b[k])\n            if j > 0 and k > 0:\n                tmp = max(tmp,dp[i][j-1][k-1]+g[j]*b[k])\n            dp[i][j][k] = tmp\n            res = max(res,tmp)\n\nprint(res)\n\n\n\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "'''     Design by Dinh Viet Anh(JOKER)\n//_____________________________________$$$$$__\n//___________________________________$$$$$$$$$\n//___________________________________$$$___$\n//___________________________$$$____$$$$\n//_________________________$$$$$$$__$$$$$$$$$$$\n//_______________________$$$$$$$$$___$$$$$$$$$$$\n//_______________________$$$___$______$$$$$$$$$$\n//________________$$$$__$$$$_________________$$$\n//_____________$__$$$$__$$$$$$$$$$$_____$____$$$\n//__________$$$___$$$$___$$$$$$$$$$$__$$$$__$$$$\n//_________$$$$___$$$$$___$$$$$$$$$$__$$$$$$$$$\n//____$____$$$_____$$$$__________$$$___$$$$$$$\n//__$$$$__$$$$_____$$$$_____$____$$$_____$\n//__$$$$__$$$_______$$$$__$$$$$$$$$$\n//___$$$$$$$$$______$$$$__$$$$$$$$$\n//___$$$$$$$$$$_____$$$$___$$$$$$\n//___$$$$$$$$$$$_____$$$\n//____$$$$$$$$$$$____$$$$\n//____$$$$$__$$$$$___$$$\n//____$$$$$___$$$$$$\n//____$$$$$____$$$\n//_____$$$$\n//_____$$$$\n//_____$$$$\n'''\nfrom math import *\nfrom cmath import *\nfrom itertools import *\nfrom decimal import *  # su dung voi so thuc\nfrom fractions import *  # su dung voi phan so\nfrom sys import *\nfrom types import CodeType, new_class\n#from numpy import *\n\n'''getcontext().prec = x # lay x-1 chu so sau giay phay (thuoc decimal)\nDecimal('12.3') la 12.3 nhung Decimal(12.3) la 12.30000000012\nFraction(a) # tra ra phan so bang a (Fraction('1.23') la 123/100 Fraction(1.23) la so khac (thuoc Fraction)\na = complex(c, d) a = c + d(i) (c = a.real, d = a.imag)\na.capitalize() bien ki tu dau cua a(string) thanh chu hoa, a.lower() bien a thanh chu thuong, tuong tu voi a.upper()\na.swapcase() doi nguoc hoa thuong, a.title() bien chu hoa sau dau cach, a.replace('a', 'b', slg)\nchr(i) ki tu ma i ord(c) ma ki tu c\na.join['a', 'b', 'c'] = 'a'a'b'a'c, a.strip('a') bo dau va cuoi ki tu 'a'(rstrip, lstrip)\na.split('a', slg = -1) cat theo ki tu 'a' slg lan(rsplit(), lsplit()), a.count('aa', dau = 0, cuoi= len(a)) dem slg\na.startswith('a', dau = 0, cuoi = len(a)) co bat dau bang 'a' ko(tuong tu endswith())\na.index(\"aa\") vi tri dau tien xuat hien (rfind())\ninput = open(\".inp\", mode='r')  a = input.readline()\nout = open(\".out\", mode='w') a.index(val) '''\n#inn = open(\".inp\", \"r\")\n\nn, m = map(int, (input().split()))\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nfor x in a:\n    if x in b:\n        print(x, end = ' ')", "complexity": "quadratic", "problem": "0994_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "print(0, 0, input())\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "a,v=map(int,input().split())\n\nl,d,w=map(int,input().split())\n\nt=0\n\ndef gett(a,b,c):\n\n    delta=b**2-4*a*c\n\n    t1=(-b+delta**(1/2))/(2*a)\n\n    t2=(-b-delta**(1/2))/(2*a)\n\n    if min(t1,t2)>0:\n\n        return min(t1,t2)\n\n    else:\n\n        return max(t1,t2)\n\nif 2*a*d<=w*w or v<=w:\n\n    if 2*a*l<=v*v:\n\n        t=(2*l/a)**(1/2)\n\n    else:\n\n        t=l/v+v/a/2\n\nelse:\n\n    tmp=d-1/2*v*v/a+1/2*(v-w)**2/a-v*(v-w)/a\n\n    if tmp<=0:\n\n        tmp2=l-d-(1/2*(v-w)**2/a+w*(v-w)/a)\n\n        if tmp2>=0:\n\n            t=tmp2/v+(v-w)/a+2*gett(a,2*w,w*w/(2*a)-d)+w/a\n\n        else:\n\n            t=gett(a/2,w,d-l)+2*gett(a,2*w,w*w/(2*a)-d)+w/a\n\n    else:\n\n        tmp2=l-d-(1/2*(v-w)**2/a+w*(v-w)/a)\n\n        if tmp2>=0:\n\n            t=tmp2/v+(v-w)/a+(2*v-w)/a+tmp/v\n\n        else:\n\n            t=gett(a/2,w,d-l)+(2*v-w)/a+tmp/v\n\nprint(\"%.12f\" %(t))\n\n\n\n# Made By Mostafa_Khaled", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import math\nfrom collections import defaultdict\n\ndef Extended_Euclid(n,m):\n    stack=[]\n    while m:\n        stack.append((n,m))\n        n,m=m,n%m\n    if n>=0:\n        x,y=1,0\n    else:\n        x,y=-1,0\n    for i in range(len(stack)-1,-1,-1):\n        n,m=stack[i]\n        x,y=y,x-(n//m)*y\n    return x,y\n\nclass MOD:\n    def __init__(self,p,e=1):\n        self.p=p\n        self.e=e\n        self.mod=self.p**self.e\n\n    def Pow(self,a,n):\n        a%=self.mod\n        if n>=0:\n            return pow(a,n,self.mod)\n        else:\n            assert math.gcd(a,self.mod)==1\n            x=Extended_Euclid(a,self.mod)[0]\n            return pow(x,-n,self.mod)\n\n    def Build_Fact(self,N):\n        assert N>=0\n        self.factorial=[1]\n        self.cnt=[0]*(N+1)\n        for i in range(1,N+1):\n            ii=i\n            self.cnt[i]=self.cnt[i-1]\n            while ii%self.p==0:\n                ii//=self.p\n                self.cnt[i]+=1\n            self.factorial.append((self.factorial[-1]*ii)%self.mod)\n        self.factorial_inv=[None]*(N+1)\n        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)\n        for i in range(N-1,-1,-1):\n            ii=i+1\n            while ii%self.p==0:\n                ii//=self.p\n            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod\n\n    def Fact(self,N):\n        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod\n\n    def Fact_Inv(self,N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inv[N]\n\n    def Comb(self,N,K,divisible_count=False):\n        if K<0 or K>N:\n            return 0\n        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod\n        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]\n        if divisible_count:\n            return retu,cnt\n        else:\n            retu*=pow(self.p,cnt,self.mod)\n            retu%=self.mod\n            return retu\n\ndef Bell_Numbers(N,mod,prime=False):\n    bell_numbers=[0]*(N+1)\n    bell_numbers[0]=1\n    MD=MOD(mod)\n    if prime:\n        MD.Build_Fact(min(mod-2,N-1))\n        for i in range(1,min(mod,N+1)):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n        for i in range(mod,N+1):\n            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod\n    else:\n        MD.Build_Fact(N-1)\n        for i in range(1,N+1):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n    return bell_numbers\n\nM,N=map(int,input().split())\nS=[input() for i in range(N)]\ndct=defaultdict(int)\nfor i in range(M):\n    tpl=()\n    for j in range(N):\n        tpl+=(S[j][i],)\n    dct[tpl]+=1\nans=1\nmod=10**9+7\nbell=Bell_Numbers(M,mod)\nfor c in dct.values():\n    ans*=bell[c]\n    ans%=mod\nprint(ans)", "complexity": "quadratic", "problem": "0908_E", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,math"}
{"src": "MOD = int(1e9+7)\nn = int(input())\na = [input() for i in range(n)]\ndp = [1]\nfor i in range(n):\n    if a[i] == 'f':\n        dp.append(0)\n        continue\n    for j in range(1, len(dp)):\n        dp[j] = (dp[j] + dp[j-1]) % MOD\nprint(dp[-1])\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "n=int(input())\na=list(map(int,input().split()))\nk=min(a[0],a[-1])//(n-1)\nfor i in range(1,n-1):\n    k=min(k,min(a[0],a[i])//i,min(a[i],a[-1])//(n-1-i))\nprint(k)\n", "complexity": "linear", "problem": "1159_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n, e = map( int, input().split() )\nd = (n - e) // 2\nq = []\nwhile n > 0:\n    i = min(n, d)\n    while i > 0:\n        q.append('1')\n        i -= 1\n        n -= 1\n    if n > 0:\n        q.append('0')\n        n -= 1\n\nprint( \"\".join(q) )", "complexity": "quadratic", "problem": "1159_D", "from": "CODEFORCES", "tags": "brute force,greedy,constructive algorithms,math,strings"}
{"src": "mod = 998244353\neps = 10**-9\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    N = int(input())\n    A = list(map(int, input().split())) + [0]\n    A.sort()\n\n    dp = [[0] * (i+1) for i in range(N+1)]\n    dp[0][0] = 1\n    l = 0\n    for i in range(1, N+1):\n        for ll in range(l+1, i):\n            if A[ll] * 2 <= A[i]:\n                l = ll\n            else:\n                break\n        for j in range(1, l+2):\n            dp[i][j] = (dp[l][j-1] + (dp[i][j-1] * (l-j+2))%mod)%mod\n        for j in range(i):\n            dp[i][j] = (dp[i-1][j] + dp[i][j])%mod\n    print(dp[-1][-1])\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "cubic", "problem": "1437_F", "from": "CODEFORCES", "tags": "combinatorics,dp,math,two pointers"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    n,m,k=map(int,input().split())\n    if (k%2==0):\n        DP=[[[10**9 for i in range(m)] for j in range(n)] for v in range(k//2)]\n        A=[]\n        B=[]\n        for i in range(n):\n            L=list(map(int,input().split()))\n            A.append(L)\n            for j in range(m-1):\n                DP[0][i][j]=min(DP[0][i][j],L[j])\n                DP[0][i][j+1]=min(L[j],DP[0][i][j+1])\n                \n        for i in range(n-1):\n            L=list(map(int,input().split()))\n            B.append(L)\n            for j in range(m):\n                DP[0][i][j]=min(DP[0][i][j],L[j])\n                DP[0][i+1][j]=min(DP[0][i+1][j],L[j])\n    \n        for k1 in range(1,k//2):\n            for i in range(n):\n                for j in range(m):\n                    if (i>0):\n                        DP[k1][i][j]=min(DP[k1][i][j],B[i-1][j]+DP[k1-1][i-1][j])\n                    if (j>0):\n                        DP[k1][i][j]=min(DP[k1][i][j],A[i][j-1]+DP[k1-1][i][j-1])\n                    if (i<(n-1)):\n                        DP[k1][i][j]=min(DP[k1][i][j],B[i][j]+DP[k1-1][i+1][j])\n                    if (j<(m-1)):\n                        DP[k1][i][j]=min(DP[k1][i][j],A[i][j]+DP[k1-1][i][j+1])\n                \n        for val in DP[(k//2)-1]:\n            ans=[i*2 for i in val]\n            print(*ans)\n    \n    else:\n        for i in range(n):\n            L=list(map(int,input().split()))\n        \n        for i in range(n-1):\n            L=list(map(int,input().split()))\n        \n        for i in range(n):\n            ans=[-1]*m\n            print(*ans)\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "\"\"\"\nBrandt Smith, Lemuel Gorion and Peter Haddad\n\ncodeforces.com\n\nProblem 12455\n\"\"\"\nimport sys\n\ndef set(mask, pos):\n    return mask | (1 << pos)\n\ndef isOn(mask, pos):\n    return mask & ( 1 << pos) > 0\n\nn, l, r, x = map(int, input().split(' '))\ndif = list(map(int, input().split(' ')))\n\ncount, mask = 0, 0\n\nwhile mask <= 2**n:\n    summ, bit = [], 0\n\n    while bit < n:\n                \n        if isOn(mask, bit):\n            summ.append(dif[bit])\n                    \n        bit += 1\n        \n    if sum(summ) <= r and sum(summ) >= l and max(summ) - min(summ) >= x:\n        count += 1\n                \n    mask += 1\n                \n                \nprint(count)\n\n    \n    \n\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "n=int(input())\na=[*map(int,input().split())]\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  r=range(i%x,n,x)\n  if s[i]==0:\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "print(\"? 0 0\")\nans00 = input()\nxr = 0\na = 0\nb = 0\ncb = 2 ** 29\nwhile cb:\n    print(\"?\", xr + cb, cb)\n    ans11 = input()\n    print(\"?\", xr, cb)\n    if ans11 == ans00:\n        ans01 = input()\n        if ans01 == '1':\n            a += cb\n            b += cb\n    else:\n        ans00 = input()\n        if ans11 == '1':\n            b += cb\n        else:\n            a += cb\n        xr += cb\n    cb //= 2\nprint(\"!\", a, b)", "complexity": "logn", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "n,m,k = list(map(int,input().split()))\n\nl = list(map(int,input().split()))\n\nout = 0\nd = 0\n\nwhile m > d:\n    nex = l[d]\n    page = (nex - d - 1)//k\n    add = 1\n    while d + add < m and (page * k) < l[d + add] - d  <= (page + 1) * k:\n        add += 1\n    d += add\n    out += 1\n\nprint(out)\n    \n", "complexity": "linear", "problem": "1190_A", "from": "CODEFORCES", "tags": "implementation,two pointers"}
{"src": "def sss(l,r,tt):\n    f = -1\n    while(l<=r):\n        mid = (l + r) >> 1\n        if(a[mid]-a[tt] <= m):\n           f = mid\n           l = mid + 1\n        else :\n           r = mid - 1\n    return f\n\nn , m =  map(int, input().split())\na = [int(x) for x in input().split()]\nf = 0\nl  = len(a)\n#print(\"l==\" + str(l))\nMaxx = -1\nfor i in range(0,l-2):\n    if(a[i+2] - a[i]<= m):\n         k = sss(i+2,l-1,i)\n         if(k != -1):\n             Maxx = max(Maxx,(a[k] - a[i+1])/(a[k]-a[i]))\nif(Maxx == -1):\n    print(-1)\nelse: print(\"%.15f\\n\" % Maxx)", "complexity": "nlogn", "problem": "0957_C", "from": "CODEFORCES", "tags": "binary search,greedy,math,two pointers"}
{"src": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n#mod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nN = INT()\nxw = [LIST() for _ in range(N)]\n\nrl = []\nfor x, w in xw:\n    rl.append((x-w, x+w))\n\nrl.sort(key = lambda x: (x[1], x[0]))\n\nans = 0\ntmp = -INF\n\nfor r, l in rl:\n    if r < tmp:\n        continue\n    ans += 1\n    tmp = l\n\nprint(ans)\n\n\n", "complexity": "nlogn", "problem": "0528_B", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "def norm(x):\n    return (x % 998244353 + 998244353) % 998244353\n\nn, k = map(int, input().split())\n\ndp1 = [0]\ndp2 = [0]\n\nfor i in range(n):\n    l = [1]\n    cur = 0\n    for j in range(n + 1):\n        cur += l[j]\n        if(j > i):\n            cur -= l[j - i - 1]\n        cur = norm(cur)\n        l.append(cur)\n    dp1.append(l[n])\n    dp2.append(norm(dp1[i + 1] - dp1[i]))\n\nans = 0\nfor i in range(n + 1):\n    for j in range(n + 1):\n        if(i * j < k):\n            ans = norm(ans + dp2[i] * dp2[j])\n\nans = norm(ans * 2)\n\nprint(ans)", "complexity": "cubic", "problem": "1027_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "def main():\n    n, m = map(int, input().split())\n    def intCompare(x):\n        if int(x) == m:\n            return 0\n        if int(x) < m:\n            return -1\n        return 1\n    p = list(map(intCompare, input().split()))\n    ret = 0\n    ind = p.index(0)\n    tem = 0\n    ret0 = [0] * 400001\n    ret1 = [0] * 400001\n    set0 = set()\n    for i in range(ind, -1, -1):\n        tem += p[i]\n        ret0[tem] += 1\n        set0.add(tem)\n    tem = 0\n    for i in range(ind, n):\n        tem += p[i]\n        ret1[tem] += 1\n    for i in set0:\n        ret += ret0[i] * (ret1[-i] + ret1[1-i]) \n    print(ret)\n    return 0\nmain()", "complexity": "nlogn", "problem": "1005_E1", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import sys\n\nrd = lambda : sys.stdin.readline().rstrip()\n\nt = int(rd())\nfor _ in range(t):\n    n = int(rd())\n    a = list(map(int, rd().split()))\n    b = []\n    res_a, res_b = 1, 1e18\n    \n    a = sorted(a)\n    i = 0\n    while i < n-1:\n        if a[i] == a[i+1]:\n            b.append(a[i])\n            i += 1\n            \n        i += 1\n        \n    p2s = lambda x, y : (x+y)**2/(x*y)\n    \n    for i in range(len(b)-1):\n        if p2s(res_a, res_b) > p2s(b[i], b[i+1]):\n            res_a, res_b = b[i], b[i+1]\n            \n    print(res_a, res_a, res_b, res_b)\n    \n    ", "complexity": "nlogn", "problem": "1027_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "def chnge(last,cap,ini=(0,0)):\n    for i in range(ini[1],last[1]):\n        fin[i][ini[0]:last[0]] = [cap]*(last[0]-ini[0])\n\nx1,y1,x2,y2,x3,y3 = map(int,input().split())\na = (max(x1,y1),[x1,y1],\"A\")\nb = (max(x2,y2),[x2,y2],\"B\")\nc = (max(x3,y3),[x3,y3],\"C\")\nm = max(a[0],b[0],c[0])\nfin = [[\"*\" for i in range(m)] for j in range(m)]\n\nif (x1*y1 + x2*y2 + x3*y3)!=m**2:\n    print(-1)\nelse:\n    l = sorted([a]+[b]+[c],reverse = True)\n    l[0][1].sort(reverse=True)\n    chnge(l[0][1],l[0][2])\n    ini=[0,l[0][1][1]]\n    last = l[1][1]\n    if m in [ini[0]+last[0],ini[1]+last[1]] and (ini[0]+last[0]+ini[1]+last[1])<=2*m:\n        last = [ini[0]+last[0],ini[1]+last[1]]\n    else:\n        last = [ini[0] + last[1], ini[1] + last[0]]\n    chnge(last,l[1][2],ini)\n    chr = l[2][2]\n    print(m)\n    for i in fin:\n        print(\"\".join(i).replace(\"*\",chr))", "complexity": "np", "problem": "0581_D", "from": "CODEFORCES", "tags": "bitmasks,brute force,constructive algorithms,geometry,implementation,math"}
{"src": "import os,sys,math \nfrom io import BytesIO, IOBase\nfrom collections import defaultdict,deque,OrderedDict\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\ndef I():return (int(input()))\ndef In():return(map(int,input().split()))\ndef ln():return list(map(int,input().split()))\ndef Sn():return input().strip()\nBUFSIZE = 8192\n#complete the main function with number of test cases to complete greater than x\ndef find_gt(a, x):\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:            \n        return len(a)\n\ndef solve():\n    n,m,k=In()\n    # rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]\n    rt,do=[list(In()) for i in range(n)],[list(In()) for i in range(n-1)]\n    # for i in range(n):\n    #     z=list(In())\n    #     for j in range(m-1):\n    #         rt[i][j]=z[j]\n    # for i in range(n-1):\n    #     z=list(In())\n    #     for j in range(m):\n    #         do[i][j]=z[j]\n\n    dp=[[0]*m for i in range(n)]\n    if k%2==1:\n        for i in range(n):\n            print(*[-1]*m)\n        return\n    k//=2\n    dp_next=[[P]*m for i in range(n)]\n    for op in range(k):\n        for i in range(n):\n            for j in range(m):\n                ans=Inf\n                if i!=0: \n                    ans=min(ans,dp[i-1][j]+do[i-1][j])\n                if j!=0: \n                    ans=min(ans,dp[i][j-1]+rt[i][j-1])\n                if i!=n-1:\n                    ans = min( ans , dp[i+1][j]+do[i][j])\n                if j!=m-1 : \n                    ans=min( ans , dp[i][j+1]+rt[i][j])\n                dp_next[i][j]=ans\n\n        for i in range(n):\n            for j in range(m):\n                dp[i][j]=dp_next[i][j]\n            \n    for i in range(n):\n        for j in range(m):\n            print(2*dp[i][j],end=' ')\n        print()\n\n\n\n\n\ndef main():\n    T=1\n    for i in range(T):\n        solve()\n        \nM = 998244353\nP = 1000000007\nInf=float('inf')\n\n\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == '__main__':\n    main()", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "fast=lambda:stdin.readline().strip()\nzzz=lambda:[int(i) for i in fast().split()]\nz,zz=input,lambda:list(map(int,z().split()))\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom re import *\nfrom sys import *\nfrom math import *\nfrom heapq import *\nfrom queue import *\nfrom bisect import *\nfrom string import *\nfrom itertools import *\nfrom collections import *\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom collections import Counter as cc\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))\ndef output(answer):stdout.write(str(answer))\n###########################---Test-Case---#################################\n\"\"\"\n\n  If you think, You Know me, Then you probably don't know me !\n\n\n\"\"\"\n###########################---START-CODING---##############################\n\n\nlst1={}\nlst2={}\nn=int(z())\nlst=set()\nfor _ in range( n ):\n    x,y=zzz()\n    lst1[x]=y\n    lst.add(x)\n    \nm=int(z())\n\nfor _ in range( m ):\n    x,y=zzz()\n    lst2[x]=y\n    lst.add(x)\n    \nans=0\nfor i in lst:\n    try:\n        x=lst1[i]\n    except:\n        x=0\n\n    try:\n        y=lst2[i]\n    except:\n        y=0\n    ans+=max(x,y)\nprint(ans)\n    \n", "complexity": "nlogn", "problem": "0981_B", "from": "CODEFORCES", "tags": "sortings"}
{"src": "# @author \n\nimport sys\n\nclass ADIYWoodenLadder:\n    def solve(self):\n        t = int(input())\n        for _ in range(t):\n            n = int(input())\n            a = [int(_) for _ in input().split()]\n            a.sort()\n            print(min(a[-2] - 1, n - 2))\n\nsolver = ADIYWoodenLadder()\ninput = sys.stdin.readline\n\nsolver.solve()\n", "complexity": "nlogn", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "def go():\n    n = int(input())\n    x, y = [int(i) for i in input().split(' ')]\n    a = 1 + 1\n    b = n + n\n    c = x + y\n    distance_w = c - a\n    distance_b = b - c\n    if distance_w == distance_b:\n        return 'White'\n    if distance_w < distance_b:\n        return 'White'\n    return 'Black'\n\nprint(go())\n", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n = int(input())\nans = (2 * (n - 1) ** 2) + 2 * n - 1\nprint(ans)\n", "complexity": "constant", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "n=input()\nl=list(map(lambda x:int(x)*2,raw_input().split(\" \")))\nt=list(map(lambda x:\"GWL\".index(x),raw_input()))\nmins=[0 for i in range(0,n+1)]\nfor i in range(n-1,-1,-1):\n\tif t[i]!=2:mins[i]=max(mins[i+1]-l[i],0)\n\telse:mins[i]=mins[i+1]+l[i]\ncurs=ans=st=0\nfor i in range(0,n):\n\tif(t[i]==0):\n\t\tcurs+=l[i];ans+=l[i]*5\n\t\tif(curs>mins[i+1]):\n\t\t\tol=(curs-mins[i+1])//2\n\t\t\tol=min(ol,l[i])\n\t\t\tans-=4*ol;curs-=2*ol\n\tif(t[i]==1):\n\t\tst=1;curs+=l[i];ans+=l[i]*3\n\tif(t[i]==2):\n\t\tif(curs<l[i]):\n\t\t\tol=l[i]-curs;curs=l[i]\n\t\t\tans+=ol*(3 if st else 5)\n\t\tcurs-=l[i];ans+=l[i]\nif curs>0:ans-=curs//2*2\nprint(ans//2)", "complexity": "linear", "problem": "1091_F", "from": "CODEFORCES", "tags": "constructive algorithms,greedy"}
{"src": "# from math import *\nfrom itertools import combinations\nfrom sys import stdin\ninput = stdin.readline\nintin = lambda: map(int, input().split())\n\nn, l, r, x = intin()\n*a, = intin()\nprint(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "n,k=map(int,input().split())\nn,k=n-1,k-1\nl=0\nr=k\ng=k*(k+1)//2\nans=-1\nwhile l<=r:\n\tm=(l+r)//2\n\tif (g-m*(m+1)//2)>=n:\n\t\tans=k-m\n\t\tl=m+1\n\telse:\n\t\tr=m-1\nprint(ans)", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "# link: https://codeforces.com/problemset/problem/961/C\n\nimport os, sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nfrom math import ceil\nmod = 10 ** 9 + 7 \n\ndef get_original_pieces(x):\n    common = (pow(x, 2) - 1) // 2\n    first_piece = \"10\"*common + '1'\n    second_piece = '0' + \"10\"*common\n    return [first_piece, second_piece]\n\n# number of test cases\nfor _ in range(1):\n    n = int(input())\n    pieces = [\"\" for _ in range(4)]\n    original_pieces = get_original_pieces(n)\n    i = 0\n    for _ in range(3 + (n*4)):\n        s = input()\n        if s:\n            pieces[i] += s\n        else:\n            i += 1   \n    #print(pieces) \n    till = pow(n, 2)\n    fp = [[0,i] for i in range(4)]\n    sp = [[0,i] for i in range(4)]\n    for i in range(4):\n        fpc, spc = 0, 0\n        for j in range(till):\n            if pieces[i][j] != original_pieces[0][j]:\n                fpc += 1\n            if pieces[i][j] != original_pieces[1][j]:\n                spc += 1\n        fp[i][0] = fpc\n        sp[i][0] = spc\n    fp.sort()\n    sp.sort()\n    ans1 = fp[0][0] + fp[1][0]\n    ans2 = sp[0][0] + sp[1][0]\n    for i in range(4):\n        if sp[i][1] not in [fp[0][1], fp[1][1]]: ans1 += sp[i][0]\n        if fp[i][1] not in [sp[0][1], sp[1][1]]: ans2 += fp[i][0]\n    ans = min(ans1, ans2)\n    print(ans)                            ", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "S = input()\nbest = 0\nfor i in range(len(S)):\n    for j in range(i+1, len(S)+1):\n        s = S[i:j]\n        c = 0\n        for k in range(len(S)):\n            if S[k:].startswith(s): c += 1\n        # print(s, c)\n        if c >= 2: \n            best = max(best, len(s))\nprint(best)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "def really_big(x):\n    sum_digit = 0\n    digits = x\n    while digits > 0:\n        sum_digit += digits % 10\n        digits = digits // 10\n\n    if x - sum_digit >= s:\n        return True\n    return False\n\ndef solve():\n    left = 1\n    right = n\n    ans = 0\n    while left <= right:\n        mid = (left + right) // 2\n        if really_big(mid): # mid is really big\n            right = mid - 1\n            ans = n - mid + 1\n        else: # mid is not really big\n            left = mid + 1\n    return ans\n\"\"\"\n25 20\n\"\"\"\n\nn, s = map(int, input().split())\nprint(solve())\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n \n# M = mod = 998244353\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\n# def inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n').split(' ')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\nn,L = li()\nl = []\nfor i in range(n):\n    l.append(li())\n\nindex = defaultdict(list)\nfor ind,i in enumerate(l):\n    index[tuple(i)].append(ind + 1)\n\nl.sort(key = lambda x:x[1])\nd = defaultdict(list)\n\nans = i = tot = currpoints = 0\nanspattern = []\nhe = []\n\nwhile i < n:\n    \n    if l[i][1] + tot <= L:\n        tot += l[i][1]\n        heapq.heappush(d[l[i][0]],l[i][1])\n        currpoints += 1\n\n        if len(d[l[i][0]]) == 1:\n            heapq.heappush(he,l[i][0])\n        \n    \n    while len(he) and currpoints > he[0]:\n        temp = heapq.heappop(he)\n        tot -= heapq.heappop(d[temp])\n        currpoints -= 1\n        if len(d[temp]):heapq.heappush(he,temp)\n    \n    if currpoints > ans:\n        ans = currpoints\n        \n    i += 1\ni = tot = currpoints = 0\nhe = []\nd = defaultdict(list)\n\nwhile i < n:\n    \n    if l[i][1] + tot <= L:\n        tot += l[i][1]\n        heapq.heappush(d[l[i][0]],l[i][1])\n        currpoints += 1\n\n        if len(d[l[i][0]]) == 1:\n            heapq.heappush(he,l[i][0])\n    \n    while len(he) and currpoints > he[0]:\n        temp = heapq.heappop(he)\n        tot -= heapq.heappop(d[temp])\n        currpoints -= 1\n        if len(d[temp]):heapq.heappush(he,temp)\n    \n    if currpoints == ans:\n        anspattern = []\n        for i in he:\n            for j in d[i]:\n                anspattern.append(index[tuple([i,j])][-1])\n                index[tuple([i,j])].pop()\n        print(ans)\n        print(len(anspattern))\n        print(*sorted(anspattern))\n        exit()\n    i += 1", "complexity": "nlogn", "problem": "0913_D", "from": "CODEFORCES", "tags": "binary search,brute force,data structures,greedy,sortings"}
{"src": "import os, sys, atexit\nfrom cStringIO import StringIO as BytesIO\n\nsys.stdout = BytesIO()\natexit.register(lambda: os.write(1, sys.stdout.getvalue()))\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\nrints = lambda: [int(x) for x in input().split()]\nrstr = lambda: input().strip()\nrstr_2d = lambda n: [rstr() for _ in range(n)]\n\nn, m = rints()\ngrid = rstr_2d(n)\nrow = [[[] for _ in range(m)] for _ in range(n)]\ncol = [[[] for _ in range(m)] for _ in range(n)]\nvisr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0\nvisc = [[-1 for _ in range(m)] for _ in range(n)]\n\nfor i in range(n):\n    be, en = -1, -1\n    for j in range(m):\n        if grid[i][j] == '*':\n            en += 1\n            if be == -1:\n                be = en = j\n        else:\n            if be != -1:\n                for k in range(be, en + 1):\n                    row[i][k] = [be, en]\n            be = -1\n\n    if be != -1:\n        for k in range(be, en + 1):\n            row[i][k] = [be, en]\n\nfor i in range(m):\n    be, en = -1, -1\n    for j in range(n):\n        if grid[j][i] == '*':\n            en += 1\n            if be == -1:\n                be = en = j\n        else:\n            if be != -1:\n                for k in range(be, en + 1):\n                    col[k][i] = [be, en]\n            be = -1\n\n    if be != -1:\n        for k in range(be, en + 1):\n            col[k][i] = [be, en]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '*':\n            all += 1\n            hor = min(row[i][j][1] - j, j - row[i][j][0])\n            ver = min(col[i][j][1] - i, i - col[i][j][0])\n            if hor <= ver:\n                ver = hor\n            else:\n                hor = ver\n\n            if hor > 0 and ver > 0:\n                out.append('%d %d %d' % (i + 1, j + 1, hor))\n                visr[i][j - ver] = j + ver\n                visc[i - hor][j] = i + hor\n\ndis = set()\nfor i in range(n):\n    j, ma = 0, -1\n    while j < m:\n        ma = max(ma, visr[i][j])\n        if ma >= j:\n            dis.add((i, j))\n\n        j += 1\n\nfor i in range(m):\n    j, ma = 0, -1\n    while j < n:\n        ma = max(ma, visc[j][i])\n        if ma >= j:\n            dis.add((j, i))\n\n        j += 1\n\nif len(dis) != all:\n    print(-1)\nelse:\n    sys.stdout.write('%d\\n%s' % (len(out), '\\n'.join(out)))\n", "complexity": "quadratic", "problem": "1015_E2", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "MOD=int(1e9+7)\nn=int(input())\na=[]\nfor i in range(n):\n    a.append(input())\na=\"\".join(a)\ndp,s=[],[]\nfor i in range(n+1):\n    dp.append([0]*(n+1))\n    s.append([0]*(n+1))\ndp[0][0]=1\ns[0][0]=1\nfor i in range(1,n):\n    for j in range(0,n):\n        if a[i-1]=='f':\n            dp[i][j+1]=dp[i-1][j]%MOD\n        elif a[i-1]=='s':\n            dp[i][j]=s[i-1][j]%MOD\n    \n    for j in reversed(range(n)):\n        s[i][j]+=(dp[i][j]+s[i][j+1])%MOD\nprint(s[n-1][0]%MOD)\n#sum from all levels\n\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "# n = int(input())\n# digits = list([])\n# new_digits= set({})\n# for i in range(n):\n#     n = int(input())\n#     if n in range(1,10):\n#         print(1)\n#         print(n)\n#     else:\n#         while n > 0 :\n#             digit = n % 10\n#             digits.append(digit)\n#             n = int(n /10)\n#         i = 0\n#         for d in digits:\n#             new_digits.add(d * 10**i)\n#             i += 1\n#         if 0 in new_digits:\n#              new_digits.remove(0)\n#         print(len(new_digits))\n#         for d in new_digits:\n#             print(d,end=\" \")\n#         print('')\n#         new_digits.clear()\n#         digits.clear()\n\n# we need to find the index of these values in the given array\n# n = int(input())\n# a = list(map(int,input().split(' ')))\n# b = list([])\n# for i in range(1,n+1):\n#     b.append(i)\n# results = []\n# for l in b:\n#     results.append(a.index(l) + 1)\n#\n# for r in results:\n#     print(r,end=\" \")\n\n\n# k = int(input())\n# l = int(input())\n# m = int(input())\n# n = int(input())\n# d = int(input())\n# nums = list([])\n# for i in range(1,d+1):\n#     nums.append(i)\n# results = set({})\n# for num in nums:\n#     if num % k == 0 :\n#         results.add(num)\n#     elif num % l == 0 :\n#         results.add(num)\n#     elif num % m == 0 :\n#         results.add(num)\n#     elif num % n == 0 :\n#         results.add(num)\n# print(len(results))\n\n# function problem\n# n = int(input())\n# result = 0\n#\n# if n %2 == 0:\n#     result = int(n /2)\n# else:\n#     result = -1 * (int(n / 2) + 1)\n# print(result)\n\n\n\n\n# General arrival\n# n = int(input())\n# a = list(map(int,input().split(' ')))\n# b = list(dict.fromkeys(a))\n# finding the max number and index\n# max_index = 0\n# i = 0\n# maxi = a[0]\n# while i < len(b):\n#     if b[i] >= maxi:\n#         maxi = b[i]\n#         max_index = i\n#     i += 1\n\n# finding the min number and index\n# min_index = 0\n# i = 0\n# mini = max(b)\n# while i < len(b):\n#     if b[i] <= mini:\n#         mini = b[i]\n#         min_index = i\n#     i += 1\n# if len(a) == 2:\n#     print(len(a) - 1)\n# else:\n#     print( (max_index - 0) + ((len(b) - 1) - min_index) )\n# print(b)\n\n\n\ndef is_prime(num):\n    if num > 1:\n        for i in range(2, num):\n            if (num % i) == 0:\n               return  False\n        else:\n            return True\n    else:\n        return False\n\nn = int(input())\ntemp = 0\nfirst = 0\nsecond = 0\nif n % 2 == 0:\n    temp = int(n/2)\n    first = temp\n    second = n - temp\n    while is_prime(first) or is_prime(second):\n        first -= 1\n        second += 1\n        if first + second == n and (not is_prime(first) and not is_prime(second)):\n            break\nelse:\n    temp = int(n / 2)\n    first = temp\n    second = n - first\n    while is_prime(first) or is_prime(second):\n        first -= 1\n        second += 1\n        if first + second == n and (not is_prime(first) and not is_prime(second)):\n            break\nprint(first,end=\" \")\nprint(second)", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "from os import path;import sys,time\nmod = int(1e9 + 7)\nfrom math import ceil, floor,gcd,log,log2 ,factorial,sqrt\nfrom collections import defaultdict ,Counter , OrderedDict , deque;from itertools import combinations,permutations\nfrom string import ascii_lowercase ,ascii_uppercase\nfrom bisect import *;from functools import reduce;from operator import mul;maxx = float('inf')\nI = lambda :int(sys.stdin.buffer.readline())\nlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\nS = lambda: sys.stdin.readline().strip('\\n')\ngrid = lambda  r :[lint() for i in range(r)]\nlocalsys = 0\nstart_time = time.time()\n#left shift --- num*(2**k) --(k - shift)\nnCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)\ndef ceill(n,x):\n    return (n+x -1 )//x\nT =0\n\ndef solve():\n\tarr = list(map(int , S()))\n\td ,s, ans  = {0} , 0 , 0\n\tfor i in arr:\n\t\ts+=i\n\t\ts%=3\n\t\tif s in d :\n\t\t\tans+=1\n\t\t\ts =0\n\t\t\td = {0}\n\t\td.add(s)\n\tprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t# n = I()\n\t# a = lint()\n\t# l , r ,ans = [1]*n , [1]*n , 1\n\t# for i in range(1 , n):\n\t# \tif a[i] > a[i-1]:\n\t# \t\tl[i] = l[i-1] + 1 #from left sort of prefix \n\t# \tans = max(ans , l[i]) \n\n\t# for i in range(n-2 ,-1 ,-1 ):\n\t# \tif a[i+1] > a[i]:\n\t# \t\tr[i] =r[i+1] +1\n\t# \tans = max(ans , r[i])\n\n\t# for i in range(1 , n - 1):\n\t# \tif a[i-1] < a[i+1]: #skipping one element\n\t# \t\tans = max(ans , l[i-1] + r[i+1])\n\t# print(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef run():\n    if (path.exists('input.txt')):\n        sys.stdin=open('input.txt','r')\n        sys.stdout=open('output.txt','w')\n\n\nrun()\nT = I() if T else 1\nfor _ in range(T):\n    solve()\n\n\nif localsys:\n    print(\"\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")\n\n\n", "complexity": "linear", "problem": "1005_D", "from": "CODEFORCES", "tags": "dp,greedy,number theory"}
{"src": "n,m=map(int,input().split())\nl1=list(map(int,input().split()))\nl2=list(map(int,input().split()))\nl1.sort()\nl2.sort()\nl2=l2[::-1]\nif n==1:\n    if l1[0]!=min(l2):\n        print(-1)\n    else :\n        print(sum(l2))\nelif max(l1)>min(l2):\n    print(-1)\nelse :\n    ans=0\n    l1=l1[::-1]\n    if min(l2)==l1[0]:\n        print(sum(l2) + (sum(l1)-l1[0])*m)\n    elif min(l2)!=l1[0]:\n        print(sum(l2)+l1[0]+sum(l1[1:])*m-l1[1])\n                \n            \n        ", "complexity": "nlogn", "problem": "1159_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "R=lambda:map(int,input().split())\na,b=R()\nx,y,z=R()\nprint(max(0,2*x+y-a)+max(0,y+3*z-b))", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nDP=[[-1]*(n+1) for i in range(n+1)]\nfor i in range(n):\n    DP[i][i]=A[i]\n\nfor mid in range(1,n):\n    for i in range(n):\n        j=i+mid\n        if j==n:\n            break\n        for k in range(i,j+1):\n            if DP[i][k]==DP[k+1][j] and DP[i][k]!=-1:\n                DP[i][j]=DP[i][k]+1\n\nANS=[2000]*(n+1)\nANS.append(0)\nfor i in range(n):\n    ANS[i]=min(ANS[i],ANS[i-1]+1)\n    for j in range(i,n):\n        if DP[i][j]!=-1:\n            ANS[j]=min(ANS[j],ANS[i-1]+1)\n            \nprint(ANS[n-1])\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\n#sys.setrecursionlimit(300000)\n#threading.stack_size(10**8)\n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------------------------------------------------------------\n#mod = 9223372036854775807  \nclass SegmentTree:\n    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n \n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n \n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n \n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n \n \nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n \n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n#-------------------------------------------------------------------------\nprime = [True for i in range(50001)] \npp=[]\ndef SieveOfEratosthenes(n=50000): \n      \n    # Create a boolean array \"prime[0..n]\" and initialize \n    #  all entries it as true. A value in prime[i] will \n    # finally be false if i is Not a prime, else true. \n    \n    p = 2\n    while (p * p <= n): \n          \n        # If prime[p] is not changed, then it is a prime \n        if (prime[p] == True): \n              \n            # Update all multiples of p \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n    for i in range(50001):\n        if prime[i]:\n            pp.append(i)\n#---------------------------------running code------------------------------------------\nn,m,k=map(int,input().split())\na=list(map(int,input().split()))\na.sort(reverse=True)\nif k>=m:\n    print(0)\nelse:\n    curr=k\n    count=0\n    for i in range (n):\n        curr+=a[i]-1\n        count+=1\n        if curr>=m:\n            break\n    if curr>=m:\n        print(count)\n    else:\n        print(-1)", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn,m,k=map(int,input().split())\nA=list(map(int,input().split()))\nA.append(n+1)\nCOMP=[]\nNOW=0\nfor a in A:\n    if a-NOW-1!=0:\n        if a-NOW-1>2*k:\n            COMP.append([(a-NOW-1)%k+k,0])\n        else:\n            COMP.append([a-NOW-1,0])\n    COMP.append([1,1])\n    NOW=a\n    \nCOMP.pop()\n\n#print(COMP)\n\nANS=0\nNOW_PAGE=0\nNOW_SCORE=0\n\npa=0\nLEN=len(COMP)\nwhile pa<LEN:\n    i,j=COMP[pa]\n  \n    if NOW_PAGE+i<=k:\n        NOW_PAGE += i\n        NOW_SCORE += j\n        pa+=1\n\n    else:\n        if NOW_SCORE>0:\n\n            COMP[pa][0]-=k-NOW_PAGE\n            NOW_PAGE=k-NOW_SCORE\n\n            ANS+=1\n            NOW_SCORE=0\n\n        else:\n            if NOW_PAGE==k:\n                NOW_PAGE=0\n                \n            else:              \n                COMP[pa][0]-=k-NOW_PAGE\n                NOW_PAGE=k-NOW_SCORE\n\n    #print(i,j,pa,NOW_PAGE,NOW_SCORE,ANS,COMP)\n\nif NOW_SCORE>0:\n    ANS+=1\n    \nprint(ANS)\n\n        \n        \n    \n", "complexity": "linear", "problem": "1190_A", "from": "CODEFORCES", "tags": "implementation,two pointers"}
{"src": "#!/usr/bin/env python\n    \nn, m = [int(x) for x in input().split()]\nmat = []\nv = []\n\nfor i in range(n):\n    mat.append([x == '#' for x in input()])\n    v.append([False]*m)\n\ndef check(m, v, x, y):\n    for i in (-1,0,1):\n        for j in (-1,0,1):\n            if (i,j) == (0,0):\n                continue\n            if not m[x+i][y+j]:\n                return\n\n    for i in (-1,0,1):\n        for j in (-1,0,1):\n            if (i,j) != (0,0):\n                v[x+i][y+j] = True\n\nfor x in range(1, n-1):\n    for y in range(1,m-1):\n        check(mat, v, x, y)\n\nflag = True\nfor i in range(0,n):\n    for j in range(0,m):\n        if mat[i][j] and (not v[i][j]):\n            flag = False\n\nif flag:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n=int(input())\nd={}\nfor _ in range(n):\n    a,x=map(int,input().split())\n    if a in d:\n        d[a][0]+=1\n        d[a][1].append(x)\n    else:\n        d[a]=[1,[x]]\n \n \nm=int(input())\nfor _ in range(m):\n    a,x=map(int,input().split())\n    if a in d:\n        d[a][0]+=1\n        d[a][1].append(x)\n    else:\n        d[a]=[1,[x]]\n \ns=0\nfor x in d:\n    if d[x][0]==1:\n        s+=d[x][1][0]\n    else:\n        s+=max(d[x][1])\nprint(s)", "complexity": "nlogn", "problem": "0981_B", "from": "CODEFORCES", "tags": "sortings"}
{"src": "s = input()\nans = 0\nfor i in range(len(s)):\n    for j in range(i + 1, len(s)):\n        cur = s[i:j]\n        if cur in s[:(j - 1)] or cur in s[(i + 1):]:\n            ans = max(ans, j - i)\nprint(ans)\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "#import resource\n#import sys\n#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n#sys.setrecursionlimit(0x10000000)\nfrom sys import stdin, stdout\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef ncr(n,r,p,f):\n    t=((f[n])*(modinv(f[r],p)%p)*(modinv(f[n-r],p)%p))%p\n    return t\nmod=(10**9)+7\ndef GCD(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\ndef BS(arr, l, r, x):\n    if r >= l:\n        mid = l + (r - l)/2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] > x:\n            return BS(arr, l, mid-1, x)\n        else:\n            return BS(arr, mid+1, r, x)\n    else:\n        return -1\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport itertools\nimport math\nfrom Queue import Queue as Q\n\"\"\"---------------------------------------------------------------------\"\"\"\ndef main():\n    n=input()\n    p=[]\n    f=[0]*(n+1)\n    for i in range(n):\n        l,r=map(int,stdin.readline().split())\n        p.append([l,\"l\"])\n        p.append([r,\"r\"])\n    p.sort(key=lambda x:x[0])\n    o=1\n    c=0\n    w=[]\n    for i in range(1,len(p)):\n        if(p[i][0]==p[i-1][0]):\n            if(p[i][1]==\"l\"):\n                o+=1\n            else:\n                c+=1\n        else:\n            w.append([p[i-1][0],o,c])\n            o,c=0,0\n            if(p[i][1]==\"l\"):\n                o=1\n            else:\n                c=1\n    w.append([p[-1][0],o,c])\n    s=0\n    i=0\n    r=-1\n    while(i<len(w)):\n        f[s]+=w[i][0]-r-1\n        f[s+w[i][1]]+=1\n        s+=w[i][1]-w[i][2]\n        r=w[i][0]\n        i+=1\n    for i in range(1,n+1):\n        stdout.write(str(f[i])+\" \")\nif __name__ == '__main__':\n    main()\n", "complexity": "nlogn", "problem": "1000_C", "from": "CODEFORCES", "tags": "data structures,implementation,sortings"}
{"src": "# minimal by inclusion means that any subset cannot satisfy the same requirements (essentially no duplicates at either end)\n\nn, k = map(int, input().split())\nvalues, single, l, r = [int(i) for i in input().split()], set(), -1, -1\nfor i in range(n):\n    single.add(values[i])\n    if len(single) == k:\n        l, r = 1, i + 1\n        break\nsingle = set()\nfor i in range(r - 1, max(-1, l - 2), -1):\n    single.add(values[i])\n    if len(single) == k:\n        l = i + 1\n        break\n        \nif len(single) < k:\n    print(-1, -1)\nelse:\n    print(l, r)\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "index = int(input())\n\ntotal = 9\nn = 1\n\nwhile index > total:\n    total += (n + 1) * (10**n) * 9\n    n += 1\nlast = 10**(n - 1)\ntotal -= n * 9 * last\nindex = index - total\n\n\nr = index % (n)\nk = index // n\n\nnumber = last + k\n\n\nif r == 0:\n    print(str(number - 1)[n-1])\nelse:\n    print(str(number)[r - 1])\n", "complexity": "constant", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict\ngraph=defaultdict(list)\nn=int(input())\npar=[ int(i) for i in input().split() if i!='\\n']\nbulb=[1]*(n+1)\nfor i in range(n-1):\n    bulb[par[i]]=0\n    graph[par[i]].append(i+2)\n#print(graph,bulb)\nzero=bulb.count(0)\nfor  i in range(n,0,-1):\n    if bulb[i]==0:\n        count=0\n        for j in graph[i]:\n            count+=bulb[j]\n        bulb[i]=count\nbulb=bulb[1:]\nbulb.sort()\nsys.stdout.write(' '.join(map(str,bulb)))\n", "complexity": "quadratic", "problem": "1056_D", "from": "CODEFORCES", "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"}
{"src": "from sys import stdin\nfrom itertools import combinations\nn, l, r , x = map(int, stdin.readline().rstrip().split(\" \"))\nli = list(map(int, stdin.readline().rstrip().split(\" \")))\nz = []\nans = 0\nfor i in range(2, n+1):\n    z += list(combinations(li, i))\n\nfor i in z:\n    a = sorted(i)\n    if a[-1]-a[0]>=x and r >= sum(a) >= l:\n        ans+=1\n\nprint(ans)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "MOD=1000000007\ndef pow2(n):\n    if n==0:\n        return 1\n    t=pow2(n//2)%MOD\n    m=(t*t)%MOD\n    if n%2==1:\n        m=(m*2)%MOD\n    return m\nx,k=map(int,input().split())\nif x==0:\n    print(0)\n    exit()\nt=pow2(k)*(2*x-1)%MOD\nprint((t+1)%MOD)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n=int(input())\nl=[input() for i in range(n)]\n#print(l)\ns=sorted(l,key=len)\nfor i in range(1,n):\n    if s[i-1] not in s[i]:\n        print(\"NO\")\n        exit()\n# else:\nprint(\"YES\")\nfor i in s:\n    print(i)\n\t     \t \t\t  \t   \t\t   \t\t \t\t\t \t\t", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "\nn = int(input())\npairs = [list(map(int, input().split()))+[i] for i in range(n)]\npairs.sort(key=lambda x:(x[0], -x[1]))\nfor i in range(1, n):\n    if pairs[i][1] <= pairs[i-1][1]:\n        print(pairs[i][2]+1, pairs[i-1][2]+1)\n        break\nelse:\n    print(-1, -1)", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "def inp():\n    return map(int, input().split())\n\n\ndef sum_range(n):\n    return (n * (n + 1)) // 2\n\n\ndef bs(st, en):\n    while (st < en):\n        mid = st + (en - st) // 2\n        s1 = s - sum_range(mid - 1)\n\n        if s1 == n:\n            return (k - mid) + 1\n        elif s1 > n:\n            st = mid + 1\n        else:\n            en = mid\n    return (k - st) + 2\n\n\nn, k = inp()\nn -= 1\nk -= 1\ns = sum_range(k)\n\nif n+1 == 1:\n    print(0)\nelif n <= k:\n    exit(print(1))\nelif n > s:\n    print(-1)\nelse:\n    print(bs(1, k))\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "def roll(i,j):\n    ways = []\n    if j:\n        ways.append(2*hor[i][j-1] + grid[i][j-1])\n    if m-1-j:\n        ways.append(2*hor[i][j] + grid[i][j+1])\n    if i:\n        ways.append(2*ver[i-1][j] + grid[i-1][j])\n    if n-1-i:\n        ways.append(2*ver[i][j] + grid[i+1][j])\n    return min(ways)\n\nn , m , k = map(int, input().split())\nhor = [list(map(int, input().split())) for _ in range(n)]\nver = [list(map(int, input().split())) for _ in range(n-1)]\n\n\ngrid = [[0]*m for _ in range(n)]\nif k%2:\n    for _ in range(n):\n        print(\" \".join([\"-1\"]*m))\nelse:\n    for _ in range(k//2):\n        new_grid = [[roll(i,j) for j in range(m)] for i in range(n)]\n        grid = new_grid[:]\n    for i in range(n):\n        print(\" \".join(map(str,grid[i])))", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "\"\"\"\n[input1]\n\n\n[output1]\n\n\n[input2]\n\n\n[output2]\n\n\"\"\"\n\nfrom sys import stdin\n\nsys_input = stdin.readline\n\n\ndef si(): return sys_input().rstrip()\n\n\ndef ii(): return int(si())\n\n\ndef sti(): return si().split()\n\n\ndef iti(): return map(int, sti())\n\n\ndef sli(): return list(si())\n\n\ndef ili(): return list(iti())\n\n\ndef main():\n    B.sort(reverse=True)\n    G.sort(reverse=True)\n\n    if B[0] > G[-1]:\n        print(-1)\n        return\n\n    boy_capacities = [M - 1] * N\n    current_capable_boy_index = 0\n    #sweets = [[b] * M for b in B]\n    result = sum(B) * M\n\n    for j, g in enumerate(G):\n        yet = True\n        while yet:\n            if B[current_capable_boy_index] < g and boy_capacities[current_capable_boy_index] > 0:\n                result += g - B[current_capable_boy_index]\n                #sweets[current_capable_boy_index][j] = g\n                boy_capacities[current_capable_boy_index] -= 1\n                yet = False\n            elif B[current_capable_boy_index] == g:\n                result += g - B[current_capable_boy_index]\n                #sweets[current_capable_boy_index][j] = g\n                yet = False\n            else:\n                current_capable_boy_index += 1\n                if current_capable_boy_index > N - 1:\n                    print(-1)\n                    return\n\n    #print(sweets)\n    print(result)\n\n    return\n\n\nif __name__ == '__main__':\n    N, M = iti()\n    B = ili()\n    G = ili()\n\n    main()\n", "complexity": "nlogn", "problem": "1159_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "\nmod = int(1e9 + 7)\n\nn = int(input())\na = [int(_) for _ in input().split()]\n\nfreq = {i: 0 for i in range(100001)}\npower = {0: 1}\nfor i in range(1, 100001):\n    power[i] = (2 * power[i - 1]) % mod\n\nfor v in a:\n    freq[v] += 1\n\ndp = {i: 0 for i in range(100001)}\nfor gcd in range(100000, 0, -1):\n    mult = 2\n    total = freq[gcd]\n    complement = 0\n    # xy = k, so integral is ln(x)\n    while mult * gcd <= 100000:\n        total += freq[mult * gcd]\n        complement += dp[mult * gcd]\n        mult += 1\n    dp[gcd] = (power[total] - 1 - complement + mod) % mod\n\nprint(dp[1])", "complexity": "np", "problem": "0803_F", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,number theory"}
{"src": "import sys\nimport heapq\n\nn, k = list(map(int,sys.stdin.readline().strip().split(' ')))\np = list(map(int,sys.stdin.readline().strip().split(' ')))\nc = list(map(int,sys.stdin.readline().strip().split(' ')))\n\nsortedp = sorted([(pi,i) for (i,pi) in enumerate(p)])\n\nans = [0 for i in range(n)]\nacc_coins = 0\nacc = []\n\nif k == 0:\n\tprint(' '.join(map(str,c)))\nelse:\n\tfor i in range(n):\n\t\tcoins = c[sortedp[i][1]]\n\t\tans[sortedp[i][1]] += acc_coins + coins\n\t\tif len(acc) < k:\n\t\t\tacc_coins += coins\n\t\t\theapq.heappush(acc,coins)\n\t\telse:\n\t\t\tsmallest_coin = heapq.nsmallest(1,acc)[0]\n\t\t\tif smallest_coin < coins:\n\t\t\t\tacc_coins -= smallest_coin\n\t\t\t\theapq.heappop(acc)\n\t\t\t\theapq.heappush(acc,coins)\n\t\t\t\tacc_coins += coins\n\tprint(' '.join(map(str,ans)))\n", "complexity": "nlogn", "problem": "0994_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "n, s = int(input()), input() * 2\nh = s.count('H') // 2\nprint(h - max(s[i:i + h].count('H') for i in range(n)))", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import sys\nsys.stderr = sys.stdout\n\nfrom math import inf\n\n\ndef explorer(n, m, k, R, C):\n    if k % 2:\n        return None\n\n    G = [[0] * m for _ in range(n)]\n    G_ = [[0] * m for _ in range(n)]\n    for _ in range(k // 2):\n        for i in range(n):\n            for j in range(m):\n                x = inf\n                if i > 0:\n                    x = min(x, G[i-1][j] + 2*C[i-1][j])\n                if i + 1 < n:\n                    x = min(x, G[i+1][j] + 2*C[i][j])\n                if j > 0:\n                    x = min(x, G[i][j-1] + 2*R[i][j-1])\n                if j + 1 < m:\n                    x = min(x, G[i][j+1] + 2*R[i][j])\n                G_[i][j] = x\n        G, G_ = G_, G\n    return G\n\n\ndef main():\n    n, m, k = readinti()\n    R = readintll(n)\n    C = readintll(n-1)\n    G = explorer(n, m, k, R, C)\n    if G:\n        print(llstr(G))\n    else:\n        s = ' '.join('-1' for _ in range(m))\n        print('\\n'.join(s for _ in range(n)))\n\n##########\n\ndef readint():\n    return int(input())\n\n\ndef readinti():\n   return map(int, input().split())\n\n\ndef readintt():\n   return tuple(readinti())\n\n\ndef readintl():\n   return list(readinti())\n\n\ndef readinttl(k):\n    return [readintt() for _ in range(k)]\n\n\ndef readintll(k):\n    return [readintl() for _ in range(k)]\n\ndef lstr(l):\n    return ' '.join(map(str, l))\n\ndef llstr(ll):\n    return '\\n'.join(map(lstr, ll))\n\n\ndef log(*args, **kwargs):\n    print(*args, **kwargs, file=sys.__stderr__)\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "# Code by Sounak, IIESTS\n# ------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\n# sys.setrecursionlimit(300000)\n# threading.stack_size(10**8)\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# -------------------------------------------------------------------------\n# mod = 9223372036854775807\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\nclass SegmentTree1:\n    def __init__(self, data, default=10 ** 6, func=lambda a, b: min(a, b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\nMOD = 10 ** 9 + 7\n\n\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\n\nmod = 10 ** 9 + 7\nomod = 998244353\n# -------------------------------------------------------------------------\nprime = [True for i in range(10)]\npp = [0] * 10\n\n\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c = 0\n    while (p * p <= n):\n\n        if (prime[p] == True):\n            c += 1\n            for i in range(p, n + 1, p):\n                pp[i] += 1\n                prime[i] = False\n        p += 1\n\n\n# ---------------------------------Binary Search------------------------------------------\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n - 1\n    res = -1\n    while (left <= right):\n        mid = (right + left) // 2\n        if (arr[mid] >= key):\n            res = arr[mid]\n            right = mid - 1\n        else:\n            left = mid + 1\n    return res\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n - 1\n    res = -1\n    while (left <= right):\n        mid = (right + left) // 2\n        if (arr[mid]>=key):\n            right = mid - 1\n        else:\n            res = arr[mid]\n            left = mid + 1\n    return res\n\n\n# ---------------------------------running code------------------------------------------\nn,k=map(int,input().split())\nprev=defaultdict(int)\nfor ik in range(k):\n    cur=int(input())\n    s=list(input())\n    t=2\n    while(cur%t==0):\n        t*=2\n    t//=4\n    for i in range(len(s)):\n        if cur==(n+1)//2:\n            if s[i]=='U':\n                continue\n            else:\n                if s[i]=='L':\n                    cur-=t\n                else:\n                    cur+=t\n                t//=2\n        elif cur%2==1:\n            if s[i]==\"U\":\n                if cur&2==0:\n                    cur+=1\n                else:\n                    cur-=1\n                t=1\n        else:\n            if s[i] == 'L':\n                cur-=t\n                t//=2\n            elif s[i]==\"U\":\n                if cur&t*4==0:\n                    cur+=t*2\n                else:\n                    cur-=t*2\n                t*=2\n            else:\n                cur+=t\n                t//=2\n    print(cur)\n\n\n", "complexity": "np", "problem": "0792_D", "from": "CODEFORCES", "tags": "bitmasks,trees"}
{"src": "import itertools\nimport bisect\nimport math\nfrom collections import *\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nii = lambda: int(input())\nlmii = lambda: list(map(int, input().split()))\nli = lambda: list(input())\nmii = lambda: map(int, input().split())\nmsi = lambda: map(str, input().split())\n\n\ndef main():\n    a = li()\n    b = li()\n    n = len(a)\n    ans = 0\n    for i in range(n):\n        if a[i] == \"0\":\n            ans += 1\n            if i - 1 >= 0 and a[i] == b[i] == b[i - 1]:\n                a[i] = b[i] = b[i - 1] = \"X\"\n            elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]:\n                a[i] = b[i] = a[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i] == b[i + 1]:\n                a[i] = b[i] = b[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]:\n                a[i] = b[i + 1] = a[i + 1] = \"X\"\n            elif i + 1 < n and a[i] == b[i] == a[i + 1]:\n                a[i] = b[i] = a[i + 1] = \"X\"\n            else:\n                ans -= 1\n    print(ans)\n    pass\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n# 3b5d858938ed5adabba546577a06a820e2ffb0defd893320d00e9740333b19c5\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "constant", "problem": "0991_D", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n = int(input())\nl = [input() for _ in range(n)]\nl.sort(key=lambda x: len(x))\n\nok = True\nfor i in range(n-1):\n  if l[i] not in l[i+1]:\n    ok = False\n    break\n\nif ok:\n  print(\"YES\")\n  print(*l, sep='\\n')\nelse:\n  print(\"NO\")\n", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "s=input()\nc=c1=0\nfor i in range(len(s)//2):\n    if s[i]==s[len(s)-i-1]:\n        c+=1\nfor i in range(len(s)):\n    if s[i]==s[0]:\n        c1+=1\nif c1==len(s):\n    print(0)\nelif c==len(s)//2:\n    print(len(s)-1)\nelse:\n    print(len(s))", "complexity": "linear", "problem": "0981_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "a=input()\nn=len(a)\nfor i in range(n-1,-1,-1):\n    b=sorted([a[j:j+i] for j in range(n-i+1)])\n    if True in [b[j]==b[j-1] for j in range(1,n-i+1)]:\n        print(i)\n        break", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "n, m = map(int, input().split())\n\nl=[]\ns1 = s2 = 0\nfor i in range(n):\n    a, b = map(int, input().split())\n    s1+=a\n    s2+=b\n    l.append(a-b)\n\nif s1<=m: print(0)\nelif s2>m: print(-1)\nelse:\n    r=0\n    l.sort(reverse=True)\n    for i in l:\n        r+=1\n        s1-=i\n        if s1<=m:\n            print(r)\n            break", "complexity": "nlogn", "problem": "1015_C", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n# from sys import stdin\n# input = stdin.readline\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ntry:\n    # sys.setrecursionlimit(int(pow(10,7)))\n    sys.stdin = open(\"input.txt\", \"r\")\n    # sys.stdout = open(\"../output.txt\", \"w\")\nexcept:\n    pass\ndef pmat(A):\n    for ele in A:\n        print(*ele,end=\"\\n\")\ndef seive():\n    prime=[1 for i in range(10**6+1)]\n    prime[0]=0\n    prime[1]=0\n    for i in range(10**6+1):\n        if(prime[i]):\n            for j in range(2*i,10**6+1,i):\n                prime[j]=0\n    return prime\n\n\n\na,b=L()\ndef rec(a,b):\n    if b==1:\n        return a\n    if a>b:\n        return a//b+rec(b,a%b)\n    else:\n        return rec(b,a)\nprint(rec(a,b))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nendtime = time.time()\n# print(f\"Runtime of the program is {endtime - starttime}\")", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "n=int(input())\nx,y=map(int,input().split())\nd1=max(x-1,y-1)\nd2=max(n-x,n-y)\nif d1<=d2:\n    print(\"White\")\nelse:\n    print(\"Black\")", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n, m, k = map(int, input().split(' '))\np = tuple(map(int, input().split(' ')))\n\n\nd = 0\npart = (p[0]-1) // k\nmoves = 0\nskip = 0\n\nfor pi in p:\n    if (pi-1-d) // k == part:\n        skip += 1\n        continue\n    d += skip\n    part = (pi-1-d) // k\n    skip = 1\n    moves += 1\n\nprint(moves+1)\n", "complexity": "linear", "problem": "1190_A", "from": "CODEFORCES", "tags": "implementation,two pointers"}
{"src": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @oj: codeforces\n# @id: hitwanyang\n# @email: 296866643@qq.com\n# @date: 2021/4/20 23:57\n# @url: https://codeforces.com/contest/988/problem/D\nimport sys, os\nfrom io import BytesIO, IOBase\nimport collections, itertools, bisect, heapq, math, string\nfrom decimal import *\nfrom collections import deque\n\n# region fastio\n\nBUFSIZE = 8192\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# ------------------------------\n## \u6ce8\u610f\u5d4c\u5957\u62ec\u53f7!!!!!!\n## \u5148\u6709\u601d\u8def,\u518d\u5199\u4ee3\u7801,\u522b\u7740\u6025!!!\n## \u5148\u6709\u6734\u7d20\u89e3\u6cd5,\u4e0d\u8981\u6709\u601d\u7ef4\u5b9a\u5f0f,\u8bd5\u7740\u6362\u601d\u8def\u89e3\u51b3\n## \u7cbe\u5ea6 print(\"%.10f\" % ans)\n## sqrt:int(math.sqrt(n))+1\n## \u5b57\u7b26\u4e32\u62fc\u63a5\u4e0d\u8981\u7528+\u64cd\u4f5c\uff0c\u4f1a\u8d85\u65f6\n## \u4e8c\u8fdb\u5236\u8f6c\u6362:bin(1)[2:].rjust(32,'0')\n## array copy:cur=array[::]\n## oeis(CROSSREFS):example 1, 3, _, 1260, _, _, _, _, _, 12164510040883200\n## sqrt:Decimal(x).sqrt()\u907f\u514d\u7cbe\u5ea6\u8bef\u5dee\n## \u65e0\u7a77\u5927\u8868\u793a:float('inf')\n## py 10**6 \u6392\u5e8f+\u53cc\u6307\u9488 3\u79d2\u53ef\u80fdTLE\n## \u6309\u533a\u95f4\u53f3\u7aef\u70b9\u6392\u5e8f,current.left>pre.right,\u8d2a\u5fc3\u6c42\u4e0d\u76f8\u4ea4\u533a\u95f4\u7684\u6700\u5927\u4e2a\u6570\n## \u52a0\u6cd5>\u4f4d\u8fd0\u7b97\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = set(a)\n    a.sort()\n    ans = []\n    for i in range(n):\n        for j in range(31):\n            tmp = [a[i]]\n            x = a[i] + 2 ** j\n            y = a[i] + 2 ** (j + 1)\n            if x in s:\n                tmp.append(x)\n            if y in s:\n                tmp.append(y)\n            if len(tmp) > 1:\n                if len(ans) == 0:\n                    ans.append(tmp)\n                else:\n                    if len(tmp) > len(ans[0]):\n                        ans[0] = tmp\n    if len(ans) == 0:\n        print(1)\n        print(a[0])\n        return\n    if len(ans[0]) == 2:\n        print(2)\n        print(ans[0][0], ans[0][1])\n        return\n    if len(ans[0]) == 3:\n        print(3)\n        print(ans[0][0], ans[0][1], ans[0][2])\n        return\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "nlogn", "problem": "0988_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "n,k=[int(i) for i in input().split()]\na = pow(1+2*k+2*n,0.5) - 1\nprint(n-int(a))\n", "complexity": "constant", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n,t=map(int,input().split())\nlist=[]\nfor i in range (n):\n    x,a=map(int,input().split())\n    list.append((x-a/2,x+a/2))\nlist.sort()\nans=2\nfor i in range(n-1):\n    dis=list[i+1][0]-list[i][1]\n    if dis>t:\n        ans+=2\n    elif dis==t:\n        ans+=1\nprint(ans)", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "from sys import stdin,stdout,setrecursionlimit\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush,nlargest\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm , accumulate\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nsetrecursionlimit(10**9)\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n# from sys import stdin\n# input = stdin.readline\n#def data(): return sys.stdin.readline().strip()\ndef data(): return input()\ndef num():return int(input())\ndef L(): return list(sp())\ndef LF(): return list(spf())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef spf(): return map(int, input.readline().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ndef pmat(A):\n    for ele in A:\n        print(*ele,end=\"\\n\")\ndef pmat2(A):\n    for ele in A:\n        for j in ele:\n            print(j,end='')\n        print()\ndef iseven(n):\n    return n%2==0\n\ndef seive(r):\n    prime=[1 for i in range(r+1)]\n    prime[0]=0\n    prime[1]=0\n    for i in range(r+1):\n        if(prime[i]):\n            for j in range(2*i,r+1,i):\n                prime[j]=0\n    return prime\n#solution\n#ACPC \n#remeber cut ribbon problem\n# set data structures faster than binary search sometimes\n#bipartite match dfs\n#think in problems with recursive manner.\nn = int(input())\ns = list(input())\nt = list(input())\nans = []\nfor i in range(n):\n    for j in range(i,n):\n        if s[j] == t[i]:\n            for k in range(j, i, -1):\n                s[k], s[k-1] = s[k-1], s[k]\n                ans.append(k)\n            break\nif s==t:\n    print(len(ans))\n    print(' '.join(map(str, ans)))\nelse:\n    print(-1)\n\n\n\n\nendtime = time.time()\n#print(f\"Runtime of the program is {endtime - starttime}\")", "complexity": "quadratic", "problem": "1015_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\nA = [int(a) for a in input().split()]\nB = A.copy()\nB.sort()\nc = 0\nfor i in range(n):\n    c = c + 1 if A[i] != B[i] else c\nprint(\"YES\" if c <= 2 else \"NO\")", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "n, q = map(int,input().split())\nai = list(map(int,input().split()))\nar  = []\nar3 = []\nnum = 1\nnummm = max(ai)\nif ai[0] != nummm:\n    num2 = ai[0]\n    for i in range(1,n):\n        ar3 += [[num2,ai[i]]]\n        if ai[i] == nummm:\n            ar += [num2]\n            num = i+1\n            break\n        if ai[i] > num2:\n            ar += [num2]\n            num2 = ai[i]\n        else:\n            ar += [ai[i]]\nar2 = []\nfor i in range(num,n):\n    ar2 += [ai[i]]\nfor i in range(len(ar)):\n    ar2 += [ar[i]]\nnum = len(ar3)\nfor i in range(q):\n    m = int(input())\n    if m <= num:\n        print(ar3[m-1][0],ar3[m-1][1])\n    else:\n        m -= num\n        m -= 1\n        print(nummm,ar2[m % (n-1)])\n", "complexity": "linear", "problem": "1180_C", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "n=int(input());\nif n % 2 == 0:\n    \n    print((n-4),\" 4\")\nelse:\n    \n    print((n-9),\" 9\")\n\t\t\n\t\t\n\t\t", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "n, m, k, l = map(int, input().split())\nneed = k + l\nif need % m == 0 and need <= n:\n    print(need // m)\nelse:\n    x = need // m + 1\n    if x * m > n:\n        print(-1)\n    else:\n        print(x)", "complexity": "constant", "problem": "1068_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\narr = list(map(int, input().split()))\ncodd = 0\nceven = 0\nptodd = -1\npteven = -1\nfor i in range(n):\n    if arr[i]%2 == 0:\n        ceven += 1\n        pteven = i\n    else:\n        codd += 1\n        ptodd = i\n\nif ceven == 1:\n    print(pteven+1)\nelse:\n    print(ptodd+1)", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "n, k = map(int,input().split())\ns = input()\np = len(s)-1\nwhile s[:p] != s[-p:]:\n    p =  p -1\nprint(s + s[p:]*(k-1))", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "n, m = map(int, input().split())\na = [0] + list(map(int, input().split()))\na.sort()\nans = 0\nh = a[-1]\nfor i in range(n, 0, -1):\n\tif a[i - 1] < h - 1:\n\t\tans = ans + a[i] - h + a[i - 1]\n\t\th = a[i - 1]\n\telse:\n\t\tans = ans + a[i] - 1\n\t\th = h - 1\nprint(ans)", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import sys\nfrom collections import defaultdict\n#input = sys.stdin.readline\n\n\ndef main():\n    n, k = map(int, input().split())\n    cand = 0\n    tot = 0\n    p = 0\n    while tot < k or tot-(n-p) != k:\n        cand += 1\n        tot += cand\n        p += 1\n\n    print(tot-k)\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n,m = int(input()),int(input())\nif n < 27:\n    print(m%2**n)\nelse:\n    print(m)", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n = int(input())\n\nparts = []\nfor i in range(4):\n    part = []\n    for _i in range(n):\n        part.append([int(x) for x in input()])\n    parts.append(part)\n\n    if i < 3:input()\n\nprocessed_parts = []\nfor part in parts:\n    dt1 = 0\n    exp = 1\n\n    for h in range(n):\n        for w in range(n):\n            if part[h][w] != exp:\n                dt1 += 1\n            exp = (exp+1) % 2\n\n    dt2 = 0\n    for h in range(n):\n        for w in range(n):\n            if part[h][w] != exp:\n                dt2 += 1\n            exp = (exp+1) % 2\n\n    processed_parts.append([dt1, dt2])\n\nans = n*n*4\n\nfor i in range(3):\n    for j in range(i+1, 4):\n        a = 0\n        for k, part in enumerate(processed_parts):\n            if k == i or k == j:\n                a += part[0]\n            else:\n                a += part[1]\n        ans = min(ans, a)\n\nprint(ans)", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "n, m, a, b = map(int, input().split())\nprint(min(n%m*b, (m-n%m)*a))\n", "complexity": "linear", "problem": "0990_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n, m = map(int, input().split())\nV = []\nfor i in range(n):\n    V.append(int(input()))\nV.sort()\nV.append(10 ** 9)\nn += 1\nX2 = []\nfor i in range(m):\n    x1, x2, y = map(int, input().split())\n    if x1 == 1:\n        X2.append(x2)\nX2.sort()\nk = len(X2)\ni = 0\nj = 0\nans = 10 ** 9 + 7\nc = 0\n\nwhile i < n:\n    while j < k:\n        if X2[j] < V[i]:\n            c += 1\n            j += 1\n        else:\n            break\n    ans = min(ans,  k - c + i)\n    i += 1\nprint(ans)", "complexity": "nlogn", "problem": "1075_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "import sys\nN, M = map(int, input().split())\n\nAns = [(0, 0) for  _ in range(N*M)]\nfor i in range(1, N*M+1):\n    if i % 2:\n        a, b = divmod(i//2, M)\n    else:\n        a, b = divmod(N*M - i//2, M)\n    Ans[i-1] = ' '.join((str(a+1), str(b+1)))\n\nfor a in Ans:\n    sys.stdout.write(f'{a}\\n') \n", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrstr = lambda: stdin.readline().strip()\nrstr_2d = lambda n: [rstr() for _ in range(n)]\n\nn, m = rints()\ngrid = rstr_2d(n)\nrow = [[[] for _ in range(m)] for _ in range(n)]\ncol = [[[] for _ in range(m)] for _ in range(n)]\nvisr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0\nvisc = [[-1 for _ in range(m)] for _ in range(n)]\n\nfor i in range(n):\n    be, en = -1, -1\n    for j in range(m):\n        if grid[i][j] == '*':\n            en += 1\n            if be == -1:\n                be = en = j\n        else:\n            if be != -1:\n                for k in range(be, en + 1):\n                    row[i][k] = [be, en]\n            be = -1\n\n    if be != -1:\n        for k in range(be, en + 1):\n            row[i][k] = [be, en]\n\nfor i in range(m):\n    be, en = -1, -1\n    for j in range(n):\n        if grid[j][i] == '*':\n            en += 1\n            if be == -1:\n                be = en = j\n        else:\n            if be != -1:\n                for k in range(be, en + 1):\n                    col[k][i] = [be, en]\n            be = -1\n\n    if be != -1:\n        for k in range(be, en + 1):\n            col[k][i] = [be, en]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '*':\n            all += 1\n            hor = min(row[i][j][1] - j, j - row[i][j][0])\n            ver = min(col[i][j][1] - i, i - col[i][j][0])\n            if hor <= ver:\n                ver = hor\n            else:\n                hor = ver\n\n            if hor > 0 and ver > 0:\n                out.append('%d %d %d' % (i + 1, j + 1, hor))\n                visr[i][j - ver] = j + ver\n                visc[i - hor][j] = i + hor\n\ndis = set()\nfor i in range(n):\n    j, ma = 0, -1\n    while j < m:\n        ma = max(ma, visr[i][j])\n        if ma >= j:\n            dis.add((i, j))\n\n        j += 1\n\nfor i in range(m):\n    j, ma = 0, -1\n    while j < n:\n        ma = max(ma, visc[j][i])\n        if ma >= j:\n            dis.add((j, i))\n\n        j += 1\n\nif len(dis) != all:\n    print(-1)\nelse:\n    print('%d\\n%s' % (len(out), '\\n'.join(out)))\n", "complexity": "quadratic", "problem": "1015_E2", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2018/11/24 15:29\n\n\"\"\"\n\nT = int(input())\n\n\ndef interact(rect1, rect2):\n    x1, y1, x2, y2 = rect1\n    x3, y3, x4, y4 = rect2\n\n    ans = (-1, -1, -1, -1)\n    if x2 < x3 or x4 < x1:\n        return 0, ans\n    if y2 < y3 or y4 < y1:\n        return 0, ans\n\n    ans = (max(x1, x3), max(y1, y3), min(x2, x4), min(y2, y4))\n\n    return area(ans), ans\n\n\ndef area(rect):\n    return (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)\n\n\ndef winrect(rect):\n    a = area(rect)\n    if a % 2 == 0:\n        return a // 2\n\n    x1, y1, x2, y2 = rect\n    e1, e2 = x1 % 2 == 0, y1 % 2 == 0\n    ow = (e1 and e2) or (not e1 and not e2)\n    return a // 2 + 1 if ow else a // 2\n\nans = []\nfor ti in range(T):\n    N, M = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n    x3, y3, x4, y4 = map(int, input().split())\n\n    w = winrect((1, 1, N, M))\n    a, b = (x1, y1, x2, y2), (x3, y3, x4, y4)\n    s, c = interact(a, b)\n    if s == 0:\n        w -= winrect(a) + winrect(b)\n        w += area(a)\n    elif s == area(a):\n        w -= winrect(b)\n    elif s == area(b):\n        w -= winrect(b)\n        w += area(a) - area(b) - (winrect(a) - winrect(b))\n    else:\n        w += area(a) - winrect(a)\n        w -= winrect(b)\n        w -= area(c) - winrect(c)\n\n    ans.append((w, N*M-w))\n\nprint('\\n'.join(['{} {}'.format(a, b) for a, b in ans]))", "complexity": "constant", "problem": "1080_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\"\"\"\nStrategy: Split sequence into subsequences\naccording to number of digits. Then find corresponding\nnumber and digit in that number.\n\"\"\"\n\n# Standard input.\nk=int(input())\n\n# Initilize sequence\nnum_digits=1\nnum_numbers=9\n\nk-=1\nwhile k>num_digits*num_numbers:\n    # Move sequence starting point. \n    k -= num_numbers*num_digits\n    num_digits += 1\n    num_numbers *= 10\n\n# Generate number.\nnumber = 10**(num_digits - 1) + k // num_digits\n# Find index in that number\nindex = k % num_digits\nanswer = str(number)[index]\nprint(answer)", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "def bin_pow(num, _pow, module):\n    if _pow == 0:\n        return 1\n    if _pow == 1:\n        return num % module\n    if _pow % 2 == 1:\n        return num * bin_pow(num, _pow - 1, module) % module\n    res = bin_pow(num, _pow//2, module)\n    return (res * res) % module\n\nx, k = map(int, input().split())\n\nif x == 0:\n    print(0)\n    exit(0)\n\nmod = 10**9 + 7\n\n__power = bin_pow(2, k, mod)\n\nprint((x* __power * 2 + 1 - __power) % mod)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import os\nimport sys\n\ndef log(*args, **kwargs):\n    if os.environ.get('CODEFR'):\n        print(*args, **kwargs)\n\n\nn, k = tuple(map(int, input().split()))\n\ns = '0'*((n-k)//2) + '1'\n\nfor i in range(n):\n    print(s[i % len(s)], end='')\nprint()\n\n", "complexity": "linear", "problem": "1159_D", "from": "CODEFORCES", "tags": "brute force,greedy,constructive algorithms,math,strings"}
{"src": "x, k = list(map(int,input().split()))\nm = 10**9 + 7\nif x==0:\n    print(0)\nelse:\n    print((pow(2,k+1,m)*x - pow(2,k,m)+1) % m)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "\nop=[0]*1000000\ncl=[0]*1000000\ndef fun(s):\n    v = []\n    for i in range(len(s)):\n        l = len(v)\n        if s[i]=='(':\n            v.append(s[i])\n        elif l>0 and v[l-1]=='(':\n            v.pop()\n        else :\n            v.append(')')\n    \n    l = len(v)\n    if  l==0:\n        op[0]+=1\n        cl[0]+=1\n    elif v[0]==v[l-1]:\n        if  v[0]=='(':\n            op[l]+=1\n        else :\n            cl[l]+=1\n\nt = int ( input() )\nwhile t>0:\n    t-=1\n    s = str ( input() )\n    fun(s)\nans = 0\nfor i in range(1000000):\n    ans+=(op[i] * cl[i])\n\nprint(ans)", "complexity": "linear", "problem": "0990_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys, string\n\nn, k = map(int, sys.stdin.readline().split())\narr = list(sys.stdin.readline().rstrip())\nst = []\nans = []\nfor i in range(n):\n    if k <= 0:\n        break\n    else:\n        if arr[i] == '(':\n            st.append((arr[i], i))\n        else:\n            if st and st[-1][0] == '(':\n                k -= 2\n                ans.append(st.pop())\n                ans.append((arr[i], i))\n            else:\n                st.append((arr[i], i))\n\nans.sort(key=lambda x: x[1])\nres = []\nfor i in ans:\n    res.append(i[0])\nprint(''.join(res))", "complexity": "linear", "problem": "1023_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "N, mod = map(int, input().split())\n\ntwo = [1] * (N+1)\nfact = [1] * (N+1)\ninv = [1] * (N+1)\nfor i in range(1, N+1):\n    two[i] = two[i-1]*2 % mod\nfor i in range(2, N+1):\n    fact[i] = fact[i-1] * i % mod\ninv[N] = pow(fact[N], mod-2, mod)\nfor i in range(N, 0, -1):\n    inv[i-1] = inv[i] * i % mod\n\ndp = [[0] * (N+2) for _ in range(N+2)]\ndp[0][0] = 1\nfor i in range(N):\n    for j in range(i+1):\n        for k in range(1, N+1):\n            if i+k > N:\n                break\n            dp[i+k+1][j+1] += dp[i][j] * two[k-1] * inv[k] % mod\n            dp[i+k+1][j+1] %= mod\n\nans = 0\nfor j in range(1, N+1):\n    ans += dp[N+1][j] * fact[N-j+1] % mod\n    ans %= mod\nprint(ans)\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "def problem(s, p):\n    for i in range(len(p)):\n        l = p[:i] + ' '\n        r = p[i:] + ' '\n\n        dp = [0] + [None] * i\n\n        for x in s:\n            for j in range(i, -1, -1):\n                if dp[j] is None:\n                    continue\n\n                if l[j] == x:\n                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])\n\n                temp = r[dp[j]]\n                if r[dp[j]] == x:\n                    dp[j] += 1\n\n        if dp[-1] == len(r) - 1:\n            return 'YES'\n\n    return 'NO'\n\n\nfor _ in range(int(input())):\n    print(problem(input(), input()))\n", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "tam,q = [int(i) for i in input().split()]\nt = input()\ns = t\n\nposi = -1\n\nfor j in range(tam-1):\n    if(t[:j+1] == t[tam - j -1:]):\n        posi = j\n\nadd = t[posi+1:]\n\nfor j in range(q-1):\n    s += add\n    \nprint(s)\n\t   \t\t     \t\t\t\t   \t \t\t\t\t\t \t\t\t", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "# python3\n\ndef readline(): return tuple(map(int, input().split()))\ndef readlines(count): return (readline() for __ in range(count))\n\n\ndef main():\n    n, = readline()\n    segments = sorted(readline() + (idx + 1,) for idx in range(n))\n\n    prev = (-1, -1, -1)\n    for segment in segments:\n        assert prev[0] <= segment[0]\n        if prev[0] == segment[0]:\n            assert prev[1] <= segment[1]\n            print(prev[2], segment[2])\n            break\n        elif prev[1] >= segment[1]:\n            print(segment[2],  prev[2])\n            break\n        prev = segment\n    else:\n        print(-1, -1)\n\n\nmain()\n", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "from sys import stdin, stdout\n\ndef check(k, b, T):\n\tc = [e for e in b if e[0] >= k]\n\n\tif len(c) < k:\n\t\treturn False, None\n\n\tfirst_k_probs = c[:k]\n\ts = sum([e[1] for e in first_k_probs])\n\n\tif s > T:\n\t\treturn False, None\n\n\treturn True, first_k_probs\n\n\ndef solve(n, T, a, t):\n\tb = []\n\n\tfor i in range(n):\n\t\tb.append((a[i], t[i], i + 1))\n\n\tb.sort(key=lambda x: x[1])\n\n\tlow, high = 0, n\n\tresult = 0\n\tfinal_probs = []\n\n\twhile low <= high:\n\t\tmid = (low + high) // 2\n\n\t\t(possible, probs) = check(mid, b, T)\n\t\tif possible:\n\t\t\tresult, final_probs = mid, probs\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\thigh = mid - 1\n\n\treturn (result, [e[2] for e in final_probs])\n\n\nn, T = (int(x) for x in stdin.readline().split())\n\na = [0] * n\nt = [0] * n\n\nfor i in range(n):\n\ta[i], t[i] = (int(x) for x in stdin.readline().split())\n\npoint, probs = solve(n, T, a, t)\nstdout.write(\"%s\\n\" % point)\nstdout.write(\"%s\\n\" % len(probs))\nif len(probs) > 0:\n\tstdout.write(\"%s\\n\" % \" \".join([str(x) for x in probs]))\n", "complexity": "nlogn", "problem": "0913_D", "from": "CODEFORCES", "tags": "binary search,brute force,data structures,greedy,sortings"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\nPLACE=[None]*(n+1)\nfor i in range(n):\n    PLACE[A[i]]=i\n\nal=n\n\n\nWINLIST=[None]*(n+1)#0:\u305d\u3053\u306b\u884c\u3051\u3070\u5fc5\u6557,1:\u305d\u3053\u306b\u3044\u3051\u3070\u5fc5\u52dd\n\ndef move(n,al):\n    place=PLACE[n]\n    for i in range(place,-1,-n):\n        if A[i]>n and WINLIST[A[i]]==\"B\":\n            WINLIST[n]=\"A\"\n            return\n            \n    for i in range(place,al,n):\n        if A[i]>n and WINLIST[A[i]]==\"B\":\n            WINLIST[n]=\"A\"\n            return \n\n    else:\n        WINLIST[n]=\"B\"\n        return \n   \n\nfor j in range(n,0,-1):\n    move(j,al)\n\n\nANS=\"\"\nfor i in A:\n    ANS+=WINLIST[i]\n\nprint(ANS)\n", "complexity": "linear", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "a,b=map(int,input().split(' '))\nprint((b+a-1)//a)", "complexity": "constant", "problem": "1036_A", "from": "CODEFORCES", "tags": "math"}
{"src": "def main():\n    from sys import stdin\n    w, h, n = map(int, stdin.readline().split())\n    res, vrt, hor = [], [], []\n    vh = (vrt, hor)\n    for i, s in enumerate(stdin.read().splitlines()):\n        x = int(s[2:])\n        flag = s[0] == 'V'\n        vh[flag].append(i)\n        res.append([x, flag])\n    dim = []\n    for tmp, m in zip(vh, (h, w)):\n        tmp.sort(key=lambda e: res[e][0])\n        u = [None, [0]]\n        dim.append(u)\n        j = z = 0\n        for i in tmp:\n            x = res[i][0]\n            if z < x - j:\n                z = x - j\n            j = x\n            v = [u, res[i]]\n            u.append(v)\n            u = v\n            res[i].append(u)\n        v = [u, [m], None]\n        u.append(v)\n        dim.append(v)\n        if z < m - j:\n            z = m - j\n        dim.append(z)\n    l, r, wmax, u, d, hmax = dim\n    whmax = [wmax, hmax]\n    for i in range(n - 1, -1, -1):\n        x, flag, link = res[i]\n        u = whmax[flag]\n        res[i] = u * whmax[not flag]\n        link[0][2] = link[2]\n        link[2][0] = link[0]\n        v = link[2][1][0] - link[0][1][0]\n        if u < v:\n            whmax[flag] = v\n    print('\\n'.join(map(str, res)))\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n\n# Made By Mostafa_Khaled", "complexity": "nlogn", "problem": "0527_C", "from": "CODEFORCES", "tags": "binary search,data structures,implementation"}
{"src": "from itertools import combinations\n\np, minn, maxn, dif = map(int, input().split())\n(*lst,) = map(int, input().split())\nprint(sum([sum([(maxn>=sum(j)>=minn)and((max(j)-min(j))>=dif) for j in combinations(lst,i)]) for i in range(2,p+1)]))\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n    # @timer\n    def __init__(self):        \n        n, d = map(int, input().strip().split())\n        x = list(map(int, input().strip().split()))\n        ans = set()\n        for i in range(n):\n            for z in [-d, d]:\n                y = x[i] + z\n                dmin = min(abs(y - xi) for xi in x)\n                if dmin == d:\n                    ans.add(y)\n        print(len(ans))\n\nsolver()", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from sys import stdin,stdout\n\n# stdin  = open(\"input.txt\",\"r\")\n# stdout = open(\"output.txt\",\"w\")\n\n\nfinal_ans=0\n\n# def solve(r,g,b):\n# \tprint(r,g,b)\n# \tans=0\n# \tif min(r,g,b)<0:\n# \t\treturn 0\n# \tif dparr[r-1][g-1][b]==-1:\n# \t\tsolve(r-1,g-1,b)\n# \tans=max(ans,dparr[r-1][g-1][b]+Ra[r-1]*Ga[g-1])\n# \tif dparr[r-1][g][b-1]==-1:\n# \t\tsolve(r-1,g,b-1)\n# \tans=max(ans,dparr[r-1][g][b-1]+Ra[r-1]*Ba[b-1])\n# \tif dparr[r][g-1][b-1]==-1:\n# \t\tsolve(r,g-1,b-1)\n# \tans=max(ans,dparr[r][g-1][b-1]+Ga[g-1]*Ba[b-1])\n# \tdparr[r][g][b]=ans\n\n\nR,G,B = map(int,stdin.readline().strip().split(' '))\nRa = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)\nGa = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)\nBa = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)\n\ndparr=[[[-1 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]\ndparr[1][1][0]=Ra[0]*Ga[0]\ndparr[1][0][1]=Ra[0]*Ba[0]\ndparr[0][1][1]=Ga[0]*Ba[0]\nfinal_ans=max(final_ans,dparr[1][1][0],dparr[1][0][1],dparr[0][1][1])\n# solve(R,G,B)\n# stdout.write(str(dparr[R][G][B])+\"\\n\")\n\n\ndef add_ns(t1):\n\tglobal queue,Ra,Ga,Ba,dparr\n\tx,y,z=t1\n\tif x+1<=R:\n\t\tif y+1<=G:\n\t\t\tif dparr[x+1][y+1][z]==-1:\n\t\t\t\tqueue.append((x+1,y+1,z))\n\t\t\t\tdparr[x+1][y+1][z]=0\n\t\t\n\t\tif z+1<=B:\n\t\t\tif dparr[x+1][y][z+1]==-1:\n\t\t\t\tqueue.append((x+1,y,z+1))\n\t\t\t\tdparr[x+1][y][z+1]=0\n\tif y+1<=G and z+1<=B:\n\t\tif dparr[x][y+1][z+1]==-1:\n\t\t\tqueue.append((x,y+1,z+1))\n\t\t\tdparr[x][y+1][z+1]=0\n\ndef store_ans(t1):\n\tglobal final_ans,dparr,Ra,Ga,Ba\n\tx,y,z=t1\n\tif dparr[x-1][y-1][z]!=-1 and min(x-1,y-1,z)>=0:\n\t\t# print(dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1])\n\t\tdparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1])\n\tif dparr[x-1][y][z-1]!=-1 and min(x-1,y,z-1)>=0:\n\t\t# print(dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1])\n\t\tdparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1])\n\tif dparr[x][y-1][z-1]!=-1 and min(x,y-1,z-1)>=0:\n\t\t# print(dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1])\n\t\tdparr[x][y][z] = max(dparr[x][y][z],dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1])\n\t# print(dparr[x][y][z])\n\n\tfinal_ans=max(final_ans,dparr[x][y][z])\n\nqueue=[(1,1,0),(1,0,1),(0,1,1)]\nadd_ns(queue[0])\nadd_ns(queue[1])\nadd_ns(queue[2])\nptr=3\n\nwhile ptr<len(queue):\n\t# print(queue[ptr])\n\tstore_ans(queue[ptr])\n\t# print()\n\tadd_ns(queue[ptr])\n\t\n\tptr+=1\n\nstdout.write(str(final_ans)+\"\\n\")", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "def bigNumber(n, s):\n  for i in range(s, n + 1):\n    sumVal = 0\n    num = i\n    while num:\n      sumVal += num % 10\n      num //= 10\n    if i - sumVal >= s:\n      print(n - i + 1)\n      return\n  print(0)\n\nn, s = (int(x) for x in input().split())\nbigNumber(n,s)\n  \t   \t\t   \t\t   \t\t\t\t\t\t   \t\t", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "n,m,a,b = map(int,input().split())\nif n%m!=0:\n    mn = n//m * m\n    mx = n//m * m + m\n    print(min(((n - mn) * b),((mx - n) * a)))\nelse:print(0) ", "complexity": "linear", "problem": "0990_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import sys\ninput=sys.stdin.readline\ndef read():return list(map(int,input().split()))\nn,k=read()\ns=input()[:-1]\nans=\"\"\nfor i in range(len(s)+1, 0, -1):\n    res=s\n    end=s[-i:]\n    for j in range(k-1):\n        res += end\n    cnt=0\n    for j in range(len(res)-len(s)+1):\n        if res[j:j+len(s)] == s:\n            cnt += 1\n    if cnt == k:\n        ans = res\nprint(ans)\n", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nmx = -1\nfor step, elem in enumerate(a):\n    if elem > mx + 1:\n        print(step + 1)\n        exit(0)\n    else:\n        mx = max(mx, elem)\nprint(-1)\n", "complexity": "linear", "problem": "1054_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from math import ceil\ndef paper(a,b,c,d):\n    return ceil((a*(ceil(b/c)))/d)\n\na,b,c,d=map(int,input().strip().split())\nprint(paper(a,b,c,d))", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "def solution(n, k, arr):\n    ret = []\n    grp = [None for _ in range(256)]\n    for i in arr:\n        if grp[i]:\n            continue\n        l = None\n        j = 1\n        for j in range(1, k):\n            if i - j < 0:\n                break\n            if grp[i - j] is not None:\n                l = i - j\n                break\n        if l is not None and grp[l] > i - k:\n            grp[i] = grp[l]\n        else:\n            ll = l + 1 if l else max(0, i - k + 1)\n            for j in range(ll, i + 1):\n                grp[j] = ll\n    for i in arr:\n        ret.append(grp[i])\n    return ret\n\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\nprint(' '.join(map(str, solution(n, k, arr))))\n", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "'''''\narr= [1,3,4,3]\ni=0\nfor k in range(8):\n    if i!=arr[i]-1:\n        if arr[i]!=arr[arr[i]-1]:\n            print(arr[i],arr[arr[i]-1],arr,i)\n            arr[i],arr[arr[i]-1]=arr[arr[i]-1],arr[i]\n        else:\n            i+=1\n    else:\n        i+=1\nprint(arr)\n'''''\n\n'''\ndef AllParenthesis(n):\n\n    def backtrack(ans,curr,openp,closep,maxp):\n        if len(curr)==2*maxp:\n            ans.append(curr)\n            return\n        if openp<maxp:\n            backtrack(ans,curr+\"(\",openp+1,closep,maxp)\n        if closep<openp:\n            backtrack(ans,curr+\")\",openp,closep+1,maxp)\n\n\n    ans = []\n    openp, closep = 0, 0\n    curr = ''\n    backtrack(ans, curr, openp, closep, n)\n    return ans\nprint(AllParenthesis(3))\n'''\n\n#mat = [[1,2,3],[4,5,6],[7,8,9]]\n\n'''temp=[[0 for x in range(len(mat[0]))]for x in range(len(mat))]\nfor i in range(len(mat)):\n    temp[i][0]=mat[i][0]\n    for j in range(1,len(mat[0])):\n        temp[i][j]=temp[i][j-1]+mat[i][j]\nfor i in range(1,len(mat)):\n    for j in range(len(mat[0])):\n        temp[i][j]=temp[i-1][j]+temp[i][j]\n\nk=3\nlr=0\nlc=0\nrr=0\nrc=0\nans=[[0 for x in range(len(mat[0]))]for x in range(len(mat))]\nfor i in range(len(mat)):\n    for j in range(len(mat[0])):\n        area1 = 0\n        area2 = 0\n        area3 = 0\n\n        lr=i\n        lc=j\n        if i-k>=0:\n            lr=i-k\n        else:\n            lr=0\n        if j-k>=0:\n            lc=j-k\n        else:\n            lc=0\n        rr=i\n        rc=j\n        if i+k<len(mat):\n            rr=i+k\n        else:\n            rr=len(mat)-1\n        if j+k<len(mat[0]):\n            rc=j+k\n        else:\n            rc=len(mat[0])-1\n        if lc-1>=0:\n            area1=temp[rr][lc-1]\n\n        if lr-1>=0:\n            area2=temp[lr-1][rc]\n        if lr-1>=0 and lc-1>=0:\n            area3=temp[lr-1][lc-1]\n        ans[i][j]=temp[rr][rc]-area1-area2+area3'''\n\n\n'''print(ans)'''\n'''\nnums = [-1,0,1,2,-1,-4]   #-1,0,1,2,-1,-4,-2,-3,3,0,4\nnums.sort()\nprint(nums)\nseen = set()\nlength=len(nums)\nans=[]\ni=0\nwhile i<length-2:\n    l=i+1\n    r=length-1\n    target=nums[i]\n    while l<r:\n        if nums[l]+nums[r]==-target:\n            seen.add((target,nums[l],nums[r]))\n\n            while l < r and nums[l + 1] == nums[l]:\n                l += 1\n            while l < r and nums[r - 1] == nums[r]:\n                r -= 1\n\n            l+=1\n            r-=1\n        elif nums[l]+nums[r]>-target:\n            r-=1\n        else:\n            l+=1\n    i+=1\nprint(seen)\n'''\nimport math\ndef check(n):\n    '''   check = [1] * (n + 1)\n    check[0] = 0\n    check[1] = 0\n\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if check[i] == 1:\n            for j in range(i * i, n + 1, i):\n                if check[j] == 1:\n                    check[j] = 0\n\n    def lcm(num1, num2):\n        gcd1 = math.gcd(num1, num2)\n        lcmf = (num1 * num2) // gcd1\n        return lcmf'''\n\n    if n==1:\n        return 1\n    if n==2:\n        return 2\n    if n==3:\n        return 6\n#    ans = 0\n    if n&1:\n        return ((n-1)*(n-2)*(n))\n    if math.gcd(n,n-3)==1:\n        return (n*(n-1)*(n-3))\n    else:\n        return ((n-1)*(n-2)*(n-3))\n'''    k = j - 1\n    for k in range(n-2, n-10, -1):\n        lcm2 = lcm((n*(n-1)), k)\n        if check[k]:\n            return(lcm1*k)\n'''\nn =int(input())\nprint(check(n))\n", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\nrd = lambda: list(map(int, input().split()))\nn, k = rd()\na = rd()\nr = 0\ns = [0]\nfor x in a:\n    s.append(s[-1] + x)\nfor i in range(n - k + 1):\n    for j in range(i + k, min(n + 1, i + 2 * k)):\n        r = max(r, (s[j] - s[i]) / (j - i))\nprint(r)\n", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "from collections import defaultdict\n\nn, k = map(int, input().split())\n\nconnections = defaultdict(set)\n\nfor _ in range(n-1):\n\tu, v = map(int, input().split())\n\tconnections[u].add(v)\n\tconnections[v].add(u)\n\nleafs = set()\nfor node in connections:\n\tif len(connections[node])==1:\n\t\tleafs.add(node)\n\nsteps = 0\nis_correct = True\nwhile is_correct and steps<=k:\n\tnew_leafs = set()\n\tfor x in leafs:\n\t\tif len(connections[x])>1:\n\t\t\tis_correct = False\n\t\t\t#print(\"Len of %d more than one\"%x)\n\t\t\tbreak\n\t\troot = list(connections[x])[0]\n\t\tif len(connections[root])<4 and len(leafs)!=3:\n\t\t\tis_correct = False\n\t\t\t#print(\"x: %d Len of root %d less than three\"%(x,root))\n\t\t\t#print(connections[root])\n\t\t\tbreak\n\tif not is_correct:\n\t\tbreak\n\tfor x in leafs:\n\t\troot = list(connections[x])[0]\n\t\tnew_leafs.add(root)\n\t\tconnections[root].remove(x)\n\tleafs = new_leafs\n\tsteps += 1\n\tif len(leafs)==1 and len(connections[list(leafs)[0]])==0:\n\t\tbreak\n\n#print(\"steps is %d\"%steps)\nif is_correct and steps==k:\n\tprint(\"Yes\")\nelse:\n\tprint('No')\n", "complexity": "nlogn", "problem": "1067_B", "from": "CODEFORCES", "tags": "dfs and similar,graphs,shortest paths"}
{"src": "n=int(input())\ng=n//2\nprint(g+n)", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "n,m = map(int,input().split())\nli = [[j for j in input()] for i in range(n)]\n\nfor j in range(m):\n    flag = False\n    for i in range(n):\n        if li[i][j] == \"B\":\n            flag = True\n            position1 = i\n            break\n    if(flag == True):\n        break\nfor j in range(m-1,-1,-1):\n    flag = False\n    for i in range(n-1,-1,-1):\n        if li[i][j] == \"B\":\n            flag = True\n            position2 = i\n            break\n    if(flag == True):\n        break\nfor i in range(n):\n    flag = False\n    for j in range(m):\n        if li[i][j] == \"B\":\n            flag = True\n            position3 = j\n            break\n    if(flag == True):\n        break\nfor i in range(n-1,-1,-1):\n    flag = False\n    for j in range(m-1,-1,-1):\n        if li[i][j] == \"B\":\n            flag = True\n            position4 = j\n            break\n    if(flag == True):\n        break\n\navg1 = (position1+position2)//2 + 1\navg2 = (position3 + position4)//2 + 1\nprint(avg1,avg2)", "complexity": "quadratic", "problem": "1028_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\ncoins = []\ncoinsValueTotal = 0\nn = int(sys.stdin.readline())\ninputs = sys.stdin.readline().split()\nfor i in range(len(inputs)):\n    coin = int(inputs[i])\n    coins.append(coin)\n    coinsValueTotal += coin\ncoins.sort(reverse = True)\nminCoins = 0\nhalfCoinsValueTotal = coinsValueTotal / 2\nfor i in range(len(coins)):\n    minCoins +=  coins[i]\n    if(minCoins > halfCoinsValueTotal):\n        print(i+1)\n        break\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "c1, c2, c3 = map(int, input().split())\nr = sorted(list(map(int, input().split())))\ng = sorted(list(map(int, input().split())))\nb = sorted(list(map(int, input().split())))\ndp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)]\nfor i in range(c1 + 1):\n    for j in range(c2 + 1):\n        for k in range(c3 + 1):\n            if i>0 and j>0:\n                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])\n            if i>0 and k>0:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])\n            if j>0 and k>0:\n                dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1])\nprint(dp[c1][c2][c3])\n ", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom heapq import *\n\ndef main():\n    n,x,y=map(int,input().split())\n    a,b=[],[]\n    for i in range(n):\n        u,v=map(int,input().split())\n        a.append((u,1))\n        a.append((v,-1))\n    a.sort(key=lambda x:x[0]*10000000000-x[1])\n    mod=10**9+7\n    t,z,ans=1,1,x\n    for i in range(1,len(a)):\n        z+=a[i][1]\n        if z<t:\n            ans=(ans+t*(a[i][0]-a[i-1][0])*y)%mod\n            heappush(b,-a[i][0])\n        else:\n            if b:\n                if x<(a[i][0]+b[0])*y:\n                    ans=(ans+t*(a[i][0]-a[i-1][0])*y+x)%mod\n                else:\n                    ans=(ans+t*(a[i][0]-a[i-1][0])*y+(a[i][0]+b[0])*y)%mod\n                    heappop(b)\n            else:\n                ans = (ans + t * (a[i][0] - a[i - 1][0]) * y + x) % mod\n        t=z\n    print(ans)\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "nlogn", "problem": "1061_D", "from": "CODEFORCES", "tags": "data structures,greedy,implementation,sortings"}
{"src": "m = int(input())\nvalues = []\nidx = []\nfor i in range(m):\n    x = int(input())\n    ans = 0\n    for xx,ii in zip(values,idx):\n        if (xx^x) < x:\n            x^=xx\n            ans^=ii\n    if x == 0:\n        anss = []\n        for j in range(i):\n            if (ans&1)==1:\n                anss.append(j)\n            ans>>=1\n        print(len(anss),*anss)\n    else:\n        print(0)\n        values.append(x)\n        idx.append(ans^(2**i))\n", "complexity": "np", "problem": "0504_D", "from": "CODEFORCES", "tags": "bitmasks"}
{"src": "N = int(input())\nS = [input() for i in range(3)]\nbu = []\nfor s in S:\n    cnt = {}\n    mx = 0\n    for c in s:\n        if c not in cnt:\n            cnt[c] = 0\n        cnt[c] += 1\n        mx = max(mx, cnt[c])\n    if mx == len(s) and N == 1:\n        bu.append(mx - 1)\n    else:\n        bu.append(min(len(s), mx + N))\n\nans = -1\nansmx = -1\nfor i in range(3):\n    if bu[i] > ansmx:\n        ans = i\n        ansmx = bu[i]\n    elif bu[i] == ansmx:\n        ans = -1\n\nif ans == -1:\n    print('Draw')\nelif ans == 0:\n    print('Kuro')\nelif ans == 1:\n    print('Shiro')\nelse:\n    print('Katie')\n", "complexity": "linear", "problem": "0979_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import sys;input = sys.stdin.readline\ndef topological_sorted(digraph):\n    n = len(digraph);indegree = [0] * n\n    for v in range(n):\n        for nxt_v in digraph[v]:indegree[nxt_v] += 1\n    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]\n    while stack:\n        v = stack.pop()\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] -= 1\n            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)\n\n    return len(tp_order) == n, tp_order\nn, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {}\nfor idx, ptn in enumerate(p):\n    val = 0\n    for i in range(k):\n        if ptn[i] != \"_\":val += (ord(ptn[i]) - 96) * (27 ** i)\n    memo[val] = idx\n\nfor i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)\n\ngraph = [[] for i in range(n)]\nfor string, idx in s:\n    idxs = []\n    idx -= 1\n    for bit_state in range(1 << k):\n        val = 0\n        for i in range(k):\n            if (bit_state >> i) & 1:\n                continue\n            val += (string[i] - 96) * (27 ** i)\n        if val in memo:\n            idxs.append(memo[val])\n    if idx not in idxs:\n        print(\"NO\")\n        exit()\n\n    for idx_to in idxs:\n        if idx == idx_to:\n            continue\n        graph[idx].append(idx_to)\n\nflag, res = topological_sorted(graph)\nif flag:print(\"YES\");print(*[i + 1 for i in res])\nelse:print(\"NO\")", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nA = list(map(int, readline().split()))\nQ = int(readline())\n\ncnt = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        if A[i] > A[j]:\n            cnt += 1\n\ncnt %= 2\n\nAns = [None]*Q\nfor qu in range(Q):\n    l, r = map(int, readline().split())\n    if (r-l+1)*(r-l)//2 & 1:\n        cnt ^= 1\n    \n    Ans[qu] = 'odd' if cnt else 'even'\n\nprint('\\n'.join(Ans))", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "n = int(input())\ncurpow, t, mx2pow = 1, 1, 0\nwhile t < n:\n    t <<= 1\n    mx2pow += 1\n\nif t > n:\n    mx2pow -= 1\n\nlast = 1 << (mx2pow-1) if mx2pow else 1\nadd = last\n\nwhile last < n:\n    last += add\n\nif last > n:\n    last -= add\n\nwhile n:\n    if n == 1:\n        print(last)            \n        break        \n    print((str(curpow)+' ') * ((n+1)//2), end='')\n    curpow *= 2\n    n //= 2\n", "complexity": "nlogn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "n, pos, l, r=map(int, input().split())\nif l==1 and r==n:\n\tprint(0)\nelif l==1 and r!=n:\n\tprint(abs(pos-r)+1)\nelif l!=1 and r==n:\n\tprint(abs(pos-l)+1)\nelse:\n\tprint(r-l+2+min(abs(pos-l), abs(pos-r)))", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "nab = [int(i) for i in input().split()]\nn = nab[0]\na = nab[1]\nb = nab[2]\nh = sorted([int(i) for i in input().split()])\nprint(h[b] - h[b-1])\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "x, k = map(int, input().split())\nmod = 10**9+7\nif x==0:\n    print(0)\nelse:\n    p = pow(2, k, mod)\n    res = (((2*x)%mod + mod - 1)%mod)\n    res = ((res*p)%mod + 1)%mod\n    print(res)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "get = lambda : list(map(int, input().split(' ')))\nn, m, k = get()\nrlist, clist = [], []\nfor _ in range(n):\n    rlist.append(get())\nfor _ in range(n-1):\n    clist.append(get())\n\ndway = [[0,1],[0,-1],[1,0],[-1,0]]\nif k%2:\n    res = [[-1]*m for _ in range(n)]\nelse:\n    flist = [[0]*m for _ in range(n)]\n    for _ in range(k//2):\n        glist = [[10**9]*m for _ in range(n)]\n        for dx, dy in dway:\n            klist = rlist if dx == 0 else clist\n            for x in range(n):\n                for y in range(m):\n                    xx, yy = x+dx, y+dy\n                    if not (0<=xx<n) or not (0<=yy<m):\n                        continue\n                    tx = xx if dx==-1 else x\n                    ty = yy if dy==-1 else y\n                    glist[x][y] = min(glist[x][y], flist[xx][yy] + klist[tx][ty] * 2)\n        flist = glist\n    res = flist\nfor row in res:\n    print(' '.join(map(str, row)))", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "n = int(input())\nlis = list(map(int, input(). split()))\nsor = sorted(lis)\ncnt = 0\nfor i in range(n):\n    if lis[i] != sor[i]:\n        cnt += 1\nif cnt > 2:\n    print(\"NO\")\nelse:\n    print(\"YES\")", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "from collections import defaultdict as dd, deque as dq\nimport math, string\n\nimport sys\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\nMOD = 10**9+7\n\n\"\"\"\nx*(x+1)//2 candies were placed in the box\nN-x candies were eaten\nK candies remain\nx*(x+1)//2 + x - N - K = 0\nx**2 +3*x - 2*(N + K) = 0\nx = (-3 + sqrt(9+4*(N+K)))*0.5\n\"\"\"\n\ndef solve():\n    N, K = getInts()\n    x = (-3 + math.sqrt(9+8*(N+K)))//2\n    return int(x*(x+1)//2 - K)\n    \n    \n#for _ in range(getInt()):\nprint(solve())", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "z,zz=input,lambda:list(map(int,z().split()))\nzzz=lambda:[int(i) for i in stdin.readline().split()]\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom string import *\nfrom re import *\nfrom collections import *\nfrom queue import *\nfrom sys import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom itertools import *\nfrom bisect import *\nfrom collections import Counter as cc\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom itertools import accumulate as ac\ndef lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))\ndef prime(x):\n    p=ceil(x**.5)+1\n    for i in range(2,p):\n        if (x%i==0 and x!=2) or x==0:return 0\n        \n    return 1\ndef dfs(u,visit,graph):\n    visit[u]=True\n    for i in graph[u]:\n        if not visit[i]:\n            dfs(i,visit,graph)\n\n###########################---Test-Case---#################################\n\"\"\"\n\n\n\n\"\"\"\n###########################---START-CODING---##############################\n\nl=z()\nn=len(l)\nans=0\nfor i in range(n):\n\n    for j in range(i+1,n+1):\n        p=l[i:j]\n        t=len(p)\n        x=0\n\n        for k in range( n):\n            if l[k:k+t]==p:\n                x+=1\n        if x>=2:\n            ans=max(ans,t)\nprint(ans)\n\n\n\n\n\t   \t\t\t   \t \t\t      \t   \t \t   \t", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "l, r = [int(x) for x in input().split()]\n\nr = bin(r)[2:]\nl = bin(l)[2:]\n\nr = r[::-1]\nl = l[::-1]\n\nif l == r:\n    print(0)\nelse:\n\n    l += '0' * (len(r) - len(l))\n    p = -1\n    for i in range(len(r)):\n        if r[i] != l[i]:\n            p = i\n\n    a = '1' * p + '0'\n    b = '0' * p + '1'\n\n    print(int(a, 2) ^ int(b, 2))\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n = int(input())\nk = n // 3\nans = []\nfor i in range(k):\n    ans += [(0, 2 * i)]\n    ans += [(1, 2 * i + 1)]\n    ans += [(2, 2 * i)]\nfor i in range(n % 3):\n    ans += [(-1000, -1000 + i)]\nres = \"\"\nfor i in ans:\n    res += \" \".join(map(str, i)) + \"\\n\"\nprint(res)", "complexity": "linear", "problem": "1067_C", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "# import math\n# import sys\n\nn,v = [int(x) for x in input().strip().split(\" \")]\nif v>=(n-1):\n\tprint(n-1)\nelse:\n\tprint(n-1+((n-1-v)*(n-v)//2))\n\t\t", "complexity": "constant", "problem": "1113_A", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "#------------------------template--------------------------#\nimport os\nimport sys\n# from math import *\nfrom collections import *\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=998244353\nEPS=1e-6\ndef Ceil(a,b): return a//b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n\n\nn=Int()\na=array()\n\nseries = [1]\nfact = 1\nfor i in range(n+1):\n    series.append(((series[-1]*2)%M + fact)%M)\n    fact = (fact*2)%M\n\n\nind = n-1\nans=0\n\nfor i in range(n):\n    ans = (ans + (a[i]*series[ind])%M )%M\n    ind-=1\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "linear", "problem": "1009_E", "from": "CODEFORCES", "tags": "combinatorics,math,probabilities"}
{"src": "from math import inf\n\na=[0,0]\na[0]=[str(c)for c in list(input().strip()) ]\na[1]=[str(X) for X in list(input().strip())]\n\nan = [-inf,-inf,-inf]\nif a[0][0]==a[1][0]=='0':\n    an[0]=0\nelif  a[0][0]!=a[1][0]:\n    an[1]=0\nx=0\nfor i in range(1,len(a[0])) :\n  #  print(a[0][i],a[1][i],an,x)\n    if an[0]==0:\n        if a[0][i]==a[1][i]=='0':\n            x+=1\n\n            an=[-inf,0 ,-inf]\n        elif a[0][i]!=a[1][i]:\n            x+=1\n            an=[-inf]*3\n        else:\n            an = [-inf, -inf, -inf]\n    elif an[1]==0:\n        if a[0][i]==a[1][i]=='0':\n            x+=1\n            an=[-inf,-inf ,-inf]\n        elif a[0][i]!=a[1][i]:\n            pass\n        else:\n            an=[-inf,-inf ,-inf]\n    else:\n        if a[0][i]==a[1][i]=='0':\n\n            an=[0,-inf ,-inf]\n        elif a[0][i]!=a[1][i]:\n            an=[-inf,0,-inf]\n        else:\n            an=[-inf,-inf ,-inf]\n\n\nprint(x)", "complexity": "constant", "problem": "0991_D", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n=int(input())\nprint(\"0\",\"0\",n)", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "a,k=map(int,input().split())\np=[]\nfor n in range(2,a+1):\n\tfor i in range(2,int(n**0.5)+1):\n\t\tif n%i==0:\n\t\t\tbreak\n\telse:\n\t\tp.append(n)\nc=0\nfor i in range(0,len(p)-1):\n\tn=p[i]+p[i+1]+1\n\tfor i in range(2,int(n**0.5)+1):\n\t\tif n%i==0:\n\t\t\tbreak\n\telse:\n\t\tif n<=a:\n\t\t\tc+=1\nif c>=k:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "# alpha = \"abcdefghijklmnopqrstuvwxyz\"\n# prime = 998244353 \nINF = 1000_000_000\n\n# from heapq import heappush, heappop\n# from collections import defaultdict\n# from math import sqrt\nfrom collections import deque      \n    \nt = 1#int(input())\n\nfor test in range(t):\n    # n = int(input())\n    n,q = map(int, input().split())\n    arr = list(map(int, input().split()))\n    maxval = max(arr)\n    d = deque(arr)\n    ans = {}\n    count = 1\n    # print(\"check\",d[0], maxval)\n    while d[0]!=maxval:\n        a = d.popleft()\n        b = d.popleft()\n        ans[count] = (a,b)\n        count+=1\n        d.append(min(a,b))\n        d.appendleft(max(a,b))\n    n = n-1\n    for i in range(q):\n        m = int(input())\n        if m in ans:\n            print(ans[m][0],ans[m][1])\n        else:\n            m = m - count\n            print(maxval, d[1+(m%n)])\n", "complexity": "linear", "problem": "1180_C", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "n, s = map(int, input().split())\nans = s\nfor i in range(n):\n    f, t = map(int, input().split())\n    ans = max(ans, t+f)\nprint(ans)", "complexity": "linear", "problem": "0608_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "#Problem Set E: Collaborated with no one\nfrom collections import defaultdict\n\nmod_v = 1000000007\n\ntemp_arr = [[1]]\nfor i in range(1,1010):\n    a = [1]\n    for k in range(1,i):\n        a.append((temp_arr[i-1][k-1]+temp_arr[i-1][k]) % mod_v)\n    a.append(1)\n    temp_arr.append(a)\n\n\nans_arr = [1]\nfor i in range(1,1010):\n    res = 0\n    for j in range(i):\n        res += ans_arr[j] * temp_arr[i-1][j]\n        res %= mod_v\n    ans_arr.append(res)\n\n\nn_list=list(map(int, input().split()))\n\nn = n_list[0]\nlines = n_list[1]\n\nnew_list = [0 for __ in range(n)]\n\nfor i in range(lines):\n    input1 = list(map(int, input()))\n    for k in range(n):\n        new_list[k] |= input1[k] << i\n\ndefault_d = defaultdict(int)\nfor k in new_list:\n    default_d[k] += 1\n\nanswer = 1\nfor n in default_d.values():\n    answer = answer * ans_arr[n] % mod_v\n\nprint(answer)\n  \t\t \t \t  \t    \t \t \t\t   \t\t \t  \t", "complexity": "quadratic", "problem": "0908_E", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,math"}
{"src": "from sys import stdin\nn,m=map(int,stdin.readline().strip().split())\ns=list(map(int,stdin.readline().strip().split()))\ns1=list(map(int,stdin.readline().strip().split()))\nif min(s1)<max(s):\n    print(-1)\n    exit(0)\ns.sort()\ns1.sort()\n\nans=0\nif s1[0]!=s[-1]:\n    ans+=s1[0]\n    ans+=s[-2]*(m-1)\n    ans+=sum(s1[1::])\n    ans+=s[-1]\n    for i in range(n-2):\n        ans+=s[i]*m\nelse:\n    ans+=sum(s1)\n    for i in range(n-1):\n        ans+=s[i]*m   \nprint(ans)\n", "complexity": "nlogn", "problem": "1159_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import sys\ninput = sys.stdin.readline\n\ntestcase=int(input())\nT=[list(map(int,input().split())) for i in range(testcase*3)]\n#n,m=map(int,input().split())\n#WHITE=list(map(int,input().split()))\n#BLACK=list(map(int,input().split()))\n\ndef COMMON(WHITE,BLACK):\n    x1,y1,x2,y2=WHITE\n    x3,y3,x4,y4=BLACK\n    return (max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))\n\ndef BtoW(WHITE):\n    x1,y1,x2,y2=WHITE\n    if (x1+y1)%2==0:\n        return (x2-x1+1)*(y2-y1+1)//2\n    else:\n        return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)//2\n        \ndef WtoB(BLACK):\n    x1,y1,x2,y2=BLACK\n    if (x1+y1)%2==1:\n        return (x2-x1+1)*(y2-y1+1)//2\n    else:\n        return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)//2\n        \nfor test in range(testcase):\n    n,m=T[test*3]\n    WHITE=T[test*3+1]\n    BLACK=T[test*3+2]\n\n    ANSB=n*m//2\n    ANSW=n*m-ANSB\n\n    #print(ANSB,ANSW,end=\"!\")\n\n    WHITE2=COMMON(WHITE,BLACK)\n\n    k=BtoW(WHITE)\n    ANSB-=k\n    ANSW+=k\n\n    #print(ANSB,ANSW,end=\"!\")\n    \n    #print(x5,y5,x6,y6)\n    if WHITE2[0]>WHITE2[2] or WHITE2[1]>WHITE2[3]:#\u5171\u901a\u90e8\u306a\u3057\n        True\n    else:\n        l=BtoW(WHITE2)\n        ANSB+=l\n        ANSW-=l\n\n    #print(ANSB,ANSW,end=\"!\")\n\n    m=WtoB(BLACK)\n\n    ANSB+=m\n    ANSW-=m\n\n    print(ANSW,ANSB)\n\n    \n        \n    \n", "complexity": "constant", "problem": "1080_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "entrada = input().split()\n\nl = int(entrada[0])\nr = int(entrada[1])\n\npop = l ^ r\nresult = 1\n\nwhile (result <= pop):\n    result = result << 1\n\nprint(result - 1)\n\t\t  \t\t\t\t  \t\t \t  \t    \t\t\t\t\t \t\t", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "class SegTree:\n    def __init__(self, init_val, ide_ele, segfunc):\n        self.n = len(init_val)\n        self.num = 2**(self.n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.segfunc = segfunc\n        self.seg = [ide_ele]*2*self.num\n        # set_val\n        for i in range(self.n):\n            self.seg[i+self.num] = init_val[i]\n        # built\n        for i in range(self.num-1, 0, -1):\n            self.seg[i] = self.segfunc(self.seg[2*i], self.seg[2*i+1])\n\n    def update(self, k, x):\n        k += self.num\n        self.seg[k] = x\n        while k:\n            k = k >> 1\n            self.seg[k] = self.segfunc(self.seg[2*k], self.seg[2*k+1])\n\n    def query(self, l, r):\n        if r <= l:\n            return self.ide_ele\n        l += self.num\n        r += self.num\n        lres = self.ide_ele\n        rres = self.ide_ele\n        while l < r:\n            if r & 1:\n                r -= 1\n                rres = self.segfunc(self.seg[r], rres)\n            if l & 1:\n                lres = self.segfunc(lres, self.seg[l])\n                l += 1\n            l = l >> 1\n            r = r >> 1\n        res = self.segfunc(lres, rres)\n        return res\n\n    def __str__(self): # for debug\n        arr = [self.query(i,i+1) for i in range(self.n)]\n        return str(arr)\n\nn = int(input())\nS = list(map(int, input().split()))\nC = list(map(int, input().split()))\nSA = list(set(S))\nSA = sorted(SA)\nd = {}\nfor i, s in enumerate(SA):\n    d[s] = i\nS = [d[s] for s in S]\nL = [0]*n\nR = [0]*n\nINF = 10**18\nN = len(d)\nseg = SegTree([INF]*(N+1), INF, min)\nseg.update(S[0], C[0])\nfor i in range(1, n-1):\n    s = S[i]\n    L[i] = seg.query(0, s)\n    seg.update(s, C[i])\n\nseg = SegTree([INF]*(N+1), INF, min)\nseg.update(S[-1], C[-1])\nfor i in reversed(range(1, n-1)):\n    s = S[i]\n    R[i] = seg.query(s+1, seg.n)\n    seg.update(s, C[i])\n\n#print(L)\n#print(R)\nans = INF\nfor i in range(1, n-1):\n    ans = min(ans, L[i]+C[i]+R[i])\nif ans >= INF:\n    print(-1)\nelse:\n    print(ans)\n", "complexity": "quadratic", "problem": "0987_C", "from": "CODEFORCES", "tags": "brute force,dp,implementation"}
{"src": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\n\n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------game starts now-----------------------------------------------------\nmod=10**9+7\nn=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range (1,n):\n    for j in range (i):\n        if a[j]>a[i]:\n            c+=1\nc=c%2\nm=int(input())\nfor i in range (m):\n    l,r=map(int,input().split())\n    s=(r-l+1)//2\n    if s%2==1:\n        c=(c+1)%2\n    if c==0:\n        print(\"even\")\n    else:\n        print(\"odd\")", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "s=input()\na=list(map(int,input().split()))\nk=sorted(a)\nb=0\nq=0\nm=0\nfor i in k:\n    b=b+i\nfor i in k[::-1]:\n    q=q+i\n    m=m+1\n    if q>(b/2):\n        break\nprint(m)    ", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "def solve(mat1: list, mat2: list, K: int) -> list:\n    if K % 2 == 1:\n        res = [[-1] * n for _ in range(m)]\n    else:\n        # dp[i][j][k]\u4e3a\u4ece\u4efb\u610f\u5730\u65b9\u8d70\u5230(i, j)\u4e14\u53ea\u8d70k\u6b65\u7684\u6700\u5c0f\u65e0\u804a\u6570\n        dp = [[[-1] * (K // 2 + 1) for _ in range(n)] for _ in range(m)]\n        for k in range(K // 2 + 1):\n            for i in range(m):\n                for j in range(n):\n                    if k == 0:\n                        dp[i][j][k] = 0\n                    else:\n                        if i > 0 and (dp[i][j][k] == -1 or dp[i - 1][j][k - 1] + mat2[i - 1][j] < dp[i][j][k]):\n                            dp[i][j][k] = dp[i - 1][j][k - 1] + mat2[i - 1][j]\n                        if i < m - 1 and (dp[i][j][k] == -1 or dp[i + 1][j][k - 1] + mat2[i][j] < dp[i][j][k]):\n                            dp[i][j][k] = dp[i + 1][j][k - 1] + mat2[i][j]\n                        if j > 0 and (dp[i][j][k] == -1 or dp[i][j - 1][k - 1] + mat1[i][j - 1] < dp[i][j][k]):\n                            dp[i][j][k] = dp[i][j - 1][k - 1] + mat1[i][j - 1]\n                        if j < n - 1 and (dp[i][j][k] == -1 or dp[i][j + 1][k - 1] + mat1[i][j] < dp[i][j][k]):\n                            dp[i][j][k] = dp[i][j + 1][k - 1] + mat1[i][j]\n        res = [[-1] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                res[i][j] = 2 * dp[i][j][-1]\n    for i in range(m):\n        for j in range(n):\n            if j < n - 1:\n                print(res[i][j], end = ' ')\n            else:\n                print(res[i][j])\n    return\n                        \n\n\nm, n, K = map(int, input().split())\nmat1 = []\nmat2 = []\nfor _ in range(m):\n    mat1.append(list(map(int, input().split())))\nfor _ in range(m - 1):\n    mat2.append(list(map(int, input().split())))\nsolve(mat1, mat2, K)\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "def mp():return map(int,input().split())\ndef it():return int(input())\n\nn,k=mp()\nl=list(mp())\nans=0\nfor i in range(n):\n\tavg,count=0,0\n\tfor j in range(i,n):\n\t\tcount+=l[j]\n\t\tif j-i+1>=k:\n\t\t\tavg=count/(j-i+1)\n\t\tans=max(avg,ans)\nprint(ans)\n", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "cases = int(input())\nwhile cases:\n    cases -= 1\n    a, b = map(int, input().split())\n\n    ans = 0\n    while a > 0 and b > 0:\n        if a < b:\n            a, b = b, a\n        ans += a//b\n        a = a % b\n\n    print(ans)\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import sys\nimport string\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nn = ria()[0]\nar = ria()\n\nif n == 1:\n    print(ar[0])\n    exit(0)\n\nonlyNegs = True\nonlyPos = True\n\nif max(ar) >= 0:\n    onlyNegs = False\nif min(ar) <= 0:\n    onlyPos = False\n\nif onlyNegs:\n    print(abs(sum(ar)) + max(ar) * 2)\n    exit(0)\n\nif onlyPos:\n    print(abs(sum(ar)) - min(ar) * 2)\n    exit(0)\n\nprint(sum([abs(i) for i in ar]))\n", "complexity": "linear", "problem": "1038_D", "from": "CODEFORCES", "tags": "dp,greedy,implementation"}
{"src": "#!/usr/bin/env python3\nimport sys\ndef contain(a, b):\n    ax1, ay1, ax2, ay2 = a\n    bx1, by1, bx2, by2 = b\n    return bx1 <= ax1 and ax2 <= bx2 and by1 <= ay1 and ay2 <= by2\ndef ask(x1, y1, x2, y2, known=(), memo={}):\n    if x2 < x1+1 or y2 < y1+1:\n        return 0\n    ofs = len(list(filter(lambda rect: contain(rect, (x1, y1, x2, y2)), known)))\n    key = (x1+1, y1+1, x2, y2)\n    if key in memo:\n        return memo[key] - ofs\n    print('?', *key)\n    sys.stdout.flush()\n    memo[key] = int(input())\n    return memo[key] - ofs\ndef binsearch(l, r, p): # (l,r], return the smallest n which p holds\n    assert l < r\n    while l+1 != r:\n        m = (l + r) // 2\n        if p(m):\n            r = m\n        else:\n            l = m\n    return r\ndef shrink(x1, y1, x2, y2, cnt, known=()):\n    assert ask(x1, y1, x2, y2, known=known) == cnt\n    x1 = binsearch(x1, x2, lambda x: ask(x, y1, x2, y2, known=known) != cnt) - 1\n    y1 = binsearch(y1, y2, lambda y: ask(x1, y, x2, y2, known=known) != cnt) - 1\n    x2 = binsearch(x1, x2, lambda x: ask(x1, y1, x, y2, known=known) == cnt)\n    y2 = binsearch(y1, y2, lambda y: ask(x1, y1, x2, y, known=known) == cnt)\n    assert ask(x1, y1, x2, y2, known=known) == cnt\n    assert ask(x1, y1, x2, y2, known=known) == cnt\n    return x1, y1, x2, y2\ndef go(x1, y1, x2, y2):\n    assert ask(x1, y1, x2, y2) == 2\n    x1, y1, x2, y2 = shrink(x1, y1, x2, y2, 2)\n    a = None\n    if not a and x1 < x2:\n        if ask(x1+1, y1, x2, y2) == 1:\n            a = shrink(x1+1, y1, x2, y2, 1)\n        elif ask(x1, y1, x2-1, y2) == 1:\n            a = shrink(x1, y1, x2-1, y2, 1)\n    if not a and y1 < y2:\n        if ask(x1, y1+1, x2, y2) == 1:\n            a = shrink(x1, y1+1, x2, y2, 1)\n        elif ask(x1, y1, x2, y2-1) == 1:\n            a = shrink(x1, y1, x2, y2-1, 1)\n    if not a:\n        a = x1, y1, x2, y2\n        return a, a\n    else:\n        b = shrink(x1, y1, x2, y2, 1, known=[ a ])\n        return a, b\nn = int(input())\na, b = go(0, 0, n, n)\nax1, ay1, ax2, ay2 = a\nbx1, by1, bx2, by2 = b\nprint('!', ax1+1, ay1+1, ax2, ay2, bx1+1, by1+1, bx2, by2)\n\n\n\n\n# Made By Mostafa_Khaled", "complexity": "logn", "problem": "0713_B", "from": "CODEFORCES", "tags": "binary search,constructive algorithms,interactive"}
{"src": "\ndef crear_intervalo(x,a):\n    lim_inf = x-a/2\n    lim_sup = x+a/2\n    intervalo = (lim_inf, lim_sup)\n    return intervalo\n\ndef calcular_posibles_posiciones(i1, i2, t):\n    espacio_disponible = i2[0] - i1[1]\n    espacio_sobrante = espacio_disponible - t\n    if espacio_sobrante > 0:\n        return 2\n    elif espacio_sobrante == 0:\n        return 1\n    else:\n        return 0\n\nintervalos = []\nposibilidades = 2\n\ndatos = input().split()\nn,t = int(datos[0]), int(datos[1])\n\nfor i in range(n):\n    casas = input().split()\n    x, a = int(casas[0]), int(casas[1])\n    intervalo = crear_intervalo(x,a)\n    intervalos.append(intervalo)\n    \nintervalos.sort()\n\nfor i in range(n-1):\n    posibilidades = posibilidades + calcular_posibles_posiciones(intervalos[i], intervalos[i+1],t)\n\nprint(posibilidades)\n\n ", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "\"\"\"\nNTC here\n\"\"\"\nfrom sys import setcheckinterval,stdin\nsetcheckinterval(1000)\n\n#print(\"Case #{}: {} {}\".format(i, n + m, n * m))\n\niin=lambda :int(stdin.readline())\nlin=lambda :list(map(int,stdin.readline().split()))\n\nn,q=lin()\na=lin()\nif q==0:\n    exit()\nQ=[iin() for i in range(q)]\nsq=set(Q)\nmx=max(Q)\nd=dict()\nch=1\nfor i in range(min(mx,n+1)):\n    if ch==n:\n        ch=1\n    if i+1 in sq:d[i+1]=[a[0],a[ch]]\n    if a[0]<a[ch]:\n        a[0],a[ch]=a[ch],a[0]\n    ch+=1\n\nfor i in Q:\n    if i>n:\n        x=n-1 if i%(n-1)==0 else i%(n-1)\n        print(a[0],a[x])\n    else:\n        print(*d[i])\n\n\n\n\n", "complexity": "linear", "problem": "1180_C", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "'''\n    Author: Ken\n    Date: 2020-02-06\n    Problems: 550B\n'''\nimport sys\n\nn, l, r, x = map(int, input().split())\ntemp = []\ntemp = list(map(int, input().split()))\n\ntemp.sort()\nans = 0\n\nfor i in range(1 << n):\n    score = 0\n    _min = sys.maxsize\n    _max = -sys.maxsize\n    for j in range(n):\n        if i & (1 << j) > 0:\n            _min = min(_min, temp[j])\n            _max = max(_max, temp[j])\n            score += temp[j]\n    if score >= l and score <= r and _max-_min >= x:\n        ans += 1\n\nprint(ans)\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import math\nn, r = list(map(int, input().split(' ')))\nl = 2 * r * math.sin(math.pi/n)\nR = l * r / (-l + 2*r)\nprint(R)", "complexity": "constant", "problem": "1100_C", "from": "CODEFORCES", "tags": "binary search,geometry,math"}
{"src": "n,l,r,x = map(int,input().split())\nnums = sorted(list(map(int,input().split())))\nans = 0\ndef recurse(i,sum, dif, cnt):\n    global ans\n    if i == n:\n        if not cnt:\n            return\n        if sum>=l and sum <= r and abs(cnt[-1]-cnt[0]) >=x:\n            ans += 1\n        return\n    recurse(i+1,sum,dif,cnt[:])\n    cnt.append(nums[i])\n    recurse(i+1,sum+nums[i],dif,cnt[:])\nrecurse(0,0,0,[])\nprint(ans)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "a, b = map(int, input().split())\narr = list(map(int, input().split()))\nmn = float(\"inf\")\nfor i in range(1, a+1):\n    mn = min(mn, arr.count(i))\n\nprint(mn)\n\n\n", "complexity": "quadratic", "problem": "0961_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\nw = list(map(int, input().split()))\nent = input()\nmp = {w[i]: i+1 for i in range(n)}\nsorted(mp)\nw.sort()\nptr = 0\nstk = []\nfor i in range(2 * n):\n    if ent[i] == \"0\":\n        print(mp[w[ptr]], end=\" \")\n        stk.append(mp[w[ptr]])\n        ptr += 1\n    else:\n        print(stk.pop(), end=\" \")\n    # print(pr.queue)\nprint()\n", "complexity": "nlogn", "problem": "0982_B", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "import math as m\na=input()\nb=input()\ntotal_sum=0\nreq_pos=0\nunreco=0\nfor i in a:\n    if i=='+':\n        total_sum+=1\n        req_pos+=1\n\n    elif i=='-':\n        total_sum-=1\nfor i in b:\n    if i=='+':\n        total_sum-=1\n        req_pos-=1\n\n    elif i=='-':\n        total_sum+=1\n    else:\n        unreco+=1\n#case 1\nif (total_sum==0 and unreco==0):\n    print(1.000000000)\nelif (abs(total_sum)>unreco or req_pos<0):\n    print(0.000000000)\nelse:\n    ans=m.factorial(unreco)/(m.factorial(req_pos)*m.factorial(unreco-req_pos)*(2**unreco))\n    print(ans)\n    ", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "l,r = map(int,input().split())\nans = l ^ r\nx = bin(ans)[1:]\nif ans == 0:\n    print(0)\nelse:\n    ptr = -1\n    po = 0\n    while True:\n        if( x[ptr] == '0') :\n            ans += 2**po\n        po += 1\n        ptr-=1\n        if( ptr == -len(x)-1 ):\n            break\n\n    print(ans)\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n, s  = [int(i) for i in input().split()]\n\nprint(max(n - [i for i in range(s, s + 180) if i - sum([int(j) for j in str(i)]) >= s][0] + 1, 0))\n\n\n\n\n\n# Made By Mostafa_Khaled", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "n=int(input())\na=list(map(int,input().split()))\na.sort()\nif a[n-1]==1:\n    a[n-1]+=1\nelse:\n    a[n-1]=1\na.sort()\nprint(*a)\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import math\nn,t=map(int,input().split())\nl=[]\nfor _ in range(n):\n    a,b=map(int,input().split())\n    x=a-b/2\n    y=a+b/2\n    l.append([x,y])\nl.sort()\nc=0\n\nfor i in range(n-1):\n    if(l[i+1][0]-l[i][1]>t):\n        c+=2\n    elif(l[i+1][0]-l[i][1]==t):\n        c+=1\nprint(c+2)\n    \n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "from math import gcd\n# region fastio\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"right\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\right\\n\")\n\n\n# endregion\n\n\ndef func(left:int, right:int):\n    if left == 1:\n        left += 1\n    if right - left < 2:\n        return -1\n\n    if left & 1:\n        if right - left > 2:\n            left += 1\n            return '{} {} {}'.format(left, left + 1, left + 2)\n        else:\n            if gcd(left, left + 2) != 1:\n                return '{} {} {}'.format(left, left + 1, left + 2)\n            return -1\n    return '{} {} {}'.format(left, left + 1, left + 2)\n\n\ndef main():\n    left, right = map(int, input().split())\n    print(func(left, right))\n    return\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "def check(x: int) -> (int, int):\n    vis = {}\n    for i, array in enumerate(a):\n        t = 0\n        for j, val in enumerate(array):\n            if val >= x:\n                t |= 1 << j\n        vis[t] = i\n    if (1 << m) - 1 in vis:\n        return vis[(1 << m) - 1], vis[(1 << m) - 1]\n    for i in range(1, (1 << m) - 1):\n        for j in range(1, (1 << m) - 1):\n            if i in vis and j in vis and i | j == (1 << m) - 1:\n                return vis[i], vis[j]\n    return -1, -1\n\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    l = 0\n    r = int(1e9)\n    while l <= r:\n        mid = l + r >> 1\n        if check(mid) != (-1, -1):\n            l = mid + 1\n        else:\n            r = mid - 1\n    ans = check(r)\n    print(\"%d %d\" % (ans[0] + 1, ans[1] + 1))\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "i = input()\ni = int(i)\nv = 0\ng = 2\ns = 4\nwhile g <= i:\n\twhile s <= i:\n\t\tv = v + int(s / g * 4)\n\t\ts = s + g\n\tg = g + 1\n\ts = g * 2\nprint(str(v))", "complexity": "linear", "problem": "1062_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation,math"}
{"src": "from math import factorial as fact\n\na = input()\nb = input()\n\naplus = a.count('+')\naminus = len(a) - aplus\n\nbplus = b.count('+')\nbminus = b.count('-')\nbjolly = len(b) - bplus - bminus\n\nif bplus > aplus or bminus > aminus:\n    print(0)\nelse:\n    c = aplus-bplus\n    res = fact(bjolly) / fact(bjolly-c) / fact(c) / 2**bjolly\n    print(res)\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\ndef hgt(x):\n    if x == 0: return -1\n    h = 0\n    while x&1 != 1:\n        h += 1\n        x = x>>1\n    return h\n\ndef up(x):\n    h = hgt(x)\n    g = x + (1<<h)\n    if g > 0 and g < N and hgt(g) == h+1:\n        return g\n    g = x - (1<<h)\n    if g > 0 and g < N and hgt(g) == h+1:\n        return g\n    return x\n\ndef left(x):\n    h = hgt(x)\n    if h == 0:\n        return x\n    g = x - (1<<(h-1))\n    if g > 0:\n        return g\n    return x\n\ndef right(x):\n    h = hgt(x)\n    if h == 0:\n        return x\n    g = x + (1<<(h-1))\n    if g < N:\n        return g\n    return x\n\nN, q = map(int, input().split())\nN += 1\nfor _ in range(q):\n    p = int(input())\n    for c in input():\n        if c == 'U':\n            p = up(p)\n        elif c == 'R':\n            p = right(p)\n        else:\n            p = left(p)\n    print(p)", "complexity": "np", "problem": "0792_D", "from": "CODEFORCES", "tags": "bitmasks,trees"}
{"src": "n=int(input())\ns=input()\ncur=0\nfor a in s:\n    cur=max(cur,0)\n    if(a=='-'):\n        cur-=1\n    else: cur+=1\n    cur=max(cur,0)\nprint(cur)", "complexity": "linear", "problem": "1159_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "def check(x, y):\n    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])\n\nn = int(input())\na = [list(input()) for i in range(n)]\nb = [list(input()) for i in range(n)]\nfor i in range(4):\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = b[::-1]\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = [s[::-1] for s in b]\n    c = [['' for t in range(n)] for u in range(n)]\n    for t in range(n):\n        for u in range(n):\n            c[t][u] = b[u][n - t - 1]\n    b = c[:]\n    if check(a, b):\n        print('Yes')\n        exit(0)\nprint('No')", "complexity": "quadratic", "problem": "0958_A1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\ndef get_fingering(notes):\n    fingering = []\n    diff = 0\n    next_diff = None\n    finger = 0\n    for i in range(len(notes) - 1):\n        next_diff = notes[i+1] - notes[i]\n        if diff == 0:\n            if next_diff > 0:\n                finger = 1 + (finger == 1)\n            elif next_diff < 0:\n                finger = 5 - (finger == 5)\n            else:\n                finger = 3 + (finger == 3)\n        elif diff > 0:\n            if finger == 5:\n                return None\n            if next_diff < 0:\n                finger = 5\n            else:\n                finger += 1\n        else:\n            if finger == 1:\n                return None\n            if next_diff > 0:\n                finger = 1\n            else:\n                finger -= 1\n        fingering.append(finger)\n        diff = next_diff\n\n    return fingering\n\n\n_ = input()\nnotes = [int(x) for x in input().split()]\nnotes.append(notes[-1])\n\nfingering = get_fingering(notes)\n\nif fingering:\n    print(*fingering)\nelse:\n    print(-1)\n\n", "complexity": "linear", "problem": "1032_C", "from": "CODEFORCES", "tags": "constructive algorithms,dp"}
{"src": "from collections import deque\nimport heapq\nimport sys\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\nn, T = map(int, input().split())\nproblems = [tuple(map(int, input().split())) for i in range(n)]\n\n\ndef possible(K):\n    d = []\n    for a, t in problems:\n        if a >= K:\n            d.append(t)\n    d.sort()\n    if len(d) < K:\n        return False\n    else:\n        return sum(d[:K]) <= T\n\n\nl = 0\nr = n + 1\nwhile r - l > 1:\n    med = (r + l)//2\n    if possible(med):\n        l = med\n    else:\n        r = med\nprint(l)\nprint(l)\nd = []\nfor i, (a, t) in enumerate(problems):\n    if a >= l:\n        d.append((t, i+1))\nd.sort(key=lambda x: x[0])\nans = [v[1] for v in d[:l]]\nprint(*ans)\n", "complexity": "nlogn", "problem": "0913_D", "from": "CODEFORCES", "tags": "binary search,brute force,data structures,greedy,sortings"}
{"src": "for _ in range(int(input())):\n    a,b = map(int, input().split())\n    c = 0\n    while (a!=0 and b!=0):\n        if (a>b) : \n            c+= a//b\n            a = a%b\n        elif (b>a):\n            c+= b//a\n            b = b%a\n        else :\n            c+=1\n            break\n    print(c)", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import sys\nimport os.path\nfrom collections import *\nimport math\nimport bisect\n\nif (os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\n\n############## Code starts here ##########################\n\nn, m, k1 = [int(x) for x in input().split()]\n\narr = [0 for i in range(n)]\nfor i in range(n):\n    arr[i] = [int(x) for x in input().split()]\n\nbrr = [0 for i in range(n - 1)]\nfor i in range(n - 1):\n    brr[i] = [int(x) for x in input().split()]\n\ndp = [[[0 for k in range(21)] for j in range(m)] for i in range(n)]\n\nfor k in range(1, 21):\n    for i in range(n):\n        for j in range(m):\n                if k % 2:\n                    dp[i][j][k] = -1\n                else:\n                    dp[i][j][k] = 10 ** 9\n                    if i > 0:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 2] + brr[i - 1][j] * 2)\n                    if i < n - 1:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 2] + brr[i][j] * 2)\n                    if j > 0:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 2] + arr[i][j - 1] * 2)\n                    if j < m - 1:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 2] + arr[i][j] * 2)\n\nfor i in range(n):\n    for j in range(m):\n        print(dp[i][j][k1],end=\" \")\n    print()\n\n############## Code ends here ############################\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import sys\nimport math\nimport collections\nimport bisect\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n,m=get_ints()\n    space=0\n    saved=[]\n    for i in range(n):\n        a,b=get_ints()\n        space+=a\n        saved.append(a-b)\n    saved.sort(reverse=True)\n    if space-sum(saved)>m:\n        print(-1)\n        continue\n    i=0\n    count=0\n    if space<=m:\n        print(0)\n        continue\n    while i<n:\n        count+=1\n        space-=saved[i]\n        if space<=m:\n            print(count)\n            break\n        i+=1", "complexity": "nlogn", "problem": "1015_C", "from": "CODEFORCES", "tags": "sortings"}
{"src": "n = int(input())\n(ax, ay) = [int(x) for x in input().split()]\n(bx, by) = [int(x) for x in input().split()]\n(cx, cy) = [int(x) for x in input().split()]\n\n\nif (bx < ax < cx) or (bx > ax > cx) or (by < ay < cy) or (by > ay > cy):\n    print(\"NO\")\nelse:\n    print(\"YES\")", "complexity": "constant", "problem": "1033_A", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation"}
{"src": "n , s = map(int,input().split())\na = [0] * (n+1)\nfor _ in range(n-1) :\n    u , v=map(int, input().split())\n    a[u] += 1\n    a[v] += 1\nprint(2.0*s/a.count(1))", "complexity": "linear", "problem": "1086_B", "from": "CODEFORCES", "tags": "greedy,implementation,trees"}
{"src": "# import sys\n# sys.stdin = open('CF_E93_D2/input.txt', 'r') \n# sys.stdout = open('CF_E93_D2/output.txt', 'w')\n#----------------------------------------------------------------\n\nr,g,b = list(map(int,input().split()))\ndp = [ [ [-1]*(b+1) for i in range(g+1) ] for j in range(r+1) ]\nra = sorted(list(map(int,input().split())),reverse=True)\nga = sorted(list(map(int,input().split())),reverse=True)\nba = sorted(list(map(int,input().split())),reverse=True)\n\ndef solve(i,j,k) :\n    \n    if dp[i][j][k] != -1 :\n        return dp[i][j][k]\n\n    if i==r :\n        if j==g or k==b :\n            return 0\n        dp[i][j][k] = ga[j] * ba[k] + solve(i,j+1,k+1)\n\n    elif j==g :\n        if i==r or k==b:\n            return 0\n        dp[i][j][k] = ra[i] * ba[k] + solve(i+1,j,k+1)\n        \n    elif k==b :\n        if j==g or i==r:\n            return 0\n        dp[i][j][k] = ga[j] * ra[i] + solve(i+1,j+1,k)\n    \n    else :\n        dp[i][j][k] = max(ra[i]*ga[j] + solve(i+1,j+1,k),ra[i]*ba[k] + solve(i+1,j,k+1),ba[k]*ga[j] + solve(i,j+1,k+1))\n\n    return dp[i][j][k]\n\n\nprint(solve(0,0,0))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n, t = map(int, input().split())\n \na, v = sorted(list(map(int, input().split())) for i in range(n)), 2\n \nfor i in range(n - 1):\n \n    d = 2 * a[i + 1][0] - a[i + 1][1] - 2 * a[i][0] - a[i][1]\n \n    if d > 2 * t:\n \n        v += 2\n \n    elif d == 2 * t:\n \n        v += 1\n \nprint(v)", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import sys\n\nn = int(input())\nl = list(map(int,input().split()))\nc = list(map(int,input().split()))\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\na = {0:0}\nb = [0]\n\nfor i in range(n):\n    for p in b:\n        d = gcd(p, l[i])\n        cost = a[p] + c[i]\n        if d not in a:\n            a[d] = cost\n            b.append(d)\n        elif a[d] > cost: a[d] = cost\n\nif 1 not in a: a[1] = -1\nprint(a[1])\n\n                                                                                                                                                                                                                                                       ", "complexity": "np", "problem": "0512_B", "from": "CODEFORCES", "tags": "data structures,dp,math,number theory,shortest paths"}
{"src": "n=int(input());print(sum(i for i in range(1+n%2!=1,n+1,2)))", "complexity": "linear", "problem": "0909_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "import math\n\nn, r = map(int, input().split())\nx = list(map(int, input().split()))\ny = [r]\n\nfor i in range(1, n):\n    _y = r\n    for j in range(i):\n        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):\n            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))\n    y.append(round(_y, 6))\n    \nprint(' '.join(map(str, y)))\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "n, M = map(int, input().strip().split())\na = list(map(int, input().strip().split()))\n\na.insert(0, 0)\nn += 1\n\nlit = [0] * (n + 1)\nfor i in range(1, n):\n    if i % 2 == 0:\n        lit[i] = lit[i - 1]\n    else:\n        lit[i] = lit[i - 1] + a[i] - a[i - 1]\nif n % 2 == 0:\n    lit[n] = lit[n - 1]\nelse:\n    lit[n] = lit[n - 1] + M - a[n - 1]\n# print(lit)\n\nans = lit[n]\nfor i in range(n):\n    pre_lit = lit[i]\n    post_lit = M - a[i] - (lit[n] - lit[i])    \n    # print(i, pre_lit, post_lit)\n    if i > 0 and a[i - 1] + 1 < a[i]:\n        if i % 2 == 0:\n            ans = max(ans, pre_lit + 1 + post_lit)\n        else:\n            ans = max(ans, pre_lit - 1 + post_lit)\n    if (i + 1 < n and a[i] + 1 < a[i + 1]) or (i + 1 == n and a[n - 1] + 1 < M):\n        if i % 2 == 0:\n            ans = max(ans, pre_lit + post_lit + 1)\n        else:\n            ans = max(ans, pre_lit + post_lit - 1)    \nprint(ans)", "complexity": "linear", "problem": "1000_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "n=int(input())\nlist1=list(map(int,input().split(' ')))\nsum2=0\nsum1=0\ncount=0\nlist1.sort(reverse=True)\nfor i in range(len(list1)):\n    sum1=sum1+list1[i]\n \nfor i in range(len(list1)):\n    if(int(sum1/2)>=sum2):\n        sum2=sum2+list1[i]\n        count=count+1\nprint(count)", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "n=int(input())\na=[int(i) for i in input().split()]\na.sort()\ntot = 0\nd={}\nfor i in range(len(a)):\n    if a[i] not in d:\n        tot+=1\n        for j in range(i+1,len(a),1):\n            if a[j]%a[i] == 0:\n                d[a[j]]=1\nprint(tot)", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "q=int(input())\n\nQ=[list(map(int,input().split())) for i in range(q)]\n\nfor n,m,k in Q:\n    if n>k or m>k:\n        print(-1)\n        continue\n\n    x=max(n,m)-min(n,m)\n    y=k-max(n,m)\n\n    if x%2==0 and y%2==0:\n        print(k)\n    elif x%2==0 and y%2==1:\n        print(k-2)\n    elif x%2==1 and y%2==0:\n        print(k-1)\n    elif x%2==1 and y%2==1:\n        print(k-1)\n", "complexity": "constant", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "q = int(input())\nfor i in range(q):\n    a, b, k = map(int, input().split())\n    if a < b:\n        a, b, = b, a\n    if a > k:\n        print(-1)\n    elif a % 2 == b % 2 != k % 2:\n        print(k - 2)\n    elif (a + b) % 2 != 0:\n        print(k - 1)\n    else:\n        print(k)\n    ", "complexity": "constant", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "def norm(x):\n    return (x % 998244353 + 998244353) % 998244353\n\nn, k = map(int, input().split())\n\ndp1 = [0]\ndp2 = [0]\n\nfor i in range(n):\n    l = [1]\n    cur = 0\n    for j in range(n + 1):\n        cur += l[j]\n        if(j > i):\n            cur -= l[j - i - 1]\n        cur = norm(cur)\n        l.append(cur)\n    dp1.append(l[n])\n    dp2.append(norm(dp1[i + 1] - dp1[i]))\n\nans = 0\nfor i in range(n + 1):\n    for j in range(n + 1):\n        if(i * j < k):\n            ans = norm(ans + dp2[i] * dp2[j])\n\nans = norm(ans * 2)\n\nprint(ans)", "complexity": "quadratic", "problem": "1027_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "#tests = int(input())\n#for t in range(tests):\n#    b= int(input())\n#    ls = [int(x) for x in input()]\n\nr,g,b = list(map(int, input().split()))\nls_r = sorted(list(map(int, input().split())))\nls_g = sorted(list(map(int, input().split())))\nls_b = sorted(list(map(int, input().split())))\n\n\ndp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]\n\ndef recursive(idx_r, idx_g, idx_b):\n    if dp[idx_r][idx_g][idx_b] is not None:\n        return dp[idx_r][idx_g][idx_b]\n    res_1 = 0\n    res_2 = 0\n    res_3 = 0\n    if (idx_r-1) >= 0 and (idx_g-1) >= 0:\n        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]\n    if (idx_g-1) >= 0 and (idx_b-1) >= 0:\n        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]\n    if (idx_r-1) >= 0 and (idx_b-1) >= 0:\n        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]\n    \n    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)\n    return dp[idx_r][idx_g][idx_b]\n\nprint(recursive(r,g,b))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import sys\ninput=sys.stdin.readline\n\nfrom collections import defaultdict\n\ndef toposort(graph):\n    res = []\n    found = [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            res.append(1+(~node))\n        elif not found[node]:\n            found[node] = 1\n            stack.append(~node)\n            stack.extend(graph[node])\n \n    # cycle check\n    for node in res:\n        node-=1\n        if any(found[nei] for nei in graph[node]):\n            print(\"NO\")\n            return\n        found[node] = 0\n \n    print(\"YES\")\n    print(*res[::-1])\n    \n#https://github.com/cheran-senthil/PyRival/blob/master/pyrival/graphs/toposort.py\n\nn,m,k=map(int,input().split())\npatterns=set()\npos=dict()\n\nfor i in range(n):\n    p=input().rstrip()\n    patterns.add(p)\n    pos[p]=i\n    \nmatches=[[] for _ in range(n)]\n\nchk=True\nfor i in range(m):\n    s,mt=input().rstrip().split()\n    mt=int(mt)-1\n    if(chk):\n        chk=False\n        for i in range(1<<k):\n            tmp=[]\n            for j in range(k):\n                if(i&(1<<j)):\n                    tmp.append('_')\n                else:\n                    tmp.append(s[j])\n            tmp=''.join(tmp)\n            if(tmp in patterns):\n                if(mt==pos[tmp]):\n                    chk=True #sj should match with old permutation of p[mtj] apparently smh\n                else:\n                    matches[mt].append(pos[tmp])\n                    \nif(not chk):\n    print(\"NO\")\nelse:\n    toposort(matches)\n    \n        \n            \n            \n            \n        ", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "import bisect\nimport copy\nimport decimal\nimport fractions\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import deque,defaultdict\nfrom functools import lru_cache,reduce\nfrom heapq import heappush,heappop,heapify,_heappop_max,_heapify_max\ndef _heappush_max(heap,item):\n    heap.append(item)\n    heapq._siftdown_max(heap,0,len(heap)-1)\nfrom math import gcd as Gcd\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\ndef Extended_Euclid(n,m):\n    stack=[]\n    while m:\n        stack.append((n,m))\n        n,m=m,n%m\n    if n>=0:\n        x,y=1,0\n    else:\n        x,y=-1,0\n    for i in range(len(stack)-1,-1,-1):\n        n,m=stack[i]\n        x,y=y,x-(n//m)*y\n    return x,y\n\nclass MOD:\n    def __init__(self,p,e=1):\n        self.p=p\n        self.e=e\n        self.mod=self.p**self.e\n\n    def Pow(self,a,n):\n        a%=self.mod\n        if n>=0:\n            return pow(a,n,self.mod)\n        else:\n            assert math.gcd(a,self.mod)==1\n            x=Extended_Euclid(a,self.mod)[0]\n            return pow(x,-n,self.mod)\n\n    def Build_Fact(self,N):\n        assert N>=0\n        self.factorial=[1]\n        self.cnt=[0]*(N+1)\n        for i in range(1,N+1):\n            ii=i\n            self.cnt[i]=self.cnt[i-1]\n            while ii%self.p==0:\n                ii//=self.p\n                self.cnt[i]+=1\n            self.factorial.append((self.factorial[-1]*ii)%self.mod)\n        self.factorial_inv=[None]*(N+1)\n        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)\n        for i in range(N-1,-1,-1):\n            ii=i+1\n            while ii%self.p==0:\n                ii//=self.p\n            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod\n\n    def Fact(self,N):\n        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod\n\n    def Fact_Inv(self,N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inv[N]\n\n    def Comb(self,N,K,divisible_count=False):\n        if K<0 or K>N:\n            return 0\n        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod\n        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]\n        if divisible_count:\n            return retu,cnt\n        else:\n            retu*=pow(self.p,cnt,self.mod)\n            retu%=self.mod\n            return retu\n\ndef Bell_Numbers(N,mod,prime=False):\n    bell_numbers=[0]*(N+1)\n    bell_numbers[0]=1\n    MD=MOD(mod)\n    if prime:\n        MD.Build_Fact(min(mod-2,N-1))\n        for i in range(1,min(mod,N+1)):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n        for i in range(mod,N+1):\n            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod\n    else:\n        MD.Build_Fact(N-1)\n        for i in range(1,N+1):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n    return bell_numbers\n\nM,N=map(int,readline().split())\nS=[readline().rstrip() for i in range(N)]\ndct=defaultdict(int)\nfor i in range(M):\n    tpl=()\n    for j in range(N):\n        tpl+=(S[j][i],)\n    dct[tpl]+=1\nans=1\nmod=10**9+7\nbell=Bell_Numbers(M,mod)\nfor c in dct.values():\n    ans*=bell[c]\n    ans%=mod\nprint(ans)", "complexity": "quadratic", "problem": "0908_E", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,math"}
{"src": "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nn,q=map(int,input().split())\nA=deque(map(int,input().split()))\nQ=[int(input()) for i in range(q)]\n\nANS=[0]\n\nfor l in range(10**5+1):\n    x=A.popleft()\n    y=A.popleft()\n\n    ANS.append((x,y))\n\n    if x>y:\n        A.appendleft(x)\n        A.append(y)\n    else:\n        A.appendleft(y)\n        A.append(x)\n\n\nANS0=A[0]\nB=list(A)[1:]\n\nfor q in Q:\n    if q<=10**5+1:\n        print(*ANS[q])\n    else:\n        print(ANS0,B[(q-10**5-2)%(n-1)])\n", "complexity": "linear", "problem": "1179_A", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "from itertools import groupby\n\nn = int(input())\nl = list(map(int, input().split()))\nr = list(map(int, input().split()))\nsums = [(a + b, ind) for (ind, (a, b)) in enumerate(zip(l, r))]\nsums.sort()\nanswer = [None] * n\ncurr_candies = n\nfor key, group in groupby(sums, key=lambda i: i[0]):\n    for elem in group:\n        answer[elem[1]] = curr_candies\n    curr_candies -= 1\ntl = []\nfor i in range(n):\n    cnt = 0\n    for j in range(i):\n        if answer[j] > answer[i]:\n            cnt += 1\n    tl.append(cnt)\ntr = []\nfor i in range(n):\n    cnt = 0\n    for j in range(i + 1, n):\n        if answer[j] > answer[i]:\n            cnt += 1\n    tr.append(cnt)\nif tl != l or tr != r:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(' '.join(map(str, answer)))\n", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "n=int(input())\ns=(input())\nL=s.split(\" \")\nL=list(set(L))\nfor i in range(len(L)):\n    L[i]=int(L[i])\nL=sorted(L)\nif len(L)==1:\n    print(\"NO\")\nelse:\n    print(L[1])\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "s=input()\nn=len(s)\nm=0\n\nfor i in range(n-1):\n    for j in range(1,n-i):\n        if s[i:i+j] in s[i+1:]:\n            if j>m:\n                m=j\n\nprint(m)\n    ", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "n, K = map(int, input().split())\nmod = 998244353\nif K == 1:\n    print(2)\n    exit()\ndp = [[0]*(2**2) for i in range(K+1)]\ndp[1][0] = 1\ndp[2][1] = 1\ndp[2][2] = 1\ndp[1][3] = 1\nfor i in range(1, n):\n    nx = [[0]*(2**2) for i in range(K+1)]\n    for k in range(K+1):\n        for j in range(4):\n            if j == 0:\n                nx[k][0] += dp[k][j]%mod\n                if k+1 <= K:\n                    nx[k+1][1] += dp[k][j]%mod\n                    nx[k+1][2] += dp[k][j]%mod\n                    nx[k+1][3] += dp[k][j]%mod\n            elif j == 1:\n                nx[k][0] += dp[k][j]%mod\n                nx[k][1] += dp[k][j]%mod\n                if k+2 <= K:\n                    nx[k+2][2] += dp[k][j]%mod\n                nx[k][3] += dp[k][j]%mod\n            elif j == 2:\n                nx[k][0] += dp[k][j]%mod\n                if k+2 <= K:\n                    nx[k+2][1] += dp[k][j]%mod\n                nx[k][2] += dp[k][j]%mod\n                nx[k][3] += dp[k][j]%mod\n            else:\n                if k+1 <= K:\n                    nx[k+1][0] += dp[k][j]%mod\n                    nx[k+1][1] += dp[k][j]%mod\n                    nx[k+1][2] += dp[k][j]%mod\n                nx[k][3] += dp[k][j]%mod\n    dp = nx\n#print(dp)\nprint(sum(dp[K])%mod)\n", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "s=input()\nn=len(s)\nm=n-1;\nwhile m>0:\n    f=False\n    for i in range(0,n-m):\n        for j in range(i+1,n-m+1):\n            x=True\n            for k in range(0,m):\n                if s[i+k]!=s[j+k]:\n                    x=False\n                    break\n            if x:\n                f=True\n                break\n        if f:\n            break\n    if f:\n        break\n    m -= 1\nprint(m)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "from math import *\nn,k=map(int,input().split())\nval=int(sqrt(9+(8*(n+k))))\nans=(-3+val)//2\nprint(n-ans)\n", "complexity": "constant", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n = int(input())\nprint([\"YES\", \"NO\"][all(n % i for i in [4, 7, 47, 744, 477])])", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "from math import gcd\nn, x, y = map(int, input().split())\n\ndef solve(n, x, y):\n    g = gcd(x, y)\n    if gcd(x, y) != 1:\n        return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g)\n    ans = 0\n    for s in [0, 1]:\n        dp = [-n, -n]\n        dp[s] = 0\n        for i in range(x + y):\n            dp = [max(dp[0], dp[1]), dp[0] + (n // (x + y)) + (i * x % (x + y) < n % (x + y))]\n        ans = max(ans, dp[s])\n    return ans\n    \nprint(solve(n, x, y))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "import sys\ninput = sys.stdin.buffer.readline\nfrom itertools import permutations\n\nk = list(map(int,input().split()))\n\nworked = 0\nfor k1,k2,k3 in permutations(k):\n    worked2 = 1\n    for t in range(10000):\n        if not (t % k1 == 0 or t % k2 == 1 or t % k3 == 2):\n            worked2 = 0\n\n    if worked2:\n        worked = 1\n        break\n\nif worked:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "kol = int(input())\n\ndic = {'purple': 'Power',\n       'green': 'Time',\n       'blue': 'Space',\n       'orange': 'Soul',\n       'red': 'Reality',\n       'yellow': 'Mind'}\n\nr = []\ng = []\nmissing = 6 - kol\n\nfor k in range(kol):\n    rocks = input()\n    r.append(rocks)\n\nfor key in dic:\n    if r.count(key) == 0:\n        g.append(dic[key])\n\nprint(missing)\n\nfor stone in g:\n    print(stone)", "complexity": "constant", "problem": "0987_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\n\nk = int(input())\nd = [0]\nfor i in range(1, 12):\n    d.append((10 ** i - 10 ** (i - 1)) * i + d[i - 1])\n# print(d)\nfor i in range(1, len(d)):\n    if k <= d[i]:\n        f = d[i - 1]\n        f1 = 10 ** (i - 1)\n        # print(i, f)\n        # print(str(((k - f - 1) // i) + f1))\n        print(str(((k - f - 1) // i) + f1)[(k - f - 1) % i])\n        sys.exit()\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import math\ndef main():\n    x = input()\n    y = input()\n    goal = x.count('+') - y.count('+')\n    options = y.count('?')\n    if options == 0:\n        if goal == options:\n            print(1)\n        else:\n            print(0)\n    else:\n        if (goal > options):\n            print(0)\n        else:\n            if goal < 0:\n                print(0)\n            else:\n                print(math.factorial(options)/math.factorial(goal)/math.factorial(options-goal)/(2**options))\nmain()\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "import sys\n\n\ndef is_winning_state(nims, n):\n    keys = set(nims)\n    counts = dict.fromkeys(keys, 0)\n    for nim in nims:\n        counts[nim] += 1\n    if 0 in keys and counts[0] > 1:\n        return True\n    lose_count = 0\n    for k in keys:\n        if counts[k] > 2:\n            return True\n        if counts[k] > 1 and (k - 1) in keys and counts[k - 1] > 0:\n            return True\n        if counts[k] > 1:\n            lose_count += 1\n    if lose_count > 1:\n        return True\n    return False\n\ndef main():\n    n = int(input())\n    nims = list(map(int, input().split()))\n    if is_winning_state(nims, n):\n        print('cslnb')\n    else:\n        x = sum(nims) - (n * (n - 1)) // 2\n        if x % 2 == 0:\n            print('cslnb')\n        else:\n            print('sjfnb')\n\nmain()\n", "complexity": "linear", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "import sys\ninput = sys.stdin.readline\nn = int(input())\ns = list(map(int,input().split()))\nc = list(map(int,input().split()))\nd = {}\nfor i in range(n-1):\n    ans = 10**12\n    for j in range(i+1,n):\n        if s[i] < s[j]:\n            ans = min(ans,c[i]+c[j])\n\n    d[i] = ans\n\nans = 10**12\nfor i in range(n-2):\n    for j in range(i+1,n-1):\n        if s[i] < s[j]:\n            ans = min(ans,c[i]+d[j])\n\nif ans == 10**12:\n    print(-1)\n\nelse:\n    print(ans)", "complexity": "quadratic", "problem": "0987_C", "from": "CODEFORCES", "tags": "brute force,dp,implementation"}
{"src": "a, b, c, n = [int(j) for j in input().split()]\na -= c\nb -= c\nif n - a - b - c >= 1 and a >= 0 and b >= 0:\n    print(n - a - b - c)\nelse:\n    print(-1)\n", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n, s = map(int,input().split())\n\ndef digs(k):\n\tr = k\n\twhile k:\n\t\tr -= k % 10\n\t\tk //= 10\n\treturn r\nx = s + 19*9\nwhile digs(x-1) >= s:\n\tx -= 1\nprint(max(n - x + 1, 0))", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "a, b = map(int, input().split())\nc = input()\nsu = 0\ncnt = 0\nj = -2\ni = 0\nlis = \"abcdefghijklmnopqrstuvwxyz\"\nwhile i < 26 and cnt < b:\n    if lis[i] in c and i-2 >= j:\n        su += i+1\n        cnt += 1\n        j = i\n    i += 1\nif cnt < b:\n    print(-1)\nelse:\n    print(su)\n\t  \t\t\t  \t  \t \t\t\t \t\t  \t\t\t\t\t", "complexity": "linear", "problem": "1011_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "n = int(input())\nL = [int(i) for i in input().split()]\nR = [int(i) for i in input().split()]\nE = []\notv = [0] * n\nfor i in range(n):\n    sum_ = L[i] + R[i]\n    E.append([sum_, i])\nE.sort()\nfor i in range(n):\n    x = R[i]\n    for j in range(n):\n        if (x > 0):\n            if (E[j][1] > i):\n                otv[E[j][1]] += 1\n                x -= 1\n        else:\n            break\n        \n    if (x > 0):\n        print(\"NO\")\n        exit()\n        \n    x = L[i]\n    for j in range(n):\n        if (x > 0):\n            if (E[j][1] < i):\n                otv[E[j][1]] += 1\n                x -= 1\n        else:\n            break\n        \n    if (x > 0):\n        print(\"NO\")\n        exit()\n\nfor i in range(n):\n    r = 0\n    l = 0\n    for j in range(i + 1, n):\n        if (otv[j] > otv[i]):\n            r += 1\n    for z in range(i - 1, -1, -1):\n        if (otv[z] > otv[i]):\n            l += 1\n    if (r != R[i]) or (l != L[i]):\n        print(\"NO\")\n        exit()\n\nprint(\"YES\")\nfor i in range(n):\n    print(otv[i] + 1, end = ' ')\n    \n    \n\n", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "actions, end_total_candies = [int(i) for i in input().split()]\ncandies = 1\nif(actions == 1):\n    print(0)\nelse:\n    for i in range(1, actions):\n        candies = candies + i + 1\n        #print(end_total_candies, candies)\n        #print(\"falta \" + str(actions - i - 1) + \" acoes\")\n        if(candies >= end_total_candies + (actions - i - 2)):\n            print(candies - end_total_candies)\n            exit()\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n,k = map(int,input().split())\nif k>n+n-1:\n    print(0)\n    exit(0)\nif k-1<=n:\n    ml = 1\n    mr = k-1\n    print((mr-ml+1)//2)\nelse:\n    mr = n\n    ml = k-n\n    print((mr-ml+1)//2)", "complexity": "constant", "problem": "1023_B", "from": "CODEFORCES", "tags": "math"}
{"src": "n,m=map(int,raw_input().split())\n\nl=[]\nfor i in range(n):\n\ts=raw_input()\n\tl.append([])\n\tfor j in range(m):\n\t\tl[-1].append(s[j])\n\nans=[]\nfor i in range(n):\n\n\tans.append([])\n\tfor j in range(m):\n\t\tans[-1].append(\".\")\n\nfor i in range(n-2):\n\tfor j in range(m-2):\n\t\tif l[i][j]==\"#\":\n\t\t\tif l[i][j]==l[i][j+1] and l[i][j]==l[i][j+2] and l[i][j]==l[i+1][j] and l[i][j]==l[i+1][j+2] and l[i][j]==l[i+2][j] and l[i][j]==l[i+2][j+1] and l[i][j]==l[i+2][j+2]:\n\t\t\t\tans[i][j]=\"#\"\n\t\t\t\tans[i][j+1]=\"#\"\n\t\t\t\tans[i][j+2]=\"#\"\n\t\t\t\tans[i+1][j]=\"#\"\n\t\t\t\tans[i+1][j+2]=\"#\"\n\t\t\t\tans[i+2][j]=\"#\"\n\t\t\t\tans[i+2][j+1]=\"#\"\n\t\t\t\tans[i+2][j+2]=\"#\"\n\nflag = True\nfor i in range(n):\n\tfor j in range(m):\n\t\tif l[i][j]!=ans[i][j]:\n\t\t\tflag = False\n\t\t\tbreak\n\tif flag==False:\n\t\tbreak\n\nif flag==True:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")\n\n", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def x(a,b):\n    if(a>b):\n        return(1)\n    else:\n        return(0)\nn=int(input())\na1,a2=map(int,input().split())\nb1,b2=map(int,input().split())\nc1,c2=map(int,input().split())\nif((a1-a2)==(b1-b2)):\n    print(\"NO\")\nelif((a1+a2)==(b1+b2)):\n    print(\"NO\")\nelif(a1==b1):\n    print(\"NO\")\nelif(a2==b2):\n    print(\"NO\")\nelif((a1-a2)==(c1-c2)):\n    print(\"NO\")\nelif((a1+a2)==(c1+c2)):\n    print(\"NO\")\nelif(a1==c1):\n    print(\"NO\")\nelif(a2==c2):\n    print(\"NO\")\nelse:\n    if((x(a1,b1)==x(a1,c1)) and (x(a2,b2)==x(a2,c2))):\n        print(\"YES\")\n    else:\n        print(\"NO\")", "complexity": "constant", "problem": "1033_A", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation"}
{"src": "n = int(input())\na = []\n\nfor i in range(1, n+1):\n    l, r = map(int, input().split())\n    a.append((l, r, i))\n\na.sort()\n\nfor i in range(n-1):\n    if (a[i][0] == a[i+1][0]):\n        print(str(a[i][2]) + ' ' + str(a[i+1][2]))\n        break\n\n    if (a[i][1] >= a[i+1][1]):\n        print(str(a[i+1][2]) + ' ' + str(a[i][2]))\n        break\nelse:\n    print('-1 -1')\n\n\n\n\n", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "i = int(input())\ns = input().split()\n\nl = []\nfor j in s:\n    if not l or  int(j)%2 != l[-1]:\n        l.append(int(j)%2)\n    else:\n        l.pop()\n\nif len(l) < 2:\n    print('YES')\nelse:\n    print('NO')\n", "complexity": "linear", "problem": "1092_D1", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "n, m = map(int, input().split())\nx1 = -1\nx2 = -1\ny1 = -1\ny2 = -1\nfor i in range(n):\n    s = input()\n    for j in range(m):\n        if s[j] == 'B':\n            if x1 == -1:\n                x1 = j + 1\n            x2 = max(x2, j + 1)\n            if y1 == -1:\n                y1 = i + 1\n            y2 = i + 1\nprint((y1 + y2) // 2, (x1 + x2) // 2)", "complexity": "quadratic", "problem": "1028_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def check_combos(diff,n,size,start,picked,total,l,r,x,combination = []):\n    if picked == size:\n        if max(combination) - min(combination) >= x and l <= sum(combination) <= r:\n            total += 1\n    else:\n        for i in range(start,n-(size-picked-1)):\n            combination.append(diff[i])\n            picked += 1\n            total = check_combos(diff,n,size,i+1,picked,total,l,r,x,combination)\n            picked -= 1\n            combination.pop() \n    return total\n\ndef prog():\n    n,l,r,x = map(int,input().split())\n    diff = list(map(int,input().split()))\n    suitable_problemsets = 0\n    for size in range(1,n+1):\n        suitable_problemsets += check_combos(diff,n,size,0,0,0,l,r,x)\n    print(suitable_problemsets)\nprog()\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import math\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def print(self):\n        print(self.x, self.y)\n\n\nclass Line:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\n    def on(self, p):\n        return distance(self.p1, p) + distance(self.p2, p) == distance(self.p1, self.p2)\n\n    def print(self):\n        self.p1.print()\n        self.p2.print()\n\n\nclass Square:\n    def __init__(self, points):\n        self.points = points\n\n    def area(self):\n        return distance(self.points[0], self.points[1]) ** 2\n\n    def lines(self):\n        l = []\n        for i in range(3):\n            l.append(Line(self.points[i], self.points[i + 1]))\n        l.append(Line(self.points[3], self.points[0]))\n        return l\n\n    def midpoint(self):\n        return Point(self.points[0].x / 2 + self.points[2].x / 2, self.points[0].y / 2 + self.points[2].y / 2)\n\n    def print(self):\n        for point in self.points:\n            point.print()\n\n\ndef distance(p1, p2):\n    return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** .5\n\n\ndef tri_area(p1, p2, p3):\n    a = distance(p1, p2)\n    b = distance(p2, p3)\n    c = distance(p3, p1)\n    s = a + b + c\n    s /= 2\n    return (s * (s - a) * (s - b) * (s - c)) ** .5\n\n\ndef inter(p, s):\n    a = s.area()\n    area_sum = tri_area(s.points[0], s.points[1], p) + tri_area(s.points[1], s.points[2], p)\n    area_sum += tri_area(s.points[2], s.points[3], p) + tri_area(s.points[3], s.points[0], p)\n    if abs(a - area_sum) < 0.000001:\n        return True\n    return False\n\n\nc1 = input().split(\" \")\nc2 = input().split(\" \")\nfor i in range(8):\n    c1[i] = int(c1[i])\n    c2[i] = int(c2[i])\nc1p = []\nc2p = []\nfor i in range(0, 8, 2):\n    c1p.append(Point(c1[i], c1[i + 1]))\n    c2p.append(Point(c2[i], c2[i + 1]))\ns1 = Square(c1p)\ns2 = Square(c2p)\nyes = False\nfor point in s1.points:\n    if inter(point, s2):\n        if not yes:\n            print(\"YES\")\n            yes = True\nfor point in s2.points:\n    if inter(point, s1):\n        if not yes:\n            print(\"YES\")\n            yes = True\nif inter(s1.midpoint(), s2):\n    if not yes:\n        print(\"YES\")\n        yes = True\nif inter(s2.midpoint(), s1):\n    if not yes:\n        print(\"YES\")\nif not yes:\n    print(\"NO\")", "complexity": "constant", "problem": "0994_C", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import sys, math\n\ndef mp():\n    return list(map(int, input().split()))\n\ndef main():\n    n, k = mp()\n    a = [2, 5, 8]\n    s = 0\n    for i in a:\n        s += (n * i - 1) // k + 1\n    print(s)\n    \ndebug = 0\nif debug:\n    file = open(\"input.txt\", \"r\")\n    input = file.readline\nmain()\nif debug:\n    file.close()", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "from __future__ import division\nfrom sys import stdin, stdout\nfrom collections import Counter\n\ndef write(x):\n    stdout.write(str(x) + \"\\n\")\n\n\nn, c = map(int, stdin.readline().split())\na = map(int, stdin.readline().split())\nassert len(a) == n\n\ntel = Counter()\ntarget_count_last = Counter()\ntargets = 0\nbest = 0\n\n\nfor num in a:\n    if num == c:\n        targets += 1\n    else:\n        since_last = targets - target_count_last[num]\n        target_count_last[num] = targets\n        tel[num] = max(0, tel[num] - since_last)\n        tel[num] += 1\n        best = max(best, tel[num])\n\nwrite(targets + best)\n", "complexity": "linear", "problem": "1082_E", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "n,s = map(int,input().split())\nl = n+1\nfor i in range(s,min(s+1000000, n)+1,1):\n    cur = sum([int(j) for j in str(i)])\n    if(i-cur>=s):\n        l = i; break\nprint(n-l+1)", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "from os import path\nimport sys,time\n# mod = int(1e9 + 7)\n# import re\nfrom math import ceil, floor,gcd,log,log2 ,factorial\nfrom collections import * \n# from bisect import *\nmaxx = float('inf')\n#----------------------------INPUT FUNCTIONS------------------------------------------#\nI = lambda :int(sys.stdin.buffer.readline())\ntup= lambda : map(int , sys.stdin.buffer.readline().split())\nlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\nS = lambda: sys.stdin.readline().strip('\\n')\ndef grid(r, c): return [lint() for i in range(r)]\nstpr = lambda x : sys.stdout.write(f'{x}' + '\\n')\nstar = lambda x: print(' '.join(map(str, x)))\nlocalsys = 0\nstart_time = time.time()\nif (path.exists('input.txt')):\n\tsys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n#left shift --- num*(2**k) --(k - shift)\ns=S()\nans = s.replace('1','')+'2'\nt =  ans.find('2')\n# print(ans,t)\nprint(ans[:t]+'1'*s.count('1')+ans[t:len(ans)-1])\n\n\n\n\n\n\nif localsys:\n\tprint(\"\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")\n", "complexity": "linear", "problem": "1009_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "from sys import  stdin\ninput=stdin.readline\nfrom  collections import defaultdict\ndef num(s):\n    l,r=0,0\n    for i in s:\n        if l==0 and i==\")\":\n            r+=1\n        elif i==\"(\":\n            l+=1\n        elif l and i==\")\":\n            l-=1\n    return (l,r)\n\ndef f(mp,cnt):\n    ans=0\n    for l in cnt:\n        if l.count(0)<1:\n            continue\n        t=mp[l[::-1]]\n        ans+=t\n        if t and l!=l[::-1]:\n            mp[l]-=1\n    return ans\n\ncnt=[]\nmp=defaultdict(int)\nfor i in range(int(input())):\n    s=input()\n    l=num(s)\n    cnt.append(l)\n    mp[l]+=1\nprint(f(mp,cnt))", "complexity": "linear", "problem": "0990_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def operations(a, b):\n    less = min(a, b)\n    more = max(a, b)\n    ops = 0\n    while less > 0 and more > 0:\n        ops += more // less\n        more -= less * (more // less)\n        less, more = more, less\n    return ops\n\nn = int(input())\nfor i in range(n):\n    a, b = map(int, input().split())\n    print(operations(a, b))\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "class Combi():\n\n    def __init__(self, N, mod=10**9 + 7):\n        self.power = [1 for _ in range(N+1)]\n        self.rev = [1 for _ in range(N+1)]\n        self.mod = mod\n        for i in range(2, N+1):\n            self.power[i] = (self.power[i-1]*i) % self.mod\n        self.rev[N] = pow(self.power[N], self.mod-2, self.mod)\n        for j in range(N, 0, -1):\n            self.rev[j-1] = (self.rev[j]*j) % self.mod\n\n    def com(self, K, R):\n        if not (0 <= R <= K):\n            return 0\n        else:\n            return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod\n\n    def perm(self, K, R):\n        if not (0 <= R <= K):\n            return 0\n        else:\n            return (self.power[K])*(self.rev[K-R]) % self.mod\n\n\ndef bitcnt(X):\n    res = 0\n    v = X\n    while v:\n        res += v & 1\n        v >>= 1\n    return res\n\n\nc = Combi(10000)\nNL = list(map(int, list(input())))[::-1]\nN = len(NL)\nK = int(input())\nMOD = 10**9 + 7\n\ndp = [[0]*(1020) for i in range(1020)]\n\ndp[0][0] = 1\nfor pos, bit in enumerate(NL):\n    if bit == 1:\n        for bit in range(1010):\n            dp[pos + 1][bit] = (dp[pos][bit - 1] + c.com(pos, bit)) % MOD\n        continue\n    else:\n        for bit in range(1010):\n            dp[pos + 1][bit] = dp[pos][bit]\n        continue\n\nINF = 1 << 60\ncnt = [INF]*(1010)\n\ncnt[1] = 0\nMOD = 10**9 + 7\n\nfor i in range(2, 1010):\n    cnt[i] = 1 + cnt[bitcnt(i)]\n\nif K == 0:\n    print(dp[N][0])\n    exit()\nelse:\n    ans = 0\n    for bitcnt in range(1010):\n        if cnt[bitcnt] == K - 1:\n            ans += dp[N][bitcnt]\n    if K == 1:\n        ans -= 1\n    print(ans % MOD)\n    exit()\n", "complexity": "linear", "problem": "0914_C", "from": "CODEFORCES", "tags": "brute force,combinatorics,dp"}
{"src": "\nfrom sys import stdout\na, b = 0, 0\n\n\nmp = 29\n\nc, d = 0,0\n\npowers = [1]\nfor i in range(32):\n    powers.append(powers[-1]*2)\n\nqqq = 0\n\ndef get_ans(c, d):\n    global qqq\n    qqq += 1\n    a, b = 1073741823, 1073741821\n    a, b = 3, 1\n\n    print(c, d)\n\n    if (a^c) > (b^d): \n        print(1)\n        return -1\n    elif (a^c) < (b^d):\n        print(-1)\n        return 1\n    print(0)\n    return 0\n\ndef get_ans(c, d):\n    print('? {} {}'.format(c, d))\n    stdout.flush()\n    return -int(input())\n\nq = get_ans(0, 0)\n\nfor i in range(mp+1):\n    cp = mp - i\n    c += powers[cp]\n    d += powers[cp]\n    #print('cp, q', cp, q)\n    if q == 0:\n        continue\n    t = get_ans(c, d)\n    #print('t', t)\n\n    if t != q:\n    #    print('t != q')\n    #    print(a, b,c,d)\n        if t == 1:\n            a += powers[cp]\n            c -= powers[cp]\n        elif t == -1:\n            b += powers[cp]\n            d -= powers[cp]\n        q = get_ans(c, d)\n\n    #print(a, b, c, d)\n\n#print('qwe', a, b, c, d)\n\n\nfor i in range(mp+1):\n    cp = mp - i\n    #print(c, powers[cp], d)\n    if c & powers[cp] > 0 and d & powers[cp] > 0:\n        c -= powers[cp]\n        t = get_ans(c, d)\n\n        if t < 0:\n            a += powers[cp]\n            b += powers[cp]\n\n        c += powers[cp]\n\nprint('!', a, b)\n\n\n", "complexity": "constant", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "\na, b, c, d, e, f = list(map(int, input().split()))\nn, n2 = 1, a * b + c * d + e * f\nwhile n ** 2 < n2:\n    n += 1\nif n ** 2 > n2:\n    print(-1)\n    exit()\nl = sorted([[max(a, b), min(a, b), 'A'], [max(c, d), min(c, d), 'B'], [max(e, f), min(e, f), 'C']])\nif l[2][0] != n:\n    print(-1)\n    exit()\nv = str(n) + '\\n' + (l[2][2] * n + '\\n') * l[2][1]\nif l[0][0] == n and l[1][0] == n:\n    for i in range(2):\n        v += (l[i][2] * n + '\\n') * l[i][1]\nelse:\n    s = n - l[2][1]\n    if s not in l[0] or s not in l[1]:\n        print(-1)\n        exit()\n    x, y = l[0][1] if l[0][0] == s else l[0][0], l[1][1] if l[1][0] == s else l[1][0]\n    v += (l[0][2] * x + l[1][2] * y + '\\n') * s\nprint(v)", "complexity": "np", "problem": "0581_D", "from": "CODEFORCES", "tags": "bitmasks,brute force,constructive algorithms,geometry,implementation,math"}
{"src": "from itertools import chain, combinations\nfrom random import randint\ndef powerset(iterable):\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n\nn,l,r,x=map(int,input().split())\nll=list(map(int,input().split()))\nsubsets=powerset(ll)\nres=0\nfor i in subsets:\n    if len(i) >= 2 and l<= sum(i) <=r and max(i)-min(i) >= x:\n        res+=1\nprint(res)\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "class DisjointSet:\n    def __init__(self, n):\n        self._fa = list(range(n))\n\n    def union(self, x, y):\n        x = self.get_father(x)\n        y = self.get_father(y)\n        self._fa[x] = y\n        return y\n\n    def get_father(self, x):\n        y = self._fa[x]\n        if self._fa[y] == y:\n            return y\n        else:\n            z = self._fa[y] = self.get_father(y)\n            return z\n\n    def __repr__(self):\n        return repr([self.get_father(i) for i in range(len(self._fa))])\n\ndef solve(n, a, b, xs):\n    h = {x: i for i, x in enumerate(xs)}\n    if a == b:\n        if all(a - x in h for x in xs):\n            return [0] * n\n        return False\n    g1 = n\n    g2 = n + 1\n    ds = DisjointSet(n + 2)\n\n    for i, x in enumerate(xs):\n        for t in (a, b):\n            if t - x in h:\n                ds.union(i, h[t - x])\n\n    for i, x in enumerate(xs):\n        b1 = (a - x) in h\n        b2 = (b - x) in h\n        if b1 + b2 == 0:\n            return False\n        if b1 + b2 == 1:\n            if b1:\n                ds.union(i, g1)\n            else:\n                ds.union(i, g2)\n            if ds.get_father(g1) == ds.get_father(g2):\n                return False\n    group = [None] * n\n    for i, x in enumerate(xs):\n        f = ds.get_father(i)\n        if f < n:\n            return False\n        group[i] = f - n\n    return group\n\nn, a, b = map(int, input().split())\nxs = list(map(int, input().split()))\ngroup = solve(n, a, b, xs)\nif isinstance(group, list):\n    print('YES')\n    print(' '.join(map(str, group)))\nelse:\n    print('NO')", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "nab=input().split()\nl=input().split()\nnab=[int(i) for i in nab]\nl=[int(i) for i in l]\nl.sort()\nif(l[nab[2]-1]==l[nab[2]]):\n    print(0)\nelse:\n    print(l[nab[2]]-l[nab[2]-1])\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "n=int(input())\na=input()\nb=a.count('T')\nc=-1\nfor i in range(n):\n    d=0\n    for j in range(b):\n        d+=int(a[(i+j)%n]=='H')\n    if c==-1 or d<c:\n        c=d\nprint(c)", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "n, s = map(int, input().split())\nx, y = divmod(s, 9)\nif not s:\n\tx = 0\nelif y:\n\tx += 1\nlow = x*9\nfor i in range(low, low+10000):\n\tif i - sum([int(c) for c in str(i)]) >= s:\n\t\tlow = i\n\t\tbreak\nprint(max(n-low+1, 0))\n\t\t\t\t  \t \t\t\t \t\t  \t\t\t\t \t\t\t   \t", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    sum_A = sum(A)\n    cnt = defaultdict(int)\n    for a in A:\n        cnt[a] += 1\n\n    ans = 0\n    for i in range(N):\n        a = A[i]\n        cnt[a] -= 1\n        sum_A -= a\n\n        tmp = sum_A\n        n = 0\n        for b in (a-1, a, a+1):\n            n += cnt[b]\n            tmp -= b * cnt[b]\n        ans += tmp - a * (N-1-i-n)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "R, G, B = list(map(int, input().split()))\nr = [int(x) for x in input().split()]\nr.sort(reverse=True)\ng = [int(x) for x in input().split()]\ng.sort(reverse=True)\nb = [int(x) for x in input().split()]\nb.sort(reverse=True)\n\nans = 0\ndp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if i<R and j<G:\n                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])\n            if j<G and k<B:\n                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])\n            if i<R and k<B:\n                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "string = input().strip()\nmx = 0\n\nfor i in range(len(string)):\n    for j in range(i+1, len(string)):\n        m = 0\n        while(j+m < len(string) and string[i+m] == string[j+m]):\n            m += 1\n        mx = max(mx, m)\n\nprint(mx)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef bisearch_max(mn, mx, func):\n\n    ok = mn\n    ng = mx\n    while ok+1 < ng:\n        mid = (ok+ng) // 2\n        if func(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ndef check(m):\n    ok = [0] * N\n    S = set()\n    for i in range(N):\n        for j in range(M):\n            if A[i][j] >= m:\n                ok[i] |= 1<<j\n        S.add(ok[i])\n    full = (1<<M) - 1\n    for bit1 in range(1<<M):\n        for bit2 in range(bit1, 1<<M):\n            if bit1 in S and bit2 in S:\n                if bit1 | bit2 == full:\n                    return True\n    return False\n\nN, M = MAP()\nA = [None] * N\nfor i in range(N):\n    A[i] = LIST()\n\nres = bisearch_max(0, 10**9+1, check)\nok = [0] * N\nS = set()\nD = {}\nfor i in range(N):\n    for j in range(M):\n        if A[i][j] >= res:\n            ok[i] |= 1<<j\n    S.add(ok[i])\n    D[ok[i]] = i + 1\nfull = (1<<M) - 1\nfor bit1 in range(1<<M):\n    for bit2 in range(bit1, 1<<M):\n        if bit1 in S and bit2 in S:\n            if bit1 | bit2 == full:\n                print(D[bit1], D[bit2])\n                exit()\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "n = int(input())\nx, y = 1, 9\nn -= 1\nwhile n > x * y:\n    n -= x * y\n    x += 1\n    y *= 10\na = 10 ** (x - 1) + n // x\nprint(str(a)[n % x])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "a=list(map(int, input().split()))\nh=0\nfor i in range(14):\n    b=a[:]\n    if i==13:\n        j=0\n    else:\n        j=i+1\n    if a[i]>0:\n        c=0\n        t=b[i]%14\n        x=b[i]//14\n        b[i]=0\n        # print(b)\n        for i in range(14):\n            b[i]+=x\n        # print(b)\n        while t>0:\n            b[j]+=1\n            j+=1\n            if j==14:\n                j=0\n            t-=1\n        for i in range(14):\n            if b[i]%2==0:\n                c+=b[i]\n        # print(b)\n        if c>h:\n            h=c\nprint(h)\n\n\n\n\n\n\n", "complexity": "constant", "problem": "0975_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "class DFS:\n    def __init__(self):\n        self.G= []\n        self.leave_tree= []\n\n    def take_input(self):\n        k = int(input())\n        if(k>1):\n            graph =[int(node)-1 for (node) in input().split(' ')]\n            self.G = [[] for _ in range(len(graph)+1)]   \n            for i in range(len(graph)):\n                self.G[graph[i]].append(i+1)\n            self.visited = [0]*k\n            self.leave_tree = [0]*k\n            for i in range(k-1,-1,-1):\n                if len(self.G[i])==0:\n                    self.leave_tree[i]=1\n                else:\n                    for j in self.G[i]:\n                        self.leave_tree[i]+=self.leave_tree[j]\n            self.leave_tree.sort()\n            print(*self.leave_tree)\n        else:\n            print(k)\n\n\n\n\n\nx = DFS()\nx.take_input()\n", "complexity": "nlogn", "problem": "1056_D", "from": "CODEFORCES", "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"}
{"src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\n\nzb = getIntList()\n\nza1 = [0]\nza2 = [zb[0]]\n\nfor i in range(1, N//2):\n    t1 = zb[i] - za1[-1]\n    if t1 <= za2[-1]:\n        za1.append(za1[-1])\n        za2.append(t1)\n        continue\n    t2 = zb[i] - za2[-1]\n    if t2 >= za1[-1]:\n        za1.append(t2)\n        za2.append(za2[-1])\n        continue\n    assert False\n\nzr = za1 + za2[ : :-1]\nzs = []\nfor x in zr:\n    zs .append(str(x))\n    \n\nr = ' '.join(zs)\n\nprint(r)\n\n\n\n\n\n\n\n\n", "complexity": "linear", "problem": "1093_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import sys,math\nfrom collections import deque,defaultdict\nimport operator as op\nfrom functools import reduce\nfrom itertools import permutations\n\n#sys.setrecursionlimit(10**6) \n\nI=sys.stdin.readline\n\n#alpha=\"abcdefghijklmnopqrstuvwxyz\"\n\n\"\"\"\nx_move=[-1,0,1,0,-1,1,1,-1]\ny_move=[0,1,0,-1,1,1,-1,-1]\n\"\"\"\ndef ii():\n\treturn int(I().strip())\ndef li():\n\treturn list(map(int,I().strip().split()))\ndef mi():\n\treturn map(int,I().strip().split())\n\n\"\"\"def ncr(n, r):\n    r = min(r, n-r)\n    numer = (reduce(op.mul, range(n, n-r, -1), 1))%(10**9+7)\n    denom = (reduce(op.mul, range(1, r+1), 1))%(10**9+7)\n    return (numer // denom)%(10**9+7)\"\"\"\ndef ncr(n, r, p):\n    # initialize numerator\n    # and denominator\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, \n            p - 2, p)) % p\n \n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef valid(row,col,rows,cols,rcross,lcross):\n \treturn rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0\n\n\ndef div(n):\n\tif n==1:\n\t\treturn 1\n\tcnt=2\n\tfor i in range(2,int(n**.5)+1):\n\t\tif n%i==0:\t\t\t\n\t\t\tif i!=n//i:\n\t\t\t\tcnt+=2\n\t\t\telse:\n\t\t\t\tcnt+=1\n\treturn cnt\n\n\t\n\ndef isPrime(n):\n\tif n<=1:\n\t\treturn False\n\telif n<=2:\n\t\treturn True\n\telse:\n\t\tflag=True\n\t\tfor i in range(2,int(n**.5)+1):\n\t\t\tif n%i==0:\n\t\t\t\tflag=False\n\t\t\t\tbreak\n\t\treturn flag\n\ndef s(b):\n\tans=[]\n\twhile b>0:\n\t\ttmp=b%10\n\t\tans.append(tmp)\n\t\tb=b//10\n\treturn ans\n\n\n\ndef main():\n\tn,k=mi()\n\tarr=[]\n\tfor _ in range(n):\n\t\tx,y=mi()\n\t\tarr.append((x,y))\n\n\tarr=sorted(arr,key=lambda x: x[0],reverse=True)\n\t\n\tfor i in range(n-1):\n\t\tfor j in range(i+1,n):\n\t\t\tif arr[i][0]==arr[j][0] and arr[i][1]>arr[j][1]:\n\t\t\t\tarr[i],arr[j]=arr[j],arr[i]\n\n\t#print(arr)\n\tcnt=arr.count(arr[k-1])\n\tprint(cnt)\n\n\n\t\t\n\n\n\t\t\n\n\n\t\t\t\n\t\t\n\t\n\n\n\n\n\n\n\n\n\n\t\t\t\t\t\n\t\t\n\t\t\n\n\n\n\n\n\t\t\n\n\n\n\n\n\n\n\n\t\n\n\t\n\n\n \n\t\n\t\n\n\n\n\n\n\n\n\n\t\n\n\n\n\t\n\t\t\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\t\n\n\t\n\n\t\t\n\n\n\n\t\t\n\n\t\t\n\t\t\n\n\n\t\n\t\n\n\t\t\n\t\n\n\t\t\n\n\n\n\n\t\t\n\n\n\n\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\n\t\t\n\t\t\t\n\n\n\n\t\t\n\n\n\t\n\t\t\t\n\t\t\t\t\t\t\n\t\t\t\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\t\t\t\n\t\t\n\n\n\n\t\n\t\t\t\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\t\n\t\n\n\n\n\n\nif __name__ == '__main__':\n\tmain()", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import sys\nimport copy\n\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nMAT=[list(map(int,input().split())) for i in range(n)]\n\n#n=15\n#m=10000\n#MAT=[list(range(j*j,j*j*(m+1),j*j)) for j in range(1,n+1)]\n\n\nif n==1:\n    ANS=10**10\n    for i in range(1,m):\n        if ANS>abs(MAT[0][i]-MAT[0][i-1]):\n            ANS=abs(MAT[0][i]-MAT[0][i-1])\n    print(ANS)\n    sys.exit()\n\n\n\nEDGE0=[[10**10]*n for i in range(n)]#i\u304c0\u884c\u76ee,j\u304c\u6700\u7d42\u884c\nEDGE1=[[10**10]*n for i in range(n)]\nMAX=0\nMIN=0\n\nif m!=1:    \n    for i in range(n):\n        for j in range(n):\n\n            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])\n            \n            if EDGE1[i][j]>MAX:\n                MAX=EDGE1[i][j]\n\n            EDGE0[i][j]=min([abs(MAT[i][k]-MAT[j][k-1]) for k in range(1,m)])\nelse:\n    for i in range(n):\n        for j in range(n):\n\n            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])\n            \n            if EDGE1[i][j]>MAX:\n                MAX=EDGE1[i][j]\n    \n\ndef Hamilton(start,USED,rest,last,weight):\n    #print(start,USED,rest,last,weight,last*(1<<n)+USED)\n    if MEMO[last*(1<<n)+USED]!=2:\n        return MEMO[last*(1<<n)+USED]\n    if rest==1:\n        for i in range(n):\n            if USED & (1<<i)==0:\n                final=i\n                break\n\n        if EDGE0[start][final]>=weight and EDGE1[last][final]>=weight:\n            #print(start,USED,rest,last,weight)\n\n            MEMO[last*(1<<n)+USED]=1\n            return 1\n        else:\n            #print(start,USED,weight,\"!\")\n            MEMO[last*(1<<n)+USED]=0\n            return 0\n\n    for j in range(n):\n        if USED & (1<<j)==0 and EDGE1[last][j]>=weight:\n            \n            NEXT=USED+(1<<j)\n            if Hamilton(start,NEXT,rest-1,j,weight)==1:\n                #print(start,USED,rest,last,weight)\n                MEMO[last*(1<<n)+USED]=1\n                return 1\n    else:\n        #print(start,USED,weight,\"?\")\n        MEMO[last*(1<<n)+USED]=0\n        return 0\n        \n    \nwhile MAX!=MIN:\n    #print(MAX,MIN)\n    aveweight=(MAX+MIN+1)//2\n\n    for start in range(n):\n        MEMO=[2]*(n*1<<(n+1))\n        START=1<<start\n        if Hamilton(start,START,n-1,start,aveweight)==1:\n            MIN=aveweight\n            break\n    else:\n        MAX=aveweight-1\n\nprint(MAX)\n", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "n = int(input())\na = n * (n + 1) // 2\nprint(4 * a - 4 * n + 1)", "complexity": "constant", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "print('?', 0, 0, flush=True)\nt = int(input())\ns = [0]*31\nif t == 1:\n    s[30] = 1\nelse:\n    s[30] = -1\n\na = 0\nb = 0\nfor i in range(30, 0, -1):\n    c = (1 << (i-1)) + a\n    d = b\n    print('?', c, d, flush=True)\n    ans1 = int(input())\n    c = a\n    d = (1 << (i-1)) + b\n    print('?', c, d, flush=True)\n    ans2 = int(input())\n    if ans1 == -1 and ans2 == 1:\n        a += 1 << (i-1)\n        b += 1 << (i-1)\n        s[i-1] = s[i]\n    elif ans1 == 1 and ans2 == -1:\n        a += 0 << (i-1)\n        b += 0 << (i-1)\n        s[i-1] = s[i]\n    else:\n        s[i-1] = ans1\n        if s[i] == 1:\n            a += 1 << (i-1)\n            b += 0 << (i-1)\n        else:\n            a += 0 << (i-1)\n            b += 1 << (i-1)\nprint('!', a, b)\n\n", "complexity": "constant", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "n,m=map(int, input().split())\nfor i in range(n):\n    mt=input()\n    if mt.count('B')!=0:\n        print(mt.count('B')//2+i+1,mt.count('B')//2+mt.index('B')+1)\n        break", "complexity": "quadratic", "problem": "1028_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "for ctr in range(1):\n    s=input().strip()\n    for l in range(len(s),0,-1):\n        k=[]\n        for i in range(0,len(s)-l+1):\n            k.append(s[i:i+l])\n        if len(k)!=len(list(set(k))):\n            print(l)\n            exit()\n    print(0)\n    \n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "from sys import stdin, stdout, exit\nimport math\n\nn, k = map(int, stdin.readline().split())\n\n\n\nans = round((-3 + math.sqrt(9 + 8*(k+n))) / 2)\nstdout.write(str(n-ans) + \"\\n\")\n", "complexity": "constant", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "(x, y) = list(map(int, input().split(' ')))\n\na = 0\nb = x * y\npos = True\n\nfor t in reversed(range(b)):\n    b -= 1\n    print(str(int(a / y + 1)) + ' '+ str(int(a % y + 1)))\n    a += b * (1 if pos else -1)\n    pos = not pos  \n\n   \t\t\t \t\t\t\t\t\t\t\t \t\t \t\t\t  \t    \t", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "from sys import stdin\ninput=stdin.readline\n\ndef intersec(arr):\n    a=sorted(arr,key=lambda s:s[0],reverse=True)\n    b=sorted(arr,key=lambda s:s[1])\n\n    x, y = 0, 0\n    if a[0]==b[0]:\n        return max(b[1][1]-a[1][0],0)\n    else:\n        x=b[0][1]-a[1][0]\n        y=b[1][1]-a[0][0]\n    return max(x,y,0)\nblanck=[]\nfor i in range(int(input())):\n    a,b=map(int,input().strip().split())\n    blanck.append([a,b])\nprint(intersec(blanck))", "complexity": "linear", "problem": "1029_C", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "#!/usr/bin/env python\n# coding: utf-8\n\n# In[4]:\n\n\nimport math\nn=int(input())\ncolumns=list(map(int, input().rstrip().split()))\n\n\n# In[5]:\n\n\nmodcolumns=[i%2 for i in columns]\n\n\n# In[6]:\n\n\ntest=0\n\n\n# In[7]:\n\n\npreviouslist=[]\n\n\nfor i in range(0,n):\n    if len(previouslist)==0:\n        previouslist.append(modcolumns[i])\n        \n    elif modcolumns[i]==previouslist[-1]:\n        previouslist.pop()\n        \n    else:\n        previouslist.append(modcolumns[i])\n    \n    \n    \n    \n        \nif len(previouslist)<=1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n\n# In[ ]:\n\n\n", "complexity": "linear", "problem": "1092_D1", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "def bin(a):\n    if a <= 1:\n        return a\n    else:\n        return 10*bin(a//2)+a%2\n\ndef convBin(a):\n    k,i = 0,0\n    while a!=0:\n        k += (a%10)*int((2**i))\n        a //= 10\n        i += 1\n    return k\n\ndef maxi(a,b):\n    if a == b:\n        return 0\n    elif a+1 == b:\n        return a^b\n    elif a+2 == b:\n        x = a^(a+1)\n        y = a^(a+2)\n        z = (a+1)^(a+2)\n        return max(max(x,y),z)\n    else:\n        x = str(bin(a^b))\n        y = '1'*len(x)\n        return convBin(int(y))\na = list(map(int,input().split()))\nprint(maxi(a[0],a[1]))\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "y = [2]\nh = []\nj = 0\nfor i in range(3,1000):\n    z = 0\n    for x in range(2, int(i**0.5)+1):\n        if i%x == 0:\n            z+=1\n    if z == 0:\n        y.append(i)\nfor i in range(0,len(y)-1):\n    x = y[i]+y[i+1]\n    h.append(x)\n\nk = list(input().split())\na = int(k[0])\nb = int(k[1])\n\nfor i in range(0,len(h)):\n    h[i] = h[i] + 1\n\ng = []\n\nfor i in h:\n    z = 0\n    for x in range(2, int(i**0.5)+1):\n        if i%x == 0:\n            z+=1\n            \n    if z == 0:\n        g.append(i)\n#print(g)\n\nfor i in g:\n    if i>=2 and i<=a:\n        j+=1\nif j >= b:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n", "complexity": "linear", "problem": "0017_A", "from": "CODEFORCES", "tags": "brute force,math,number theory"}
{"src": "a,b=map(int,input().split())\nx,y,z=map(int,input().split())\nif a < x*2+y:\n    ry=x*2+y-a\nelse:\n    ry=0\nif b < y+z*3:\n    rb=y+z*3-b\nelse:\n    rb=0\nprint(ry+rb)", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\nu = list(map(int, input().split()))\nu.sort()\nans = 0\nk = 1\nok = False\nfor i in range(1, n):\n    if u[i] == u[i - 1]:\n        k += 1\n        if k == 3:\n            print('cslnb')\n            exit()\n        if k == 2:\n            if ok or u[i] == 0 or u[i] - u[i - 2] == 1:\n                print('cslnb')\n                exit()\n            ok = True\n    else:\n        k = 1\nfor i in range(n):\n    ans += u[i] - i\nif ans % 2 == 0:\n    print('cslnb')\nelse:\n    print('sjfnb')\n", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "k, n, s, p = map(int, input().split())\nL = (n - 1) // s + 1\nL *= k\nprint((L - 1) // p + 1)", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "#########################################################################################################\\\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\nimport sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math \n\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):  \n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef fastPrintNextLines(a):\n    # 12\n    # 3\n    # 1\n    #like this\n    #a is list of strings\n    print('\\n'.join(map(str,a)))\n\n#__________________________TEMPLATE__________________OVER_______________________________________________________\n\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\") \nelse:\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nt = 1\n# t = int(input())\nfor _ in range(t):\n    n = ii()\n    a = li()\n    s = sum(a)\n    cur = 0\n    for i in range(n):\n        cur+=a[i]\n        if cur>=s/2:\n            print(i+1)\n            break\n", "complexity": "linear", "problem": "0962_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n,s=int(input()),input()\np,q,r=len(set(s)),{},10**6\nfor i in range(n):\n    q[s[i]]=i\n    if len(q)==p:r=min(r,max(q.values())-min(q.values()))\nprint(r+1)", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "import math\n\nq = int(input())\n\nfor i in range(q):\n    x, y, k = map(int, input().split())\n    if x > k or y > k:\n        print(-1)\n    else:\n        if (x+y)%2 == 0:\n            if (k-max(x,y)) % 2 == 0:\n                print(k)\n            else:\n                print(k - 2)\n        else:\n            if (k-max(x,y)) % 2 == 0:\n                print(k-1)\n            else:\n                print(k-1)", "complexity": "constant", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "from math import inf\n\nif True:\n    n,m,k = map(int,input().split())\n    cosp = [[int(x) for x in input().split()]+[inf] for _ in range(n)]\n    cosv = [[int(x) for x in input().split()]for _ in range(n-1)]+[[inf]*m]\n    if k%2==1:\n        for _ in range(n):\n            print(*[-1]*m)\n     \n    else:    \n        dp = [[0]*m for i in range(n)]\n        xx,yy = [0,0,1,-1],[1,-1,0,0]\n        for _ in range(k//2):\n            dp1 = [[inf]*m for _ in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    for kk in range(4):\n                        x1,y1 = i+xx[kk],j+yy[kk]\n                        if kk < 2:\n                            if kk==1:\n                                edge = cosp[i][j-1]\n                            else:\n                                edge=cosp[i][j]\n                        else:\n                            if kk==3 :\n                                edge = cosv[i-1][j]\n                            else:\n                                edge = cosv[i][j]\n                        if edge != inf:\n                            dp1[i][j] = min(dp1[i][j],2*edge+dp[x1][y1])\n            dp = dp1[:]\n        for i in dp:\n            print(*i)", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom math import inf\n\nri = lambda : map(int, input().split())\n\ndef solve():\n    n,m = ri()\n    A = [[0 for _ in range(m)] for __ in range(n)]\n    left = [[0 for _ in range(m)] for __ in range(n)]\n    right = [[0 for _ in range(m)] for __ in range(n)]\n    up = [[0 for _ in range(m)] for __ in range(n)]\n    down = [[0 for _ in range(m)] for __ in range(n)]\n    for r in range(n):\n        lst = input()\n        for c in range(m):\n            if lst[c] == '*':\n                A[r][c] = left[r][c] = right[r][c] = up[r][c] = down[r][c] = 1\n\n    for r in range(n):\n        for c in range(1, m):\n            if A[r][c]:\n                left[r][c] += left[r][c-1]\n        for c in range(m-2, -1, -1):\n            if A[r][c]:\n                right[r][c] += right[r][c+1]\n\n    for c in range(m):\n        for r in range(1, n):\n            if A[r][c]:\n                up[r][c] += up[r-1][c]\n\n        for r in range(n-2, -1, -1):\n            if A[r][c]:\n                down[r][c] += down[r+1][c]\n    res = []\n    stars = 0\n\n    ROWS = [[0 for _ in range(m)] for __ in range(n)]\n    COLS = [[0 for _ in range(m)] for __ in range(n)]\n\n    for r in range(n):\n        for c in range(m):\n            if A[r][c]:\n                can = min(left[r][c], right[r][c], up[r][c], down[r][c])\n                can -= 1\n                if can > 0:\n                    stars += 1\n                    res.append((r+1, c+1, can))\n                ROWS[r-can][c] += can\n                if r+can+1 < n:\n                    ROWS[r+can+1][c] -= can\n                COLS[r][c-can] += can\n                if c+can+1 < m:\n                    COLS[r][c+can+1] -= can\n\n    valid = [[False for _ in range(m)] for __ in range(n)]\n    for r in range(n):\n        curr = 0\n        for c in range(m):\n            curr += COLS[r][c]\n            if curr > 0:\n                valid[r][c] = True\n\n\n    for c in range(m):\n        curr = 0\n        for r in range(n):\n            curr += ROWS[r][c]\n            if curr > 0:\n                valid[r][c] = True\n\n    for r in range(n):\n        for c in range(m):\n            if A[r][c] and not valid[r][c]:\n                print(-1)\n                return\n    print(stars)\n    for x,y,z in res:\n        print(x,y,z)\nt = 1\n#t = int(input())\nwhile t:\n    t -= 1\n    solve()\n\n", "complexity": "quadratic", "problem": "1015_E2", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "n=int(input())\nprint(n**2+(n-1)**2)", "complexity": "constant", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "n, m = map(int, input().split())\ns = 0\nwhile m:\n    s += n // m\n    n, m = m, n % m\nprint(s)", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "a = input()\nb = input()\nlist_a = list(a)\nlist_a.sort()\nmax_a = int(''.join(list_a))\nfor i in range(len(a)):\n    for j in range(i+1, len(a)):\n        list_a[i], list_a[j] = list_a[j], list_a[i]\n        temp_a = int(''.join(list_a))\n        if int(b) < temp_a or temp_a <= max_a:\n            list_a[i], list_a[j] = list_a[j], list_a[i]\n        else:\n            max_a = temp_a\nprint(max_a)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n = int(input())\nif n <= 5:\n    print(-1)\n    for i in range(2, n+1):\n        print(1, i)\n    exit()\n\nprint(1, 2)\nprint(2, 3)\nprint(2, 4)\nfor i in range(5, n+1):\n    print(3, i)\n\nfor i in range(2, n+1):\n    print(1, i)\n", "complexity": "linear", "problem": "0959_C", "from": "CODEFORCES", "tags": "constructive algorithms,trees"}
{"src": "a,b,c,d,e,f,g,h,i,j,k,l= [9*1, 90*2, 900*3, 9000*4, 90000*5, 900000*6, 9000000*7, 90000000*8, 900000000*9, 9000000000*10, 90000000000*11, 900000000000*12]\na=a; b= a+b; c= b+c; d=c+d; e=d+e; f= e+f; g= f+g; h=g+h; i=h+i; j= i+j\nk= j+k; l= k+l\nli1=[0,a,b,c,d,e,f,g,h,i,j,k,l]\nn= int(input()); nn=0\nfor ii in range(1,12):\n    if li1[ii-1]<n and li1[ii+1]>n:\n        nn= ii\n        \nn= n-li1[nn-1]\nr1= 10**(nn-1)\nn1= n//nn\nr1+= n1-1\nn2= n-(n1*nn)\nif n2==0:\n    print(str(r1)[-1])\nelse:\n    #print(r1, n2-1)\n    print(str(r1+1)[n2-1])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res//x * (x-1)\n            while n%x==0:\n                n //= x\n    if n!=1:\n        res = res//n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n//=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):#\u6392\u4ed6\u7684\u8ad6\u7406\u548c\u306e\u968e\u4e57\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\n#O(|S|)\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matrix[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matrix[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matrix[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]+other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]-other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matrix[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m//=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matrix[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import log,gcd\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn = int(input())\nP = permutations([i for i in range(4)])\nplus = [(0,0),(0,n),(n,0),(n,n)]\n\nA = []\nfor i in range(4):\n    tmp = [input() for i in range(n)]\n    if i!=3:\n        _ = input()\n    A.append(tmp)\n\ntmp = [[0 for i in range(2*n)] for j in range(2*n)]\nres = 10**17\nfor p in P:\n    for k in range(4):\n        x,y = plus[p[k]]\n        for i in range(n):\n            for j in range(n):\n                tmp[i+x][j+y] = int(A[k][i][j])\n\n    ans_1 = 0\n    ans_2 = 0\n    for i in range(2*n):\n        for j in range(2*n):\n            if tmp[i][j]==(i+j)%2:\n                ans_1 += 1\n            else:\n                ans_2 += 1\n\n    res = min(res,ans_1,ans_2)\n\nprint(res)\n", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "n=int(input())\nar=list(map(int,input().split()))\nd={};ans=0\nfor i in ar:d[i]=d.get(i,0)+1\nfor i in ar:\n  flag=False\n  for j in range(31):\n    k=2**j;\n    if k>=i:\n     k1=k-i\n     if i!=k1 and d.get(k1,0)>0:flag=True;break\n     if i==k1 and d.get(i,0)>1:flag=True;break\n  if not flag:ans+=1\n    \nprint(ans)\n", "complexity": "nlogn", "problem": "1005_C", "from": "CODEFORCES", "tags": "brute force,greedy,implementation"}
{"src": "def getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\n\nfrom collections import deque\n\nn, m = getList()\nnums = getList()\nmxnum = max(nums)\nd = deque(nums)\n\nqr = []\nfor i in range(m):\n    qr.append(getN())\n\nlog = []\n\nrot = 0\nwhile(True):\n    # print(d)\n    a = d.popleft()\n    b = d.popleft()\n    log.append((a, b))\n    if a > b:\n        a, b = b, a\n\n    d.append(a)\n    d.appendleft(b)\n\n    rot += 1\n\n    if b == mxnum:\n        break\n\n\n\nfor q in qr:\n    if q <= rot:\n        print(log[q - 1][0], log[q - 1][1])\n    else:\n        res = q -  rot - 1\n        print(b, d[res % (n-1) + 1  ])\n\n# print(d)\n\"\"\"\n5 10\n1 2 5 4 3\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\"\"\"\n", "complexity": "linear", "problem": "1180_C", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "N = int(input())\nmap_1 = [list(input()) for i in range(N)]\nmap_2 = [list(input()) for i in range(N)]\n\nmaps = list()\n\nmaps.append([[map_2[i][j] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[i][N - 1 - j] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[N - 1 - i][j] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[N - 1 - i][N - 1 - j] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[j][i] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[j][N - 1 - i] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[N - 1 - j][i] for j in range(N)] for i in range(N)])\nmaps.append([[map_2[N - 1 - j][N - 1 - i] for j in range(N)] for i in range(N)])\n\nprint(('No', 'Yes')[any(map_1 == el for el in maps)])\n", "complexity": "quadratic", "problem": "0958_A1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\nprint(3*n//2)", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "n,k = map(int,input().split())\nif(k - n >= n) :\n    print(0)\n    exit()\nif(k <= n):\n    if(k%2):\n         print(k//2)\n    else :\n        print(k//2-1)\nelse:\n    print(n-k//2)", "complexity": "constant", "problem": "1023_B", "from": "CODEFORCES", "tags": "math"}
{"src": "from sys import stdin\nfrom collections import deque\n\nn, k = map(int, stdin.readline().split())\n\ngraph = [set() for _ in range(n)]\n\nfor _ in range(n-1):\n    a,b = map(int,stdin.readline().split())\n\n    graph[a - 1].add(b - 1)\n    graph[b - 1].add(a - 1)\n\nleafs = [i for i,v in enumerate(graph) if len(v) == 1]\nnew_leafs = []\nvalid = True\ncenters = dict()\ncount = 0\n\nwhile len(leafs) > 1 and valid:\n    for leaf in leafs:\n        center = graph[leaf].pop()\n\n        try:\n            centers[center] += 1\n        except KeyError:\n            centers[center] = 1\n\n        graph[center].remove(leaf)\n\n        if len(graph[center]) == 0:\n            break\n\n        elif len(graph[center]) == 1:\n            new_leafs.append(center)\n\n    if any(mult < 3 for mult in centers.values()):\n        valid = False\n        break\n    \n    count = count + 1\n    leafs = new_leafs\n    new_leafs = []\n    centers = {}\n\nif valid and count == k:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "nlogn", "problem": "1067_B", "from": "CODEFORCES", "tags": "dfs and similar,graphs,shortest paths"}
{"src": "input()\nl=[int(x)%2 for x in input().split()]\nprint(l.index(sum(l)==1)+1)", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "'''\n                ___                       ____                     \n  ____ _____ _____/ (_)_  ______  ____ _____/ / /_  __  ______ ___  __\n / __ `/ __ `/ __  / / / / / __ \\/ __ `/ __  / __ \\/ / / / __ `/ / / /\n/ /_/ / /_/ / /_/ / / /_/ / /_/ / /_/ / /_/ / / / / /_/ / /_/ / /_/ / \n\\__,_/\\__,_/\\__,_/_/\\__,_/ .___/\\__,_/\\__,_/_/ /_/\\__, /\\__,_/\\__, /  \n                        /_/                      /____/      /____/   \n'''\nimport os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\ndef st(): return list(sys.stdin.readline().strip())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef mp(): return map(int, sys.stdin.readline().split())\ndef inp(): return int(sys.stdin.readline())\ndef pr(n): return sys.stdout.write(str(n)+\"\\n\")\ndef prl(n): return sys.stdout.write(str(n)+\" \")\n\n\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\n\ndef solve():\n    n, m = mp()\n    k = inp()\n    l = li()\n    q = deque()\n    v = [[0]*(m+1) for i in range(n+1)]\n    for i in range(0, 2*k - 1, 2):\n        q.append((l[i], l[i+1]))\n        v[l[i]][l[i+1]] = 1\n    while q:\n        a, b = q.popleft()\n        for i in range(4):\n            A, B = a+dx[i], b+dy[i]\n            if A > 0 and A <= n and B > 0 and B <= m:\n                if not v[A][B]:\n                    q.append((A, B))\n                    v[A][B] = 1\n    print(a, b)\n\n\nfor _ in range(1):\n    solve()\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "import bisect\n\ndef solve():\n    n = int(input())\n    a = [int(x) for x in input().split(' ')]\n    p = [0]\n    for x in a:\n        p.append(p[-1] + x)\n    return bisect.bisect_left(p, p[-1] / 2)\n\nprint(solve())", "complexity": "linear", "problem": "0962_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\n# sys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef check(x):\n    T1 = T[:x] + '*'\n    T2 = T[x:] + '*'\n    m1 = len(T1)\n    m2 = len(T2)\n\n    dp = list2d(N+1, m1, -1)\n    dp[0][0] = 0\n    for i in range(N):\n        s = S[i]\n        for j in range(m1):\n            k = dp[i][j]\n            if k != -1:\n                dp[i+1][j] = max(dp[i+1][j], k)\n                if T1[j] == s:\n                    dp[i+1][j+1] = max(dp[i+1][j+1], k)\n                if T2[k] == s:\n                    dp[i+1][j] = max(dp[i+1][j], k+1)\n    return dp[N][m1-1] == m2-1\n\nfor _ in range(INT()):\n    S = input()\n    T = input()\n\n    N = len(S)\n    M = len(T)\n    for x in range(M):\n        if check(x):\n            YES()\n            break\n    else:\n        NO()\n", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "n, k = map(int, input().split())\na = input().split()\nmods = [dict() for i in range(10)]\nl = [0] * n\nfor i in range(n):\n    l[i] = len(a[i])\n    a[i] = int(a[i]) % k\n    cur = a[i]\n    for j in range(10):\n        cur = cur * 10 % k\n        mods[j][cur] = mods[j].get(cur, 0) + 1\nans = 0\nfor i in range(n):\n    mod = (k - a[i]) % k\n    ans += mods[l[i] - 1].get(mod, 0)\n    cur = a[i]\n    for j in range(l[i]):\n        cur = cur * 10 % k\n    if cur == mod:\n        ans -= 1\nprint(ans)", "complexity": "nlogn", "problem": "1029_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n = [int(x) for x in input().split()]\na = []\nfor i in range(3):\n\ta.append([int(x) for x in input().split()])\n\ta[i].sort(reverse=True)\n\ndp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]\nans = 0\nfor i in range(n[0] + 1):\n\tfor j in range(n[1] + 1):\n\t\tfor k in range(n[2] + 1):\n\t\t\tif i < n[0] and j < n[1]:\n\t\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])\n\t\t\tif i < n[0] and k < n[2]:\n\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])\n\t\t\tif j < n[1] and k < n[2]:\n\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])\n\t\t\tans = max(ans, dp[i][j][k])\n\nprint(ans)", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "from sys import stdin, stdout \ninput = stdin.readline\n \nn,m,K = map(int,input().split())\nedges = []\nfor i in range(n):\n    edges.append([[]])\n    lis = list(map(int,input().split()))\n    for j in range(m-1):\n        edges[i][j].append((1,0,lis[j]))\n        edges[i].append([])\n        edges[i][j+1].append((-1,0,lis[j]))\nfor i in range(n-1):\n    lis = list(map(int,input().split()))\n    for j in range(m):\n        edges[i][j].append((0,1,lis[j]))\n        edges[i+1][j].append((0,-1,lis[j]))\n\nif K%2==1:\n    lis = []\n    for i in range(n):\n        lis.append([-1]*m)\nelse:\n    lis = []\n    for i in range(n):\n        lis.append([0]*m)\n        \n    for k in range(1,(K//2)+1):\n        new_lis = []\n        for i in range(n):\n            new_lis.append([0]*m)\n        for i in range(n):\n            for j in range(m):\n                dist = []\n                for e in edges[i][j]:\n                    # print(e,i,j,lis)\n                    dist.append(e[2] + lis[i+e[1]][j+e[0]])\n                new_lis[i][j] = min(dist)\n        lis = new_lis\n    for i in range(n):\n        for j in range(m):\n            lis[i][j] *= 2\n            \nfor i in lis:\n    print(*i)", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import math as ma\nimport sys\nfrom sys import exit\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\n\ndef li():\n\treturn list(map(int , input().split()))\n\n\ndef num():\n\treturn map(int , input().split())\n\n\ndef nu():\n\treturn int(input())\n\n\nn,s=num()\ncc=0\nfor i in range(n,0,-1):\n\tcc+=s//i\n\ts=s%i\nprint(cc)", "complexity": "constant", "problem": "1061_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    cnt = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] > a[j]:\n                cnt += 1\n    even = cnt % 2 == 0\n    q = int(input())\n    for _ in range(q):\n        l, r = map(int, input().split())\n        len = r - l + 1\n        pairs = len * (len-1) // 2\n        if pairs % 2 == 1:\n            even = not even\n        if even:\n            print('even')\n        else:\n            print('odd')\n\n\nmain()", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "l = input().split(' ')\nx = int(l[0])\nk = int(l[1])\n\nif x == 0:\n    print('0')\nelse:\n    mod = 1000000007\n\n    def pow_mod(a, b):\n        if b < 2:\n            return int(a ** b) % mod\n        elif b % 2 == 0:\n            return int(pow_mod(a, b // 2) ** 2) % mod\n        else:\n            return pow_mod(a, b - 1) * a % mod\n\n    twop = pow_mod(2, k)\n    high = x * twop\n    leafs = twop\n    low = high - leafs + 1\n    s = (high + 1) * high // 2 - (low - 1 + 1) * (low - 1) // 2\n    answer = s * 2 // leafs\n    answer %= mod\n\n    print(answer)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n=int(input())\nif n%4==2:\n    print('!', '-1')\n    exit()\ndef qry(i):\n    print('?', i+1, flush=True)\n    a=int(input())\n    return a\ndef qry2(i):\n    a=qry(i+n//2)-qry(i)\n    if a==0:\n        print('!', i+1)\n        exit()\n    return a\na=qry2(0)\nlb,rb=1,n//2-1\nwhile lb<=rb:\n    mb=(lb+rb)//2\n    b=qry2(mb)\n    if (a>0)==(b>0):\n        lb=mb+1\n    else:\n        rb=mb-1", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "str=input()\nn=len(str)\nans=0\namap={}\ndef fun():\n    global ans\n    for strLen in range(n,0,-1):\n        mark=0\n        for t in range(0,n):\n            if t+strLen>n:\n                break\n            s=str[t:t+strLen]\n            if s in amap:\n                amap[s]+=1\n            else:\n                amap[s]=1\n            if amap[s]>=2:\n                mark=1\n                ans=len(s)\n                print(ans)\n                break\n        if mark==1:\n            break\nfun()\nif ans==0:\n    print(ans)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "def solve(a, b):\n    m = len(a)\n    n = len(b)\n    p_b = [0]\n    for x in b[:]:\n        p_b.append(p_b[-1] + int(x))\n    s = 0\n    for i in range(m):\n        if a[i] == '0':\n            s += p_b[n - m + 1 + i] - p_b[i]\n        else:\n            s += (n - m + 1) - (p_b[n - m + 1 + i] - p_b[i])\n    return s\n\n\na = input()\nb = input()\nprint(solve(a, b))\n", "complexity": "linear", "problem": "0608_B", "from": "CODEFORCES", "tags": "combinatorics,strings"}
{"src": "n = int(input())\nar = []\nfor i in range(n):\n    ar.append(input())\nsortedAr = sorted(ar,key=len)\nflag = False\nfor i in range(n-1):\n    if sortedAr[i+1].find(sortedAr[i]) == -1:\n        print('NO')\n        flag = True\n        break\nif not flag:\n    print('YES')\n    for i in sortedAr:\n        print(i)\n \t \t \t    \t\t\t \t   \t \t \t\t\t \t \t\t", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "n=int(input())\na=[0]+list(map(int,input().split()))\nans=0\nfor i in range(1,len(a)):\n    if a[i]==-1:\n        continue\n    j=i\n    while a[j]!=-1:\n        prev=j\n        j=a[j]\n        a[prev]=-1\n    ans+=1\nif n%2==0:\n    #n even ans also even even number of swaps required\n    #3*n \n    if ans%2==0:\n        print(\"Petr\")\n    else:\n        print(\"Um_nik\")\nelse:\n    #n us odd ans is even odd number of swaps required\n    if ans%2==0:\n        print(\"Petr\")\n    else:\n        print(\"Um_nik\")", "complexity": "nlogn", "problem": "0986_B", "from": "CODEFORCES", "tags": "combinatorics,math"}
{"src": "n,x=list(map(int,input().split()))\nb=list(map(int,input().split()))\nd={}\nflag=0\nfor i in b:\n    if d.get(i):\n        flag=1\n        break\n    else:\n        d[i]=1\nif flag:\n    print(0)\nelse:\n    flag=0\n    c=set()\n    for i in b:\n        a=i&x\n        c.add(a)\n        if d.get(a) and a!=i:\n            flag=1\n            break\n    if flag:\n        print(1)\n    elif len(c)<n and flag==0:\n        print(2)\n    else:\n        print(-1)\n\n        \n        \n", "complexity": "linear", "problem": "1013_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "#This code sucks, you know it and I know it.  \n#Move on and call me an idiot later.\n\nMOD = 1000000007\ndef fast_power(base, power):\n    result = 1\n    while power > 0:\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        power = power // 2\n        base = (base * base) % MOD\n\n    return result\n\nx, k = map(int, input().split())\n\nif x == 0 or k == 0:\n    print((x * 2) % MOD)\nelse:\n    d = ((x * 4) - 1) - (x * 2)\n    print(((x * 2) + (d * (fast_power(2, k) - 1))) % MOD)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "from sys import stdin\nfrom collections import Counter\n\nrstr = lambda: stdin.readline().strip()\na, b = list(rstr()), list(rstr())\n\nif len(a) < len(b) or len(a) == 1:\n    print(''.join(sorted(a)[::-1]))\nelse:\n    ans, tem = 0, []\n\n    for i in range(len(b)):\n        for j in range(int(b[i]) - 1, -1, -1):\n            if str(j) in a and not (j == i == 0):\n                a.remove(str(j))\n                ans = max(ans, int(''.join(tem) + str(j) + ''.join(sorted(a)[::-1])))\n                a.append(str(j))\n                break\n\n        if b[i] not in a:\n            break\n\n        tem.append(b[i])\n        a.remove(b[i])\n        \n    if tem:\n        ans = max(ans, int(''.join(tem)))\n\n    print(ans)\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "from __future__ import division\nfrom sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, m = rints()\na, cur, ans = rints()[::-1], 2, -1\n\nfor i in range(n - 2):\n    cur = max(cur, i + 2)\n    for j in range(cur, n):\n        if a[i] - a[j] > m:\n            break\n\n        cur += 1\n        v = (a[i] - a[j - 1]) / (a[i] - a[j])\n        ans = max(ans, v)\n\nprint(ans)\n", "complexity": "nlogn", "problem": "0957_C", "from": "CODEFORCES", "tags": "binary search,greedy,math,two pointers"}
{"src": "import sys\nimport math\nimport itertools\nimport functools\nimport collections\nimport operator\n\n\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef wr(arr): return ' '.join(map(str, arr))\ndef revn(n): return str(n)[::-1]\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\ndef divs(n, start=1):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    return r\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\ndef prime(n):\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    return True\ndef convn(number, base):\n    newnumber = 0\n    while number > 0:\n        newnumber += number % base\n        number //= base\n    return newnumber\ndef cdiv(n, k): return n // k + (n % k != 0)\n\n\nn, k = mi()\nt = math.ceil(math.sqrt(2 * (n + k) + 2.25) - 1.5)\nprint(n - t)\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n,ll,r,x=map(int,input().split(\" \"))\nl=list(map(int,input().split(\" \")))\nsubset = []\nfor i in range(1,(2**n)):\n  sub=[]\n  for j in range(n):\n    if (1<<j)&i>0:\n      sub.append(l[j])\n  subset.append(sub)\nc=0\n# print(*subset,sep=\"\\n\")\nfor i in subset:\n  if len(i)>1:\n    su=sum(i)\n    if (su>=ll and su<=r) and ((max(i)-min(i))>=x):\n      c+=1\nprint(c)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "MOD=1000000007\n\nx,k=map(int,raw_input().split())\n\nif x>0:\n\tans=(pow(2,k+1,MOD)*x)%MOD\n\tans=(ans-pow(2,k,MOD))%MOD\n\tans=(ans+1)%MOD\nelse:\n\tans=0\n\nprint(ans)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\na = list(map(int,input().split()))\nrev = [-1] * (n + 1)\nfor i, j in enumerate(a):\n    rev[j] = i\n\nmx = max(a)\n\n# [l, r]\nl = a.index(mx)\nr = l\n\nfor i in range(n - 1, 0, -1):\n    idx = rev[i]\n    if idx == l - 1:\n        l -= 1\n    elif idx == r + 1:\n        r += 1\n    else:\n        print('NO')\n        exit()\nprint('YES')", "complexity": "linear", "problem": "1197_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "ints=[int(x) for x in input().split()]\nn=ints[0] # number of ints\nm=ints[1] # num special\nk=ints[2] # divider\nspecial=[int(x) for x in input().split()]\nnumOn=0\nnumOps=0\nwhile numOn<m:\n    numOps+=1\n    op=((special[numOn]-numOn-1)//(k))*k+k+numOn+1\n    while numOn<m and special[numOn]<op:\n        numOn+=1\nprint(numOps)", "complexity": "linear", "problem": "1191_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def quadrant(x, y, rx, ry):\n\tif x>rx and y>ry:\n\t\treturn 1\n\telif x<rx and y>ry:\n\t\treturn 2\n\telif x<rx and y<ry:\n\t\treturn 3\n\telse:\n\t\treturn 4\n\nn = int(input())\n\nqx, qy = map(int, input().split())\nkx, ky = map(int, input().split())\ncx, cy = map(int, input().split())\n\nif quadrant(kx, ky, qx, qy) == quadrant(cx, cy, qx, qy):\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")\n", "complexity": "constant", "problem": "1033_A", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation"}
{"src": "from math import factorial\ns=input().rstrip()\ns1=input().rstrip()\npos1=0\npos=0\nposi=0\nnegi=0\nposi1=0\nnegi1=0\nques1=0\nfor i in s:\n    if i=='+':\n        pos+=1\n        posi+=1\n        \n    else:\n        pos-=1\n        negi+=1\nfor i in s1:\n    if i=='+':\n        posi1+=1\n    elif i=='-':\n        negi1+=1\n    else:\n        ques1+=1\nif posi==posi1 and negi==negi1:\n    print(1)\n    exit()\ndiff1=posi-posi1\ndiff=negi-negi1\nif diff<0  or diff1<0:\n    print(0)\nelse:\n    outcomes=2**ques1\n    nume=factorial(ques1)\n    deno=factorial(ques1-diff1)*factorial(diff1)\n    fav1=nume/deno\n    ques1=ques1-diff1\n    num1=factorial(ques1)\n    deno1=factorial(ques1-diff)*factorial(diff)\n    fav2=num1/deno1\n    ans=fav1*fav2\n    print(ans/outcomes)\n\n    \n    \n\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "from math import *\nn,x,y=map(int,input().split());g=gcd(x,y);n,x,y,r,h=n//g,x//g,(x+y)//g,n%g,lambda n:max(f(n,0),f(n,1))\ndef f(n,s):\n d=[-n,-n];d[s]=0\n for i in range(y):d=[max(d[0],d[1]),d[0]+n//y+(i*x%y<n%y)]\n return d[s]\nprint(h(n+1)*r+h(n)*(g-r))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "n, m = map(int, input().split())\nprint(m // n + (1 if m % n else 0))\n", "complexity": "constant", "problem": "1036_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\nx,y = map(int,input().split())\nnum = x - 1 + y - 1\nnum2 = n - x + n - y\nans = num <= num2\nif ans:\n    print(\"White\")\nelse:\n    print(\"Black\")\n", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "# from typing import List, Set, Dict, Tuple, Text, Optional\nfrom collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nimport functools\nimport random\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__  # type: ignore\n\nEPS = 10**-12\n\n#########\n# INPUT #\n#########\n\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n    # type: () -> str\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\n##########\n# OUTPUT #\n##########\n\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n    # type: (str) -> None\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n    # type: (str) -> None\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\n###########\n# LIBRARY #\n###########\n\n\ndef bootstrap(f, stack=[]):\n  # Deep Recursion helper.\n  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst\n  # Usage:\n\n  # @bootstrap\n  # def recur(n):\n  #   if n == 0:\n  #     yield 1\n  #   yield (yield recur(n-1)) * n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\n\nclass CycleFindDirected(object):\n  '''\n  >>> tp = CycleFindDirected(6)\n  >>> tp.find() is None\n  True\n  >>> tp.add_edge(1, 2)\n  >>> tp.add_edge(2, 4)\n  >>> tp.add_edge(2, 3)\n  >>> tp.add_edge(3, 0)\n  >>> tp.add_edge(1, 3)\n  >>> tp.find() is None\n  True\n  >>> tp.add_edge(0, 1)\n  >>> len(tp.find())\n  4\n  >>> tp.add_edge(3, 1)\n  >>> tp.find() is not None\n  True\n  >>> tp = CycleFindDirected(2)\n  >>> tp.add_edge(0, 1)\n  >>> tp.add_edge(1, 1)\n  >>> tp.find()\n  [1, 1]\n  >>> tp = CycleFindDirected(2)\n  >>> tp.add_edge(0, 1)\n  >>> tp.add_edge(1, 0)\n  >>> tp.find() in [[0, 1], [1, 0]]\n  True\n\n  Tested in: \n  '''\n\n  def __init__(self, n):\n    # type: (int) -> None\n    self.n = n\n    self.adj = [[] for _ in range(n)]\n\n  def add_edge(self, u, v):\n    # type: (int, int) -> None\n    assert 0 <= u < self.n\n    assert 0 <= v < self.n\n    self.adj[u].append(v)\n\n  @bootstrap\n  def dfs(self, node):\n    self.color[node] = 1\n    for i in self.adj[node]:\n      if self.color[i] == 0:\n        # unvisited\n        self.parent[i] = node\n        if (yield self.dfs(i)):\n          yield True\n\n      elif self.color[i] == 1:\n        self.cycle_end = node\n        self.cycle_start = i\n        yield True\n\n    self.color[node] = 2\n    yield False\n\n  def find(self):\n    self.color = [0] * self.n\n    self.parent = [-1] * self.n\n    self.cycle_end = -1\n    self.cycle_start = -1\n\n    for i in range(self.n):\n      if not self.color[i] and self.dfs(i):\n        answer = []\n        node_begin = self.cycle_start\n        node_end = self.cycle_end\n        answer.append(node_begin)\n        while node_end != node_begin:\n          answer.append(node_end)\n          node_end = self.parent[node_end]\n\n        answer.reverse()\n        if len(answer) == 1:\n          # special case of self loop\n          return [node_begin, node_begin]\n        return answer\n\n    return None\n\n\n#########\n# LOGIC #\n#########\n\n\ndef main(inp, out):\n  # type: (Input, Output) -> any\n  n, m = map(int, inp.rawInput().split())\n  edges = []\n  base = CycleFindDirected(n)\n  for _ in range(m):\n    u, v = map(int, inp.rawInput().split())\n    u -= 1\n    v -= 1\n    edges.append((u, v))\n    base.add_edge(u, v)\n\n  cycle = base.find()\n  if not cycle:\n    out.writeLine(\"YES\")\n    return\n\n  cycle.append(cycle[0])\n\n  bad_edges = set()\n  cycle_edges = []\n  for u, v in zip(cycle[:-1], cycle[1:]):\n    bad_edges.add((u, v))\n    cycle_edges.append((u, v))\n\n  cf = CycleFindDirected(n)\n  for edge in edges:\n    if edge not in bad_edges:\n      cf.add_edge(edge[0], edge[1])\n\n  for edge in cycle_edges:\n    for toadd in cycle_edges:\n      if toadd != edge:\n        cf.adj[toadd[0]].append(toadd[1])\n\n    if not cf.find():\n      out.writeLine('YES')\n      return\n\n    for toadd in cycle_edges:\n      if toadd != edge:\n        cf.adj[toadd[0]].pop()\n\n  out.writeLine('NO')\n\n###############\n# BOILERPLATE #\n###############\n\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()\n", "complexity": "quadratic", "problem": "0915_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs"}
{"src": "def chk(n):\n    return int(n**0.5+0.1)**2 == n\nfor _ in range(int(input())):\n    n = int(input())\n    if n % 2 == 0 and chk(n//2) or n % 4 == 0 and chk(n//4):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "complexity": "constant", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import sys\nfrom math import sqrt,log2\nfrom collections import Counter\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn=input()\nct=0\ni=0\ns=[]\nwhile i <len(n):\n    if not int(n[i])%3:\n        ct+=1\n        s.clear()\n    else:\n        t=int(n[i])%3\n        if 3-t in s:\n            ct+=1\n            s.clear()\n        else:\n            s.append(t)\n    if len(s)==3:\n        ct+=1\n        s.clear()\n    i+=1\n\nprint(ct)", "complexity": "linear", "problem": "1005_D", "from": "CODEFORCES", "tags": "dp,greedy,number theory"}
{"src": "o=int(input())\nuk=[]\ngh=0\nuo=0\nfor i in range(o):\n    yu=input()\n    if(len(yu)>gh):\n        gh=len(yu)\n        uo=i\n    uk.append(yu)\n        \nyk=0\nyj={}\n\ntd=0  \nuk.sort()\nfor i in range(len(uk)-1):\n    for j in range(i+1,len(uk)):\n        if(len(uk[j])<len(uk[i])):\n            t=uk[j]\n            uk[j]=uk[i]\n            uk[i]=t\nfor i in range(1,len(uk)):\n    j=i\n    while(j>=0):\n        if(uk[i].count(uk[j])==0):\n            td=1\n        j=j-1\nif(td==0):        \n    print('YES')   \n    for i in uk:\n        print(i)            \nelse:   \n    print('NO')\n\n \t\t \t \t\t\t \t\t\t\t\t \t\t\t\t\t\t     \t\t", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "from sys import stdin, stdout\nn = int(stdin.readline())\nm = int(stdin.readline())\nstdout.write(str(m%(1<<n)))", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "a = list(map(int, input().split()))\nn = a[0]\nk = a[1]\ns = input()\nm = int(-1)\nfor i in range(0, n - 1):\n    ff = int(0)\n    for j in range(0, i + 1):\n        if s[j] != s[n - i - 1 + j]:\n            ff = 1\n            break;\n    if ff == 0:\n        m = i\nprint(s, end=\"\")\nfor i in range(1, k):\n    for j in range(m + 1, n):\n        print(s[j], end=\"\")\n\n\t\t \t  \t  \t\t \t\t\t \t  \t\t\t\t \t \t\t\t\t\t", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "import math\ns1 = input()\ns2 = input()\nx = 0\ny = 0\np = 0\nfor i in range(len(s1)):\n    if s1[i] == '+': x+=1\n    elif s1[i] == '-': y+=1\n    if s2[i] == '+': x-=1\n    elif s2[i] == '-': y-=1\n    else: p+=1\nif x<0 or y<0:\n    print(float(0))\nelse:\n    q = math.factorial(x+y)/(math.factorial(x)*math.factorial(y))\n    r = q/math.pow(2,p)\n    print(r)\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "import sys\nimport math\nimport collections\nimport bisect\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n=int(input())\n    starting=[]\n    ending=[]\n    points=[]\n    for i in range(n):\n        x,y=get_ints()\n        starting.append(x)\n        ending.append(y)\n    ans=0\n    start_count=collections.Counter(starting)\n    end_count=collections.Counter(ending)\n    s=starting.copy()\n    s.sort()\n    e=ending.copy()\n    e.sort()\n    maxim=max(starting)\n    minim=min(ending)\n    #print(maxim,minim)\n    for i in range(n):\n        if starting[i]==maxim:\n            if start_count[maxim]>1:\n                loc_max=maxim\n            else:\n                pos=bisect.bisect_left(s,maxim)\n                loc_max=s[pos-1]\n        else:\n            loc_max=maxim\n        if ending[i]==minim:\n            if end_count[minim]>1:\n                loc_min=minim\n            else:\n                pos=bisect.bisect_right(e,minim)\n                loc_min=e[pos]\n        else:\n            loc_min=minim\n        ans=max(ans,loc_min-loc_max)\n        #print(loc_max,loc_min)\n    print(ans)", "complexity": "linear", "problem": "1029_C", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "# from math import ceil\n# n, k = map(int, input().split())\n# print(ceil(n*2/k) + ceil(n*5/k) + ceil(n*8/k))\n\nfor _ in range(int(input())):\n    i, j = map(int, input().split())\n    i -= 1\n    print((j//2 * (j//2 + 1) - i//2 * (i//2 + 1)) - \n          (((j - j//2) * (j - j//2)) - ((i - i//2) * (i - i//2)))) ", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys,os,io,time,copy\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\nimport math\n\ndef main():\n    # start=time.time()\n    n=int(input())\n    print(0,0,n)\n\n    # end=time.time()\nmain()", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "def Fast_power(x , y):\n    res = 1\n    while y > 0 :\n        if (y % 2 != 0):\n            res = res * x\n\n        y = y // 2\n        x = x * x\n\n    return res\n\nn = int(input())\nm = int(input())\n\nif n <= 40 :\n    print(m % Fast_power(2 , n))\nelse:\n    print(m)\n\n\n", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import sys\n\nn = int(input())\nl = list(map(int,input().split()))\nc = list(map(int,input().split()))\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\na = {0:0}\n\nfor i in range(n):\n    b = a.copy()\n    for p in a.items():\n        d = gcd(p[0], l[i])\n        cost = p[1] + c[i]\n        if d not in b: b[d] = cost\n        elif b[d] > cost: b[d] = cost\n    a = b\n\nif 1 not in a: a[1] = -1\nprint(a[1])\n\n                                                                                                         ", "complexity": "np", "problem": "0512_B", "from": "CODEFORCES", "tags": "data structures,dp,math,number theory,shortest paths"}
{"src": "k = int(input())\nprev=0\nnext=0\nNumofDigits=0\n#i = 0\n#while(sum<(2^12)):\nwhile(True):\n    prev = next\n    next = next+(9*(10**(NumofDigits-1))*NumofDigits)\n    if(k>= prev and k<=next):\n        break\n    NumofDigits=NumofDigits+1\nif(NumofDigits==1):\n    print(k)\nelse:\n    result = (10**(NumofDigits-1))+int((k-(prev+1))/NumofDigits)\n    i=0\n    while(True):\n        if (k-int(prev+1))%NumofDigits == i:\n            break\n        i=i+1\n    result = str(result)\n    print(result[i])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "def main():\n    c,r,o,e=0,0,[0]*300000,[0]*300000\n    for _ in range(int(input())):\n        s=input()\n        l,n=0,0\n        for i in s:\n            if i=='(':\n                l+=1\n            else:\n                if l!=0:\n                    l-=1\n                else:\n                    n+=1\n        if l==0 and n==0:\n            c+=1\n        elif l!=0 and n!=0:\n            pass\n        elif l!=0:\n            o[l]+=1\n        else:\n            e[n]+=1\n    for i in range(300000):\n        if e[i] and o[i]:\n            r+=e[i]*o[i]\n    print(pow(c,2)+r)\nif __name__=='__main__':\n    main()", "complexity": "linear", "problem": "0990_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "s = input()\nt = s.count('1')\ns = s.replace('1', '')\ni = s.find('2')\nif i == -1:\n    print(s + '1'*t)\nelse:\n    print(s[:i] + '1'*t + s[i:])", "complexity": "linear", "problem": "1009_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "a,b = map(int,input().split())\na,b = min(a, b), max(a, b)\nA = bin(a)[2:]\nB = bin(b)[2:]\nA = \"0\" * (len(B) - len(A)) + A\ndiff = 0\nfor i in range(len(A)):\n    if(A[i]!=B[i]):\n        diff = len(A) - i\n        break\nprint((2**diff) - 1)\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import math\n\ndef solve(n) :\n    if not n%2 and math.sqrt(n//2) == int(math.sqrt(n//2)) :\n        print('YES')\n        return\n    if not n%4 and math.sqrt(n//4) == int(math.sqrt(n//4)) :\n        print('YES')\n        return\n    print('NO')\n\nt = int(input())\nfor i in range(t) :\n    n = int(input())\n    solve(n)", "complexity": "constant", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\nimport math as mt\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef lcm(a, b):\n    return (a * b) / gcd(a, b)\n\n\nmod = int(1e9) + 7\n\n\ndef power(k, n):\n    if n == 0:\n        return 1\n    if n % 2:\n        return (power(k, n - 1) * k) % mod\n    t = power(k, n // 2)\n    return (t * t) % mod\n\n\ndef totalPrimeFactors(n):\n    count = 0\n    if (n % 2) == 0:\n        count += 1\n        while (n % 2) == 0:\n            n //= 2\n\n    i = 3\n    while i * i <= n:\n        if (n % i) == 0:\n            count += 1\n            while (n % i) == 0:\n                n //= i\n        i += 2\n    if n > 2:\n        count += 1\n    return count\n\n\n# #MAXN = int(1e7 + 1)\n# # spf = [0 for i in range(MAXN)]\n#\n#\n# def sieve():\n#     spf[1] = 1\n#     for i in range(2, MAXN):\n#         spf[i] = i\n#     for i in range(4, MAXN, 2):\n#         spf[i] = 2\n#\n#     for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n#         if (spf[i] == i):\n#             for j in range(i * i, MAXN, i):\n#                 if (spf[j] == j):\n#                     spf[j] = i\n#\n#\n# def getFactorization(x):\n#     ret = 0\n#     while (x != 1):\n#         k = spf[x]\n#         ret += 1\n#         # ret.add(spf[x])\n#         while x % k == 0:\n#             x //= k\n#\n#     return ret\n\n\n# Driver code\n\n# precalculating Smallest Prime Factor\n# sieve()\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    same = 0\n    ind = -1\n    poss=1\n    for i in range(1, n):\n        same += (a[i] == a[i - 1])\n        if a[i]==a[i-1]:\n            ind = i - 1\n            if a[i]==0:\n                poss=0\n    if same > 1 or poss==0:\n        print('cslnb')\n    else:\n        if ind > 0:\n            if a[ind] - a[ind - 1] == 1:\n                print('cslnb')\n                return\n        c = 0\n        for i in range(n):\n            c += a[i] - i\n        if c % 2:\n            print('sjfnb')\n        else:\n            print('cslnb')\n\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "s1, s2 = input().split()\nans = s1[0]\nfor i in range(1, len(s1)):\n    if s1[i] < s2[0]:\n        ans += s1[i]\n        if i == len(s1) - 1:ans += s2[0]\n    else:\n        ans += s2[0]\n        break\nif len(s1) == 1:print(s1[0] + s2[0])\nelse:print(ans)", "complexity": "linear", "problem": "0909_A", "from": "CODEFORCES", "tags": "brute force,greedy,sortings"}
{"src": "n=int(input())\nif n>=6:\n\tfor i in range(2, n-1):\n\t\tprint(1, i)\n\tfor i in range(n-1, n+1):\n\t\tprint(2, i)\nelse:\n\tprint(-1)\nfor i in range(2, n+1):\n\tprint(1, i)", "complexity": "linear", "problem": "0959_C", "from": "CODEFORCES", "tags": "constructive algorithms,trees"}
{"src": "import io,os\n# input = sys.stdin.buffer.readline\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nn,m=map(lambda x:int(x), input().split())\nA = []\nfor _ in range(n):\n    scores = list(map(lambda x:int(x), input().split()))\n    A.append(scores)\n\ndef solve(n,m,A):\n    # O(31*( 5*n + 4**5 ))\n    # all index from 0\n    ans = ()\n    nstats = 2**m\n    def judge(finalScore):\n        nonlocal ans\n        seen = {}\n        for i,scores in enumerate(A):\n            sta = 0\n            for e in scores:\n                sta=sta*2+(e>=finalScore)\n            # example [1,2,3,4,1], finalScore=3\n            # sta = 0b00110\n            seen[sta]=i\n        \n        for i in range(nstats):\n            for j in range(nstats):\n                if ((i|j) == nstats-1) and i in seen and j in seen:\n                    ans = (seen[i], seen[j])\n                    return True\n\n        return False\n    \n    l=0\n    r=2**31-1\n    while l<r:\n        m=l+(r-l)//2\n        if not judge(m):\n            r=m\n        else:\n            l=m+1\n    # Highest score is l-1\n    print(ans[0]+1,ans[1]+1) # answer index start from 1\n\nsolve(n,m,A)\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "n,m = map(int,input().split())\nxi = list(map(int,input().split()))\nti = list(map(int,input().split()))\nai = [0] * (m+2)\nar = [0] * (m+2)\nar[-1] = 10**11\nar[0] = -100000000000\nj = 1\nn2 = n + m\nfor i in range(n2):\n    if ti[i] == 1:\n        ar[j] = xi[i]\n        j += 1\ni1 = 0\ni2 = 1\nfor i in range(n2):\n        if ti[i] == 1:\n            i2 += 1\n            i1 += 1\n            continue\n        num = xi[i] - ar[i1]\n        num2 = ar[i2] - xi[i]\n        if num <= num2:\n            ai[i1] += 1\n        else:\n            ai[i2] += 1\nfor i in range(1,m+1):\n    print(ai[i],end=\" \")\n", "complexity": "linear", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import sys,math\nfrom collections import deque,defaultdict\nimport operator as op\nfrom functools import reduce\n\n#sys.setrecursionlimit(10**6) \n\nI=sys.stdin.readline\n\n #s=\"abcdefghijklmnopqrstuvwxyz\"\n\n\"\"\"\nx_move=[-1,0,1,0,-1,1,1,-1]\ny_move=[0,1,0,-1,1,1,-1,-1]\n\"\"\"\ndef ii():\n\treturn int(I().strip())\ndef li():\n\treturn list(map(int,I().strip().split()))\ndef mi():\n\treturn map(int,I().strip().split())\n\n\"\"\"def ncr(n, r):\n    r = min(r, n-r)\n    numer = (reduce(op.mul, range(n, n-r, -1), 1))%(10**9+7)\n    denom = (reduce(op.mul, range(1, r+1), 1))%(10**9+7)\n    return (numer // denom)%(10**9+7)\"\"\"\ndef ncr(n, r, p):\n    # initialize numerator\n    # and denominator\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, \n            p - 2, p)) % p\n \n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef valid(row,col,rows,cols,rcross,lcross):\n \treturn rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0\n\n\ndef div(n):\n\ttmp=[]\n\tfor i in range(2,int(n**.5)+1):\n\t\tif n%i==0:\n\t\t\tcnt=0\n\t\t\twhile(n%i==0):\n\t\t\t\tn=n//i \n\t\t\t\tcnt+=1\n\t\t\ttmp.append((i,cnt))\n\tif n>1:\n\t\ttmp.append((n,1))\n\treturn tmp\n\ndef isPrime(n):\n\tif n<=1:\n\t\treturn False\n\telif n<=2:\n\t\treturn True\n\telse:\n\t\tflag=True\n\t\tfor i in range(2,int(n**.5)+1):\n\t\t\tif n%i==0:\n\t\t\t\tflag=False\n\t\t\t\tbreak\n\t\treturn flag\n\ndef s(b):\n\tans=[]\n\twhile b>0:\n\t\ttmp=b%10\n\t\tans.append(tmp)\n\t\tb=b//10\n\treturn ans\n\n\ndef main():\n\tn=ii()\n\tprint(n,0,0)\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\t\n\t\t\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\t\n\n\t\n\n\t\t\n\n\n\n\t\t\n\n\t\t\n\t\t\n\n\n\t\n\t\n\n\t\t\n\t\n\n\t\t\n\n\n\n\n\t\t\n\n\n\n\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\n\t\t\n\t\t\t\n\n\n\n\t\t\n\n\n\t\n\t\t\t\n\t\t\t\t\t\t\n\t\t\t\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\t\t\t\n\t\t\n\n\n\n\t\n\t\t\t\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\t\n\t\n\n\n\n\n\nif __name__ == '__main__':\n\tmain()", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "def binarySearch (N,l,r,x): \n    if r >= l: \n        mid = l + (r - l)//2\n        Temp = (mid*(mid+1))//2\n        if Temp-x == N-mid: \n            return N-mid \n        elif Temp-x > N-mid: \n            return binarySearch(N,l, mid-1, x)  \n        else: \n            return binarySearch(N,mid + 1, r, x) \n    else: \n        return -1\nn,k=list(map(int,input().split()))\nprint(binarySearch (n,0,n,k))", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
