{"src": "mod = 1000000007\nx, k = map(int, input().split())\nif x == 0:\n    print(0)\nelse:\n    ans = (pow(2, k + 1, mod) * x % mod - (pow(2, k, mod) - 1 + mod) % mod + mod) % mod\n    print(ans)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\nimport threading\ninp = sys.stdin.buffer.readline      \ninput = lambda: sys.stdin.readline().rstrip()\ndef I(): return list(map(int,inp().split()))\ndef main():\n    n,=I() ; vis=[0]*n ; st=[0]*n\n    if n==1:\n        print(1)\n        exit(0)\n    def dfs(g,e):\n        if vis[e]==1: return\n        else: \n            vis[e]=1\n            for i in g[e]:\n                dfs(g,i)\n            if len(g[e])==1 and e!=0: st[e]+=1\n            for i in g[e]:\n                st[e]+=st[i]\n    a=[int(i)-1 for i in input().split()]\n    g=[[] for i in range(n)]\n    for i in range(n-1):\n        g[i+1].append(a[i])\n        g[a[i]].append(i+1)\n    dfs(g,0)\n    st.sort()\n    print(*st)\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "complexity": "quadratic", "problem": "1056_D", "from": "CODEFORCES", "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"}
{"src": "n, p = map(int, input().split())\na = list(map(int, input().split()))\na = [c % p for c in a]\ns = sum(a)\nsp = s % p\nif sp == s or sp + 1 == p:\n    print(sp)\nelse:\n    print(sp + p)", "complexity": "linear", "problem": "0958_C1", "from": "CODEFORCES", "tags": "brute force"}
{"src": "cs = int(input())\n\nfor c in range(cs):\n    l, r = map(int, input().split())\n    #odd     => -\n    #even    => +\n    \n    if l%2 == 0 and r%2 == 0:\n        print((r - l) // 2 + l)\n    if l%2 == 1 and r%2 == 0:\n        print((r - l + 1) // 2)\n    if l%2 == 0 and r%2 == 1:\n        print(-(r - l + 1) // 2)\n    if l%2 == 1 and r%2 == 1:\n        print(-(r - l) // 2 - l)", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\ninput=sys.stdin.readline\nn=int(input())\nar=list(map(int,input().split()))\ndic={}\nli=[]\nfor i in range(n):\n    xx=[]\n    for j in range(n-i):\n        xx.append(0)\n    li.append(xx.copy())\nfor i in range(n):\n    for j in range(n-i):\n        if(i==0):\n            li[i][j]=ar[j]\n        else:\n            li[i][j]=li[i-1][j]^li[i-1][j+1]\nfor i in range(1,n):\n    for j in range(n-i):\n        li[i][j]=max(li[i][j],li[i-1][j],li[i-1][j+1])\nfor _ in range(int(input())):\n    l,r=map(int,input().split())\n    print(li[r-l][l-1])", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "from os import path\nimport sys,time\n# mod = int(1e9 + 7)\n# import re\nfrom math import ceil, floor,gcd,log,log2 ,factorial\nfrom collections import * \n# from bisect import *\nmaxx = float('inf')\n#----------------------------INPUT FUNCTIONS------------------------------------------#\nI = lambda :int(sys.stdin.buffer.readline())\ntup= lambda : map(int , sys.stdin.buffer.readline().split())\nlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\nS = lambda: sys.stdin.readline().replace('\\n', '').strip()\ndef grid(r, c): return [lint() for i in range(r)]\nstpr = lambda x : sys.stdout.write(f'{x}' + '\\n')\nstar = lambda x: print(' '.join(map(str, x)))\nlocalsys = 0\nstart_time = time.time()\nif (path.exists('input.txt')):\n\tsys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n#left shift --- num*(2**k) --(k - shift)\nn = I()\nls = [int(i) for i in S()]\npre , s =[] , 0\nfor i in ls:\n\ts+=i\n\tpre.append(s)\nfor i in range(n-1):\n\tcnt =0\n\tsu =0\n\tfor j in range(i+1 , n):\n\t\tsu+=ls[j]\n\t\tif su == pre[i]:\n\t\t\tcnt+=1\n\t\t\tsu =0\n\tif cnt and su ==0:\n\t\tprint('YES')\n\t\texit()\nprint('NO')\n\n\n\n\n\n\n\n\n\nif localsys:\n\tprint(\"\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")\n", "complexity": "quadratic", "problem": "1030_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from math import ceil\ndef test(f):\n    for i in range(n):\n        if (r1+ f) > f * lift[i]:\n            return 0\n        f -= (r1 + f) / lift[i]\n        if (r1+ f) > f * land[i + 1]:\n            return 0\n        f -= (r1 + f) / land[i + 1]\n    return 1\np=int(input())\ntotal_wgt=int(input());r1=total_wgt\nlift=list(map(int,input().split()))\nland=list(map(int,input().split()));n=len(land);ans=1e20\nlift+=[lift[0]];land+=[land[0]]\nl=0.0;r=1e20\nfor i in range(1000):\n  mid=(l+r)/2.0\n  #print(mid)\n  if test(mid):r=mid\n  else:l=mid\nif r<1e19:\n    print('%.17f' %r)\nelse:\n    print(-1)\n", "complexity": "linear", "problem": "1010_A", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "from collections import defaultdict\nfrom sys import stdin\n\nall_in = stdin.read().splitlines()\n\nn = int(all_in[0])\ns = all_in[1:]\n\none = defaultdict(lambda: 0)\ntwo = defaultdict(lambda: 0)\n\nfor el in s:\n    I = 0\n    min_ = 0\n\n    for char in el:\n        I += {'(': 1, ')': -1}[char]\n        min_ = min(min_, I)\n\n    if I >= 0 and min_ == 0:\n        one[I] += 1\n\n    if I <= 0 and min_ == I:\n        two[I] += 1\n\nans = 0\nfor el in one.keys():\n    ans += one[el] * two[-el]\n\nprint(ans)\n", "complexity": "linear", "problem": "0990_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def forninho(miolo, s):\n    premiolo = miolo\n    temp = 0\n    while (miolo > 0):\n        temp += miolo % 10;\n        miolo = miolo // 10;\n    if (premiolo - temp >= s):\n        return 1\n    else:\n        return 0\n\nentrada = input().split()\nn = int(entrada[0])\ns = int(entrada[1])\n\nresult = -1\nl = 1\nr = n\nwhile (r-l >= 0):\n    miolo = (l + r) // 2\n    if(forninho(miolo,s) == 1):\n        r = miolo - 1\n        result = miolo\n    else:\n        l = miolo + 1\n\nif (result == -1):\n    print(\"0\")\nelse:\n    print(n - result + 1)\n  \t\t  \t \t\t\t \t   \t \t\t \t  \t\t  \t", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "a=int(input())\nb=str(a)\nc=[]\nfor i in range(2,a+1):\n    if(a%i==0):\n        c.append(i)\n\nl=0\nfor j in c:\n    r=str(j)\n    t=len(r)\n    o=0\n    for p in r:\n        if(p==\"4\" or p==\"7\"):\n            o=o+1\n    if(o==t):\n        l=l+1\nif(l>0):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n            \n    \n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "# A. Game Shopping\n\nn, m = map(int, input().split())\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nans = 0\ni = 0\nfor bill in a:\n    try:\n        i += next(ind for ind, el in enumerate(c[i:]) if el <= bill) + 1\n        ans += 1\n    except StopIteration:\n        break\n\nprint(ans)\n", "complexity": "linear", "problem": "1009_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import math\nx, k = list(map(int, input().split()))\nmod = 10**9 + 7\nprint((pow(2, k+1, mod)*x - pow(2, k, mod) + 1) % mod if x > 0 else 0)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "# import os\n\nn = int(input())\n\nr = []\nfor _ in range(n):\n    a,b,c,d = map(int,input().split())\n    r.append(sum([a,b,c,d]))\n\nthomas = r[0]\nprint(sorted(r, reverse=True).index(thomas)+1)\n", "complexity": "linear", "problem": "1017_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import json\nimport os\n\n\ndef convert_files_to_json():\n    answer = dict()\n    for file in os.listdir(\"bad/\"):\n        if '_' in file:\n            # x, y = map(int, file.split('_'))\n            answer[file] = [list(map(int, line.split())) for line in open(\"bad/\" + file).read().split('\\n')[:2]]\n\n    return json.dumps(answer)\n\n\ndef extract_list(compressed_list, start_val=1):\n    answer = []\n    for num in compressed_list:\n        answer += [start_val] * num\n        start_val += 1\n    return answer\n\n\nanswer = json.loads('{\"1_12\": [[], [2, 2, 2, 2, 2, 3]], \"6_11\": [[1, 1, 1, 1, 1, 7], [2, 3, 1, 2, 2, 2, 2, 3]], '\n                    '\"3_10\": [[], [1, 1, 4, 1, 1, 5]], \"3_17\": [[1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], \"6_9\": [[], [1, 1, '\n                    '1, 1, 1, 10]], \"9_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 19]], \"18_21\": [[], [1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22]], \"10_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], \"15_18\": [['\n                    '], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], \"1_10\": [[], [2, 2, 2, 2, 3]], \"6_19\": [[], '\n                    '[1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 8]], \"3_13\": [[1, 1, 4, 1, 1, 4], [2]], \"2_22\": [[], [1, 3]], '\n                    '\"3_6\": [[], [1, 1, 7]], \"10_14\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 1, 1, 1, 1, 7], '\n                    '[1, 3]], \"9_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [2]], \"6_15\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 7]], '\n                    '\"7_22\": [[], [1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 9]], \"1_15\": [[], [2]], \"10_15\": [[], [1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 16]], \"3_15\": [[], [1, 1, 4]], \"11_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '12], [1, 3, 1, 4, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4]], \"15_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 16, 1, 1, 4, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 1, 4]], \"18_19\": [[], [1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20]], \"11_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12], '\n                    '[2]], \"2_2\": [[], [1, 3]], \"16_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 3, 1, 2, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 3, '\n                    '3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, '\n                    '3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], \"3_12\": [[], [1, 1, 4, 1, 1, 7]], \"18_22\": [['\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 15, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 3, 1, 3, 1, '\n                    '3, 1, 3, 1, 1, 1, 1, 1, 7], [1, 3]], \"21_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 23]], \"8_19\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 1, 4, 1, 4, 1, 1, 3, 1, 1, 4, 1, '\n                    '4]], \"13_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14], [1, 1, 1, 6, 1, 1, 1, 1, 5, 1, 1, 1, 5, '\n                    '1, 1, 1, 6]], \"5_18\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3, 1, 2, 1, 3, 3]], '\n                    '\"8_16\": [[], [1, 1, 1, 1, 1, 1, 1, 17]], \"18_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 19]], \"1_19\": [[], [2]], \"5_15\": [[], [1, 1, 1, 1, 6]], \"1_6\": [[], [2, 2, 3]], '\n                    '\"11_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23]], \"17_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 19]], \"7_16\": [[1, 1, 1, 1, 1, 1, 8], [1, 3, 1, 4, 1, 1, 3, 1, 3, 1, 4]], '\n                    '\"3_3\": [[], [1, 1, 4]], \"15_16\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], '\n                    '\"5_11\": [[1, 1, 1, 1, 6], [2]], \"1_2\": [[], [3]], \"1_17\": [[], [2]], \"14_17\": [[1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 15, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 3, 3, 1, 2, 1, 2, 1, 1, '\n                    '1, 1, 1, 1, 1, 9, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 6], [3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, '\n                    '2, 1, 3, 3]], \"13_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6], [2]], \"1_8\": [[], [2, 2, 2, 3]], \"9_20\": [[1, '\n                    '1, 1, 1, 1, 1, 1, 1, 10], [1, 3, 1, 3, 3, 1, 2, 1, 3, 1, 3, 1, 3, 3]], \"8_22\": [[], [1, 1, 1, 1, '\n                    '1, 1, 1, 9, 1, 1, 1, 1, 1, 9]], \"7_17\": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 4, 2, 2, 2, 2, 1, 1, 4], '\n                    '[2]], \"17_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 1, 4, 1, 1, 3, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 13, 1, 4, 1, 4, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 4, 1, 4, '\n                    '1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 3, 1, 4]], \"12_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13], [1, 1, '\n                    '7, 1, 1, 1, 1, 1, 4, 1, 1, 4, 1, 1, 7]], \"5_19\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [2]], '\n                    '\"14_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 2, 3, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, '\n                    '2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 5], [2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3]], '\n                    '\"6_6\": [[], [1, 1, 1, 1, 1, 7]], \"7_11\": [[1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 1, 1, 4], [2]], '\n                    '\"2_10\": [[], [1, 3]], \"5_7\": [[1, 1, 1, 1, 6, 2, 2, 1, 1, 4], [2]], \"2_7\": [[], [1, 3, 1, 4]], '\n                    '\"10_13\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 1, 2, 1, 2, 1, 1, '\n                    '1, 5], [3, 3, 3, 1, 2, 1, 2, 1, 2, 2, 3]], \"12_12\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], '\n                    '\"4_15\": [[1, 1, 1, 5, 1, 1, 1, 5], [3, 1, 2, 2, 3, 1, 2, 2, 3]], \"9_14\": [[1, 1, 1, 1, 1, 1, 1, '\n                    '1, 10, 2, 3, 1, 2, 2, 1, 1, 1, 5], [2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 3]], \"11_15\": [[1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], '\n                    '\"15_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], \"3_14\": [[], [1, 1, 4, 1, 1, 4, '\n                    '1, 4]], \"7_18\": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 5, 3, 1, 2, 1, 1, 1, 5], [3, 1, 2, 2, 3, 3, 1, '\n                    '2, 1, 2, 2, 3]], \"2_13\": [[], [1, 3, 1, 3, 1, 3, 3]], \"10_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], '\n                    '[1, 3]], \"9_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 3, 3, 1, 2, 1, 3, 1, 3, 1, 3, 3]], '\n                    '\"8_18\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 3, 1, 5, 1, 1, 1, 3, 1, 3, 1, 5]], \"6_10\": [[1, 1, 1, 1, '\n                    '1, 7], [1, 3]], \"16_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 2, 3, 1, 2, 2, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 7], [2, 3, 2, 3, 2, 3, '\n                    '1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 3]], \"21_21\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 22]], \"12_16\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], \"10_19\": [[1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 11], [2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]], \"2_9\": [[], [1, 3, 1, 3, '\n                    '3]], \"1_18\": [[], [2, 2, 2, 2, 2, 2, 2, 2, 3]], \"8_9\": [[], [1, 1, 1, 1, 1, 1, 1, 10]], '\n                    '\"5_13\": [[1, 1, 1, 1, 6, 1, 1, 4, 2, 2, 1, 1, 4], [2]], \"4_10\": [[], [1, 1, 1, 5, 1, 5]], '\n                    '\"1_5\": [[], [2]], \"18_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], '\n                    '\"3_8\": [[], [1, 1, 4, 1, 4]], \"2_12\": [[], [1, 3, 1, 3, 1, 5]], \"2_21\": [[], [1, 3, 1, 3, 1, 3, '\n                    '1, 3, 1, 3, 3]], \"6_13\": [[1, 1, 1, 1, 1, 7], [2, 2, 3, 1, 2, 2, 2, 2, 3]], \"4_6\": [[], [1, 1, '\n                    '1, 7]], \"2_8\": [[], [1, 3, 1, 5]], \"12_13\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14]], '\n                    '\"5_10\": [[], [1, 1, 1, 1, 11]], \"3_4\": [[], [1, 1, 5]], \"10_11\": [[], [1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 12]], \"16_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 1, 5, 1, 1, 1, 3, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 11], [1, 5, 1, 5, 1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 5, 1, 5]], \"4_12\": [[], [1, '\n                    '1, 1, 5]], \"11_14\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 9, 3, 3, '\n                    '1, 2, 1, 2, 1, 1, 1, 1, 6], [3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 3, 3]], \"4_16\": [[], [1, 1, 1, 5, 1, '\n                    '1, 1, 9]], \"5_16\": [[], [1, 1, 1, 1, 6, 1, 1, 1, 1, 7]], \"5_17\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6, '\n                    '2, 2, 1, 1, 4, 2, 2, 1, 1, 4], [2]], \"10_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 3]], '\n                    '\"4_18\": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 5]], \"4_19\": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 1, 5]], '\n                    '\"8_8\": [[], [1, 1, 1, 1, 1, 1, 1, 9]], \"19_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 21]], \"3_20\": [[], [1, 1, 4, 1, 1, 4, 1, 1, 4, 1, 4]], \"5_14\": [[], [1, 1, 1, 1, 6, '\n                    '1, 1, 1, 6]], \"13_15\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 12, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], \"1_3\": [[], [2]], '\n                    '\"5_21\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [2]], \"1_20\": [[], [2, 2, 2, 2, 2, 2, 2, 2, 2, 3]], '\n                    '\"15_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 12, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, '\n                    '4], [2]], \"14_21\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22]], \"4_5\": [[], [1, 1, 1, 6]], '\n                    '\"3_21\": [[], [1, 1, 4]], \"4_9\": [[1, 1, 1, 5], [2, 3, 1, 2, 2, 3]], \"7_7\": [[], [1, 1, 1, 1, 1, '\n                    '1, 8]], \"11_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12], [1, 1, 5, 1, 1, 1, 4, 1, 1, 1, 5, 1, 1, '\n                    '5]], \"15_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 1, '\n                    '1, 1, 1, 9], [2, 2, 3, 2, 2, 3, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 3]], \"14_14\": [[], [1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], \"4_17\": [[1, 1, 1, 5, 1, 1, 1, 5], [2, 3, 1, 2, 2, 3, 1, 2, 2, '\n                    '3]], \"6_12\": [[], [1, 1, 1, 1, 1, 13]], \"1_1\": [[], [2]], \"19_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 2, 2, '\n                    '2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 2, 2, '\n                    '2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, '\n                    '2, 1, 1, 4], [2]], \"9_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 1, 4]], \"17_21\": [[1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, '\n                    '6], [2]], \"16_17\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18]], \"4_21\": [[], [1, 1, '\n                    '1, 5, 1, 1, 1, 5, 1, 1, 1, 6]], \"5_6\": [[], [1, 1, 1, 1, 7]], \"10_10\": [[], [1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 11]], \"8_15\": [[1, 1, 1, 1, 1, 1, 1, 9], [2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 3]], '\n                    '\"13_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 9], [1, '\n                    '4, 1, 4, 1, 1, 3, 1, 1, 3, 1, 1, 4, 1, 4]], \"20_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 23]], \"9_10\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 11]], \"2_19\": [[], [1, 3, 1, 3, '\n                    '1, 3, 1, 3, 1, 4]], \"6_22\": [[1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 7], [1, 3]], \"13_13\": [[], [1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14]], \"17_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '18, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 12, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 9, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, '\n                    '2, 1, 1, 1, 1, 6], [3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 3]], \"6_18\": [[], [1, 1, '\n                    '1, 1, 1, 7]], \"5_12\": [[1, 1, 1, 1, 6], [1, 3, 3, 1, 2, 1, 3, 3]], \"17_17\": [[], [1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18]], \"8_20\": [[], [1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 9]], '\n                    '\"11_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6], [2]], \"1_4\": [[], '\n                    '[2, 3]], \"3_11\": [[1, 1, 4, 1, 1, 4], [2]], \"3_9\": [[], [1, 1, 4]], \"7_14\": [[], [1, 1, 1, 1, 1, '\n                    '1, 15]], \"13_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 1, 1, '\n                    '7], [2, 2, 3, 2, 2, 3, 1, 2, 2, 2, 1, 2, 2, 2, 2, 3]], \"8_13\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 4, '\n                    '1, 1, 3, 1, 1, 4, 1, 4]], \"9_13\": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 1, 1, 1, 1, 6], '\n                    '[2]], \"11_13\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, '\n                    '1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], '\n                    '\"9_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 5, 2, 3, 1, 2, 2, 1, 1, 1, 5], [2, 3, 1, 2, 2, 3, '\n                    '2, 3, 1, 2, 2, 1, 2, 2, 3]], \"6_21\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 10]], \"12_14\": [[], '\n                    '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], \"3_7\": [[1, 1, 4], [2]], \"14_20\": [[1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 15, 1, 5, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 9], [1, 5, 1, 5, 1, 1, 1, 3, 1, 1, '\n                    '1, 3, 1, 3, 1, 5]], \"9_11\": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, '\n                    '1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], \"12_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '13], [1, 3, 1, 5, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 5]], \"5_20\": [[], [1, 1, 1, 1, 6, 1, 1, 1, 1, '\n                    '11]], \"1_16\": [[], [2, 2, 2, 2, 2, 2, 2, 3]], \"7_12\": [[1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 1, 3, 1, '\n                    '3, 1, 4]], \"12_15\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16]], \"7_9\": [[1, 1, 1, 1, 1, 1, 8, '\n                    '2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 1, 1, 4], [2]], \"15_15\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 16]], \"5_5\": [[], [1, 1, 1, 1, 6]], \"9_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [2]], '\n                    '\"8_11\": [[1, 1, 1, 1, 1, 1, 1, 9, 3, 1, 2, 1, 1, 1, 1, 6], [3, 3, 1, 2, 1, 2, 1, 3, 3]], '\n                    '\"2_3\": [[], [1, 4]], \"7_10\": [[1, 1, 1, 1, 1, 1, 8, 3, 1, 2, 1, 1, 1, 5], [3, 3, 1, 2, 1, 2, 2, '\n                    '3]], \"8_14\": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 5, 1, 1, 1, 3, 1, 3, 1, 5]], \"11_11\": [[], [1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 12]], \"2_11\": [[], [1, 3, 1, 3, 1, 4]], \"2_15\": [[], [1, 3, 1, 3, 1, 3, 1, '\n                    '4]], \"10_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [2, 2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]], '\n                    '\"10_12\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], \"13_21\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '14, 1, 1, 4, 2, 2, 1, 1, 4, 1, 1, 1, 1, 6, 1, 1, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], '\n                    '[2]], \"12_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 1, 3, 3, 1, 2, 1, 3, 1, 1, 1, 1, 6], [1, '\n                    '3, 3, 1, 3, 3, 1, 2, 1, 3, 1, 2, 1, 3, 3]], \"9_9\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 10]], '\n                    '\"3_18\": [[], [1, 1, 4, 1, 1, 4, 1, 1, 7]], \"14_15\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '16]], \"14_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, '\n                    '1, 7], [1, 3]], \"13_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 11, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, 3, '\n                    '3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], \"6_8\": [[], [1, 1, 1, 1, 1, 9]], \"3_16\": [[], [1, 1, 4, 1, '\n                    '1, 4, 1, 1, 5]], \"2_6\": [[], [1, 3]], \"20_21\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 22]], \"6_7\": [[], [1, 1, 1, 1, 1, 8]], \"2_4\": [[], [1, 5]], \"9_12\": [[], [1, 1, '\n                    '1, 1, 1, 1, 1, 1, 13]], \"8_12\": [[], [1, 1, 1, 1, 1, 1, 1, 13]], \"8_10\": [[], [1, 1, 1, 1, 1, 1, '\n                    '1, 11]], \"15_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 14, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, '\n                    '1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], \"2_17\": [[], [1, 3, 1, 3, 1, 3, 1, 3, '\n                    '3]], \"16_16\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], \"1_22\": [[], [2, 2, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 3]], \"4_11\": [[], [1, 1, 1, 5, 1, 1, 5]], \"4_4\": [[], [1, 1, 1, 5]], '\n                    '\"11_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 3, 1, 2, 2, 1, 1, 1, 1, 1, 7], [2, 3, 2, 3, 1, '\n                    '2, 2, 1, 2, 2, 2, 2, 3]], \"2_18\": [[], [1, 3]], \"6_16\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 7]], '\n                    '\"2_14\": [[], [1, 3]], \"7_13\": [[1, 1, 1, 1, 1, 1, 8], [2]], \"3_22\": [[], [1, 1, 4, 1, 1, 4, 1, '\n                    '1, 4, 1, 1, 5]], \"19_19\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20]], '\n                    '\"8_17\": [[1, 1, 1, 1, 1, 1, 1, 9], [2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 3]], \"2_5\": [[], [1, 3, '\n                    '3]], \"19_22\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 3, 1, 2, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, '\n                    '3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, '\n                    '1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, 3, 3, 3, 3, 3, '\n                    '1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], \"10_16\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 5, 1, '\n                    '1, 1, 3, 1, 1, 1, 5, 1, 5]], \"22_22\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 23]], \"4_13\": [[], [1, 1, 1, 5, 1, 1, 1, 6]], \"7_20\": [[], [1, 1, 1, 1, 1, 1, 8, 1, '\n                    '1, 1, 1, 1, 8]], \"5_22\": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [1, 3, 3, 1, 2, 1, 3, 3, 1, 2, 1, 3, '\n                    '3]], \"16_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], \"13_14\": [[], [1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], \"5_8\": [[1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3]], \"1_11\": [[], '\n                    '[2]], \"7_21\": [[], [1, 1, 1, 1, 1, 1, 8]], \"11_12\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], '\n                    '\"12_18\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], \"7_19\": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, '\n                    '6, 2, 2, 1, 1, 1, 1, 6, 2, 2, 1, 1, 4, 2, 2, 2, 2, 1, 1, 4], [2]], \"7_8\": [[], [1, 1, 1, 1, 1, '\n                    '1, 9]], \"10_17\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 1, 5, 1, 1, 1, 4, 1, 1, 4, 1, 1, 5]], '\n                    '\"6_20\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 9]], \"3_19\": [[1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], '\n                    '\"11_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 4, 2, 2, 1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], '\n                    '\"6_17\": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 7]], \"20_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 21]], \"4_8\": [[], [1, 1, 1, 9]], \"8_21\": [[1, 1, 1, 1, 1, 1, 1, 9, 1, 1, '\n                    '1, 1, 6, 3, 1, 2, 1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3]], \"12_17\": [[1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 4, 1, 1, 3, 1, 1, '\n                    '3, 1, 3, 1, 4]], \"2_20\": [[], [1, 3, 1, 3, 1, 3, 1, 3, 1, 5]], \"1_9\": [[], [2]], \"14_16\": [[], '\n                    '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], \"4_20\": [[], [1, 1, 1, 5]], \"2_16\": [[], [1, 3, 1, '\n                    '3, 1, 3, 1, 5]], \"1_14\": [[], [2, 2, 2, 2, 2, 2, 3]], \"1_21\": [[], [2]], \"13_19\": [[1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8], [2]], \"7_15\": [[1, 1, 1, 1, '\n                    '1, 1, 8], [2]], \"5_9\": [[1, 1, 1, 1, 6], [2]], \"4_7\": [[1, 1, 1, 5], [3, 1, 2, 2, 3]], '\n                    '\"4_14\": [[], [1, 1, 1, 5, 1, 1, 1, 7]], \"3_5\": [[1, 1, 4], [2]], \"9_15\": [[1, 1, 1, 1, 1, 1, 1, '\n                    '1, 10], [1, 1, 4]], \"6_14\": [[1, 1, 1, 1, 1, 7], [1, 3]], \"14_18\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 15, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, '\n                    '1, 7], [1, 3]], \"12_20\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13], [1, 1, 1, 5]], \"1_13\": [[], '\n                    '[2]], \"4_22\": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 1, 1, 7]], \"16_20\": [[], [1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 1, 21]], \"1_7\": [[], [2]], \"17_19\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 18, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, '\n                    '1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 2, '\n                    '2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, '\n                    '2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]]}')\n\nn, x, y = map(int, input().split())\nn -= 1\nif x > y:\n    x, y = y, x\nprefix = extract_list(answer[str(x) + '_' + str(y)][0])\npattern = extract_list(answer[str(x) + '_' + str(y)][1], prefix[-1] + 1 if prefix else 1)\nif n < len(prefix):\n    print(prefix[n])\nelse:\n    n -= len(prefix)\n    print(n // len(pattern) * (pattern[-1] - pattern[0] + 1) + pattern[n % len(pattern)])\n", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "def bs(l, h):\n    while l < h:\n        m = (l + h) // 2\n        if gf(m):\n            h = m\n        else:\n            l = m + 1\n    return l\n\ndef gf(x):\n    d = {}\n    for i in range(x):\n        if s[i] in d:\n            d[s[i]] += 1\n        else:\n            d[s[i]] = 1\n    if len(d) == len(u):\n        return 1\n    for i in range(x, n):\n        if s[i] in d:\n            d[s[i]] += 1\n        else:\n            d[s[i]] = 1\n        d[s[i - x]] -= 1\n        if not d[s[i - x]]:\n            del d[s[i - x]]\n        if len(d) == len(u):\n            return 1\n    return 0\n\nn = int(input())\ns = input()\nu = set([*s])\nprint(bs(1, n))", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------- fast io --------------------\nfrom math import gcd, ceil\n\ndef prod(a, mod=10**9+7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\nfor _ in range(int(input()) if not True else 1):\n    n = int(input())\n    #n, k = map(int, input().split())\n    #a, b = map(int, input().split())\n    #c, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    #b = list(map(int, input().split()))\n    #s = input()\n    mod =  10**9 + 7\n    twopow = [1]*(10**5+69)\n    for i in range(1, 10**5+69):\n        twopow[i] = (twopow[i-1] * 2) % mod\n    count = [0]*100069\n    for i in a:\n        count[i] += 1\n    multiples = [0]*100069\n    for i in range(1, 10**5+1):\n        for j in range(i, 10**5+1, i):\n            multiples[i] += count[j]\n    gcd_of = [0]*100069\n    for i in range(10**5, 0, -1):\n        gcd_of[i] = (twopow[multiples[i]] - 1) % mod\n        for j in range(2*i, 10**5+1, i):\n            gcd_of[i] -= gcd_of[j]\n    print(gcd_of[1] % mod)", "complexity": "np", "problem": "0803_F", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,number theory"}
{"src": "MAX = 100001\nparent = []\n\ndef makeSet():\n    global parent\n    parent = [i for i in range(MAX + 1)]\n\ndef findSet(u):\n    global parent\n    if u != parent[u]:\n        parent[u] = findSet(parent[u])\n    return parent[u]\n\ndef unionSet(u, v):\n    up = findSet(u)\n    vp = findSet(v)\n    parent[up] = vp\n\nmakeSet()\nn, a, b = map(int, input().split())\np = list(map(int, input().split()))\npos = dict()\nfor i in range(n):\n    pos[p[i]] = i + 1\n\nfor i in range(n):\n    unionSet(i + 1, pos.get(a - p[i], n + 1))\n    unionSet(i + 1, pos.get(b - p[i], 0))\n\nA = findSet(0)\nB = findSet(n + 1)\n\nif A != B:\n    print('YES')\n    for i in range(1, n + 1):\n        if findSet(i) == B:\n            print('1', end = \" \")\n        else:\n            print('0', end = \" \")\nelse:\n    print('NO')\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "M = 10 ** 9 + 7\nx, k = map(int, input().split())\nif x == 0: print(0); exit(0)\nP = pow(2, k, M)\nr = (P * x) % M - (0.5 * (-1 + P)) % M\nprint(int((2 * r + M) % M))\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "#n, m = map(int, input().split())\n#x = int(input())\nn, m = map(int, input().split())\nans = m // n + min(1, m % n)\nprint(ans)", "complexity": "constant", "problem": "1061_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "k=int(input())\n\ns=0\ni=1\nwhile  (s +  i * ( 9 * pow ( 10,i-1)) ) < k :\n    s +=  i * (9 * pow(10, i - 1))\n    i+=1\nelse:\n    i-=1\n\nk=k-s-1\nx= k // (i+1)\ny= k %(i+1)\nx= pow(10,i)+x\nss=str(x)\nprint(ss[y])\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "n = int(input())\n\nmult = 1\nres = []\nremain = n\nwhile remain >0:\n    if remain == 2:\n        res.extend([mult, mult*2])\n        remain = 0\n    elif remain == 3:\n        res.extend([mult, mult, mult *3])\n        remain = 0\n    else:\n        half = remain // 2\n        extra = remain - half\n        res.extend([mult]*extra)\n        remain  = half\n        mult = mult *2\nprint(*res)\n    \n", "complexity": "logn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "# for #!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\nclass union_find:\n    def __init__(self, n):\n        self.n = n\n        self.rank = [0]*n\n        self.parent = [int(j) for j in range(n)]\n    \n    def union(self,i,j):\n        i = self.find(i)\n        j = self.find(j)\n        if self.rank[i] == self.rank[j]:\n            self.parent[i] = j\n            self.rank[j] += 1\n\n        elif self.rank[i] > self.rank[j]:\n            self.parent[j] = i\n        else:\n            self.parent[i] = j\n\n    def find(self, i):\n        temp = i\n        if self.parent[temp] != temp:\n            self.parent[temp] = self.find(self.parent[temp])\n        return self.parent[temp]\nfrom math import log2, ceil\nfrom collections import deque, Counter as CC, defaultdict as dd\ndef main():\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n    # for t in range(int(input())):\n        \n        # n = int(input())\n        p,q,r  = [int(j) for j in input().split()]\n        a = [int(j) for j in input().split()]\n        b = [int(j) for j in input().split()]\n        c = [int(j) for j in input().split()]\n        a.sort()\n        b.sort()\n        c.sort()\n        l = [a,b,c]\n\n        dp = [[[0 for i in range(r+1)] for j in range(q+1)] for k in range(p+1)]\n        for i in range(p+1):\n            for j in range(q+1):\n                for k in range(r+1):\n                    s = [i-1,j-1,k-1]\n                    for u in range(3):\n                        \n                        s[u]+=1\n                        try:\n                            tmp = dp[s[0]][s[1]][s[2]]\n                        except:\n                            s[u]-=1\n                            continue\n                        tmp2 = 1\n                        flag =True\n                        for t in range(3):\n                            if(u!=t):\n                                if(s[t]==-1):\n                                    flag = False\n                                    break\n                                tmp2 *= l[t][s[t]] \n                        tmp += tmp2\n                        s[u]-=1\n                        if(flag):\n                            dp[i][j][k] = max(dp[i][j][k], tmp)\n        print(dp[p][q][r])\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n,k = map(int,input().split())\ns = input()\nc=0\nfor i in range(len(s)):\n\tif s[:i]==s[-i:]:\n\t\tc=i\nprint(s+s[c:]*(k-1))", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\na = li()\nb = [abs(x) for x in a] \nif n == 1:\n    ans = a[0]\nelif all(x > 0 for x in a) or all(x < 0 for x in a):\n    b.sort()\n    ans = sum(b) - 2 * b[0]\nelse:\n    ans = sum(b)\nprint(ans)\n", "complexity": "nlogn", "problem": "1038_D", "from": "CODEFORCES", "tags": "dp,greedy,implementation"}
{"src": "n, m=[int(k) for k in input().split()]\nres=[]\nfor j in range(n//2):\n    for k in range(m):\n        res.append(str(j+1)+\" \"+str(k+1))\n        res.append(str(n-j)+\" \"+str(m-k))\nif n%2:\n    for j in range(m//2):\n        res.append(f\"{n//2+1} {j+1}\")\n        res.append(f\"{n//2+1} {m-j}\")\n    if m%2:\n        res.append(f\"{n//2+1} {m//2+1}\")\nprint(\"\\n\".join(res))", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nn,m = map(int, input().split())\na = []\nfor i in range(n):\n    ai = list(map(int, input().split()))\n    a.append(ai)\n\ndef check(mid):\n    mask = (1<<m)-1\n    s = set()\n    d = dict()\n    for i in range(n):\n        state = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                state += 1<<j\n        if state in s:\n            continue\n        s.add(state)\n        k = state\n        while k>=0:\n            k &= state\n            d[k] = i\n            k -= 1\n        need = mask^state\n        if need in d:\n            q1, q2 = d[need], i\n            if q1 > q2:\n                q1, q2 = q2, q1\n            return True, (q1, q2)\n    return False, (-1, -1)\n\nleft = 0\nright = 10**9+1\ni,j = 0, 0\nwhile right-left>1:\n    mid = (right+left)//2\n    flag, (q1, q2) = check(mid)\n    if flag:\n        left = mid\n        i,j = q1, q2\n    else:\n        right = mid\nprint(i+1, j+1)\n\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\ns = input()[:-1]\nleft, right = 0, n\nwhile left < right:\n    mid = right - (right - left) // 2\n    A = [[0] * (n + 2) for _ in range(k)]\n\n    for c in range(k):\n        A[c][n] = A[c][n + 1] = n + 1\n        L = 0\n        for i in range(n - 1, -1, -1):\n            if s[i] == '?' or ord(s[i]) - ord('a') == c: L += 1\n            else: L = 0\n            A[c][i] = i + mid if L >= mid else A[c][i + 1]\n\n    dp = [n + 1] * (1 << k)\n    dp[0] = 0\n    for mask in range(1 << k):\n        for i in range(k):\n            if mask >> k & 1: continue\n            t = mask | 1 << i\n            dp[t] = min(dp[t], A[i][dp[mask]])\n    if dp[-1] <= n: left = mid\n    else: right = mid - 1\nprint(left)", "complexity": "np", "problem": "1550_E", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,strings,two pointers"}
{"src": "a = int(input())\nc = [1] * 30\nfor i in range (1,20):\n\tc[i] = 9 * i * pow(10,i-1)\nfor i in range (1,15):\n\tif (a > c[i]):\n\t\ta -= c[i]\n\telse:\n\t\td = int((a-1) / i + pow(10,i-1) - 1)\n\t\te = (a-1) % i + 1\n\t\tf = str(d+1)\n\t\tprint(f[e-1])\n\t\texit()", "complexity": "constant", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "## necessary imports\nimport sys\ninput = sys.stdin.readline\nfrom math import ceil, floor, factorial;\n\n# swap_array function\ndef swaparr(arr, a,b):\n    temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp\n\n## gcd function\ndef gcd(a,b):\n    if a == 0:\n        return b\n    return gcd(b%a, a)\n\n## nCr function efficient using Binomial Cofficient\ndef nCr(n, k): \n    if(k > n - k): \n        k = n - k \n    res = 1\n    for i in range(k): \n        res = res * (n - i) \n        res = res / (i + 1) \n    return int(res) \n\n## upper bound function code -- such that e in a[:i] e < x;\ndef upper_bound(a, x, lo=0):\n    hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x:\n            lo = mid+1\n        else:\n            hi = mid\n    return lo\n\n## prime factorization\ndef primefs(n):\n    ## if n == 1    ## calculating primes\n    primes = {}\n    while(n%2 == 0):\n        primes[2] = primes.get(2, 0) + 1\n        n = n//2\n    for i in range(3, int(n**0.5)+2, 2):\n        while(n%i == 0):\n            primes[i] = primes.get(i, 0) + 1\n            n = n//i\n    if n > 2:\n        primes[n] = primes.get(n, 0) + 1\n    ## prime factoriazation of n is stored in dictionary\n    ## primes and can be accesed. O(sqrt n)\n    return primes\n\n## MODULAR EXPONENTIATION FUNCTION\ndef power(x, y, p): \n    res = 1\n    x = x % p  \n    if (x == 0) : \n        return 0\n    while (y > 0) : \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n        y = y >> 1      \n        x = (x * x) % p \n    return res \n\n## DISJOINT SET UNINON FUNCTIONS\ndef swap(a,b):\n    temp = a\n    a = b\n    b = temp\n    return a,b\n\n# find function with path compression included (recursive)\n# def find(x, link):\n#     if link[x] == x:\n#         return x\n#     link[x] = find(link[x], link);\n#     return link[x];\n\n# find function with path compression (ITERATIVE)\ndef find(x, link):\n    p = x;\n    while( p != link[p]):\n        p = link[p];\n    \n    while( x != p):\n        nex = link[x];\n        link[x] = p;\n        x = nex;\n    return p;\n\n\n# the union function which makes union(x,y)\n# of two nodes x and y\ndef union(x, y, link, size):\n    x = find(x, link)\n    y = find(y, link)\n    if size[x] < size[y]:\n        x,y = swap(x,y)\n    if x != y:\n        size[x] += size[y]\n        link[y] = x\n\n## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES\ndef sieve(n): \n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n#### PRIME FACTORIZATION IN O(log n) using Sieve ####\nMAXN = int(1e6 + 5)\ndef spf_sieve():\n    spf[1] = 1;\n    for i in range(2, MAXN):\n        spf[i] = i;\n    for i in range(4, MAXN, 2):\n        spf[i] = 2;\n    for i in range(3, ceil(MAXN ** 0.5), 2):\n        if spf[i] == i:\n            for j in range(i*i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i;\n    ## function for storing smallest prime factors (spf) in the array\n\n################## un-comment below 2 lines when using factorization #################\n# spf = [0 for i in range(MAXN)]\n# spf_sieve() \ndef factoriazation(x):\n    ret = {};\n    while x != 1:\n        ret[spf[x]] = ret.get(spf[x], 0) + 1;\n        x = x//spf[x]\n    return ret\n    ## this function is useful for multiple queries only, o/w use\n    ## primefs function above. complexity O(log n)\n\n## taking integer array input\ndef int_array():\n    return list(map(int, input().strip().split()))\n## taking string array input\ndef str_array():\n    return input().strip().split();\n\n#defining a couple constants\nMOD = int(1e9)+7;\nCMOD = 998244353;\nINF = float('inf'); NINF = -float('inf');\n\n################### ---------------- TEMPLATE ENDS HERE ---------------- ###################\n\nn, l, r, x = int_array(); a = sorted(int_array());\nans = 0;\nfor mask in range( 1 << n):\n    mx = NINF; mn = INF; sub = 0;\n    for i in range(n):\n        if (1 << i) & mask:\n            sub += a[i];\n            mx = max(mx, a[i]);\n            mn = min(mn, a[i]);\n    if sub >= l and sub <= r:\n        if mx - mn >= x:\n            ans += 1;\nprint(ans);", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "a, b = [int(x) for x in input().split(' ')]\nidx = 0\nif(a == b):\n    print(0)\nelse:\n    for i in range(63,-1,-1):\n        set1 = (a >> i) & 1\n        set2 = (b >> i) & 1\n        if(set1!=set2):\n            idx = i\n            break\n    print((1<<(idx+1))-1)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import math\n\nif __name__ == '__main__':\n    n, m, k, l = map(int, input().split())\n    one_friend = (k + l) // m + int((k + l) % m != 0)\n    if one_friend * m > n:\n        print(-1)\n    else:\n        print(one_friend)\n", "complexity": "constant", "problem": "1068_A", "from": "CODEFORCES", "tags": "math"}
{"src": "def getsum(a, b):\n    if a % 2 == 0:\n        return (a + b) * ((b - a) // 2 + 1) // 2\n    else:\n        return -(a + b) * ((b - a) // 2 + 1) // 2\n\nq = int(input())\nfor i in range(q):\n    l, r = map(int, input().split())\n    if l == r:\n        print(l if l % 2 == 0 else -l)\n    else:\n        print(\n            getsum(l if l % 2 == 1 else l + 1, r if r % 2 == 1 else r - 1) + \n            getsum(l if l % 2 == 0 else l + 1, r if r % 2 == 0 else r - 1)\n        )", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "n,s = map(int,input().split())\nif s>=n:\n    print('0')\nelse:\n    for i in range(s,n+2):\n        l=0\n        for j in str(i):\n            l+=int(j)\n        if i-l>=s:\n            break\n    print(n-i+1)", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "n, A, C = list(map(int, input().split()))\n\ndef Ro(x, y):\n    return A * x - y + C\n \nhuh = []\n \nfor i in range(n):\n    z, x, y = list(map(int, input().split()))\n    huh.append((Ro(x + z, z * A + y), x))\nhuh = sorted(huh)\nanss = 0\nc1 = 0\nc2 = 0\nprev = (-9999999999999, -999999999999999)\ng = []\n\nhuh.append((-9999999999999, -999999999999999))\n#print(huh)\nfor huhh in huh:\n    if huhh[0] != prev[0]:\n        g.append(c1)\n        #print(g)\n        for j in g:\n            anss += (c2 - j) * j\n        g = []\n        c1 = 1\n        c2 = 1\n        prev = (huhh[0], huhh[1])\n        continue\n    c2 += 1\n    if huhh[1] != prev[1]:\n        g.append(c1)\n        c1 = 0\n        prev = (huhh[0], huhh[1])\n    c1 += 1\nprint(anss)\n    ", "complexity": "linear", "problem": "0975_D", "from": "CODEFORCES", "tags": "geometry,math"}
{"src": "n = int(input())\na = list(map(int, input().split()))\n\nmax_mod = 0\nmax_i = -1\nfor i in range(n):\n\tif a[i] >= 0:\n\t\ta[i] = -a[i] - 1\n\tif -a[i] > max_mod:\n\t\tmax_mod = -a[i]\n\t\tmax_i = i\n\nif n % 2 == 1:\n\ta[max_i] = -a[max_i] - 1\n\nprint(' '.join(list(map(str, a))))\n", "complexity": "linear", "problem": "1180_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import math\nres = [0, 1, 0, 3, 0, 15, 0, 133, 0, 2025, 0, 37851, 0, 1030367, 0, 36362925, 0]\nn = int(input())\nprint(res[n] * math.factorial(n) % (10 ** 9 + 7))\n\n  \t   \t\t\t\t\t\t \t  \t\t\t\t \t  \t\t\t\t\t\t", "complexity": "np", "problem": "0285_D", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,implementation,meet-in-the-middle"}
{"src": "import os, sys\nfrom io import BytesIO, IOBase\nfrom copy import deepcopy\n\n\ndef main():\n    n = rint()\n    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []\n    for i in range(4):\n        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])\n    print(['No', 'Yes'][a2.mat in ans])\n\n\nclass Matrix:\n    def __init__(self, r, c, mat=None, id=None):\n        self.r, self.c = r, c\n\n        if mat != None:\n            self.mat = deepcopy(mat)\n        else:\n            self.mat = [[0 for i in range(c)] for j in range(r)]\n\n    def __add__(self, other):\n        mat0 = Matrix(self.r, self.c)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]\n\n        return mat0\n\n    def __mul__(self, other):\n        mat0 = Matrix(self.r, other.c)\n\n        for i in range(self.r):\n            for j in range(other.c):\n                for k in range(self.c):\n                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]\n\n        return mat0\n\n    def dot_mul(self, other):\n        res = 0\n        for i in range(self.r):\n            for j in range(self.c):\n                res += self.mat[i][j] * other.mat[j][i]\n\n        return res\n\n    def trace(self):\n        res = 0\n        for i in range(self.r):\n            res += self.mat[i][i]\n\n        return res\n\n    def rotate(self):\n        mat0 = Matrix(self.c, self.r)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]\n\n        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r\n        return self.mat\n\n    def flipv(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def fliph(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def mat_pow(self, mat, p, mod=None):\n        sq = Matrix(mat.r, mat.r, id=1)\n\n        while p:\n            if p & 1:\n                p -= 1\n                sq = sq * mat\n\n            p //= 2\n            mat = mat * mat\n\n        return sq.mat\n\n\n# FASTIO REGION\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [list(rstr()) for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\nif __name__ == '__main__':\n    main()\n", "complexity": "quadratic", "problem": "0958_A1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\nmod = 998244353\na.sort()\ndp = [1] + [0] * n\nfor i in range(1, n + 1):\n    x, pt = 1, i - 2\n    while pt >= 0 and 2 * a[pt] > a[i - 1]:\n        x = x * (n - pt - 2) % mod\n        pt -= 1\n    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod\nprint(dp[-1])", "complexity": "cubic", "problem": "1437_F", "from": "CODEFORCES", "tags": "combinatorics,dp,math,two pointers"}
{"src": "def solve(n, k):\n\n\tif n >= 60:\n\t\treturn \"YES \" + str(n - 1)\n\n\tmxxx = (4 ** n - 1) // 3\n\t\n\tif k > mxxx:\n\t\treturn 'NO'\n\n\tmn, mx = 0, 0\n\n\tfor i in range(n):\n\t\tmn += 2 ** (i + 1) - 1\n\t\tmx += 4 ** i\n\t\tif mn <= k and mx >= k:\n\t\t\treturn \"YES \" + str(n - i - 1)\n\t\t# print(mn, mx)\n\n\tif k >= 22 and k <= 25:\n\t\treturn 'YES ' + str(n - 3) # OK\n\n\tif k == 2: # OK\n\t\tif n >= 2:\n\t\t\treturn 'YES ' + str(n - 1)\n\t\treturn 'NO'\n\t\n\tif k == 3: # OK\n\t\tif n <= 2:\n\t\t\treturn 'NO'\n\t\treturn 'YES ' + str(n - 1)\n\n\tif k >= 6 and k <= 10: #OK\n\t\treturn 'YES ' + str(n - 2)\n\nt = int(input())\n\nfor i in range(t):\n\tn, k = map(int, input().split())\n\tprint(solve(n, k))\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "from itertools import combinations\ndef out1(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==1 and b==0 and c==0:\n        return 1\n    return a*(out2(a-1,b,c)+out3(a-1,b,c))\ndef out2(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==1 and c==0:\n        return 1\n    return b*(out1(a,b-1,c)+out3(a,b-1,c))\ndef out3(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==0 and c==1:\n        return 1\n    return c*(out2(a,b,c-1)+out1(a,b,c-1))\ndef column(matrix, i):\n    return [row[i] for row in matrix]\n    \nN, T = [int(x) for x in input().split()]\nA = []\ns = 0\nfor i in range(N):\n    A.append([int(x) for x in input().split()])\nfor i in range(1,N+1):\n    comb = list(combinations(A, i))\n    for x in comb:\n        if sum(column(x,0))==T:\n            a = column(x,1).count(1)\n            b = column(x,1).count(2)\n            c = column(x,1).count(3)\n            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))\nprint(s%1000000007)", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "t = int(input())\ndef maxsa(A):\n    ans = 0\n    #print(\"asdasd\")\n    for i in range(n):\n        cur_maxx = 0\n        for j in range(4):\n            cur_maxx = max(cur_maxx, A[j][i])\n        ans+= cur_maxx\n    return ans\n\ndef fu(A):\n    answer = 0\n    for j in range(n):\n        A[0] = A[0][1:] + A[0][:1]\n        for i in range(n):\n            A[1] = A[1][1:] + A[1][:1]\n            for k in range(n):\n                A[2] = A[2][1:] + A[2][:1]\n                for l in range(n):\n                    A[3] = A[3][1:] + A[3][:1]\n                    #print(A)\n                    cur_ans = maxsa(A)\n                    answer = max(answer, cur_ans)\n    return answer\n\n\nfor j in range(t):\n    n,m = map(int,input().split())\n    A = [0] * n\n    inds = [-1,-1,-1,-1]\n    maxs  =[ 0,0,0,0]\n    for j in range(n):\n        A[j] = list(map(int,input().split()))\n    for j in range(m):\n        cur_maxs = 0\n        for i in range(n):\n            cur_maxs = max(cur_maxs, A[i][j])\n        maxs.append(cur_maxs)\n        inds.append(j)\n        ind  = 4\n        #print(cur_maxs)\n        while ind !=0 and maxs[ind] > maxs[ind-1]:\n            inds[ind], inds[ind-1] = inds[ind-1] , inds[ind]\n            maxs[ind], maxs[ind - 1] = maxs[ind - 1], maxs[ind]\n            ind-=1\n        maxs.pop()\n        inds.pop()\n\n\n    #print(maxs)\n    #print(inds)\n    S = [0] * 4\n    for j in range(4):\n        if inds[j] != -1:\n            #print(A)\n            #print(inds[j])\n            S[j] = [s[inds[j]] for s in A]\n            #print(S[j])\n        else:\n            S[j] = [0] * n\n    #print(S)\n    print(fu(S))", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "yellow, blue = map(int, input().split())\nx, y, z = map(int, input().split())\nanswer1 = x*2+y-yellow\nanswer2 = z*3+y - blue\nif answer1 > 0:\n    if answer2 > 0:\n        print(answer1+answer2)\n    else:\n        print(answer1)\nelse:\n    if answer2 > 0:\n        print(answer2)\n    else:\n        print(0)\n", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "#476B\nfrom math import factorial as fact\ns=input()\nt=input()\npos=s.count('+')-t.count('+')\nneg=s.count('-')-t.count('-')\nque=t.count('?')\nif pos<0 or neg<0:\n    print(0)\nelse:\n    print((fact(que)/(fact(pos)*fact(neg)))/(2**que))", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nchet = 0\nne_chet = 0\nchet1 = []\nne_chet1 = []\nfor i in range(len(a)):\n    if a[i] % 2 == 0:\n        chet += 1\n        chet1.append(a[i])\n    else:\n        ne_chet += 1\n        ne_chet1.append(a[i])\n    if chet >= 1 and ne_chet >= 1 and (chet > 1 or ne_chet > 1):\n        break\nif chet == 1:\n    print(a.index(chet1[0]) + 1)\nelif ne_chet == 1:\n    print(a.index(ne_chet1[0]) + 1)\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "from collections import deque\nfrom sys import stdin, stderr\nlines = deque(line.strip() for line in stdin.readlines())\n\ndef nextline():\n    return lines.popleft()\n\ndef types(cast, sep=None):\n    return tuple(cast(x) for x in strs(sep=sep))\n\ndef ints(sep=None):\n    return types(int, sep=sep)\n\ndef strs(sep=None):\n    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))\n\ndef signum(n):\n    return 1 if n > 0 else 0 if n == 0 else -1\n\ndef range_includes(i, j):\n    s = signum(j - i)\n    return range(i, j + s, s)\n\ndef main():\n    # lines will now contain all of the input's lines in a list\n    first = ints()\n    aCoords = tuple(first[i:i+2] for i in range(0, 8, 2))\n    minX = min(aCoord[0] for aCoord in aCoords)\n    minY = min(aCoord[1] for aCoord in aCoords)\n    maxX = max(aCoord[0] for aCoord in aCoords)\n    maxY = max(aCoord[1] for aCoord in aCoords)\n    def inFirst(x, y):\n        return x >= minX and x <= maxX and y >= minY and y <= maxY\n\n    second = ints()\n    bCoords = tuple(second[i:i+2] for i in range(0, 8, 2))\n    minSum = min(sum(bCoord) for bCoord in bCoords)\n    maxSum = max(sum(bCoord) for bCoord in bCoords)\n    minDiff = min(bCoord[0] - bCoord[1] for bCoord in bCoords)\n    maxDiff = max(bCoord[0] - bCoord[1] for bCoord in bCoords)\n    def inSecond(x, y):\n        return x + y >= minSum and x + y <= maxSum and x - y >= minDiff and x - y <= maxDiff\n\n    for aCoord in aCoords:\n        if inSecond(*aCoord):\n            return True\n    for i in range(-1, 3):\n        c1 = bCoords[i]\n        c2 = bCoords[i + 1]\n        for x, y in zip(range_includes(c1[0], c2[0]), range_includes(c1[1], c2[1])):\n            if inFirst(x, y):\n                return True\n    return False\n\nif __name__ == '__main__':\n    print(\"YES\" if main() else \"NO\")\n", "complexity": "constant", "problem": "0994_C", "from": "CODEFORCES", "tags": "brute force"}
{"src": "from sys import stdout\nm = 30\na, b = 0, 0\nfle = 1\nfor i in range(m):\n    if fle:\n        print('? {} {}'.format(a, b))\n        stdout.flush()\n        resp1 = int(raw_input())\n        fle = 0\n    print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i)))\n    stdout.flush()\n    resp2 = int(raw_input())\n    #print(resp1,resp2,a,b)\n    if resp1 == -1 and resp2 == 1:\n        b += 2**(m-1-i)\n        fle = 1\n    elif resp1 == 1 and resp2 == -1:\n        a += 2**(m-1-i)\n        fle = 1\n    else:\n        fle = 0\n        print('? {} {}'.format(a + 2**(m-1-i), b))\n        stdout.flush()\n        resp3 = int(raw_input())\n        if resp3 == -1:\n            b += 2**(m-1-i)\n            a += 2**(m-1-i)\n        #print(resp1,resp2,resp3,a,b)\nprint('! {} {}'.format(a,b))\nstdout.flush()", "complexity": "logn", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "import sys\ninput=sys.stdin.buffer.readline\nn,k=map(int,input().split())\narr=list(map(int,input().split()))\nd=[{} for i in range(11)]\nfor i in range(n):\n    st=arr[i]\n    for j in range(11):\n        r=st % k\n        try:\n            d[j][r]+=1\n        except KeyError:\n            d[j][r] =1\n        st*=10\ncount_pair=0\nfor i in arr:\n    st=str(i)\n    l=len(st)\n    mod_st=(k-(i % k)) %k\n    if mod_st in d[l]:\n        count_pair +=d[l][mod_st]\n        if int(st + st) %k==0:\n            count_pair -=1\nprint(count_pair)", "complexity": "nlogn", "problem": "1029_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "def binar(a,st,d):\n    if st==0:\n        return 1\n    \n    elif st==1:\n        return a%d\n    \n    return (   binar(a**2%d,st//2,d) *  binar(a, st%2,d)   )%d\n\nx,k=map(int,input().split())\n\nif x==0:\n\tprint(0)\n\texit()\n\nres= ((x*binar(2,k+1,1000000007)) - (binar(2,k,1000000007))+1)% 1000000007 \nprint(res)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import math\n\ndef getdt():\n    return map(int,input().split())\ndef calc(v0,v,a,x):\n    t = (v - v0)/a\n    x0 = v0 * t + 0.5*a*t*t\n    if x0>=x:\n        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)\n    return (x0,t)\ndef go(v0,v,a,x):\n    x0,t = calc(v0,v,a,x)\n    return t + (x-x0)/v\n\na,v = getdt()\nl,d,w = getdt()\nif w>v:\n    w = v\nx,t = calc(0,w,a,d)\nif x==d:\n    print(go(0,v,a,l))\nelse:\n    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "N = 1030\nMOD = int(1e9+7)\nc = [[0] * N for i in range(N)]\nfor i in range(N):\n    c[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, N):\n        c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD\n\narr = list(map(int, list(input())))\ncnt = int(input())\nif cnt == 0:\n    print(1)\n    exit()\n\ndp = [0] * N\nfor i in range(2, N):\n    dp[i] = dp[bin(i).count('1')] + 1\nres = 0\nfor i in range(1, N):\n    if dp[i] != cnt - 1:\n        continue\n    n, k = len(arr)-1, i\n    for pos in range(len(arr)):\n        if arr[pos] == 1:\n            res = (res + c[n][k]) % MOD\n            k -= 1\n        n -= 1\n    if n == -1 and k == 0:\n        res += 1\nif cnt == 1: \n    res -= 1\nprint(res)", "complexity": "linear", "problem": "0914_C", "from": "CODEFORCES", "tags": "brute force,combinatorics,dp"}
{"src": "a, b= map(int,input().split())\n\nif a == b:\n    print(0)\n\nelse:\n    x = a ^ b\n    c = 0\n\n    while x:\n        x //= 2\n        c += 1\n\n    print(2**c-1)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "# Author Name: Ajay Meena\n# Codeforce : https://codeforces.com/profile/majay1638\nimport sys\nimport math\nimport bisect\nimport heapq\nfrom bisect import bisect_right\nfrom sys import stdin, stdout\n\n# -------------- INPUT FUNCTIONS ------------------\n\n\ndef get_ints_in_variables(): return map(\n    int, sys.stdin.readline().strip().split())\n\n\ndef get_int(): return int(sys.stdin.readline())\n\n\ndef get_ints_in_list(): return list(\n    map(int, sys.stdin.readline().strip().split()))\ndef get_list_of_list(n): return [list(\n    map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n\ndef get_string(): return sys.stdin.readline().strip()\n\n# -------- SOME CUSTOMIZED FUNCTIONS-----------\n\n\ndef myceil(x, y): return (x + y - 1) // y\n\n# -------------- SOLUTION FUNCTION ------------------\n\n\ndef Solution(td, n, k):\n    # Write Your Code Here\n    mxHeap = []\n    td = sorted(td, key=lambda x: x[0])\n    prefix = []\n    tmp = 0\n    for v in td:\n        b = v[1]\n        tmpAns = tmp+b\n        if len(mxHeap) == k:\n            if len(mxHeap) and b > mxHeap[0]:\n                t = heapq.heappop(mxHeap)\n                heapq.heappush(mxHeap, b)\n                tmp -= t\n                tmp += b\n        elif len(mxHeap) < k:\n            tmp += b\n            heapq.heappush(mxHeap, b)\n        prefix.append([tmpAns, v[2]])\n\n    ans = [0 for _ in range(n)]\n    for v in prefix:\n        ans[v[1]] = v[0]\n    print(*ans)\n\n\ndef main():\n    # Take input Here and Call solution function\n    n, k = get_ints_in_variables()\n    a = get_ints_in_list()\n    b = get_ints_in_list()\n    td = [[a[i], b[i], i] for i in range(n)]\n    Solution(td, n, k)\n\n\n# calling main Function\nif __name__ == '__main__':\n    main()\n", "complexity": "nlogn", "problem": "0994_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import sys\ninput = sys.stdin.readline\nfrom itertools import combinations\nfrom collections import defaultdict\nn,m = map(int,input().split())\na = [list(map(int,input().split())) for i in range(n)]\nmx = max(max(a[i]) for i in range(n))\nif n == 1:\n  print(1,1)\n  exit()\nl = 0\nr = mx+1\nwhile l+1 < r:\n  flg = 0\n  x = (l+r)//2\n  jud = set()\n  dc = defaultdict(int)\n  for i in range(n):\n    jnum = 0\n    for j in range(m):\n      if a[i][j] >= x:\n        jnum += 1<<j\n    if dc[jnum] == 0:\n      dc[jnum] = i+1\n    if jnum == (1<<m)-1:\n      flg = 1\n      if i == 0:\n        ans = (i+1,i+2)\n      else:\n        ans = (1,i+1)\n    jud.add(jnum)\n  for p,q in combinations(jud,2):\n    if p|q == (1<<m)-1:\n      flg = 1\n      ans = (dc[p],dc[q])\n  if flg:\n    l = x\n  else:\n    r = x\nif l == 0:\n  print(1,2)\nelse:\n  print(*ans)", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nok = False\nfor i in range(len(a)):\n    if (a[i] > min(a) ):\n        ans = a[i]\n        ok = True\n        break\nif (ok):\n    print(ans)\nelse:\n    print(\"NO\")", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "n,l,r,x=map(int,input().split())\na=list(map(int,input().split()))\ncount=0\nt=0\nans=[]\nfor i in range(3,(2**n)+1):\n    c=i\n    ans=[]\n    sum=0\n    while c!=0:\n        c=c&(c-1)\n        count+=1\n    if count>1:\n        for j in range(n):\n            if i & (1 << j):\n                sum+=a[j]\n                ans.append(a[j])\n        if l<=sum<=r and (max(ans)-min(ans))>=x:\n            t+=1\nprint(t)\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "lis = list(map(int,input().split()))\nif lis[2] <= lis[0] and lis[2] <= lis[1]:\n\tif ((lis[0]+lis[1]) - lis[2]) < lis[3]:\n\t\tprint(lis[3] - ((lis[0]+lis[1]) - lis[2]))\n\telif sum(lis) == 0:\n\t\tprint(-1)\n\telif lis[0] == 0 and lis[1] == 0 and lis[2] == 0 :\n\t\tprint(lis[3])\n\telse:\n\t\tprint(-1)\nelse:\n\tprint(-1)\n\n\n\n\n\n\t\t\n\n\n\n", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\nm = int(input())\nif(n<=26):\n    print(m%(2**n))\nelse:\n    print(m)\n    ", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n, k = [int(x) for x in input().split()]\nps = [int(x) for x in input().split()]\nmapping = [-1 for _ in range(256)]\n\nres = []\nfor p in ps:\n    if mapping[p] == -1:\n        j = p - k + 1\n        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):\n            j += 1\n        for i in range(j, p+1):\n            mapping[i] = j\n    res.append(mapping[p])\nprint(\" \".join(map(str, res)))", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "t=int(input())\nfor _ in range(t):\n\tn,k=list(map(int,input().split()))\n\tif n>=32:\n\t\tprint(\"YES \"+str(n-1))\n\telse:\n\t\tans=-1\n\t\tfor i in range(1,n+1):\n\t\t\tp=(4**i)-(2**(i+1))+1\n\t\t\tp*=(((4**(n-i))-1)//3)\n\t\t\tg=(((4**i)-1)//3)\n\t\t\tp+=(((4**i)-1)//3)\n\t\t\tg=(((4**i)-1)//3)-(((4**(i-1))-1)//3)\n\t\t\tif g<=k and p>=k:\n\t\t\t\tans=n-i\n\t\t\t\tbreak\n\t\tif ans!=-1:\n\t\t\tprint(\"YES \"+str(ans))\n\t\telse:\n\t\t\tprint(\"NO\")", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "N = int(input())\nX = list(map(int, input().split()))\nfrom collections import defaultdict\ndp = defaultdict(lambda :-1)\nfor i in range(N):\n    dp[i+1001] = X[i]\nfor i in range(2, N+1):\n    for j in range(N-i+1):\n        for k in range(1, i):\n            u, v = dp[j+1001*k], dp[j+k+1001*(i-k)]\n            if u == -1 or v == -1 or u != v:\n                continue\n            dp[j+1001*i] = u+1;break\n \n \n#print(dp)\ndp2 = [0]*(N+1)\nfor i in range(N):\n    dp2[i+1] = dp2[i]+1\n    if dp[1001*(i+1)] != -1:\n        dp2[i+1] = 1\n        continue\n    for j in range(i+1):\n        if dp[j+(i+1-j)*1001] == -1:\n            continue\n        dp2[i+1] = min(dp2[i+1], dp2[j]+1)\nprint(dp2[-1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\n\nans = 0\n\nfor mask in range(2**n):\n    cnt, csum = 0, 0\n    mn, mx = 10**18, -(10**18)\n    for i in range(n):\n        if (mask & (1 << i) != 0):\n            cnt += 1\n            csum += c[i]\n            mn = min(mn, c[i])\n            mx = max(mx, c[i])\n    if (cnt >= 2) and (csum >= l) and (csum <= r) and (mx - mn >= x):\n        ans += 1\n        \nprint(ans)\n    ", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "## \nmax_ = 10**18\narr  = [0, 1]\narr2 = [0, 3] \nwhile arr[-1] < max_:\n    arr.append(arr[-1]*4)\n    arr2.append(arr2[-1]*2+1)\n    \nfor i in range(1, len(arr)):\n    arr[i] += arr[i-1]\n    \ndef solve(n, k):\n    if n==2 and k==3:\n        return 'NO'\n    if n==2 and k==4:\n        return 'YES 0'\n    if n+1<=len(arr) and k > arr[n]:\n         return 'NO'\n        \n    i=0\n    while k >= arr[i+1]:\n        i+=1\n    if k-arr[i] > arr2[i]:\n        i+=1\n    return 'YES ' +str(n-i)    \n\nfor _ in range(int(input())):\n    n, k = map(int, input().split())\n    print(solve(n, k))", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "m = 10**18\n\ndef run():\n    n, k = [int(x) for x in input().split()]\n    currn, currs = 1, n\n    rem = 0\n\n    while True:\n        if k == 0:\n            print(f'YES {currs}')\n            return\n        if k < currn or currs == 0:\n            print('NO')\n            return\n        currs -= 1\n        k -= currn\n        if currs >= 40:\n            rem = m\n        else:\n            rem = min(m, rem + cc[currs]*((currn-1)*2+1))\n        currn = (currn - 1) * 2 + 3\n\n        if k <= rem:\n            print(f'YES {currs}')\n            return\n\n\ncc = [0, 1]\nfor i in range(2, 50):\n    cc.append(min(m, 1 + 4*cc[-1]))\nfor i in range(int(input())): run()\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import sys\n\ndef main():\n\n    n,k=map(int,sys.stdin.readline().strip().split())\n    arr=list(map(int,sys.stdin.readline().strip().split()))\n    arr.sort()\n    dic={}\n    for a in arr:\n        if a/k not in dic:\n            dic[a]=1\n    \n    print(len(dic))\n\nmain()", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "n=int(input())\ns=list(map(int,input().split()))\nc=list(map(int,input().split()))\ndp=[float('inf')]*(n)\nfor i in range(1,n):\n    mn=float('inf')\n    for j in range(i):\n        if s[i]>s[j]:\n            mn=min(mn,c[i]+c[j])\n    dp[i]=mn\nres=float('inf')\nfor i in range(1,n):\n    for j in range(i):\n        if s[i]>s[j]:\n            res=min(res,c[i]+dp[j])\nif res==float('inf'):\n    res=-1\nprint(res)\n            \n    \n    ", "complexity": "quadratic", "problem": "0987_C", "from": "CODEFORCES", "tags": "brute force,dp,implementation"}
{"src": "# B. Preparing Olympiad\n\ndef check_combination(v):\n    sm = sum(v)\n    if l <= sm <= r:\n        if max(v) - min(v) >= x:\n            global ans\n            ans += 1\n\n\ndef go(offset, k):\n    # https://stackoverflow.com/questions/12991758/creating-all-possible-k-combinations-of-n-items-in-c/28698654\n    if k == 0:\n        check_combination(combination)\n        return\n    for i in range(offset, len(problems) - k + 1):\n        combination.append(problems[i])\n        go(i+1, k-1)\n        combination.pop()\n\n\nn, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\n\nproblems = list()\ncombination = list()\n\nans = 0\n\nfor i in range(2, len(c) + 1):\n    problems = c.copy()\n    go(0, i)\n\nprint(ans)\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "def getsum(n):\n    return ((1 << (2*n)) - 1) // 3\n\ndef b(n, k):\n    l = n - 1\n    r = max(0, l - 41)\n    while True:\n        mid = (l + r) // 2\n        count = getsum(n - mid)\n        if count <= k:\n            l = mid\n        else:\n            r = mid\n        if l - r <= 1:\n            break\n        del count\n    g = getsum(n - r)\n    if g < k:\n        del g\n        return None\n    elif g == k:\n        del g\n        return r\n    return l        \n\n\nt = int(input())\nfor i in range(t):\n    n, k = map(int, input().split())\n    min_side = b(n, k)\n    if min_side is None:\n        print('NO')\n        continue\n    k -= getsum(n - min_side)\n    if n == 2 and min_side == 1 and k == 2:\n        print('NO')\n        continue\n    num_squares = (1 << (n - min_side)) * 2 - 1\n    if k >= num_squares:\n        print('YES ' + str(min_side - 1))\n    else:\n        print('YES ' + str(min_side))", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\nimport math as mt\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef lcm(a, b):\n    return (a * b) / gcd(a, b)\n\n\nmod = int(1e9) + 7\n\n\ndef power(k, n):\n    if n == 0:\n        return 1\n    if n % 2:\n        return (power(k, n - 1) * k) % mod\n    t = power(k, n // 2)\n    return (t * t) % mod\n\n\ndef totalPrimeFactors(n):\n    count = 0\n    if (n % 2) == 0:\n        count += 1\n        while (n % 2) == 0:\n            n //= 2\n\n    i = 3\n    while i * i <= n:\n        if (n % i) == 0:\n            count += 1\n            while (n % i) == 0:\n                n //= i\n        i += 2\n    if n > 2:\n        count += 1\n    return count\n\n\n# #MAXN = int(1e7 + 1)\n# # spf = [0 for i in range(MAXN)]\n#\n#\n# def sieve():\n#     spf[1] = 1\n#     for i in range(2, MAXN):\n#         spf[i] = i\n#     for i in range(4, MAXN, 2):\n#         spf[i] = 2\n#\n#     for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n#         if (spf[i] == i):\n#             for j in range(i * i, MAXN, i):\n#                 if (spf[j] == j):\n#                     spf[j] = i\n#\n#\n# def getFactorization(x):\n#     ret = 0\n#     while (x != 1):\n#         k = spf[x]\n#         ret += 1\n#         # ret.add(spf[x])\n#         while x % k == 0:\n#             x //= k\n#\n#     return ret\n\n\n# Driver code\n\n# precalculating Smallest Prime Factor\n# sieve()\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[a[i]] = i\n    found=[-1, -1, -1]\n    found2=[-1, -1]\n    for i in range(n):\n        c=1\n        while c<(1<<31):\n            if a[i]- c in d.keys() and a[i]+c in d.keys():\n                found[0]=a[i]-c\n                found[1]=a[i]\n                found[2]=a[i]+c\n            if a[i]- c in d.keys() :\n                found2=[a[i], a[i]-c]\n            if a[i]+ c in d.keys() :\n                found2=[a[i], a[i]+c]\n            c*=2\n    if found[0]==found[1]:\n        if found2[0]==found2[1]:\n            print(1)\n            print(a[0])\n        else:\n            print(2)\n            print(*found2)\n    else:\n        print(3)\n        print(*found)\n\n\n\n\n\n\n\n\n\n\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "nlogn", "problem": "0988_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "# from typing import List, Set, Dict, Tuple, Text, Optional\nfrom collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__  # type: ignore\n\n#########\n# INPUT #\n#########\n\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n    # type: () -> str\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\n##########\n# OUTPUT #\n##########\n\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n    # type: (str) -> None\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n    # type: (str) -> None\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\n###########\n# LIBRARY #\n###########\n\n\ndef bootstrap(f, stack=[]):\n  # Deep Recursion helper.\n  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst\n  # Usage:\n\n  # @bootstrap\n  # def recur(n):\n  #   if n == 0:\n  #     yield 1\n  #   yield (yield recur(n-1)) * n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\n\n'''\narrayInit([3, 4, 5], 0):\nInitialize 3-dim array with [3][4][5] with 0 as its initial value\n\nTested with:\nhttps://codeforces.com/contest/625/problem/B\n'''\n\n\nclass MDArray(object):\n  # Faster implementation of md array, using a single array and a lot of math.\n  '''\n  >>> x = MDArray([1, 2, 5], 5)\n  >>> x.get([0, 0, 0])\n  5\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.set([0, 1, 2], 3)\n  3\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.set([0, 1, 3], 1)\n  1\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.get([0, 1, 3])\n  1\n  '''\n\n  def __init__(self, dimensions, initial_value=0):\n    # type: (Iterable[int], Any) -> None\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n    # type: (Iterable[int]) -> Any\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n    # type: (Iterable[int], Any) -> Any\n    self.arr[self._index(indexes)] = value\n    return value\n\n\n#########\n# LOGIC #\n#########\n\ndef encode(row, col, n, m):\n  return row * m + col\n\n\ndef solve(node, remain, adj, dp):\n  if remain == 0:\n    return 0\n  key = (node, remain)\n  mem = dp.get(key)\n  if mem != -1:\n    return mem\n\n  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))\n  dp.set(key, ans)\n  return ans\n\n\ndef main(inp, out):\n  # type: (Input, Output) -> any\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = [-1] * (n*m*(k/2+1))\n\n  for i in range(n*m):\n    dp[i] = 0\n\n  for t in range(1, k/2+1):\n    for i in range(n*m):\n      ans = min(map(lambda x: dp[x[0]+((t-1)*n*m)] + x[1], adj[i]))\n      dp[i+(t*n*m)] = ans\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(dp[node+(k/2*n*m)] * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\n\n###############\n# BOILERPLATE #\n###############\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "def rec(r,g,b):\n    if(dp[r][g][b]!=-1):\n        return dp[r][g][b]\n    ans=0\n    if r<R and g<G:\n        ans=max(ans, red[r]*green[g]+rec(r+1, g+1, b))\n    if r<R and b<B:\n        ans=max(ans, red[r]*blue[b]+rec(r+1, g, b+1))\n    if b<B and g<G:\n        ans=max(ans, blue[b]*green[g]+rec(r, g+1, b+1))\n    dp[r][g][b]=ans\n    return ans\nR,G,B=map(int,input().split())\nred=sorted(list(map(int, input().split())), reverse=True)\ngreen=sorted(list(map(int, input().split())), reverse=True)\nblue=sorted(list(map(int, input().split())), reverse=True)\ndp=[[[-1]*(B+1) for _ in range(G+1)] for _ in range(R+1)]\nprint(rec(0,0,0))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "from math import factorial,pow\nsend = input()\nreceived = input()\n\npos = 0\nfor p in send:\n\tpos = pos +1 if p=='+' else pos-1\nqcount = 0\ncurr_pos = 0\nfor p in received:\n\tif p=='+':\n\t\tcurr_pos = curr_pos +1  \n\telif(p=='-'):\n\t\tcurr_pos = curr_pos-1\n\tif p=='?':\n\t\tqcount +=1\n\nif qcount == 0:\n\tprint(\"{:.12f}\".format(1.0 if pos==curr_pos else 0.0))\nelse:\n\texp_val_q = abs(pos -curr_pos)\n\tif exp_val_q%2!=qcount%2 or qcount<exp_val_q:\n\t\tprint(\"{:.12f}\".format(0.0))\n\telse:\n\t\tneg = (qcount - exp_val_q)/2\n\t\tposi = qcount - neg\n\t\tval = factorial(qcount)/(factorial(neg)*factorial(posi)*pow(2,qcount))\n\t\tprint(\"{:.12f}\".format(val))\n\n\n\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "import sys\nimport bisect\nfrom bisect import bisect_left as lb\ninput_=lambda: sys.stdin.readline().strip(\"\\r\\n\")\nfrom math import log\nfrom math import gcd\nfrom math import atan2,acos\nfrom random import randint\nsa=lambda :input_()\nsb=lambda:int(input_())\nsc=lambda:input_().split()\nsd=lambda:list(map(int,input_().split()))\nsflo=lambda:list(map(float,input_().split()))\nse=lambda:float(input_())\nsf=lambda:list(input_())\nflsh=lambda: sys.stdout.flush()\n#sys.setrecursionlimit(10**6)\nmod=10**9+7\ngp=[]\ncost=[]\ndp=[]\nmx=[]\nans1=[]\nans2=[]\nspecial=[]\nspecnode=[]\na=0\nkthpar=[]\ndef dfs(root,par):\n    if par!=-1:\n        dp[root]=dp[par]+1\n    for i in range(1,20):\n        if kthpar[root][i-1]!=-1:\n            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]\n    for child in gp[root]:\n        if child==par:continue\n        kthpar[child][0]=root\n        dfs(child,root)\nans=0\ndef hnbhai(t):\n    n=sb()\n    p=[]\n    for i in range(n):\n        p.append(sflo())\n    #print(p)\n    dp=[0]*(1<<n)\n    dp[1]=1\n    for i in range(2,1<<n):\n        for j in range(1,n):\n            for k in range(0,j):\n                if (i>>j)&1 and (i>>k)&1:\n                    dp[i]=max(dp[i],dp[i^(1<<j)]*p[k][j]+dp[i^(1<<k)]*p[j][k])\n    #print(dp)\n    print(dp[-1])\nfor _ in range(1):\n    hnbhai(_+1)\n", "complexity": "np", "problem": "0678_E", "from": "CODEFORCES", "tags": "bitmasks,dp,math,probabilities"}
{"src": "import math\ns1=list(input())\ns2=list(input())\np1,m1,p2,m2,c=0,0,0,0,0\nfor i in range(len(s1)):\n\tif(s1[i]=='+'):\n\t\tp1+=1\n\tif(s1[i]=='-'):\n\t\tm1+=1\n\tif(s2[i]=='+'):\n\t\tp2+=1\n\tif(s2[i]=='-'):\n\t\tm2+=1\n\tif(s2[i]=='?'):\n\t\tc+=1\np=abs(p1-p2)\nm=abs(m1-m2)\nif((p+m)==c):\n\tprint(math.factorial(c)/(math.factorial(p)*math.factorial(m)*pow(2,c)))\nelse:\n\tprint(0/1)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "l, r = map(int, input().split())\n\nif l == r:\n    print(0)\n    exit()\nbinr, binl = bin(r)[2:], bin(l)[2:]\nbinl = '0' * (len(binr) - len(binl)) + binl\n# print(binl, binr)\nfor i in range(len(binl)):\n    if binl[i] != binr[i]:\n        binl = '1' * len(binl[i:])\n        break\n\nprint(int(binl, 2))\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "def cal(r, g, b):\n\tif dp[r][g][b] != -1:\n\t\treturn dp[r][g][b]\n\n\tarea = 0\n\tif r<R and g<G:\n\t\tarea = max(area, rl[r] * gl[g] + cal(r+1, g+1, b))\n\tif r<R and b<B:\n\t\tarea = max(area, rl[r] * bl[b] + cal(r+1, g, b+1))\n\tif g<G and b<B:\n\t\tarea = max(area, gl[g] * bl[b] + cal(r, g+1, b+1))\n\tdp[r][g][b] = area\n\treturn area\n\nif __name__ == \"__main__\":\n\tR, G, B = map(int,input().split())\n\trl = sorted(list(map(int,input().split())), reverse=True)\n\tgl = sorted(list(map(int,input().split())), reverse=True)\n\tbl = sorted(list(map(int,input().split())), reverse=True)\n\tdp = [[[-1]*(B+1) for i in range(G+1)] for i in range(R+1)]\n\tprint(cal(0,0,0))\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import math,sys,bisect,heapq,os\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\nfrom functools import lru_cache\n#sys.setrecursionlimit(200000000)\nint1 = lambda x: int(x) - 1\ndef input(): return sys.stdin.readline().rstrip('\\r\\n')\n#input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\naj = lambda: list(map(int, input().split()))\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n#MOD = 1000000000 + 7\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\n\n\ndef solve():\n\tG = defaultdict(list)\n\n\tdef addEdge(a,b):\n\t\tG[a].append(b)\n\n\tdef Kahn(N):\n\t    in_degree = [0]*(N+1)\n\t    for i in G.keys():\n\t        for j in G[i]:\n\t            in_degree[j] += 1\n\t    queue = deque()\n\t    for i in range(1,N+1):\n\t        if in_degree[i] == 0:\n\t            queue.append(i)\n\t    cnt =0\n\t    top_order = []\n\t    while queue:\n\t        u = queue.popleft()\n\t        top_order.append(u)\n\t        for i in G.get(u,[]):\n\t            in_degree[i] -= 1\n\t            if in_degree[i] == 0:\n\t                queue.append(i)\n\t        cnt += 1\n\t    if cnt != N:\n\t        Y(0);exit(0)\n\t    else:\n\t        Y(1);print(*top_order)\n\n\tn,m,k = aj()\n\tmark= {}\n\tfor i in range(n):\n\t\ts = input()\n\t\tmark[s] = i+1\n\n\tB = []\n\tfor i in range(2**k):\n\t\tf = bin(i)[2:]\n\t\tf = '0'*(k - len(f)) + f\n\t\tB.append(f)\n\n\tfor i in range(m):\n\t\ts,mt = input().split(\" \")\n\t\tmt = int(mt)\n\t\tst = set()\n\t\tfor j in B:\n\t\t\tss = ['']*k\n\t\t\tfor l in range(k):\n\t\t\t\tif j[l] == '1':\n\t\t\t\t\tss[l] = s[l]\n\t\t\t\telse:\n\t\t\t\t\tss[l] = '_'\n\t\t\tss = \"\".join(ss)\n\t\t\tif ss in mark:\n\t\t\t\tst.add(mark[ss])\n\t\t#print(st)\n\t\tif mt not in st:\n\t\t\tY(0);exit(0)\n\t\tst.discard(mt)\n\t\tfor j in st:\n\t\t\taddEdge(mt,j)\n\t#print(G)\n\tKahn(n)\n\n\ntry:\n\t#os.system(\"online_judge.py\")\n\tsys.stdin = open('input.txt', 'r') \n\tsys.stdout = open('output.txt', 'w')\nexcept:\n\tpass\n\nsolve()", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "t=list(map(int,input().split()))\nn=t[0]\nc=t[1]\na=list(map(int,input().split()))\nf=[]\nfor i in range(0,500001):\n\tf.append(0)\nl=[]\nfor i in range(0,500001):\n\tl.append([0])\nm=0\nfor i in range(n):\n\tl[a[i]].append(f[a[i]]-m)\n\tif a[i]==c:\n\t\tm+=1\n\tf[a[i]]+=1\n\tl[a[i]].append(f[a[i]]-m)\nma=0\nfor i in l:\n\tmi=0\n\tfor j in i:\n\t\tif(j<mi):\n\t\t\tmi=j\n\t\tif(ma<j-mi):\n\t\t\tma=j-mi\nprint(m+ma)", "complexity": "linear", "problem": "1082_E", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int,sys.stdin.readline().strip().split()))\n\nfor i in range (0, n):\n    if a[i] >= 0:\n        a[i] = - a[i] - 1\n\nif n % 2 == 1:\n    i = a.index(min(a))\n    a[i] = - a[i] - 1\n\na = list(map(str,a))\nprint(\" \".join(a))\n\n", "complexity": "linear", "problem": "1180_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2024)]\n \nd = [[] for _ in range(n)]\nfor j, v in enumerate(b):\n\te[v][j] = j\n\td[j].append(j)\n \nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n \na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])\n\t\t\t\t \t\t  \t\t\t\t\t  \t \t\t\t\t\t \t \t \t\t\t", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys, math\nimport io, os\n# data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\n# from heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n# from itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\n# from fractions import Fraction\n# sys.setrecursionlimit(100000)\nINF = 10001\nmod = int(1e9) + 7\n\n\nn=int(data())\na=mdata()\nans=[n]\ndp1=[[0]*n for i in range(n)]\ndp2=[[n]*n for i in range(n)]\nfor i in range(n-1,-1,-1):\n    dp1[i][i]=a[i]\n    dp2[i][i]=1\n    for j in range(i+1,n):\n        for k in range(i,j):\n            if dp1[i][k] == dp1[k+1][j] != 0:\n                dp1[i][j] = dp1[i][k] + 1\n                dp2[i][j] = 1\n            dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j])\nout(dp2[0][n-1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "\nimport sys\ninput = sys.stdin.buffer.readline\n\nn,k=map(int,input().split())\narr=[int(x) for x in input().split()]\n\nx=0\ndp=[]\nfor i in range(n):\n    x=x+arr[i]\n    dp.append(x)\n\nans=0\nfor i in range(n):\n    for j in range(i+k-1,n):\n        ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1))\nprint(ans) ", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "from sys import stdin, stdout\nfrom math import gcd\ninput = stdin.buffer.readline\n\nx, k = map(int, input().split())\nif x == 0:\n\tprint(0)\n\texit()\nx *= 2\nmod = 1000000007\nx = pow(2, k, mod) * x % mod - (pow(2, k, mod) - 1)\nprint(x % mod)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "'''\n      ___           ___                         ___                       ___           ___                         ___\n     /\\__\\         /\\  \\         _____         /\\  \\                     /\\  \\         /\\  \\                       /\\__\\\n    /:/ _/_        \\:\\  \\       /::\\  \\        \\:\\  \\       ___         /::\\  \\       |::\\  \\         ___         /:/ _/_\n   /:/ /\\  \\        \\:\\  \\     /:/\\:\\  \\        \\:\\  \\     /\\__\\       /:/\\:\\__\\      |:|:\\  \\       /\\__\\       /:/ /\\  \\\n  /:/ /::\\  \\   ___  \\:\\  \\   /:/  \\:\\__\\   ___ /::\\  \\   /:/__/      /:/ /:/  /    __|:|\\:\\  \\     /:/  /      /:/ /::\\  \\\n /:/_/:/\\:\\__\\ /\\  \\  \\:\\__\\ /:/__/ \\:|__| /\\  /:/\\:\\__\\ /::\\  \\     /:/_/:/__/___ /::::|_\\:\\__\\   /:/__/      /:/_/:/\\:\\__\\\n \\:\\/:/ /:/  / \\:\\  \\ /:/  / \\:\\  \\ /:/  / \\:\\/:/  \\/__/ \\/\\:\\  \\__  \\:\\/:::::/  / \\:\\~~\\  \\/__/  /::\\  \\      \\:\\/:/ /:/  /\n  \\::/ /:/  /   \\:\\  /:/  /   \\:\\  /:/  /   \\::/__/       ~~\\:\\/\\__\\  \\::/~~/~~~~   \\:\\  \\       /:/\\:\\  \\      \\::/ /:/  /\n   \\/_/:/  /     \\:\\/:/  /     \\:\\/:/  /     \\:\\  \\          \\::/  /   \\:\\~~\\        \\:\\  \\      \\/__\\:\\  \\      \\/_/:/  /\n     /:/  /       \\::/  /       \\::/  /       \\:\\__\\         /:/  /     \\:\\__\\        \\:\\__\\          \\:\\__\\       /:/  /\n     \\/__/         \\/__/         \\/__/         \\/__/         \\/__/       \\/__/         \\/__/           \\/__/       \\/__/\n\n'''\n\"\"\"\n\u2591\u2591\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\n\u2591\u2584\u2580\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2591\u2588\u2591\n\u2591\u2588\u2591\u2584\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2584\u2591\u2588\u2591\n\u2591\u2588\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2588\u2591\n\u2591\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2591\n\u2584\u2588\u2580\u2588\u2580\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2580\u2580\u2588\u2588\u2588\n\u2588\u2588\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2588\u2588\n\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2580\u2591\u2591\u2591\u2591\u2580\u2588\u2591\u2591\u2591\u2591\u2588\u2588\n\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\u2588\n\u2591\u2580\u2588\u2588\u2588\u2584\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2588\u2588\u2588\u2580\u2591\n\u2591\u2591\u2591\u2580\u2588\u2588\u2584\u2591\u2580\u2588\u2588\u2580\u2591\u2584\u2588\u2588\u2580\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\"\"\"\nimport sys\nimport math\nimport collections\nimport operator as op\nfrom collections import deque\nfrom math import gcd, inf, sqrt, pi, cos, sin, ceil, log2, floor, log\nfrom bisect import bisect_right, bisect_left, bisect\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\nfrom functools import reduce\nfrom sys import stdin, stdout, setrecursionlimit\nsetrecursionlimit(2**20)\n\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(op.mul, range(n, n - r, -1), 1)\n    denom = reduce(op.mul, range(1, r + 1), 1)\n    return numer // denom  # or / in Python 2\n\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return (list(factors))\n\n\ndef isPowerOfTwo(x):\n    return (x and (not(x & (x - 1))))\n\nMOD = 1000000007\nPMOD = 998244353\nN = 10**18 + 1\nLOGN = 30\nalp = 'abcdefghijklmnopqrstuvwxyz'\nT = 1\n# T = int(stdin.readline())\nfor _ in range(T):\n    n, k = list(map(int, stdin.readline().rstrip().split()))\n    # n = int(stdin.readline())\n    # a = list(map(int, stdin.readline().rstrip().split()))\n    # b = list(map(int, stdin.readline().rstrip().split()))\n    # s = str(stdin.readline().strip('\\n'))\n    # s = list(stdin.readline().strip('\\n'))\n    # m = int(stdin.readline())\n    # c = list(map(int, stdin.readline().rstrip().split()))\n    det = (int(sqrt(9 + 8 * (n + k)) - 3)) // 2\n    print(n - det)\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n=int(input())\nc=0\nlst=[4,7,47,74,447,474,744,477,747,774]\nif n in lst:\n    print(\"YES\")\nelse:\n    for i in lst:\n        if n%i==0:\n            print(\"YES\")\n            c=c+1\n            break\n        else:\n            continue\n    if c==0:\n        print(\"NO\")\n    \n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "import os, sys\nfrom io import BytesIO, IOBase\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\nvalid = lambda x, y: -1 < x < n and -1 < y < m\ndx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)\n\nn, m, k = inp(int)\nif k & 1:\n    [print(*([-1] * m)) for _ in range(n)]\n    exit()\n\nright, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]\nmem = [[[float('inf')] * (k // 2 + 1) for _ in range(m + 1)] for _ in range(n + 1)]\n\nfor _ in range(n):\n    for i, j in enumerate(inp(int)):\n        right[_][i] = j\n\nfor _ in range(n - 1):\n    for i, j in enumerate(inp(int)):\n        down[_][i] = j\n\nfor i in range(n):\n    for j in range(m):\n        mem[i][j][0] = 0\n\nfor k1 in range(1, k // 2 + 1):\n    for i in range(n):\n        for j in range(m):\n            ans = []\n            ans.append(mem[i - 1][j][k1 - 1] + down[i - 1][j])\n            ans.append(mem[i + 1][j][k1 - 1] + down[i][j])\n            ans.append(mem[i][j - 1][k1 - 1] + right[i][j - 1])\n            ans.append(mem[i][j + 1][k1 - 1] + right[i][j])\n            mem[i][j][k1] = min(ans)\n\n[print(*[mem[i][x][-1] * 2 for x in range(m)]) for i in range(n)]\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "inp = list(map(int, input().strip().split()))\nmoves = inp[0]\ncandiesAtTheEnd = inp[1]\n\ndef find(moves, candiesAtTheEnd):\n  result = -1\n  start = 0\n  end = moves-1\n  while result!=candiesAtTheEnd:\n    #print(\"start: \",start, \", end: \", end)\n    mid=((end-start+1)//2)+start\n    #print(\"mid: \", mid)\n    pluses=moves-mid\n    minuses=mid\n    #print(\"pluses: \", pluses, \", minuses: \", minuses)\n    result=((pluses+1)/2)*pluses\n    result=result-minuses\n    #print(\"result: \", result)\n    if result==candiesAtTheEnd:\n      return minuses\n    elif result>candiesAtTheEnd:\n      start=mid\n    else:\n      end=mid\n    \n\nresult_final=find(moves,candiesAtTheEnd)\nprint(result_final)\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "t = int(input())\n\ndef get_max(n):\n    ans = 0\n    while n:\n        ans = 4 * ans + 1\n        n = n - 1\n        if ans > 10**19:\n            break\n    return ans\n\nfor _ in range(t):\n    n, k = map(int, input().split())\n    if n == 1:\n        if k == 1:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    elif n == 2:\n        if k <= 2:\n            print(\"YES 1\")\n        elif k != 3 and k <= 5:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    else:\n        siz = n - 1\n        l = 1\n        cnt = 3\n        while siz:\n            if l <= k < l+cnt:\n                print(\"YES {}\".format(siz))\n                break\n            l = l + cnt\n            cnt = 2 * cnt + 1\n            siz = siz - 1\n        else:\n            if k <= get_max(n):\n                print(\"YES 0\")\n            else:\n                print(\"NO\")\n", "complexity": "linear", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "n, s = map(int, input().split())\nprint((s + n - 1) // n)", "complexity": "constant", "problem": "1061_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "def main():\n    def solve():\n        n = int(input())\n        arr = sorted(map(int, input().split()))\n        a = arr[-2]\n        print(min(n - 2, a - 1))\n    \n    import sys\n    input = sys.stdin.readline\n    \n    for _ in range(int(input())):\n        solve()\n    \n    return 0\n\nmain()", "complexity": "nlogn", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "from sys import stdin, stdout\n\nnxt = []\n\ndef find_it(s, left, right):\n    global nxt\n    dp = [[1000 for i in range(len(right) + 1)] for j in range(len(left) + 1)]\n    dp[0][0] = 0\n    for i in range(len(left)+1):\n        for j in range(len(right)+1):\n            if dp[i][j] > len(s):\n                continue\n            if j < len(right) and nxt[ord(right[j]) - 97][dp[i][j]] != -1:\n                if nxt[ord(right[j]) - 97][dp[i][j]] < dp[i][j+1]:\n                    dp[i][j+1] = nxt[ord(right[j]) - 97][dp[i][j]] +1\n            if i < len(left) and nxt[ord(left[i]) - 97][dp[i][j]] != - 1:\n                if nxt[ord(left[i]) - 97][dp[i][j]] < dp[i+1][j]:\n                    dp[i+1][j] = nxt[ord(left[i]) - 97][dp[i][j]] +1\n    if dp[len(left)][len(right)] != 1000:\n        return True\n    else:\n        return False\n\ndef main():\n    global nxt\n    n = int(stdin.readline())\n    for _ in range(n):\n        s = stdin.readline().rstrip()\n        t = stdin.readline().rstrip()\n        nxt = [[-1 for _ in range(len(s)+1)] for i in range(26)] \n        for i,x in enumerate(s):\n            nxt[ord(x) - 97][i] = i\n        for i in range(26):\n            for j in range(len(s)-1 ,-1,-1):\n                if nxt[i][j] != j:\n                    nxt[i][j] = nxt[i][j+1]\n        \n        r = False            \n        for i in range(len(t)):\n            res = find_it(s, t[:i], t[-len(t)+i:])\n            if res is True:\n                r = True\n                break\n        \n        if r is True:\n            stdout.write(\"YES\\n\")\n        else:\n            stdout.write(\"NO\\n\")\n            \n\nmain()            ", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "n,m = map(int,input().split())\nprint(n*\"8\")\nprint((n-1)*\"1\"+\"2\")", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "import sys\nlines = int(sys.stdin.readline())\ndp = [0] * lines\nf = 1\ndp[0] = 1\n\nfor i in range(lines):\n  char_in = sys.stdin.readline()[0]\n  if char_in == 'f':\n    f += 1\n  else:\n    # num ways to write the statements\n    # the more for loops, the more we can combination\n    # any single statement can be the indent of anything previously\n    # sum over previous, but also update all of previous\n    for j in range(1, f):\n      dp[j] = (dp[j] + dp[j- 1]) % 1000000007\nprint(dp[f - 1])", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "n = int(input())\n\nif n>=2:\n    print(25)\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "from collections import defaultdict\nfrom sys import stdin\ninput = stdin.readline\ndef check(mid, m):\n    d = defaultdict(int)\n    for idx, i in enumerate(a):\n        string = ''\n        for j in i:\n            if j >= mid:\n                string+='1'\n            else:\n                string+='0'\n        d[int(string, 2)] = idx\n    for i in d.keys():\n        for j in d.keys():\n            if i|j == 2**m - 1:\n                 return [d[i], d[j]]\n    return []\ndef binarySearch(lo, hi, m):\n    ans = []\n    while lo < hi:\n        mid = lo + (hi-lo+1)//2\n        x = check(mid, m)\n        if x:\n            lo = mid\n            ans = [x[0]+1, x[1]+1]\n        else:\n            hi = mid-1\n    return ans\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\nprint(*binarySearch(-1, 10**9+1, m))", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "\n\n\ndef solve(matrix, col, N, M):\n    if col == M:\n        '''\n        for row in matrix:\n            print(row)\n        print()\n        '''\n\n        ans = 0\n        for row in matrix:\n            if len(row) == 1:\n                ans += row[0]\n            else:\n                ans += max(*row)\n\n        return ans\n\n    # girar la columna `col` N - 1 veces\n\n    if N == 1:\n        return solve(matrix, col + 1, N, M)\n\n    ans = solve(matrix, col + 1, N, M)\n    for _ in range(N-1):\n        tmp = matrix[0][col]\n        for n in range(1, N):\n            matrix[n-1][col] = matrix[n][col]\n        matrix[N-1][col] = tmp\n\n        local_ans = solve(matrix, col + 1, N, M)\n        if local_ans > ans:\n            ans = local_ans\n\n    return ans\n\ndef main():\n    T = int(input())\n    for t in range(T):\n        N, M = list(map(lambda x: int(x), input().split()))\n\n        matrix = []\n        for n in range(N):\n            matrix.append(\n                list(map(lambda x: int(x), input().split()))\n            )\n\n        elements = []\n        for n in range(N):\n            for m in range(M):\n                elements.append((matrix[n][m], m))\n\n        elements.sort(reverse=True)\n\n        candidates = []\n        for t in elements:\n            if t[1] not in candidates:\n                candidates.append(t[1])\n                if len(candidates) == N:\n                    break\n\n        simplified = []\n        for n in range(N):\n            row = []\n            for m in candidates:\n                row.append(matrix[n][m])\n            simplified.append(row)\n\n        ans = solve(simplified, 0, N, min(N, M))\n        print(ans)\n\nmain()\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "c = [[0 for i in range(5205)] for j in range(5205)]\nK = 998244353\ninv = [0 for i in range(5205)]\n\ndef mu(a, n):\n\tif n == 0: return 1\n\tq = mu(a, n // 2)\n\tif n % 2 == 0:\n\t\treturn q * q % K\n\telse: return q * q % K * a % K\n\ndef calc(m, d, S):\n\tres = 0\n\tif m == 0:\n\t\tif S == 0: return 1\n\t\treturn 0\n\n\tfor u in range(0, m + 1):\n\t\tif (u * d > S): break\n\t\tU = c[m][u] * c[S - u * d + m - 1][m - 1] % K \n\t\tif u % 2 == 0:\n\t\t\tres = (res + U) % K\n\t\telse: res = (res - U + K) % K \n\treturn res\n\n\nc[0][0] = 1\ninv[0] = 1\nfor i in range(1, 5101):\n\tinv[i] = mu(i, K - 2)\n\nfor i in range(1, 5101):\n\tc[i][0] = 1\n\tfor j in range (1, i):\n\t\tc[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K\n\tc[i][i] = 1\n\np, s, r = map(int, input().split())\n\nres = 0\nden = 0\n\nfor i in range(1, p + 1):\n\tA = 0\n\tfor d in range(r, s // i + 1):\n\t\tif (i < p): A = (A + calc(p - i, d, s - d * i)) % K\n\t\telse:\n\t\t\tif (s - i * d == 0): A += 1\n\tA = A * inv[i] % K\n\tres = (res + A * c[p - 1][i - 1] % K) % K\n\nden = c[s - r + p - 1][p - 1]\nres = res * mu(den, K - 2) % K\nprint(res)\n\n\n", "complexity": "cubic", "problem": "1096_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math,probabilities"}
{"src": "n = int(input())\nboard = list(map(int,input().split(\" \")))\nindex = list(range(0,n))\nascending = [x for _,x in sorted(zip(board,index))]\n\nwinners = n * [\"\"]\n\n\nfor c in reversed(ascending):\n\tif board[c] == n:\n\t\twinners[c] = \"B\"\n\t# going down\n\ttoCheck = c - board[c]\n\twhile(toCheck >= 0):\n\t\tif winners[toCheck] == \"B\":\n\t\t\twinners[c] = \"A\"\n\t\ttoCheck = toCheck - board[c]\n\tif winners[c] == \"\":\n\t\ttoCheck = c + board[c]\n\t\twhile(toCheck < n):\n\t\t\tif winners[toCheck] == \"B\":\n\t\t\t\twinners[c] = \"A\"\n\t\t\ttoCheck = toCheck + board[c]\n\tif winners[c] == \"\":\n\t\twinners[c] = \"B\"\n\t#print(\"board at c\",board[c])\n\t#print(c)\n\t#print(winners)\n\nfor i in range(n):\n\tprint(winners[i],end=\"\")\nprint()\n\t\t\n\t\n\n", "complexity": "nlogn", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "# import itertools\n# import bisect\n# import math\nfrom collections import defaultdict, Counter\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n# sys.setrecursionlimit(10 ** 5)\nii = lambda: int(input())\nlmii = lambda: list(map(int, input().split()))\nslmii = lambda: sorted(map(int, input().split()))\nli = lambda: list(input())\nmii = lambda: map(int, input().split())\nmsi = lambda: map(str, input().split())\n\n\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\n\ndef lcm(a, b): return (a * b) // gcd(a, b)\n\n\ndef main():\n    # for _ in \" \" * int(input()):\n    w, h, n = mii()\n    ws, dws, hs, dhs, hsm, wsm = SortedList([]), defaultdict(int), SortedList([]), defaultdict(int), SortedList(\n        []), SortedList([])\n    hsm.add(h);\n    wsm.add(w);\n    hs.add(0);\n    ws.add(0);\n    hs.add(h);\n    ws.add(w);\n    dhs[h] = 1;\n    dhs[0] = 1;\n    dws[0] = 1;\n    dws[w] = 1\n    for i in range(n):\n        t, p = map(str, input().split())\n        p = int(p)\n        if t == \"H\":\n            if dhs[p] == 0:\n                hs.add(p)\n                dhs[p] = 1\n            ind = hs.bisect_left(p)\n            pre, nex = hs[ind - 1], hs[ind + 1]\n            hsm.__delitem__(hsm.bisect_left(nex - pre));\n            hsm.add(p - pre);\n            hsm.add(nex - p)\n        else:\n            if dws[p] == 0:\n                ws.add(p)\n                dws[p] = 1\n            ind = ws.bisect_left(p)\n            pre, nex = ws[ind - 1], ws[ind + 1]\n            wsm.__delitem__(wsm.bisect_left(nex - pre));\n            wsm.add(p - pre);\n            wsm.add(nex - p)\n        print(wsm[-1] * hsm[-1])\n    pass\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "nlogn", "problem": "0527_C", "from": "CODEFORCES", "tags": "binary search,data structures,implementation"}
{"src": "a = input().split()\nb = [int(i) for i in a]\ninputs = []\ndiff = []\nsinComprimir = 0\nfor i in range(b[0]):\n    input1 = input().split()\n    input2 = [int(i) for i in input1]\n    inputs.append(input2)\n\ncomprimido = 0\nfor k in range(len(inputs)):\n    sinComprimir = sinComprimir + inputs[k][0]\n    diff.append(inputs[k][0] - inputs[k][1])\n    comprimido = comprimido + inputs[k][1] \n\ndifference = sorted(diff)\ninvDifference = difference[::-1]\nnewTotal = sinComprimir\niteraciones = 0\niterador = 0\nif sinComprimir <= b[1]:\n    print(\"0\")\nelif comprimido > b[1]:\n    print(\"-1\")\nelse:\n    while newTotal > b[1]:\n        iterador = iterador + 1\n        newTotal = newTotal - invDifference[iterador-1] \n        iteraciones += 1\n    print(iteraciones)", "complexity": "nlogn", "problem": "1015_C", "from": "CODEFORCES", "tags": "sortings"}
{"src": "n, k = map(int, input().split())\nlst = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    lst.append([-a, b])\nlst.sort()\nprint(lst.count(lst[k-1]))", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "def res(d,N):\n    for i in range(1,N):\n        if d[i][1] <= d[i-1][1]:\n            return str(d[i][2]+1) + ' ' + str(d[i-1][2]+1)\n    return '-1 -1'    \n\nN = int(input())\nd = []\nfor i in range(N):\n    a,b = map(int,input().split())\n    d.append((a,b,i))\nd = sorted(d, key = lambda x:(x[0],-x[1]))\nprint(res(d,N))\n", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "def smallest(d):\n    out = \"\"\n    for j in range(0, 10):\n        out += (\"%d\" % j)*d[j]\n    return out\n\n\ndef largest(d):\n    out = \"\"\n    for j in range(9, -1, -1):\n        out += (\"%d\" % j)*d[j]\n    return out\n\n\nsa = input()\nsb = input()\nb = int(sb)\n\nh = int(sa)\ndigits_a = [0]*10\nwhile h > 0:\n    digits_a[h % 10] += 1\n    h //= 10\n\nout = \"\"\nif len(sb) > len(sa):\n    print(largest(digits_a))\n    exit()\n\nout = 0\nfor i in range(len(sa)-1, -1, -1):\n    for j in range(9, -1, -1):\n        if digits_a[j] == 0:\n            continue\n\n        if j < (b % (10 ** (i+1))) // (10 ** i):\n            digits_a[j] -= 1\n            if out > 0:\n                print(\"{}{}{}\".format(out, j, largest(digits_a)))\n                exit()\n            else:\n                print(\"{}{}\".format(j, largest(digits_a)))\n                exit()\n\n        if j == (b % (10 ** (i+1))) // (10 ** i):\n            if i == 0:\n                out = 10*out + j\n                print(out)\n                exit()\n            digits_a[j] -= 1\n            if int(smallest(digits_a)) <= b % (10 ** i):\n                out = 10*out + j\n                break\n            else:\n                digits_a[j] += 1\n\nprint(out)\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n=int(input())\na=str(n)\nm=len(a)\nb=int(a[0:m-1])\nc=int(a[0:m-2]+a[-1])\nd=max(n,b,c)\nprint(d)\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "n,K=map(int,input().split())\nb=sorted([int(x)for x in input().split()])\nl=cur=0\nfor i in range(1,n):\n    if b[i]==b[i-1]:continue\n    if b[i]>b[i-1]+K:l=i\n    else:cur+=(i-l);l=i\nprint(n-cur)\n", "complexity": "nlogn", "problem": "0990_B", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "t = int(input())\n\nfor iter in range(t):\n    n, k = map(int, input().split())\n    if n >= 50:\n        if k == 0:\n            print(\"YES \" + str(n))\n        else:\n            print(\"YES \" + str(n - 1))\n    else:\n        a = [0] * (n + 1)\n        b = [0] * (n + 1)\n        c = [0] * (n + 1)\n        a[0] = 0\n        b[n] = 1\n        c[n] = 0\n\n        for i in range(1, n + 1):\n            a[i] = 4 * a[i - 1] + 1\n        for i in range(n - 1, -1, -1):\n            b[i] = b[i + 1] * 2 + 1\n        for i in range(n - 1, -1, -1):\n            c[i] = c[i + 1] + b[i + 1]\n\n        res = -1\n        for d in range(n + 1):\n            if c[d] <= k and k <= a[n] - a[d] * b[d]:\n                res = d\n\n        if res == -1:\n            print(\"NO\")\n        else:\n            print(\"YES \" + str(res))\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "\ndef check(mid,n,m,arr):\n\tmasks = {}\n\tfor index in range(n):\n\t\tarray = arr[index]\n\t\tx = 0\n\t\tfor i in range(m):\n\t\t\tif array[i] >= mid:\n\t\t\t\tx ^= (1<<i)\n\t\tmasks[x] = index+1\n\tans = False\n\ta,b = 1,1\n\tif (1<<m)-1 in masks.keys():\n\t\treturn True,(masks[(1<<m)-1],masks[(1<<m)-1])\n\tfor i in  masks.keys():\n\t\tfor j in masks.keys():\n\t\t\torAns = i|j\n\t\t\tif(orAns == ((1<<m)-1)):\n\t\t\t\tif i == (1<<m)-1 and (i in masks.keys()):\n\t\t\t\t\ta = masks[i]\n\t\t\t\t\tans = True\n\t\t\t\t\tbreak\n\t\t\t\telif j == (1<<m)-1 and (j in masks.keys()):\n\t\t\t\t\tb =  masks[j]\n\t\t\t\t\tans = True\n\t\t\t\t\tbreak\n\t\t\t\telif (i in masks.keys()) and (j in masks.keys()):\n\t\t\t\t\tans = True\n\t\t\t\t\ta,b = masks[i],masks[j]\n\t\t\t\t\tbreak\n\treturn ans,(a,b)\n\ndef solve(n,m,arr):\n\tmini = 0\n\tmaxi = int(1e9)+5\n\ti,j = 1,1\n\twhile(mini<=maxi):\n\t\tmid = (mini+maxi)//2\n\t\tans,res = check(mid,n,m,arr)\n\t\tif(ans):\n\t\t\ti,j = res\n\t\t\tmini =mid +1\n\t\telse:\n\t\t\tmaxi = mid -1\n\tprint(i,j)\n\ndef main():\n\tn,m = map(int,input().split(' '))\n\tarr = []\n\tfor _ in range(n):\n\t\tx = list(map(int,input().split(' ')))\n\t\tarr.append(x)\n\tsolve(n,m,arr)\n\nmain()", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "n,m = map(int,input().split())\narr1 = list(map(int,input().split()))\narr2 = list(map(int,input().split()))\n\nprint(*sorted([x for x in arr2 if x in arr1],key = lambda k:arr1.index(k)))", "complexity": "quadratic", "problem": "0994_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "if __name__ == \"__main__\":\n    n = int(input())\n    nums = [int(a) for a in input().strip().split()]\n    counts = 0\n\n    for i in range(n-1):\n        for j in range(i + 1, n):\n            if nums[i] > nums[j]:\n                counts += 1\n\n    ans = counts % 2\n    ans_tmp = []\n    m = int(input())\n    for i in range(m):\n        l, r = [int(a) for a in input().strip().split()]\n\n        tmp = r - l + 1\n        tmp_count = (tmp * (tmp - 1) // 2)\n        if tmp_count % 2 == 1:\n            ans = (ans + 1) % 2\n        ans_tmp.append(ans)\n    \n    for i in range(m):\n        ans = ans_tmp[i]\n        if ans % 2 == 1:\n            print(\"odd\")\n        else:\n            print(\"even\")\n\n \t  \t\t \t \t \t    \t  \t\t \t\t    \t \t", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "a,b=map(int,input().split())\nans=0\nwhile a and b:\n  ans+=a//b\n  a,b=b,a%b\nprint(ans)", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "#n=int(input())\nn,m=map(int,input().split())\n\nvert=[]\n\nfor i in range(n):\n    v=int(input())\n    vert.append(v)\n\nhorz=[]\n\nfor i in range(m):\n    x1,x2,y=map(int,input().split())\n    if x1==1:\n        horz.append(x2)\n\nvert.sort()\nhorz.sort()\n\nvert.append(1000000000)\n\ndef next(k,a,x):\n    while k<len(a) and a[k]<x:\n        k+=1\n    return k\n\nnum=next(0,horz,vert[0])\n\nans=len(horz)-num\n\nfor i in range(1,len(vert)):\n    num2=next(num,horz,vert[i])\n    t=i+len(horz)-num2\n    if t<ans: ans=t\n    num=num2\n\nprint(ans)\n\n\n\n\n", "complexity": "nlogn", "problem": "1075_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "#!usr/bin/python\n\na = input()\nb = input()\n\nlength_of_a = len(a)\nlength_of_b = len(b)\nfound_digit = False\nchk_finnish = False\nappended_digit_count = 0\nn = {}\nnum = []\nfor i in range(0,10):\n\tn[i] = 0\n\nfor i in range(0,length_of_a):\n\tc = int(a[i])\n\tn[c] += 1\n\n\nif length_of_a < length_of_b:\n\tnum = sorted(a,reverse=True)\n\tfor i in range(0,length_of_a):\n\t\tprint(num[i],end=\"\")\nelse:\n\tfor i in range(0,length_of_b):\n\t\tdigit = int(b[i])\n\t\tif n[digit] > 0:\n\t\t\tnum.append(digit)\n\t\t\tn[digit] -= 1\n\t\t\t# print(\"from start as equal : n[\"+str(digit)+\"] : \"+str(n[digit]))\n\t\t\t# print(num)\n\t\t\tappended_digit_count += 1\n\t\telse:\n\t\t\tj = digit - 1\n\t\t\twhile j > -1:\n\t\t\t\tif n[j] > 0:\n\t\t\t\t\tnum.append(j)\n\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\tn[j] -= 1\n\t\t\t\t\t# print(\"from 2nd : n[\"+str(j)+\"] : \"+str(n[j]))\n\t\t\t\t\t# print(num)\n\t\t\t\t\tfound_digit = True\n\t\t\t\t\tchk_finnish = True\n\t\t\t\t\tbreak\n\t\t\t\tj -= 1\n\n\t\t\tif found_digit:\n\t\t\t\tj = 9\n\t\t\t\twhile j > -1:\n\t\t\t\t\tif n[j] > 0:\n\t\t\t\t\t\tdigit_count = n[j]\n\t\t\t\t\t\tfor k in range(0,digit_count):\n\t\t\t\t\t\t\tnum.append(j)\n\t\t\t\t\t\t\tn[j] -= 1\n\t\t\t\t\t\t\t# print(\"form 3rd : n[\"+str(j)+\"] : \"+str(n[j]))\n\t\t\t\t\t\t\t# print(num)\n\t\t\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\tj -= 1\n\t\t\t\tif chk_finnish:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tfound_digit = False\n\t\t\t\twhile found_digit == False:\n\t\t\t\t\tpop_up = num[appended_digit_count-1]\n\t\t\t\t\t# print(pop_up,end=\" \")\n\t\t\t\t\tdel num[-1]\n\t\t\t\t\tj = pop_up - 1\n\t\t\t\t\tn[pop_up] += 1\n\t\t\t\t\t# print(\"form 4th popped : n[\"+str(pop_up)+\"] : \"+str(n[pop_up]))\n\t\t\t\t\t# print(num)\n\t\t\t\t\t# print(n[pop_up])\n\t\t\t\t\tappended_digit_count -= 1\n\t\t\t\t\twhile j > -1:\n\t\t\t\t\t\tif n[j] > 0:\n\t\t\t\t\t\t\tnum.append(j)\n\t\t\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\t\t\tn[j] -= 1\n\t\t\t\t\t\t\t# print(\"from 5th appeneded n[\"+str(j)+\"] : \"+str(n[j]))\n\t\t\t\t\t\t\t# print(num)\n\t\t\t\t\t\t\tfound_digit = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tj -= 1\n\t\t\t\tj = 9\n\t\t\t\twhile j > -1:\n\t\t\t\t\tif n[j] > 0:\n\t\t\t\t\t\t# print(\"from 5th : n[\"+str(j)+\"] : \"+str(n[j]))\n\t\t\t\t\t\t# print(num)\n\t\t\t\t\t\tdigit_count = n[j]\n\t\t\t\t\t\tfor k in range(0,digit_count):\n\t\t\t\t\t\t\tnum.append(j)\n\t\t\t\t\t\t\tappended_digit_count += 1\n\t\t\t\t\tj -= 1\n\t\t\t\tbreak\n\t\t\t\n\n\tfor i in range(0,length_of_b):\n\t\tprint(num[i],end=\"\")", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a = sorted(a)\n    print(min(a[-2]-1, n-2))\n", "complexity": "nlogn", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "def digit(a):\n    s=0\n    while a:\n        s+=a%10\n        a//=10\n    return s\n\ndef big(n,s):\n    # lst=[[i,i-digit(i)] for i in range(1,n+1)]\n    lo=1\n    hi=n\n    while lo<=hi:\n        mid=(lo+hi)//2\n        if mid-digit(mid)<s:\n            # print(digit(mid))\n            lo=mid+1\n        else:\n            hi=mid-1\n            # hi=mid-1\n    return n-lo+1\n\na,b=map(int,input().strip().split())\nprint(big(a,b))", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "from sys import stdin,stdout\n# input=stdin.readline\nmod=10**9+7\nt=1\nfor _ in range(t):\n    a=input()\n    b=input()\n    n=len(a)\n    m=len(b)\n    dp=[[0 for i in range(2)] for j in range(m+1)]\n    dp[1][0]=int(b[0])^1\n    dp[1][1]=int(b[0])\n    for i in range(2,m+1):\n        dp[i][0]=dp[i-1][0]+(int(b[i-1])^1)\n        dp[i][1]=dp[i-1][1]+int(b[i-1])\n    ans=0\n    for i in range(n):\n        count0=dp[m-n+i+1][0]-dp[i][0]\n        count1=dp[m-n+i+1][1]-dp[i][1]\n        ans+=count0*int(a[i])+count1*(int(a[i])^1)\n    print(ans)", "complexity": "linear", "problem": "0608_B", "from": "CODEFORCES", "tags": "combinatorics,strings"}
{"src": "def go():\n    n = int(input())\n    for i in range(n):\n        a, b, d = [int(i) for i in input().split(' ')]\n        if a > d or b > d:\n            print(-1)\n        elif a % 2 == b % 2:\n            if a % 2 == d % 2:\n                print(d)\n            else:\n                print(d - 2)\n        else:\n            if a % 2 == b % 2:\n                if d % 2 == a % 2:\n                    print(d)\n                else:\n                    print(d - 2)\n            else:\n                print(d - 1)\ngo()\n", "complexity": "constant", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import io\nimport os\n\nfrom functools import lru_cache\nfrom collections import defaultdict\n\n\ndef solve(N, A):\n    # Compute all intervals that merge down to a single value\n    # val -> leftEndpoint -> rightEndpoints\n    valToLeftRight = defaultdict(lambda: defaultdict(set))\n    # val -> rightEndpoint -> leftEndpoints\n    valToRightLeft = defaultdict(lambda: defaultdict(set))\n    # Initialize with intervals of length 1 (left and right endpoints inclusive)\n    for i, x in enumerate(A):\n        valToLeftRight[x][i].add(i)\n        valToRightLeft[x][i].add(i)\n\n    # Go from smallest to largest values\n    # Note: max val formable is with A = [1000] * 500 which should be around 1000 + lg(500)\n    maxVal = 1000 + 100\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val - 1].items():\n            for r in rights:\n                # Merge (l, r) with (l2, r2) with value (val - 1)\n                l2 = r + 1\n                if l2 in valToLeftRight[val - 1]:\n                    for r2 in valToLeftRight[val - 1][l2]:\n                        assert l <= r\n                        assert r + 1 == l2\n                        assert l2 <= r2\n                        valToLeftRight[val][l].add(r2)\n                        valToRightLeft[val][r2].add(l)\n                # Merge (l2, r2) with (l, r) with value (val - 1)\n                r2 = l - 1\n                if r2 in valToRightLeft[val - 1]:\n                    for l2 in valToRightLeft[val - 1][r2]:\n                        assert l2 <= r2\n                        assert r2 == l - 1\n                        assert l <= r\n                        valToLeftRight[val][l2].add(r)\n                        valToRightLeft[val][r].add(l2)\n\n    # Merge all left to right endpoints regardless of value formed\n    intervals = defaultdict(list)\n    for val in range(maxVal):\n        for l, rights in valToLeftRight[val].items():\n            for r in rights:\n                # print(A[l : r + 1], l, r, val)\n                intervals[l].append(r)\n\n    # DP[i] returns most area you can cover in A[i:]\n    dp = {}\n    dp[N] = 0\n    for left in range(N - 1, -1, -1):\n        best = float(\"inf\")\n        for right in intervals[left]:\n            # left to right inclusive is combined down to one character\n            best = min(best, 1 + dp[right + 1])\n        dp[left] = best\n\n    # print(intervals)\n    # print(A)\n    # print([g[i] for i in range(N + 1)])\n    return dp[0]\n\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    ans = solve(N, A)\n    print(ans)\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import collections\n\n\ndef main():\n    # # n = int(input())\n    # x, y, z, t1, t2, t3 = list(map(int, input().split()))\n    # stair = t1 * abs(y - x)\n    # ele = t2 * (abs(y - x) + abs(z - x)) + 3 * t3\n    # # print(stair, ele)\n    # print(\"YES\" if ele <= stair else \"NO\")\n\n    # n = int(input())\n    # num = list(map(int, input().split()))\n    # prevMax, totMax = -1, float('-inf')\n    # for i, v in enumerate(num):\n    #     totMax = max(totMax, v)\n    #     if totMax - prevMax in [0, 1]:\n    #         prevMax = totMax\n    #     else:\n    #         print(i + 1)\n    #         return\n    # print(-1)\n\n    n = int(input())\n    left = list(map(int, input().split()))\n    right = list(map(int, input().split()))\n    res = [0] * n\n    val = n\n\n    if all(not left[i] and not right[i] for i in range(n)):\n        print(\"YES\")\n        print(' '.join(['1'] * n))\n        return\n\n    while not all(not left[i] and not right[i] for i in range(n)):\n        zeroSet = set()\n        for i in range(n):\n            if not left[i] and not right[i] and res[i] == 0:\n                zeroSet.add(i)\n                res[i] = val\n        for v in zeroSet:\n            for i in range(v + 1, n):\n                if i not in zeroSet and res[i] == 0:\n                    left[i] -= 1\n            for i in range(v):\n                if i not in zeroSet and res[i] == 0:\n                    right[i] -= 1\n        val -= 1\n        # print(zeroSet, left, right)\n        if not zeroSet:\n            print(\"NO\")\n            return\n\n    for i in range(n):\n        if not res[i]:\n            res[i] = str(val)\n        else:\n            res[i] = str(res[i])\n    if any(i == '0' for i in res):\n        print(\"NO\")\n        return\n    print(\"YES\")\n    print(' '.join(res))\n\n\nmain()\n", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "n = int(input())\na = []\nfor i in range(n):\n    a.append(list(map(int,input().split()))+[i+1])\na.sort(key = lambda e:e[0])\nf = 0\nfor i in range(n-1):\n    if a[i][0] == a[i+1][0]:\n        if a[i][1] >= a[i+1][1]:\n            print(a[i+1][2],a[i][2])\n        else:print(a[i][2],a[i+1][2])\n        f =1\n        break\n    if a[i][1] >= a[i+1][1]:\n        f = 1\n        print(a[i+1][2],a[i][2])\n        break\nif f == 0:print(-1,-1)\n", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "#!/usr/bin/python3.5\n\nN = int(input())\nL = [int(s) for s in input().split(\" \")]\nR = [int(s) for s in input().split(\" \")]\n\nC = [N - L[i] - R[i] for i in range(0, N)]\n\nfor i, x in enumerate(C):\n    if C[i] <= 0:\n        print(\"NO\")\n        exit()\n\n    l = 0\n    r = 0\n\n    j = i-1\n    while j >= 0:\n        if C[j] > C[i]:\n            l = l + 1\n            \n        j = j - 1\n\n    j = i+1\n    while j < N:\n        if C[j] > C[i]:\n            r = r + 1\n\n        j = j + 1\n\n    if L[i] != l or R[i] != r:\n        print(\"NO\")\n        exit()\n\nprint(\"YES\")\nfor i in range(0, N-1):\n    print(C[i], end=\" \")\n\nprint(C[N-1])\n\n", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "import collections\nimport sys\n\ndef can_win(i, dp):\n    if i in dp:\n        return dp[i]\n    else:\n        for next in possible[i]:\n            if not can_win(next, dp):\n                dp[i] = True\n                return True\n        dp[i] = False\n        return False\n\ndata = sys.stdin.readlines()\nnb = int(data[0])\nnums = data[1].split(' ') \nnums = [int(c) for c in nums]\npossible = [[] for _ in range(nb)]\nfor i in range(nb):\n    if nums[i] == 1:\n        possible[i] = [k for k in range(nb) if k != i] \n    else:\n        for j in range(i+nums[i], nb, nums[i]):\n            if nums[j] > nums[i]:\n                possible[i].append(j)\n        for j in range(i-nums[i], -1, -nums[i]):\n            if nums[j] > nums[i]:\n                possible[i].append(j)\n\nres = \"\"\ndp = {}\nfor i in range(nb):\n    if can_win(i, dp):\n        res += \"A\"\n    else:\n        res += \"B\"\nprint(res)\n        \n", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "n = int(input())\nm = int(input())\nprint(m%2**n)", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "from sys import stdout\nfrom sys import stdin\ndef get():\n    return stdin.readline().strip()\ndef getf(sp = \" \"):\n    return [int(i) for i in get().split(sp)]\ndef put(a, end = \"\\n\"):\n    stdout.write(str(a) + end)\ndef putf(a, sep = \" \", end = \"\\n\"):\n    stdout.write(sep.join([str(i) for i in a]) + end)\n   \n#from collections import defaultdict as dd, deque\n#from random import randint, shuffle, sample\n#from functools import cmp_to_key, reduce\n#from math import factorial as fac, acos, asin, atan2, gcd, log, e\n#from bisect import bisect_right as br, bisect_left as bl, insort\n\nfrom math import log\nfrom bisect import bisect_right as br, bisect_left as bl\n\ndef main():\n    n, k = getf()\n    a = getf()\n    rem = [[] for i in range(11)]\n    ln = [0] * n\n    for i in range(n):\n        ln[i] = int(log(a[i], 10)) + 1\n        rem[ln[i]] += [a[i] % k]\n    for i in range(11):\n        rem[i].sort()\n    ans = 0\n    for i in range(n):\n        res = 0\n        for add_len in range(1, 11):\n            cur_rem = ((a[i] % k) * pow(10, add_len, k)) % k\n            need_rem = (k - cur_rem) % k\n            sz = len(rem[add_len])\n            l = bl(rem[add_len], need_rem)\n            r = br(rem[add_len], need_rem)\n            if(l > sz - 1):\n                continue\n            if(rem[add_len][l] == need_rem):\n                res += (r - l)\n        if((a[i] + (a[i] % k) * pow(10, ln[i], k)) % k == 0):\n            res -= 1\n        ans += res\n    put(ans)\nmain()\n", "complexity": "nlogn", "problem": "1029_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import sys\nimport logging\nlogging.root.setLevel(level=logging.DEBUG)\nimport re\n\ns = sys.stdin.readline().strip()\n\nfrom collections import defaultdict\nsubstr = defaultdict(int)\nfor left in range(len(s)):\n    for right in range(left+1,len(s)+1):\n        substr[s[left:right]] += 1\nmax_len = 0\nfor segment,times in substr.items():\n    if times >= 2:\n        max_len = max(max_len,len(segment))\nprint(max_len)\n\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "n=int(input())\nif n>=0:\n    print(n)\nelse:\n    a=str(n)\n    a=a[1::]\n    if len(a)>2:\n        a=a[::-1][1::][::-1]\n        num1=int(a)\n        a=str(n)\n        a=a[1::]\n        b=a[::-1]\n        p1=b[0]\n        p2=b[2::]\n        p=p1+p2\n        p=p[::-1]\n        num2=int(p)\n        small=min(num1,num2)\n        print(-1*small)\n        \n    elif len(a)==2:\n        m=a[0]\n        n=a[1]\n        small=min(int(m),int(n))\n        print(-1*small)\n    ", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##########################################################\nfrom collections import Counter, defaultdict\nimport bisect\nimport math\n\nfor _ in range(1):\n    n = int(input())\n    #n,k=map(int, input().split())\n    arr = list(map(int, input().split()))\n    t=[0]*n\n    cur=0\n    for i in range(n-1,-1,-1):\n        cur=max(cur-1,0,arr[i]+1)\n        t[i]=cur\n    ans=0\n    for i in range(n):\n        cur=max(cur,t[i])\n        ans+=cur\n    for i in range(n):\n        ans-=(arr[i]+1)\n    print(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "linear", "problem": "0924_C", "from": "CODEFORCES", "tags": "data structures,dp,greedy"}
{"src": "import math\nn, k = map(int, input().split())\n\nq = int(-3 + math.sqrt(9 + 8*(n+k)))//2\n\nr = n-q\n\nprint(r)", "complexity": "constant", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n= int(input())\nb = [int(_) for _ in input().split()]\nd = [[b[i] if i == j else -1 for i in range(n)] for j in range(n)]\n\ndef f(i, j):\n\tif d[i][j] != -1:\n\t\treturn d[i][j]\n\td[i][j] = 0\n\tfor m in range(i, j):\n\t\tl = f(i, m)\n\t\tif f(m+1, j) == l and l:\n\t\t\td[i][j] = l+1\n\t\t\tbreak\n\treturn d[i][j]\n\na = [_ for _ in range(1, n+1)]\nfor e in range(1, n):\n\tfor s in range(e+1):\n\t\tif f(s, e):\n\t\t\ta[e] = min(a[e], ((a[s-1]+1) if s > 0 else a[s]))\nprint(a[-1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n = int(input())\ns = input()\nmaxn = 0\nnow = 0\nfor i in s:\n    if i == '+':\n        now += 1\n    else:\n        now -= 1\n    maxn = max(maxn, -now)\nprint(now + maxn)", "complexity": "linear", "problem": "1159_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import math\n\nn, m, k, l = map(int, input().split())\n\nx = (l + k) // m\nif x * m < l + k:\n    x += 1\nassert x * m >= l + k\n\nif m * x > n:\n    print(-1)\nelse:\n    print(x)", "complexity": "constant", "problem": "1068_A", "from": "CODEFORCES", "tags": "math"}
{"src": "t=int(input())\nfor l in range(t):\n\tn=int(input())\n\tarr=list(map(int,input().split()))\n\tarr.sort()\n\ta=arr[-2]\n\tprint(min(a-1,n-2))\n\t", "complexity": "nlogn", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "# encontrar o m\u00e1ximo xor entre um par que se encontra no intervalo [l,r]\n\ndef main():\n    l,r = map(int,input().split())\n\n    if l == r:\n        print(0)\n        return\n\n    l = bin(l)[2:]\n    r = bin(r)[2:]\n\n    if len(l) == len(r):\n        i = 1 #ambos come\u00e7am com 1, n\u00e3o preciso checar\n        while l[i] == r[i]:\n            i += 1\n        tam = len(l)-i\n    else:\n        tam = len(r)\n\n    num = \"\"\n    for i in range(tam):\n        num += '1'\n\n    print(int(num,2))    \n\nmain()", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "pfs=[i*i for i in range(1,3163)]\np=[i for i in range(0,10000001)]\nfor i in range(1,10000001):\n    if(p[i]==i):\n        for j in pfs:\n            if(i*j>10000000): break\n            p[i*j]=i\nt=int(input())\nfor lll in range(0,t):\n    n,k=map(int,input().split())\n    zc=list(map(int,input().split()))\n    s=[p[zc[i]] for i in range(0,len(zc))]\n    dp=[n]*(k+1)\n    dp[0]=1\n    ys=[{}]*(n+1)\n    for i in range(0,len(s)):\n        for j in range(k,-1,-1):\n            if(dp[j]==n): continue\n            if(ys[j].get(s[i],-1)!=-1):\n                if(j<k and dp[j]<dp[j+1]):\n                    dp[j+1]=dp[j]\n                    ys[j+1]=ys[j]\n                dp[j]+=1\n                ys[j]={}\n            ys[j][s[i]]=1\n    print(min(dp))\n\t\t\t\t\t\t  \t\t      \t \t \t \t \t\t   \t\t", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "x,k=map(int,input().split())\nif x==0:\n  print(0)\nelse:\n    u=(pow(2,k,1000000007)*(2*x-1)+1)%1000000007\n    print(int(u))\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "from copy import deepcopy\nx,k=map(int,input().split(' '))\nif(x==0):\n\tprint(0)\nelse:\n\tprint((((pow(2,k,1000000007))*((2*x-1)%1000000007))+1)%1000000007)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n=int(input())\ndef judge(x):\n    if x%2==0:\n        return 0\n    else:\n        return 1\nls=[int(x) for x in input().split()]\nif judge(ls[0])==judge(ls[1]):\n    for x in ls[2:]:\n        if judge(x)!=judge(ls[0]):\n            print(ls.index(x)+1)\n            break\nelse:\n    if judge(ls[2])==judge(ls[0]):\n        print(2)\n    elif judge(ls[2])==judge(ls[1]):\n        print(1)", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "k = int(input())\n\nif k <= 9:\n\tprint(k)\n\nelse:\n\ts = 9\n\tn = 1\n\t\n\twhile s < k:\n\t\tn += 1\n\t\tprev_s = s\n\t\ts += (10**n - 10**(n-1)) * n\n\n\tdigit_pos = k - (prev_s + 1)\n\tnumber = 10**(n-1) + digit_pos // n\n\t\n\tif digit_pos / n != digit_pos // n:\n\t\tdigit_pos = digit_pos - (digit_pos // n) * n\n\n\n\telse:\n\t\tdigit_pos = 0\n\n\tprint(str(number)[digit_pos])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import sys\nfrom math import gcd, sqrt\nfrom typing import Deque\n\nsys.setrecursionlimit(10 ** 5)\n\n\ninf = float(\"inf\")\nen = lambda x: list(enumerate(x))\n\nii = lambda: int(input())\nr = lambda: map(int, input().split())\nrr = lambda: list(r())\n\n\nn = ii()\narr = rr()\narr = en(arr)\n\narr.sort(key=lambda x: x[1])\n\ni = 0\nbrr = []\n\nfor j in input():\n    if j == \"0\":\n        brr.append(arr[i])\n        print(arr[i][0] + 1, end=\" \")\n        i += 1\n    else:\n        x = brr.pop()\n        print(x[0] + 1, end=\" \")\n", "complexity": "nlogn", "problem": "0982_B", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "n=int(input())\na=[]\nfor i in range(n):\n    l=[int(i) for i in input().split()]\n    if i==0:\n        t=sum(l)\n    a.append(sum(l))\na.sort(reverse=True)\nprint(a.index(t)+1)", "complexity": "linear", "problem": "1017_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from math import ceil\nn, k = map(int, input().split())\ncou = 0\ncou += ceil(n*2/k)\ncou += ceil(n*5/k)\ncou += ceil(n*8/k)\nprint(cou)", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "def main():\n    q = int(input())\n    ans = []\n    for i in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        min_ans = 10 ** 9\n        pr1 = [0]\n        pr2 = [0]\n        pr3 = [0]        \n        for i in range(n):\n            count1 = 0\n            count2 = 0\n            count3 = 0\n            if i % 3 == 0:\n                if s[i] != \"R\":\n                    count1 += 1\n                if s[i] != \"G\":\n                    count2 += 1\n                if s[i] != \"B\":\n                    count3 += 1\n            if i % 3 == 1:\n                if s[i] != \"G\":\n                    count1 += 1\n                if s[i] != \"B\":\n                    count2 += 1\n                if s[i] != \"R\":\n                    count3 += 1 \n            if i % 3 == 2:\n                if s[i] != \"B\":\n                    count1 += 1\n                if s[i] != \"R\":\n                    count2 += 1\n                if s[i] != \"G\":\n                    count3 += 1\n            pr1.append(pr1[-1] + count1)\n            pr2.append(pr2[-1] + count2)\n            pr3.append(pr3[-1] + count3)\n            j = i + 1\n            if j >= k:\n                count1 = pr1[j] - pr1[j - k]\n                count2 = pr2[j] - pr2[j - k]\n                count3 = pr3[j] - pr3[j - k]\n                min_ans = min(min_ans, count1, count2, count3)     \n        ans.append(min_ans)\n    print(*ans, sep=\"\\n\")\n\nmain()", "complexity": "linear", "problem": "1196_D2", "from": "CODEFORCES", "tags": "data structures,dp,implementation,two pointers"}
{"src": "from collections import Counter\n\nn,k=list(map(int,input().split()))\nx=list(map(int,input().split()))\n\ndd=Counter()\nfor i in range(k):\n   \n    dd[x[i]]=dd[x[i]]+1\n\n \nfinal=0   \nfor i in range(1,k+1):\n    ans=0\n    d=dd.copy()\n    for j in range(n):\n        for jj in d:\n            if d[jj]>=i:\n                d[jj]-=i\n                ans=ans+1\n                break\n    if ans>=n:\n        final=i\n    else:\n        break\nprint(final)", "complexity": "nlogn", "problem": "1011_B", "from": "CODEFORCES", "tags": "binary search,brute force,implementation"}
{"src": "import math\nimport sys\n\nn=int(input())\ns=list(map(int,input().split()))\nce=list(map(int,input().split()))\n\nbest=10**9\nfor j in range(1,n-1):\n    a=ce[j];b=10**9;c=10**9\n    for i in range(j-1,-1,-1):\n        if s[i]<s[j]:\n            b=min(b,ce[i])\n    for k in range(j+1,n):\n        if s[k]>s[j]:\n            c=min(c,ce[k])\n    best=min(best,a+b+c)\n\nif best>=10**9:\n    print(-1)\nelse:\n    print(best)", "complexity": "quadratic", "problem": "0987_C", "from": "CODEFORCES", "tags": "brute force,dp,implementation"}
{"src": "a=list(map(int,input().split()))\nmr=0\nfor t in range(14):\n    b=list(a)\n    m=b[t]\n    k=t\n    i=1\n    b[k]=0\n    while(m>0):\n        if(m//14==0):\n            b[(k+i)%14]+=1\n            m-=1\n            i+=1\n        else:\n            q=m//14\n            for c in range(14):\n                b[c]+=q\n            m-=14*q\n    p=sum([ x  for x in b if x%2==0 ])\n    mr=max(p,mr)\nprint(mr)\n        \n        \n", "complexity": "constant", "problem": "0975_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "from bisect import insort,bisect_right,bisect_left\nfrom sys import stdout, stdin, setrecursionlimit\nfrom heapq import heappush, heappop, heapify \nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import * \nfrom string import *\nfrom queue import *\nfrom math import *\nfrom re import *\nfrom os import *\n\n# sqrt,ceil,floor,factorial,gcd,log2,log10,comb\n\n####################################---fast-input-output----#########################################\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ngraph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())\ndef getStr(): return input()\ndef getInt(): return int(input())\ndef listStr(): return list(input())\ndef getStrs(): return input().split()\ndef isInt(s): return '0' <= s[0] <= '9'\ndef input(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in input().split()]\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))\n\n\ndef getPrimes(N = 10**5):\n    SN = int(sqrt(N))\n    sieve = [i for i in range(N+1)]\n    sieve[1] = 0\n    for i in sieve:\n        if i > SN:\n            break\n        if i == 0:\n            continue\n        for j in range(2*i, N+1, i):\n            sieve[j] = 0\n    prime = [i for i in range(N+1) if sieve[i] != 0] \n    return prime\ndef primeFactor(n,prime=getPrimes()):\n    lst = []\n    mx=int(sqrt(n))+1\n    for i in prime:\n        if i>mx:break\n        while n%i==0:\n            lst.append(i)\n            n//=i\n    if n>1:\n        lst.append(n)\n    return lst    \n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\ndaysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n\n#################################################---Some Rule For Me To Follow---#################################\n\"\"\"\n    --instants of Reading problem continuously try to understand them.\n\n    --Try & again try, maybe you're just one statement away!\n\n\"\"\"\n##################################################---START-CODING---###############################################\n\n\na = getInt()\nb = getInt()\n\n\narr = list(str(a))\n\narr = sorted(arr)\nans=''\n\nwhile arr:\n    for i in range(len(arr)-1,-1,-1):\n        x=ans+arr[i]\n\n        for j in arr[:i]:\n            x+=j\n        for j in arr[i+1:]:\n            x+=j\n        if int(x)<=b:\n            ans+=arr[i]\n            arr.pop(i)\n            break\n\nprint(ans)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import math\n\nn, r = map(int, input().split())\ns = math.sin(math.pi / n)\nprint('%.7lf' % (r * s / (1 - s)))", "complexity": "constant", "problem": "1100_C", "from": "CODEFORCES", "tags": "binary search,geometry,math"}
{"src": "import math\nnum=int(input())\nk=math.ceil(num/2)\nif num%2==0:\n    print(k+1)\nelse:\n    print(k)", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "# URDL\nDR = [1,0,-1,0]\nDC = [0,1,0,-1]\n\nn, m, k = map(int, input().split())\nw = [[[0] * m for _ in range(n)] for _ in range(4)]\nfor r in range(n):\n    for c, e in enumerate(map(int, input().split())):\n        w[1][r][c] = w[3][r][c + 1] = e\nfor r in range(n - 1):\n    for c, e in enumerate(map(int, input().split())):\n        w[0][r][c] = w[2][r + 1][c] = e\n\n\nINF = 10 ** 9\n\n\ndef solve():\n    global k\n    global w\n    if k % 2 == 1:\n        return [[-1] * m] * n\n    k //= 2\n    best = [[[0] * m for _ in range(n)] for _ in range(k + 1)]\n    for steps in range(1, k + 1):\n        for r in range(n):\n            for c in range(m):\n                best[steps][r][c] = INF\n                for d in range(4):\n                    r2, c2 = r + DR[d], c + DC[d]\n                    if 0 <= r2 < n and 0 <= c2 < m:\n                        best[steps][r][c] = min(best[steps][r][c], 2 * w[d][r][c] + best[steps - 1][r2][c2])\n    return best[k]\n\n\nres = solve()\nfor e in res:\n    print(*e)", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "\ndef STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n#visited = [[False for i in range(m)] for j in range(n)]\n#for tt in range(INT()):\n\ndef Binary_Search(arr , x , n):\n    l ,r = 0 , n-1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if arr[mid] == x :\n            return mid+1\n        elif arr[mid] > x:\n            r = mid - 1\n        else:\n            l = mid + 1\n    return r + 1\n\n\nn , q = MAP()\na = LIST()\nb = LIST()\nps = list(accumulate(a))\nans = []\n\narrows = 0\nfor arrow in b :\n    arrows += arrow\n    if arrows >= ps[-1]:\n        ans.append(n)\n        arrows = 0\n    else:\n        res = Binary_Search(ps , arrows , n)\n        ans.append(n - res)\n\nfor i in ans:\n    print(i)\n\n", "complexity": "nlogn", "problem": "0975_C", "from": "CODEFORCES", "tags": "binary search"}
{"src": "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n \nmax_val = 0\nn, m = [int(item) for item in input().split()]\narray = []\nfor i in range(n):\n    line = [int(item) for item in input().split()]\n    array.append(line)\n    max_val = max(max_val, max(line))\n \ngood = (1 << m) - 1\nl = 0; r = max_val + 1\na = 0; b = 0\nwhile r - l > 1:\n    mid = (l + r) // 2\n    bit_array = dict() \n    for k, line in enumerate(array):\n        val = 0\n        for i, item in enumerate(line):\n            if item >= mid:\n                val |= 1 << i\n        bit_array[val] = k\n    ok = False\n    for key1 in bit_array.keys():\n        for key2 in bit_array.keys():\n            if key1 | key2 == good:\n                ok = True\n                i = bit_array[key1]\n                j = bit_array[key2]\n                break\n    if ok:\n        a = i; b = j\n        l = mid\n    else:\n        r = mid\nprint(a+1, b+1)", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "from sys import stdin\nfrom math import factorial\n\nn, mod = map(int, stdin.readline().split())\n\ndef binom(n, m):\n    return factorial(n) // factorial(m) // factorial(n-m)\n\ndef foo(x, k):\n    ans = 0\n    for i in range(k, 0, -1):\n        sign = 1 if (i-k)%2 == 0 else -1\n        ans += sign * binom(k, i) * (i**x)\n        ans %= mod\n    return ans\n\ndef f(x, k):\n    return (foo(x, k) * pow(2, x-k, mod)) % mod\n\nans = 0\nfor i in range((n+1)//2):\n    ans = (ans + f(n-i, i+1))\n    ans %= mod\nprint(ans)", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn, k = mi()\nans = (n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k\nprint(ans)\n", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "'''input\n3\n1 1\n2 2\n2 12\n'''\nfor _ in range(int(input())):\n\tdef get(n):\n\t\treturn (4**n-1)//3\n\tn,k = map(int,input().split())\n\tif n<32 and 4**n < 1*3*k:\n\t\tprint(\"NO\")\n\t\tcontinue\n\tnow = 1\n\tp = 2\n\tans = n\n\tsq = 0\n\tbuff = 0\n\td = 4\n\twhile k>=now:\n\t\tk -= now\n\t\tp *= 2\n\t\tnow = p-1\n\t\tans -= 1\n\n\t\tsq = sq*4 + d-3\n\t\td *= 2\n\t\tif n < 60:\n\t\t\tbuff += sq * (4**ans-1)//3\n\t\telse:\n\t\t\tbuff = 10**19\n\t\t# print(sq, k, buff)\n\t\tif ans == 0: break\n\t\t# if n < 60:\n\t\t# \tbuff += get(ans)\n\tif buff < k: print(\"NO\")\n\telse: print(\"YES\",max(ans,0))", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "# A. Nastya and an Array\n\nn = int(input())\na = set(map(int, input().split()))\n\nans = len(a) - 1 if 0 in a else len(a)\nprint(ans)\n", "complexity": "linear", "problem": "0992_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "l,r=map(int,input().split())\nal=[]\nar=[]\nwhile(r):\n    p=r%2\n    ar.append(p)\n    r=r//2\nwhile(l):\n    p=l%2\n    al.append(p)\n    l=l//2\nif len(ar)!=len(al):\n    ans=(2**len(ar))-1\nelse:\n    n=len(ar)\n    s=0\n    k=0\n    for i in range(n-1,-1,-1):\n        if ar[i]!=al[i]:\n            k=i+1\n            break\n    ans=(2**k)-1\n    if k==0:\n        ans=0\nprint(ans)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n, m = map(int, input().split())\na = list(map(str, input().strip()))\n\ndp = [10 ** 10] * (1 << 20)\ncnt = [0] * (1 << 20)\n\n\ndef get(x):\n    return 1 << (ord(x) - ord('a'))\n\n\nfor i, v in enumerate(a):\n    if i:\n        cnt[get(a[i]) | get(a[i - 1])] += 1\n\nfor i in range(m):\n    for j in range(1 << m):\n        if (1 << i) & j:\n            cnt[j] += cnt[j ^ (1 << i)]\n            # print(bin(j), bin(j ^ 1 << i), cnt[j])\n\n# for i in range(1 << m):\n#     for j in range(m):\n#         if not i & (1 << j):\n#             cnt[i | (1 << j)] += cnt[i]\n#             print(bin(i | (1 << j)), bin(i), cnt[i | 1 << j])\n\ndp[0] = 0\n\nfor i in range(1 << m):\n    for j in range(m):\n        if not i & (1 << j):\n            dp[i | (1 << j)] = min(dp[i | (1 << j)],\n                                   dp[i] + n - 1 - cnt[i | (1 << j)] - cnt[(1 << m) - 1 - (i | (1 << j))])\nprint(dp[(1 << m) - 1])\n", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "num=int(input())\n\nvals=list(map(int,input().split()))\n\nvals.sort()\n\nflag=0\n\nfor i in vals:\n    if i>vals[0]:\n        print(i)\n        flag=1\n        break\n    \n\nif flag==0:\n    print('NO')\n    ", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "n, m = [int(x) for x in input().split()]\nxs = [int(x) for x in input().split()]\nts = [int(x) for x in input().split()]\n\n\ntaxi_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 1])\npassenger_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 0])\n\na_is = [0] * len(taxi_idx)\nt_idx = 0\np_idx = 0\n\nwhile True:\n    if p_idx >= len(passenger_idx):\n        break\n\n    if t_idx == len(taxi_idx) - 1:\n        a_is[t_idx] += 1\n    else:\n        while t_idx < len(taxi_idx) - 1:\n            d1 = abs(passenger_idx[p_idx] - taxi_idx[t_idx])\n            d2 = abs(passenger_idx[p_idx] - taxi_idx[t_idx + 1])\n            # print(t_idx, d1, d2)\n            if d1 > d2:\n                t_idx += 1\n            else:\n                break\n\n        a_is[t_idx] += 1\n\n    p_idx += 1\n\nprint(' '.join([str(x) for x in a_is]))\n", "complexity": "quadratic", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "from random import randint\nfor _ in range(int(input())):\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n    ans = 0\n    for _ in range(100):\n        for j in range(m):\n            x = randint(0, n - 1)\n            if x:\n                B = []\n                for i in range(n):\n                    B.append(A[i][j])\n                B = B[x:] + B[:x]\n                for i in range(n):\n                    A[i][j] = B[i]\n        c = 0\n        for i in range(n):\n            c += max(A[i])\n        ans = max(ans, c)\n    print(ans)", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "n,l,r,x = map(int,input().split())\na = list(map(int,input().split()))\nans = 0\nfor i in range(1,(2**n)+1):\n    j = bin(i)\n    j = j[2:]\n    if len(j)<n:\n        j = '0'*(n-len(j))+j\n    #print(j)\n    c = 0\n    temp = []\n    for k in j:\n        if k=='1':\n            temp.append(a[c])\n        c+=1\n    s = sum(temp)\n    #print(s)\n    if len(temp)>=2 and s>=l and s<=r and (max(temp)-min(temp))>=x:\n        ans+=1\n    #print(ans)\n    #print()\n    #print(j)\nprint(ans)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "from math import ceil\n\nk, n, s, p = map(int, input().split())\nn_sheets = ceil(n / s)* k\nn_p = ceil(n_sheets / p)\nprint(n_p)", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n=int(input())\nl1=list(map(int,input().split()))\nans=0\nl1.sort()\nvisited=[0]*n\nfor i in range(n):\n    if visited[i]==1:\n        continue\n    visited[i]=1\n    ans+=1\n    for j in range(i+1,n):\n        if visited[j]==0 and l1[j]%l1[i]==0:\n            visited[j]=1\nprint(ans)", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res//x * (x-1)\n            while n%x==0:\n                n //= x\n    if n!=1:\n        res = res//n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n//=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):#\u6392\u4ed6\u7684\u8ad6\u7406\u548c\u306e\u968e\u4e57\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\n#O(|S|)\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=None):\n        self.BIT=[0]*(n+1)\n        self.num=n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        self.mod = mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matrix[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matrix[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matrix[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]+other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]-other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matrix[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m//=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matrix[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nclass SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def bisect_l(self,l,r,x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:\n                    Rmin = r-1\n            l >>= 1\n            r >>= 1\n\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        else:\n            return -1\n\nfrom heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        forward = [to, cap, cost, None]\n        backward = forward[3] = [fr, 0, -cost, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [None]*N\n\n        d0 = [INF]*N\n        dist = [INF]*N\n\n        while f:\n            dist[:] = d0\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                r0 = dist[v] + H[v]\n                for e in G[v]:\n                    w, cap, cost, _ = e\n                    if cap > 0 and r0 + cost - H[w] < dist[w]:\n                        dist[w] = r = r0 + cost - H[w]\n                        prv_v[w] = v; prv_e[w] = e\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return None\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, prv_e[v][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = prv_e[v]\n                e[1] -= d\n                e[3][1] += d\n                v = prv_v[v]\n        return res\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import log,gcd\n\ninput = lambda :sys.stdin.buffer.readline()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn = int(input())\na = li()\n\ninv = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        if a[i] > a[j]:\n            inv += 1\ninv %= 2\n\nm = int(input())\nfor _ in range(m):\n    l,r = mi()\n    L = r-l+1\n\n    all = L*(L-1)//2\n    if all%2==1:\n        inv = 1 - inv\n\n    print(\"odd\" if inv else \"even\")\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "######################################################################\n# Write your code here\nimport sys\ninput = sys.stdin.readline\n#import resource\n#resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY])\n#sys.setrecursionlimit(0x100000)\n# Write your code here\nRI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nrw = lambda : input().strip().split()\n#from collections import defaultdict as df\n#import heapq \n#heapq.heapify(li) heappush(li,4) heappop(li)\n#import random\n#random.shuffle(list)\ninfinite = float('inf')\n#######################################################################\n\nt=int(input())\n\nfor _ in range(t):\n    n,k=RI()\n    s=input()\n\n    mini=n\n    \n    test=\"RGB\"*(k//3 + 5)\n    for i in range(n-k+1):\n        count=0\n        \n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    test=\"GBR\"*(k//3 + 5)\n    for i in range(n-k+1):\n        count=0\n        \n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    test=\"BRG\"*(k//3 + 5)\n    for i in range(n-k+1):\n        count=0\n        \n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    print(mini)\n", "complexity": "quadratic", "problem": "1196_D1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from collections import defaultdict\nn = int(input())\narr = defaultdict(int)\nfor a0 in range(n):\n\tl,r = input().strip().split()\n\tl,r=int(l),int(r)\n\tarr[l]+=1\n\tarr[r+1]-=1\n\nbrr=[0]*(n+1)\n\nl=sorted(arr.keys())\nsum=arr[l[0]]\nprevpoint=l[0]\nfor key in l[1:]:\n\tbrr[sum]+=key-prevpoint\n\tprevpoint=key\n\tsum+=arr[key]\nprint(*brr[1:])", "complexity": "nlogn", "problem": "1000_C", "from": "CODEFORCES", "tags": "data structures,implementation,sortings"}
{"src": "import sys\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\nr, g, b = nm()\nR = nl()\nG = nl()\nB = nl()\ndp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\nR.insert(0, 0)\nG.insert(0, 0)\nB.insert(0, 0)\ndp[0][0][0], ans = 0, 0\nfor i in range(0, r+1):\n    for j in range(0, g+1):\n        for k in range(0, b+1):\n            if i==0 and j==0 and k==0:continue\n            if i and j and dp[i - 1][j - 1][k] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])\n            if k and j and dp[i][j - 1][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])\n            if i and k and dp[i - 1][j][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import sys\nreadline = sys.stdin.buffer.readline\n\nN = int(readline())\nA = list(map(int, readline().split()))\n\ndp = [[0]*N for _ in range(N)]\nfor j in range(N):\n    dp[j][0] = A[j]\n\nfor l in range(1, N):\n    for j in range(l, N):\n        for k in range(j-l, j):\n            if dp[k][k-j+l] == dp[j][j-k-1] > 0:\n                dp[j][l] = 1+dp[j][j-k-1]\n                break\n\ndp = [None] + dp\nDp = [0]*(N+1)\nfor j in range(1, N+1):\n    res = N\n    for l in range(j):\n        if dp[j][l]:\n            res = min(res, 1+Dp[j-l-1])\n    Dp[j] = res\nprint(Dp[N])\n\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import math\n#n,s = map(int, input().strip().split(' '))\nn=int(input())\n#lst = list(map(int, input().strip().split(' ')))\ns2=input()\ns2=list(s2)\ns=[]\nfor i in range(n):\n    if s2[i]=='0':\n        continue\n    else:\n        s.append(int(s2[i]))\ns1=sum(s)\nn=len(s)\nl=[]\nfor i in range(2,n+1):\n    if s1%i==0:\n        l.append(s1//i)\nf=0\nif len(s)==0:\n    f=1\nfor i in range(len(l)):\n    c=0\n    if f==1:\n        break\n    for j in range(n):\n        c+=s[j]\n        if c==l[i]:\n            c=0\n            if j==n-1:\n                f=1\n        elif c<l[i]:\n            c=c\n        else:\n            break\nif f==0:\n    print('NO')\nelse:\n    print('YES')", "complexity": "quadratic", "problem": "1030_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\"\"\"\nID: happyn61\nLANG: PYTHON3\nPROB: loan\n\"\"\"\nfrom itertools import product\nimport itertools\n#from collections import defaultdict\nimport sys\nimport heapq\nfrom collections import deque\nMOD=1000000000007\n#fin = open ('loan.in', 'r')\n#fout = open ('loan.out', 'w')\n#print(dic[\"4734\"])\ndef find(parent,i):\n\n\n    if parent[i] != i: \n        parent[i]=find(parent,parent[i]) \n    return parent[i] \n\n        # A utility function to do union of two subsets \ndef union(parent,rank,xx,yy): \n    x=find(parent,xx)\n    y=find(parent,yy)\n    if rank[x]>rank[y]:\n        parent[y]=x\n    elif rank[y]>rank[x]:\n        parent[x]=y\n    else:\n        parent[y]=x\n        rank[x]+=1\nans=0\n#NK=sys.stdin.readline().strip().split()\n#K=int(sys.stdin.readline().strip())\n#N=int(NK[0])\n#K=int(NK[1])\n#M=int(NK[2])\n#ol=list(map(int,sys.stdin.readline().strip().split()))\n#d={0:0,1:0}\n\nx=0\ny=0\n\nMAX=1000000000\nN,M,K=list(map(int,sys.stdin.readline().strip().split()))\nW=[[[MAX,MAX,MAX,MAX] for j in range(M)] for i in range(N)] #L R U D\nfor i in range(N):\n    l=list(map(int,sys.stdin.readline().strip().split()))\n    for j in range(M-1):\n        W[i][j][1]=l[j]\n        W[i][j+1][0]=l[j]\nfor i in range(N-1):\n    l=list(map(int,sys.stdin.readline().strip().split()))\n    for j in range(M):\n        #print(l,i,j)\n        W[i][j][3]=l[j]\n        W[i+1][j][2]=l[j]\n        \n#print(W)\nif K%2==1:\n    for i in range(N):\n        ans=[]\n        for j in range(M):\n            ans.append(\"-1\")\n        print(\" \".join(ans))\nelse:\n    \n    K=K//2\n    dp=[[[0 for j in range(M)] for i in range(N)] for k in range(K+1)]\n    for kt in range(1,K+1):\n        \n        dl=((0,-1),(0,1),(-1,0),(1,0))\n        for i in range(N):\n            for j in range(M):\n                ans=MAX\n                for t in range(4):\n                    \n                    ii,jj=dl[t]\n                \n                    if i+ii>=0 and i+ii<N and j+jj>=0 and j+jj<M:\n                        ans=min(ans,dp[kt-1][i+ii][j+jj]+W[i][j][t]*2)\n                    #print(i,j,ii,jj,ans)\n                dp[kt][i][j]=ans\n    #print(dp[-1])\n    for i in range(N):\n        ans=[]\n        for j in range(M):\n            ans.append(str(dp[-1][i][j]))\n        print(\" \".join(ans))\n\n                \n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from collections import defaultdict\nfrom math import gcd\nn = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\ndp = defaultdict(lambda: float(\"inf\"))\nfor a, b in zip(A, B):\n    dp[a] = min(dp[a], b)\n    for d in dp.copy():\n        cur = gcd(a, d)\n        dp[cur] = min(dp[cur], dp[a] + dp[d])\nif 1 not in dp:\n    print(-1)\nelse:\n    print(dp[1])", "complexity": "np", "problem": "0510_D", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,math"}
{"src": "n,k = [int(x) for x in input().split()]\na = []\nfor _ in range(n):\n    a.append([int(x) for x in input().split()])\n\na.sort(key = lambda x: x[1])\na.sort(reverse=True,key=lambda x: x[0])\nb=a[k-1] \nprint(a.count(b))", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import sys\n\nIS_LOCAL = False\n\n\ndef readMultiple(f):\n    return f(map(int, input().split()))\n\n\ndef main():\n    n = 3\n    a = [1, 2, -4]\n\n    if not IS_LOCAL:\n        n = int(input())\n        a = readMultiple(list)\n\n    for i, x in enumerate(a):\n        if x >= 0:\n            a[i] = -x - 1\n\n    cnt_neg = 0\n    for x in a:\n        if x < 0:\n            cnt_neg += 1\n\n    b = sorted([(abs(x), i) for i, x in enumerate(a)])\n    if cnt_neg % 2 == 1:\n        ind = b[n-1][1]\n        a[ind] = -a[ind] - 1\n\n    print(' '.join(map(str, a)))\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1 and sys.argv[1] == 'True':\n        IS_LOCAL = True\n    main()\n", "complexity": "nlogn", "problem": "1180_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "k=int(input())\ni=0\nr=1\nwhile(k>=r):\n    r+=9*(i+1)*10**i\n    i+=1\nr=r-(9*i*10**(i-1))\nans=str(((k-r)//i)+10**(i-1))[(k-r)%i]\nprint(ans)", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "def mul(x, y, md):\n\treturn x * y % md;\n\ndef power(x, y, md) :\n\tres = 1;\n\twhile (y != 0):\n\t\tif (y & 1):\n\t\t\tres = mul(res, x, 1000000007);\n\t\tx = mul(x, x, 1000000007);\n\t\ty >>= 1;\n\treturn res\n\ndef inv(x, md):\n\treturn power(x, md - 2, 1000000007);\n\nt = input().split()\na = int(t[0])\nk = int(t[1])\nif (a == 0):\n\tprint(0)\nelse:\n\tfirst = power(2, 2 * k, 1000000007);\n\tsecond = power(2, k, 1000000007);\n\tans = mul(first, 2 * a - 1, 1000000007) + second;\n\tthird = inv(second, 1000000007);\n\tans = mul(ans, third, 1000000007);\n\tprint(ans)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "#########################################################################################################\\\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\nimport sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math \n\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):  \n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n    \"\"\"\n    L is a list.\n    The function returns the power set, but as a list of lists.\n    \"\"\"\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n    \n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n        \n    #the function could stop here closing with\n    #return powerset\n\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n        \n    return powerset_orderred\ndef fastPlrintNextLines(a):\n    # 12\n    # 3\n    # 1\n    #like this\n    #a is list of strings\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\n#__________________________TEMPLATE__________________OVER_______________________________________________________\n\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\") \n# else:\n#     input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nt = 1\n# t = int(input())\nfor _ in range(t):\n    n,m = li()\n    s = list(si())\n    t = list(si())\n    if '*' not in s:\n        if s==t:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n        continue\n    i = s.index('*')\n    if s[:i]==t[:i]:\n        s = s[i:]\n        t = t[i:]\n        s=s[::-1]\n        t = t[::-1]\n        i = s.index('*')\n        \n        if len(t)>=i and s[:i]==t[:i]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")\n    \n", "complexity": "linear", "problem": "1023_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "mecces, burgerKing, both, groupSize = map(int,input().strip().split(' '))\nmecces -= both\nburgerKing -= both\nnotPassed = groupSize - sum((mecces,burgerKing,both))\nif notPassed > 0 and burgerKing >= 0 and mecces >= 0:\n    print(notPassed)\nelse:\n    print(-1)", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import math\nn,k=map(int,input().split())\nfor _ in range(k):\n    l,r=map(int,input().split())\nfor i in range(1,n+1):\n    if i%2==0:\n        print('0',end='')\n    else:\n        print('1',end='')\nprint()\n\n", "complexity": "linear", "problem": "1004_B", "from": "CODEFORCES", "tags": "constructive algorithms,greedy,implementation,math"}
{"src": "I = lambda: map(int,input().split())\nn,l,r,x=I()\nC,k=[*I()],0\nfor i in range(2**n):\n    W = [w for w,b in zip(C, bin(i)[2:].zfill(n)) if b=='1']\n    \n    if l <= sum(W) <= r and max(W)-min(W) >= x:\n        k += 1\nprint(k)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "\nr,g,b = map(int,input().split())\nl1 = list(map(int,input().split()))\nl2 = list(map(int,input().split()))\nl3 = list(map(int,input().split()))\nl1.sort(reverse=True)\nl2.sort(reverse=True)\nl3.sort(reverse=True)\ndp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]\nans = 0\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            if i == 0 and j == 0:\n                dp[i][j][k] = 0\n            if j == 0 and k == 0:\n                dp[i][j][k] = 0\n            if i == 0 and k == 0:\n                dp[i][j][k] = 0\n            if i>0 and j>0 and k>0:\n                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])\n            else:\n                if i>0 and j>0:\n                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]\n                elif i>0 and k>0:\n                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]\n                elif j>0 and k>0:\n                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]\n            ans = max(ans,dp[i][j][k])\n                    \nprint(ans)\n                                   \n                \n            \n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "from sys import stdin\ninput=stdin.readline\ndef answer():\n    dp=[[[1e9 for i in range(k//2 + 1)] for j in range(m)] for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            dp[i][j][0]=0\n    \n    for x in range(1,k//2 + 1):\n\n        for i in range(n):\n            for j in range(m):\n\n                if(i > 0):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1] + c[i-1][j])\n                if(j > 0):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1] + r[i][j-1])\n                if(i + 1 < n):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1] + c[i][j])\n                if(j + 1 < m):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1] + r[i][j])\n\n    for i in range(n):\n        for j in range(m):\n            print(2*dp[i][j][-1],end=' ')\n\n        print()\n\n\n\nn,m,k=map(int,input().split())\n\nr=[list(map(int,input().split())) for i in range(n)]\nc=[list(map(int,input().split())) for i in range(n-1)]\n\nif(k & 1):\n    for i in range(n):\n        for j in range(m):\n            print(-1,end=' ')\n    \nelse:answer()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "n, v = map(int, input().strip().split())\nanswer = 0\nn -= 1\nif n <= v:\n    print(n)\nelse:\n    answer =v\n\n    for i in range(1,n-v + 1):\n\n        answer += (i + 1)\n    print(answer)", "complexity": "linear", "problem": "1113_A", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "# -*- coding: utf-8 -*-\n\ns = input()\nn,m = len(s),0\n\nfor i in range(n-1):\n    for j in range(i,n+1):\n        if len(s[i:j]) > m and s[i:j] in s[i+1:n]: m = len(s[i:j])\n    \nprint(m)\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "n, k = [int(i) for i in input().split()]\np = [int(i) for i in input().split()]\nans = [-1] * (max(p) + 1)\nans[0] = 0\nfor i in range(n):\n\tif ans[p[i]] < 0:\n\t\tposition = p[i] - k + 1\n\t\tfor j in range(max(0,p[i] - k + 1), p[i] + 1):\n\t\t\tif ans[j] < 0:\n\t\t\t\tposition = j\n\t\t\t\tbreak\n\t\tj = max(0, position - 1)\n\t\tkey = ans[j]\n\t\tcount = 0\n\t\twhile j >= 0:\n\t\t\tif ans[j] != key:\n\t\t\t\tposition1 = j + 1\n\t\t\t\tbreak\n\t\t\tj -= 1\n\t\t\tcount += 1\n\t\tif count + p[i] + 1 - position > k:\n\t\t\tkey = position\n\t\tfor j in range(position, p[i] + 1):\n\t\t\tans[j] = key\n\nfor i in range(n):\n\tif i != len(p) - 1:\n\t\twk1 = \" \"\n\telse:\n\t\twk1 = \"\\n\"\n\tprint(ans[p[i]], end = wk1)\n", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "arra = []\narrb = []\narr = []\ns = \"\"\ntemp = 1 \nvalue = ans = n = 0\n \ndef fill(myList = [], *args):\n    for i in range(n):\n        arra.insert(0,0)  \n        \ndef check():\n    for i,j in zip(arra,arrb):\n        if i == j:\n            return 1\n        else:\n            return 0\n\n        \ndef Engine1(num): \n    if num > 1: \n        Engine1(num // 2) \n    arra.append( num%2 )\ndef Engine2(num):\n    if num > 1: \n        Engine2(num // 2) \n    arrb.append( num%2 )\n\na,b = map(int,input().split())\nEngine1(a)\nEngine2(b)\n\nn = abs(len(arra)-len(arrb))\nif(len(arra)>len(arrb)):\n    fill(arrb)\nif(len(arra)<len(arrb)):\n    fill(arra)\n    \n\nfor i in range(len(arra)):\n    if(check() == 0):\n        break\n    check()\n    arra.pop(0)\n    arrb.pop(0)\n\nfor i in range(len(arra)):\n    ans += temp\n    temp *= 2\nprint(ans)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "def process(S):\n    n = len(S)\n    h_count = 0\n    answer = float('inf')\n    for c in S:\n        if c=='H':\n            h_count+=1\n    current = 0\n    for i in range(h_count):\n        if S[i]=='H':\n            current+=1\n    answer = min(answer, h_count-current)\n    for i in range(h_count, n+h_count):\n        if i > n-1:\n            i1 = i-n\n        else:\n            i1 = i \n        i2 = i-h_count\n        if S[i1]=='H':\n            current+=1\n        if S[i2]=='H':\n            current-=1\n        answer = min(answer, h_count-current)\n    return answer\n\nn = int(input())\nS = input()\nprint(process(S))", "complexity": "linear", "problem": "0046_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "# from typing import List, Set, Dict, Tuple, Text, Optional\nfrom collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__  # type: ignore\n\n#########\n# INPUT #\n#########\n\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n    # type: () -> str\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\n##########\n# OUTPUT #\n##########\n\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n    # type: (str) -> None\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n    # type: (str) -> None\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\n###########\n# LIBRARY #\n###########\n\n\ndef bootstrap(f, stack=[]):\n  # Deep Recursion helper.\n  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst\n  # Usage:\n\n  # @bootstrap\n  # def recur(n):\n  #   if n == 0:\n  #     yield 1\n  #   yield (yield recur(n-1)) * n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\n\n'''\narrayInit([3, 4, 5], 0):\nInitialize 3-dim array with [3][4][5] with 0 as its initial value\n\nTested with:\nhttps://codeforces.com/contest/625/problem/B\n'''\n\n\nclass MDArray(object):\n  # Faster implementation of md array, using a single array and a lot of math.\n  '''\n  >>> x = MDArray([1, 2, 5], 5)\n  >>> x.get([0, 0, 0])\n  5\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.set([0, 1, 2], 3)\n  3\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.set([0, 1, 3], 1)\n  1\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.get([0, 1, 3])\n  1\n  '''\n\n  def __init__(self, dimensions, initial_value=0):\n    # type: (Iterable[int], Any) -> None\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n    # type: (Iterable[int]) -> Any\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n    # type: (Iterable[int], Any) -> Any\n    self.arr[self._index(indexes)] = value\n    return value\n\n\n#########\n# LOGIC #\n#########\n\ndef encode(row, col, n, m):\n  return row * m + col\n\n\ndef solve(node, remain, adj, dp):\n  if remain == 0:\n    return 0\n  key = (node, remain)\n  mem = dp.get(key)\n  if mem != -1:\n    return mem\n\n  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))\n  dp.set(key, ans)\n  return ans\n\n\ndef main(inp, out):\n  # type: (Input, Output) -> any\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = MDArray([total_nodes, k+2], -1)\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(solve(node, k/2, adj, dp) * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\n\n###############\n# BOILERPLATE #\n###############\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "# https://codeforces.com/problemset/problem/701/C\n# two pointers method\n\n\ndef main():\n    n = int(input())\n    s = input()\n\n    u_set = set()\n    for i in s:\n        u_set.add(i)\n    u_cnt = len(u_set)\n\n    d = {}\n    j = 0\n    ans = 10**9\n    for i in range(n):\n        while len(d.keys()) < u_cnt and j < n:\n            d[s[j]] = d.get(s[j], 0) + 1\n            j += 1\n\n        if len(d.keys()) == u_cnt:\n            if j - i < ans:\n                ans = j - i\n        elif j == n:\n            break\n\n        d[s[i]] -= 1\n        if d[s[i]] == 0:\n            del d[s[i]]\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "n = int(input())\nm = input().split()\nt = []\nfor i in range(n):\n    m[i] = int(m[i])\n    if i == 0:\n        t.append(m[i]+1)\n    else:\n        t.append(max(t[i-1], m[i]+1))\ns = t[n-1] - m[n-1] - 1\nfor i in range(n-2, -1, -1):\n    if t[i] < t[i+1]-1:\n        t[i] = t[i+1]-1\n    s += t[i] - m[i] - 1\nprint(s)", "complexity": "linear", "problem": "0924_C", "from": "CODEFORCES", "tags": "data structures,dp,greedy"}
{"src": "n, k = [int(i) for i in input().split()]\na, j = sorted([int(i) for i in input().split()]), 0\nfor i in a:\n    while i > a[j]:\n        if i <= a[j] + k:\n            n -= 1\n        j += 1\nprint(n)", "complexity": "nlogn", "problem": "0990_B", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "# %matplotlib inline\n\ndef main():\n    n, k = [int(x) for x in input().split(' ')]\n    if k==1:\n        print(n)\n        return\n    a = []\n    b = {}\n    a = [int(x) for x in input().split(' ')]\n    a.sort()\n\n    a=dict(zip(a,range(n)))\n    count = {}\n\n    for x in a:\n        if x % k == 0 and int(x / k) in a:\n            b[x] = b[int(x / k)]\n            count[b[int(x / k)]] += 1\n        else:\n            b[x] = x\n            count[x] = 1\n\n    for x,y in count.items():\n        n -= int(y / 2)\n\n    print(n)\n\n\nmain()\n", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\n\nzl = getIntList()\nzr = getIntList()\n\nzt = [ (zl[i] + zr[i], i) for i in range(N) ]\nzt.sort()\nza = [0 for i in range(N) ]\nnow = N\nfor i in range(N):\n    if i>0 and zt[i-1][0] <zt[i][0]:\n        now-=1\n    za[ zt[i][1] ] = now\n\nfor i in range(N):\n    l = 0\n    r = 0\n    for j in range(i):\n        if za[j] > za[i]:\n            l+=1\n    for j in range(i+1, N):\n        if za[j] > za[i]:\n            r+=1\n    if zl[i] != l or zr[i] != r:\n        print('NO')\n        sys.exit()\nprint('YES')\nfor i in range(N):\n    print(za[i],end = ' ')\n\n\n\n\n", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "import sys\ninput=sys.stdin.buffer.readline\nn,m=map(int,input().split())\nfor i in range(n//2+n%2):\n    x1=i+1\n    x2=n-i\n    if(x1==x2):\n        for j in range(m//2+m%2):\n            if(j+1==m-j):\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n            else:\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(m-j)+\"\\n\"))\n    else:\n        if(i%2==0):\n            for j in range(m):\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(m-j)+\"\\n\"))\n        else:\n            for j in range(m):\n                sys.stdout.write((str(x1)+\" \"+str(m-j)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(j+1)+\"\\n\"))", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "def maxx(n):\n\treturn n&-n\nn,q=map(int,input().split())\nroot=n//2+1\nwhile q>0:\n\tx=int(input())\n\ts=input()\n\n\tfor i in s:\n\t\tif i=='U' and x!=root:\n\t\t\tp=x+maxx(x)\n\t\t\tif x==p-maxx(p)//2:\n\t\t\t\tx=p\n\t\t\telse:\n\t\t\t\tx=x-maxx(x)\n\t\telif i=='L':\n\t\t\tx=x-maxx(x)//2\n\t\telif i=='R':\n\t\t\tx=x+maxx(x)//2\n\tq=q-1\n\tprint(x)", "complexity": "np", "problem": "0792_D", "from": "CODEFORCES", "tags": "bitmasks,trees"}
{"src": "l,r=input().split(\" \")\nl,r=int(l),int(r)\n\na,b,c=l,l+1,l+2\n\nif (l % 2 != 0):\n    a,b,c=a+1,b+1,c+1\n    \nif (c > r):\n    print(-1)\n    \nelse:\n    print(a,b,c)", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "import sys, heapq\n\nn, x = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\nres = dict().fromkeys(set(arr), 0)\nfor i in arr:\n    res[i] += 1\ncan = False\nfor i in res:\n    if res[i] >= 2:\n        can = True\n        break\nif can:\n    print(0)\nelse:\n    res = dict().fromkeys([i for i in range(max(arr) + 1)])\n    for i in res:\n        res[i] = []\n    for i in range(n):\n        temp = set()\n        now = arr[i]\n        cnt = 0\n        while True:\n            added = False\n            before = len(temp)\n            temp.add(now)\n            after = len(temp)\n            if before == after:\n                break\n            heapq.heappush(res[now], cnt)\n            now = now & x\n            cnt += 1\n    ans = 9876543210\n    for i in res:\n        if len(res[i]) >= 2:\n            ans = min(ans, heapq.heappop(res[i]) + heapq.heappop(res[i]))\n    print(ans if ans != 9876543210 else -1)", "complexity": "linear", "problem": "1013_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "def main():\n    n, m = map(int, input().split())\n    w = [c == '*' for i in range(n) for c in input()]\n    nm = n * m\n    q = [*[range(i, i + m) for i in range(0, nm, m)],\n            *[range(i, nm, m) for i in range(m)]]\n    e = [1000] * nm\n    for f in True, False:\n        for r in q:\n            v = 0\n            for i in r:\n                if w[i]:\n                    v += 1\n                    if e[i] > v:\n                        e[i] = v\n                else:\n                    v = e[i] = 0\n        if f:\n            w.reverse()\n            e.reverse()\n    e = [c if c != 1 else 0 for c in e]\n    for f in True, False:\n        for r in q:\n            v = 0\n            for i in r:\n                if v > e[i]:\n                    v -= 1\n                else:\n                    v = e[i]\n                if v:\n                    w[i] = False\n        if f:\n            w.reverse()\n            e.reverse()\n    if any(w):\n        print(-1)\n    else:\n        r = []\n        for i, c in enumerate(e):\n            if c:\n                r.append(f'{i//m+1} {i%m+1} {c-1}')\n        print(len(r), '\\n'.join(r), sep='\\n')\n\n\nmain()", "complexity": "quadratic", "problem": "1015_E2", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "n = int(input())\nl = [4,7,47,74,444,447,474,477,747,744,774,777]\n\nfor i in l:\n    if n % i == 0:\n        print('YES')\n        break\n    else:\n        pass\nelse:\n    print('NO')\n    \n        \n\n\n\n            \n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "\nn=int(input())\narr=[]\nfor i in range(n):\n    arr.append(input())\n\narr.sort(key=lambda x: len(x))\nflag=False\nfor i in range(n-2,-1,-1):\n    if arr[i] not in arr[i+1]:\n        flag=True\n        break\n\nif flag:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in arr:\n        print(i)", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "n=input()\ni=0\nwhile(True):\n    if (n-9*10**i*(i+1))<=0:\n        break\n    n-=9*10**i*(i+1)\n    i+=1\n\na=n/(i+1)\nb=n%(i+1)\nif(b!=0):\n    print(str(10**i+a)[b-1])\nelse:\n    print(str(10**i+a-1)[-1])\n", "complexity": "constant", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "n = int(input())\nr = 0\ni = 2\nwhile i*2 <=n:\n\ta = int(n/i)\n\tr += (a+2)*(a-2+1)/2\n\ti += 1\nprint(int(4*r))\n", "complexity": "linear", "problem": "1062_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation,math"}
{"src": "from sys import stdin\ninput = stdin.buffer.readline\n \nn,k=map(int,input().split())\narr=[int(x) for x in input().split()]\n \nl=[]\nfor i in range(n):\n    l.append((arr[i],i))\n \nl.sort(reverse=True)\n \ndp=[]\nx=0\nfor i in range(k):\n    dp.append(l[i][1])\n    x=x+l[i][0]\n \nprint(x)\ndp.sort()\ndp=[-1]+dp\n \nl=len(dp)\nfor i in range(1,l-1):\n    print(dp[i]-dp[i-1],end=\" \")\nprint(n-1-dp[l-2])    ", "complexity": "nlogn", "problem": "1006_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "'''\n\n                            Online Python Compiler.\n                Code, Compile, Run and Debug python program online.\nWrite your code in this editor and press \"Run\" button to execute it.\n\n'''\n\ntot, choc = [int(i) for i in input().split()]\n\n# add = 0\n# mid = tot\nbg = 1\nend = tot\n\nwhile True:\n    mid = (bg + end) / 2\n    add = (mid * (mid + 1)) / 2\n    sub = tot - mid\n    if add - sub == choc:\n        print(int(sub))\n        break\n    if add - sub < choc:\n        bg = mid + 1\n    else:\n        end = mid - 1\n    \n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "\nn=int(input())\ns=list(input())\nt=list(input())\nd={}\nans=0\nx,y=-1,-1\nfor i in range(n):\n\tif s[i]!=t[i]:\n\t\td[(s[i],t[i])]=i\n\t\tans+=1\nl=[chr(i+97) for i in range(26)]\nfor i in l:\n\tfor j in l:\n\t\tif (i,j) in d and (j,i) in d:\n\t\t\tans-=2\n\t\t\tx=d[(i,j)]+1\n\t\t\ty=d[(j,i)]+1\n\t\t\tbreak\n\tif x!=-1:\n\t\tbreak\nif x==y==-1:\n\tfor i in l:\n\t\tfor j in l:\n\t\t\tfor k in l:\n\t\t\t\tif (i,j) in d and (j,k) in d:\n\t\t\t\t\tans-=1\n\t\t\t\t\tx=d[(i,j)]+1\n\t\t\t\t\ty=d[(j,k)]+1\n\t\t\t\t\tbreak\n\t\tif x!=-1:\n\t\t\tbreak\nprint(ans)\nprint(x,y)", "complexity": "linear", "problem": "0527_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "def matches(pos, c, case):\n    if case==0:\n        return pos%3==\"RGB\".index(c)\n    elif case==1:\n        return pos%3==\"GBR\".index(c)\n    else:\n        return pos%3==\"BRG\".index(c)\n\nq = int(input())\nfor _ in range(q):\n    n, k = map(int, input().split())\n\n    s = input()\n\n    mglobal = k\n\n    r=g=b=0\n\n    for i, c in enumerate(s[:k]):\n            \n        r += not matches(i, c, 0)\n        g += not matches(i, c, 1)\n        b += not matches(i, c, 2)\n    \n    mglobal = min([mglobal, r, g, b])\n    for i, c in enumerate(s[k:]):\n        i+=k\n        r += -(not matches(i-k, s[i-k], 0)) + (not matches(i, c, 0))    \n        g += -(not matches(i-k, s[i-k], 1)) + (not matches(i, c, 1))    \n        b += -(not matches(i-k, s[i-k], 2)) + (not matches(i, c, 2))    \n    \n        mglobal = min([mglobal, r, g, b])\n\n    print(mglobal)\n", "complexity": "linear", "problem": "1196_D1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\na = list(map(int, input().split()))[::-1]\nb = list(map(int, input().split()))\nans = [0] * n\nmarked = [True] * (n + 1)\nfor i in range(n):\n    if marked[b[i]]:\n        while True:\n            marked[a[-1]] = False\n            ans[i] += 1\n            if a[-1] == b[i]:\n                a.pop()\n                break\n            a.pop()\n    else:\n        continue\nprint(*ans)", "complexity": "quadratic", "problem": "1073_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key,lru_cache\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nimport sys\n# input = sys.stdin.readline\n \nM = mod = 10 ** 9 + 7\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\ndef li2():return [str(i)[2:-1] for i in input().rstrip().split()]\ndef li3():return [int(i) for i in st()]\n\n\n\nn = val()\nl = li()\nc = li()\n\nelement = l[0]\nfor i in range(1, n):element = math.gcd(element, l[i])\n\nif element != 1:\n    print(-1)\n    exit()\n    \nmyset = {}\n\nfor ind, i in enumerate(l):\n    for j in list(myset):\n        temp = math.gcd(j, i)\n        if(temp not in myset):myset[temp] = myset[j] + c[ind]\n        else:myset[temp] = min(myset[temp], c[ind] + myset[j])\n    \n    if i not in myset:myset[i] = c[ind]\n    else:myset[i] = min(myset[i], c[ind])\n\nprint(myset[1])", "complexity": "np", "problem": "0510_D", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,math"}
{"src": "n,m = map(int, input().split())\nb = [int(s) for s in input().split()]\ng = [int(s) for s in input().split()]\nans = 0\nmaxb2, maxb = sorted(b)[-2:]\nming = min(g)\nif maxb > ming:\n    ans = -1\nelse:\n    ans += sum(b)*m\n    ans += (sum(g)-ming)-(maxb*(m-1))\n    if ming > maxb:\n        ans += ming-maxb2\nprint(ans)", "complexity": "nlogn", "problem": "1159_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nans = []\n\n\ndef check(mid: int) -> bool:\n    global ans\n    dic = {}\n    for i in range(n):\n        bit = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                bit += 1\n            bit <<= 1\n        dic[bit >> 1] = i\n    for x, idx in dic.items():\n        for y, idy in dic.items():\n            if x | y == 2**m-1:\n                ans = idx + 1, idy + 1\n                return True\n    return False\n\n\nle = 0\nri = int(1e9)\nwhile le <= ri:\n    mid = (le + ri) >> 1\n    if check(mid):\n        le = mid + 1\n    else:\n        ri = mid - 1\nprint(ans[0], ans[1])\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "def f(n,s):\n    d=[-n,-n];\n    d[s]=0;\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)];\n    return d[s];\nimport math;\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny=y+x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": " ### @author Juan Sebastian Beltran Rojas \n ### @mail jsbeltran.valhalla@gmail.com \n ### @veredict \n ### @url https://codeforces.com/problemset/problem/1195/B\n ### @category \n ### @date 12/11/2019\n\nimport math\n\nline = input().split()\nN = int(line[0])\nK = int(line[1])\n\nn = (-3 + math.sqrt(9+4*(2*N+2*K)))/2\n\nprint(int(N-n))\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n,m,a,b=[int(x) for x in input().split()]\nif n>m:\n\tif n%m==0:\n\t\tprint(0)\n\telse:\n\t\tt1=n%m\n\t\tprint(min(t1*b,(m-t1)*a))\nelif n==m:\n\tprint(0)\nelse:\n\tprint(min(n*b,(m-n)*a))", "complexity": "linear", "problem": "0990_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "from math import ceil\n\nn=int(input())\nd={1:[1],2:[1,2],3:[1,1,3]}\nif n in d:\n    for i in d[n]:\n        print(i,end=' ')\n    exit()\ndef f(n):\n    if n in d:\n        return d[n]\n    odds=ceil(n/2)\n    lis=[1]*odds\n    even=n//2\n    lis1=f(even)\n    for i in range(len(lis1)):\n        lis1[i]*=2\n    return lis+lis1\nans=f(n)\nfor i in ans:\n    print(i,end=' ')", "complexity": "nlogn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "x,k = map(int,input().split())\nmod = 10**9 + 7\nif x == 0:\n    print(0)\nelse:\n    print(((2*x-1)*pow(2,k,mod) + 1)%mod)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n\nn = ria()[0]\nif n == 1:\n    print(1)\n    exit(0)\n\nif n == 2:\n    print(1, 2)\n    exit(0)\n\nif n == 3:\n    print(1, 1, 3)\n    exit(0)\n\nar = [0] * 30\n\nfor i in range(30):\n    ar[i] = n // (2 ** i) - n // (2 ** (i + 1))\nsd = 0\nfor i in range(30):\n    if sd == n - 1:\n        if n==(2**i):\n            print(2**i)\n        else:\n            print(n-n%(2**(i-1)))\n        exit(0)\n    for j in range(ar[i]):\n        print(2 ** i, end=' ')\n        sd += 1\n", "complexity": "linear", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\n\ndef check(a,mid,n,m,z):\n    b=Counter()\n    for i in range(n):\n        c=[\"0\"]*m\n        for j in range(m):\n            if a[i][j]>=mid:\n                c[j]=\"1\"\n        zz=int(\"\".join(c),2)\n        b[zz]=i\n    c=list(b.keys())\n    lc=len(c)\n    for i in range(lc):\n        for j in range(i,lc):\n            if c[i]|c[j]==z:\n                mi,x,y=10000000000,b[c[i]],b[c[j]]\n                for k in range(m):\n                    mi=min(mi,max(a[x][k],a[y][k]))\n                if mi>=mid:\n                    return (x,y)\ndef main():\n    n,m= map(int, input().split())\n    a=[list(map(int,input().split())) for _ in range(n)]\n    lo,hi,ans,y=0,10**9,[1,1],(1<<m)-1\n    while lo<=hi:\n        mid=(lo+hi)//2\n        z=check(a,mid,n,m,y)\n        if z:\n            lo=mid+1\n            ans=[z[0]+1,z[1]+1]\n        else:\n            hi=mid-1\n    print(*ans)\n# (region fastio\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "from sys import stdout, stdin, setrecursionlimit\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom bisect import *\nfrom string import *\nfrom queue import *\nfrom heapq import *\nfrom math import *\nfrom re import *\nfrom os import *\n\n####################################---fast-input-output----#########################################\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ndef fast(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in fast().split()]\n\n\nz, zz = fast, lambda: (map(int, z().split()))\nszz, graph, mod, szzz = lambda: sorted(\n    zz()), {}, 10**9 + 7, lambda: sorted(zzz())\n\n\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\n\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\n\n\n#################################################---Some Rule For Me To Follow---#################################\n\"\"\"\n    --instants of Reading problem continuously try to understand them.\n\n    --If you Know some-one , Then you probably don't know him !\n\n    --Try & again try\n\n\"\"\"\n##################################################---START-CODING---###############################################\n\n\n\nn, m = zz()\narr = zzz()\ns = sum(arr)\nx = [[] for i in range(m)]\nfor i in range(n): x[arr[i] % m].append(i)\nj = 0\nfor i in range(m):\n    while len(x[i]) > n // m:\n        while j < i or len(x[j % m]) >= n // m: j += 1\n        k = x[i].pop()\n        arr[k] += (j - i) % m\n        x[j % m].append(k)\nprint(sum(arr) - s)\nprint(*arr)\n", "complexity": "linear", "problem": "0999_D", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "# %matplotlib inline\n\ndef main():\n    n, k = [int(x) for x in input().split(' ')]\n    if k==1:\n        print(n)\n        return\n    a = []\n    b = {}\n    a = [int(x) for x in input().split(' ')]\n    a.sort()\n\n    a=dict(zip(a,range(n)))\n    count = {}\n\n    for x in a:\n        if x % k == 0 and int(x / k) in a:\n            b[x] = b[int(x / k)]\n            count[b[int(x / k)]] += 1\n        else:\n            b[x] = x\n            count[x] = 1\n\n    for x,y in count.items():\n        n -= int(y / 2)\n\n    print(n)\n\n\nmain()\n", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "n = int(input())\na = [int(i) for i in input().split()]\na.sort()\ncount = 0\nfor i in range(n):\n    cur_c = a[i]\n    if not cur_c:\n        continue\n    count += 1\n    for j in range(i+1,n):\n        if a[j]%cur_c == 0:\n            a[j] = 0\nprint(count)", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "n=int(input())\nif n==1:\n    print(1)\nelse:\n    p=list(map(int,input().split()))\n    children=[]\n    for i in range(n):\n        children.append([])\n    for i in range(n-1):\n        children[p[i]-1].append(i+1)\n    layers=[1]+[0]*(n-1)\n    layer=[0]\n    num=2\n    bylayer=[]\n    while len(layer)>0:\n        bylayer.append(layer)\n        newlayer=[]\n        for vert in layer:\n            for child in children[vert]:\n                layers[child]=num\n                newlayer.append(child)\n        layer=newlayer\n        num+=1\n    bylayer=bylayer[::-1]\n    count=[0]*n\n    for layer in bylayer:\n        for vert in layer:\n            if children[vert]==[]:\n                count[vert]=1\n            else:\n                count[vert]=sum(count[v] for v in children[vert])\n    count.sort()\n    out=\"\"\n    for guy in count:\n        out+=str(guy)+\" \"\n    print(out)", "complexity": "quadratic", "problem": "1056_D", "from": "CODEFORCES", "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"}
{"src": "n, m, k = map(int,input().split())\nline = [int(x) for x in input().split()]\nline.sort(reverse = True)\ncount = 0\nif k >=m:\n    print(count)\n    exit(0)\nfor i in range(n):\n    k += line[i]-1\n    count += 1\n    if k >= m:\n        print(count)\n        exit(0)\nprint(-1)", "complexity": "nlogn", "problem": "0257_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import math\n\n\na, b = [int(x) for x in input().split()]\nwhile a != 0 and b != 0:\n    x = int(math.log(a, 2))\n    y = int(math.log(b, 2))\n    if x != y:\n        break\n    a = a & (~(1 << x))\n    b = b & (~(1 << y))\n\nif a == 0 and b == 0:\n    print(0)\nelse:\n    if b > a:\n        a, b = b, a\n    x = int(math.log(a, 2)) + 1\n    b = (1 << x) - 1\n    a = a | b\n    print(a)\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "R, G, B = map(int, input().split())\nL = [sorted(map(int, input().split())) for _ in range(3)]\n \nDP = [0] * ((R+1) * (G+1) * (B+1))\ndef idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b\n \nfor r in range(R+1):\n\tfor g in range(G+1):\n\t\tfor b in range(B+1):\n\t\t\tbest = 0\n \n\t\t\tif r:\n\t\t\t\tif g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]\n\t\t\t\tif b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])\n \n\t\t\tif g and b:\n\t\t\t\tbest = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])\n \n\t\t\tDP[idx(r, g, b)] = best\n \nprint(max(DP))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import math\ns1=str(input())\ns2=str(input())\nd1=0;d2=0;n=0\nanswer=0\nfor i in s1:\n    if i=='+':d1+=1\n    else:\n        d1-=1\nfor i in s2:\n    if i=='+':d2+=1\n    elif i=='?':n+=1\n    else:\n        d2-=1\nif n>=abs(d2-d1):\n    y=(n-abs(d1-d2))/2\n    if y%1==0:\n        answer=math.factorial(n)/math.factorial(n-y)/math.factorial(y)/2**n\nprint('%.9f'%answer)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "# _\n#####################################################################################################################\n\ndef main():\n    pieces_Dimension = int(input())\n    piece1 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece2 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece3 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece4 = ''.join(input() for _ in range(pieces_Dimension))\n\n    brokenPieces = (piece1, piece2, piece3, piece4)\n    nSquares = pieces_Dimension*pieces_Dimension\n    squares = '01'*-(-nSquares//2)\n\n    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)\n\n\ndef nSquaresToRecolorIn(brokenPieces, nSquares, squares):\n    possible_nSquares = [(sum(piece[i] != squares[:-1][i] for i in range(nSquares)),\n                          sum(piece[i] != squares[1:][i] for i in range(nSquares)))\n                         for piece in brokenPieces]\n    possible_nSquares.sort(key=lambda x: x[0])\n\n    return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1]\n\n\nif __name__ == '__main__':\n    print(main())\n    # main()\n", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn,k=map(int,input().split())\n\nMIN=0\nMAX=n\n\nwhile True:\n    ANS=(MIN+MAX)//2\n    \n    if (n-ANS)*(n-ANS+1)//2-ANS>k:\n        MIN=ANS+1\n    elif (n-ANS)*(n-ANS+1)//2-ANS<k:\n        MAX=ANS-1\n    else:\n        print(ANS)\n        break\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "l,r = map(int,input().split())\n\nx = 64\nwhile x>=0 and  (l&(1<<x)) == (r&(1<<x)):\n    x-=1\nprint((1<<(x+1))-1)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport collections\nimport itertools\nimport bisect\nimport heapq\n# sys.setrecursionlimit(100000)\n# ^^^TAKE CARE FOR MEMORY LIMIT^^^\nimport random\n\n\ndef main():\n    pass\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\n\ndef decimal(s):\n    return (int(s, 2))\n\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n //= 2\n        p += 1\n    return (p)\n\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\ndef primeFactorsCount(n):\n    cnt=0\n    while n % 2 == 0:\n        cnt+=1\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            cnt+=1\n            n = n // i\n    if n > 2:\n        cnt+=1\n    return (cnt)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\n\ndef countcon(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if (s[i] == ch):\n            c += 1\n        else:\n            break\n    return (c)\n\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\n\n\ndef isSubSequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\n\n\ndef maxfac(n):\n    root = int(n ** 0.5)\n    for i in range(2, root + 1):\n        if (n % i == 0):\n            return (n // i)\n    return (n)\n\n\ndef p2(n):\n    c = 0\n    while (n % 2 == 0):\n        n //= 2\n        c += 1\n    return c\n\n\ndef seive(n):\n    primes = [True] * (n + 1)\n    primes[1] = primes[0] = False\n    i = 2\n    while (i * i <= n):\n        if (primes[i] == True):\n            for j in range(i * i, n + 1, i):\n                primes[j] = False\n        i += 1\n    pr = []\n    for i in range(0, n + 1):\n        if (primes[i]):\n            pr.append(i)\n    return pr\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\n\ndef denofactinverse(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (pow(fac, m - 2, m))\n\n\ndef numofact(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (fac)\n\ndef sod(n):\n    s = 0\n    while (n > 0):\n        s += n % 10\n        n //= 10\n    return s\nx,k=map(int,input().split())\nmod=1000000007\ntp=pow(2,k+1,mod)\ntp2=pow(2,k,mod)\nans=(tp*x-tp2+1)%mod\nprint(ans if x!=0 else 0)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "#!/usr/bin/env python3\nimport sys\ndef ask(i):\n    print('?', i + 1)\n    sys.stdout.flush()\n    a_i = int(input())\n    return a_i\ndef answer(i):\n    print('!', i + 1 if i != -1 else -1)\n    sys.exit()\n\ndef has_intersection(l1, r1, l2, r2):\n    if l1 <= l2 and r2 <= r1:\n        return True\n    if l2 <= l1 and r1 <= r2:\n        return True\n    return False\n\nn = int(input())\nassert n >= 2 and n % 2 == 0\nif (n // 2) % 2 == 1:\n    answer(-1)\nelse:\n    assert n % 4 == 0\n    l1 = 0\n    r1 = n // 2\n    a_l1 = ask(l1)\n    a_r1 = ask(r1)\n    if a_l1 == a_r1:\n        answer(0)\n    a_l2 = a_r1\n    a_r2 = a_l1\n    # print('binary search [', l1, ',', r1, ') ->', (l1 + r1) // 2, file=sys.stderr)\n    while True:\n        m1 = (l1 + r1) // 2\n        m2 = (m1 + n // 2) % n\n        a_m1 = ask(m1)\n        a_m2 = ask(m2)\n        if a_m1 == a_m2:\n            answer(m1)\n        if has_intersection(a_l1, a_m1, a_l2, a_m2):\n            r1 = m1\n            a_r1 = a_m1\n            a_r2 = a_m2\n        else:\n            assert has_intersection(a_m1, a_r1, a_m2, a_r2)\n            l1 = m1\n            a_l1 = a_m1\n            a_l2 = a_m2\n        # print('binary search [', l1, ',', r1, ') ->', (l1 + r1) // 2, file=sys.stderr)\nassert False\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "from collections import deque\nn, d, k = map(int, input().split())\nif n==1:\n    print('NO')\n    exit(0)\nif n==2:\n    if d>1:\n        print('NO')\n    else:\n        print('YES')\n        print(1, 2)\n    exit(0)\nif (not 2<=d<=n-1) or k==1:\n    print('NO')\n    exit(0)\nans = []\nfor i in range(d):\n    ans.append((i+1, i+2))\nnow = d+2\nfor i in range(d-1):\n    q = deque([(i+2, min(i, d-i-2))])\n    first = True\n    while q and len(ans)<n-1:\n        node, depth = q.popleft()\n        end = now+k-1\n        if first:\n            end -= 1\n        for j in range(now, end):\n            ans.append((node, j))\n            if len(ans)==n-1:\n                break\n            if depth>0:\n                q.append((j, depth-1))\n        now = end\n        first = False\n\nif len(ans)==n-1:\n    print('YES')\n    for i, j in ans:\n        print(i, j)\nelse:\n    print('NO')", "complexity": "quadratic", "problem": "1003_E", "from": "CODEFORCES", "tags": "constructive algorithms,graphs"}
{"src": "def reach_max(n, k):\n    return n * k + 1 - n * (n + 1) // 2\n\n\nn, k = map(int, input().split())\n\nif n == 1:\n    print(0)\n    exit()\n\nlo, hi = 1, k - 1\n\nif n > reach_max(hi, k):\n    print(-1)\n    exit()\n\n\nwhile lo < hi:\n    mid = (lo + hi) // 2\n    if reach_max(mid, k) < n:\n        lo = mid + 1\n    else:\n        hi = mid\n\nprint(lo)\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "n=int(input())\nd={\"purple\":\"Power\",\"green\":\"Time\",\"blue\":\"Space\",\"orange\":\"Soul\",\"red\":\"Reality\",\"yellow\":\"Mind\"}\nl=[]\nfor i in range(n):\n    s=input()\n    l.append(s)\nprint(6-n)\nfor i in d:\n    if i not in l:\n        print(d[i])", "complexity": "constant", "problem": "0987_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n,k=map(int,input().split())\narr=list(map(int,input().split()))\nd={}\nfor i in arr:\n\tif i in d:\n\t\td[i]+=1\n\telse:\n\t\td[i]=1\nflag=True\nfor i in range(100,0,-1):\n\tt2=0\n\tfor j in d.values():\n\t\tt2+=j//i\n\tif(t2>=n):\n\t\tprint(i)\n\t\tflag=False\n\t\tbreak\nif(flag):\n\tprint(0)", "complexity": "nlogn", "problem": "1011_B", "from": "CODEFORCES", "tags": "binary search,brute force,implementation"}
{"src": "n, k = map(int, input().split())\nif n == 1:\n    print(0)\nelif (k*k -k)//2 +1 < n:\n    print(-1)\nelse:\n    g, b = 0, k//2\n    while b != 0:\n        while g +b <= k and (k*k -k)//2 +1 -((g +b)**2 -(g +b))//2 >= n:\n            g += b\n        b //= 2\n    print(k -g)\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "'''\n    Auther: ghoshashis545 Ashis Ghosh\n    College: Jalpaiguri Govt Enggineering College\n\n'''\nfrom os import path\nfrom io import BytesIO, IOBase\nimport sys\nfrom heapq import heappush,heappop\nfrom functools import cmp_to_key as ctk\nfrom collections import deque,Counter,defaultdict as dd \nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input().rstrip()\ndef mi():return map(int,input().split())\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef bo(i):\n    return ord(i)-ord('0')\n\nfile = 1\ndef ceil(a,b):\n    return (a+b-1)//b\n\n\n\n\ndef solve():\n\n    \n    # for _ in range(1,ii()+1):\n      \n    l,r = mi()\n    s1 = bin(l)[2:]\n    s2 = bin(r)[2:]\n    if len(s1) != len(s2):\n      print((1<<len(s2))-1)\n      return\n    \n    x = 0\n    for i in range(62,-1,-1):\n      if ((l>>i)&1)^((r>>i)&1):\n        x +=(1<<(i+1))\n        x -=1\n        break\n    print(x)\n\n\n\n\n\n\n\n\n            \n\n\n\n\n\n    \n        \n\n\n\n\n\n\n\n\n        \nif __name__ ==\"__main__\":\n\n    if(file):\n    \n       if path.exists('input.txt'):\n           sys.stdin=open('input.txt', 'r')\n           sys.stdout=open('output.txt','w')\n       else:\n           input=sys.stdin.readline\n    solve()\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "k=int(input())\ni=0\nr=1\nwhile(k>=r):\n    r+=9*(i+1)*10**i\n    i+=1\nr=r-(9*i*10**(i-1))\nans=str(((k-r)//i)+10**(i-1))[(k-r)%i]\nprint(ans)", "complexity": "constant", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "from _collections import deque\nn = int(input())\nm = list(map(int, input().split()))\na = []\nb = deque()\n \ni = 1\nfor x in m:\n    a.append((x, i))\n    i += 1\na.sort(key=lambda p: -p[0])\n \ns = input()\nans = []\n \nfor x in s:\n    if x == \"1\":\n        v = b.pop()\n        ans.append(v[1])\n    else:\n        v = a.pop()\n        ans.append(v[1])\n        b.append(v)\nprint(*ans)", "complexity": "nlogn", "problem": "0982_B", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "import math\nk, n, s, p = map(int, input().split())\nsheets = math.ceil(n/s) * k\nprint(math.ceil(sheets/p))\n \t  \t\t\t\t\t\t\t\t\t\t  \t \t\t \t\t\t\t", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import heapq\n\n\ndef read_int():\n    return int(input().strip())\n\n\ndef read_ints():\n    return list(map(int, input().strip().split(' ')))\n\n\ndef solve():\n    '''\n    8 8 8 8 8 8\n    9 9\n    9 9\n\n    81+81\n\n    72+72+72+72\n    '''\n    R, G, B = read_ints()\n    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]\n    # dp[R][G][B]\n    Rs = read_ints()\n    Gs = read_ints()\n    Bs = read_ints()\n    Rs.sort(reverse=True)\n    Gs.sort(reverse=True)\n    Bs.sort(reverse=True)\n    answer = 0\n    for r in range(R+1):\n        for g in range(G+1):\n            for b in range(B+1):\n                if r > 0 and g > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])\n                if g > 0 and b > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])\n                if r > 0 and b > 0:\n                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])\n                answer = max(answer, dp[r][g][b])\n    return answer\n\n\nif __name__ == '__main__':\n    print(solve())\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "d = {\"purple\":\"Power\", \"green\":\"Time\", \"blue\":\"Space\", \"orange\":\"Soul\", \"red\":\"Reality\", \"yellow\":\"Mind\"}\ns = set()\nn = int(input())\nfor _ in range(n):\n\tw = input()\n\ts.add(w)\nprint(6 - n)\nfor (key, value) in d.items():\n\tif key not in s:\n\t\tprint(value)\n ", "complexity": "constant", "problem": "0987_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nwhile len(a) > 0:\n    k = a.pop(0)\n    a = [i for i in a if i % k != 0]\n    ans += 1\n\nprint(ans)\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "n = int(input())\nl = [0]+list(map(int,input().split()))\nfrom collections import defaultdict\nans = ['A','B']\nx = defaultdict(int)\ntable = [-1]*(n+1)\nfor i in range(1,n+1):\n\tx[l[i]] = i\n\ntable[x[n]] = 1\nfor i in range(n-1,0,-1):\n\tif(x[i]-i>0):\n\t\tfor j in range(x[i],0,-i):\n\t\t\tif(l[j]>i):\n\t\t\t\tif(table[j]==1):\n\t\t\t\t\ttable[x[i]] = 0\n\t\t\t\t\tbreak\n\tif(n-i>0 and table[x[i]]==-1):\n\t\tfor j in range(x[i],n+1,i):\n\t\t\tif(l[j]>i):\n\t\t\t\tif(table[j]==1):\n\t\t\t\t\ttable[x[i]] = 0\n\t\t\t\t\tbreak\n\n\tif(table[x[i]]==-1):\n\t\ttable[x[i]] = 1\n\nfor i in table[1:]:\n\tprint(ans[i],end='')", "complexity": "linear", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "n = int(input())\n\nlst = []\nfor x in range(n):\n    (a, b) = map(int, input().split())\n    lst.append((a, b))\n\ndef scal(x1, y1, x2, y2, x3, y3):\n    if (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1) == 0:\n        return True\n    return False\n\ndef check():\n    for x in range(n - 2):\n        if len(s2) >= 3:\n            if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):\n                return False\n        if scal(lst[0][0], lst[0][1], lst[1][0], lst[1][1], lst[x + 2][0], lst[x + 2][1]):\n            s1.append(x + 2)\n        else:\n            s2.append(x + 2)\n    if len(s2) >= 3:\n        if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):\n            return False\n    return True\n\nflag = True\n\nif n >= 5:\n    s1 = []\n    s2 = []\n    if not check():\n        lst[1], lst[s2[0]] = lst[s2[0]], lst[1]\n        x = s2[0]\n        s1 = []\n        s2 = []\n        if not check():\n            lst[0], lst[s2[0]] = lst[s2[0]], lst[0]\n            s1 = []\n            s2 = []\n            if not check():\n                flag = False\n\nif flag:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "nlogn", "problem": "0961_D", "from": "CODEFORCES", "tags": "geometry"}
{"src": "n, m = list(map(int, input().split()))\ncl = []\nfor i in range(n):\n  cl.append(input())\n\ndef is_squad(x, y):\n  if cl[x][y]=='#' and cl[x+1][y]=='#' and cl[x+2][y]=='#' and cl[x+2][y+1]=='#' and cl[x+2][y+2]=='#' and cl[x+1][y+2]=='#' and cl[x][y+2]=='#' and cl[x][y+1]=='#':\n    return True\n  else:\n    return False\n\ndef cv(x, y):\n  counter = 0\n  if x-2>=0 and y+2<=m-1 and is_squad(x-2, y):\n    return True\n   \n  elif x-1>=0 and x+1<=n-1 and y+2<=m-1 and is_squad(x-1, y):\n    return True\n\n  elif x+2<=n-1 and y+2<=m-1 and is_squad(x, y):\n    return True\n  \n  elif x+2<=n-1 and y+1<=m-1 and y-1>=0 and is_squad(x, y-1):\n    return True\n\n  elif x+2<=n-1 and y-2>=0 and is_squad(x, y-2):\n    return True\n\n  elif x+1<=n-1 and x-1>=0 and y-2>=0 and is_squad(x-1, y-2):\n    return True\n\n  elif x-2>=0 and y-2>=0 and is_squad(x-2, y-2):\n    return True\n\n  elif x-2>=0 and y-1>=0 and y+1<=m-1 and is_squad(x-2, y-1):\n    return True\n  else:\n    return False\n  \n\n  \n\n  \n  \n\nfor i in range(n):\n  for j in range(m):\n    if cl[i][j]=='#':\n      if not cv(i, j):\n        print('NO')\n        exit()\n\nprint('YES')", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from sys import stdin\ninput=stdin.readline\ndef check(mid,a,limit):\n\tres=[]\n\ts=0\n\tfor r,t,id in a:\n\t\tif r>=mid and t+s<=limit:\n\t\t\tres.append(id+1)\n\t\t\ts+=t\n\t\telif t+s>limit:\n\t\t\tbreak\n\t\tif len(res)==mid:\n\t\t\tbreak\n\t# print(res,s)\n\treturn res\n\ndef f(a,limit):\n\ta.sort(key=lambda s:s[1])\n\tans=None\n\tlo=0\n\thi=len(a)+1\n\twhile lo<=hi:\n\t\tmid=(lo+hi)//2\n\t\tres=check(mid,a,limit)\n\t\tif len(res)>=mid:\n\t\t\tlo=mid+1\n\t\t\tans=(res,mid)\n\t\telse:\n\t\t\thi=mid-1\n\tprint(ans[1])\n\tprint(ans[1])\n\tprint(*ans[0])\n\n\nn,limit=map(int,input().strip().split())\nq=[]\nfor i in range(n):\n\tx,y=map(int,input().strip().split())\n\tq.append((x,y,i))\nf(q,limit)", "complexity": "nlogn", "problem": "0913_D", "from": "CODEFORCES", "tags": "binary search,brute force,data structures,greedy,sortings"}
{"src": "def solve():\n    n, k = list(map(lambda x: int(x), input().split()))\n    upper_bound = n+1\n    lower_bound = -1\n    while upper_bound > lower_bound + 1:\n        m = (upper_bound + lower_bound) // 2\n        if (n - m) * (n - m + 1) // 2 - m > k:\n            lower_bound = m\n        else:\n            upper_bound = m\n    print(upper_bound)\n\nsolve()\n\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "\ndef f(n):\n    return n + n//2\n        \n        \nn = int(input())\nprint(f(n))\n", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "t = int(input())\n\ndef sol(n, k):\n    p = 1\n    q = 1\n    acc = 0\n    while n > 0 and k >= p:\n#        print(\"itr\", k, n, p, q)\n        k -= p\n        n -= 1\n        if n >= 40:\n            return n\n        acc += q*(4**n-1)//3\n#        print(\"k<=acc\", k, acc)\n        if k <= acc:\n            return n\n        p = 2*p+1\n        q = 2*q+3\n    return -1\n\nfor _ in range(t):\n    n, k = (int(v) for v in input().split())\n    ans = sol(n, k)\n    if ans == -1:\n        print(\"NO\")\n    else:\n        print(\"YES\", ans)\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "x,k=map(int,input().split())\nmod=1000000007\nif x==0: print(0)\nelse:\n    print((x*pow(2,(k+1),mod)-pow(2,k,mod)+1)%mod)\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "from sys import stdin\nMOD = 1000000007\ns = stdin.readline().strip()\nn = len(s)\nbuc = [0] * 101\nfac = [0] * (n + 1)\ninv = [0] * (n + 1)\ndp = [0] * (n + 1)\n# temp_dp = [0] * (n+1)\nans = [[0] * 55 for _ in range(55)]\n\n\ndef find(c: 'str') -> 'int':\n    if 'A' <= c <= 'Z':\n        return ord(c) - ord('A') + 26\n    else:\n        return ord(c) - ord('a')\n\n\ndef add(a: 'int', b: 'int') -> 'int':\n    a += b\n    if a >= MOD:\n        a -= MOD\n    return a\n\n\ndef sub(a: 'int', b: 'int') -> 'int':\n    a -= b\n    if a < 0:\n        a += MOD\n    return a\n\n\n# c = Counter(s)\n\n# # store frequency\n# for k in c.keys():\n#     buc[find(k)] = c[k]\n\nfor i in s:\n    buc[find(i)] += 1  # naive count is fater than counter\n\n# compute factorial and inv\n\nfac[0] = 1\nfor i in range(1, n + 1):\n    fac[i] = (fac[i - 1] * i) % MOD\ninv[n] = pow(fac[n], MOD - 2, MOD)\nfor i in range(n - 1, -1, -1):\n    inv[i] = (inv[i + 1] * (i + 1)) % MOD\n\nnum = pow(fac[n // 2], 2, MOD)\nfor i in range(0, 52):\n    num = (num * inv[buc[i]]) % MOD\n\ndp[0] = 1\n\nfor i in range(0, 52):\n    if not buc[i]:\n        continue\n    for j in range(n, buc[i] - 1, -1):\n        dp[j] = add(dp[j], dp[j - buc[i]])\n\nfor i in range(52):\n    ans[i][i] = dp[n // 2]\n\nfor i in range(52):\n    if not buc[i]:\n        continue\n    temp_dp = dp.copy()\n    for k in range(buc[i], n + 1):\n        temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[i]])\n\n    for j in range(i + 1, 52):\n        if not buc[j]:\n            continue\n        for k in range(buc[j], n + 1):\n            temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[j]])\n\n        ans[i][j] = (2 * temp_dp[n // 2]) % MOD\n\n        for k in range(n, buc[j] - 1, -1):\n            temp_dp[k] = add(temp_dp[k], temp_dp[k - buc[j]])\n\nq = int(input())\nl = stdin.read().splitlines()\nfor i in l:\n    x, y = map(int, i.split())\n    l, r = find(s[x - 1]), find(s[y - 1])\n    if l > r:\n        l, r = r, l\n    print(num * ans[l][r] % MOD)\n", "complexity": "cubic", "problem": "1111_D", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "t = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    arr.sort(reverse=True)\n    print(min(arr[1] - 1, len(arr) - 2))", "complexity": "nlogn", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "from math import *\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef bin_search(arr, n):\n\n\tpos = -1\n\n\t# all nums < n\n\n\tfor i in range(35, -1, -1):\n\t\tjump = (1 << i)\n\n\t\tif (pos + jump) >= len(arr):\n\t\t\tcontinue\n\n\t\tif arr[pos + jump] <= n-1:\n\t\t\tpos += jump\n\n\n\treturn len(arr) - pos - 1  \n\ndef main():\n\tn, m = [int(x) for x in input().split(' ')]\n\n\tvert = []\n\tfor i in range(n):\n\t\tvert.append(int(input()))\n\n\thor = []\n\tfor i in range(m):\n\t\tcol1, col2, row = [int(x) for x in input().split(' ')]\n\n\t\tif col1 != 1:\n\t\t\tcontinue\n\n\t\thor.append((col2))\n\n\n\tvert.append(1000000000)\n\n\tvert = sorted(vert)\n\thor = sorted(hor)\n\n\tbest = int(1e10)\n\n\n\tfor i in range(len(vert)):\n\t\tcur_ans = bin_search(hor, vert[i]) + i\n\t\tbest = min(best, cur_ans)\n\n\n\n\tprint(best)\n\nif __name__ == \"__main__\":\n\tmain()", "complexity": "nlogn", "problem": "1075_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "n, m = map(int, input().split())\na = []\nb = []\ncheck = True\nwhile n >= 0:\n    if check == True:\n        a.append(5)\n        n -= 5\n        b.append(4)\n        check = False\n    else:\n         check = True\n         a.append(4)\n         n -= 4\n         b.append(5)\n\n\nif m != 1:\n    a.append(5)\n    b.append(6)\nelse:\n    a.append(5)\n    b.append(5)\n\nprint(*a, sep = \"\")\nprint(*b, sep = \"\")\n", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "#!/usr/bin/python\n\nx,k = map(int, input().strip().split())\n\nMOD = 1000000007\n\nif x > 0:\n\tr = (pow(2, k+1, MOD) * x - pow(2, k, MOD) + 1 + MOD * 10) % MOD\nelse:\n\tr = 0\n\nprint(r)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n,m=map(int,input().split())\narr=[ int(x) for x in input().split()]\n\narr=sorted(arr,reverse=True)\narr.append(0)\n#print(arr)\nisum=sum(arr)\nans=[]\ntop=arr[0]\nfor i in range(n):\n\tif(arr[i]==1):\n\t\tans.append(1)\n\t\tarr[i+1]=1\n\t\tcontinue\n\tif(arr[i+1] >arr[i]):\n\t\tarr[i+1]=arr[i]\n\tif arr[i]-arr[i+1]==0:\n\t\tans.append(1)\n\t\th=1\n\telse:\n\t\tans.append(arr[i]-arr[i+1])\n\t\th=arr[i]-arr[i+1]\n\n\ttop=arr[i]-h\n\tarr[i+1]=top\n# \tprint(\"top:\",top)\n# \tprint(\"arr:\",arr)\n# \tprint(\"ans:\",ans)\n# print(ans)\nprint(isum-sum(ans))", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "from itertools import combinations\n \nn, l, r, x = map(int, input().split())\n(*a,) = map(int, input().split())\nsumu = 0\nfor i in range(2, n + 2):\n    for j in combinations(a, i):\n        if (r >= sum(j) >= l) and (max(j) - min(j) >= x):\n            sumu += 1\nprint(sumu)\n\t \t\t      \t \t  \t\t   \t  \t\t \t \t", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "if __name__ == '__main__':\n    cin = input\n    n, m = map(int, cin().split())\n    s, l, f = [[] for _ in range(n)], [0] * m, 0\n\n    for i in range(n):\n        t = cin()\n        for j in range(m):\n            if t[j] == \"1\":\n                l[j] += int(t[j])\n                s[i].append(j)\n    for i in range(n):\n        r = set(l[c] - 1 for c in s[i])\n        if not 0 in r:\n            f = not f\n            break\n    print(\"YNEOS\"[not f::2])", "complexity": "quadratic", "problem": "0985_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def isValid(arr, l, r, x):\n\treturn l <= sum(arr) <= r and max(arr)-min(arr) >= x\n\nn, l, r, x = map(int, input().strip().split())\narr = list(map(int, input().strip().split()))\nvalid = 0\n\nfor i in range(1, 1<<n):\n\ts = str(bin(i))[2:].rjust(n, '0')\n\ttemp = []\n\tfor j in range(n):\n\t\tif s[j] == '1':\n\t\t\ttemp.append(arr[j])\n\tif isValid(temp, l, r, x):\n\t\tvalid += 1\nprint(valid)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect, insort\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nfrom copy import deepcopy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ntry:\n    # sys.setrecursionlimit(int(pow(10,6)))\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\nexcept:\n    pass\ndef pmat(A):\n    for ele in A: print(*ele,end=\"\\n\")\n\n# from sys import stdin\n# input = stdin.buffer.readline\n# I = lambda : list(map(int,input().split()))\n\n# import sys\n# input=sys.stdin.readline\n\n\n\nn, m = L()\nk = L()[0]\na = [[0] * m for _ in range(n)]\ndq = deque()\nline = list(map(lambda x: int(x) - 1, L()))\nfor i in range(0, 2 * k, 2):\n    a[line[i]][line[i + 1]] = 1\n    dq.append((line[i], line[i + 1]))\n \n \nx, y = -1, -1\nwhile dq:\n    x, y = dq.popleft()\n    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):\n        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:\n            a[tx][ty] = 1\n            dq.append((tx, ty))\n \nprint(f'{x+1} {y+1}')\n", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "from collections import defaultdict, Counter\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd\n \ndef read(): return list(map(int, input().strip().split()))\n \nans_ = []\n\n \n# for _ in range(int(input())):\nt_p = [2**i for i in range(31)]\nn = int(input()); \narr = Counter(read())\nd = defaultdict(int)\nm = 1; ans_lis = [list(arr.keys())[0]]\n\nfor i in arr:\n    for j in t_p:\n        a, b, c = i, i+j, i+2*j\n        s = (arr[a] > 0) + (arr[b] > 0) + (arr[c] > 0)\n        if s > m:\n            m = s\n            ans_lis = [x for x in [a, b, c] if arr[x]]\n\n\nans_.append(m)\nt = \"\"\nfor i in ans_lis:t += (str(i)+\" \")\nans_.append(t)\n\n\n\n\n\n \n \n# print(ans_)\nfor i in ans_:\n    print(i)\n \n \n\"\"\"\n0 2 4 \n3 5 7\n\n\n0 8 16\n\n\n\"\"\"", "complexity": "nlogn", "problem": "0988_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "n, m, k = map(int, input().split())\n\na = list(map(int, input().split()))\n\nbest = 0\ndp = [0] * (n + 1)\nfor i in range(n):\n    b2 = 0\n    for j in range(max(-1, i - m), i + 1):\n        b2 = max(b2, dp[j] - k + sum(a[j + 1:i + 1]))\n    dp[i] = max(b2, a[i] - k)\n    best = max(best, dp[i])\n\nprint(best)\n# print(dp)\n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "def main():\n    a = sorted(input(), reverse=True)\n    b = int(input())\n    k = \"\"\n    while len(a) > 0:\n        for i in range(len(a)):\n            num = k + a[i] + \"\".join(sorted(a[:i] + a[i + 1:]))\n            if int(num) <= b:\n                k += a[i]\n                a = a[:i] + a[i + 1:]\n                break\n    print(k)\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n=int(input())\na=list(map(int,input().split()))\nd=set()\nt={}\nrep=set()\nif a.count(0)>=2:\n\tprint(\"cslnb\")\n\texit()\n\nfor i in a:\n\tif i in d:\n\t\tif t[i]+1==3:\n\t\t\tprint(\"cslnb\")\n\t\t\texit()\n\t\telse:\n\t\t\tt[i]+=1\n\t\t\trep.add(i)\n\t\t\tif len(rep)>=2:\n\t\t\t\tprint(\"cslnb\")\n\t\t\t\texit()\n\telse:\n\t\tt[i]=1\n\t\td.add(i)\nif rep:\n\tfor c in rep:\n\t\tif c-1 in d:\n\t\t\tprint(\"cslnb\")\n\t\t\texit()\ns=0\na.sort()\nfor i in range(n):\n\ts+=a[i]-i\nif s%2==1:print(\"sjfnb\")\nelse:print(\"cslnb\")", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\nimport pprint\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n# sys.stdout = open('output.txt', 'w')\n\n\nn = ria()[0]\nx, y = ria()\nd1 = abs(1 - x) + abs(1 - y)\nd2 = abs(n - x) + abs(n - y)\nif d1<=d2:\n    print('White')\nelse:\n    print('Black')", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right \nfrom heapq import heappop,heappush,heapify\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n\nk = inpl(); k.sort()\nif k.count(1) >= 1 or k.count(2) >= 2 or k.count(3) >= 3 or k == [2,4,4]:\n    print('YES')\nelse:\n    print('NO')", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO,IOBase\nfrom math import inf\n\ndef main():\n    n = int(input())\n    a = [0]+list(map(int,input().split()))\n    dp = [[[-1,0]for _ in range(n+1)]for _ in range(n+1)]\n    ### int: value , bool: can it be reduced to length 1\n    for i in range(1,n+1):\n        dp[i][i][0],dp[i][i][1] = a[i],1\n    for i in range(n-1,0,-1):\n        for j in range(i+1,n+1):\n            for k in range(j-i):\n                a,b = dp[i][i+k],dp[i+k+1][j]\n                if a[1] and b[1] and a[0] == b[0]:\n                    dp[i][j][0],dp[i][j][1] = a[0]+1,1\n                    break\n    val = [0,0]+[inf]*n\n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            if dp[i][j][1]:\n                val[j+1] = min(val[j+1],val[i]+1)\n    print(val[-1])\n\n#Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n=int(input())\narr=list(map(int,input().split()));ans=0\nwhile len(arr)!=0:\n e=arr.pop(0)\n ans+=arr.index(e)\n arr.remove(e)\nprint(ans)\n \n\n  \n", "complexity": "quadratic", "problem": "0995_B", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "def main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = 10 ** 10\n    for i in range(n):\n        x = i if i > n - i - 1 else n - i - 1\n        ans = min(ans, arr[i] // x)\n    print(ans)\nmain()", "complexity": "linear", "problem": "1159_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "from collections import namedtuple\nn = int(input())\nvertex = namedtuple('vertex', ['degree', 'id'])\na, b, c = [], [], 0\n\nrr = list(map(int, input().split()))\n\nfor i in range(n):\n    tmp = rr[i]\n    v = vertex(tmp, i + 1)\n    if tmp > 1:\n        a.append(v)\n    else:\n        b.append(v)\n    c += tmp\n\nif c < (n - 1)*2:\n    print('NO')\nelse:\n    if len(a) == 0:\n        print('YES 1')\n        print('1 2')\n    else:\n        print('YES', len(a) - 1 + min(2, len(b)))\n        print(n - 1)\n        for i in range(len(a)):\n            if i == 0:\n                continue\n            print(a[i - 1].id, a[i].id)\n        if len(b) > 0:\n            print(b[0].id, a[0].id)\n        if len(b) > 1:\n            print(b[1].id, a[-1].id)\n        j = 2\n        for i in range(len(a)):\n            if j >= len(b):\n                yes = 1\n                break\n            k = a[i].degree - 2\n            yes = 0\n            for t in range(k):\n                print(a[i].id, b[j].id)\n                j += 1\n                if j >= len(b):\n                    yes = 1\n                    break\n            if yes == 1:\n                break", "complexity": "linear", "problem": "1082_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "n=int(input())\nl1=list(map(int,input().split()))\nif n%2==0:\n    for i in range(n):\n        if l1[i]>=0:\n            l1[i]=-1*l1[i]-1\nelse :\n    for i in range(n):\n        if l1[i]>=0:\n            l1[i]=-1*l1[i]-1\n    l1[l1.index(min(l1))]=l1[l1.index(min(l1))]*-1 -1\nprint(' '.join(str(x) for x in l1))", "complexity": "linear", "problem": "1180_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "n = int(input())\n\nlst = list(map(int, input().split()))\n\nevens = []\nodds = []\n\nfor e, x in enumerate(lst):\n    if x % 2 == 0:\n        evens.append(e + 1)\n    else:\n        odds.append(e + 1)\n\nif len(evens) < len(odds):\n    print(evens[0])\nelse:\n    print(odds[0])\n", "complexity": "linear", "problem": "0025_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "a, b= list(map(int, input().split()))\nc = 1\nresult = a^b\nwhile c <= result:\n    c *= 2\nc -= 1\n \nprint(c)\n \t\t \t   \t\t\t\t \t\t   \t\t   \t  \t  \t", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "from math import log2\nn = int(input())\nif n == 1:\n    print(1)\n    exit()\nelif n == 3:\n    print(1, 1, 3)\n    exit()\nl = [1] * (n // 2)\nif n % 2 == 1:\n    l.append(1)\n\nxn = int(log2(n))\ntmp = n - len(l)\nfor i in range(2, xn+1):\n    fn = tmp // 2\n    if tmp % 2 == 1:\n        fn += 1\n    tmp -= fn\n    l += ([pow(2, i-1)] * fn)\nl.append((n // pow(2, xn - 1)) * pow(2, xn - 1))\nprint(' '.join(str(i) for i in l))", "complexity": "linear", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "t = int(input())\n\ndef get_max(n):\n    ans = 0\n    while n:\n        ans = 4 * ans + 1\n        n = n - 1\n        if ans > 10**19:\n            break\n    return ans\n\nfor _ in range(t):\n    n, k = map(int, input().split())\n    if n == 1:\n        if k == 1:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    elif n == 2:\n        if k <= 2:\n            print(\"YES 1\")\n        elif k != 3 and k <= 5:\n            print(\"YES 0\")\n        else:\n            print(\"NO\")\n    else:\n        siz = n - 1\n        l = 1\n        cnt = 3\n        while siz:\n            if l <= k < l+cnt:\n                print(\"YES {}\".format(siz))\n                break\n            l = l + cnt\n            cnt = 2 * cnt + 1\n            siz = siz - 1\n        else:\n            if k <= get_max(n):\n                print(\"YES 0\")\n            else:\n                print(\"NO\")\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "def add(num):\n    if(num<=1):\n        return 0\n    return (num*(num-1))//2\n    \n    \nn,k=map(int,input().split())\n\na=list(map(int,input().split()))\npre=[a[0]]\nbase=(2**(k))-1\nhb=2**(k-1)\nfor i in range(1,n):\n    pre.append(a[i]^pre[-1])\n    \ncnt=dict()\ncnt[0]=[0,0]\n\nfor i in range(n):\n    if(pre[i]>=hb):\n        if(base-pre[i] not in cnt):\n            cnt[base-pre[i]]=[0,0]\n        cnt[base-pre[i]][1]+=1\n    else:\n        if(pre[i] not in cnt):\n            cnt[pre[i]]=[0,0]\n        cnt[pre[i]][0]+=1\ncnt1=0\n#print(pre)\n#print(cnt)\nfor i in cnt.values():\n    sum1=i[0]+i[1]\n    cnt1+=add(sum1//2)\n    cnt1+=add((sum1+1)//2)\ncnt1+=sum(cnt[0])//2\n#print(cnt1)\nprint((n*(n+1))//2 - cnt1)\n    \n    \n\n    \n", "complexity": "linear", "problem": "1054_D", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "if __name__ == '__main__':\n\t\tn,m = map(int, input().split())\n\t\tl = list(map(int, input().split()))\n\t\td = dict()\n\t\tif len(set(l)) < n:\n\t\t\tprint(0)\n\t\telse:\n\t\t\tfor i in range (m):\n\t\t\t\td.setdefault(l[i],0)\n\t\t\t\td[l[i]]+=1\n\t\t\tmin1 = 999999999\n\t\t\tfor i in d.values():\n\t\t\t\tif i < min1 :\n\t\t\t\t\tmin1 = i\n\t\t\tprint(min1)", "complexity": "quadratic", "problem": "0961_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "x, y, z, t1, t2, t3 = [int(i) for i in input().split()]\nif abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "constant", "problem": "1054_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "#!/usr/bin/env python3\nimport sys\n\ndef rint():\n    return map(int, sys.stdin.readline().split())\n#lines = stdin.readlines()\n\ndef writable(r, c):\n    if r+2 >= n or c+2 >= m:\n        return False\n    t = set()\n    t.add(cells[r][c])\n    t.add(cells[r][c+1])\n    t.add(cells[r][c+2])\n    t.add(cells[r+1][c])\n    t.add(cells[r+1][c+2])\n    t.add(cells[r+2][c])\n    t.add(cells[r+2][c+1])\n    t.add(cells[r+2][c+2])\n    return not '.' in t\n\ndef fill_ink(r,c):\n    paper[r][c] = \"#\"\n    paper[r][c+1] = \"#\"\n    paper[r][c+2] = \"#\"\n    paper[r+1][c] = \"#\"\n    paper[r+1][c+2] = \"#\"\n    paper[r+2][c] = \"#\"\n    paper[r+2][c+1] = \"#\"\n    paper[r+2][c+2] = \"#\"\n\nn, m = rint()\n\ncells = []\nfor i in range(n):\n    cells.append(input())\n\n#for i in range(n):\n#    for j in range(m):\n#        print(cells[i][j], end='')\n#    print()\n\npaper = [[\".\" for j in range(m)] for i in range(n)]\n\nfor r in range(n):\n    for c in range(m):\n        if writable(r,c) is True:\n            fill_ink(r, c)\n\nfor r in range(n):\n    for c in range(m):\n        if cells[r][c] != paper[r][c]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\n", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import math\n\nt = int(input())\nres = []\nwhile t:\n\tt -= 1\n\tn, k = map(int, input().split())\n\tlimit = -1\n\tif n <= 60:\n\t\tlimit = 0\n\t\tpow4 = 1\n\t\tfor _ in range(n):\n\t\t\tlimit += pow4\n\t\t\tpow4 *= 4\n\tif limit < k and limit != -1 or n == 2 and k == 3:\n\t\tres.append('NO')\n\telse:\n\t\tdiv = 1\n\t\tk -= 1\n\t\tsize = 1\n\t\twhile div < n and k >= 4 * size - 1:\n\t\t\tk -= 4 * size - 1\n\t\t\tsize *= 2\n\t\t\tdiv += 1\n\t\tres.append('YES ' + str(n - div))\n\nprint('\\n'.join(res))", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "def solve(i, j, k):\n    if dp[i][j][k]!=-1:\n        return dp[i][j][k]\n    call = 0\n    if i>0 and j>0:\n        call = max(call, R[i]*G[j]+solve(i-1, j-1, k))\n    if j>0 and k>0:\n        call = max(call, G[j]*B[k]+solve(i, j-1, k-1))\n    if k>0 and i>0:\n        call = max(call, B[k]*R[i]+solve(i-1, j, k-1))\n    dp[i][j][k] = call\n    return call\n\n\nnr, ng, nb = map(int,input().split())\nR = [0]+list(map(int,input().split()))\nG = [0]+list(map(int,input().split()))\nB = [0]+list(map(int,input().split()))\nR.sort()\nG.sort()\nB.sort()\ndp = [[[-1]*(nb+1) for j in range(ng+1)] for i in range(nr+1)]\nans = solve(nr, ng, nb)\nprint(ans)", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "print(\"? 0 0\")\nt = int(input())\nA=[]\nB=[]\na=0\nb=0\nfor i in range(30):\n    A.append(-1)\n    B.append(-1)\ni = 29\nd = 2**i\nwhile i>=0:\n    a+=d\n    b+=d\n    print(\"?\", end=' ')\n    print(a, end=' ')\n    print(b)\n    s=int(input())\n    if s == -t:\n        if s==1:\n            A[i]=0\n            B[i]=1\n            b-=d\n            print(\"?\", end=' ')\n            print(a, end=' ')\n            print(b)\n            t=int(input())\n        elif s==-1:\n            A[i]=1\n            a-=d\n            B[i]=0\n            print(\"?\", end=' ')\n            print(a, end=' ')\n            print(b)\n            t=int(input())\n    i-=1\n    d//=2\nd=1\nfor j in range(30):\n    if A[j]==-1:\n        a = a^d\n        print(\"?\", end=' ')\n        print(a, end=' ')\n        print(b)\n        s = int(input())\n        if s==1:\n            A[j]=1\n            B[j]=1\n        else:\n            A[j]=0\n            B[j]=0\n        a = a^d\n    d*=2\nd=1\na=0\nb=0\nfor i in range(30):\n    a+=d*A[i]\n    b+=d*B[i]\n    d*=2\nprint(\"!\", end=' ')\nprint(a, end=' ')\nprint(b)\n", "complexity": "constant", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "import sys\ninput = sys.stdin.readline\n\n\nn, m, k = map(int, input().split())\nA = [[0] * (m) for _ in range(n)]\nB = [[0] * (m) for _ in range(n)]\nfor i in range(n):\n    tmp = list(map(int, input().split()))\n    for j in range(m - 1):\n        A[i][j + 1] = tmp[j] # + A[i][j]\nfor i in range(n - 1):\n    tmp = list(map(int, input().split()))\n    for j in range(m):\n        B[i + 1][j] = tmp[j] # + B[i][j]\n\nif k % 2:\n    ans = [[-1] * m for _ in range(n)]\n    for a in ans:\n        print(*a)\n    sys.exit()\nans = [[0] * m for _ in range(n)]\nlim = k // 2\ndp = [[[float(\"inf\")] * (lim + 1) for _ in range(m)] for _ in range(n)]\nfor i in range(n):\n    for j in range(m):\n        dp[i][j][0] = 0\n\nfor k in range(1, lim + 1):\n    for i in range(n):\n        for j in range(m):\n            if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j])\n            if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j])\n            if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j])\n            if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1])\nfor i in range(n):\n    for j in range(m):\n        ans[i][j] = dp[i][j][-1] * 2\nfor a in ans:\n    print(*a)", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import sys\nreadline = sys.stdin.readline\n\ndef popcount(i):\n    assert 0 <= i < 0x100000000\n    i = i - ((i >> 1) & 0x55555555)\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\nN, M = map(int, readline().split())\n\nAr = [tuple(map(int, readline().split())) for _ in range(N)]\n\npc = [popcount(i) for i in range(1<<(M+1))]\n\ninf = 1<<31\nmaxi = [0]*(1<<M)\n\nfor i in range(N):\n    a = Ar[i]\n    dp = [0]*(1<<M)\n    for S in range(1, 1<<M):\n        p = pc[S]\n        if p == 1:\n            k = S.bit_length() - 1\n            dp[S] = a[k]\n        else:\n            dp[S] = min(dp[-S&S], dp[S^(-S&S)]) \n        maxi[S] = max(maxi[S], dp[S])\nfor i in range(M):\n    for j in range(1<<M):\n        if not j & (1<<i):\n            maxi[j] = max(maxi[j], maxi[j|(1<<i)])\n\nD = (1<<M)-1\nans = maxi[D]\naS, bS = D, D\nfor S in range(1<<M):\n    candi = min(maxi[S], maxi[D^S])\n    if candi > ans:\n        aS, bS = S, D^S\n        ans = candi\n\nAns = [None]*2\npre = False\nfro = False\n\nfor i in range(N):\n    a = Ar[i]\n    resa = inf\n    resb = inf\n    for j in range(M):\n        if (1<<j)&aS:\n            resa = min(resa, a[j])\n        else:\n            resb = min(resb, a[j])\n    if resa >= ans:\n        pre = True\n        Ans[0] = i+1\n    if resb >= ans:\n        fro = True\n        Ans[1] = i+1\n    if pre and fro:\n        break\nprint(*Ans)\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import io\nimport os\n\nfrom collections import Counter, defaultdict, deque\n\nDEBUG = False\n\n\ndef bisect_f(f, lo, hi):\n    if DEBUG:\n        assert f(lo) and not f(hi)\n    while hi - lo > 1:\n        mid = (lo + hi) // 2\n        if f(mid):\n            lo = mid\n        else:\n            hi = mid\n        if DEBUG:\n            assert f(lo) and not f(hi)\n    if DEBUG:\n        assert hi - lo == 1\n        assert f(lo) and not f(hi)\n    return lo\n\n\ndef solve(N, M, arrs):\n    def isPossible(target):\n        possible = set()\n        for arr in arrs:\n            mask = 0\n            for pos, x in enumerate(arr):\n                if x >= target:\n                    mask += 1 << pos\n            possible.add(mask)\n        allMask = (1 << M) - 1\n        for mask1 in possible:\n            for mask2 in possible:\n                if mask1 | mask2 == allMask:\n                    return (mask1 << 8) + mask2\n        return 0\n\n    lo = min(arrs[0])\n    hi = 10 ** 9 + 1\n    index = bisect_f(isPossible, lo, hi)\n\n    mask1, mask2 = divmod(isPossible(index), 1 << 8)\n    ans = [-1, -1]\n    for i, arr in enumerate(arrs):\n        mask = 0\n        for pos, x in enumerate(arr):\n            if x >= index:\n                mask += 1 << pos\n        if mask == mask1:\n            ans[0] = str(i + 1)\n        if mask == mask2:\n            ans[1] = str(i + 1)\n    return \" \".join(ans)\n\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, M = [int(x) for x in input().split()]\n    arrs = [[int(x) for x in input().split()] for i in range(N)]\n    ans = solve(N, M, arrs)\n    print(ans)\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "def f(a,b):\n\tr=list(bin(b).lstrip(\"0b\"))\n\tl=list((len(bin(b))-len(bin(a)))*(\"0\")+bin(a).lstrip(\"0b\"))\n\tfor i in range(len(r)):\n\t\tif (r[i]==\"1\" and l[i]==\"1\"):\n\t\t\tr[i]=\"0\"\n\t\t\tif int(\"\".join(r),2)>=a:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tr[i]=\"1\"\n\t\tif l[i]==\"0\" and r[i]==\"0\":\n\t\t\tl[i]=\"1\"\n\t\t\tif int(\"\".join(l),2)<=b:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tl[i]=\"0\"\n\tl=int(\"\".join(l),2)\n\tr=int(\"\".join(r),2)\n\treturn l^r\n\n\n\na,b=map(int,input().strip().split())\nprint(f(a,b))", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "def helper(n,m,k):\n    \n    if k % 2 == 1:\n        res = [[-1] * m for i in range(n)]\n        return res\n    \n    k = k // 2\n    \n    pool = [[[0]*m for i in range(n)] for j in range(k+1)]\n    \n    dx = [0,0,1,-1]\n    dy = [1,-1,0,0]\n    \n    for t in range(1,k+1):\n        for i in range(n):\n            for j in range(m):\n                tres = [9999999] * 4\n                for c in range(4):\n                    if 0 <= i+dx[c] < n and 0 <= j+dy[c] < m:\n                        if c == 0:\n                            tres[c] = hedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                        elif c == 1:\n                            tres[c] = hedge[i][j-1]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                        elif c == 2:\n                            tres[c] = vedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                        else:\n                            tres[c] = vedge[i-1][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]\n                pool[t][i][j] = min(tres)\n    #print(pool)\n\n    return pool[k]\n\n#t = int(input())\n#for i in range(t):\n#n = int(input())\nn,m,k = map(int,input().split(\" \"))\nhedge = []\nvedge = []\nfor i in range(n):\n    hedge.append(list(map(int,input().split(\" \"))))\nfor i in range(n-1):\n    vedge.append(list(map(int,input().split(\" \"))))\n#a = list(map(int,input().split(\" \")))\n#print(len(a))\nres = helper(n,m,k)\nfor j in range(len(res)):\n    print(\" \".join(map(str,res[j])))\n#print(res)", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import sys\nstdin=sys.stdin\n\nip=lambda: int(sp())\nfp=lambda: float(sp())\nlp=lambda:list(map(int,stdin.readline().split()))\nsp=lambda:stdin.readline().rstrip()\nYp=lambda:print('Yes')\nNp=lambda:print('No')\n\nN = ip()\nL = []\nfor _ in range(N):\n    x,w = lp()\n    L.append([x-w,x+w])\nL.sort(reverse=True)\nans = 0\nedge = 1<<40\nfor i in range(N):\n    if L[i][1] <= edge:\n        edge = L[i][0]\n        ans += 1\nprint(ans)", "complexity": "nlogn", "problem": "0528_B", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "a = list(input())\nb = input()\nout = []\nmx = '/'\na.sort()\na.reverse()\nx = len(a)\nif x == len (b):\n    for i in range(x):\n        q = 0\n        \n        for j in range(len(a)):\n            if a[j] == b[i]:\n                out.append(a[j])\n                a.pop(a.index(a[j]))\n                q = 1\n                break\n            elif a[j] < b[i]:\n                out.append(a[j])\n                a.pop(a.index(a[j]))\n                print(''.join(out), end = '')\n                print(''.join(a))\n                exit(0)\n        if q == 0:\n            break\n    if q == 1:\n        print(''.join(out))\n    else:\n        y = len(out)\n        for i in range(y-1, -1, -1):\n            for j in range(len(a)):\n                if a[j] < b[i] and a[j]>mx:\n                    mx = a[j]\n            if mx != '/':\n                   \n                    \n                a.append(out[len(out)-1])\n                out.pop()\n                out.append(mx)\n                a.pop(a.index(mx))\n                a.sort()\n                a.reverse()              \n                print(''.join(out), end = '')\n                print(''.join(a))\n                exit(0)\n            else:\n                a.append(out[len(out)-1])\n                out.pop()\n                a.sort()\n                a.reverse()\n                    \n                    \n                    \n        a.pop(a.index(mx))\n        print(mx, end ='')\n        print(''.join(a))\n                \n                \nelse:\n    print(''.join(a))\n        \n'''15778899\n98715689'''\n\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "N, K = input().split()\nN, K = int(N), int(K)\nP = [int(x) for x in input().split()]\nA = [None]*256\nA[0] = 0\nfor i in range(N):\n    pn = P[i]\n    if A[pn] is None:\n        for j in range(K-1, -1, -1):\n            if pn < j: continue\n            if A[pn-j] is None:\n                A[pn-j] = pn-j\n                break\n            else:\n                if A[pn-j] + K - 1 >= pn:\n                    break\n        for jj in range(j, -1, -1):\n            A[pn-jj] = A[pn-j]\nprint(*[A[P[i]] for i in range(N)])\n", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "def check(e,value,pre):\n    global maxi,count\n    e[str(value)]-=1\n    pre+=str(value)\n    arr=[]\n    for i in e:\n        for j in range(e[i]):\n            arr.append(i)\n    arr.sort(reverse=True)\n    st=''\n    for i in arr:\n        st+=str(i)\n    alpha=int(pre+st)\n    if alpha<=int(b):\n        maxi=max(maxi,int(pre+st))\n\n\na=input()\nb=input()\nmaxi=0\nd={}\nfor i in a:\n    if i not in d:\n        d[i]=1\n    else:\n        d[i]+=1\nmaxi=0\nnum=\"\"\ncount=0\nif len(a)<len(b):\n    check(d.copy(),max(d),'')\nelse:\n    for i in b:\n        if i in d and d[i]>0:\n            for j in range(int(i)-1,-1,-1):\n                if str(j) in d and d[str(j)]>0:\n                    check(d.copy(),j,num)\n                    break\n            check(d.copy(),i,num)\n            num+=i\n            d[i]-=1\n\n        else:\n            j=0\n            for j in range(int(i)-1,-1,-1):\n                if str(j) in d and d[str(j)]>0:\n                    check(d.copy(),j,num)\n                    break\n            break\nprint(maxi)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n,k=map(int,input().split())\nfor i in range(10**5):\n  if (i*(i+1))//2-(n-i)==k:\n    print(n-i)", "complexity": "constant", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\ndef add(a,b):\n\treturn (a+b)%1000000007\n\ndef mul(a,b):\n\treturn (a*b)%1000000007\n\ndef sub(a,b):\n\treturn (a-b+1000000007)%1000000007\n\ndef qpow(a, b):\n\tr = 1\n\tk = a\n\tfor i in range(17):\n\t\tif b & (1<<i):\n\t\t\tr = mul(r, k)\n\t\tk = mul(k, k)\n\treturn r\n\nn, q = mints()\na = list(minp())\nc = [0]*(n+1)\nfor i in range(n):\n\tc[i+1] = c[i] + int(a[i])\nfor i in range(q):\n\tl, r = mints()\n\tk = (r-l+1)\n\to = c[r]-c[l-1]\n\tz = sub(qpow(2,o),1)\n\tprint(mul(z,qpow(2,k-o)))", "complexity": "linear", "problem": "1062_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)\nk = int(input())\na = 0\nfor i in T:\n    if i - k > 0:\n        a = T.index(i)\n        break\ntemp = T[a] - k\nx = temp % a\nres = (10 ** a) - 1 - int(temp / a)\nans = int((res % (10 ** (x+1))) / (10 ** x))\nprint(ans)\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# ------------------- fast io --------------------\nfrom bisect import bisect_left as bsl\ndef main():\n    cur=9;count=1;tot=0\n    num=[];cc=[]\n    for s in range(11):\n        num.append(cur*count)\n        tot+=cur\n        cc.append(tot)\n        cur*=10;count+=1\n    ans=[num[0]]\n    for s in range(1,11):\n        ans.append(ans[-1]+num[s])\n    k=int(input())\n    ind=min(bsl(ans,k),10)\n    left=k\n    if ind>0:\n        left-=ans[ind-1]\n    #sort out this bit below, might be ceil instead of //\n    nums=left//(ind+1);rem=left%(ind+1)\n    if left%(ind+1)!=0:\n        nums+=1\n    if ind>0:\n        nums+=cc[ind-1]\n    answer=[int(k) for k in str(nums)]\n    print(answer[rem-1])\nmain()", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "n,s=map(int,input().split())\nif s>=n:\n    print(\"0\")\n    exit()\nfor i in range(s,n+2):\n    cur=int(0)\n    for j in str(i):\n        cur+=int(j)\n    if i-cur>=s:\n        break\nprint(n-i+1)\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import sys\ninput = sys.stdin.readline\nq = int( input() )\nrgb = \"RGB\"\nfor _ in range( q ):\n    n, k = map( int, input().split() )\n    s = input()\n    ans = n\n    for i in range( 3 ):\n        r = [ 0 ]\n        l = i\n        for c in s:\n            r.append( r[ -1 ] + ( 1 if c != rgb[ l ] else 0 ) )\n            l = ( l + 1 ) % 3\n            if len( r ) > k:\n                ans = min( ans, r[ -1 ] - r[ len( r ) - 1 - k ] )\n    print( ans )\n", "complexity": "linear", "problem": "1196_D2", "from": "CODEFORCES", "tags": "data structures,dp,implementation,two pointers"}
{"src": "import sys\nimport math\nimport collections\nimport heapq\ninput=sys.stdin.readline\nk1,k2,k3=(int(i) for i in input().split())\nl=[k1,k2,k3]\nif(1 in l):\n    print(\"YES\")\nelif(l.count(2)>=2):\n    print(\"YES\")\nelif(l.count(3)==3):\n    print(\"YES\")\nelif(sorted(l)==[2,4,4]):\n    print(\"YES\")\nelse:\n    print(\"NO\")", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "n = int(input())\nA = list(map(int, input().split()))\nA.sort()\nB = [0] * n\nans = 0\nfor i in range(n):\n    if B[i] == 0:\n        ans += 1\n        B[i] = 1\n        for j in range(n):\n            if A[j] % A[i] == 0:\n                B[j] = 1\nprint(ans)", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "# Problem G\n\nnum = input()\nnum_list = []\nfor i in range(len(num)):\n  num_list.append(int(num[i]))\nmyMod = (10 ** 9) + 7\nlength = len(num_list)\nf = [0] * (length + 1)\nt = [1] * (length + 1)\nfor i in range(length):\n    f[i+1] = (f[i] * 10 + 1) % myMod\n    t[i+1] = (t[i] * 10) % myMod\nans = 0\nfor i in range(1, 10):\n    dp = [0] * (length + 1)\n    for j in range(length):\n        dp[j+1] = (dp[j] * i + (10 - i) * (dp[j] * 10 + t[j])) % myMod\n    c = 0\n    ctr = 0\n    for k in num_list:\n        z = min(i, k)\n        o = k - z\n        ans += o * (dp[length-1-ctr] * t[c+1] + f[c+1] * t[length-1-ctr]) % myMod\n        ans += z * (dp[length-1-ctr] * t[c] + f[c] * t[length-1-ctr]) % myMod\n        ans %= myMod\n        c += k >= i\n        ctr += 1\n    ans += f[c]\n    if ans >= myMod:\n        ans -= myMod\nprint(ans)\n \t     \t \t\t\t\t   \t  \t \t\t \t  \t\t", "complexity": "quadratic", "problem": "0908_G", "from": "CODEFORCES", "tags": "dp,math"}
{"src": "from math import sin\nn,r=[int(i) for i in input().split()]\npi=3.14159265359\nprint(r/((2*sin(pi*(1/2-1/n)))/(sin(2*pi/n))-1))", "complexity": "constant", "problem": "1100_C", "from": "CODEFORCES", "tags": "binary search,geometry,math"}
{"src": "n = [int(x) for x in input().split(' ')]\nM = 1000000007\n\ndef a(k):\n\tM = 1000000007\n\tif(k>0):\n\t\tl = a(k//2)\n\t\treturn (l*l*(k%2+1))%M\n\telse:\n\t\treturn 1\n\n\nif n[0]==0:\n\tprint(0)\nelse:\n\tl = a(n[1])\n\tprint((2*(n[0]%M)*l-l+1)%M)\n\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "l,r=map(int,input().split())\nz=l^r\nc=0\nif(z==0):\n    print(0)\n    exit()\nwhile(z):\n\tc+=1;\n\tz>>=1;\nx='1'*c\nprint(int(x,2))\n\t   \t  \t   \t\t \t \t\t  \t \t  \t\t  \t\t", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n, k = map(int, input().split())\ns = input()\nfail = [-1] * (len(s) + 1)\nfor i in range(1, len(s) + 1):\n    j = fail[i - 1]\n    while j != -1 and s[i - 1] != s[j]:\n        j = fail[j]\n    fail[i] = j + 1\n# print(fail)\n\nf1 = fail[-1]\nprint(s + s[f1:] * (k - 1))", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "\nimport math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n    return d[s]\n \nn,x,y=map(int,input().split())\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))\ny+=x\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "n = int(input())\na = list(map(int, input().split()))\ns = set(a)\ns.discard(0)\nprint(len(s))\n", "complexity": "linear", "problem": "0992_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "n,k=map(int,input().split())\nmod=998244353\ndp=[[0,0,0,0] for _ in range(k+1)]\n#dp[0][0]=dp[0][1]=dp[0][2]=dp[0][3]=\ndp[1][0]=dp[1][3]=1\nif k>1:\n    dp[2][2]=dp[2][1]=1\nfor x in range(1,n):\n    g=[[0,0,0,0] for _ in range(k+1)]\n    # 0 - bb\n    # 1 - bw\n    # 2 - wb\n    # 3 - ww\n    g[1][0]=g[1][3]=1\n    for i in range(2,k+1):\n        g[i][0]=(dp[i][0]+dp[i][1]+dp[i][2]+dp[i-1][3])%mod\n        g[i][1]=(dp[i-1][0]+dp[i][1]+dp[i-2][2]+dp[i-1][3])%mod\n        g[i][2]=(dp[i-1][0]+dp[i-2][1]+dp[i][2]+dp[i-1][3])%mod\n        g[i][3]=(dp[i-1][0]+dp[i][1]+dp[i][2]+dp[i][3])%mod\n    dp=g\nprint(sum(dp[-1])%mod)", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "n = int(input())\narr = list(map(int, input().split()))\n\nfor i in range(n):\n    arr[i] = (arr[i]-i)//n + (1 if (arr[i]-i)%n>0 else 0)\nprint(arr.index(min(arr))+1)\n", "complexity": "linear", "problem": "0996_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "n = int(input())\nprint(25)\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "a = sorted(input())\nb = int(input())\na = a[::-1] #reverse a\np = ''\ncnt = [0]*10\n\nwhile a :\n    for i, d in enumerate(a):\n        n = p + d + \"\".join(sorted(a[:i]+a[i+1:]))\n        if int(n) <= b :\n            p += d\n            a.pop(i)\n            break\n        \nprint(p)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import math\nfrom collections import defaultdict\nml=lambda:map(int,input().split())\nll=lambda:list(map(int,input().split()))\nii=lambda:int(input())\nip=lambda:list(input())\n\n\"\"\"========main code===============\"\"\"\n\nn,k=ml()\nans=0;\nfor i in range(1,1000001):\n    val=(i*(i+1))//2\n    if(val-(n-i)==k):\n        ans=n-i\nprint(ans)        ", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n, k = map(int, input().split())\n\nm = 2 * (n - 1) - k * (k - 1)\n\nif m > 0: print(-1)\n\nelse:\n\n    x = int((1 + (1 - 4 * m) ** 0.5) / 2)\n\n    if x * (x - 1) + m > 0: x -= 1\n\n    print(k - x)\n\n\n\n# Made By Mostafa_Khaled", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import sys\nfrom array import array  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\nn = int(input())\nprob = [tuple(map(float, input().split())) for _ in range(n)]\nfull_bit = (1 << n) - 1\ndp = [0.0] * full_bit + [1.0]\n\nfor bit in range(full_bit, 0, -1):\n    popcount = len([1 for i in range(n) if (1 << i) & bit])\n    if popcount == 1 or dp[bit] == 0.0:\n        continue\n    div = 1 / ((popcount * (popcount - 1)) >> 1)\n\n    for i in range(n):\n        if ((1 << i) & bit) == 0:\n            continue\n        for j in range(i + 1, n):\n            if ((1 << j) & bit) == 0:\n                continue\n            dp[bit - (1 << j)] += dp[bit] * prob[i][j] * div\n            dp[bit - (1 << i)] += dp[bit] * prob[j][i] * div\n\nprint(*(dp[1 << i] for i in range(n)))\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import sys, os.path\nif(os.path.exists('input.txt')):\n\tsys.stdin = open(\"input.txt\",\"r\")\n\t\n\nt = int(input())\nlast = []\ncurrent = []\n\nfor i in range(t):\n\tlast.append(str(input()))\nfor i in range(t):\n\tcurrent.append(str(input()))\n\nfor i in range(len(last)):\n\tif last[i] in current:\n\t\tcurrent[current.index(last[i])] = \"*\"\n\t\tlast[i] = \"*\"\n\nlast.sort()\ncurrent.sort()\n\ntotal = 0\nfor i in range(len(last)):\n\tif last[i] == current[i]:\n\t\tcontinue\n\telse:\n\t\ttotal+=1\n\t\nprint(total)\n\n\n", "complexity": "linear", "problem": "1000_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "n,x = list(map(int, input().split()))\na = set(map(int, input().split()))\n\nif len(a) < n :\n    print(0)\nelse :\n    d = set()\n    p = 0\n    for i in a :\n        d.add(i&x)\n        if i&x != i and i&x in a :\n            print(1)\n            p = 1\n            break\n    if len(d) < n and p == 0 :\n        print(2)\n    elif p != 1 :\n        print(-1)\n", "complexity": "linear", "problem": "1013_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "t = input()\n\nn = len(t)\n\nmaxi = 0\n\nfor i in range(n):\n    s = t[i]\n    if t.count(s) > 1:\n        maxi = max(maxi, 1)\n    nr = 1\n    for j in range(i + 1, n):\n        s += t[j]\n        nr += 1\n        g = 0\n        for h in range(n - nr + 1):\n            if s == t[h:h + nr]:\n                g += 1\n        if g > 1:\n            maxi = max(nr,maxi)\n\nprint(maxi)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import sys\ndef ask(x,y,rev):\n\tif (rev==0):\n\t\tprint(\"? %d %d\"%(x,y))\n\telse:\n\t\tprint(\"? %d %d\"%(y,x))\n\tsys.stdout.flush()\n\tif (rev==1):\n\t\treturn -int(input())\n\telse:\n\t\treturn int(input())\n\ncomp=ask(0,0,0)\nnowa=0\nnowb=0\nrev=0\nfor i in range(29,-1,-1):\n\tif (comp<0):\n\t\trev^=1\n\t\tnowa,nowb=nowb,nowa\n\t\tcomp=-comp\n\tif comp>=0:\n\t\tcomp=ask(nowa|(1<<i),nowb|(1<<i),rev)\n\t\tif (comp<0):\n\t\t\tnowa|=1<<i\n\t\t\tcomp=ask(nowa,nowb,rev)\n\t\telse:\n\t\t\ttmp=ask(nowa|(1<<i),nowb,rev)\n\t\t\tif (tmp<0):\n\t\t\t\tnowa|=1<<i\n\t\t\t\tnowb|=1<<i\nif (rev==1):\n\tnowa,nowb=nowb,nowa\nprint(\"! %d %d\"%(nowa,nowb))\n\t\t\t\n\t\t", "complexity": "logn", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "\nn = int(input())\nfib = [0,1]\n\nfor x in range(1,200):\n\n\n    z = fib[x] + fib[x-1]\n    if z <= n:\n\n        fib.append(z)\n    else:\n        break\n\nfib = fib[::-1]\nlis = []\nfor y in range(len(fib)):\n\n    if fib[y] <= n:\n        if (sum(lis) + fib[y]) <= n:\n            if len(lis) < 3:\n                lis.append(fib[y])\nif sum(lis) == n:\n    if len(lis) == 1:\n        lis.append(0)\n        lis.append(0)\n        print(*lis)\n    elif len(lis) == 2:\n        lis.append(0)\n        print(*lis)\n    else:\n        print(*lis)\nelse:\n    print(\"I'm too stupid to solve this problem\")\n\n\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "#!/usr/bin/env python3\nn,m,k,l=map(int,input().split())\nq=(l+k-1)//m+1\nif q*m>n:print(-1)\nelse:print(q)\n", "complexity": "constant", "problem": "1068_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\n\ndef chain_reaction(n, beacons):\n    table = [0] * n\n    # table[i] represents the number of beacons destroyed if the first i beacons are used\n    for i in range(n):\n        position = beacons[i][0]\n        power = beacons[i][1]\n        destroyed = 0\n        r = position - power\n        b = 0\n        # use binary search to find the beacon that will be activated after the current one\n        lo = 0\n        hi = len(beacons) - 1\n        while lo <= hi:\n            mid = int(lo + (hi - lo) / 2)\n            pos = beacons[mid][0]\n            if beacons[mid][0] < r:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        # beacons destroyed by next activated one\n        destroyed += table[hi]\n        # beacons destroyed by currently activated one\n        destroyed += (i - (hi + 1))\n        table[i] = destroyed\n\n    # print(table)\n\n    # find first index of max # of beacons destroyed\n    max_val = max(table)\n    ind = 0\n    while ind < len(table):\n        if table[ind] == max_val:\n            break\n        ind += 1\n    cost = (len(table) - ind) + table[ind - 1]\n\n    options = []\n    for i in range(n):\n        cost = (n - i) + table[i - 1]\n        options.append(cost)\n    min_cost = min(options)\n\n    # options: add a beacon that doesn't destroy any or add a beacon that destroys the beacon at index ind\n    # return min(table[n - 1], cost)\n    return min(table[n - 1], min_cost)\n \nn = int(sys.stdin.readline().strip())\nbeacons = []\nfor i in range(n):\n    a, b = [int(x) for x in sys.stdin.readline().strip().split(\" \")]\n    beacons.append((a, b))\nbeacons.sort()\nprint(chain_reaction(n, beacons))", "complexity": "linear", "problem": "0608_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "def solve(a, b):\n    m = max(a, b)\n    n = min(a, b)\n    if n == 0:\n        return 0\n    if m == n:\n        return 1\n    elif m % n == 0:\n        return m // n\n    k = m // n\n    return k + solve(n, m - n * k)\n\n\nfor _ in range(int(input())):\n    a, b = map(int, input().split())\n    print(solve(a, b))", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+1)\n\n    def to_sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, x):\n        while i <= self.n:\n            self.data[i] += x\n            i += (i & -i)\n\n    def get(self, i, j):\n        #[i,j](1<=i<=j<=N)\n        return self.to_sum(j) - self.to_sum(i - 1)\n\n\ndef f(x, V):\n    if x < V:\n        return -1\n    return 1\n\n\ndef calc_median(M):\n    b = [f(v, M) for v in a]\n    res = 0\n    c = [0]\n    for x in b:\n        c.append(c[-1] + x)\n    d = [(c[i], i) for i in range(n + 1)]\n    bit = BIT(2*n + 10)\n    for value, index in d:\n        if index == 0:\n            bit.add(value + n + 1, 1)\n            continue\n        res += bit.get(1, value + n)\n        bit.add(value + n + 1, 1)\n\n    return res\n\n\nprint(calc_median(m) - calc_median(m + 1))\n\n", "complexity": "nlogn", "problem": "1005_E1", "from": "CODEFORCES", "tags": "sortings"}
{"src": "\nfrom sys import stdin,stdout,setrecursionlimit\nstdin.readline\ndef mp(): return list(map(int, stdin.readline().strip().split()))\ndef it():return int(stdin.readline().strip())\nfrom collections import defaultdict as dd,Counter as C,deque\nfrom math import ceil,gcd,sqrt,factorial,log2,floor\t\nfrom bisect import bisect_right as br,bisect_left as bl\nimport heapq\n\ndef solve(a,b):\n\tif a == 0:\n\t\treturn 0\n\treturn b//a + solve(b%a,a)\nprint(solve(*mp()))\n\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n# sys.setrecursionlimit(111111) \n \ndef main():\n    \n\n  \n \n\n          \n                  \n    # mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n\n            \n\n\n    ###CODE\n    tc = 1\n    for _ in range(tc):\n        n,x=ria()\n        a=ria()\n        d=Counter(a)\n        sa=set(a)\n        if len(sa)<n:\n            print(0)\n        else:\n            c=0\n            for i in a:\n                k=i&x\n                if k!=i and k in d:\n                    c=1\n                    print(1)\n                    break            \n            if c==0:\n                z=[]\n                for i in a:\n                    z.append(i&x)\n                if len(set(z))<n:\n                    print(2)\n                else:\n                    print(\"-1\")\n        \n        \n                \n        \n            \n        \n                    \n                                    \n                \n        \n            \n                    \n                    \n        \n            \n        \n        \n        \n            \n            \n            \n            \n            \n        \n        \n                    \n            \n        \n        \n                    \n                \n        \n        \n            \n                \n        \n\n            \n        \n\n               \n            \n        \n              \n                \n        \n        \n            \n        \n        \n            \n            \n        \n        \n                \n                \n                \n                \n            \n        \n        \n            \n           \n        \n            \n                    \n\n                                 \n                \n                \n        \n\n                \n        \n        \n        \n            \n        \n        \n                \n            \n        \n        \n                    \n        \n        \n        \n            \n                    \n            \n\n                \n            \n            \n                \n            \n                \n            \n            \n            \n            \n                \n            \n        \n        \n        \n        \n        \n        \n        \n                    \n        \n        \n        \n                \n                \n        \n            \n            \n            \n        \n\n                    \n        \n                \n        \n        \n                        \n        \n                            \n\n        \n\n                \n            \n        \n\n                \n            \n                    \n                \n                \n        \n        \n         \n        \n\n                        \n                            \n                \n        \n                            \n                    \n\n                \n            \n        \n                \n            \n                \n        \n        \n        \n                             \n        \n            \n        \n        \n            \n                        \n                        \n                    \n            \n        \n        \n        \n        \n        \n                        \n       \n\n        \n                           \n        \n        \n        \n            \n        \n        \n        \n                      \n\n      \n                            \n            \n        \n        \n            \n            \n            \n            \n            \n        \n        \n        \n            \n        \n        \n        \n            \n        \n        \n        \n        \n            \n            \n        \n        \n        \n        \n        \n        \n        \n                \n                \n                    \n        \n        \n            \n            \n        \n                \n            \n            \n        \n        \n        \n        \n                \n        \n            \n        \n                \n        \n        \n            \n        \n       \n            \n\n                \n        \n        \n        \n   \n            \n        \n        \n        \n        \n            \n        \n                \n        \n        \n        \n            \n            \n        \n        \n            \n        \n        \n\n        \n        \n            \n        \n        \n            \n        \n                        \n\n        \n        \n            \n     \n        \n        \n            \n        \n        \n                \n            \n        \n        \n        \n                \n            \n        \n\n            \n             \n        \n            \n        \n        \n        \n                \n        \n            \n        \n        \n        \n        \n                \n        \n        \n            \n        \n        \n        \n        \n                \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    ", "complexity": "linear", "problem": "1013_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=998244353\nEPS=1e-6\ndef Ceil(a,b): return a//b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n\n\ndef ok(a,b,c):\n\n    # print(a[0],b,c)\n\n    n = a[0][-1]\n    ans = []\n    for i in range(a[0][0]): ans.append([a[1]]*n)\n\n    l = n\n    r = n - a[0][0]\n\n    for i in range(2):\n        for j in range(2):\n\n            l1,r1 = b[0]\n            l2,r2 = c[0]\n\n            if(i): l1,r1 = r1,l1\n            if(j): l2,r2 = r2,l2\n\n            if(l1 == l):\n                if(l2 != l or r1 + r2 != r): continue\n\n                for k in range(r1): ans.append([b[1]]*n)\n                for k in range(r2): ans.append([c[1]]*n)\n                return ans\n\n\n            if(l1 == r):\n                if(l2 != r or r1 + r2 != l): continue\n\n                for k in range(r): ans.append( [b[1]]*r1 + [c[1]]*r2)\n                return ans\n\n    return False\n\n\nl1,r1,l2,r2,l3,r3 = value()\n\na = [sorted((l1,r1)),'A']\nb = [sorted((l2,r2)),'B']\nc = [sorted((l3,r3)),'C']\n\nA = ok(a,b,c)\nB = ok(b,a,c)\nC = ok(c,a,b)\n\nif(A):\n    print(len(A))\n    for i in A: print(*i,sep=\"\")\nelif(B): \n    print(len(B))\n    for i in B: print(*i,sep=\"\")\nelif(C):\n    print(len(C))\n    for i in C: print(*i,sep=\"\")\nelse: \n    print(-1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "np", "problem": "0581_D", "from": "CODEFORCES", "tags": "bitmasks,brute force,constructive algorithms,geometry,implementation,math"}
{"src": "# Fast IO Region\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# Get out of main function\ndef main():\n    pass\n# decimal to binary\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n# binary to decimal\ndef decimal(s):\n    return (int(s, 2))\n# power of a number base 2\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return (p)\n# if  number is prime in \u221an time\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n# list to string ,no spaces\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n# String to list\ndef stl(s):\n    # for each character in string to list with no spaces -->\n    l = list(s)\n    # for space in string  -->\n    # l=list(s.split(\" \"))\n    return l\n# Returns list of numbers with a particular sum\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n# Sieve for prime numbers in a range\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n            # print(p)\n    return (cnt)\n# for positive integerse only\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n# 1000000007\nmod = int(1e9) + 7\nimport math\n#import random\n#import bisect\n#from fractions import Fraction\n#from collections import OrderedDict\n#from collections import deque\n########################                         mat=[[0 for i in range(n)] for j in range(m)]                      ########################\n########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################\n########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################\n########################                         from collections import deque                              ########################\n########################                         ASCII of A-Z= 65-90                                        ########################\n########################                         ASCII of a-z= 97-122                                       ########################\n########################                         d1.setdefault(key, []).append(value)                       ########################\n#sys.setrecursionlimit(300000)          #Gives memory limit exceeded if used a lot\n#for ___ in range(int(input())):\ndef deep(node):\n    visited[node-1]=1\n    if(len(d[node])==1):\n        return node\n    for c in d[node]:\n        if(visited[c-1]!=1):\n            return(deep(c))\n\nn=int(input())\nd={}\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    d.setdefault(u,[]).append(v)\n    d.setdefault(v,[]).append(u)\nnode=1\nfor key in d:\n    if(len(d[key])>len(d[node])):\n        node=key\nans=[]\nvisited=[0]*n\nvisited[node-1]=1\nfor c in d[node]:\n    while(True):\n        visited[c-1]=1\n        if(len(d[c])==1):\n            ans.append([node,c])\n            break\n        for child in d[c]:\n            if(visited[child-1]!=1):\n                c=child\n                break\nif(sum(visited)==n):\n    print(\"Yes\")\n    print(len(ans))\n    for c in ans:\n        print(*c)\nelse:\n    print(\"No\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "linear", "problem": "0981_C", "from": "CODEFORCES", "tags": "implementation,trees"}
{"src": "s=input()\nans=0\nm=set()\nfor i in range(len(s)):\n    for j in range(i,-1,-1):\n        if(s[j:i+1] in m):\n            ans=max(ans,i-j+1)\n        else:\n            m.add(s[j:i+1])\nprint(ans)\n    ", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import sys\nimport math\ninput = sys.stdin.readline\n\ntestcase=int(input())\nT=[list(map(int,input().split())) for i in range(testcase)]\n\ndef bi(n,k):\n    MIN=0\n    MAX=n\n\n    while MAX>MIN+1:\n        bn=(MIN+MAX)//2\n        if math.log2(k+2+bn)<bn+1:\n            MAX=bn\n        elif math.log2(k+2+bn)==bn+1:\n            return bn\n        else:\n            MIN=bn\n\n    if MAX+1<=math.log2(k+2+MAX):\n        return MAX\n\n    return MIN\n\nfor n,k in T:\n    if n==1:\n        if k==1:\n            print(\"YES\",0)\n        else:\n            print(\"NO\")\n        continue\n\n    if n==2:\n        if 1<=k<=2:\n            print(\"YES\",1)\n        elif k==3:\n            print(\"NO\")\n        elif 4<=k<=5:\n            print(\"YES\",0)\n        else:\n            print(\"NO\")\n        continue\n        \n    if n<=30 and k>(pow(4,n)-1)//3:\n        print(\"NO\")\n        continue\n\n    ANS=bi(n,k)\n\n    print(\"YES\",n-ANS)\n    \n    \n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "# ---------------------------iye ha aam zindegi---------------------------------------------\nimport math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\n#threading.stack_size(10**8)\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\n# ------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n#sys.setrecursionlimit(300000)\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n        \"\"\"\n        Side effect!!! Changes node. Node should have exactly one child\n        \"\"\"\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\n\n# -----------------------------------------------binary seacrh tree---------------------------------------\nclass SegmentTree1:\n    def __init__(self, data, default=2**30, func=lambda a, b: min(a , b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b:a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------------------iye ha chutiya zindegi-------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\n\n# --------------------------------------iye ha combinations ka zindegi---------------------------------\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n // 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\n\n# --------------------------------------iye ha power ka zindegi---------------------------------\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\n\n# --------------------------------------------------product----------------------------------------\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\n\n# --------------------------------------------------binary----------------------------------------\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) / 2)\n\n        # Check if middle element is\n        # less than or equal to key\n        if (arr[mid] < key):\n            count = mid + 1\n            left = mid + 1\n\n        # If key is smaller, ignore right half\n        else:\n            right = mid - 1\n\n    return count\n\n\n# --------------------------------------------------binary----------------------------------------\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    # Stores the index of the left most element\n    # from the array which is greater than k\n    leftGreater = n\n\n    # Finds number of elements greater than k\n    while (l <= r):\n        m = int(l + (r - l) / 2)\n        if (arr[m] > k):\n            leftGreater = m\n            r = m - 1\n\n        # If mid element is less than\n        # or equal to k update l\n        else:\n            l = m + 1\n\n    # Return the count of elements\n    # greater than k\n    return (n - leftGreater)\n\n\n# --------------------------------------------------binary------------------------------------\nclass TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEndOfWord = False\nclass Trie:\n    def __init__(self):\n        self.root = self.getNode()\n    def getNode(self):\n        return TrieNode()\n    def _charToIndex(self, ch):\n        return ord(ch) - ord('a')\n    def insert(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n        pCrawl.isEndOfWord = True\n    def search(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return False\n            pCrawl = pCrawl.children[index]\n        return pCrawl != None and pCrawl.isEndOfWord\n#-----------------------------------------trie---------------------------------\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.count=0\n        self.left = None  # left node for 0\n        self.right = None  # right node for 1\nclass BinaryTrie:\n    def __init__(self):\n        self.root = Node(0)\n    def insert(self, pre_xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = pre_xor & (1 << i)\n            if val:\n                if not self.temp.right:\n                    self.temp.right = Node(0)\n                self.temp = self.temp.right\n                self.temp.count+=1\n            if not val:\n                if not self.temp.left:\n                    self.temp.left = Node(0)\n                self.temp = self.temp.left\n                self.temp.count += 1\n        self.temp.data = pre_xor\n    def query(self, xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = xor & (1 << i)\n            if not val:\n                if self.temp.left and self.temp.left.count>0:\n                    self.temp = self.temp.left\n                elif self.temp.right:\n                    self.temp = self.temp.right\n            else:\n                if self.temp.right and self.temp.right.count>0:\n                    self.temp = self.temp.right\n                elif self.temp.left:\n                    self.temp = self.temp.left\n            self.temp.count-=1\n        return xor ^ self.temp.data\n#-------------------------bin trie-------------------------------------------\nn,m=map(int,input().split())\nl=[]\npm=2**m-1\nfor i in range(n):\n    l.append(list(map(int,input().split())))\ndef find (x):\n    s=set()\n    d=defaultdict(int)\n    for i in range(n):\n        a=\"\"\n        for j in range(m):\n            if l[i][j]>=x:\n                a+='1'\n            else:\n                a+='0'\n        d[int(a,2)]=i\n        s.add(int(a,2))\n    s=list(s)\n    #print(s)\n    for i in range(len(s)):\n        for j in range(i,len(s)):\n            if s[i]|s[j]==pm:\n                return [d[s[i]]+1,d[s[j]]+1]\n    return [-1,-1]\nst=0\nend=10**9\nans=(0,0)\nwhile(st<=end):\n    mid=(st+end)//2\n    s=find(mid)\n    if s[0]!=-1:\n        ans=s\n        st=mid+1\n    else:\n        end=mid-1\nprint(*ans)", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\n# ------------------------------\n# f = open('./input.txt')\n# sys.stdin = f\n\ndef main():\n    n, k = RL()\n    cds = RLL()\n    fn = RLL()\n    sc = [0]+RLL()\n\n    rec = set(fn)\n    uses = 0\n    dic = defaultdict(int)\n    for i in cds:\n        if i in rec:\n            dic[i]+=1\n            uses+=1\n\n    dp = [[0]*(n*k+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(1, n*k+1):\n            for l in range(k+1):\n                if l>j: break\n                val = sc[l]\n                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)\n    res = 0\n\n    for i, v in Counter(fn).items():\n        res+=dp[v][dic[i]]\n    # for i in dp: print(i)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n\n", "complexity": "cubic", "problem": "0999_F", "from": "CODEFORCES", "tags": "dp"}
{"src": "n = int(input())\nax, ay = map(int, input().split())\nbx, by = map(int, input().split())\ncx, cy = map(int, input().split())\n\nif bx < ax < cx:\n    print(\"NO\")\nelif cx < ax < bx:\n    print(\"NO\")\nelif by < ay < cy:\n    print(\"NO\")\nelif cy < ay < by:\n    print(\"NO\")\nelse:\n    print(\"YES\")", "complexity": "constant", "problem": "1033_A", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation"}
{"src": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\npoints = [(x1, y1), (x2, y2), (y3, x3)]\n\ndef gen_points(A, B):\n\t'''\n\t+--.\n\t|\n\t|\n\t.\n\t'''\n\n\treturn [(A[0], B[1]), (B[0], A[1])]\n\npoints += gen_points([x1, y1], [x2, y2])\npoints += gen_points([x2, y2], [x3, y3])\npoints += gen_points([x1, y1], [x3, y3])\n\npoints = list(set(points))\n\nans = 1e9\nans_l = []\n\ndef mark_points(A, B):\n\tA = list(A)\n\tB = list(B)\n\td = set()\n\tx_s = 1 if A[0] < B[0] else -1\n\ty_s = 1 if A[1] < B[1] else -1\n\td.add((A[0], A[1]))\n\twhile A[0] != B[0]:\n\t\tA[0] += x_s\n\t\td.add((A[0], A[1]))\n\twhile A[1] != B[1]:\n\t\tA[1] += y_s\n\t\td.add((A[0], A[1]))\n\treturn d\n\nfor el in points:\n\td = mark_points([x1, y1], el).union(mark_points([x2, y2], el))\n\td = d.union(mark_points([x3, y3], el))\n\tif len(d) < ans:\n\t\tans = len(d)\n\t\tans_l = d\n\nprint(ans)\nfor el in ans_l:\n\tprint(*el)", "complexity": "quadratic", "problem": "1086_A", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "from itertools import combinations\n \nn,l,r,x = map(int,input().split())\na=list(map(int,input().split()))\n \nc=[]\nfor i in range(2,n+1):\n\tc+=list(combinations(a,i))\n \ncnt=0\n \nfor t in c:\n\tm=min(t)\n\tM=max(t)\n\ts=sum(t)\n\tif M-m >=x and (s>=l and s<=r):\n\t\tcnt+=1\n \nprint(cnt)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import sys\n \np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.buffer.readline())\ndef MI(): return map(int, sys.stdin.buffer.readline().split())\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef BI(): return sys.stdin.buffer.readline().rstrip()\ndef SI(): return sys.stdin.buffer.readline().rstrip().decode()\ndef li(): return [int(i) for i in input().split()]\ndef lli(rows): return [li() for _ in range(rows)]\ndef si(): return input()\ndef ii(): return int(input())\ndef ins(): return input().split()\n\n\nn,m=MI()\nposf=(n*(n-1))//2\nif(n%2!=0):\n    negf=(n//2)*(n//2+1)\nelse:\n    negf=(n//2)*(n//2-1)+n//2\nans=0\nfor i in range(m):\n    x,d=MI()\n    ans+=n*x\n    if(d>=0):\n        ans+=posf*d\n    else:\n        ans+=negf*d\nprint(ans/n)", "complexity": "linear", "problem": "1009_C", "from": "CODEFORCES", "tags": "greedy,math"}
{"src": "n, k = map(int, input().split())\nr_n = n * 2\ng_n = n * 5\nb_n = n * 8\nt = 0\nt += r_n // k\nif r_n % k != 0:\n    t += 1\nt += g_n // k\nif g_n % k != 0:\n    t += 1\n\nt += b_n // k\nif b_n % k != 0:\n    t += 1\nprint(t)\n", "complexity": "constant", "problem": "1080_A", "from": "CODEFORCES", "tags": "math"}
{"src": "\n\n\n\nn,k = map(int,input().split())\n\n\nt  = list(map(int,input().split()))\n\nt.sort()\n\n\nf={}\n\nfor j in t:\n    if j not in f:\n        f[j]=1\n    else:\n        f[j]+=1\n\n\np=0\nfor j in range(n):\n    if j<n-1:\n        if t[j+1]>t[j] and t[j]+k >= t[j+1]:\n            p+=f[t[j]]\n    \nprint(n-p)\n", "complexity": "nlogn", "problem": "0990_B", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n = I()\n    aa = [LI() for _ in range(n)]\n    r = []\n    for a,b in aa:\n        al = a + (1-a%2)\n        ar = b - (1-b%2)\n        sa = (ar-al) // 2 + 1\n        tr = -(al+ar) * sa // 2\n\n        bl = a + (a%2)\n        br = b - (b%2)\n        sb = (br-bl) // 2 + 1\n        tr += (bl+br) * sb // 2\n        r.append(tr)\n\n    return \"\\n\".join(map(str,r))\n\n\nprint(main())\n", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "n, m = map(int, input().split())\na = 1\nfor i in range(n - 1):\n  a *= 10\n  a += 1\nb = 10 ** n - a\nprint(a)\nprint(b)", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "s = input()\nwhile s!=\"\":\n\tif s==s[::-1]:\n\t\ts=s[:(len(s)-1)]\n\telse:\n\t\tbreak\nprint(len(s))", "complexity": "linear", "problem": "0981_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "import os\nfrom io import BytesIO, IOBase\nimport sys\n \n \ndef main():\n    n = int(input())\n    a = list(map(int,input().split()))\n    a = set(a)\n    a = list(sorted(list(a)))\n    if len(a) == 1:\n        print(\"NO\")\n    else:\n        print(a[1])\n    return\n \n \n# region fastio\nBUFSIZE = 1048576\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip('\\r\\n')\n \n# endregion\n \n \nif __name__ == '__main__':\n    main()", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "t=int(input())\nfor i in range(t):\n    n,k=map(int,input().split())\n    if n>32:\n        print(\"YES\",n-1)\n    else:\n        max_splits=(4**n-1)//3\n        if k>max_splits or (n,k)==(2,3):\n            print(\"NO\")\n        else:\n            done=False\n            for i in range(n):\n                if k<2**(i+2)-i-3:\n                    print(\"YES\",n-i)\n                    done=True\n                    break\n            if not done:\n                print(\"YES\",0)", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "# problem: https://codeforces.com/contest/903/problem/D\n# idea: https://www.programmersought.com/article/86646430026/\n# import numpy as np\n\n\n# def almost_difference():\n#     n = int(input())\n#     if n == 1:\n#         return 0\n#     # n = 5\n#     # array = [1,2,3,1,3]\n#     # n = 4\n#     # array = [6,6,4,4]\n#     x = np.zeros(1000000)\n#     # int from 1... -> 10^9\n#     # normal array declaration took over 3s. so used array from numpy\n#     count_equal = np.zeros(10**9+1)\n#     array = [int(el) for el in input().split()]\n#     ad_sum = 0\n#     prev_sum = 0\n#     for i in range(n):\n#         # formula from the: https://www.programmersought.com/article/86646430026/\n#         ad_sum = ad_sum + i * array[i] - prev_sum +count_equal[array[i]+1] - count_equal[array[i]-1]\n#         count_equal[array[i]] += 1\n#         prev_sum += array[i]\n \n#     return ad_sum\n \n \n# print(almost_difference())\n\n\n\ndef almost_difference():\n    n = int(input())\n    if n == 1:\n        return 0\n    # n = 5\n    # array = [1,2,3,1,3]\n    # n = 4\n    # array = [6,6,4,4]\n    # x = np.zeros(1000000)\n    # int from 1... -> 10^9\n    # normal array declaration took over 3s. so used array from numpy\n    dict_equal = dict()\n    array = [int(el) for el in input().split()]\n    ad_sum = 0\n    prev_sum = 0\n    for i in range(n):\n        if not array[i] in dict_equal.keys():\n            dict_equal[array[i]] = 0\n        if not array[i]-1 in dict_equal.keys():\n            dict_equal[array[i]-1] = 0\n        if not array[i]+1 in dict_equal.keys():\n            dict_equal[array[i]+1] = 0\n\n        # formula from the: https://www.programmersought.com/article/86646430026/\n        ad_sum = ad_sum + i * array[i] - prev_sum +dict_equal[array[i]+1] - dict_equal[array[i]-1]\n        dict_equal[array[i]] += 1\n        prev_sum += array[i]\n \n    return ad_sum\n\nprint(almost_difference())\n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "n=int(input())\na=list(map(int,input().split()))\np=0\nwhile p+1<len(a) and a[p]==a[p+1]:\n    p+=2\nc=0\nwhile p<len(a):\n    if p+1<len(a):\n        i=a.index(a[p],p+1)\n        c+=i-p-1\n        tmp=a.pop(i)\n        a.insert(p,tmp)\n    while p+1<len(a) and a[p]==a[p+1]:\n        p+=2\nprint(c)", "complexity": "quadratic", "problem": "0995_B", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n + 1) for _ in range(3024)]\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n    e[v][i] = i\n    d[i].append(i)\nfor v in range(1, 3024):\n    for i in range(n):\n        j = e[v][i]\n        h = e[v][j + 1] if j != -1 else -1\n        if j != -1 and h != -1:\n            e[v + 1][i] = h\n            d[i].append(h)\n\na = [_ for _ in range(1, n + 1)]\nfor s in range(n):\n    for e in d[s]:\n        a[e] = min(a[e], a[s - 1] + 1 if s > 0 else 1)\nprint(a[n - 1])\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import math\n#t=int(input())\n#for i in range(t):\nn,m = map(int, input().strip().split(' '))\n#lst = list(map(int, input().strip().split(' ')))\ns=input()\nt=input()\nif '*' not in s:\n    if s==t:\n        print('YES')\n    else:\n        print('NO')\nelif n>m+1:\n    print('NO')\nelif n==1 and s=='*':\n    print('YES')\nelse:\n    s=list(s)\n    t=list(t)\n    if s[0]=='*':\n        if s[1:]==t[-(len(s[1:])):]:\n            print('YES')\n        else:\n            print('NO')\n    elif s[-1]=='*':\n        if s[:n-1]==t[:n-1]:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        ind=s.index('*')\n        #print(ind)\n        #print(s[ind+1:])\n        #print(t[-len(s[ind+1:]):])\n        if s[:ind]==t[:ind] and s[ind+1:]==t[-len(s[ind+1:]):]:\n            print('YES')\n        else:\n            print('NO')\n        \n\n", "complexity": "linear", "problem": "1023_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "i=int(input())\nd=i%2+8;print(d,i-d)", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn,T=map(int,input().split())\nS=[list(map(int,input().split())) for i in range(n)]\n\nDP=[[0]*(4) for i in range(T+1)]\nmod=10**9+7\n\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef calc(used,recent,time):\n    ANS=0\n    for i in range(n):\n        #print(i,used)\n        if i in used:\n            continue\n        if time+S[i][0]>T:\n            continue\n        if S[i][1]==recent:\n            continue\n        if time+S[i][0]==T:\n            ANS+=1\n        if time+S[i][0]<T:\n            used2=list(used)+[i]\n            used2.sort()\n            recent2=S[i][1]\n            time2=time+S[i][0]\n            ANS=(ANS+calc(tuple(used2),recent2,time2))%mod\n\n    return ANS\n\nprint(calc(tuple(),-1,0)%mod)\n    \n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "n, m = map(int, input().split())\na = []\narray = []\nfor i in range(n):\n    a.append(list(map(str, input())))\n    listt = []\n    for c in range(m):\n        if a[i][c] == '#':\n            listt.append(1)\n        else:\n            listt.append(0)\n    array.append(listt)\nfor y in range(1, n - 1):\n    for x in range(1, m - 1):\n        f = a[y + 1][x] == '#' and a[y + 1][x + 1] == '#' and a[y + 1][x - 1] == '#'\n        s = a[y][x + 1] == '#' and a[y][x - 1] == '#'\n        th = a[y - 1][x] == '#' and a[y - 1][x + 1] == '#' and a[y - 1][x - 1] == '#'\n        if f and s and th:\n            array[y + 1][x] -= 1\n            array[y + 1][x + 1] -= 1\n            array[y + 1][x - 1] -= 1\n            array[y][x + 1] -= 1\n            array[y][x - 1] -= 1\n            array[y - 1][x - 1] -= 1\n            array[y - 1][x] -= 1\n            array[y - 1][x + 1] -= 1\nmb = True\nfor y in range(n):\n    for x in range(m):\n        if array[y][x] == 1:\n            mb = False\n            break\nif mb:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\n\n\nn = int(input())\nd={}\nfor _ in range(n):\n    a,b = map(int,input().split())\n    d[a] = b\n\ns=0\nm = int(input())\nfor _ in range(m):\n    x,y = map(int,input().split())\n\n    if x in d:\n        d[x] = max(d[x],y)\n\n    else:\n        d[x] = y\n\nfor i in d:\n\n    s+=d[i]\nprint(s)\n\n", "complexity": "nlogn", "problem": "0981_B", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import sys\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nN, M, K = map(int, input().split())\nP = []\nD_P = {}\n\nfor i in range(N):\n\tS = input()\n\tP.append(S)\n\tD_P[S] = i\n\nadj = [[] for _ in range(N)]\nindeg = [0] * N\n\nfor _ in range(M):\n\tS, mt = input().split()\n\tmt = int(mt)-1\n\n\tfp = P[mt]\n\n\tif any(fp[i] not in (S[i], '_') for i in range(K)):\n\t\tprint('NO')\n\t\traise SystemExit\n\n\tfor bs in range(1<<K):\n\t\tpat = ''.join(S[i] if bs & (1<<i) == 0 else '_' for i in range(K))\n\t\tif pat == fp: continue\n\t\tif pat in D_P:\n\t\t\tj = D_P[pat]\n\t\t\tindeg[j] += 1\n\t\t\tadj[mt].append(j)\n\nQ = [i for i in range(N) if indeg[i] == 0]\nfor i in Q:\n\tfor j in adj[i]:\n\t\tindeg[j] -= 1\n\t\tif indeg[j] == 0:\n\t\t\tQ.append(j)\n\nif len(Q) == N:\n\tprint('YES')\n\tprint(' '.join(str(v+1) for v in Q))\nelse:\n\tprint('NO')\n", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "#########################################################################################################\\\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\nimport sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math \n\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):  \n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n    \"\"\"\n    L is a list.\n    The function returns the power set, but as a list of lists.\n    \"\"\"\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n    \n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n        \n    #the function could stop here closing with\n    #return powerset\n\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n        \n    return powerset_orderred\ndef fastPlrintNextLines(a):\n    # 12\n    # 3\n    # 1\n    #like this\n    #a is list of strings\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\n#__________________________TEMPLATE__________________OVER_______________________________________________________\n\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\") \n# else:\n#     input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nt = 1\n# t = int(input())\nfor _ in range(t):\n    n,k = li()\n    s = list(si())\n    cnt = 0\n    ans = []\n    covered = 0\n    for i in range(n):\n        if (s[i]=='('):\n            cnt+=1\n            ans.append('(')\n        else:\n            ans.append(')')\n            covered+=1\n        if cnt==k//2:\n            break\n    ans+=[')']*(k//2-covered)\n    print(''.join(ans))", "complexity": "linear", "problem": "1023_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "n = int(input())\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\nif (x2 < x1 and x3 < x1 or x2 > x1 and x3 > x1) and (y2 < y1 and y3 < y1 or y2 > y1 and y3 > y1):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "constant", "problem": "1033_A", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation"}
{"src": "import sys\nimport math\nimport collections\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n,k=get_ints()\n    arr=get_list()\n    ans=0\n    for i in range(n):\n        val=arr[i]\n        c=1\n        sol=0\n        if c >= k:\n            sol = max(sol, val / c)\n        for j in range(i+1,n):\n            val+=arr[j]\n            c+=1\n            if c>=k:\n                sol=max(sol,val/c)\n        ans=max(sol,ans)\n    print(ans)", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "n=int(input())\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\nif l[0]!=0 or r[n-1]!=0:\n    print(\"NO\")\n    exit(0)\ns=[(l[i]+r[i]) for i in range(n)]\nm=max(s)+1\nk=[]\nfor i in s:\n    k.append(m-i)\nl1=[]\nr1=[]\n\nfor i in range(n):\n    c=0\n    d=0\n    for j in range(0,i):\n        if k[j]>k[i]:\n            c+=1\n    l1.append(c)\n    for j in range(i+1,n):\n        if k[j]>k[i]:\n            d+=1\n    r1.append(d)\nif l1!=l or r1!=r:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*k)\n        \n    \n    \n\n    ", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "import sys\n\n\nclass fenwick():\n    \"\"\"\n    This Tree Data Structure speeds up caliculating summations of partial sum \n    and also updating subsets of sequences. Both queries finish in logarithmic times.\n    \"\"\"\n    # 1-indexed\n\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+1)\n\n    def to_sum(self, i):\n        # return sigma(a_j) (0<=j<=i)\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, x):\n        #a_i -> a_i + x\n        while i <= self.n:\n            self.data[i] += x\n            i += (i & -i)\n\n    def get(self, i, j):\n        # return sigma(a_k) (i<=k<=j)\n        # assert 1<=i<=j<= N\n        return self.to_sum(j)-self.to_sum(i-1)\n\n\ndef input():\n    return sys.stdin.buffer.readline()\n\n\nn = int(input())\npermutation = list(map(int, input().split()))\nseq = [(permutation[i], i + 1) for i in range(n)]\nseq.sort(reverse=True)\n\nm = int(input())\nquery = [tuple(map(int, input().split())) for i in range(m)]\n\n#count whole inversion\n\nWHOLE_INVERSION = 0\nfenwick_1 = fenwick(n)\n\nfor value, index in seq:\n    WHOLE_INVERSION += fenwick_1.get(1, index)\n    fenwick_1.add(index, 1)\n\nfor l, r in query:\n    d = r - l + 1\n    WHOLE_INVERSION += d*(d-1)//2\n    if WHOLE_INVERSION % 2 != 0:\n        print(\"odd\")\n    else:\n        print(\"even\")\n\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import math\nsone= list(input())\nstwo = list(input())\nsum1=0\nsum2=0\nm=0\nfor i in range(len(sone)):\n    if sone[i]=='+':\n        sum1=sum1 + 1\n        m=m+1\n    else:\n        sum1=sum1 - 1\nk=0        \nfor i in range(len(stwo)):\n    if stwo[i]=='+':\n        sum2=sum2 + 1\n        k=k\n    elif stwo[i]=='-':\n        sum2=sum2 - 1\n        k=k\n    elif stwo[i]=='?':\n        k=k+1\nn=0\nif (k-(abs(sum1-sum2)))<0:\n    print(float (0))\nelif (k-(abs(sum1-sum2)))==0:\n    if k==0:\n        print(float (1))\n    else:\n        print(float (pow(0.5,k)))\n             \nelse:\n    n=k-(abs(sum1-sum2))\n    n=abs(sum1-sum2)+n/2\n    if abs(sum1-sum2)==0:\n        print(float ((math.factorial(k)/(math.factorial(k/2)*math.factorial(k/2))) * pow(0.5,k)))\n    else:\n        print(float ((math.factorial(k)/(math.factorial(k-n) * math.factorial(n))) * pow(0.5,k)))", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "from sys import stdin\ninput = stdin.buffer.readline\n    \nn=int(input())\narr=[int(x) for x in input().split()]\n\narr.sort()\ns=set(arr)\nflag=False\nfor ele in arr:\n    for i in range(31):\n        if ((ele-2**i) in s) and ((ele+2**i) in s):\n            ans=[ele,ele-2**i,ele+2**i]\n            flag=True\n            break\n    if flag:\n        break\nif flag:\n    print(3) \n    print(*ans)    \n    exit()\nfor ele in arr:\n    for i in range(31):\n        if (ele+2**i) in s:\n            ans=[ele,ele+2**i]\n            flag=True\n            break\n    if flag:\n        break\nif flag:\n    print(2)\n    print(*ans)\nelse:\n    print(1)\n    print(arr[0])", "complexity": "nlogn", "problem": "0988_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "l,r=tuple(map(int,input().split(\" \")))\nx=l^r\npow=1\nwhile(pow<=x) :\n    pow*=2\n    \nprint(pow-1)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n = int(input())\nm = int(input())\nif(n<=26):\n    print(m%(2**n))\nelse:\n    print(m)\n    ", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n,l,r,x = [int(x) for x in input().split(\" \")]\narr = [int(x) for x in input().split(\" \")]\nans = 0\nfor i in range(2**n):\n\tsubset = [] \n\tfor j in range(n): \n\t\tif (i & (1 << j)) != 0: \n\t\t\tsubset.append(arr[j])\n\tif len(subset)>1:\n\t    mx = max(subset)\n\t    mn = min(subset)\n\t    sm = sum(subset)\n\t    if l<=sm<=r and mx-mn>=x:\n\t        ans+=1\nprint(ans)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "k = int(input())\ns = k\ni = 1\nnumber_digits = 1\nwhile s - (i * (9 * 10 ** (i - 1))) > 0:\n    number_digits = number_digits + 1\n    s = s - (i * (9 * 10 ** (i - 1)))\n    i += 1\nv = (s - 1) // number_digits\ns = s - v * number_digits\nans = 10 ** (number_digits - 1) + v\nans = str(ans)\nfans = ans[s - 1]\nprint(fans)\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "n,m,k=list(map(int,input().split()))\np=[]\nfor _ in range(n):\n    p.append(list(map(int,input().split())))\nq=[]\nfor _ in range(n-1):\n    q.append(list(map(int,input().split())))\ndef f(g):\n    r=[[0]*m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            l=[]\n            if i-1>=0:\n                l.append(g[i-1][j]+q[i-1][j])\n            if i+1<n:\n                #print(i,j)\n                l.append(g[i+1][j]+q[i][j])\n            if j-1>=0:\n                l.append(g[i][j-1]+p[i][j-1])\n            if j+1<m:\n                l.append(g[i][j+1]+p[i][j])\n            r[i][j]=min(l)\n    return r\ng=[[0]*m for _ in range(n)]\nif k%2!=0:\n    for i in range(n):\n        for j in range(m):\n            g[i][j]=-1\n        print(*g[i])\nelse:\n    for _ in range(k//2):\n       g=f(g)\n    for i in range(n):\n        for j in range(m):\n            g[i][j]*=2\n        print(*g[i])\n        ", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "r, g, b = map(int, input().split())\nR = list(map(int, input().split()))\nG = list(map(int, input().split()))\nB = list(map(int, input().split()))\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\n\nmemo = [[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]\n\ndef calc(ir, ig, ib):\n    if memo[ir][ig][ib] != -1:\n        return memo[ir][ig][ib]\n    ans = 0\n    if ir < r and ig < g:\n        ans = max(ans, calc(ir+1, ig+1, ib)+R[ir]*G[ig])\n    if ir < r and ib < b:\n        ans = max(ans, calc(ir+1, ig, ib+1)+R[ir]*B[ib])\n    if ig < g and ib < b:\n        ans = max(ans, calc(ir, ig+1, ib+1)+G[ig]*B[ib])\n    memo[ir][ig][ib] = ans\n    return ans\n\nprint(calc(0, 0, 0))\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "candies = 0\nn, k = map(int,input().split())\nsumm = 0\nif k == 0:\n    for i in range (n-1,-1,-1):\n        summ = summ + 1\n        candies = candies + summ\n        if candies == i:\n            print(i)\n            break\n\nif k != 0:\n    for i in range (n-1,-1,-1):\n        summ = summ + 1\n        candies = candies + summ\n        if candies - i == k:\n            print(i)\n            break\n  \t\t\t \t\t \t\t\t \t \t\t\t\t\t\t  \t  \t\t\t", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "print(25)", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "n, m = map(int, input().split())\nu = []\nu1 = []\nfor i in range(n):\n    u.append(list(input()))\n    u1.append(['.'] * m)\nfor i in range(n - 2):\n    for j in range(m - 2):\n        ok = True\n        for k in range(3):\n            if u[i][j + k] != '#' or u[i + k][j] != '#':\n                ok = False\n                break\n##        print(ok)\n        if ok:\n            if u[i + 2][j + 1] != '#' or u[i + 2][j + 2] != '#' or u[i + 1][j + 2] != '#':\n                ok = False\n            else:\n                for k in range(3):\n                    u1[i][j + k] = '#'\n                    u1[i + k][j] = '#'\n                u1[i + 2][j + 1] = '#'  \n                u1[i + 2][j + 2] = '#'\n                u1[i + 1][j + 2] = '#'\nok = True\n##for i in u:\n##    print(i)\n##for i in u1:\n##    print(i)\nfor i in range(n):\n    for j in range(m):\n        if u[i][j] != u1[i][j]:\n            ok = False\n            break\n    if not ok:\n        break\nif ok:\n    print('YES')\nelse:\n    print('NO')\n", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from sys import stdin, stdout, exit\n\nn, m, k = map(int, stdin.readline().split())\na = list(map(int, stdin.readline().split()))\n\ndef bf(a):\n    best = 0\n    best_arg = (-1, -1)\n    for i in range(n):\n        for j in range(i, n):\n            cur = sum(a[i:j+1]) - k*((j - i) // m + 1)\n            if cur > best:\n                best = max(best, cur)\n                best_arg = (i,j)\n    return best, best_arg\n\ndef max_sum(a):\n    if len(a) == 0:\n        return 0\n    elif len(a) == 1:\n        return max(0, a[0] - k)\n    mid = len(a) // 2\n    l_rec = max_sum(a[:mid])\n    r_rec = max_sum(a[mid:])\n    l_bests = [0]*m\n    r_bests = [0]*m\n    l_sum = 0\n    for idx in range(1,mid+1):\n        l_sum += a[mid-idx]\n        if idx % m == 0:\n            l_sum -= k\n        l_bests[idx%m] = max(l_bests[idx%m], l_sum)\n    r_sum = 0\n    for idx in range(0, len(a)-mid):\n        r_sum += a[idx+mid]\n        if (idx+1) % m == 0:\n            r_sum -= k\n        r_bests[(idx+1)%m] = max(r_bests[(idx+1)%m], r_sum)\n\n #   print(\"Array:\", a, \"mid:\", mid)\n#    print(l_bests)\n  #  print(r_bests)\n    best_acr = 0\n    for i in range(m):\n        for j in range(m):\n            best_acr = max(best_acr, l_bests[i] + r_bests[j] - (k if i+j>0 else 0) - (k if i+j>m else 0))\n    ans = max(l_rec,r_rec, best_acr)\n   # print(\"Answer:\", ans)\n    return ans\n\n\nans = max_sum(a)\nstdout.write(str(ans) + \"\\n\")\n#stdout.write(str(bf(a))+\"\\n\")\n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "import sys,os,io\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import defaultdict\n\nn,m = [int(i) for i in input().split()]\na = []\nmi = -1\nma = 10**9\nfor i in range (n):\n    a.append([int(j) for j in input().split()])\n\nans = []\nwhile(mi<ma):\n    mid = (mi+ma+1)//2\n    masks = {}\n    for i in range (n):\n        currMask = 0\n        for j in range (m):\n            if a[i][j] >= mid:\n                currMask +=  1<<j\n        masks[currMask] = i\n    req = (1<<m) - 1\n    possible = 0\n    for i in masks:\n        for j in masks:\n            if i|j == req:\n                possible = 1\n                ans = [masks[i]+1,masks[j]+1]\n                break\n        if possible:\n            break\n    if possible:\n        mi = mid\n    else:\n        ma = mid - 1\nprint(*ans)", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import math\nn=int(input())\nlst = list(map(int, input().strip().split(' ')))\n#n,r = map(int, input().strip().split(' '))\np=max(lst)\nind=lst.index(p)\nif p==1:\n    lst[ind]=2\nelse:\n    lst[ind]=1\nlst.sort()\nfor j in range(n):\n    print(lst[j],end=\" \")", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "a, b = map(int, input().split())\nc = input()\nsu = 0\ncnt = 0\nj = -2\ni = 0\nlis = \"abcdefghijklmnopqrstuvwxyz\"\nwhile i < 26 and cnt < b:\n    if lis[i] in c and i-2 >= j:\n        su += i+1\n        cnt += 1\n        j = i\n    i += 1\nif cnt < b:\n    print(-1)\nelse:\n    print(su)\n    \t  \t\t\t \t\t \t \t\t \t \t\t\t \t\t\t", "complexity": "linear", "problem": "1011_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "n, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\n\nfrom itertools import combinations\nways_to_choose = 0\nfor length in range(2, n + 1):\n    for p in combinations(c, length):\n        problemset = sorted(p)\n        if l <= sum(problemset) <= r and problemset[-1] - problemset[0] >= x:\n            ways_to_choose += 1\n\nprint(ways_to_choose)\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport itertools\nimport bisect\nimport heapq\nsys.setrecursionlimit(100000)\n#^^^TAKE CARE FOR MEMORY LIMIT^^^\ndef main():\n    pass\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\n\ndef decimal(s):\n    return (int(s, 2))\n\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n //= 2\n        p += 1\n    return (p)\n\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\n\ndef countcon(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if (s[i] == ch):\n            c += 1\n        else:\n            break\n    return (c)\n\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\ndef isSubSequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\ndef maxfac(n):\n    root = int(n ** 0.5)\n    for i in range(2, root + 1):\n        if (n % i == 0):\n            return (n // i)\n    return (n)\ndef p2(n):\n    c=0\n    while(n%2==0):\n        n//=2\n        c+=1\n    return c\ndef seive(n):\n    primes=[True]*(n+1)\n    primes[1]=primes[0]=False\n    for i in range(2,n+1):\n        if(primes[i]):\n            for j in range(i+i,n+1,i):\n                primes[j]=False\n    p=[]\n    for i in range(0,n+1):\n        if(primes[i]):\n            p.append(i)\n    return(p)\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n            p - 2, p)) % p\ndef denofactinverse(n,m):\n    fac=1\n    for i in range(1,n+1):\n        fac=(fac*i)%m\n    return (pow(fac,m-2,m))\ndef numofact(n,m):\n    fac=1\n    for i in range(1,n+1):\n        fac=(fac*i)%m\n    return(fac)\ndef sod(n):\n    s=0\n    while(n>0):\n        s+=n%10\n        n//=10\n    return s\ndef getVal(x,y,sx,sy):\n    #print(x,y,sx,sy)\n    if (x == -1 or y == -1 or x == n or y == m):\n        return inF\n    elif(sx==x):\n        return hor[sx][min(sy,y)]\n    else:\n        return ver[min(sx,x)][sy]\ndef rec(k,x,y):\n    if(x==-1 or y==-1 or x>=n or y>=m):\n        return inF\n    elif (k == 0):\n        #print(x,y)\n        dp[k][x][y] = 0\n        return dp[k][x][y]\n    elif(dp[k][x][y]!=-1):\n        return dp[k][x][y]\n    else:\n        #print(getVal(x-1,y,x,y))\n        val1=rec(k-1,x-1,y)+getVal(x-1,y,x,y)\n        val2=rec(k-1,x+1,y)+getVal(x+1,y,x,y)\n        val3=rec(k-1,x,y+1)+getVal(x,y+1,x,y)\n        val4=rec(k-1,x,y-1)+getVal(x,y-1,x,y)\n        dp[k][x][y]=min(val1,val2,val3,val4)\n        return dp[k][x][y]\nn,m,k=map(int,input().split())\nadj=[[-1]*n for i in range(0,m)]\nif(k%2):\n    for i in range(0, n):\n        for j in range(0, m):\n            print(-1, end=\" \")\n        print(\"\")\nelse:\n    hor,ver=[],[]\n    inF=10**20\n    k//=2\n    for i in range(0,n):\n        hor.append(list(map(int,input().split())))\n    for i in range(0,n-1):\n        ver.append(list(map(int,input().split())))\n    dp=[[[-1]*(m+1) for i in range(0,n+1)]for j in range(0,k+1)]\n    for i in range(0,n):\n        for j in range(0,m):\n            print(2*rec(k,i,j),end=\" \")\n        print(\"\")\n    '''\n    print(\"\\n\",getVal(0,0,0,1))\n    print(\"\\n\\n\\n\\n\\n\")\n    for k in range(0,k+1):\n        print(\"page\",k)\n        for i in range(0,n):\n            for j in range(0,m):\n                print(dp[k][i][j],end=\" \")\n            print(\"\")\n    '''\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from collections import Counter\n\ndef f(x):\n    return max(list(Counter(x).values()))\n\nn=int(input())\nz=input()\nl=len(z)\na=f(z)\nb=f(input())\nc=f(input())\n\ndef v(x):\n    if x==l:\n        return x-1\n    else:\n        return x+1\n\nif n==1:\n    a, b, c=v(a), v(b), v(c)\n    if a>b and a>c:\n        print(\"Kuro\")\n    elif b>a and b>c:\n        print(\"Shiro\")\n    elif c>a and c>b:\n        print(\"Katie\")\n    else:\n        print(\"Draw\")\nelif (l-a<=n)+(l-b<=n)+(l-c<=n)>=2:\n    print(\"Draw\")\nelif a>b and a>c:\n    print(\"Kuro\")\nelif b>a and b>c:\n    print(\"Shiro\")\nelif c>a and c>b:\n    print(\"Katie\")\nelse:\n    print(\"Draw\")\n#print((l-a<=n)+(l-b<=n)+(l-c<=n))\n#print(a, b, c)", "complexity": "linear", "problem": "0979_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "ch_0={0:[0,1,2],2:[2],1:[1],3:[1,2,3]}\nch_1={0:[3],3:[0],1:[0,3],2:[0,3]}\nch_2={0:[],3:[],2:[1],1:[2]}\nN=998244353\nn,k=map(int,input().strip().split(\" \"))\ndp=[[[0]*4 for j in range(k+5)] for i in range(n+5)]\ndp[0][1][3]=1\ndp[0][1][0]=1\ndp[0][2][1]=1\ndp[0][2][2]=1\n\nfor i in range(1,n):\n    for j in range(1,k+1):\n        for mask in range(4):\n            for t in ch_0[mask]:\n                dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j][t])%N\n            if j>1:\n                for t in ch_1[mask]:\n                    dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-1][t])%N\n                if j>2:\n                    for t in ch_2[mask]:\n                        dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-2][t])%N\nans=0\nfor mask in range(4):\n    ans=(ans+dp[n-1][k][mask])%N\nprint(ans)\n", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "\ndef maxXORInRange(L, R): \n\n\tLXR = L ^ R \n\tmsbPos = 0\n\twhile(LXR): \n\t\n\t\tmsbPos += 1\n\t\tLXR >>= 1\n\tmaxXOR, two = 0, 1\n\t\n\twhile (msbPos): \n\t\n\t\tmaxXOR += two \n\t\ttwo <<= 1\n\t\tmsbPos -= 1\n\n\treturn maxXOR \n\nL, R = [int(i) for i in input().split()]\nprint(maxXORInRange(L, R)) \n\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "def f(n,s):\n    d=[-n,-n];\n    d[s]=0;\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)];\n    return d[s];\nimport math;\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny=y+x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "import io,os,bisect;input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline;prime = [2]\nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue \n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0: flag = True;break\n    if not flag:  prime.append(i)\ndef primefactor(num):\n    index = 0;output = []\n    while num>=prime[index]**2:\n        times = 0\n        while num%prime[index]==0:num = num // prime[index];times += 1\n        if times&1:  output.append(prime[index])\n        index += 1 \n    if num>1: output.append(num)\n    return tuple(output)\nfor _ in range(int(input())):\n    n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:            bisect.insort(stack,fact[factor]+1)            \n        fact[factor] = i\n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1)\n    print(dp[-1][-1])   ", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "from sys import stdin, stdout\nn=int(input())\ns=list(map(int,stdin.readline().strip().split()))\ndp=[[-1 for i in range(n+1)]for j in range(n+1)]\nfor i in range(n):\n    dp[0][i]=s[i]\nfor i in range(1,n):\n    for j in range(n-i):\n        dp[i][j]=dp[i-1][j]^dp[i-1][j+1]\nfor i in range(1,n):\n    for j in range(n-i):\n        dp[i][j]=max(dp[i-1][j],dp[i-1][j+1],dp[i][j])\nq=int(input())\nans=\"\"\nfor i in range(q):\n    l,r=map(int,stdin.readline().strip().split())\n    print(dp[r-l][l-1])\n", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "# A. Find Square\n\nn, m = map(int, input().split())\n\ntop = [-1, -1]\nbottom = [-1, -1]\n\nmatrix = list()\nfor i in range(n):\n    s = input()\n    matrix.append(s)\n\nfor i in range(n):\n    left = matrix[i].find('B')\n    if left != -1:\n        top[0] = i\n        top[1] = left\n        break\n\nfor i in range(n-1, -1, -1):\n    right = matrix[i].rfind('B')\n    if right != -1:\n        bottom[0] = i\n        bottom[1] = right\n        break\n\nprint(1 + top[0] + (bottom[0] - top[0]) // 2, 1 + top[1] + (bottom[1] - top[1]) // 2)\n", "complexity": "quadratic", "problem": "1028_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def search(arr,power):\n    lo=0\n    hi=len(arr)-1\n    ans=-1\n    while lo<=hi:\n        mid=(lo+hi)//2\n        if arr[mid]<=power:\n            ans=mid\n            lo=mid+1\n        else:\n            hi=mid-1\n    return ans\n\nn,q = list(map(int, input().split()))\na = list(map(int, input().split()))\nk = list(map(int, input().split()))\nfor i in range(1,n):\n    a[i]+=a[i-1]\npower = 0\nfor i in range(q):\n    power+=k[i]\n    pos = search(a,power)\n    if pos==n-1:\n        print(n)\n        power=0\n    elif pos==-1:\n        print(n)\n    else:\n        print(n-pos-1)", "complexity": "nlogn", "problem": "0975_C", "from": "CODEFORCES", "tags": "binary search"}
{"src": "\nfrom bisect import bisect,bisect_left\n\nfrom collections import *\nfrom heapq import *\nfrom math import gcd,ceil,sqrt,floor,inf\n\nfrom itertools import *\nfrom operator import add,mul,sub,xor,truediv,floordiv\nfrom functools import *\n\n#------------------------------------------------------------------------\nimport os\nimport sys\n\nfrom io import BytesIO, IOBase\n# region fastio\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n\n#------------------------------------------------------------------------\ndef RL(): return map(int, sys.stdin.readline().split())\ndef RLL(): return list(map(int, sys.stdin.readline().split()))\ndef N(): return int(input())\ndef A(n):return [0]*n\ndef AI(n,x): return [x]*n\ndef A2(n,m): return [[0]*m for i in range(n)]\ndef G(n): return [[] for i in range(n)]\ndef GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]\n#------------------------------------------------------------------------\n\n\nfrom types import GeneratorType\n \n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n \n    return wrappedfunc\n\nmod=10**9+7\nfarr=[1]\nifa=[]\n \ndef fact(x,mod=0):\n    if mod:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr)%mod)\n    else:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr))\n    return farr[x]\n \ndef ifact(x,mod):\n    global ifa\n    fact(x,mod)\n    ifa.append(pow(farr[-1],mod-2,mod))\n    for i in range(x,0,-1):\n        ifa.append(ifa[-1]*i%mod)\n    ifa.reverse()\n \ndef per(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return fact(i)//fact(i-j)\n    return farr[i]*ifa[i-j]%mod\n    \ndef com(i,j,mod=0):\n    if i<j: return 0\n    if not mod:        \n        return per(i,j)//fact(j)\n    return per(i,j,mod)*ifa[j]%mod\n \ndef catalan(n):\n    return com(2*n,n)//(n+1)\n \ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef floorsum(a,b,c,n):#sum((a*i+b)//c for i in range(n+1))\n    if a==0:return b//c*(n+1)\n    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2\n    m=(a*n+b)//c\n    return n*m-floorsum(c,c-b-1,a,m-1)\n\ndef inverse(a,m):\n    a%=m\n    if a<=1: return a\n    return ((1-inverse(m,a)*m)//a)%m\n \ndef lowbit(n):\n    return n&-n\n \nclass BIT:\n    def __init__(self,arr):\n        self.arr=arr\n        self.n=len(arr)-1\n        \n    def update(self,x,v):\n        while x<=self.n:\n            self.arr[x]+=v\n            x+=x&-x\n \n    def query(self,x):\n        ans=0\n        while x:\n            ans+=self.arr[x]\n            x&=x-1\n        return ans\n\nclass ST:\n    def __init__(self,arr):#n!=0\n        n=len(arr)\n        mx=n.bit_length()#\u53d6\u4e0d\u5230\n        self.st=[[0]*mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0]=arr[i]\n        for j in range(1,mx):\n            for i in range(n-(1<<j)+1):\n                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])\n    def query(self,l,r):\n        if l>r:return -inf\n        s=(r+1-l).bit_length()-1\n        return max(self.st[l][s],self.st[r-(1<<s)+1][s])\n        \nclass DSU:#\u5bb9\u91cf+\u8def\u5f84\u538b\u7f29\n    def __init__(self,n):\n        self.c=[-1]*n\n \n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n \n    def find(self,x):\n        if self.c[x]<0:\n            return x\n        self.c[x]=self.find(self.c[x])\n        return self.c[x]\n \n    def union(self,u,v):\n        u,v=self.find(u),self.find(v)\n        if u==v:\n            return False\n        if self.c[u]>self.c[v]:\n            u,v=v,u\n        self.c[u]+=self.c[v]\n        self.c[v]=u\n        return True\n \n    def size(self,x): return -self.c[self.find(x)]\n    \nclass UFS:#\u79e9+\u8def\u5f84\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n \n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n\nclass UF:#\u79e9+\u8def\u5f84+\u5bb9\u91cf\uff0c\u8fb9\u6570\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n        self.size=AI(n,1)\n        self.edge=A(n)\n \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n \n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            self.edge[pu]+=1\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            self.edge[pu]+=self.edge[pv]+1\n            self.size[pu]+=self.size[pv]\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n            self.edge[pv]+=self.edge[pu]+1\n            self.size[pv]+=self.size[pu]\n \ndef Prime(n):\n    c=0\n    prime=[]\n    flag=[0]*(n+1) \n    for i in range(2,n+1):\n        if not flag[i]:\n            prime.append(i)\n            c+=1\n        for j in range(c):\n            if i*prime[j]>n: break\n            flag[i*prime[j]]=prime[j]\n            if i%prime[j]==0: break\n    return flag\n \ndef dij(s,graph):\n    d=AI(n,inf)\n    d[s]=0\n    heap=[(0,s)]\n    vis=A(n)\n    while heap:\n        dis,u=heappop(heap)\n        if vis[u]:\n            continue\n        vis[u]=1\n        for v,w in graph[u]:\n            if d[v]>d[u]+w:\n                d[v]=d[u]+w\n                heappush(heap,(d[v],v))\n    return d\n\ndef bell(s,g):#bellman-Ford\n    dis=AI(n,inf)\n    dis[s]=0\n    for i in range(n-1):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n    change=A(n)\n    for i in range(n):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n                change[v]=1\n    return dis\n\ndef lcm(a,b): return a*b//gcd(a,b)\ndef lis(nums):\n    res=[]\n    for k in nums:\n        i=bisect.bisect_left(res,k)\n        if i==len(res):\n            res.append(k)\n        else:\n            res[i]=k\n    return len(res)\n\ndef RP(nums):#\u9006\u5e8f\u5bf9\n    n = len(nums)\n    s=set(nums)\n    d={}\n    for i,k in enumerate(sorted(s),1):\n        d[k]=i\n    bi=BIT([0]*(len(s)+1))\n    ans=0\n    for i in range(n-1,-1,-1):\n        ans+=bi.query(d[nums[i]]-1)\n        bi.update(d[nums[i]],1)\n    return ans\n \nclass DLN:\n    def __init__(self,val):\n        self.val=val\n        self.pre=None\n        self.next=None\n\ndef nb(i,j,n,m):\n    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:\n        if 0<=ni<n and 0<=nj<m:\n            yield ni,nj\n\ndef topo(n):\n    q=deque()\n    res=[]\n    for i in range(1,n+1):\n        if ind[i]==0:\n            q.append(i)\n            res.append(i)\n    while q:\n        u=q.popleft()\n        for v in g[u]:\n            ind[v]-=1\n            if ind[v]==0:\n                q.append(v)\n                res.append(v)\n    return res\n\n@bootstrap\ndef gdfs(r,p):\n    for ch in g[r]:\n        if ch!=p:\n            yield gdfs(ch,r)\n    yield None\n\n        \n#from random import randint\n'''\ndef f(n):\n    s=set()\n    for order in permutations(range(n)):\n        res=A(n)\n        cur=[]\n        for i in order:\n            if res[i]==0:\n                res[i]=1\n                if i>=2 and res[i-2]==1 and res[i-1]==0:\n                    res[i-1]=1\n                if i<n-2 and res[i+2]==1 and res[i+1]==0:\n                    res[i+1]=1\n                cur.append(i)\n        s.add(tuple(cur))\n    print(len(s))\n    for x in s:\n        print(x)\n    #print(s)'''\n\nt=1\nfor i in range(t):\n    n,mod=RL()\n    #f(n)\n    ma=(n+1)//2\n    ifact(n,mod)\n    dp=A2(n+1,ma+1)\n    f=A(n+1)\n    f[1]=1\n    f[2]=2\n    f[3]=4\n    for i in range(4,n+1):\n        f[i]=f[i-1]*2%mod\n    dp[1][1]=1\n    dp[2][1]=2\n    dp[3][1]=4\n    dp[3][2]=2\n    for i in range(4,n+1):\n        dp[i][1]=f[i]\n        for k in range(2,(i+1)//2+1):\n            for x in range(1,i-2*k+3):\n                #print(k,x)\n                dp[i][k]+=dp[i-x-1][k-1]*f[x]%mod*ifa[x]%mod*fact(i-k+1,mod)%mod*ifa[i-k-x+1]%mod\n                dp[i][k]%=mod\n    ans=0\n    for k in range(1,ma+1):\n        ans=(ans+dp[n][k])%mod\n    print(ans)\n   \n\n        \n\n\n\n                 \n    \n    \n''' \nsys.setrecursionlimit(200000)\nimport threading\nthreading.stack_size(10**8)\nt=threading.Thr\nead(target=main)\nt.start()\nt.join()\n'''\n\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "# https://codeforces.com/problemset/problem/909/D\ndef process(a):\n    assert len(a) >= 2\n    \n    n    = len(a)\n    min_ = float('inf')\n\n    for i, [cnt, c] in enumerate(a):\n        if i == 0 or i == n-1:\n            min_ = min(min_, cnt)\n        else:\n            min_ = min(min_, (cnt+1) //2) \n    \n    b    = []\n    for i, [cnt, c] in enumerate(a):\n        if i == 0 or i == n-1:\n            remain = cnt - min_\n        else:\n            remain = cnt - min_ * 2\n        \n        if remain <= 0:\n            continue\n        \n        if len(b) == 0 or c != b[-1][1]:\n            b.append([remain, c])\n        else:\n            pre_cnt, pre_c  = b.pop()\n            b.append([pre_cnt+remain, c])\n    \n    return b, min_        \n\nS   = input() + ' '\ncur = []\n\ncnt = 0\npre = ''\nfor x in S:\n    if cnt == 0:\n        cnt+= 1\n        pre = x\n    elif x!=pre:\n        cur.append([cnt, pre])\n        cnt = 1\n        pre = x\n    else:\n        cnt+=1\n\ncnt = 0\nwhile len(cur) not in [0, 1]: \n    cur, min_ = process(cur)\n    cnt+=min_\n    \nprint(cnt)    ", "complexity": "linear", "problem": "0909_D", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "import sys\nimport math\nimport itertools\nimport functools\nimport collections\nimport operator\nimport fileinput\nimport copy\n\n\nORDA = 97\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef revn(n): return str(n)[::-1]\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\ndef divs(n, start=2):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    return r\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\ndef prime(n):\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    return True\ndef convn(number, base):\n    newnumber = 0\n    while number > 0:\n        newnumber += number % base\n        number //= base\n    return newnumber\ndef cdiv(n, k): return n // k + (n % k != 0)\n\n\ns = input()\nlens = len(s)\nmax_ = 0\nfor i in range(1, lens):\n    d = {}\n    for j in range(lens - i + 1):\n        if s[j: j + i] in d:\n            d[s[j: j + i]] += 1\n        else:\n            d[s[j: j + i]] = 1\n    maxd = max(d.values())\n    if max(d.values()) > 1:\n        max_ = i\nprint(max_)\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import sys\nif locals()['__file__'][-2:] == 'py':\n    sys.stdin = open('in.txt', 'r')\nn = int(input())\na = []\nfor i in range(1, n + 1):\n    l, r = map(int, input().split())\n    a.append([l, -r, i])\na.sort()\nma = a[0][1]\nnma = a[0][2]\nfor i in range(1, n):\n    if a[i][1] >= ma:\n        print(a[i][2], nma)\n        exit()\n    else:\n        ma = a[i][1]\n        nma = a[i][2]\nprint(-1, -1)\n", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "n=int(raw_input())\n\nl=list(map(int,raw_input().split()))\n\nindex = []\nans=[]\nfor i in range(n):\n\tindex.append(i+1)\n\tans.append(0)\n\nl1,index1 = zip(*sorted(zip(l, index),reverse=True))\n#print('l1',l1)\n#print('index1',index1)\nfor i in range(n):\n\t#print(\"i\",i)\n\tk=1\n\tflag=False\n\twhile (index1[i]-k*l1[i])>0:\n\t\tif l[index1[i]-k*l1[i]-1]>l[index1[i]-1]:\n\t\t\tif ans[index1[i]-k*l1[i]-1]==\"B\":\n\t\t\t\tans[index1[i]-1]=\"A\"\n\t\t\t\tflag=True\n\t\t\t\tbreak\n\t\tk+=1\n\n\tk=1\n\tif flag==False:\n\t\twhile (index1[i]+k*l1[i])<=n:\n\t\t\tif l[index1[i]+k*l1[i]-1]>l[index1[i]-1]:\n\t\t\t\tif ans[index1[i]+k*l1[i]-1]==\"B\":\n\t\t\t\t\tans[index1[i]-1]=\"A\"\n\t\t\t\t\tflag=True\n\t\t\t\t\tbreak\n\t\t\tk+=1\n\n\n\tif flag==False:\n\t\tans[index1[i]-1]=\"B\"\n\nprint(''.join(ans))\n\n\n", "complexity": "nlogn", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "n, l, r, x = map(int, input().split())\narr = list(map(int, input().split()))\nres = 0\nfor j in range(1, 2**n):\n    a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)]\n    res += (max(a) - min(a) >= x and sum(a) >= l and sum(a) <= r)\nprint(res)\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "t = int(input())\nans = ''\nfor j in range(t):\n    ab = input().split()\n    a = int(ab[0])\n    b = int(ab[1])\n    k = 0\n    while a > 0 and b > 0:\n        if a >= b:\n            k += a // b\n            a %= b\n        else:\n            k += (b // a)\n            b %= a\n    ans += str(k) + '\\n'\nprint(ans)\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import math\nn,k=map(int,input().split())\nn-=1\nk-=1\nif n>(k*(k+1))//2:\n    print(-1)\nelse:\n    l=-1\n    r=k+1\n    while r>l+1:\n        m=(l+r)//2\n        if n>(m*(2*k-m+1))//2:\n            l=m\n        else:\n            r=m\n    print(r)\n    ", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import sys\nimport math\ninput = sys.stdin.readline\nfrom functools import cmp_to_key;\n\ndef pi():\n    return(int(input()))\ndef pl():\n    return(int(input(), 16))\ndef ti():\n    return(list(map(int,input().split())))\ndef ts():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\nmod = 998244353;\nf = [];\ndef fact(n,m):\n    global f;\n    f = [1 for i in range(n+1)];\n    f[0] = 1;\n    for i in range(1,n+1):\n        f[i] = (f[i-1]*i)%m;\n\ndef fast_mod_exp(a,b,m):\n    res = 1;\n    while b > 0:\n        if b & 1:\n            res = (res*a)%m;\n        a = (a*a)%m;\n        b = b >> 1;\n    return res;\n\ndef inverseMod(n,m):\n    return fast_mod_exp(n,m-2,m);\n\ndef ncr(n,r,m):\n    if r == 0: return 1;\n    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;\n\ndef main():\n    B();\n\ndp = [];\ndef D():\n    [n,k] = ti();\n    a = ti();\n    a = sorted(a);\n    cnt = [0 for i in range(n)];\n    for i in range(n):\n        c = 0;\n        for j in range(i,n):\n            if a[j]-a[i] <= 5: c+=1;\n            else:break;\n        cnt[i] = c;\n     \n    global dp;\n    dp = [[0 for j in range(k+1)] for i in range(n+1)];\n    ans = 0;\n    for i in range(n):\n        for j in range(k+1):\n            dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n            if j+1 <= k:\n                dp[i+cnt[i]][j+1] = max(dp[i+cnt[i]][j+1], dp[i][j]+cnt[i]);\n    print(dp[n][k]);\n\ndef B():\n    n = pi();\n    a = ti();\n    q = pi();\n\n    mat = [[0 for j in range(n)] for i in range(n)];\n    dp = [[0 for i in range(n)] for j in range(n)];\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                mat[i][j] = a[i];\n                dp[i][j] = a[i];\n    i = 0;\n    x = 1;\n    while x < n:\n        j = x;\n        i = 0;\n        while j < n:\n            mat[i][j] = mat[i][j-1] ^ mat[i+1][j];\n            j += 1;\n            i += 1;\n        x += 1;\n    \n    i = 0;\n    x = 1;\n    while x < n:\n        j = x;\n        i = 0;\n        while j < n:\n            dp[i][j] = max(mat[i][j], dp[i][j-1], dp[i+1][j]);\n            j += 1;\n            i += 1;\n        x += 1;\n        \n    for i in range(q):\n        [l,r] = ti();\n        print(dp[l-1][r-1]);\n\n            \n\n\nmain();", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "import sys\ninput=sys.stdin.readline\nn=int(input())\na=list(map(int,input().split()))\nINF=10**9\ndp=[[INF]*(n+1) for i in range(n+1)]\nval=[[-1]*(n+1) for i in range(n+1)]\nfor i in range(n):\n  dp[i][i+1]=1\n  val[i][i+1]=a[i]\nfor l in range(2,n+1):\n  for i in range(n-l+1):\n    j=i+l\n    for k in range(i+1,j):\n      if dp[i][k]==dp[k][j]==1 and val[i][k]==val[k][j]:\n        dp[i][j]=1\n        val[i][j]=val[i][k]+1\n      else:\n        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])\nprint(dp[0][n])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys\nfrom array import array  # noqa: F401\nfrom typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\ndef main():\n    n, m = map(int, input().split())\n    mat = [array('i', map(int, input().split())) for _ in range(n)]\n    bit = [1 << i for i in range(m)]\n    fullbit = (1 << m) - 1\n\n    def solve(x: int) -> Tuple[int, int]:\n        dp = {sum(bit[j] for j, y in enumerate(mat[i]) if y >= x): i for i in range(n)}\n        keys = tuple(dp.keys())\n\n        for i in range(len(keys)):\n            for j in range(i, len(keys)):\n                if keys[i] | keys[j] == fullbit:\n                    return dp[keys[i]], dp[keys[j]]\n\n        return -1, -1\n\n    ok, ng = 0, 10**9 + 1\n    ans_i, ans_j = 1, 1\n\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) >> 1\n        x, y = solve(mid)\n        if x == -1:\n            ng = mid\n        else:\n            ok = mid\n            ans_i, ans_j = x + 1, y + 1\n\n    print(ans_i, ans_j)\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "print(25)", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import math\nk = int(input())\n\n\ndef cnt_digit_order(X):\n    res = 0\n    if X == 0:\n        return 0\n    for i in range(1, X+1):\n        res += i*(9*pow(10, i-1))\n    return res\n\n\nL = -1\nleftcnt = 0\nfor length in range(1, 100):\n    if cnt_digit_order(length - 1) < k <= cnt_digit_order(length):\n        L = length\n        leftcnt = k - cnt_digit_order(length - 1)\n        break\n\n#L = digits/length\nM = str(math.ceil(leftcnt/L) + (10**(L-1) - 1))\nleftcnt -= 1\nleftcnt %= L\nprint(M[leftcnt])\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "line = input()\nn = len(line)\ntemp = [0]\nfor i in range(1, n):\n    for j in range(n-i):\n        for k in range(1, n-i-j+1):\n            # print(line[j:j+i+1])\n            # print(line[j+k:j+k+i+1])\n            if line[j:j+i] == line[j+k:j+k+i]:\n                temp.append(i)\nprint(max(temp))", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "\ndef make_number(b,chars):\n\tif len(chars) == 0:\n\t\treturn \"\"\n\ttarget = chars[0]\n\tfor i in chars:\n\t\tif int(b[0]) <= int(i):\n\t\t\tbreak\n\t\ttarget = i\n\tchars.remove(target)\n\treturn target + \"\".join(chars[::-1])\n\n\ndef find_number(b,chars):\n\tbackup_chars = list(chars)\n\tif len(b) == 1:\n\t\treturn chars[0]\n\telif b[0] in chars:\n\t\tchars.remove(b[0])\n\t\tnum = b[0] + find_number(b[1:],chars)\n\t\tif min(num,b) == b and b != num:\n\t\t\treturn make_number(b,backup_chars)\n\t\telse:\n\t\t\treturn num\n\n\telse:\n\t\treturn make_number(b,backup_chars)\n\na,b = str(input()), str(input())\nchars = [i for i in a]\nchars.sort()\n\nif len(a) < len(b):\n\tprint(\"\".join(chars[::-1]))\nelse:\n\tprint(find_number(b,chars))", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "input_arr = [int(i) for i in input().split()]\na,b = input_arr\n\ndef dec_to_bin(N):\n    res=[0]*64\n    \n    pos=0\n    while N!=0:\n        last_bit = N & 1\n        res[pos] = last_bit\n        pos+=1\n        N=N>>1\n    return res\n\ndef max_xor(a,b):\n    a_bin = dec_to_bin(a)\n    b_bin = dec_to_bin(b)\n    #print(a_bin)\n    #print(b_bin)\n\n    res = \"\"\n    x = \"\"\n    y = \"\"\n    diff_pt_found = False\n\n    for i in range(len(a_bin)-1,-1,-1):\n\n        if diff_pt_found == False and a_bin[i] == b_bin[i]:\n            x+=str(a_bin[i])\n            y+=str(b_bin[i])\n\n        if diff_pt_found == False and a_bin[i] != b_bin[i]:\n            diff_pt_found = True\n            x+=str(a_bin[i])\n            y+=str(b_bin[i])\n            #print(\"Diff Pt.\",i)\n            res+=\"1\"\n            continue\n        \n        if diff_pt_found == True:\n            if a_bin[i] != b_bin[i]:\n                res+=\"1\"\n                x+=str(a_bin[i])\n                y+=str(b_bin[i])\n            elif b_bin[i]==1:\n                res+=\"1\"\n                # y+=\"0\"\n                x+=str(a_bin[i])\n                y+=str(0)\n            elif a_bin[i]==0:\n                res+=\"1\"\n                #x+=\"1\"\n                x+=str(1)\n                y+=str(b_bin[i])\n\n    #print(len(x))\n    return x,y,res\n\ndef bin_to_dec(bin):\n    bin = str(bin)\n    mul = 1\n    res=0\n    for i in range(len(bin)-1,-1,-1):\n        if bin[i]=='1':\n            res+=mul\n            \n        mul=mul*2\n        \n    return res\n\n\nx,y,res = max_xor(a,b)\n#print(\"X:\",x)\n#print(bin_to_dec(x))\n#print(\"Y:\",y)\n#print(bin_to_dec(y))\n#print(\"Res:\",res)\nprint(bin_to_dec(res))", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import sys\n\ninput=sys.stdin.readline\ninf = 1e10\nmod = int(1e9 + 7)\nt=1;\n# t=int(input())\nfor _ in range(t):\n    # n, k= map(int, input().split())\n    # v=list(map(int, input().split()))\n    s=input()\n    c=s.count('1')\n    c1, i=0, 0\n    while(i<len(s) and s[i]!='2'):\n        if(s[i]=='0'):c1+=1\n        i+=1\n    print('0'*c1, end=\"\")\n    print('1'*c, end=\"\")\n    while(i<len(s)):\n        if(s[i]!='1'):\n            print(s[i], end=\"\")\n        i+=1", "complexity": "linear", "problem": "1009_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "\nimport math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n    return d[s]\n\nn,x,y=map(int,input().split())\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))\ny+=x\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "a=int(input())\nb=int(input())\nx=[0]*10\nwhile a:\n    x[a%10]+=1\n    a=a//10\nans=0\nfor i in range(9,-1,-1):\n    for j in range(x[i]):\n        ans=ans*10+i\nif ans<=b:\n    print(ans)\nelse:\n    ans=0\n    for j in str(b):\n        c=int(j)\n        while c>=0 and not x[c]:\n            c-=1\n        if c<0:\n            while True:\n                x[ans%10]+=1\n                d=ans%10\n                ans=ans//10\n                flag=0\n                for b in range(d-1,-1,-1):\n\n                    if x[b]:\n                        ans=ans*10+b\n                        x[b]-=1\n                        flag=1\n                        break\n                if flag:\n                    break\n            break\n                        \n                \n        else:\n            x[c]-=1\n            ans=ans*10+c\n            if c<int(j):\n                break\n\n    for j in range(9,-1,-1):\n        for i in range(x[j]):\n            ans=ans*10+j\n    print(ans)\n        \n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n, p = map(int, input().split())\n\narr = [int(b) for b in input().split()]\n\nres = []\n\nprefsums = [arr[0]]\n\nfor i in range(1, n):\n    prefsums.append(prefsums[i - 1] + arr[i])\n\nallsum = sum(arr)\n\nif len(arr) == 2:\n    print(arr[0] % p + arr[1] % p)\n    exit()\n\nfor i in range(1, n - 1):\n    res.append((prefsums[i] % p) + ((allsum - prefsums[i]) % p))\n\n\nprint(max(res))\n\n", "complexity": "linear", "problem": "0958_C1", "from": "CODEFORCES", "tags": "brute force"}
{"src": "# http://codeforces.com/contest/992/problem/C\n\nx, k = map(int, input().split())\n\nmd = 10 ** 9 + 7\n\nres = x * pow(2, k + 1, md) - pow(2, k, md) + 1 if x > 0 else 0\nprint(res % md)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\nA = list(map(int, input().split()))\nk = 10 ** 10\nfor i in range(1, n - 1):\n    k = min(k, min(A[0], A[i]) // i)\n    k = min(k, min(A[-1], A[i]) // (n - i - 1))\nk = min(k, min(A[0], A[-1]) // (n - 1))\nprint(k)", "complexity": "linear", "problem": "1159_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import sys\nimport math\ninput = sys.stdin.readline\nfrom functools import cmp_to_key;\n\ndef pi():\n    return(int(input()))\ndef pl():\n    return(int(input(), 16))\ndef ti():\n    return(list(map(int,input().split())))\ndef ts():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\nmod = 1000000007;\nf = [];\ndef fact(n,m):\n    global f;\n    f = [1 for i in range(n+1)];\n    f[0] = 1;\n    for i in range(1,n+1):\n        f[i] = (f[i-1]*i)%m;\n\ndef fast_mod_exp(a,b,m):\n    res = 1;\n    while b > 0:\n        if b & 1:\n            res = (res*a)%m;\n        a = (a*a)%m;\n        b = b >> 1;\n    return res;\n\ndef inverseMod(n,m):\n    return fast_mod_exp(n,m-2,m);\n\ndef ncr(n,r,m):\n    if n < 0 or r < 0 or r > n: return 0;\n    if r == 0: return 1;\n    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;\n\ndef main():\n    C();\n\ndef D():\n    [n,m,k] = ti();\n    w = [[] for i in range(n)];\n    for i in range(n):\n        w[i] = ts();\n\n    mn = [[0 for j in range(k+1)] for i in range(n+1)];\n    for i in range(1,n+1):\n        for j in range(k+1):\n            c = 0;\n            st,en = -1,-1;\n            for x in range(m):\n                if w[i-1][x] == '1':\n                    if c == j and st == -1: st = x;\n                    if c < j: c += 1;\n                    if c == j: en = x;\n            mn[i][j] = en-st+1 if st != -1 and en != -1 else 0;\n            st,en = -1,-1;\n            c = 0;\n            for x in range(m-1,-1,-1):\n                if w[i-1][x] == '1':\n                    if c == j and st == -1: st = x;\n                    if c < j: c += 1;\n                    if c == j: en = x;\n            if st != -1 and en != -1 >= 0:\n                mn[i][j] = min(mn[i][j], st-en+1);\n\n    dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)];\n    for i in range(k+1):\n        dp[0][i] = 0;\n    for i in range(1,n+1):\n        for j in range(k+1):\n            for x in range(k+1):\n                if j-x >= 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]);\n\n    print(dp[n][k]);\n\ndef C():\n    n = pi();\n    s = [];\n    mxI = 0;\n    for i in range(n):\n        c = input();\n        s.append(c[:len(c)-1]);\n        if s[len(s)-1] == 'f': mxI += 1;\n    dp = [[0 for j in range(mxI+1)] for i in range(n)];\n    dp[0][0] = 1;\n    preSum = [1 for i in range(mxI+1)];\n    pre = 1;\n    for i in range(1,n):\n        sm = 0;\n        pre = 0;\n        for j in range(mxI+1):\n            if s[i-1] == 'f':\n                dp[i][j] = dp[i-1][j-1]%mod;\n            else:\n                dp[i][j] = (preSum[mxI]%mod-(pre if j != 0 else 0)%mod)%mod;\n            pre = preSum[j];\n            preSum[j] = ((preSum[j-1] if j != 0 else 0)%mod+dp[i][j]%mod)%mod;\n\n    print(preSum[mxI]%mod);\n\nmain();", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "n,k = map(int,input().split())\ns= input()\ns1=s\nc=0\nfor i in range(len(s)-1):\n    if(s[:i+1]==s[n-i-1:]):\n        c=i+1\nfor i in range(k-1):\n    s1+=s[c:]\nprint(s1)", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "n, a, b = map(int, input().split())\nif min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:\n    print('NO')\n    exit()\nprint('YES')\nf = int(a == 1)\ng = [a, b][f]\nr = [[f] * n for i in range(n)]\nfor i in range(n):\n    r[i][i] = 0\nfor i in range(n - g):\n    r[i][i + 1] ^= 1\n    r[i + 1][i] ^= 1\nfor x in r:\n    print(*x, sep='')\njohnny=0\n \t \t \t \t\t\t   \t\t \t\t  \t\t\t\t \t\t\t\t", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "n,k = map(int,input().split())\na = list(map(int,input().split()))\n\ncount = 0\nb = {}\nfor i in range(n):\n    if a[i] in b:\n        b[a[i]] += 1\n    else:\n        b[a[i]] =1\n    if b[a[i]] == 1:\n        count += 1\n    if count == k:\n        break\n#print(\"i=\", i)\n#print(b)\n\n\nfor j in range(n):\n  if a[j] in b:\n    b[a[j]] -= 1\n#    print(\"j=\", j)\n#    print(b)\n  if b[a[j]] == 0:\n    break \n#  print(\"j=\",j)\n        \nif count != k:\n    print(\"-1 -1\")\nelse:\n  if n == 1:\n    print(1,1)\n  elif n == 2 and count == 2:\n    print(1,2)\n  else:\n    print(j+1,i+1)  ", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import math \n  \ndef countDigit(n): \n\treturn math.floor(math.log(n, 10)+1)\n\n\n\nn=int(input())\ncount=countDigit(n)\nif count==1:\n\tprint(n)\nelse:\n\tlow=1\n\thigh=9\n\tsum=[]\n\tdigit=0\n\tsum.append(0)\n\tsum.append(9)\n\tfor i in range(2,16):\n\t\tlow=low*10\n\t\thigh=high*10+9\n\t\t#print(countDigit(high))\n\t\tsum.append((high-low+1)*i+sum[i-1])\n\t\t\n\t\tif n<sum[i]:\n\t\t\tdigit=i\n\t\t\tbreak\n\tx=n-sum[digit-1]\n\tq=x/(digit)\n\tr=x%(digit)\n\tlow=math.pow(10,digit-1)\n\tlow=low+q-1\n\t#print(low)\n\tif r==0:\n\t\tprint(int(low%10))\n\telse:\n\t\tn=low+1\n\t\tstringnum=str(n)\n\t\tprint(int(stringnum[r-1]))", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nmask = (1 << m) - 1\n\nl = []\nfor i in range(n):\n    l.append(list(map(int,input().split())))\n\nlo = -1 #Possible\nhi = 10 ** 9 + 1 #Impossible\nwhile hi - lo > 1:\n    test = (hi + lo) // 2\n\n    things = dict()\n    for i in range(n):\n        curr = 0\n        for v in l[i]:\n            curr *= 2\n            if v >= test:\n                curr += 1\n        things[curr] = i\n\n    works = False\n    for v1 in things:\n        for v2 in things:\n            if v1 | v2 == mask:\n                outi = things[v1]\n                outj = things[v2]\n                works = True\n                break\n        if works:\n            break\n\n    if works:\n        lo = test\n    else:\n        hi = test\n\nprint(outi + 1, outj + 1)\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import bisect\nimport copy\nimport decimal\nimport fractions\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import deque,defaultdict\nfrom functools import lru_cache,reduce\nfrom heapq import heappush,heappop,heapify,_heappop_max,_heapify_max\ndef _heappush_max(heap,item):\n    heap.append(item)\n    heapq._siftdown_max(heap,0,len(heap)-1)\nfrom math import gcd as Gcd\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\ndef Extended_Euclid(n,m):\n    stack=[]\n    while m:\n        stack.append((n,m))\n        n,m=m,n%m\n    if n>=0:\n        x,y=1,0\n    else:\n        x,y=-1,0\n    for i in range(len(stack)-1,-1,-1):\n        n,m=stack[i]\n        x,y=y,x-(n//m)*y\n    return x,y\n\nclass MOD:\n    def __init__(self,p,e=1):\n        self.p=p\n        self.e=e\n        self.mod=self.p**self.e\n\n    def Pow(self,a,n):\n        a%=self.mod\n        if n>=0:\n            return pow(a,n,self.mod)\n        else:\n            assert math.gcd(a,self.mod)==1\n            x=Extended_Euclid(a,self.mod)[0]\n            return pow(x,-n,self.mod)\n\n    def Build_Fact(self,N):\n        assert N>=0\n        self.factorial=[1]\n        self.cnt=[0]*(N+1)\n        for i in range(1,N+1):\n            ii=i\n            self.cnt[i]=self.cnt[i-1]\n            while ii%self.p==0:\n                ii//=self.p\n                self.cnt[i]+=1\n            self.factorial.append((self.factorial[-1]*ii)%self.mod)\n        self.factorial_inv=[None]*(N+1)\n        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)\n        for i in range(N-1,-1,-1):\n            ii=i+1\n            while ii%self.p==0:\n                ii//=self.p\n            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod\n\n    def Fact(self,N):\n        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod\n\n    def Fact_Inv(self,N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inv[N]\n\n    def Comb(self,N,K,divisible_count=False):\n        if K<0 or K>N:\n            return 0\n        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod\n        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]\n        if divisible_count:\n            return retu,cnt\n        else:\n            retu*=pow(self.p,cnt,self.mod)\n            retu%=self.mod\n            return retu\n\ndef Bell_Numbers(N,mod,prime=False):\n    bell_numbers=[0]*(N+1)\n    bell_numbers[0]=1\n    MD=MOD(mod)\n    if prime:\n        MD.Build_Fact(min(mod-2,N-1))\n        for i in range(1,min(mod,N+1)):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n        for i in range(mod,N+1):\n            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod\n    else:\n        MD.Build_Fact(N-1)\n        for i in range(1,N+1):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n    return bell_numbers\n\nM,N=map(int,readline().split())\nS=[readline().rstrip() for i in range(N)]\ndct=defaultdict(int)\nfor i in range(M):\n    tpl=()\n    for j in range(N):\n        tpl+=(S[j][i],)\n    dct[tpl]+=1\nans=1\nmod=10**9+7\nbell=Bell_Numbers(M,mod)\nfor c in dct.values():\n    ans*=bell[c]\n    ans%=mod\nprint(ans)", "complexity": "quadratic", "problem": "0908_E", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,math"}
{"src": "\n# this sequence is a bit scary\n# 8\n# 1 2 3 2 3 2 1 0\n\nimport sys\n#sys.stdin=open(\"data.txt\")\n#input=sys.stdin.readline\n\ngot=[10**18]*100005\n\ndef getnum(i):\n    if got[i]==10**18:\n        print(\"? %d\"%i)\n        sys.stdout.flush()\n        got[i]=int(input())\n    return got[i]\n\nn=int(input())\nif n%4==2:\n    # the opposite person has a different parity\n    print(\"! -1\")\nelse:\n    lo=1\n    hi=n//2+1\n    t1=getnum(lo)\n    t2=getnum(hi)\n    lo2=t1-t2\n    hi2=t2-t1\n    if lo2==0:\n        print(\"! 1\")\n    else:\n        # binary search\n        # let's hope that 1 <= mid <= n/2\n        while lo<hi:\n            mid=(lo+hi)//2\n            #print(lo,hi,mid)\n            mid2=getnum(mid)-getnum(mid+n//2)\n            if mid2==0:\n                print(\"! %d\"%mid)\n                break\n            if (lo2>0) == (mid2>0):\n                lo=mid+1\n            else:\n                hi=mid-1\n        else:\n            print(\"! %d\"%lo)\nsys.stdout.flush()\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "n = int(input())\nar = list(map(int, input().split()))\nrev = ar[::-1]\nfrom collections import Counter\ndef d(ar):\n\tme = Counter()\n\ts = 0 \n\tfor i in range (n) : \n\t\ts+=(i*ar[i])\n\t\ts-=(me[ar[i]] + me[ar[i]+1]*ar[i] + me[ar[i]-1]*ar[i])\n\t\tme[ar[i]]+=1\n\treturn s\nprint(d(ar) - d(rev))", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2024)]\n\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n\nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys\nfrom array import array  # noqa: F401\nimport typing as Tp  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\nT = Tp.TypeVar('T')\n\n\nclass FenwickSum(Tp.Generic[T]):\n    __slots__ = ['nodes', 'size', 'unit']\n\n    def __init__(self, size: int, default: T, unit: T):\n        self.nodes = [default] * (size + 1)\n        self.size = size + 1\n        self.unit = unit\n\n    def add(self, index: int, value: T):\n        while index < self.size:\n            self.nodes[index] += value\n            index += index & -index\n\n    def sum(self, right: int) -> T:\n        result = self.unit\n\n        while right:\n            result += self.nodes[right]\n            right -= right & -right\n\n        return result\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = [x for x in a if x != -1]\n    mod = 998244353\n    minus = n - len(b)\n    m_inv = pow(minus, mod - 2, mod)\n    ans = 0\n\n    bit = FenwickSum[int](n, 0, 0)\n    for x in reversed(b):\n        ans += bit.sum(x)\n        bit.add(x, 1)\n\n    ans += minus * (minus - 1) * pow(4, mod - 2, mod) % mod\n\n    acc_u, m = [0] * (n + 1), minus\n    for x in a:\n        if x == -1:\n            m -= 1\n        else:\n            acc_u[x] = m\n\n    for i in range(n - 1, 0, -1):\n        acc_u[i] += acc_u[i + 1]\n        if acc_u[i] >= mod:\n            acc_u[i] -= mod\n\n    acc_d, m = [0] * (n + 1), minus\n    for x in reversed(a):\n        if x == -1:\n            m -= 1\n        else:\n            acc_d[x] = m\n\n    for i in range(1, n + 1):\n        acc_d[i] += acc_d[i - 1]\n        if acc_d[i] >= mod:\n            acc_d[i] -= mod\n\n    for x in set(range(1, n + 1)) - set(b):\n        ans = (ans + (acc_u[x] + acc_d[x]) * m_inv) % mod\n\n    print(ans % mod)\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "nlogn", "problem": "1096_F", "from": "CODEFORCES", "tags": "dp,math,probabilities"}
{"src": "import math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n    return d[s]\n\nn,x,y=map(int,input().split())\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))\ny+=x\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "from collections import defaultdict\n\ndef f(b,d):\n    fi = int(b[0])\n    if len(b)==1:\n        j=fi\n        while(j>=0):\n            if d[j]:\n                return str(j)\n            j+=-1\n\n        return \"\"\n\n\n    fi=int(b[0])\n    s=\"\"\n    if d[fi]>0:\n        d1=defaultdict(lambda:0)\n        for j in d:\n            d1[j]=d[j]\n        d1[fi]+=-1\n        s=f(b[1:],d1)\n\n    if s!=\"\":\n        return str(fi)+s\n\n    else:\n        s1=\"\"\n        j=fi-1\n        while(j>=0):\n            if d[j]>0:\n                s1+=str(j)\n                d[j]+=-1\n                break\n            j+=-1\n        if s1==\"\":\n            return \"\"\n        else:\n            j=9\n            while(j>=0):\n                if d[j]==0:\n                    j+=-1\n\n                else:\n                    s1+=str(j)\n                    d[j]+=-1\n\n            return s1\n\n\n\n\n\n\n\n\n\n\n\n\na=input()\nb=input()\nd=defaultdict(lambda:0)\nres=[]\nfor j in a:\n    d[int(j)]+=1\n    res.append(int(j))\nres.sort(reverse=True)\nfor j in range(len(a)):\n    res[j]=str(res[j])\nif len(b)>len(a):\n    print(\"\".join(res))\n\nelse:\n    print(f(b,d))\n\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys\ndef read():\n    return int(input())\ndef reads():\n    return [int(x) for x in input().split()]\nN,M=reads()\ntable=[reads() for i in range(N)]\nA=[[0]*N for i in range(N)]\nB=[[0]*N for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        res=10**9+7\n        for k in range(M):\n            res=min(res,abs(table[i][k]-table[j][k]))\n        A[i][j]=res\n        A[j][i]=res\n        res=10**9+7\n        for k in range(M-1):\n            res=min(res,abs(table[i][k]-table[j][k+1]))\n        B[i][j]=res\n#print(table)\n#print(A)\n#print(B)\n#A=[[10**9,2,3],[2,10**9,8],[1,5,10**9]]\n#B=[[10**9,2,3],[2,10**9,8],[1,5,10**9]]\ndp=[[-1]*N for i in range((1<<N) )]\ndef calc(mask,v):\n    if dp[mask][v]!=-1:\n        return dp[mask][v]\n    res =0\n    for u in range(N):\n        if (mask & 1<<u) and u!=v:\n            res =max(res,min(calc(mask^(1<<v),u),A[u][v]))\n    dp[mask][v]=res\n    return dp[mask][v]\nans=0\nfor i in range(N):\n    dp = [[-1] * N for i in range((1 << N))]\n    for k in range(N):\n        if k==i:\n            dp[1<<k][k]=10**9+7\n        else:\n            dp[1<<k][k]=0\n    for j in range(N):\n        ans=max(ans,min(B[j][i],calc((1<<N)-1,j)))\n    #print(dp,ans)\nprint(ans)", "complexity": "np", "problem": "1102_F", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,graphs"}
{"src": "import sys\ninput = sys.stdin.readline\nx,y = map(int, input().split())\nif y-x<2:\n\tprint(-1)\nelif x%2 != 0 and y-x==2:\n\tprint(-1)\nelif x%2==0:\n\tprint(x, x+1, x+2)\nelse:\n\tprint(x+1, x+2, x+3)", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "n, values, wrong = int(input()), [int(i) for i in input().split()], 0\nsorted_values = list(sorted(values))\nfor i in range(n):\n    if values[i] != sorted_values[i]:\n        wrong += 1\nif wrong > 2:\n    print(\"NO\")\nelse:\n    print(\"YES\")", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "n=input()\nans=0\nr,c=0,0\nfor i in range(len(n)):\n    r+=int(n[i])\n    c+=1\n    if int(n[i])%3==0 or r%3==0 or c==3:\n        ans+=1\n        r,c=0,0\nprint(ans)", "complexity": "linear", "problem": "1005_D", "from": "CODEFORCES", "tags": "dp,greedy,number theory"}
{"src": "def main():\n    import sys\n    input = sys.stdin.readline\n    \n    n, k = map(int, input().split())\n    \n    l = 1\n    r = n + 1\n    \n    while r - l != 1:\n        m = l + r >> 1\n        candies = m * (m + 1) // 2\n        eat = n - m\n        \n        if candies - eat <= k:\n            l = m\n        else:\n            r = m\n    \n    print(n - l)\n    \n    return 0\n\nmain()", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "def givestringsk(k):\n    t=[\"R\",\"G\",\"B\"]\n    ans=[]\n    for i in range(3):\n        temp=\"\"\n        for j in range(i,i+k):\n            temp+=t[j%3]\n        ans.append(temp)\n    return ans\ndef countdifferences(a,b):\n    cnt=0\n    for i in range(len(a)):\n        if a[i]!=b[i]:cnt+=1\n    return cnt\nfor _ in range(int(input())):\n    n,k=list(map(int,input().split()))\n    s=input()\n    temp=givestringsk(k)\n    ans=10000000000000\n    for i in range(k,n+1):\n        for j in range(3):\n            ans=min(ans,countdifferences(s[i-k:i],temp[j]))\n    print(ans)\n    ", "complexity": "quadratic", "problem": "1196_D1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "#########################################################################################################\\\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\n\nimport sys,os,io\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom sys import stdin\n\nimport math \n\n\n\ndef ncr(n, r, p):  #using fermat's little theorem\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\n  \ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n          \n    for i in range(3,int(math.sqrt(n))+1,2): \n          \n\n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    return list(set(l))\n    \ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \n\n\ndef si():\n    return input()\n\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\n\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\n\ndef ii():\n    return int(input())\n\ndef li():\n    return list(map(int,input().split()))\n\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\n\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\")\n    sys.stdout = open(\"output.txt\",\"w\")\n\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nt = int(input())\nfor _ in range(t):\n    n = ii()\n    l = li()\n    l1 = l[:]\n    arr = defaultdict(lambda:0)\n    for i in l:\n        arr[i]+=1\n    l = []\n    graterthan4 = 0\n    isgraterthan4 = False\n    for i in list(arr.keys()):\n        if (arr[i]>=4):\n            isgraterthan4 = True\n            graterthan4 = i\n        if (arr[i]>=2):\n            l.append(i)\n    n = len(l)\n    l.sort()\n    m = 1000000000000\n    mi = []\n    # print(l)\n    for i in range(n-1):\n        a = l[i]\n        b = l[i+1]\n        # print(a/b+b/a)\n        if (a/b+b/a<m):\n            m = a/b+b/a\n            # print(\"m\",m)\n            mi = [a,b]\n    if (isgraterthan4==True):\n        print(graterthan4,graterthan4,graterthan4,graterthan4)\n    else:\n        a,b = mi\n        print(a,a,b,b)\n    \n\n    ", "complexity": "nlogn", "problem": "1027_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "#########################################################################################################\\\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\nimport sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math \n\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):  \n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n    \"\"\"\n    L is a list.\n    The function returns the power set, but as a list of lists.\n    \"\"\"\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n    \n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n        \n    #the function could stop here closing with\n    #return powerset\n\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n        \n    return powerset_orderred\ndef fastPlrintNextLines(a):\n    # 12\n    # 3\n    # 1\n    #like this\n    #a is list of strings\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\n#__________________________TEMPLATE__________________OVER_______________________________________________________\n\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\") \nelse:\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nt = 1\n# t = int(input())\nfor _ in range(t):\n    n,k = li()\n    if k<=n:\n        print((k-1)//2)\n    else:\n        print(max((2*n-k+1)//2,0))\n    \n    \n", "complexity": "constant", "problem": "1023_B", "from": "CODEFORCES", "tags": "math"}
{"src": "for _ in range(int(input())):\n    n,m = sorted(map(int,input().split()))\n    count = 0\n    while n> 0:\n        count+= m//n\n        m = m%n\n        n,m = sorted([n,m])\n    print(count)\n", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "n,a,b=map(int,input().split())\nalist=list(map(int,input().split()))\nalist.sort(reverse=True)\np=alist[a-1]\nq=alist[a]\nprint(p-q)", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "n, k = map(int, input().split(' '))\ns = input()\nm = 10 ** 10\nfor i in range(k):\n    c = chr(ord('A') + i)\n    m = min(m, s.count(c))\nprint(m * k)", "complexity": "linear", "problem": "1038_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "n,k=map(int,input().strip().split())\nd=(n-k)//2+1\nx=['1' if (i+1)%d==0 else '0' for i in range(n)]\nprint(''.join(x))", "complexity": "linear", "problem": "1159_D", "from": "CODEFORCES", "tags": "brute force,greedy,constructive algorithms,math,strings"}
{"src": "\ndef naiveSolve():\n    \n    \n    \n    return\n\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\nclass OrderedList(SortedList): #Codeforces, Ordered Multiset\n    def __init__(self, arg):\n        super().__init__(arg)\n    def rangeCountByValue(self, leftVal, rightVal): #returns number of items in range [leftVal,rightVal] inclusive\n        leftCummulative = self.bisect_left(leftVal)\n        rightCummulative = self.bisect_left(rightVal + 1)\n        return rightCummulative - leftCummulative\n\nfrom collections import Counter\n\ndef main():\n    \n    n=int(input())\n    a=readIntArr()\n    \n    cnts=Counter(a)\n    ol=OrderedList([v for v in cnts.values()])\n    ol.add(0) # might have to remove 0 counts for x-1\n    canMakeFirstMove=False\n    for x in a:\n        if x>0:\n            c=cnts[x]\n            ol.remove(c)\n            ol.add(c-1)\n            d=cnts[x-1]\n            ol.remove(d)\n            ol.add(d+1)\n            # check\n            if ol[-1]==1:\n                canMakeFirstMove=True\n                break\n            ol.add(c)\n            ol.remove(c-1)\n            ol.add(d)\n            ol.remove(d+1)\n    if canMakeFirstMove==False:\n        print('cslnb')\n    else:\n        # first to make 0,1,2,3,4... loses\n        target=(n*(n-1))//2\n        if (sum(a)-target)%2==0:\n            print('cslnb')\n        else:\n            print('sjfnb')\n    \n    return\n\n\nimport sys\n# input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\ninput=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(l,r):\n    print('? {} {}'.format(l,r))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(x):\n    print('! {}'.format(x))\n    sys.stdout.flush()\n \ninf=float('inf')\nMOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n \nfor _abc in range(1):\n    main()\n", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "n = int(input())\nnums = [int(x) for x in input().split()]\nans = 10 ** 12\nfor idx, num in enumerate(nums):\n    dist = max(idx, n - idx - 1)\n    curr = num // dist\n    ans = min(ans, curr)\nprint(ans)", "complexity": "linear", "problem": "1159_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\n \n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------game starts now-----------------------------------------------------\n\nx,k=map(int,input().split())\nres=0\nmod=1000000007\nres=pow(2,k,mod)*(2*x-1)+1\nres%=mod\nif x==0:\n    res=0\nprint(res)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Dec 15 23:11:30 2020\n\nLCM Challenge\n\n@author --> yashodeep\n@Link --> https://codeforces.com/problemset/problem/235/A\n@status --> Accepted in first attempt\n\"\"\"\nn = int(input())\nans = 1\nif n == 1:\n    ans = 1\nelif n == 2:\n    ans = 2\nelif n == 3:\n    ans = 6\nelif n%2 == 0:\n    if n%3 == 0:\n        ans = (n-1)*(n-2)*(n-3)\n    else:\n        ans = n*(n-1)*(n-3)\nelse:\n    ans = n*(n-1)*(n-2)\n\nprint(ans)", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "a,b=input().split()\nif(a==b):\n    print(\"0\")\nelse:\n    xor=bin(int(a)^int(b))[2:]\n    a=bin(int(a))[2:]\n    b=bin(int(b))[2:]\n    ans=\"\"\n    if a[0]==b[0]:\n        ans+=\"0\"\n    else:\n        ans+=\"1\"\n    for i in range(len(xor)):\n        ans+=\"1\"\n    print(int(ans,2))\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n = int(input())\na = list(map(int,input().split()))\nmod = 10**9+7\nb = [0 for i in range(1<<20)]\nfor i in range(n):\n  b[a[i]] += 1\nfor i in range(20):\n  for j in range(1<<20):\n    if j&1<<i == 0:\n      b[j] += b[j|1<<i]\nans = 0\nfor i in range(1<<20):\n  cnt = str(bin(i)).count(\"1\")\n  if cnt%2 == 0:\n    ans += pow(2,b[i],mod)-1\n  else:\n    ans -= pow(2,b[i],mod)-1\n  ans %= mod\nprint(ans)", "complexity": "np", "problem": "0449_D", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "import io, sys\ninput = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()\n \nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nn, k = mi()\nans = None\nfor x in range(1, n + 1):\n    if x * (x + 3) == 2 * (k + n):\n        ans = n - x\n        break\nprint(ans)", "complexity": "linear", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nmax_el = -1;\ner = -1;\nfor i in range(len(a)):\n    if a[i] - max_el > 1:\n        er = i + 1;\n        break\n    if a[i] > max_el:\n        max_el = a[i]\n\nprint(er)\n", "complexity": "linear", "problem": "1054_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\ninput=sys.stdin.readline\nal=list(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nn=int(input())\ns=[input().rstrip() for i in range(3)]\nl=len(s[0])\nans=[0]*3\nfor c in al:\n    for i in range(3):\n        cnt_c=s[i].count(c)\n        if cnt_c+n<=l:\n            ans[i]=max(ans[i],cnt_c+n)\n        else:\n            if n==1 and l==cnt_c:\n                ans[i]=max(ans[i],l-1)\n            else:\n                ans[i]=l\nif (ans[0]==ans[1] and max(ans)==ans[0]) or (ans[1]==ans[2] and max(ans)==ans[1]) or (ans[0]==ans[2] and max(ans)==ans[2]):\n    print(\"Draw\")\nelif max(ans)==ans[0]:\n    print(\"Kuro\")\nelif max(ans)==ans[1]:\n    print(\"Shiro\")\nelse:\n    print(\"Katie\")", "complexity": "linear", "problem": "0979_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "import sys\nfrom collections import deque\nn=int(input())\nvisited=[False for i in range(n+1)]\ndp=[0 for i in range(n+1)]\nl=[[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    l[a].append(b)\n    l[b].append(a)\nb=list(map(int,input().split()))\ns=[1]\nvisited[1]=True\nc=1\nc1=0\nt=True\nwhile len(s)!=n :\n    aux=0\n    for i in l[s[c1]]:\n        if not visited[i]:\n            visited[i]=True\n            dp[i]=1\n            aux+=1\n    for i in range(c,c+aux):\n        if dp[b[i]]==1:\n            s.append(b[i])\n            dp[b[i]]=0\n        else:\n            print(\"No\")\n            t=False\n            break\n    else:\n        c+=aux\n        c1+=1\n        continue\n    break\nif t:\n    print(\"Yes\")\n", "complexity": "nlogn", "problem": "1037_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs,shortest paths,trees"}
{"src": "from collections import Counter\nfrom math import *\nimport sys\nmod=1000000007\n\ndef pro(arr,q):\n    n=len(arr)\n    ans=0\n    for i in range(n):\n        for j in range(i+1,n):\n            if(arr[i]>arr[j]):\n                ans+=1\n    \n    res=ans%2\n    for x,y in q:\n        k= y-x + 1\n        k=k//2\n        k=k%2\n        res= k^res\n        if(res):\n            print('odd')\n        else:\n            print('even')\nn=int(input())\narr=list(map(int,input().split()))\nt=int(input())\nque=[]\nfor i in range(t):\n    que.append(list(map(int,input().split())))\npro(arr,que)", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "n=int(input())\na=[int(x) for x in input().split()]\npro=n*(n-1)//2\ndic={}\nfor item in a:\n    if item not in dic:\n        dic[item]=1\n    else:\n        dic[item]+=1\ncounter=0\nfor item in dic:\n    if 0 in dic and dic[0]>=2:\n        print('cslnb')\n        break\n    if dic[item]>2:\n        print('cslnb')\n        break\n    elif dic[item]==2:\n        if counter==1 or item-1 in dic:\n            print('cslnb')\n            break\n        else:\n            counter=1\nelse:\n    if (sum(a)-pro)%2==1:\n        print('sjfnb')\n    else:\n        print('cslnb')\n", "complexity": "linear", "problem": "1191_D", "from": "CODEFORCES", "tags": "games"}
{"src": "import sys,io,os,math\ntry:yash=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nexcept:yash=lambda:sys.stdin.readline().encode()\nI=lambda:[*map(int,yash().split())]\nimport __pypy__;an=__pypy__.builders.StringBuilder()\nn,=I();lis=I();N=22;dp=[-1]*(1<<22)\nfor i in range(n):\n    dp[lis[i]]=lis[i]\n    for j in range(22):\n        lis[i]^=(1<<j)\nfor mask in range(1<<22):\n    for i in range(22):\n        if (mask&(1<<i)) and dp[mask^(1<<i)]!=-1:dp[mask]=dp[mask^(1<<i)]\nfor num in lis:\n    an.append(\"%s \"%(dp[num]))\nan.append(\"\\n\")\nos.write(1, an.build().encode())", "complexity": "np", "problem": "0165_E", "from": "CODEFORCES", "tags": "bitmasks,brute force,dfs and similar,dp"}
{"src": "'''input\n5 25 35 10\n10 10 20 10 20\n'''\nfrom sys import stdin, stdout, setrecursionlimit\nfrom collections import deque, defaultdict\nfrom bisect import bisect_left\n\n\n\ndef check(temp):\n\tif len(temp) < 2:\n\t\treturn False\n\telse:\n\t\ts = sum(temp)\n\t\tif s >= l and s <= r:\n\t\t\tif temp[-1] - temp[0] >= x:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\t\telse:\n\t\t\treturn False\n \ndef brute(index, temp):\n\tglobal count\n\n\tif index == n:\n\t\tif check(temp):\n\t\t\tcount += 1\n\n\telse:\n\t\ttemp.append(arr[index])\n\t\tbrute(index + 1, temp)\n\t\ttemp.pop()\n\t\tbrute(index + 1, temp)\n\n\n# main starts\nn, l, r, x = list(map(int, stdin.readline().split()))\narr = list(map(int, stdin.readline().split()))\narr.sort()\ncount = 0\ntemp = []\nbrute(0, temp)\nprint(count)\n\t    \t\t\t\t\t\t\t    \t\t\t \t\t\t   \t\t \t", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "def isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\nn=int(input());d=0\nif n%2==0:\n    print('4 '+str(n-4))\nelse:\n    i=4\n    while i<=int(n//2)+1:\n        k=n-i\n        if isPrime(k)==False:\n            print(str(i)+' '+str(k))\n            break\n        i+=2\n\n            \n        \n            \n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "# cook your dish here\nn=int(input())\narr=[int(x) for x in input().split()]\nli=arr[:]\nli.sort()\nc=0\nfor i in range(n):\n    if(arr[i]!=li[i]):\n        c+=1\n    if(c>2):\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")", "complexity": "nlogn", "problem": "0220_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import sys\ninput=sys.stdin.readline\ndef read():return list(map(int,input().split()))\nn,m=read()\na=[]\nfor i in range(n):\n    a.append(read())\nsm=0\ncur=0\nfor x, y in a:\n    sm+=y\n    cur+=x\nif sm>m:\n    print(-1)\n    quit()\ncnt=0\na.sort(key=lambda x: -x[0]+x[1])\ni = 0\nwhile cur>m and i < n:\n    cur -= a[i][0]-a[i][1]\n    cnt += 1\n    i += 1\nprint(cnt)", "complexity": "nlogn", "problem": "1015_C", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import sys\n\nn, m, k = map(int, input().split())\ntable = [input() for _ in range(n)]\n\ndp = [0]*(k+1)\n\nfor a in table:\n    one = []\n    for i in range(m):\n        if a[i] == '1':\n            one.append(i)\n\n    if not one:\n        continue\n\n    ni = len(one)\n    subdp = [10**9] * (ni+1)\n    subdp[-1] = 0\n\n    for i in range(ni):\n        for j in range(i, ni):\n            subdp[ni-(j-i+1)] = min(subdp[ni-(j-i+1)], one[j]-one[i]+1)\n\n    next_dp = [10**9]*(k+1)\n    for i in range(k, -1, -1):\n        for j in range(ni+1):\n            if i+j > k:\n                break\n            next_dp[i+j] = min(next_dp[i+j], dp[i] + subdp[j])\n    dp = next_dp\n\nprint(min(dp))\n", "complexity": "cubic", "problem": "0946_D", "from": "CODEFORCES", "tags": "dp"}
{"src": "n,k =  map(int,input().split())\n\ndef tonny(i) :\n\treturn (ord(i)-96)\na= sorted(input())\na=list(map(tonny,a))\na=sorted(list(set(a)))\nans=[a.pop(0)]\nk-=1\nfor j in a :\n\tif j-ans[-1] >1 and k>0 :\n\t\tk-=1\n\t\tans.append(j)\n\tif k==0 :\n\t\tbreak\nif k!=0 :\n\tprint(-1)\nelse:\n\tprint(sum(ans))\n", "complexity": "linear", "problem": "1011_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nstate = [list(map(int, input().split())) for _ in range(N)]\n\nAns = {}\n\nl = -1\nr = 10**9+1\nwhile r-l > 1:\n    m = (l+r)//2\n    T = {}\n    for j, S in enumerate(state):\n        bit = 0\n        for i, s in enumerate(S):\n            if s >= m:\n                bit += 1<<i\n        T[bit] = j\n    \n    ok = False\n    for bit1 in range(1<<M):\n        for bit2 in range(1<<M):\n            if bit1|bit2 == (1<<M)-1 and bit1 in T and bit2 in T:\n                ok = True\n                Ans[m] = [T[bit1], T[bit2]]\n                break\n        if ok: break\n    if ok:\n        l = m\n    else:\n        r = m\nprint(Ans[l][0]+1, Ans[l][1]+1)", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "n, m = map(int, input().split())\na = (n * (n - 1)) // 2\nn2 = n // 2\nb = n2 * (n2 + 1)\nif n % 2 == 0:\n    b -= n2\ns = 0\nfor i in range(m):\n    x, d = map(int, input().split())\n    s += x * n\n    s += d * (a if d > 0 else b)\n\nprint(s / n)\n", "complexity": "linear", "problem": "1009_C", "from": "CODEFORCES", "tags": "greedy,math"}
{"src": "import math\n\ndef solutions(a,b,c):\n    d = (b**2) - (4*a*c)\n    sol1 = (-b-math.sqrt(d))/(2*a)\n    sol2 = (-b+math.sqrt(d))/(2*a)\n    if sol1<0 and sol2>0:\n        return sol2\n    elif sol1>0 and sol2<0:\n        return sol1\n    else:\n        return 0\n    \n    \n    \n\nx = input()\nx=x.split(\" \")\nc = int(x[0])\nm = int(x[1])\n\nprint(int(c-solutions(1,3,-(2*c+2*m))))\n\n\t\t\t\t  \t \t \t  \t   \t    \t\t\t  \t\t\t\t", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\n#from math import *\nfrom collections import defaultdict as dd, deque\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return map(int, data().split())\n#sys.setrecursionlimit(1000000)\nmod=int(1e9+7)\n\ndef bfs(x):\n    cnt=0\n    for i in tree[x]:\n        bfs(i)\n        cnt+=a[i]\n    if len(tree[x])==0:\n        cnt=1\n    a[x]=cnt\n\nn=int(data())\ntree=[{} for i in range(n)]\nif n>1:\n    P=list(mdata())\n    for i in range(n-1):\n        tree[P[i]-1][i+1]=0\n    a=[0]*n\n    for i in range(n-1,-1,-1):\n        if len(tree[i])==0:\n            a[i]=1\n        else:\n            for j in tree[i]:\n                a[i]+=a[j]\n    a.sort()\nelse:\n    a=[1]\nprint(*a)", "complexity": "nlogn", "problem": "1056_D", "from": "CODEFORCES", "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"}
{"src": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Feb 15 19:45:38 2019\n\n@author: avina\n\"\"\"\n\nn = int(input())\n\nl = []\nfor _ in range(n):\n    k,m = map(int, input().strip().split())\n    l.append((k,m))\n\nl.sort(key=lambda x:x[0]+x[1])\n\nlast = 0\nans = 1\n\nfor i in range(1,n):\n   if l[i][0] - l[i][1] >= l[last][0] - l[last][1] and abs(l[i][0] - l[last][0]) >= l[i][1] + l[last][1] :\n       last = i\n       ans = ans + 1\n       \nprint(ans)", "complexity": "nlogn", "problem": "0528_B", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n=int(input())\nd,l,m,a=[0]*(n+1),[0]*2,[0]*(n+1),0\nfor _ in range(n-1):\n    a=int(input())\n    l.append(a)\n    m[a]+=1\nfor i in range(1,n+1):\n    if m[i]==0:\n        d[l[i]]+=1\nfor i in range(1,n+1):\n    if m[i]>0 and d[i]<3:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")", "complexity": "linear", "problem": "0913_B", "from": "CODEFORCES", "tags": "implementation,trees"}
{"src": "MAXN = 200001\nn, m = map(int, input().split(' '))\ns = list(map(int, input().split(' ')))\n\nf = [0 for i in range(n+1)]\ncount = [0 for i in range(-MAXN, MAXN+1)]\n\nf[0] = 0\n\nlast = 0\nres = 0\n\n#print(n, m, s)\n\nfor i in range(1, n+1):\n    if s[i-1] == m:\n        for j in range(last, i):\n            count[f[j]] += 1\n        last = i\n\n    if s[i-1] > m:\n        f[i] = f[i-1] - 1\n    else:\n        f[i] = f[i-1] + 1\n\n    #print(i, last, count[f[i]] + count[f[i]-1])\n    res += count[f[i]] + count[f[i]-1]    \n\n#print(f)\nprint(res)\n\n\n\n", "complexity": "nlogn", "problem": "1005_E1", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import sys\nimport math\ninput = sys.stdin.readline\n\nn,q=map(int,input().split())\n\narr=list(map(int,input().split()))\nfor i in range(n):\n\tarr.append(0)\nmaxx=0\n\nind=arr.index(max(arr))\nans=[]\nptr1=0\nptr2=n\nfor i in range(ind):\n\tans.append([arr[ptr1],arr[ptr1+1]])\n\tif arr[ptr1]>arr[ptr1+1]:\n\t\tarr[ptr2]=arr[ptr1+1]\n\t\tarr[ptr1+1]=arr[ptr1]\n\telse:\n\t\tarr[ptr2]=arr[ptr1]\n\tptr1+=1\n\tptr2+=1\n#print(arr)\nfor i in range(q):\n\tm=int(input())\n\n\tif m<=ind:\n\t\tprint(*ans[m-1])\n\telse:\n\t\tm-=ind\n\t\tm=m%(n-1)\n\t\tif m==0:\n\t\t\tm+=n-1\n\t\tprint(arr[ind],arr[ind+m])", "complexity": "linear", "problem": "1180_C", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "\ndef naiveSolve():\n    \n    \n    \n    return\n\n\n\ndef main():\n    \n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n,m=readIntArr()\n        grid=[]\n        for __ in range(n):\n            grid.append(readIntArr())\n        columns=[]\n        for col in range(m):\n            temp=[grid[i][col] for i in range(n)]\n            columns.append(temp)\n        \n        valCol=[] # (value, column)\n        for i in range(n):\n            for j in range(m):\n                valCol.append((grid[i][j],j))\n        valCol.sort(reverse=True)\n        \n        # try all possible shifts for top n columns\n        topCols=set()\n        for val,col in valCol:\n            topCols.add(col)\n            if len(topCols)==n:\n                break\n        \n        # try all configurations\n        m2=len(topCols)\n        grid2=[[-1 for __ in range(m2)] for ___ in range(n)]\n        topColsList=list(topCols)\n        for j in range(m2):\n            col=topColsList[j]\n            for i in range(n):\n                grid2[i][j]=grid[i][col]\n        ans=-inf\n        for mask in range(n**m2):\n            grid3=[[-1 for __ in range(m2)] for ___ in range(n)]\n            for col in range(m2):\n                shift=mask%n\n                for row in range(n):\n                    grid3[row][col]=grid2[(shift+row)%n][col]\n                mask//=n\n            tempAns=0\n            for row in range(n):\n                maxx=-inf\n                for col in range(m2):\n                    maxx=max(maxx,grid3[row][col])\n                tempAns+=maxx\n            ans=max(ans,tempAns)\n        allans.append(ans)\n        \n    multiLineArrayPrint(allans)\n    \n    return\n\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(r):\n    print('? {}'.format(r))\n    sys.stdout.flush()\n    return readIntArr()\n \ndef answerInteractive(adj,n):\n    print('!')\n    for u in range(1,n+1):\n        for v in adj[u]:\n            if v>u:\n                print('{} {}'.format(u,v))\n    sys.stdout.flush()\n \ninf=float('inf')\nMOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "n = int(input())\n\nd = {}\n\nfor i in range(n-1):\n\ta,b = map(int,input().split())\n\n\ttry:\n\t\td[a].append(b);\n\texcept:\n\t\td[a] = [b]\n\ttry:\n\t\td[b].append(a);\n\texcept:\n\t\td[b] = [a]\n\narray = list(map(int,input().split()))\nflag=0;\n\nif array[0]==1:\n\n\ti = 1;\n\tj = 0;\n\n\twhile ( j < n and i < n ):\n\t\tif ( array[j] in d[array[i]] ):\n\t\t\ti+=1;\n\t\telse:\n\t\t\tj+=1;\n\tif j==n and i!=n:\n\t\tflag=1;\nelse:\n\tflag=1;\n\nif flag==1:\n\tprint(\"No\")\nelse:\n\tprint(\"Yes\")", "complexity": "linear", "problem": "1037_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs,shortest paths,trees"}
{"src": "\nimport sys\ninput = sys.stdin.readline\nq=int(input())\nfor i in range(q):\n  n,k=map(int,input().split())\n  s=input()\n  a=k\n  for j in range(n-k+1):\n    a1,a2,a3=0,0,0\n    for jj in range(k):\n      if jj%3==0:\n        if s[j+jj]==\"R\":\n          a2+=1\n          a3+=1\n        elif s[j+jj]==\"G\":\n          a1+=1\n          a3+=1\n        else:\n          a1+=1\n          a2+=1\n      elif jj%3==1:\n        if s[j+jj]==\"R\":\n          a1+=1\n          a2+=1\n        elif s[j+jj]==\"G\":\n          a2+=1\n          a3+=1\n        else:\n          a3+=1\n          a1+=1\n      else:\n        if s[j+jj]==\"R\":\n          a1+=1\n          a3+=1\n        elif s[j+jj]==\"G\":\n          a1+=1\n          a2+=1\n        else:\n          a3+=1\n          a2+=1\n    a=min(a,a1,a2,a3)\n  print(a)\n      \n\n\n", "complexity": "quadratic", "problem": "1196_D1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n=int(input())\na=(n//2)*3\nprint(a)", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "a = input()\nb = input()\nla = [int(x) for x in a]\nres = []\nla.sort()\nla = la[::-1]\nlb = [int(x) for x in b]\ncnt = [0] * 20\n\ndef check():\n    tres = 0\n    for x in range(len(res)):\n        tres *= 10\n        tres += int(res[x])\n    return tres <= int(b)\nif len(a) < len(b):\n    for i in range(len(la)):\n        print(la[i], end = '')\n    print()\nelse:\n    for i in range(len(la)):\n        cnt[la[i]] += 1\n    flag = 0\n    for i in range(len(lb)):\n        if flag == 0 and cnt[lb[i]]:\n            res.append(lb[i])\n            cnt[lb[i]] -= 1\n        else:\n            flag = i - 1\n            for j in range(lb[i] - 1, -1, -1):\n                if cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n                    break\n            for j in range(9, -1, -1):\n                while cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n            break\n    while not check():\n        temp = []\n        cnt = [0] * 20\n        for x in range(flag):\n            temp.append(res[x])\n            cnt[res[x]] -= 1\n        for i in la:\n            cnt[i] += 1\n        ##print(\"cnt = \", cnt)\n        res = temp\n        ##print(flag, res)\n        for v in range(lb[flag] - 1, -1, -1):\n            if cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n                break\n        for v in range(9, -1, -1):\n            while cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n        ##print(flag, res)\n        flag -= 1\n    for i in range(len(res)):\n        print(res[i], end = '')\n    print()", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import math\nfrom decimal import Decimal, ROUND_FLOOR\n\ndef sum2(s, e):\n    return sum1(e) - sum1(s - 1) - (e - s)\n\ndef sum1(i):\n    return i * (i + 1) / 2\n\nn, k = map(Decimal, input().split())\n\nif(n == 1):\n    print(0)\nelif(k > n):\n    print(1)\nelif(sum2(Decimal(2),k) < n):\n    print(-1)\nelse:\n    c = 2 * n + k - k * k\n    discriminant = (9 - 4 * c).sqrt()\n    res1 = int(((3 + discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))\n    res2 = int(((3 - discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))\n    res1 = max(res1, res2)\n    print(k - res1 + 1);", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "l,r = [int(i) for i in input().split()]\nbitafter=-1;\nfor i in range(60,-1,-1):\n    if(l&(1<<i)!=r&(1<<i)):\n        bitafter = i\n        break\nres = 0\nwhile(bitafter>=0):\n    res+=1<<bitafter\n    bitafter-=1\nprint(res)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n = int(input())\nb = list(map(int, input().split()))\nff = []\nss = []\nfor i in  b[::-1]:\n    q = i\n    f = q // 2\n    if q % 2:\n        s = f + 1\n    else:\n        s = f\n    if len(ff) == 0:\n        ff = [f]\n        ss = [s]\n    else:\n        if f > ff[-1] or s < ss[-1]:\n            d = max(f - ff[-1], ss[-1] - s)\n            f -= d\n            s += d\n        ff.append(f)\n        ss.append(s)\nprint(*(ff[::-1] + ss))", "complexity": "linear", "problem": "1093_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "modulo = 1000 ** 3 + 7\n\n\ndef mat_oz(x, k):\n    if k == 0:\n        return (2 * x) % modulo\n    if x == 0:\n        return 0\n    b = (pow(2, k, modulo) * (2 * x - 1) + 1) % modulo\n    return b\n\n\ny, m = [int(i) for i in input().split()]\nprint(mat_oz(y, m))\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n,m=map(int,input().split())\nl=list()\nr=list()\nfor _ in range(m):\n    a,b=map(int,input().split())\n    l.append(a)\n    r.append(b)\nfor i in range(n):\n    if(i%2==0):\n        print(0,end='')\n    else:\n        print(1,end='')\n", "complexity": "linear", "problem": "1004_B", "from": "CODEFORCES", "tags": "constructive algorithms,greedy,implementation,math"}
{"src": "x, k = map(int, input().split())\nmod = 1000000007\nif (k == 0):\n    print((2 * x) % mod)\nelif (x == 0):\n    print(0)\nelse:\n    ans = ((2 * x - 1) * pow(2, k, mod) + 1) % mod\n    print(ans)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import math\nk,n,s,p=[int(x) for x in input().split()]\nx=math.ceil(n/s)\ny=math.ceil(x*k/p)\nprint(y)", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\nlst = list(map(int,input().split()))\nlst.sort()\nlst.reverse()\nm = 0\nfor i in range(n):\n  if sum(lst[:i]) > sum(lst[i:]):\n    break\n  else:\n    m+=1\nprint(m)", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import sys;\ndef transform(c):\n\tif c == '.': return 0;\n\tif c == '#': return 1;\n\treturn 2;\n\ndef take_care(board,n,m):\n\tif n + 2 >= N:\n\t\treturn;\n\tif m + 2 >= M:\n\t\treturn;\n\tif board[n][m+1] == 0 or board[n][m+2] == 0 or board[n+1][m] == 0 or board[n+1][m+2] == 0 or board[n+2][m] == 0 or board[n+2][m+1] == 0 or board[n+2][m+2] == 0:\n\t\treturn;\n\tboard[n][m] = 2\n\tboard[n][m+1] = 2\n\tboard[n][m+2] = 2\n\tboard[n+1][m] = 2\n\tboard[n+1][m+2] = 2\n\tboard[n+2][m] = 2\n\tboard[n+2][m+1] = 2\n\tboard[n+2][m+2] = 2\n\treturn False,board;\n\nN,M = [int(i) for i in input().strip().split()];\nboard = [];\nfor n in range(N):\n\trow = input().strip();\n\trow = [ transform(c) for c in row];\n\tboard.append(row);\n#print('board = ');\n#print(board);\nfor n in range(N):\n\tfor m in range(M):\n\t\ttake_care(board,n,m);\nfor row in board:\n\tif 1 in row:\n\t\tprint('NO');\n\t\tsys.exit();\nprint('YES');\n", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n, k = map( int, input().split() )\n\nd = n - k\nd = d // 2\n\nl = []\n\nwhile n > 0:\n    i = min(n,d)\n    while i>0:\n        l.append('1')\n        i -= 1\n        n -= 1\n    if n > 0:\n        l.append('0')\n        n -= 1\n\nprint( \"\".join( l ) )", "complexity": "quadratic", "problem": "1159_D", "from": "CODEFORCES", "tags": "brute force,greedy,constructive algorithms,math,strings"}
{"src": "x, y, z, t1, t2, t3 = map( int, input().split() )\nelevator = t2 * ( abs( x - y ) + abs( z - x ) ) + 3 * t3\nstairs = t1 * abs( x - y )\nif elevator > stairs:\n    print( 'NO' )\nelse:\n    print( 'YES' )\n", "complexity": "constant", "problem": "1054_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from itertools import combinations\nn, l, r, x = map(int,input().split())\na = list(map(int,input().split()))\nprint(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\ndef main():\n    # mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n   \n\n    tc=1\n    for _ in range(tc):\n        n=ri()\n        ans=[]\n        i=1\n        k=1\n        t=0\n        while True:\n            k=i*i\n            if k<=n:\n                t=i\n            else:\n                break\n            i+=1\n        a=[]\n        z=[]\n        for i in range(n):\n            z+=[i+1]\n            if len(z)==t:\n                a=z+a\n                z=[]\n        a=z+a\n        wia(a)\n        \n        \n\n            \n                    \n                \n        \n        \n            \n                \n        \n\n            \n        \n\n               \n            \n        \n              \n                \n        \n        \n            \n        \n        \n            \n            \n        \n        \n                \n                \n                \n                \n            \n        \n        \n            \n           \n        \n            \n                    \n\n                                 \n                \n                \n        \n\n                \n        \n        \n        \n            \n        \n        \n                \n            \n        \n        \n                    \n        \n        \n        \n            \n                    \n            \n\n                \n            \n            \n                \n            \n                \n            \n            \n            \n            \n                \n            \n        \n        \n        \n        \n        \n        \n        \n                    \n        \n        \n        \n                \n                \n        \n            \n            \n            \n        \n\n                    \n        \n                \n        \n        \n                        \n        \n                            \n\n        \n\n                \n            \n        \n\n                \n            \n                    \n                \n                \n        \n        \n         \n        \n\n                        \n                            \n                \n        \n                            \n                    \n\n                \n            \n        \n                \n            \n                \n        \n        \n        \n                             \n        \n            \n        \n        \n            \n                        \n                        \n                    \n            \n        \n        \n        \n        \n        \n                        \n       \n\n        \n                           \n        \n        \n        \n            \n        \n        \n        \n                      \n\n      \n                            \n            \n        \n        \n            \n            \n            \n            \n            \n        \n        \n        \n            \n        \n        \n        \n            \n        \n        \n        \n        \n            \n            \n        \n        \n        \n        \n        \n        \n        \n                \n                \n                    \n        \n        \n            \n            \n        \n                \n            \n            \n        \n        \n        \n        \n                \n        \n            \n        \n                \n        \n        \n            \n        \n       \n            \n\n                \n        \n        \n        \n   \n            \n        \n        \n        \n        \n            \n        \n                \n        \n        \n        \n            \n            \n        \n        \n            \n        \n        \n\n        \n        \n            \n        \n        \n            \n        \n                        \n\n        \n        \n            \n     \n        \n        \n            \n        \n        \n                \n            \n        \n        \n        \n                \n            \n        \n\n            \n             \n        \n            \n        \n        \n        \n                \n        \n            \n        \n        \n        \n        \n                \n        \n        \n            \n        \n        \n        \n        \n                \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    ", "complexity": "linear", "problem": "1017_C", "from": "CODEFORCES", "tags": "constructive algorithms,greedy"}
{"src": "n=int(input())\nl=list(map(lambda x:int(x)*2,input().split(\" \")))\nt=list(map(lambda x:\"GWL\".index(x),input()))\nmins=[0 for i in range(0,n+1)]\nfor i in range(n-1,-1,-1):\n\tif t[i]!=2:mins[i]=max(mins[i+1]-l[i],0)\n\telse:mins[i]=mins[i+1]+l[i]\ncurs=ans=st=0\nfor i in range(0,n):\n\tif(t[i]==0):\n\t\tcurs+=l[i];ans+=l[i]*5\n\t\tif(curs>mins[i+1]):\n\t\t\tol=(curs-mins[i+1])//2\n\t\t\tol=min(ol,l[i])\n\t\t\tans-=4*ol;curs-=2*ol\n\tif(t[i]==1):\n\t\tst=1;curs+=l[i];ans+=l[i]*3\n\tif(t[i]==2):\n\t\tif(curs<l[i]):\n\t\t\tol=l[i]-curs;curs=l[i]\n\t\t\tans+=ol*(3 if st else 5)\n\t\tcurs-=l[i];ans+=l[i]\nif curs>0:ans-=curs//2*2\nprint(ans//2)", "complexity": "linear", "problem": "1091_F", "from": "CODEFORCES", "tags": "constructive algorithms,greedy"}
{"src": "def get_input_list():\n\treturn list(map(int, input().split()))\n\nn = int(input())\nl = get_input_list()\nr = get_input_list()\n\na = [0 for _ in range(n)]\nm = []\nm_ = []\nfor i in range(n):\n\tm.append(l[i] + r[i])\n\tm_.append(l[i] + r[i])\nm.sort()\nma = m[-1] + 1\n\nfor i in range(n):\n\ta[i] = ma - m_[i]\n\nl_ = []\nr_ = []\nfor i in range(n):\n\tc = 0\n\td = 0\n\tfor j in range(i+1):\n\t\tif a[j] > a[i]:\n\t\t\tc += 1\n\tfor j in range(i,n):\n\t\tif a[j] > a[i]:\n\t\t\td += 1\n\tl_.append(c)\n\tr_.append(d)\nres = True\nfor i in range(n):\n\tif l[i] != l_[i] or r[i] != r_[i]:\n\t\tres = False\n\t\tbreak\nif res:\n\tprint(\"YES\")\n\tfor i in range(n):\n\t\ta[i] = str(a[i])\n\tprint(\" \".join(a))\nelse:\n\tprint(\"NO\")", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "a,b,c,n=list(map(int,input().split()))\np=(a+b-c)\nf=n-p\nif p>=n or c>a or c>b:\n\tprint(\"-1\")\nelse:\n\tprint(f)", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "q = int(input())\nfor i in range(q):\n    x, y, k = map(int, input().split())\n    if x > y: x, y = y, x\n    m = y\n    d = y\n    if (y - x) % 2 == 1:\n        d -= 1\n    if k < m:\n        print(-1)\n        continue\n    r = k - m\n    if r % 2 != 0:\n        r -= 1\n        if d != m:\n            d += 1\n        else:\n            d -= 1\n    d += r\n    print(d)\n", "complexity": "constant", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nfor t in range(ii()):\n    n, k = mi()\n    if n == 1:\n        ans = 'YES 0' if k == 1 else 'NO'\n    elif n == 2:\n        if k <= 2:\n            ans = 'YES 1'\n        elif k == 3 or k > 5:\n            ans = 'NO'\n        else:\n            ans = 'YES 0'\n    elif n <= 32 and k > (4 ** n - 1) // 3:\n        ans = 'NO'\n    else:\n        c, x = 0, n\n        p2 = 2\n        while x > 0:\n            if c + p2 - 1 > k:\n                break\n            c += p2 - 1\n            x -= 1\n            p2 *= 2\n        ans = 'YES %d' % (x,)\n    print(ans)\n", "complexity": "linear", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "print(25)", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "import math,sys,bisect,heapq\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\nfrom functools import lru_cache\n#sys.setrecursionlimit(200000000)\nint1 = lambda x: int(x) - 1\n#def input(): return sys.stdin.readline().strip()m\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\naj = lambda: list(map(int, input().split()))\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n#MOD = 1000000000 + 7\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\ndef fun(A):\n    for i in range(len(A)):\n        if A[i] == 0:\n            return i\n    return 1\n    \n    \ndp = [0]*10\nA = aj();A.sort()\nk1,k2,k3 = A\nfor i in range(0,10,k1):\n    dp[i] = 1\nfor i in range(fun(dp),10,k2):\n    dp[i] = 1\nfor i in range(fun(dp),10,k3):\n    dp[i] = 1\nY(0 not in dp)\n    \n    ", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "def pwr(a,n,m):\n    if n==0:return 1\n    ans=pwr(a,n//2,m)\n    ans=ans*ans\n    ans%=m\n    if n%2==1:return (ans*a)%m\n    else: return ans\nM=1000000007\ntx,tn=input().split()\nx=int(tx)\nn=int(tn)\nans=pwr(2,n+1,M)*x\nans%=M\nans=ans-pwr(2,n,M)+1\nans=(ans+M)%M\nif x==0: ans=0\nprint(ans)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\n\ndef sol(a,b):\n\tfor square in [a,b]:\n\t\tfor i1 in range(4):\n\t\t\ti2 = (i1 + 1)%4\n\t\t\tp1,p2 = square[i1],square[i2]\n\t\t\t\n\t\t\tnorm = (p2[1]-p1[1],p1[0]-p2[0])\n\n\t\t\tminA = maxA = minB = maxB = None\n\t\t\tfor p in a:\n\t\t\t\tproj = norm[0] * p[0] + norm[1] * p[1]\n\t\t\t\tif minA == None or proj < minA:\n\t\t\t\t\tminA = proj\n\t\t\t\tif maxA == None or proj > maxA:\n\t\t\t\t\tmaxA = proj\n\t\t\tfor p in b:\n\t\t\t\tproj = norm[0] * p[0] + norm[1] * p[1]\n\t\t\t\tif minB == None or proj < minB:\n\t\t\t\t\tminB = proj\n\t\t\t\tif maxB == None or proj > maxB:\n\t\t\t\t\tmaxB = proj\n\n\t\t\tif maxA < minB or maxB < minA:\n\t\t\t\treturn False\n\treturn True\n\nx11,y11,x12,y12,x13,y13,x14,y14 = list(map(int,sys.stdin.readline().strip().split(' ')))\nx21,y21,x22,y22,x23,y23,x24,y24 = list(map(int,sys.stdin.readline().strip().split(' ')))\n\na = [(x11,y11), (x12,y12), (x13,y13), (x14,y14)]\nb = [(x21,y21), (x22,y22), (x23,y23), (x24,y24)]\n\nprint([\"NO\",\"YES\"][sol(a,b)])", "complexity": "constant", "problem": "0994_C", "from": "CODEFORCES", "tags": "brute force"}
{"src": "N = 10**5+5\nMOD = 10**9+7\n\nfreq = [0 for i in range(N)]\n\n# Calculating {power(2,i)%MOD} and storing it at ith pos in p2 arr\np2 = [0 for i in range(N)]\np2[0] = 1\nfor i in range(1,N):\n    p2[i] = p2[i-1]*2\n    p2[i]%=MOD\n\ndef Calculate_Mobius(N):\n    arr = [1 for i in range(N+1)]\n    prime_count = [0 for i in range(N+1)]\n\n    mobius_value = [0 for i in range(N+1)]\n    for i in range(2,N+1):\n        if prime_count[i]==0:\n            for j in range(i,N+1,i):\n                prime_count[j]+=1\n                arr[j] = arr[j] * i\n\n    for i in range(1, N+1):\n        if arr[i] == i:\n            if (prime_count[i] & 1) == 0:\n                mobius_value[i] = 1\n            else:\n                mobius_value[i] = -1\n        else:\n            mobius_value[i] = 0\n\n    return mobius_value\n\n# Caluclating Mobius values for nos' till 10^5\nmobius = Calculate_Mobius(N)\nn = int(input())\nb = [int(i) for i in input().split()]\n\n# Storing freq of I/p no.s in array  \nfor i in b:\n    freq[i]+=1\n\nans = 0\nfor i in range(1,N):\n    # Count no of I/p no's which are divisible by i\n    cnt = 0\n    for j in range(i,N,i):\n        cnt += freq[j]\n    \n    total_subsequences = p2[cnt] - 1\n    ans = (ans + (mobius[i] * total_subsequences)%MOD)%MOD\n\n# Dealing if ans is -ve due to MOD\nans += MOD\nprint(ans%MOD)\n\n", "complexity": "np", "problem": "0803_F", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,number theory"}
{"src": "n = int(input())\nl = list(map(int, input().split()))\nansl = ['sjfnb', 'cslnb']\nans = -1\nd = dict()\nval = 0\nif n == 1:\n    ans = (l[0] + 1) % 2\nelse:\n    l.sort()\n    for elem in l:\n        d[elem] = d.get(elem, 0) + 1\n    hm = 0\n    which = -1\n    i = 0\n    for elem in d.values():\n        if elem >= 2:\n            hm += 1\n            which = i\n        i += 1\n    which = list(d.keys())[which]\n    if max(d.values()) >= 3 or d.get(0, 0) >= 2 or hm > 1:\n        ans = 1\n    elif hm == 1 and d.get(which - 1, 0) > 0:\n        ans = 1\n    else:\n        for i in range(n):\n            val += l[i] - i\n        ans = (val + 1) % 2\nprint(ansl[ans])", "complexity": "nlogn", "problem": "1191_D", "from": "CODEFORCES", "tags": "games"}
{"src": "import sys\nn,m=map(int,input().split())\nfor i in range(n//2):\n    for j in range(m):\n        sys.stdout.write('{} {}\\n'.format(*[i+1,j+1]))\n        sys.stdout.write('{} {}\\n'.format(*[n-i,m-j]))\nif n%2:\n    for j in range(m//2):\n        sys.stdout.write('{} {}\\n'.format(*[n//2+1,j+1]))\n        sys.stdout.write('{} {}\\n'.format(*[n//2+1,m-j]))\n    if m%2:\n        sys.stdout.write('{} {}\\n'.format(*[n//2+1,m//2+1]))", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "n,k = list(map(int,input().split()))\n\n# modulo divisor\nlimit = 998244353\n\n\nif k > 2*n:\n    print(0)\nelif k == 1 or k == 2*n:\n    print(2)\nelse:\n    same = [0] * (k+1)\n    same[1] = 2\n\n    diff = [0] * (k+1)\n    diff[2] = 2\n\n    for i in range(2, n+1):\n        for j in range(min(k, 2*i), 1, -1):\n\n            same[j] = same[j] + 2*diff[j] + same[j-1]\n            same[j] %= limit\n\n            diff[j] = diff[j] + 2*same[j-1] + diff[j-2]\n            diff[j] %= limit\n\n    print((same[k] + diff[k]) % limit)", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "def wzor(n):\n    return (n*(n+1))/2\n\ndef mafia():\n    pom = [int(x) for x in input().split()]\n    n = pom[0]\n    c = pom[1]\n\n    po = 1\n    ko = n\n    sr = (po + ko)//2\n    while po != ko:\n        if wzor(sr)-(n-sr) >= c:\n            ko = sr\n        else:\n            po = sr+1\n        sr = (po+ko)//2\n\n        \n    print(int(wzor(po)-c))\n\nmafia()\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "k,n,s,p = map(int,input().split())\nx = (n+s-1)//s\nx *= k\nprint((x+p-1)//p)\n\n\n", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\nimport math\ninput=sys.stdin.readline\na=list(input())\nb=list(input())\nx=a.count('+')-b.count('+')\ny=a.count('-')-b.count('-')\nif x<0 or y<0:\n    print(0)\nelse:\n    fact=math.factorial(x+y)/(math.factorial(x)*math.factorial(y))\n    total=2**(x+y)\n    print(fact/total)\n\n\t\t\t \t    \t  \t  \t\t    \t   \t \t  \t", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "from itertools import chain, combinations, permutations\n\ndef powerset(iterable):\n    \"\"\"\n    powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\n    \"\"\"\n    xs = list(iterable)\n    # note we return an iterator rather than a list\n    return chain.from_iterable(combinations(xs,n) for n in range(len(xs)+1))\n\nn = int(input())\ncl1 = []\ncl2 = []\nfor i in range(n):\n  s = input()\n  a = []\n  for j in range(n):\n    a.append(s[j])\n  cl1.append(a)\n\nfor i in range(n):\n  s = input()\n  a = []\n  for j in range(n):\n    a.append(s[j])\n  cl2.append(a)\n\ndef copy(m):\n  res = []\n  for i in range(n):\n    a = []\n    for j in range(n):\n      a.append(m[i][j])\n    res.append(a)\n  return res\n\ndef pow(m):\n  res = []\n  for i in range(n):\n    a = []\n    for j in range(n):\n      a.append(m[n-1-j][i])\n    res.append(a)\n  return res\n  \ndef vert(m):\n  res = []\n  for i in range(n):\n    res.append(m[i][::-1])\n  return res\n  \ndef gor(m):\n  res = []\n  for i in range(n):\n    a = []\n    for j in range(n):\n      a.append(m[i][n-1-j])\n    res.append(a)\n  return res\n\ncomblist = [[1], []]\ncm = [pow, pow, pow, vert, gor]\ncm = list(powerset(cm))\nres = False\nif cl1 == cl2:\n  res = True\nelse:\n  for x in cm:\n    for y in permutations(x):\n      t = copy(cl1)\n      for z in y:\n        t = z(t)\n      if t==cl2:\n        res = True\n      \nif res:\n  print('Yes')\nelse:\n  print('No')", "complexity": "quadratic", "problem": "0958_A1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "# Author : nitish420 --------------------------------------------------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\n\ndef main():\n    a=list(map(int,input()))\n    b=list(map(int,input()))\n    dff=len(b)-len(a)\n    if dff<0:\n        print(0)\n        exit()\n    lb=len(b)\n    c=[0]*(lb+1)\n    for i in range(lb):\n        c[i+1]=c[i]+b[i]\n    ans=0\n    for i in range(len(a)):\n        item=a[i]\n        if item:\n            ans+=(dff+1-(c[dff+i+1]-c[i]))\n        else:\n            ans+=(c[dff+i+1]-c[i])\n\n    print(ans)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\n\n\n\n# endregion\n\nif __name__ == '__main__':\n    main()", "complexity": "linear", "problem": "0608_B", "from": "CODEFORCES", "tags": "combinatorics,strings"}
{"src": "def bs(n, k, lo, hi):\n    \n    while lo <= hi: \n        mid = (hi + lo)//2\n        # print(lo, hi, mid)\n        # print('start')\n        # ks = range(mid, k+1)\n        # print('end')\n        # print('start')\n        # summ = (mid + k) * ((k - mid +1)/2) - (k-2)\n        # summ = (-mid * (mid -1) + k * (k + 1))/2 - (k-2)\n        summ = ((k * (k + 1))//2 - 1) - (((mid-1) * (mid))//2 -1) - (k-2)\n        # kk = k\n        # summ = 0\n        # while kk > 0:\n        #     summ += summ\n        #     kk -=1\n        # summ = summ - (k-2)\n        # summ = sum(ks) - (len(ks) - 1)\n        # print('end')\n        # print(list(range(mid, k+1)))\n        # print(summ, n)\n        # print(mid, k, (summ), 'mid')\n        if summ == n: \n            # print('done')\n            return k - mid + 1\n            # print(f'result: {k - mid + 1}')\n            # break\n        if summ > n: \n            # print('hi')\n            lo = mid + 1\n            # print(lo, hi, (hi + lo)//2)\n            \n        elif summ < n:\n            hi = mid - 1\n            # print((hi + lo)//2 , 'yarab', lo, hi)\n            # print('lala')\n            # print(summ)\n    # print(lo, 'i am the mid')\n    # if n - summ == 1:\n    #     print('there') \n    #     return -1\n    # summ = ((k * (k + 1))//2 - 1) - ((((mid+1)-1) * ((mid+1)))//2 -1) - (k-2)\n    # print(summ, 'yalla')\n    # print(mid, 'lol')\n    # print(k - mid)\n    # print('yo')\n    if summ > n: \n       mid += 1\n    return k - mid + 1\n    # print(f'result: {k - mid + 2}')\n\n\n\ndef solve():\n    n, k = map(int, input().split())\n    # n, k = 499999999500000000, 1000000000\n    # n, k = 8, 4\n    if n == 1: return 0\n    elif (k * (k + 1)//2) - (k-2) <= n: \n        # print('here')\n        return -1\n    elif k >= n: return 1\n    else: \n        return bs(n, k, 2, k)\n\nprint(solve())", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Dec 14 13:18:46 2020\n\n@author: yash\n\"\"\"\n\"\"\"\n __  __ _                   \n|  \\/  (_)_ __ ___  _ __    \n| |\\/| | | '__/ _ \\| '_ \\  \n| |  | | | | | (_) | | | | \n|_|  |_|_|_|  \\___/|_| |_|  \n\"\"\"\n\"\"\"\n \n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u258c\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u25d0\u25d0\u25d0\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580\u2580\u2580\u2580\ud83d\udd25\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u258c\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u258c\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2584\u2588\u2588\u2588\u2588\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u25d0\u25d0\u25d0\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580\u2580\u2580\u2580\ud83d\udd25\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\"\"\"\n\"\"\"\n \n \n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@#@@#@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##@M@M # #@@@M@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@#@@ @@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@### #@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@B@@#@@@@@#M@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@##@@M@#@@##@##@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#M@@@@@##@M@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##@@@@@@#@##@#@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#  @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@  #\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @# @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @# @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@  #\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#  @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@ @@#@@#@@@@@@@@@@@@@@@@@#@@#@#@@@@@@@@@@@@@@@@@@@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@\n @ #@@@@@@@@@@@@@@@@@@@@#@@@@@@#@@@@@@@@@@@@@@@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@ @@#@#@@@@@@@@@@@@@@@@@@#@####@@@@@@@@@@@@@@@@@M@#@@#@#@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@#@#M@@@M@@@@@@@@@@@@@@@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n#@M@#@#@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@M@@M@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@#@@#@@@@@@@@@@@@@@@@@@@@M@M@#@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@\n@@#@@#@@@@@@@@@@@@@@@@@@@@@@@M@                   @M@@#@@@@@@@@@@@@@@@@@@@@@@@@@\n@#@@@@@#@@@@@@@@@@@@@@@@@@@#@@                     @@@@M@@@@@@@@@@@@@@@@@@@@@@@@\n@@@#@@@##@@@#@@@@@#@@@@@##@@@@                     #@#@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@####@@####@@@@#@@@@M@@@#@@#                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@#@          @#@@#@@@       #@             @       #@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                            @#           @@#@@     #@@#@@@@@@@@@@@@@@@@@@@@@@@@@\n                     ##@#@@ #M           @# @@     @@M  @@@@@@@@@@@@@@@@@@@@@@@@\n                     @#@@@M #@           #@   #    @@   @@@@@@@@@@@@@@@@@@@@@@@@\n                      @@ @@#@@           ##    @##@@    @@@@@@@@@@@@@@@@@@@@@@@@\n                      @#  @@M@           @@             @@@@@@@@@@@@@@@@@@@@@@@@\n    @@@##@@@          @@@@ @@@          @@               #@#@@#@@@@@@@@@@@@@@@@@\n@@@@###@@###@@@@#@#@@@@#@@@ M@          #@    @       B  @@@#@@@@@@@@@@@@@@@@@@@\n@M@@@@@MM@@@@@M@@#@##@@@#@@M@B          @#   M@   @# #@  #@@#@@@@@@@@@@@@@@@@@@@\n@#@#@@M@@M@@#@#@#@#@@#@#@#@@@@          @#   @@   #  @M  @#@@@@@@@@@@@@@@@@@@@@@\n@@@          @@@@#@##@     #@#          @M    #  @   @   @@@@@#@@@@@@@@@@@@@@@@@\n                            @@          @@   @#@@#@@#M   #@@@@#@@@@@@@@@@@@@@@@@\n                           M@#           #@   @@@@##@@ @M@#M@@@#@@@@@@@@@@@@@@@@\n                           @@@@           @@          @@@#@@@#@#@@@@@@@@@@@@@@@@\n                          @#  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                          @@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n   @M@H@@  @#        @#@@@@#@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@#@#@##@M@@@M@ @M#@@@@@#@@#@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n#M@@@##@@@@@@@@M@@@@#@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@#@@@@@M@#@M@@B#M@@M@###@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n###@@@@@@@@@# @#@@@@@@@#@@@#@##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@#@@M@@@#@@#@#@@@@@@#@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@M@#@# \n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@#\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@##\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@M\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n \n \n\"\"\"\n\"\"\"\n                          / \\  //\\\n            |\\___/|      /   \\//  \\\\\n            /0  0  \\__  /    //  | \\ \\    \n           /     /  \\/_/    //   |  \\  \\  \n           @_^_@'/   \\/_   //    |   \\   \\ \n           //_^_/     \\/_ //     |    \\    \\\n        ( //) |        \\///      |     \\     \\\n      ( / /) _|_ /   )  //       |      \\     _\\\n    ( // /) '/,_ _ _/  ( ; -.    |    _ _\\.-~        .-~~~^-.\n  (( / / )) ,-{        _      `-.|.-~-.           .~         `.\n (( // / ))  '/\\      /                 ~-. _ .-~      .-~^-.  \\\n (( /// ))      `.   {            }                   /      \\  \\\n  (( / ))     .----~-.\\        \\-'                 .~         \\  `. \\^-.\n             ///.----..>        \\             _ -~             `.  ^-`  ^-_\n               ///-._ _ _ _ _ _ _}^ - - - - ~                     ~-- ,.-~\n                                                                  /.-~\n \n\"\"\"\n\"\"\"\n  ____          _      _____                       \n / ___|___   __| | ___|  ___|__  _ __ ___ ___  ___ \n| |   / _ \\ / _` |/ _ \\ |_ / _ \\| '__/ __/ _ \\/ __|\n| |__| (_) | (_| |  __/  _| (_) | | | (_|  __/\\__ \\\n \\____\\___/ \\__,_|\\___|_|  \\___/|_|  \\___\\___||___/\n\"\"\"\n\"\"\"\n\u2591\u2591\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\n\u2591\u2584\u2580\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2591\u2588\u2591\n\u2591\u2588\u2591\u2584\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2584\u2591\u2588\u2591\n\u2591\u2588\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2588\u2591\n\u2591\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2591\n\u2584\u2588\u2580\u2588\u2580\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2580\u2580\u2588\u2588\u2588\n\u2588\u2588\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2588\u2588\n\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2580\u2591\u2591\u2591\u2591\u2580\u2588\u2591\u2591\u2591\u2591\u2588\u2588\n\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\u2588\n\u2591\u2580\u2588\u2588\u2588\u2584\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2588\u2588\u2588\u2580\u2591\n\u2591\u2591\u2591\u2580\u2588\u2588\u2584\u2591\u2580\u2588\u2588\u2580\u2591\u2584\u2588\u2588\u2580\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\"\"\"\n\"\"\"\u2591\u2591\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\n\u2591\u2584\u2580\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2591\u2588\u2591\n\u2591\u2588\u2591\u2584\u2591\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2591\u2584\u2591\u2588\u2591\n\u2591\u2588\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2588\u2591\n\u2591\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2591\n\u2584\u2588\u2580\u2588\u2580\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2580\u2580\u2588\u2588\u2588\n\u2588\u2588\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2588\u2588\n\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2580\u2591\u2591\u2591\u2591\u2580\u2588\u2591\u2591\u2591\u2591\u2588\u2588\n\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\u2588\n\u2591\u2580\u2588\u2588\u2588\u2584\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2588\u2588\u2588\u2580\u2591\n\u2591\u2591\u2591\u2580\u2588\u2588\u2584\u2591\u2580\u2588\u2588\u2580\u2591\u2584\u2588\u2588\u2580\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\"\"\"\n\"\"\"\n# Codeforces Round #186 (Div. 2), problem: (A) Ilya and Bank Account\n\n    n = int(input())\n    if n > 0:\n        print(n)\n    else:\n        s = str(n)\n        if s[len(s)-1] < s[len(s)-2] and s[len(s)-2] != '0':\n            print(int(s[:len(s)-2] + s[len(s)-1:]))\n        elif s[len(s)-1] > s[len(s)-2] and s[len(s)-1] != '0':\n            print(int(s[:len(s)-1]))\n        else:\n            print(int(s[:len(s)-1]))\n\"\"\"\n\n\n\"\"\"\n# Codeforces Round #261 (Div. 2), problem: (A) Pashmak and Garden,\n\nx1, y1, x2, y2=map(int,input().split())\nl=abs(x1-x2)\nm=abs(y1-y2)\nif x1==x2:\n    print(x1+m,y1,x2+m,y2)\nelif y1==y2:\n    print(x1,y1+l,x2,y2+l)\nelif l!=m: \n    print(-1)\nelse: \n    print(x1,y2,x2,y1)\n\"\"\"\n\n\n\"\"\"\n# Codeforces Round #142 (Div. 2), problem: (A) Dragons\n\ndef solve():\n    s, n = map(int, input().split())\n    sets = []\n    for _ in range(n):\n        ith, bonus = map(int, input().split())\n        sets.append([ith, bonus])\n    sets.sort(key=lambda x: x[0])\n    for i in sets:  \n        if i[0] < s:\n                s += i[1]\n        else:\n            return \"NO\"\n    return \"YES\"\nprint(solve())\n\"\"\"\n\"\"\"\n# Codeforces Round #690 (Div. 3)\n\n# (A) Favorite Sequence-\n\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        ans = []\n        k = n//2\n        start = 0\n        end = len(l)-1\n        while start <= end:\n            if start != end:\n                ans.append(l[start])\n                ans.append(l[end])\n            else:\n                ans.append(l[end])\n            start += 1\n            end -= 1\n        for i in ans:\n            print(i, end=\" \")\n        print()\n\n# B) Last Year's Substring-\n\n    for _ in range(int(input())):\n        n = int(input())\n        s = input()\n        if s[0]+s[1] == '20' and s[-2]+s[-1] == '20':\n            print(\"YES\")\n        elif s[0] == '2' and s[-3]+s[-2]+s[-1] == '020':\n            print(\"YES\")\n        elif s[0]+s[1]+s[2] == '202' and s[-1] == '0':\n            print(\"YES\")\n        elif s[0]+s[1]+s[2]+s[3] == '2020':\n            print(\"YES\")\n        elif s[-4]+s[-3]+s[-2]+s[-1] == '2020':\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\"\"\"\n\"\"\"\n# Codeforces Round #251 (Div. 2)\n   \n    n, d = map(int, input().split())\n    l = list(map(int, input().split()))\n    if (sum(l) + (n-1)*10) > d:\n        print(-1)\n    else:\n        print((d-sum(l))//5)\n\"\"\"\n\"\"\"\n# Codeforces Round #290 (Div. 2)\n\nn,m=map(int,input().split())\nfor i in range(n):\n    if i % 4 == 0:\n        print('#'*m)\n    elif i % 4 == 1:\n        print('.'*(m-1)+'#')\n    elif i % 4 == 2:\n        print('#'*m)\n    else:\n        print('#'+'.'*(m-1))\n        \n        \nn,m=map(int,input().split())\nfor i in range(n):\n    print(['#'*m,'.'*(m-1)+'#','#'*m,'#'+'.'*(m-1)][i%4])\n\n\"\"\"     \n\"\"\"\n# Educational Codeforces Round 100 (Rated for Div. 2)\n\n\n# problem: (A) Dungeon\n    def solve(a, b, c):\n        s = a+b+c\n        k = s//9\n        if s % 9 == 0 and a >= k and b >=k and c >= k:\n            return \"YES\"\n        else:\n            return \"NO\"\n            \n    for _ in range(int(input())):\n        a, b, c = map(int, input().split())\n        print(solve(a, b, c)) \n\n\n# problem: (B) Find The Array\n\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        even = 0\n        odd = 0\n        for i in range(len(l)):\n            if i % 2 == 0:\n                even += l[i]\n            else:\n                odd += l[i]\n        \n        if even < odd:\n            for i in range(len(l)):\n                if i % 2 == 0:\n                    l[i] = 1\n                    print(l[i], end=\" \")\n                else:\n                    print(l[i], end=\" \")\n        else:\n             for i in range(len(l)):\n                if i % 2 == 0:\n                    print(l[i], end=\" \")\n                else:\n                    l[i] = 1\n                    print(l[i], end=\" \")\n\n\"\"\"\n\n\n\n\"\"\"\n# Codeforces Beta Round #25 (Div. 2 Only), problem: (A) IQ test\n    n = int(input())\n    nums = list(map(int, input().split()))\n    even = 0\n    odd = 0\n    counter1 = 0\n    counter2 = 0\n    for i in range(len(nums)):\n        if nums[i]%2 == 0:\n            counter1+=1\n            even = i+1\n        else:\n            counter2+=1\n            odd = i+1\n        \n    if counter1 == 1:\n        print(even)\n    else:\n        print(odd)\n\"\"\"\n\n\"\"\"\n# Codeforces Round #246 (Div. 2), problem: (A) Choosing Teams\n\n    n, k = map(int, input().split())\n    l = list(map(int, input().split()))\n    counter = 0\n    for i in range(len(l)):\n        if (5-l[i]) >= k:\n            counter += 1\n    print(counter//3)\n\"\"\"\n\n\"\"\"\n # Codeforces Round #192 (Div. 2), problem: (A)   \n    r, c = map(int, input().split())\n    a = set()\n    b = set()\n    for i in range(r):\n        d = input()\n        for j in range(len(d)):\n            if d[j] == 'S':\n                a.add(j)\n                b.add(i)\n    \n    print(r*c - len(a)*len(b))\n\"\"\"\n\n\n# n, m = map(int, input().split())\n# b = []\n# for i in range(n):\n#     if min(list(map(int, input().split()))[1:]) < m:\n#         b.append(i + 1)\n# print(len(b), '\\n', *b)\n        \n\"\"\"\n # Codeforces Round #691 (Div. 2), problem: (A) Red-Blue Shuffle,\n    for i in range(int(input())):\n        n = int(input())\n        a = input()\n        b = input()\n        counter_a = 0\n        counter_b = 0\n        for j in range(len(a)):\n            if a[j] > b[j]:\n                counter_a += 1\n            elif a[j] < b[j]:\n                counter_b += 1\n        \n        if counter_a > counter_b:\n            print(\"RED\")\n        elif counter_a < counter_b:\n            print(\"BLUE\")\n        else:\n            print(\"EQUAL\")\n    \n\"\"\"\n\"\"\"\n# Codeforces Round #263 (Div. 2), problem: (A) Appleman and Easy Task\n    x = ''\n    for _ in range(int(input())):\n        x += input()\n        \n    if x == x[::-1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\"\"\"\n\"\"\"\n # Codeforces Round #226 (Div. 2), problem: (A) Bear and Raspberry\n    n, c = map(int, input().split())\n    l = list(map(int, input().split()))\n    ans = l[0] - l[1]\n    for i in range(1, len(l)-1):\n        ans = max(ans, l[i] - l[i+1])\n    if ans - c < 0:\n        print(0)\n    else:\n        print(ans-c)\n\"\"\"\n\n# n, k = map(int, input().split())\n# joy = float(\"-inf\")\n# for _ in range(n):\n#     f, t = map(int, input().split())\n#     if t >= k:\n#         joy = max(joy, f - (t - k))\n#     else:\n#         joy =  max(joy, f)\n# print(joy)\n\n\n\"\"\"\n# Codeforces Round #260 (Div. 2), problem: (A) Laptops,   \n    for _ in range(int(input())):\n        a,b=input().split()\n        if a!=b:\n            print('Happy Alex')\n            exit()\n    print('Poor Alex')\n\"\"\"\n\"\"\"\n# Technocup 2021 - Elimination Round 3:\n    \n    problem: (A) In-game Chat\n        for _ in range(int(input())):\n            n = int(input())\n            s = input()\n            j = len(s)-1\n            count = 0\n            while j >= 0:\n                if s[j] != ')':\n                    break\n                count += 1\n                j -= 1\n        \n            if count > len(s)-count:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\"\"\"\n\n\n# def solve(x):\n#     for i in str(x):\n#         if i != '0' and x % int(i) != 0:\n#             return False\n#     return True\n     \n# t = int(input())\n# for _ in range(t):\n#     n = int(input())\n#     while not solve(n):\n#         n += 1\n#     print(n)\n    \n\"\"\"\n # Codeforces Round #222 (Div. 2), problem: (A) Playing with Dice\n    a, b = map(int, input().split())\n    a_w = 0\n    b_w = 0\n    draw = 0\n    for i in range(1, 7):\n        if abs(i-a) < abs(i-b):\n            a_w += 1\n        elif  abs(i-a) > abs(i-b):\n            b_w += 1\n        else:\n            draw += 1\n    print(a_w, draw, b_w)\n\"\"\"\n\"\"\"\n# Codeforces Round #283 (Div. 2), problem: (A) Minimum Difficulty\n    n=int(input())\n    l=list(map(int,input().split()))\n    x=max([l[i+1]-l[i] for i in range(n-1)])\n    y=min([l[i+2]-l[i] for i in range(n-2)])\n    print(max(x,y))\n\"\"\"\n\"\"\"\n # Codeforces Round #156 (Div. 2), problem: (A) Greg's Workout\n        n = int(input())\n        arr = list(map(int, input().split()))\n        chest_count = 0\n        biceps_count = 0\n        back_count = 0\n        for i in range(len(arr)):\n            if i%3 == 0:\n                chest_count += arr[i]\n            elif i%3 == 1:\n                biceps_count += arr[i]\n            elif i%3 == 2:\n                back_count += arr[i]\n            \n        ans = max(chest_count, biceps_count, back_count)\n        \n        if chest_count == ans:\n            print(\"chest\")\n        elif biceps_count == ans:\n            print(\"biceps\")\n        else:\n            print(\"back\")\n            \n               OR\n\n        input()\n        arr = [int(i) for i in input().split()]\n        b = [sum(arr[::3]), sum(arr[1::3]), sum(arr[2::3])]\n        c = ['chest', 'biceps', 'back']\n        print(c[b.index(max(b))])\n    \n\"\"\"\n\nl, r = map(int, input().split())\nif r - l + 1 < 3:\n    print(-1)\n    exit()\nif l % 2 == 0:\n    print(l, l+1, l+2)\n    exit()\nif r - l + 1 > 3:\n    print(l+1, l+2, l+3)\n    exit()\nprint(-1)\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            \n\n        \n    \n            \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n ", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n,m=map(int,input().split())\n    s,e,ans=[1,1],[n,m],[]\n    for i in range(n*m//2):\n        ans.append(s[:])\n        ans.append(e[:])\n        s[1],e[1]=s[1]+1,e[1]-1\n        if s[1]==m+1:\n            s=[s[0]+1,1]\n        if not e[1]:\n            e=[e[0]-1,m]\n    if (n*m)&1:\n        ans.append([s[0],s[1]])\n    for i in ans:\n        print(*i)\n\n     \n\n\n# FASTIO REGION\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "# 803F\nimport math\nimport collections\ndef do():\n    n = int(input())\n    nums = map(int, input().split(\" \"))\n    count = collections.defaultdict(int)\n    for num in nums:\n        for i in range(1, int(math.sqrt(num))+1):\n            cp = num // i\n            if num % i == 0:\n                count[i] += 1\n            if cp != i and num % cp == 0:\n                count[cp] += 1\n    maxk = max(count.keys())\n    freq = {k: (1 << count[k]) - 1 for k in count}\n    for k in sorted(count.keys(), reverse=True):\n        for kk in range(k << 1, maxk+1, k):\n            freq[k] -= freq[kk] if kk in freq else 0\n    return freq[1] % (10**9 + 7)\n\nprint(do())", "complexity": "np", "problem": "0803_F", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,number theory"}
{"src": "import sys\n\ninput = sys.stdin.readline\n\n\ndef intersection(segs):\n    end = float('inf')\n    start = - float('inf')\n    for l, r in segs:\n        end = min(end, r)\n        start = max(start, l)\n    return start, end\n\n\ndef solve():\n    n = int(input())\n    segs = [tuple([int(x) for x in input().split(' ')]) for s in range(n)]\n    starts = {}\n    ends = {}\n    x = intersection(segs)\n    for l, r in segs:\n        if r in starts:\n            starts[r] = max(starts[r], l)\n        else:\n            starts[r] = l\n        if l in ends:\n            ends[l] = min(ends[l], r)\n        else:\n            ends[l] = r\n\n    b = segs.copy()\n    b.remove((x[0], ends[x[0]]))\n    y = intersection(b)\n\n    c = segs.copy()\n    c.remove((starts[x[1]], x[1]))\n    z = intersection(c)\n\n    return max(x[1] - x[0], y[1] - y[0], z[1] - z[0], 0)\n\nprint(solve())\n", "complexity": "linear", "problem": "1029_C", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "n = int(input())\n\npairs = [int(i) for i in input().split(\" \")]\n\nN=len(pairs)\nN//=2\nvisited = [False] * (N + 1)  \n  \nminimumSwaps = 0\n\nfor i in range(2 * N) :   \n    if (visited[pairs[i]] == False) :  \n        visited[pairs[i]] = True \n        count = 0 \n        for j in range( i + 1, 2 * N) :   \n            if (visited[pairs[j]] == False) : \n                count += 1 \n            elif (pairs[i] == pairs[j]) : \n                minimumSwaps += count \nprint(minimumSwaps)\n       \t\t\t  \t\t\t \t  \t\t \t \t   \t\t\t", "complexity": "quadratic", "problem": "0995_B", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "def main():\n\tl, r = map(int , input().split())\n\tif l == r :\n\t\tprint(0)\n\telse :\n\t\trs = \"\"\n\t\twhile (r):\n\t\t\trs += '1' if r%2 else '0'\n\t\t\tr //= 2\n\t\tfor i in range(len(rs), 65):\n\t\t\trs += '0' \n\t\t# rs = rs[::-1]\n\t\tls = \"\"\n\t\twhile (l):\n\t\t\tls += '1' if l%2 else '0'\n\t\t\tl //= 2\n\t\tfor i in range(len(ls), 65):\n\t\t\tls += '0'\n\t\t# ls = ls[::-1]\n\t\tpos = -1\n\t\tfor i in range(64, -1, -1):\n\t\t\t# print(rs[i], '#', ls[i])\n\t\t\tif (rs[i] == '1' and ls[i] == '0'):\n\t\t\t\tpos = i\n\t\t\t\tbreak\n\n\t\tans = 2**(pos+1) - 1\n\t\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "N = int(input())\nsrc = [tuple(map(int,input().split() + [i])) for i in range(N)]\nsrc.sort()\n\nprev_l = max_r = 0\nprev_i = outer = -1\nfor l,r,i in src:\n    if prev_l == l:\n        print(prev_i+1, i+1)\n        exit()\n    if r <= max_r:\n        print(i+1, outer+1)\n        exit()\n    else:\n        max_r = r\n        outer = i\n    prev_l = l\n    prev_i = i\nprint(-1,-1)\n", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "def suma_o_resta(a, b):\n\treturn (a & (1<<b))\n\ndef diferencia(s1, d):\n\tif s1:\n\t\ts1.sort()\n\t\t#print(*s1, sep=\" - \")\n\t\tif s1[-1] - s1[0] >= d:\n\t\t\t#print(str(s1[-1]) + \" - \" + str(s1[0]) + \" = \" + str(s1[-1] - s1[0]))\n\t\t\treturn s1\n\t\telse:\n\t\t\treturn diferencia(s1.remove(s1[-1]), d)\t\n\treturn s1\n\ndef no_sets(v, n, l, r, d):\n\ts = []\n\tcont = 0\n\tfor x in range(1<<n):\n\t\tfor i in range(n):\n\t\t\t#print(\"(\" + str(x) + \", \" + str(i) + \")\")\n\t\t\tif suma_o_resta(x, i) > 0:\n\t\t\t\t#print(str(suma_o_resta(x, i)))\n\t\t\t\ts.append(v[i])\n\t\ts = diferencia(s, d)\n\t\tif s:\n\t\t\tif sum(s) >= l and sum(s) <= r:\n\t\t\t\tcont += 1\n\t\ts = []\n\treturn cont;\n\t\n\nn, l, r, x = map(int, input().split())\n\nv = list(map(int, input().split()))\n\nprint(str(no_sets(v, n, l, r, x)))\n\n\n\t\t\t\t \t\t\t  \t\t\t\t   \t  \t \t\t \t", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "R = lambda: map(int, input().split())\nfor _ in range(int(input())):\n    n,k = R()\n    s = input()\n    p = (k+2)//2\n    l = \"RGB\"*p\n    res = n\n    for i in range(n-k+1):\n        c = 0\n        #print(l[0:k])\n        for j in range(0,k):\n            c += (s[i+j] != l[j])\n        res = min(res,c)\n        #print(c)\n        c = 0\n        #print(l[1:k+1])\n        for j in range(1,k+1):\n            c += (s[i+j-1] != l[j])\n        res = min(res,c)\n        #print(c)\n        c = 0\n        #print(l[2:k+2])\n        for j in range(2,k+2):\n            c += (s[i+j-2] != l[j])\n        res = min(res,c)\n        #print(c)\n    print(res)", "complexity": "quadratic", "problem": "1196_D1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n,l,r,x = map(int,input().split())\nA = list(map(int,input().split()))\ncount = 0\nfor i in range(1<<n):\n    total = 0\n    mn = 1e6\n    mx = -1e6\n    for k in range(n):\n        if (i & (1<<k)):\n            total += A[k]\n            mn = min(A[k],mn)\n            mx = max(A[k],mx)\n    if total<=r and total>=l and mx-mn>=x:\n        count += 1\nprint(count)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "n = int(input())\narr = list(map(int, input().split()))\nres = float('inf')\nfor i in range(1, n):\n    res = min(res, min(arr[i], arr[0]) // i)\nfor i in range(n - 1):\n    res = min(res, min(arr[i], arr[n - 1]) // (n - 1 - i))\nprint(res)\n", "complexity": "linear", "problem": "1159_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n=int(input())\nls=list(map(int,input().split()))\nls.sort()\nif ls.count(min(ls))==len(ls):\n\tprint('NO')\nfor i in range(n):\n\tif ls[i]!=min(ls):\n\t\tprint(ls[i])\n\t\tbreak\n\t   \t \t\t    \t\t\t \t  \t  \t\t \t\t\t  \t", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "a = list(map(int,input().split()))\nif a.count(1)>=1 or a.count(2)>=2 or a.count(3)==3 or (a.count(2)==1 and a.count(4)==2):\n    print(\"YES\")\nelse:\n    print(\"NO\")", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "from collections import defaultdict\n\ndef E1():\n\n    mod = 10 ** 9 + 7\n\n    comb = [[1]]\n    for i in range(1, 1010):\n        x = [1]\n        for j in range(1, i):\n            x.append((comb[i - 1][j - 1] + comb[i - 1][j]) % mod)\n        x.append(1)\n        comb.append(x)\n\n    dp = [1]\n    for i in range(1, 1010):\n        r = 0\n        for k in range(i):\n            r += dp[k] * comb[i - 1][k]\n            r %= mod\n        dp.append(r)\n\n    m, n = map(int, input().split())\n\n    ns = [0 for __ in range(m)]\n    for j in range(n):\n        temp = input()\n        s = [int(i) for i in temp]\n        for i in range(m):\n            ns[i] |= s[i] << j\n\n    dd = defaultdict(int)\n    for e in ns:\n        dd[e] += 1\n\n    ans = 1\n    for b in dd.values():\n        ans = ans * dp[b] % mod\n\n    print(ans)\n\nif __name__=='__main__':\n    E1()\n\t \t \t   \t   \t\t\t  \t\t\t\t  \t \t \t \t", "complexity": "quadratic", "problem": "0908_E", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,math"}
{"src": "n = int(input())\nans = 0\nif n==1:\n    print(1)\n    exit()\nif n==2:\n    print(2)\n    exit()\nif n==3:\n    print(6)\n    exit()\nif n%2==0:\n    if n%3==0:\n        ans=(n-1)*(n-2)*(n-3)\n    else:\n        ans=n*(n-1)*(n-3)\nelse:\n    ans=n*(n-1)*(n-2)\n\nprint(ans)", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "i = input()\ni = int(i)\nv = 0\ng = 2\ns = 4\nwhile g <= i:\n\twhile s <= i:\n\t\tv = v + int(s / g * 4)\n\t\ts = s + g\n\tg = g + 1\n\ts = g * 2\nprint(str(v))", "complexity": "quadratic", "problem": "1062_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation,math"}
{"src": "x, k = map(int, input().strip().split())\nMOD = 10**9 + 7\n\ndef pow2(k):\n    if k == 0:\n        return 1\n    if k == 1:\n        return 2\n    r = pow2(k // 2)\n    r = r * r\n    if k % 2 != 0:\n        r *= 2\n    return r % MOD\n\ndef calc(x, k):\n    if x == 0:\n        return 0\n    if k == 0:\n        return (2 * x) % MOD\n    r = pow2(k) * (2 * x - 1) + 1\n    return r % MOD\n\nprint(calc(x, k))", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "def main():\n    n = int(input())\n    left = [int(x) for x in input().strip().split()]\n    right = [int(x) for x in input().strip().split()]\n    rank = [x + y for (x,y) in zip(left,right)]\n    arr = [(n - r) for r in rank]\n\n    # check left\n    for i in range(n):\n        more = 0\n        for j in range(i):\n            if arr[j] > arr[i]:\n                more += 1\n        if more != left[i]:\n            print('NO')\n            return\n    \n    # check right\n    for i in range(n):\n        more = 0\n        for j in range(i+1,n):\n            if arr[j] > arr[i]:\n                more += 1\n        if more != right[i]:\n            print('NO')\n            return\n\n    print('YES')\n    for x in arr:\n        print(x, end=' ')\n    print()\n\n\nif __name__ == '__main__':\n    main()", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "\nimport sys\n\n\ndef query(c, d):\n    print('? %d %d' % (c, d))\n    sys.stdout.flush()\n    res = int(input())\n    return res\n\na = 0\nb = 0\nbig = query(0, 0)\n\nfor i in range(29, -1, -1):\n    p = query(a ^ (1 << i), b)\n    q = query(a, b ^ (1 << i))\n    if p == q:\n        if big == 1:\n            a ^= 1 << i\n        else:\n            b ^= 1 << i\n        big = p\n    elif p == -1:\n        a ^= 1 << i\n        b ^= 1 << i\n\nprint('! %d %d' % (a, b))\nsys.stdout.flush()\n", "complexity": "constant", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "import io\nimport os\n\nfrom collections import Counter, defaultdict, deque\n\n\ndef solveBFS(NR, NG, NB, R, G, B):\n    def pack(i, j, k):\n        return i * 256 * 256 + j * 256 + k\n\n    def unpack(ijk):\n        i, jk = divmod(ijk, 256 * 256)\n        j, k = divmod(jk, 256)\n        return i, j, k\n\n    R.sort(reverse=True)\n    G.sort(reverse=True)\n    B.sort(reverse=True)\n    dp = [0 for i in range(256 ** 3)]\n    q = deque([0])\n    while q:\n        ijk = q.popleft()\n        d = dp[ijk]\n        i, j, k = unpack(ijk)\n\n        if i < NR:\n            r = R[i]\n\n        if j < NG:\n            g = G[j]\n        if k < NB:\n            b = B[k]\n        if i + 1 <= NR and j + 1 <= NG:\n            rg = pack(i + 1, j + 1, k)\n            dp[rg] = max(dp[rg], r * g + d)\n            q.append(rg)\n\n        if i + 1 <= NR and k + 1 <= NB:\n            rb = pack(i + 1, j, k + 1)\n            dp[rb] = max(dp[rb], r * b + d)\n            q.append(rb)\n\n        if j + 1 <= NG and k + 1 <= NB:\n            gb = pack(i, j + 1, k + 1)\n            dp[gb] = max(dp[gb], g * b + d)\n            q.append(gb)\n\n    return max(dp)\n\n\ndef solve(NR, NG, NB, R, G, B):\n    assert NR == len(R)\n    R.sort(reverse=True)\n    G.sort(reverse=True)\n    B.sort(reverse=True)\n\n    R += [0]\n    G += [0]\n    B += [0]\n\n    NR1 = NR + 2\n    NG1 = NG + 2\n    NB1 = NB + 2\n    dp = [0 for i in range((NR1) * (NG1) * (NB1))]\n\n    def pack(i, j, k):\n        return i * NG1 * NB1 + j * NB1 + k\n\n    inf = float(\"inf\")\n    for i in range(NR + 1):\n        for j in range(NG + 1):\n            dp[pack(i, j, -1)] = -inf\n    for i in range(NR + 1):\n        for k in range(NB + 1):\n            dp[pack(i, -1, k)] = -inf\n\n    for j in range(NG + 1):\n        for k in range(NB + 1):\n            dp[pack(-1, j, k)] = -inf\n\n    for l in range(2, NR + NG + NB + 1, 2):\n        for j in range(NG + 1):\n            for k in range(NB + 1):\n                i = l - j - k\n                if i < 0 or i > NR:\n                    continue\n                r = R[i - 1]\n                g = G[j - 1]\n                b = B[k - 1]\n                dp[pack(i, j, k)] = max(\n                    r * g + dp[pack(i - 1, j - 1, k)],\n                    r * b + dp[pack(i - 1, j, k - 1)],\n                    b * g + dp[pack(i, j - 1, k - 1)],\n                )\n\n    return max(dp)\n\n\nif False:\n    import random\n\n    random.seed()\n    N = 5\n    for t in range(100):\n        R = [random.randint(1, 10) for i in range(random.randint(1, N))]\n        G = [random.randint(1, 10) for i in range(random.randint(1, N))]\n        B = [random.randint(1, 10) for i in range(random.randint(1, N))]\n        ans1 = solveBFS(len(R), len(G), len(B), R, G, B)\n        ans2 = solve(len(R), len(G), len(B), R, G, B)\n        if ans1 != ans2:\n            print(ans1, ans2)\n            print(R, G, B)\n        exit()\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    NR, NG, NB = [int(x) for x in input().split()]\n    R = [int(x) for x in input().split()]\n    G = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n    ans = solve(NR, NG, NB, R, G, B)\n    print(ans)\n\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n, k = list( map( int, input().split()))\np = list( map( int, input().split()))\nc = list( map( int, input().split()))\n\nm = {}\nfor i in range( n ):\n    if p[ i ] not in m:\n        m[ p[ i ] ] = list()\n    m[ p[ i ] ].append( c[ i ] )\n\na = {}\nt = []\nfor key, val in sorted( m.items() ):\n    a[ key ] = sum( t )\n    t += val\n    t.sort()\n    t = t[ max( 0, len( t ) - k ) : len( t ) ]\n\nprint( \" \".join( [ str( a[ p[ i ] ] + c[ i ] ) for i in range( n )]))\n", "complexity": "nlogn", "problem": "0994_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "M = 10**9+7\nx,k=[int(i) for i in input().split()]\nif(x==0):\n    print(0)\nelif(k==0):\n    print((x*2)%M)\nelse:\n    top_sum = ((pow(2,k,M)%M)*((2*x-1)%M))%M+1\n    print(top_sum%M)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "from collections import defaultdict\nfrom sys import stdout,stdin\nn,m,K=map(int,input().split())\ndp=[[[0 for h in range(11)]for j in range(m+1)] for i in range(n+1)]\nl1=[list(map(int,stdin.readline().split())) for i in range(n)]#i,j i,j+1\nl2=[list(map(int,stdin.readline().split())) for i in range(n-1)]#i,j i+1,j\nif K%2:\n    for i in range(n):\n        for j in range(m):\n            print('-1',end=' ')\n        print()\nelse:\n    for k in range(1,K//2+1):\n     for i in range(n):\n        for j in range(m):\n                res=100000000\n                if i-1>=0 and j>=0:\n                     res=min(res,l2[i-1][j]+dp[i-1][j][k-1])\n                if i+1<n and j>=0:\n                     res=min(res,l2[i][j]+dp[i+1][j][k-1])\n                if 0<=i and j+1<m:\n                     res=min(res,l1[i][j]+dp[i][j+1][k-1])\n                if 0<=i and j-1>=0:\n                     res=min(res,l1[i][j-1]+dp[i][j-1][k-1])\n                dp[i][j][k]=res\n    for i in range(n):\n        for j in range(m):\n            stdout.write(str(2*dp[i][j][K//2])+' ')\n        stdout.write('\\n')", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "n, m, k, l = map(int, input().split())\nif m > n or (l + k + m - 1) // m * m > n:\n    print(-1)\nelse:\n    x = (l + k + m - 1) // m\n    print(x)", "complexity": "constant", "problem": "1068_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\ns = input()\n \nfor sum in range(9 * n + 1):\n    cnt = 0\n    cursum = 0\n    for i in s:\n        cursum += int(i)\n        if cursum == sum:\n            cnt += 1\n            cursum = 0\n \n    if cursum == 0 and cnt > 1:\n        print(\"YES\")\n        exit(0)\n \nprint(\"NO\")", "complexity": "quadratic", "problem": "1030_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\ncoins = list(map(int, input().split()))\ncoins.sort(reverse=True)\ntarget = (sum(coins)+2)//2\n\ncount = 1\ntotal = coins[count-1]\nwhile total < target:\n    count += 1\n    total += coins[count-1]\n\nprint(count)\n\n", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "\nif __name__ == '__main__':\n    a = [int(c) for c in str(input())]\n    b = [int(c) for c in str(input())]\n    b_len = len(b)\n    a_len = len(a)\n    carCountPrefix = [[ 0 for c in range(2)] for _ in range(b_len+1)]\n    b_zero_count = 0\n    b_one_count = 0\n    for b_i in range(b_len):\n        if b[b_i] == 0:\n            b_zero_count += 1\n        elif b[b_i] == 1:\n            b_one_count += 1\n        carCountPrefix[b_i+1][1] = b_one_count\n        carCountPrefix[b_i+1][0] = b_zero_count\n    res = 0\n    for cur in range(0, a_len):\n        for dig in range(2):\n            res += (carCountPrefix[b_len - a_len + cur + 1][dig] - carCountPrefix[cur][dig]) * abs(a[cur] -dig)\n    print(res)\n\n \t \t\t \t\t\t\t\t  \t \t \t  \t\t \t\t    \t", "complexity": "linear", "problem": "0608_B", "from": "CODEFORCES", "tags": "combinatorics,strings"}
{"src": "import sys\ninput=sys.stdin.readline\ndef read():return list(map(int,input().split()))\nn=int(input())\ns=input()\nt=input()\nif sorted(s)!=sorted(t):\n    print(-1)\n    quit()\ns=list(s)\nt=list(t)\nans=[]\nfor i in range(n):\n    for j in range(i,n-1):\n        if s[j+1] == t[i]:\n            for k in range(j,i-1,-1):\n                ans.append(k+1)\n                s[k+1], s[k] = s[k], s[k+1]\n            break\nprint(len(ans))\nprint(*ans)", "complexity": "quadratic", "problem": "1015_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from math import sin\npi = 3.141592653589793238462643383279502884197\nn, r = map(int,input().split())\ntheta = 2*pi / n\nR = r / (1-sin(theta/2))\nprint(R-r)", "complexity": "constant", "problem": "1100_C", "from": "CODEFORCES", "tags": "binary search,geometry,math"}
{"src": "a, b = map(int, input().split(\" \"))\n\na, b = min(a, b), max(a, b)\n\nbina = str(bin(a))[2:]\nbinb = str(bin(b))[2:]\n\nlena = len(bina)\nlenb = len(binb)\n\nans = 0\nif lena != lenb:\n\tans = 2**lenb-1\nelse:\n\ta = '0'*(lena-lenb) + bina\n\tfor i in range(lenb):\n\t\tif (bool(int(bina[i])) != bool(int(binb[i]))):\n\t\t\tans = 2**(lenb-i) - 1\n\t\t\tbreak\n\t\n\t\t\nprint(ans)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "x, k = map(int, input().split())\nmod = 10**9+7\ne = (x * pow(2, k, mod)) % mod\ns = (e - pow(2, k, mod)) % mod\nf = lambda x: (x*(x+1))%mod\nans = ((f(e) - f(s)) * pow(2, k*(mod-2), mod))%mod\nprint(ans if x != 0 else 0)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import bisect\nn,q=map(int,input().split())\nstrength=list(map(int,input().split()))\narrows=list(map(int,input().split()))\nfor i in range(1,n):\n    strength[i]+=strength[i-1]\nNo_arrows=0\nn-=1\nfor i in range(q):\n    No_arrows+=arrows[i]\n    if(No_arrows>=strength[-1]):\n        No_arrows=0\n        print(n+1)\n    else:\n        it=bisect.bisect_left(strength,No_arrows)\n        if(strength[it]==No_arrows):\n            print(n-it)\n        else:\n            print(n-it+1)\n", "complexity": "nlogn", "problem": "0975_C", "from": "CODEFORCES", "tags": "binary search"}
{"src": "#!/usr/bin/python3\nimport sys\ninput = sys.stdin.readline\nn, m = map(int, input().split())\n\nMOD = m\nMAX_N = 10**3\n\n# Construct factorial table\nfac = [1] + [0] * MAX_N\nfor i in range(1, MAX_N+1):\n    fac[i] = fac[i-1] * (i) % MOD\n\nfac_inv = [1] + [0] * MAX_N\n# Femrmat's little theorem says a**(p-1) mod p == 1\n# then, a * a**(p-2) mod p == 1\n# it means that a**(p-2) is the inverse element\n# Here, Get 1 / n! first\nfac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)\nfor i in range(MAX_N, 1, -1):\n    fac_inv[i-1] = fac_inv[i] * i % MOD\n\ndef mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD\n\npow2 = [0] * (n+1)\npow2[0] = 1\nfor i in range(1, n+1):\n    pow2[i] = pow2[i-1] * 2 % MOD\n\ntable = [[0] * 500 for _ in range(500)]\nfor i in range(500):\n    for j in range(i+1):\n        table[i][j] = mod_nCr(i, j)\n\n# dp[i-th][j used]\ndp = [[0] * (n+1) for _ in range(n)]\nfor i in range(n):\n    dp[i][i+1] = pow2[i]\nfor i in range(n-1):\n    for j in range(i // 2 + 1, n-1):\n        if dp[i][j] == 0:\n            continue\n        dp[i][j] %= MOD\n        for k in range(1, n-j):\n            if i + k + 1 >= n:\n                break\n            # create new\n            dp[i+k+1][j+k] += dp[i][j] * pow2[k-1] * table[k + j][k]\n\nans = sum(dp[-1]) % MOD\nprint(ans)", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "from operator import itemgetter\nn = int(input())\nai = list(map(int,input().split()))\nai2 = [[ai[i], i] for i in range(n)]\nanswer = [0] * n\nai2.sort(key = itemgetter(0))\nanswer[ai2[0][1]] = 1\nanswer[ai2[-1][1]] = 0\nfor i in range(n-2,0,-1):\n    num = ai2[i][1] % ai2[i][0]\n    for j in range(num,n,ai2[i][0]):\n        if ai[j] > ai2[i][0] and answer[j] == 0:\n            answer[ai2[i][1]] = 1\n            break\nfor i in range(n):\n    if answer[i] == 1:\n        print(\"A\",end=\"\")\n    else:\n        print(\"B\",end=\"\")\n", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "import sys\nimport math\ninput = sys.stdin.readline\n\n############ ---- Input Functions ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s.rstrip()))\ndef invr():\n    return(map(int,input().split()))\nn, m, k=inlt()\nM=[[[] for i in range(m)] for j in range(n)]\nS=[[-1]*m for i in range(n)]\nfor y in range(n):\n\tL=inlt()\n\tfor x in range(m-1):\n\t\tM[y][x].append(((y, x+1), L[x]))\n\t\tM[y][x+1].append(((y, x), L[x]))\n\nfor y in range(n-1):\n\tL=inlt()\n\n\tfor x in range(m):\n\t\tM[y][x].append(((y+1, x), L[x]))\n\t\tM[y+1][x].append(((y, x), L[x]))\nif k%2==0:\n\tfor l in range(k//2):\n\t\tS2=[[0]*m for i in range(n)]\n\t\tfor y in range(n):\n\t\t\tfor x in range(m):\n\t\t\t\tMi=10000000000000000000000\n\t\t\t\tfor ((a, b), p) in M[y][x]:\n\t\t\t\t\tMi=min(Mi,max(0,S[a][b])+p)\n\t\t\t\tS2[y][x]=Mi\n\t\tS=S2\n\tfor y in range(n):\n\t\tfor x in range(m):\n\t\t\tS[y][x]*=2\n\nfor y in range(n):\n\tprint(' '.join(list(map(str, S[y]))))", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "# https://codeforces.com/contest/913/problem/D\nimport heapq\nfrom heapq import heappush as push_\nfrom heapq import heappop  as pop_\n\nclass heapT():\n    def __init__(self, T):\n        self.Q     = []\n        self.curT  = 0\n        self.maxT  = T\n        self.his   = []\n        \n    def push(self, t, index):\n        push_(self.Q, (-t, index))\n        self.his.append(index)\n        self.curT += t\n        \n        while self.curT > self.maxT:\n            self.pop()\n            \n    def pop(self):\n        t, ind     = pop_(self.Q)\n        self.his.append(ind) \n        self.curT -= t * -1\n        \n    def normalize(self, length):\n        while len(self.Q) > length:\n            self.pop()\n\ndef solve(a, n, T):\n    a    =  sorted(a, key=lambda x:x[0], reverse=True) \n    H    =  heapT(T)\n\n    max_ = -1\n    pos  = None\n    \n    for ak, t, ind in a:\n        H.push(t, ind)\n        H.normalize(ak)\n    \n        if len(H.Q) >  max_:\n            max_ = len(H.Q)\n            pos  = len(H.his)  \n            \n    d = {}\n    if pos is not None:\n        for x in H.his[:pos]:\n            if x not in d:\n                d[x] = 1\n            else:\n                del d[x]\n\n    if len(d) > 0:\n        print(len(d))\n        print(len(d))\n        print(' '.join([str(x+1) for x in d]))\n    else:\n        print('0'+'\\n'+'0')\n\nn, T =  map(int, input().split())\na    =  [list(map(int, input().split())) + [_] for _ in range(n)]\nsolve(a, n, T)\n\n#5 300\n#3 100\n#4 150\n#4 80\n#2 90\n#2 300        \n\n#7 100\n#5 30\n#5 40\n#6 20\n#2 50 \n#2 40\n#3 10\n#4 10\n\n#2 100\n#1 787\n#2 788", "complexity": "nlogn", "problem": "0913_D", "from": "CODEFORCES", "tags": "binary search,brute force,data structures,greedy,sortings"}
{"src": "x,k=map(int,input().split())\nif x==0:\n  print(0)\n  exit()\nmod=10**9+7\np=pow(2,k,mod)\nprint((2*p*x-p+1)%mod)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "MOD=1000000007\n\ndef powr(n,N):\n    temp=1\n    while(N>0):\n        if(N%2!=0):\n            temp=(temp*n)%MOD\n        n=(n*n)%MOD\n        N=N//2\n    return (temp%MOD)\n \n\"\"\"def powr(n,N):\n    if(N==1):\n        ans=n\n        return ans\n    else:\n        ans=powr(n,N//2)\n        if(N%2==0):\n            return ((ans*ans)%MOD)\n        else:\n            return ((((ans*ans)%MOD)*n)%MOD)\"\"\"\n \ndef MODI(a,b):\n    ans=(powr(a,b)%MOD)\n    return ans\n \n\n\nx,k=map(int,input().split())\nif(x==0):\n    print(0)\nelse:\n    t1=powr(2,k+1)%MOD\n    t1=(t1*x)%MOD\n    t2=powr(2,k)%MOD\n    t2=(t2-1)%MOD\n    ans=(t1-t2)%MOD\n    print(ans)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "l,r = [int(x) for x in input().split()]\nif l==r or l+1==r:\n    print(-1)\nelif l%2==0:\n    print(l,l+1,l+2)\nelif l%2!=0 and r-l+1>3:\n    print(l+1,l+2,l+3)\nelse:\n    print(-1)", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "n=int(raw_input())\narr=list(map(int,raw_input().split()))\ndict1={}\narr1=[0]*n\nfor i in range(n):\n\tarr1[arr[i]-1]=i\nfor i in range(n):\n\tdict1[i+1]=[]\nfor i in range(n):\n\tfor j in range(i-arr[i],-1,-arr[i]):\n\t\tif(arr[j]>arr[i]):\n\t\t\tdict1[arr[i]].append(arr[j])\n\tfor j in range(i+arr[i],n,arr[i]):\n\t\tif(arr[j]>arr[i]):\n\t\t\tdict1[arr[i]].append(arr[j])\nstrarr=['.']*n\n#print(dict1)\nfor i in range(n-1,-1,-1):\n\tif(len(dict1[arr[arr1[i]]])==0):\n\t\tstrarr[arr1[i]]='B'\n\telse:\n\t\tif(len(dict1[arr[arr1[i]]])==1 and len(dict1[dict1[arr[arr1[i]]][0]])==0):\n\t\t\tstrarr[arr1[i]]='A'\n\t\telse:\n\t\t\tflag=0\n\t\t\tfor j in dict1[arr[arr1[i]]]:\n\t\t\t\t#print(j)\n\t\t\t\t#print(arr1[j-1])\n\t\t\t\tif(strarr[arr1[j-1]]=='B'):\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\n\t\t\tif(flag==1):\n\t\t\t\tstrarr[arr1[i]]='A'\n\t\t\telse:\n\t\t\t\tstrarr[arr1[i]]='B'\n\t#print(*strarr)\nprint(\"\".join(x for x in strarr))\n\n", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "n,k=map(int,input().split())\nprint(max(min(n,k-1)-k//2,0))", "complexity": "constant", "problem": "1023_B", "from": "CODEFORCES", "tags": "math"}
{"src": "from sys import stdin,stdout\nn,q=map(int,input().split())\nmod=1000000007\no=[]\ns=[]\nr=m=0\na=input()\nfor i in a:\n    if i=='0':\n        r+=1\n    else:\n        m+=1\n    o.append(r)\n    s.append(m)\nz=[1]\n#print(o)\nfor i in range(100000):\n    z.append((z[-1]*2)%mod)\nfor j in range(q):\n    l,r=(int(j) for j in stdin.readline().split())\n    m=r-l+1\n    zs=o[r-1]-o[l-1]+(a[l-1]=='0')\n    os=m-zs\n    #print(zs,os)\n    if zs!=0:\n        print((((z[os]-1)%mod)*((z[zs])%mod))%mod)\n    else:\n        print(((z[os]-1)%mod))\n    \n    \n    \n", "complexity": "linear", "problem": "1062_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "x=int(input())\nd=x//2\nprint(d+1)\n", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\ninput=sys.stdin.buffer.readline\nn=int(input())\narr=list(map(int,input().split()))\ngap=n//2\ncount =0\nwhile gap >=1:\n    for j in range(gap ,n):\n        i= j-gap\n        while i >=0:\n            if arr[i +gap] >arr[i]:\n                break\n            else:\n                arr[i +gap],arr[i] =arr[i] ,arr[i +gap]\n                count +=1\n            i-=gap\n    gap//=2\nif count % 2== 3*n %2:\n    print(\"Petr\")\nelse:\n    print(\"Um_nik\")\n", "complexity": "nlogn", "problem": "0986_B", "from": "CODEFORCES", "tags": "combinatorics,math"}
{"src": "import sys\ninput=sys.stdin.readline\nn,m,k=map(int,input().strip().split(\" \"))\n#s=input().strip()\n#n=int(input().strip())\n#a=list(map(int,input().strip().split(\" \")))\nlr=[]\nfor i in range(n):\n\tlr.append([100000001]+list(map(int,input().strip().split(\" \")))+[100000001])\nud=[[100000001]*m]\nfor i in range(n-1):\n\tud.append(list(map(int,input().strip().split(\" \"))))\nud.append([100000001]*m)\no=[[1000000001]*(m+2)]\nfrom copy import deepcopy\nif k%2:\n\tfor i in range(n):\n\t\tsys.stdout.write(\" \".join([\"-1\"]*m)+\"\\n\")\n\tsys.exit()\nfor _ in range(n):\n\too=[100000001]\n\tfor _ in range(m):\n\t\too.append(0)\n\too.append(100000001)\n\to.append(oo)\no.append([100000001]*(m+2))\nfor _ in range(k//2):\n\too=deepcopy(o)\n\tfor i in range(1,n+1):\n\t\tfor j in range(1,m+1):\n\t\t\too[i][j]=min(lr[i-1][j-1]+o[i][j-1],lr[i-1][j]+o[i][j+1],ud[i-1][j-1]+o[i-1][j],ud[i][j-1]+o[i+1][j])\n\to=deepcopy(oo)\nfor i in o[1:n+1]:\n\tsys.stdout.write(\" \".join(map(str,[j*2 for j in i[1:m+1]]))+\"\\n\")\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "def mus(x):\n    c = 0\n    while(x>0):\n        c += x%10\n        x = x//10\n    return c\nn,s=map(int,input().split())\nans = s + 10 - s%10\nwhile(ans - mus(ans) < s):\n    ans += 10\nif ans > n:\n    print(0)\nelse:\n    print(n-ans+1)\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "m, a = map(int, input().split())\nif (a % m == 0):\n    print(a // m)\nelse:\n    print(a//m + 1)", "complexity": "constant", "problem": "1061_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "# http://codeforces.com/contest/23/problem/A\n\nstring = input()\nsize = len(string)\n\nans_got = 0\nfor s in range(1,size)[::-1]:\n    dic = {}\n    for i in range(0,size-s+1):\n        if(string[i:i+s] in dic):\n            print(s)\n            ans_got = 1\n            break\n        else:\n            dic[string[i:i+s]] = 1\n    if(ans_got == 1):\n        break\nif(ans_got == 0):\n    print(0)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "a = int(input())\nprint(25)", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "\ndef solve():\n    n = int(input())\n    max_degs = [int(x) for x in input().split()]\n\n    B = [[i+1, x] for i, x in enumerate(max_degs) if x >= 2]\n    S = [[i+1, x] for i, x in enumerate(max_degs) if x < 2]\n\n    if 2 + sum(b - 2 for _, b in B) < len(S):\n        print('NO')\n        return\n\n    print('YES', len(B) + min(len(S), 2) - 1)\n    print(n-1)\n\n    # B edges\n    for k in range(len(B) - 1):\n        i, x = B[k]\n        i_n, _ = B[k+1]\n        print(i, i_n)\n        B[k][1] -= 1\n        B[k+1][1] -= 1\n\n    k = 0\n    for i, (s_idx, _) in enumerate(S):\n        if i == 0:\n            print(B[0][0], s_idx)\n            B[0][1] -= 1\n        elif i == 1:\n            print(B[-1][0], s_idx)\n            B[-1][1] -= 1\n        else:\n            while B[k][1] == 0:\n                k += 1\n            print(B[k][0], s_idx)\n            B[k][1] -= 1\n\n\nsolve()\n", "complexity": "linear", "problem": "1082_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "import sys\nimport string\n\nfrom collections import Counter, defaultdict\nfrom math import fsum, sqrt, gcd, ceil, factorial\nfrom operator import *\nfrom itertools import accumulate, count\n\ninf = float(\"inf\")\n# input = sys.stdin.readline\nflush = lambda: sys.stdout.flush\ncomb = lambda x, y: (factorial(x) // factorial(y)) // factorial(x - y)\n\n\n# inputs\n# ip = lambda : input().rstrip()\nip = lambda: input()\nii = lambda: int(input())\nr = lambda: map(int, input().split())\nrr = lambda: list(r())\n\n\narr = ip()\nn = len(arr)\nms = \"\"\nmn = 0\n\n\ndef counter(s, x):\n    p = len(x)\n    px = 0\n    for i in range(len(s)):\n        if s[i : i + p] == x:\n            px += 1\n\n    return px\n\n\nfor i in range(n):\n    s = \"\"\n    for j in range(i, n):\n        s += arr[j]\n        c = counter(arr, s)\n        if c > 1 and len(s) > mn:\n            ms = s\n            mn = len(s)\n\nprint(mn)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import sys\nimport os.path\nfrom collections import *\nimport math\nimport bisect\n\nif (os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\nelse:\n    input = sys.stdin.readline\n\n############## Code starts here ##########################\n\nn = int(input())\n\nif(n == 2 or n == 3 or n == 4 or n == 5):\n    print(-1)\nelse:\n    print(1,2)\n    print(2,3)\n    print(2,4)\n    for i in range(5,n + 1):\n        print(4,i)\n\nfor i in range(2,n + 1):\n    print(1,i)\n\n############## Code ends here ############################\n", "complexity": "linear", "problem": "0959_C", "from": "CODEFORCES", "tags": "constructive algorithms,trees"}
{"src": "x=list(map(int,input().split()))\npos=x[1]\nn=x[0]\nl=x[2]\nr=x[3]\nstep=0\nif pos<l :\n    step=l-pos+1\n    \n    if r< n :\n        step+=r-l+1\nelif pos>r:\n    step=pos-r+1\n    \n    if l> 1 :\n        step+=r-l+1\nelse:\n    if l>1 and n>r:\n        step+=min(pos-l,r-pos)+r-l+2\n    elif l==1 and n>r:\n        step=r-pos+1\n    elif l>1 and n==r:\n        step+=pos-l+1\n    else:\n        step=0\n\n\n\nprint(step)", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def pow2(n):\n    j=0\n    while(n%2==0):\n        n//=2\n        j+=1\n    return j    \nn,q=map(int,input().split())\nfor j in range(q):\n    u=int(input())\n    s=input()\n    for k in range(len(s)):\n        num=pow2(u)\n        if(s[k]==\"R\" and num!=0):\n            u=u+2**(num-1)\n        elif(s[k]==\"L\" and num!=0):\n            u=u-2**(num-1)\n        elif(s[k]==\"U\" and u!=(n+1)//2):\n            m1=u+2**(num)\n            m2=u-2**(num)\n            if(pow2(m1)==(num+1)):\n                u=m1\n            else:\n                u=m2\n    print(u)                ", "complexity": "np", "problem": "0792_D", "from": "CODEFORCES", "tags": "bitmasks,trees"}
{"src": "n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2002)]\n\nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n\nfor v in range(1, 2002):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n\na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n, m, k = map(int, input().strip().split())\n\na = list(map(int, input().strip().split()))\na = [0] + a\ndp = [0] * 300005\nans = 0\nfor i in range(1, n + 1):\n    a[i] += a[i - 1]\n    for j in range(1, m + 1):\n        if i - j >= 0:\n            dp[i] = max(dp[i], a[i] - a[i - j] - k)\n    if i - m >= 0:\n        dp[i] = max(dp[i], a[i] - a[i - m] + dp[i - m] - k)\n    ans = max(ans, dp[i])\n\nprint(ans)\n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "n=int(input())\na=[*map(int,input().split())]\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=range(i%x,n,x)\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "# https://codeforces.com/problemset/problem/313/A\n\nn = int(input())\n\nif n > 0:\n    print(n)\nelse:\n    n = n * -1\n    x = n % 10\n    y = (n // 10) % 10\n\n    if x > y:\n        print(-(n // 10))\n    else:\n        print(-((n // 100)* 10 + x))\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "n,d,k=map(int,input().split())\nif n==1:\n  print(\"NO\")\n  exit()\nif k==1:\n  if n==2 and d==1:\n    print(\"YES\")\n    print(1,2)\n  else:\n    print(\"NO\")\n  exit()\nif n<d+1:\n  print(\"NO\")\n  exit()\nco=1\nans=[]\nfor i in range(1,d+1):\n  ans.append((i,i+1))\n  co+=1\ndef dfs(r,dist,co):\n  if 2<=r<=d:\n    t=k-2\n  else:\n    t=k-1\n  if co==n:\n    return co\n  for _ in range(t):\n    if dist==d:\n      return co\n    if co==n:\n      return co\n    co+=1\n    ans.append((r,co))\n    co=dfs(co,dist+1,co)\n  return co\nfor i in range(2,d+1):\n  co=dfs(i,max(i-1,d-i+1),co)\nif co==n:\n  print(\"YES\")\n  for j in ans:\n    print(*j)\nelse:\n  print(\"NO\")", "complexity": "quadratic", "problem": "1003_E", "from": "CODEFORCES", "tags": "constructive algorithms,graphs"}
{"src": "yellow,blue = map(int,input().split())\nx,y,z = map(int,input().split())\nry = x*2+y\nrb =z*3+y\nr1,r2 = 0,0\nif ry-yellow < 0:\n    r1 = 0\nelse:\n    r1 = ry-yellow\nif rb - blue < 0:\n    r2 = 0\nelse:\n    r2 = rb-blue\nprint(r1+r2)\n", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "q = int(input())\nfor _ in range(q):\n\tl, r = map(int, input().split())\n\tsign = -1 if l % 2 else 1\n\tif (r-l) % 2:\n\t\tprint(-sign*(r-l+1)//2)\n\telse:\n\t\tprint(sign*(l+(r-l)//2))\n\n", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "x,k = map(int,input().split())\nif(x==0):\n    print(0)\n    exit(0)\nm = 10**9+7\np = pow(2,k+1,m)\nq = pow(2,k,m)\na = (x*p-q+1)%m\nprint(a)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import itertools\n\nn = int(input())\na = []\nfor i in range(4):\n    a.append([input() for _ in range(n)])\n    if i < 3:\n        assert input() == ''\n\nbest = 4*n*n\nfor p in itertools.permutations(a):\n    for s in range(2):\n        count = 0\n        for i in range(4):\n            for r in range(n):\n                for c in range(n):\n                    if p[i][r][c] != str((s + (i//2 + r) + (i % 2 + c)) % 2):\n                        count += 1\n        best = min(best, count)\nprint(best)\n", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "people,n=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nd={}\ntmp=[]\nfor i in range(n):\n    if a[i] in d:\n        d[a[i]]+=1\n    else:\n        d[a[i]]=1\nd1={}\nfor i in d:\n    if d[i] in d1:\n        d1[d[i]]+=1\n    else:\n        d1[d[i]]=1\n    tmp.append(d[i])\ntmp.sort()\nans=0\nfor i in range(1,10001):\n    x=people\n    try:\n        x-=d1[i]\n    except:\n        pass\n    for j in d1:\n        if j>i:\n            x-=(j//i)*d1[j]\n    if x<=0:\n        ans=max(ans,i)\nprint(ans)", "complexity": "nlogn", "problem": "1011_B", "from": "CODEFORCES", "tags": "binary search,brute force,implementation"}
{"src": "T = int(input())\nfor _ in range(T):\n    N = int(input())\n\n    if N%2 == 1:\n        print(\"NO\")\n    else:\n        N //= 2\n        if N**(1/2) == int(N**(1/2)):\n            print(\"YES\")\n        else:\n            if N%2 == 1:\n                print(\"NO\")\n            else:\n                N //= 2\n                if N**(1/2) == int(N**(1/2)):\n                    print(\"YES\")\n                else:\n                    print(\"NO\")", "complexity": "constant", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "N = 1010\n\ndp = [[[0] * 4 for j in range(N*2)] for i in range(N)]\ndp[0][1][0] = dp[0][1][1] = dp[0][2][2] = dp[0][2][3] = 1\nm = 998244353\nfor i in range(N-1):\n    for j in range(1,N*2-5):\n        for me in range(4):\n            for he in range(4):\n                if me <= 1:\n                    if he <= 1:\n                        dp[i+1][j+(he!=me)][he] = (dp[i+1][j+(he!=me)][he] + dp[i][j][me]) % m\n                    else:\n                        dp[i+1][j+1][he] = (dp[i+1][j+1][he] + dp[i][j][me]) % m\n                else:\n                    if he <= 1:\n                        dp[i+1][j][he] = (dp[i+1][j][he] + dp[i][j][me]) % m\n                    else:\n                        dp[i+1][j + (he != me)*2][he] = (dp[i+1][j+(he!=me)*2][he] + dp[i][j][me]) % m\nn,k = map(int,input().split())\nprint(sum(dp[n-1][k])%m)                        \n", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "# make sure the king never crosses the row or column the queen is in\n\nn = int(input())\nax, ay = map(int, input().split())\nbx, by = map(int, input().split())\ncx, cy = map(int, input().split())\n\nif bx < ax < cx or bx > ax > cx or by < ay < cy or cy < ay < by:\n    print('NO')\nelse:\n    print('YES')\n", "complexity": "constant", "problem": "1033_A", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation"}
{"src": "mass = list(input())\nb = int(input())\nmass.sort()\nmass = mass[::-1]\np = ''\nwhile(len(mass)>0):\n\tfor i in range(len(mass)):\n\t\tn = p + mass[i] + ''.join(sorted(mass[:i] + mass[i + 1:]))\n\t\tif int(n) <= b:\n\t\t\tp += mass[i]\n\t\t\tmass = mass[:i] + mass[i + 1:]\n\t\t\tbreak\nprint(p)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "#!/bin/python3\nfrom itertools import*\n\nmoves =[(x*mx,y*my) for mx,my,(x,y) in product( (-1,1),(-1,1), ( (1,2),(2,1) ) )]\n\ndef ac(l,x):\n\tif l==0: return 0\n\treturn l[x] if 0<=x<len(l) else 0\n\ndef work():\n\tx=1\n\twhile x:\n\t\tx=0\n\t\tfor r in range(len(a)):\n\t\t\tfor c in range(len(a[0])):\n\t\t\t\tif not a[r][c] and sum(ac(ac(a,r+dr),c+dc) for dr,dc in moves)>=4:\n\t\t\t\t\ta[r][c]=1\n\t\t\t\t\tx=1\n\nfor n in [int(input())]:\n\t#print(' ===== n=',n)\n\tcand=set()\n\n\t#for x in (0,1):\n\t#\tfor y in range(-1000,1000):\n\t#\t\tif y%3!=0: cand.add((x,y))\n\t#\n\t#for y in [0]:\n\t#\tfor x in range(-1000,1000):\n\t#\t\tcand.add((x,y))\n\n\tfor i in range(1000):\n\t\tfor x,y in ( (0,i),(i,0),(i,1),(-i,0),(-i,1),(0,-i) ):\n\t\t\tif x==0 or x%3!=1:\n\t\t\t\tif n==len(cand): break\n\t\t\t\tcand.add((x,y))\n\n\tassert len(cand)==n\n\n\t#NN=25\n\t#a=[[0]*(NN*2) for x in range(NN*2)]\n\t#for x,y in sorted(cand,key=lambda a:abs(a[0])+abs(a[1]))[:n]:\n\t#\ta[x+NN][y+NN]=1\n\n\t#for r in a: print(''.join('-#'[x] for x in r))\n\t#print('===')\n\t#nn=sum(sum(r) for r in a)\n\t#print(nn)\n\n\t#work()\n\n\t#for r in a: print(''.join('-#'[x] for x in r))\n\t#print('===')\n\n\t#have=sum(sum(r) for r in a)\n\t#print(have)\n\t#need=nn**2//10\n\t#print('need',need)\n\n\t#assert have>=need, n\n\n\tfor x,y in cand: print(x,y)\n", "complexity": "constant", "problem": "1067_C", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "import os, sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef getInt(): return int(input())\ndef getStrs(): return input().split()\ndef getInts(): return list(map(int,input().split()))\ndef getStr(): return input()\ndef listStr(): return list(input())\ndef getMat(n): return [getInts() for _ in range(n)]\ndef isInt(s): return '0' <= s[0] <= '9'\n\nsquares = set([i*i for i in range(1,4000)])\n\np = [i for i in range(10**7+1)]\nfor i in range(1,10**7+1):\n    if p[i] == i:\n        for sq in squares:\n            if i*sq > 10**7: break\n            p[i*sq] = i\n\nfor _ in range(getInt()):\n    N, K = getInts()\n    A = getInts()\n    new = 10**8\n    A = [p[A[i]] for i in range(N)]\n    dp = [N]*(K+1)\n    dp[0] = 0\n    used = [set()]*(K+1)\n    for i in range(N):\n        for j in range(K,-1,-1):\n            if dp[j] == N: continue\n            if A[i] in used[j]:\n                if j < K and dp[j+1] > dp[j]:\n                    dp[j+1] = dp[j]\n                    used[j+1] = used[j]\n                dp[j] += 1\n                used[j] = set([A[i]])\n            else:\n                used[j].add(A[i])\n    print(min(dp)+1)\n", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "class Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Vector:\n\n    def __init__(self, start, end):\n        self.x = end.x - start.x\n        self.y = end.y - start.y\n\n    def mult(self, a):\n        return self.y * a.x - self.x * a.y\n\nn = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append(Point(x, y))\n\nif n <= 3:\n    print('YES')\n    exit()\n\n\ndef onLine(points):\n    n = len(points)\n    if n < 3:\n        return True\n    a = Vector(points[0], points[1])\n    for i in range(2, n):\n        b = Vector(points[0], points[i])\n        if a.mult(b) != 0:\n            return False\n    return True\n\ntmp = [points[0], points[1]]\noth = []\nfor i in range(2, n):\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    exit()\n\ntmp = [points[0], points[2]]\noth = []\nfor i in range(1, n):\n    if i == 2:\n        continue\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    exit()\n\ntmp = [points[1], points[2]]\noth = []\nfor i in range(0, n):\n    if i == 2 or i == 1:\n        continue\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    exit()\n\nprint('NO')\n", "complexity": "nlogn", "problem": "0961_D", "from": "CODEFORCES", "tags": "geometry"}
{"src": "l = list(sorted(list(map(int,input().split()))))\nif min(l) == 1 or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==4 and l[2]==4) or(l[0]==2 and l[1] == 2):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "n = int(input())\nA = map(int, input().split())\na = []\nfor x in A:\n\ta.append(x)\ntot = 0\nfor i in range(n):\n\tl = i\n\tr = n - i - 1\n\ttot += a[i] * l + -a[i] * r\n\nfrom collections import defaultdict\n\n# d = defaultdict(int)\n\nfor_cnt = defaultdict(int)\n\nfor i in range(n):\n\tfault = for_cnt[a[i] - 1] + for_cnt[a[i] + 1] + for_cnt[a[i]]\n\ttot -= a[i] * fault\n\tfor_cnt[a[i]] += 1\n\nback_cnt = defaultdict(int)\n\ni = n - 1\nwhile i >= 0:\n\tfault = back_cnt[a[i] - 1] + back_cnt[a[i] + 1] + back_cnt[a[i]]\n\ttot -= -a[i] * fault\n\tback_cnt[a[i]] += 1\n\ti -= 1\n\nprint(tot) \t\n\n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "def ch_x(stri, n):\n    res = ''\n    for i in range(len(stri)):\n        if i != n:\n            res += stri[i]\n        else:\n            res += 'x'\n    return res\n\n\na = input()\nb = input()\nn = 0\nfor i in range(0, len(a)):\n    if a[i] == '0' and b[i] == '0':\n        c = [i-1, i+1]\n        for e in c:\n            if 0 <= e < len(a):\n                if a[e] == '0':\n                    n += 1\n                    a = ch_x(a, e)\n                    break\n                if b[e] == '0':\n                    n += 1\n                    b = ch_x(b, e)\n                    break\n        a = ch_x(a, i)\n        b = ch_x(b, i)\nprint(n)", "complexity": "constant", "problem": "0991_D", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys\n\nn,m=map(int,sys.stdin.readline().split())\nX=[int(sys.stdin.readline()) for i in range(n)]\nY=[list(map(int,sys.stdin.readline().split())) for i in range(m)]\nZ=[]\n\nANS=0\nfor y in Y:\n    if y[0]==1 and y[1]==10**9:\n        ANS+=1\n    elif y[0]==1:\n        Z.append(y[1])\nX.sort(reverse=True)\nZ.sort(reverse=True)\n\nXCOUNT=[0]*n#X[i]\u3088\u308a\u5927\u304d\u3044Z\u306e\u500b\u6570\n\ni=0\nj=0\nl=len(Z)\nX.append(0)\nZ.append(0)\nwhile i<l+1 and j<n:\n    if Z[i]>=X[j]:\n        i+=1\n    else:\n        XCOUNT[j]=i\n        j+=1\n\ncount=n\nXCOUNT.reverse()\nfor i in range(n):\n    if count>i+XCOUNT[i]:\n        count=i+XCOUNT[i]\n\nprint(count+ANS)\n\n\n    \n", "complexity": "nlogn", "problem": "1075_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "a=''.join(reversed(sorted(input())))\nb=int(input())\nr=''\nwhile len(a)>0:\n    for i in range(len(a)):\n        n=r+a[i]+''.join(sorted(a[:i]+a[i+1:]))\n        if int(n)<=b:\n            r+=a[i]\n            a=a[:i]+a[i+1:]\n            break\nprint(r)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n=int(input())\ns=[c=='1' for c in input()]\nm=len(s)\nz=[[0,0]]\nfor c in s:\n ind = z[-1][c]\n z[-1][c] = len(z)\n z.append(z[ind][:])\nassert(len(z) == m+1)\nz[m][0] = z[m][1] = m # make it sticky\n\n# how many things match directly\ndp = [0 for _ in range(m+1)]\ndp[0] = 1\nfor i in range(n):\n ndp = [0 for _ in range(m+1)]\n for i in range(m+1):\n  ndp[z[i][0]] += dp[i]\n  ndp[z[i][1]] += dp[i]\n dp = ndp\nres = dp[m]\n\nfor k in range(1, m):\n s0 = 0\n for c in s[-k:]:\n  s0 = z[s0][c]\n dp = [0 for _ in range(m+1)]\n dp[s0] = 1\n for i in range(n - k):\n  ndp = [0 for _ in range(m+1)]\n  for i in range(m+1):\n   ndp[z[i][0]] += dp[i]\n   ndp[z[i][1]] += dp[i]\n  dp = ndp\n for s1 in range(m): # skip m\n  v = dp[s1]\n  for c in s[-k:]:\n   if s1 == m: v = 0\n   s1 = z[s1][c]\n  if s1 == m: res += v\nprint(res)", "complexity": "np", "problem": "1038_F", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "def solve(n,k):\n    print(1*k,end = ' ')\n    if n==2:\n        print(2*k,end = ' ')\n    if n == 3:\n        print(k,3*k,end = ' ')\n    else:\n        temp = n//2\n        if(n%2 == 0): temp -= 1\n        print((str(k)+' ')*temp,end='')\n        if(n>3):\n            solve(n//2,k*2)\n\nn = int(input())\nsolve(n,1)", "complexity": "linear", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "n = int(input())\ns = input()\nwant = len(set(s))\nd = {}\nj = 0\ncount = 0\nans = float(\"inf\")\nfor i in range(n):\n    if s[i] not in d:\n        d[s[i]] = 0\n        count+=1\n    d[s[i]]+=1\n    if count==want:\n        while d[s[j]]>1:\n            d[s[j]]-=1\n            j+=1\n        ans = min(ans,i-j+1)\nprint(ans)", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "#!/usr/bin/env python\n'''\n' Author:   Cheng-Shih Wong\n' Email:    mob5566@gmail.com\n' Date:     2017-08-08\n'''\n\nfrom itertools import chain\nfrom time import time\n\ndef main():\n\n    BITS = [1 << sh for sh in range(24)]\n    B2N = {v: u for u, v in enumerate(BITS)}\n\n    def getPt():\n        return tuple(map(int, input().split()))\n\n    def dist(ptA, ptB):\n        return sum(((u-v)**2 for u, v in zip(ptA, ptB)))\n\n    def getBits(val):\n        return tuple(filter(lambda x: x&val, BITS))\n\n    def chooseTwo(pool):\n        n = len(pool)\n        for i in range(n):\n            for j in range(i+1, n):\n                yield (pool[i], pool[j])\n\n    ori = getPt()\n    pts = []\n    N = int(input())\n\n    for _ in range(N):\n        pts.append(getPt())\n\n    vis = set([0])\n    mint = [0]+[1e8]*(1<<N) # minimal time for dp\n    pres = [None]*(1<<N) # previous step for reconstruct path\n    allb = (1 << N)-1 # all objects contained state\n    B2P = {BITS[u]: v for u, v in enumerate(pts)}\n    B2P[0] = ori\n    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}\n\n    getDP = lambda x: mint[x]\n    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \\\n                                + alld[p[0]][0] \\\n                                + alld[p[1]][0] \n\n    for stt in range(1<<N):\n        if stt not in vis:\n            continue\n\n        bits = getBits(~stt&allb)\n\n        sb = bits[0] if bits else None\n\n        for bit in bits:\n\n            newstt = stt | sb | bit\n            nd = newDist(stt, (sb, bit))\n            if getDP(newstt) > nd:\n                mint[newstt] = nd\n                pres[newstt] = sb | bit\n                vis.add(newstt)\n\n    print(mint[allb])\n    path = ['0']\n    stt = allb\n\n    while stt:\n\n        bits = getBits(pres[stt])\n        for bit in bits:\n            path.append(str(B2N[bit]+1))\n        path.append('0')\n\n        stt ^= pres[stt]\n\n    print(' '.join(path))\n\nif __name__ == '__main__':\n    import sys\n    st = time()\n    main()\n    print('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO,IOBase\nfrom collections import defaultdict,Counter\nfrom copy import deepcopy\n\ndef main():\n    n,c = map(int,input().split())\n    a = list(map(int,input().split()))\n    nums = defaultdict(lambda :[0])\n    freq,minus = Counter(),0\n    for i in a:\n        if i == c:\n            minus += 1\n        else:\n            freq[i] += 1\n            nums[i].append(freq[i]-minus)\n    tot = minus\n    suff = deepcopy(nums)\n    for i in nums:\n        for j in range(len(nums[i])-2,0,-1):\n            suff[i][j] = max(suff[i][j],suff[i][j+1])\n    freq,ans = Counter(),tot\n    for i in a:\n        if i == c:\n            continue\n        freq[i] += 1\n        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)\n    print(ans)\n\n# Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self,file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            self.newlines = b.count(b\"\\n\")+(not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd,self.buffer.getvalue())\n            self.buffer.truncate(0),self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self,file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s:self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda:self.buffer.read().decode(\"ascii\")\n        self.readline = lambda:self.buffer.readline().decode(\"ascii\")\nsys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)\ninput = lambda:sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()", "complexity": "constant", "problem": "1082_E", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "n,v=[int(x) for x in input().split()]\nif v>=(n-1):\n    print(n-1)\nelse:\n    print(int((((n-v)*(n-v+1))/2)-1+v))\n    \n    ", "complexity": "constant", "problem": "1113_A", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "n = int(input())\na = [int(i) for i in input().split()]\nc = 0\nfor i in range(n):\n    if a[i] > c:\n        print(i+1)\n        break\n    else:\n        c = max(a[i]+1, c)\nelse:\n    print(-1)\n", "complexity": "linear", "problem": "1054_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "a=list(input())\nb=list(input())\nnum=int(''.join(b))\na.sort()\na.reverse()\nal=len(a)\nans=[]\nif(len(a)==len(b) and len(a)!=1):\n\tc=[]\n\tcount=0\n\thogya=0\n\tfor i in range(al):\n\t\tif(hogya==1):\n\t\t\to.reverse()\n\t\t\tf=list(c+o)\n\t\t\tans.append(''.join(f))\n\t\t\tcount+=1\n\t\t\tbreak\n\t\tt=len(a)\n\t\tj=0\n\t\tmittal=t\n\t\tabhinhi=0\n\t\twhile(t):\n\t\t\t#print(\"hello\")\n\t\t\tif(j>len(a)-1):\n\t\t\t\tbreak\n\t\t\tif(int(a[j])<=int(b[i])):\n\t\t\t\tc.append(a[j])\n\t\t\t\ttemp=a[j]\n\t\t\t\ta.remove(a[j])\n\t\t\t\to=a.copy()\n\t\t\t\to.sort()\n\t\t\t\tf=list(c+o)\n\t\t\t\t#if(i==8):\n\t\t\t\t#\tprint(c,a)\n\t\t\t\t#print(num,a)\n\t\t\t\tif(temp<b[i]):\n\t\t\t\t\t#print(i,temp,j,f)\n\t\t\t\t\t#print(\"hello\")\n\t\t\t\t\t#print(\"hello\",hogya)\n\t\t\t\t\thogya=1\n\t\t\t\t\tbreak\n\t\t\t\tif(int(''.join(f))<=num):\n\t\t\t\t\tans.append(''.join(f))\n\t\t\t\t\tcount+=1\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\ta.append(temp)\n\t\t\t\t\tc=c[:len(c)-1]\n\t\t\t\t\t#c.remove(c[len(c)-1])\n\t\t\t\t\t#print(c,a)\n\t\t\t\t\t\n\t\t\t\tt-=1\n\t\t\telse:\n\t\t\t\tj+=1\n\t\t\t\tt-=1\n\t\tif(mittal==len(a)):\n\t\t\t#print(mittal,i)\n\t\t\t#print(\"hello\")\n\t\t\tbreak\n\t#print(count)\n\tprint(ans[count-1])\nelif(len(a)==1):\n\tprint(''.join(a))\nelse:\n\tprint(''.join(a))\n#print(ans)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n = int(input())\na = list(map(int, input().strip().split()))\n\namin = min(a)\nfor i in range(n):\n    a[i] -= amin\nans = amin % n\ncnt = 0\nwhile True:\n    if a[ans] <= cnt:\n        break\n    ans = (ans + 1) % n\n    cnt += 1\nprint(ans + 1)\n\n", "complexity": "linear", "problem": "0996_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "# Fast IO Region\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# Get out of main function\ndef main():\n    pass\n# decimal to binary\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n# binary to decimal\ndef decimal(s):\n    return (int(s, 2))\n# power of a number base 2\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return (p)\n# if  number is prime in \u221an time\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n# list to string ,no spaces\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n# String to list\ndef stl(s):\n    # for each character in string to list with no spaces -->\n    l = list(s)\n    # for space in string  -->\n    # l=list(s.split(\" \"))\n    return l\n# Returns list of numbers with a particular sum\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n# Sieve for prime numbers in a range\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n            # print(p)\n    return (cnt)\n# for positive integerse only\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n# 1000000007\nmod = int(1e9) + 7\nimport math\n#import random\n#import bisect\n#from fractions import Fraction\n#from collections import OrderedDict\n#from collections import deque\n########################                         mat=[[0 for i in range(n)] for j in range(m)]                      ########################\n########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################\n########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################\n########################                         from collections import deque                              ########################\n########################                         ASCII of A-Z= 65-90                                        ########################\n########################                         ASCII of a-z= 97-122                                       ########################\n########################                         d1.setdefault(key, []).append(value)                       ########################\n#sys.setrecursionlimit(300000)          #Gives memory limit exceeded if used a lot\n#for ___ in range(int(input())):\nn=int(input())\nd={}\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    d.setdefault(u,[]).append(v)\n    d.setdefault(v,[]).append(u)\nnode=1\nfor key in d:\n    if(len(d[key])>len(d[node])):\n        node=key\nans=[]\nvisited=[0]*n\nvisited[node-1]=1\nfor c in d[node]:\n    while(True):\n        visited[c-1]=1\n        if(len(d[c])==1):\n            ans.append([node,c])\n            break\n        for child in d[c]:\n            if(visited[child-1]!=1):\n                c=child\n                break\nif(sum(visited)==n):\n    print(\"Yes\")\n    print(len(ans))\n    for c in ans:\n        print(*c)\nelse:\n    print(\"No\")", "complexity": "linear", "problem": "0981_C", "from": "CODEFORCES", "tags": "implementation,trees"}
{"src": "# Fast IO Region\nimport os\nimport sys\nfrom io import BytesIO ,IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# Get out of main functoin\ndef main():\n    pass\n# decimal to binary\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n# binary to decimal\ndef decimal(s):\n    return (int(s, 2))\n# power of a number base 2\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return (p)\n# if  number is prime in \u221an time\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n# list to string ,no spaces\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n# String to list\ndef stl(s):\n    # for each character in string to list with no spaces -->\n    l = list(s)\n    # for space in string  -->\n    # l=list(s.split(\" \"))\n    return l\n# Returns list of numbers with a particular sum\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n# Sieve for prime numbers in a range\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n            # print(p)\n    return (cnt)\n# for positive integerse only\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n# 1000000007\nmod = int(1e9) + 7\ndef ssinp(): return input()\n# s=input()\ndef iinp(): return int(input())\n# n=int(input())\ndef nninp(): return map(int ,input().split())\n# a,b,c=map(int,input().split())\ndef llinp(): return list(map(int ,input().split()))\n# a=list(map(int,input().split()))\ndef p(xyz): print(xyz)\ndef p2(a ,b): print(a ,b)\nimport math\n\n# import random\n# sys.setrecursionlimit(300000)\n# from fractions import Fraction\nfrom collections import OrderedDict\n# from collections import deque\n########################                         mat=[[0 for i in range(n)] for j in range(m)]                      ########################\n########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################\n########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################\n########################                         from collections import deque                              ########################\n########################                         ASCII of A-Z= 65-90                                        ########################\n########################                         ASCII of a-z= 97-122                                       ########################\n########################                         d1.setdefault(key, []).append(value)                       ########################\n#for __ in range(iinp()):\na=llinp()\nans=0\nfor i in range(14):\n    temp=a.copy()\n    nos=temp[i]\n    temp[i]=0\n    for j in range(i+1,14):\n        temp[j]+=1\n        nos-=1\n    for j in range(0,14):\n        temp[j]+=nos//14\n    nos=nos%14\n    j=0\n    while(nos!=0):\n        temp[j]+=1\n        nos-=1\n        j+=1\n    ans1=0\n    for c in temp:\n        if(c%2==0):\n            ans1+=c\n    ans=max(ans,ans1)\np(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "constant", "problem": "0975_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "input()\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nu = [0] * len(a)\n\nans = 0\n\nfor i in range(len(a)):\n    if u[i] != 0:\n        continue\n    idx = i\n    while u[idx] == 0:\n        u[idx] = 1\n        idx = a[idx] - 1\n    \n    if (u[idx] == 2):\n        idx = i\n        while u[idx] == 1:\n            u[idx] = 2\n            idx = a[idx] - 1\n        continue\n\n    start = idx\n    mn = c[idx]\n    u[idx] = 2\n    while a[idx] - 1 != start:\n        idx = a[idx] - 1\n        mn = min(mn, c[idx])\n        u[idx] = 2\n\n    idx = i\n    while u[idx] == 1:\n        u[idx] = 2\n        idx = a[idx] - 1\n    ans += mn\nprint(ans)\n", "complexity": "linear", "problem": "1027_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs"}
{"src": "n=input();print(max(map(int,(n,n[:-1],n[:-2]+n[-1]))))", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "import sys\nimport math\n\n\ndef readlines(type=int):\n    return list(map(type, sys.stdin.readline().split()))\n\n\ndef read(type=int):\n    return type(sys.stdin.readline().strip())\n\n\njoint = lambda it, sep=\" \": sep.join(\n    [str(i) if type(i) != list else sep.join(map(str, i)) for i in it])\n\n\ndef solve_naive(n, k):\n    taken = set()\n    current_cap = 0\n    found = False\n    while current_cap != n:\n        for c in range(k, 1, -1):\n            found = False\n            if current_cap == 0:\n                if c <= n:\n                    current_cap += c\n                    taken.add(c)\n                    found = True\n                    break\n            else:\n                if c not in taken and c - 1 <= n - current_cap:\n                    current_cap += c - 1\n                    taken.add(c)\n                    found = True\n                    break\n        if not found:\n            break\n    return len(taken) if found else -1\n\n\ndef solve(n, k):\n    if n == 1:\n        return 0\n    if k >= n:\n        return 1\n    else:\n        if (3 - 2 * k) ** 2 - 8 * (n - k) < 0:\n            return -1\n        t = (-math.sqrt((3 - 2 * k) ** 2 - 8 * (n - k)) + (2 * k) - 3) / 2\n        if t == 0.0:\n            return 2\n        if t % 1 == 0:\n            return 1 + int(t)\n        else:\n            # print(f\"{t=}\")\n            return 2 + int(t)\n\n\ndef main():\n    n, k = readlines()\n    print(solve(n, k))\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "tmp = input().split()\nn = int(tmp[0])\nm = int(tmp[1])\n\na = list()\nb = list()\ndiff = list()\nfor i in range(n):\n    tmp = input().split()\n    a.append(int(tmp[0]))\n    b.append(int(tmp[1]))\n    diff.append(a[i] - b[i])\n\ndiff.sort(reverse=True)\n\nsum_a = sum(a)\ni = 0 \nwhile sum_a > m and i < n:\n    sum_a = sum_a - diff[i]\n    i = i + 1 \n\nif i >= n and sum_a > m:\n    print(-1)\nelse:\n    print(i)", "complexity": "nlogn", "problem": "1015_C", "from": "CODEFORCES", "tags": "sortings"}
{"src": "n = int(input())\na = list(map(int, input().split(' ')))\n\nnew_a = [[0] * 600 for i in range(600)]\ndp = [[0x7fffffff] * 600 for i in range(600)]\n\nfor i in range(n):\n\tnew_a[i+1][i+1] = a[i]\n\tdp[i+1][i+1] = 1\n\nfor i in range(1, n + 1):\n\tfor j in range(i + 1, n + 1):\n\t\tdp[i][j] = j - i + 1\n\nfor llen in range(2, n + 1):\n\tfor left in range(1, n - llen + 2):\n\t\tright = left + llen - 1\n\t\tfor middle in range(left, right):\n\t\t\tdp[left][right] = min(dp[left][right], dp[left][middle] + dp[middle+1][right])\n\t\t\tif dp[left][middle] == 1 and dp[middle+1][right] == 1 and new_a[left][middle] == new_a[middle+1][right]:\n\t\t\t\tdp[left][right] = 1\n\t\t\t\tnew_a[left][right] = new_a[left][middle] + 1\n\nprint(dp[1][n])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "N, K = list(map(int, input().split()))\nS = input().strip()\nS = [-1 if _ == '?' else ord(_) - ord('a') for _ in S]\n\ndef check(x):\n    p = [[N for i in range(N+1)] for k in range(K)]\n\n    for k in range(K):\n        keep = 0\n        for i in range(N-1, -1, -1):\n            keep += 1\n            if S[i] != -1 and S[i] != k:\n                keep = 0\n            p[k][i] = p[k][i+1]\n            if keep >= x:\n                p[k][i] = i + x - 1\n\n    d = [N for s in range(1<<K)]\n    d [0] = -1\n    for s in range(1, 1<<K):\n        for k in range(K):\n            if (s&(1<<k)) and (d[s^(1<<k)]<N):\n                d[s] = min(d[s], p[k][d[s^(1<<k)]+1])\n                # print('d[%d%d]=%d'%(s//2, s%2, d[s]))\n    return d[(1<<K)-1] < N\n    \nl, r = 0, N//K\n\nwhile l < r:\n    mid = (l + r + 1) // 2\n    if check(mid):\n        l = mid\n    else:\n        r = mid - 1\nprint(l)\n", "complexity": "np", "problem": "1550_E", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,strings,two pointers"}
{"src": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\n\nr, g, b = rints()\nar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]\nmem = [[[0 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]\nans = 0\n\nfor r1 in range(r + 1):\n    for g1 in range(g + 1):\n        for b1 in range(b + 1):\n            if r1 < r:\n                if g1 < g:\n                    mem[r1 + 1][g1 + 1][b1] = max(mem[r1 + 1][g1 + 1][b1], (ar[r1] * ag[g1]) + mem[r1][g1][b1])\n                if b1 < b:\n                    mem[r1 + 1][g1][b1 + 1] = max(mem[r1 + 1][g1][b1 + 1], (ar[r1] * ab[b1]) + mem[r1][g1][b1])\n\n            if g1 < g and b1 < b:\n                mem[r1][g1 + 1][b1 + 1] = max(mem[r1][g1 + 1][b1 + 1], (ag[g1] * ab[b1]) + mem[r1][g1][b1])\n\n            ans = max(ans, mem[r1][g1][b1])\n\nprint(ans)", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nidx = list(range(n))\nidx.sort(key=lambda i: a[i], reverse=True)\nimin = imax = idx[0]\nfor i in idx[1:]:\n    if i == imin - 1 or i == imax + 1:\n        imin = min(imin, i)\n        imax = max(imax, i)\n    else:\n        print('NO')\n        exit(0)\nprint('YES')\n", "complexity": "nlogn", "problem": "1197_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "from sys import stdin, stdout\nfrom math import sin, tan, cos\n\nn, m, k, l = map(int, stdin.readline().split())\n\nlb, rb = 0, n // m + 1\nwhile rb - lb > 1:\n    mid = (lb + rb) >> 1\n    \n    if mid * m - k >= l:\n        rb = mid\n    else:\n        lb = mid\n\nif lb != n // m:\n    stdout.write(str(rb))\nelse:\n    stdout.write('-1')", "complexity": "logn", "problem": "1068_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\ninput=sys.stdin.readline\nn=int(input())\na=list(map(int,input().split()))\nf=[[0]*n for i in range(n)]\nfor i in range(n):\n    f[0][i]=a[i]\nfor i in range(1,n):\n    for j in range(n-i):\n        f[i][j]=f[i-1][j]^f[i-1][j+1]\nfor i in range(1,n):\n    for j in range(n-i):\n        f[i][j]=max(f[i][j],f[i-1][j],f[i-1][j+1])\nq=int(input())\nfor _ in range(q):\n    l,r=map(int,input().split())\n    print(f[r-l][l-1])", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "import math\ndef nCr(n,r):\n\tf = math.factorial\n\treturn f(n) / f(r) / f(n-r)\ndict1 = {'+':0,'-':0,'?':0}\nfor i in input():\n\tdict1[i]+=1\nfor i in input():\n\tif(i=='?'):\n\t\tdict1[i]+=1\n\telse:\n\t\tdict1[i]-=1\nif dict1['+']<0 or dict1['-']<0:\n\tprint(0.000000000000)\nelif dict1['+']==0 and dict1['-']==0:\n\tprint(1.000000000000)\nelif dict1['+'] and dict1['-']:\n\tans = (nCr(dict1['?'], dict1['+'])/(2**dict1['?']))\n\tprint(\"%.12f\" %ans)\nelse:\n\tans = (1 / (2 ** dict1['?']))\n\tprint(\"%.12f\" % ans)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "n = int(input())\n\nstring = input()\ni = 0\nj = 0\ntotal = 0\n\nwhile j < len(string):\n    bool = False\n    count = 0\n    while j < len(string) and string[i] == 'x' and string[j] == 'x':\n        count += 1\n        bool = True\n        j += 1\n\n    if count >= 3:\n        total += (count-3)+1\n    if bool:\n        i = j\n    else:\n        i += 1\n        j += 1\n\n\n\nprint(total)\n", "complexity": "linear", "problem": "0978_B", "from": "CODEFORCES", "tags": "greedy,strings"}
{"src": "from collections import defaultdict, Counter\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd\n \ndef read(): return list(map(int, input().strip().split()))\n \nans_ = []\n\n \n# for _ in range(int(input())):\nt_p = [2**i for i in range(31)]\nn = int(input()); \narr = Counter(read())\nd = defaultdict(int)\nm = 1; ans_lis = [[list(arr.keys())[0], 1]]\n\nfor i in arr:\n    for j in t_p:\n        a, b, c = i, i+j, i+2*j\n        s = arr[a] + arr[b] + arr[c]\n        if s > m:\n            m = s\n            ans_lis = [[x, arr[x]] for x in [a, b, c]]\n\n\nans_.append(m)\nt = \"\"\nfor i in ans_lis:t += (str(i[0])+\" \")*i[1]\nans_.append(t)\n\n\n\n\n\n \n \n# print(ans_)\nfor i in ans_:\n    print(i)\n \n \n\"\"\"\n0 2 4 \n3 5 7\n\n\n0 8 16\n\n\n\"\"\"", "complexity": "nlogn", "problem": "0988_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "str1,str2=map(str,input(\"\").split())\nlst=[]\nlst_ans=[]\nl_count=0\ncount=0\nfor i in str2:\n    if(count<1):\n        lst.append(i)\n    else:\n        break\nfor i in str1:\n    if(count==0):\n        lst_ans.append(i)\n        count+=1\n    elif(ord(i)<ord(lst[0])):\n        lst_ans.append(i)\n    else:\n        lst_ans.append(lst[0])\n        break\nelse:\n    lst_ans.append(lst[0])\nprint(''.join(lst_ans))  ", "complexity": "linear", "problem": "0909_A", "from": "CODEFORCES", "tags": "brute force,greedy,sortings"}
{"src": "def problem(s, p):\n    for i in range(len(p)):\n        l = p[:i] + ' '\n        r = p[i:] + ' '\n \n        dp = [0] + [None] * i\n \n        for x in s:\n            for j in range(i, -1, -1):\n                if dp[j] is None:\n                    continue\n \n                if l[j] == x:\n                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])\n \n                temp = r[dp[j]]\n                if r[dp[j]] == x:\n                    dp[j] += 1\n \n        if dp[-1] == len(r) - 1:\n            return 'YES'\n \n    return 'NO'\n \n \nfor _ in range(int(input())):\n    print(problem(input(), input()))\n\n\t\t\t \t \t   \t  \t     \t\t\t    \t\t\t \t", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "\ndef main():\n    k = int(input())\n    n = []\n    a = []\n    for i in range(k):\n        line = [int(x) for x in input().split()]\n        ni = line[0]\n        ai = []\n        n.append(ni)\n        a.append(ai)\n        for j in range(ni):\n            ai.append(line[1 + j])\n    answer, c, p = solve(k, n, a)\n    if answer:\n        print(\"Yes\")\n        for i in range(k):\n            print(c[i], p[i] + 1)\n    else:\n        print(\"No\")\n\n\ndef solve(k, n, a):\n    asum, sums = calc_sums(k, n, a)\n    if asum % k != 0:\n        return False, None, None\n    tsum = asum / k\n    num_map = build_num_map(k, n, a)\n    masks = [None]*(1 << k)\n    simple = [False]*(1 << k)\n    answer = [False]*(1 << k)\n    left = [0]*(1 << k)\n    right = [0]*(1 << k)\n    by_last_one = [[] for _ in range(k)]\n    for i in range(k):\n        for j in range(n[i]):\n            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, [])\n            if found and not answer[mask]:\n                answer[mask] = True\n                masks[mask] = path\n                simple[mask] = True\n                by_last_one[calc_last_one(mask)].append(mask)\n    if answer[(1 << k) - 1]:\n        return build_answer(k, masks, left, right)\n    for mask_right in range(2, 1 << k):\n        if not simple[mask_right]:\n            continue\n        last_one = calc_last_one(mask_right)\n        zeroes_count = 0\n        alternative_sum = 0\n        zero_list = []\n        for u in range(last_one):\n            if (mask_right & (1 << u)) == 0:\n                zeroes_count += 1\n                alternative_sum += len(by_last_one[u])\n                zero_list.append(u)\n        if zeroes_count == 0:\n            continue\n        if alternative_sum < (1 << zeroes_count):\n            for fill_last_zero in zero_list:\n                for mask_left in by_last_one[fill_last_zero]:\n                    if (mask_left & mask_right) != 0:\n                        continue\n                    joint_mask = mask_left | mask_right\n                    if not answer[joint_mask]:\n                        answer[joint_mask] = True\n                        left[joint_mask] = mask_left\n                        right[joint_mask] = mask_right\n                        by_last_one[last_one].append(joint_mask)\n                        if joint_mask == ((1 << k) - 1):\n                            return build_answer(k, masks, left, right)\n        else:\n            for mask_mask in range(1 << zeroes_count):\n                mask_left = 0\n                for u in range(zeroes_count):\n                    if (mask_mask & (1 << u)) != 0:\n                        mask_left = mask_left | (1 << zero_list[u])\n                joint_mask = mask_left | mask_right\n                if answer[mask_left] and not answer[joint_mask]:\n                    answer[joint_mask] = True\n                    left[joint_mask] = mask_left\n                    right[joint_mask] = mask_right\n                    by_last_one[last_one].append(joint_mask)\n                    if joint_mask == ((1 << k) - 1):\n                        return build_answer(k, masks, left, right)\n    return False, None, None\n\n\ndef calc_last_one(x):\n    result = -1\n    while x > 0:\n        x = x >> 1\n        result = result + 1\n    return result\n\n\ndef build_answer(k, masks, left, right):\n    c = [-1] * k\n    p = [-1] * k\n    pos = (1 << k) - 1\n    while not masks[pos]:\n        for i, a, j in masks[right[pos]]:\n            c[i] = a\n            p[i] = j\n        pos = left[pos]\n    for i, a, j in masks[pos]:\n        c[i] = a\n        p[i] = j\n    return True, c, p\n\n\ndef build_num_map(k, n, a):\n    result = dict()\n    for i in range(k):\n        for j in range(n[i]):\n            result[a[i][j]] = (i, j)\n    return result\n\n\ndef find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):\n    if (mask & (1 << i)) != 0:\n        if i == i_origin and j == j_origin:\n            return True, mask, path\n        else:\n            return False, None, None\n    mask = mask | (1 << i)\n    a_needed = tsum - (sums[i] - a[i][j])\n    if a_needed not in num_map:\n        return False, None, None\n    i_next, j_next = num_map[a_needed]\n    path.append((i_next, a[i_next][j_next], i))\n    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)\n\n\ndef calc_sums(k, n, a):\n    sums = [0] * k\n    for i in range(k):\n        for j in range(n[i]):\n            sums[i] = sums[i] + a[i][j]\n    asum = 0\n    for i in range(k):\n        asum = asum + sums[i]\n    return asum, sums\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nimport bisect\nT = int(input())\nr = 1\nprime = [2]\n\nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue \n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0: \n            flag = True \n            break\n    if not flag:  prime.append(i)\n\ndef primefactor(num):\n\n    index = 0\n    output = []\n\n    while num>=prime[index]**2:\n\n        times = 0\n        while num%prime[index]==0:\n            num = num // prime[index]\n            times += 1\n        if times&1:  output.append(prime[index])\n        index += 1 \n\n    if num>1: output.append(num)\n\n\n    return tuple(output)\n\nwhile r<=T:\n    n,k = map(int,input().split())\n    arr = list(map(int,input().split()))\n\n    seg = 1\n    fact = {}\n    left = [[0 for j in range(k+1)] for i in range(n)]\n    dp = [[300000 for j in range(k+1)] for i in range(n)]\n\n    stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:\n            bisect.insort(stack,fact[factor]+1)\n            \n        fact[factor] = i\n\n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n\n\n\n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):\n                l = left[i][t]\n                if l>0:\n                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])\n                else:\n                    dp[i][j] = 1\n\n    print(dp[-1][-1])   \n    r += 1", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "from collections import Counter as C\nn, m = map(int, input().split())\nl = [*map(int, input().split())]\nc = sorted(C(l).items())\n\nres = 0\nj = 0\nfor hi, ni in c:\n    # print(hi, ni, j)\n    h = min(hi - j, ni) + j\n    res += (hi - 1) * ni \n    if h > j:\n        j = h\nm = max(l)\nif j < m:\n    res -= m - j\nprint(res)", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "n,m=map(int,input().strip().split())\nv=[0]*51\nleft=1\nright=n\nfor i in range(1,n+1):\n\tif(n-i-1<=0):\n\t\tpw=1\n\telse:\n\t\tpw=(1<<(n-i-1))\n\n\tif(m<=pw):\n\t\tv[left]=i\n\t\tleft+=1\n\telse:\n\t\tv[right]=i\n\t\tright-=1\n\t\tm-=pw\nfor i in range(1,n):\n\tprint(v[i], end=' ')\nprint(v[n])\n\t\t\t   \t\t\t   \t  \t\t \t\t \t \t\t\t\t\t\t\t", "complexity": "np", "problem": "0513_B2", "from": "CODEFORCES", "tags": "bitmasks,divide and conquer,math"}
{"src": "n = int(input())\ndp = [1]\nfor IND in range(n):\n    c = input()\n    if c == \"f\":\n        dp.insert(0,0)\n    else:\n        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007\nprint(dp[0])\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "n, a, b = map(int, input().split())\nz, o = ('01', '10')[a < b]\nn *= not (a > 1 < b or 1 < n * a * b < 4)\nl = [[z] * n for _ in range(n)]\nfor i in range(n):\n    l[i][i] = '0'\nfor i in range(n - a * b):\n    l[i][i + 1] = l[i + 1][i] = o\nprint(('YES', 'NO')[not n])\nprint('\\n'.join(map(''.join, l)))", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "# template begins\n#####################################\nfrom io import BytesIO, IOBase\nimport sys\nimport math\nimport os\nfrom collections import defaultdict\nfrom math import ceil\nfrom bisect import bisect_left, bisect_left\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\ndef mint(): return map(int, input().split())\ndef mfloat(): return map(float, input().split())\n\n\n#####################################\n# template ends\n# Use the recursion snippet if heavy recursion is needed (depth>1000)\ndef solve():\n    n, m, k = mint()\n    horizontal = [list(mint()) for i in range(n)]\n    vertical = [list(mint()) for i in range(n-1)]\n    if k%2 or max(n, m)==1:\n        for i in range(n):\n            print(*[-1]*m)\n        return\n    \"\"\"\n    does it make sense to double back on a path if k is large enough?\n    or are there cases when you need to make a loop?\n\n    proof:\n    if you have a path of length k that does not visit any edge more than once,\n    we can split it into 2 paths of length k/2\n    if one of them was cheaper than the other, we should have just back tracked on that\n    hence, both must be the same\n    in that case, you can just double any one\n\n    should ideally double back on the same path if k is big enough\n    just find the cheapest path of length k/2 and double it?\n\n    how do you find the cheapest path of length k/2?\n\n    dp?\n    store the cheapest path of length x from every node,\n    where x will be from 1 to k/2\n    yeah should work\n    dp[i][j][x] represents the cheapest path of length from g[i][j] of length x\n    \"\"\"\n    dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]\n    for length in range(1, k//2+1):\n        for i in range(n):\n            for j in range(m):\n                \"\"\"\n                we want cost_to_neighbour + dp[neigbour][length-1] to be min\n                \"\"\"\n                left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]\n                right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]\n                top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]\n                bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]\n                dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])\n    for i in range(n):\n        for j in range(m):\n            print(dp[i][j][k//2]*2, end=' ')\n        print()\n\n    \n\ndef main():\n    # t = int(input())\n    t = 1\n    for _ in range(t):\n        solve()\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res//x * (x-1)\n            while n%x==0:\n                n //= x\n    if n!=1:\n        res = res//n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n//=b\n    return res\n\ndef isPrimeMR(n):\n    if n==1:\n        return 0\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):#\u6392\u4ed6\u7684\u8ad6\u7406\u548c\u306e\u968e\u4e57\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\n#O(|S|)\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=0):\n        self.BIT = [0]*(n+1)\n        self.num = n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matridigit[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matridigit[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matridigit[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matridigit[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m//=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matridigit[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn,mod = mi()\n\nN = 1000\ng1 = [1]*(N+1)\ng2 = [1]*(N+1)\ninverse = [1]*(N+1)\n\nfor i in range( 2, N + 1 ):\n    g1[i]=( ( g1[i-1] * i ) % mod )\n    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2[i]=( (g2[i-1] * inverse[i]) % mod )\ninverse[0]=0\n\npow_2 = [1 for i in range(1001)]\nfor i in range(1,1001):\n    pow_2[i] = (pow_2[i-1] * 2) % mod\n\ndp = [[1]]\n\nfor i in range(n):\n    ndp = [[0] + [dp[s][k] for k in range(i+1)] for s in range(i+1)] + [[0 for k in range(i+2)]]\n    for s in range(i+1):\n        for k in range(i+1):\n            if not dp[s][k]:\n                continue\n            #auto\n            if k!=0:\n                ndp[s+k][0] += (dp[s][k] * g2[k] % mod) * pow_2[k-1] % mod\n                ndp[s+k][0] %= mod\n\n    dp = ndp\n\nres = 0\nfor s in range(n+1):\n    for k in range(1,n+1):\n        res += (pow_2[k-1] * g1[s+k] % mod) * (dp[s][k] * g2[k] % mod) % mod\n        res %= mod\n\nprint(res)\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "n = int(input())\nb = list(map(int, input().split(' ')))\ne = [[-1] * (n+1) for _ in range(2048)]\n \nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n \nfor v in range(1, 2048):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\tif j != -1:\n\t\t\th = e[v][j+1]\n\t\telse:\n\t\t\th = -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n \na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\tif s > 0:\n\t\t\ttemp = a[s-1]+1\n\t\telse :\n\t\t\ttemp = 1\n\t\ta[e] = min(a[e], temp)\nprint(a[n-1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "d4i=[0,-1,0,1]\nd4j=[-1,0,1,0]\n\ndef main():\n    \n    n,m,k=readIntArr()\n    horizontalEdges=[] # [i,j] represents [i,j] to [i,j+1]\n    for _ in range(n):\n        horizontalEdges.append(readIntArr())\n    verticalEdges=[] # [i,j] represents [i,j] to [i+1,j]\n    for _ in range(n-1):\n        verticalEdges.append(readIntArr())\n    \n    if k%2==1: # impossible\n        ans=makeArr(-1,[n,m])\n    else:\n        dp=makeArr(inf,[n,m,k//2+1]) # dp[i][j][nMoves] is the minimum possible boredom\n        for i in range(n):\n            for j in range(m):\n                dp[i][j][0]=0\n        for nM in range(1,k//2+1): # nM is nMoves\n            for i in range(n):\n                for j in range(m):\n                    # move right\n                    if j+1<m:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i][j+1][nM-1]+horizontalEdges[i][j])\n                    # move left\n                    if j-1>=0:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i][j-1][nM-1]+horizontalEdges[i][j-1])\n                    # move down\n                    if i+1<n:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i+1][j][nM-1]+verticalEdges[i][j])\n                    # move up\n                    if i-1>=0:\n                        dp[i][j][nM]=min(dp[i][j][nM],\n                                         dp[i-1][j][nM-1]+verticalEdges[i-1][j])\n        ans=makeArr(0,[n,m])\n        for i in range(n):\n            for j in range(m):\n                ans[i][j]=dp[i][j][k//2]*2\n    \n    multiLineArrayOfArraysPrint(ans)\n    \n    return\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n \ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n\ndef makeArr(defaultVal,dimensionArr): # eg. makeArr(0,[n,m])\n    dv=defaultVal;da=dimensionArr\n    if len(da)==1:return [dv for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(x,y):\n    print('? {} {}'.format(x,y))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\n# MOD=10**9+7\nMOD=998244353\n \n \nfor _abc in range(1):\n    main()", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "#   Author: yumtam\n#   Created at: 2021-05-02 23:39\n\ndef is_square(x):\n    sq = int(x**0.5)\n    return sq * sq == x\n\nfor _ in range(int(input())):\n    n = int(input())\n\n    if ((n % 2 == 0 and is_square(n//2))\n            or (n % 4 == 0 and is_square(n//4))):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "complexity": "constant", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "N, K = map(int, input().split())\nif N == K:\n    print(\"0\"*N)\nelif K == 1:\n    print(\"0\"*(N-1) + \"1\")\nelif K == 3:\n    print(\"1\" + \"0\"*(N-4) + \"101\")\nelse:\n    res = [\"0\"]*N\n    for i in range(0, N, N//2-K//2+1):\n        res[i] = \"1\"\n    print(''.join(res))", "complexity": "linear", "problem": "1159_D", "from": "CODEFORCES", "tags": "brute force,greedy,constructive algorithms,math,strings"}
{"src": "from sys import stdout\n\nn = int(input())\n\nif n % 4 == 2:\n    print('!', -1)\n    exit(0)\n\nl = 1\nr = l + n // 2\n\nmemo = [-1] * (n + 1)\n\ndef check(i):\n    if memo[i] == -1:\n        print('?', i)\n        stdout.flush()\n\n        memo[i] = int(input())\n\n    return memo[i]\n\nwhile r >= l:\n    a = check(l)\n    b = check(l + n // 2)\n    \n    if a == b:\n        print('!', l)\n        exit(0)\n\n    mid = (l + r) >> 1\n\n    c = check(mid)\n    d = check(mid + n // 2)\n\n    if c == d:\n        print('!', mid)\n        exit(0)\n\n    if (a < b and c < d) or (a > b and c > d):\n        l = mid + 1\n\n    else:\n        r = mid\n\n    \n\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "def binary_search(n, k):\n    left = -1\n    right = n\n    while left < right - 1:\n        middle = (left + right) // 2\n        if middle % 2 != 0:\n            s = (1 + middle) * (middle // 2) + ((1 + middle) // 2)\n        else:\n            s = (1 + middle) * (middle // 2)\n        if s - (n - middle) >= k:\n            right = middle\n        else:\n            left = middle\n    return right\n\n\nn, k = map(int, input().split())\ni = 1\ncount = 0\nprint(n - binary_search(n, k))", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "# Fonte https://cs.stackexchange.com/questions/29508/finding-the-max-xor-of-two-numbers-in-an-interval-can-we-do-better-than-quadrat\nl, r = [int(x) for x in input().split()]\n\nq = l ^ r\na = 1\nwhile q:\n    q //=2\n    a <<= 1\nprint(a-1)\n\n \t \t\t\t \t \t\t\t    \t \t\t\t \t\t\t \t\t \t\t", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n = int(input())\nmod = 10**9+7\ndp = [0]*(n+1)\ndp[0] = 1\nfor i in range(n):\n    nx = [0]*(n+1)\n    s = str(input())\n    if s == 'f':\n        nx[0] = 0\n        for j in range(1, n+1):\n            nx[j] = dp[j-1]\n            nx[j] %= mod\n    else:\n        nx[n] = dp[n]\n        for j in reversed(range(n)):\n            nx[j] = nx[j+1]\n            nx[j] += dp[j]\n            nx[j] %= mod\n    if i != n-1:\n        dp = nx\nprint(sum(dp)%mod)\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "#n=int(input())\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\ndef next(k,a):\n    i=k+1\n    while a[i]!=1: i+=1\n    return i\n\nans=[0]*(m+1)\n\nk=-1\nk=next(k,b)\nans[1]=k\nfor i in range(2,m+1):\n    kk=next(k,b)\n    for j in range(k+1,kk):\n        if a[j]-a[k]<=a[kk]-a[j]:\n            ans[i-1]+=1\n        else:\n            ans[i]+=1\n    k=kk\n    \n\nans[m]+=(n+m-1-k)\n\nfor i in range(1,m+1):\n    print(ans[i],end=' ')\n", "complexity": "quadratic", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "n = int(input())\nprint(n, 0, 0)", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "import sys\n\nn, m, k = list(map(int, sys.stdin.readline().strip().split()))\na = list(map(int, sys.stdin.readline().strip().split()))\nb = [0] * (n+1)\nfor i in range (1, n+1):\n    b[i] = b[i-1] + m * a[i-1] - k\nM = [10 ** 20] * m\nans = 0\nfor i in range (0, n+1):\n    M[i % m] = min([M[i % m], b[i]])\n    for j in range (0, m):\n        if i > j:\n            ans = max([ans, b[i]-M[j]-k*((m*i+m-(i-j))%m)])\n    # print(j, M, ans)\nprint(ans // m)\n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "n, k= map(int, input().split())\nA = list(map(int, input().split()))\nC = [0] * 100001\n\nl = 0\nr = 0\np = 0\n\nwhile r<n and p < k:\n    C[A[r]] += 1\n    if C[A[r]] == 1:\n        p += 1\n    r += 1\nif p != k:\n    print('-1', '-1')\nelse:\n    while p == k:\n        C[A[l]] -= 1\n        if C[A[l]] == 0:\n            p -= 1\n        l +=1\n        \n    l -= 1\n    \n    print(l+1,r)", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "\nfrom sys import stdout\na, b = 0, 0\n\n\nmp = 29\n\nc, d = 0,0\n\npowers = [1]\nfor i in range(32):\n    powers.append(powers[-1]*2)\n\nqqq = 0\n\ndef get_ans(c, d):\n    global qqq\n    qqq += 1\n    a, b = 1073741823, 1073741821\n    a, b = 3, 1\n\n    print(c, d)\n\n    if (a^c) > (b^d): \n        print(1)\n        return -1\n    elif (a^c) < (b^d):\n        print(-1)\n        return 1\n    print(0)\n    return 0\n\ndef get_ans(c, d):\n    print('? {} {}'.format(c, d))\n    stdout.flush()\n    return -int(input())\n\nq = get_ans(0, 0)\n\nfor i in range(mp+1):\n    cp = mp - i\n    c += powers[cp]\n    d += powers[cp]\n    #print('cp, q', cp, q)\n    if q == 0:\n        continue\n    t = get_ans(c, d)\n    #print('t', t)\n\n    if t != q:\n    #    print('t != q')\n    #    print(a, b,c,d)\n        if t == 1:\n            a += powers[cp]\n            c -= powers[cp]\n        elif t == -1:\n            b += powers[cp]\n            d -= powers[cp]\n        q = get_ans(c, d)\n\n    #print(a, b, c, d)\n\n#print('qwe', a, b, c, d)\n\n\nfor i in range(mp+1):\n    cp = mp - i\n    #print(c, powers[cp], d)\n    if c & powers[cp] > 0 and d & powers[cp] > 0:\n        c -= powers[cp]\n        t = get_ans(c, d)\n\n        if t < 0:\n            a += powers[cp]\n            b += powers[cp]\n\n        c += powers[cp]\n\nprint('!', a, b)\n\n\n", "complexity": "logn", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "# qumeric\nn, m = map(int, input().split())\na = [int(input(), 2) for _ in range(n)]\n\ns = t = 0\nfor x in a:\n    t |= s & x\n    s |= x\nprint((\"YES\", \"NO\")[all(x & s & ~t for x in a)])\n", "complexity": "quadratic", "problem": "0985_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def A(n):\n\treturn (4**n-1)//3\n\nL = 31\n\nT = int(input())\nfor _ in range(T):\n\tn,k = [int(_) for _ in input().split()]\n\n\tif n > L:\n\t\tprint(\"YES\",n-1)\n\t\tcontinue\n\n\tif k > A(n):\n\t\tprint(\"NO\")\n\t\tcontinue\n\n\tE = 1\n\tM = 0\n\tR = 0\n\twhile n >= 0:\n\t\tM += E\n\n\t\tI = 2*E-1\n\t\tE = 2*E+1\n\n\t\tn -= 1\n\t\tR += I*A(n)\n\n\t\tif M <= k and k <= M+R: break\n\n\tif n >= 0: print(\"YES\",n)\n\telse: print(\"NO\")\n", "complexity": "linear", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import sys\n\ninput = sys.stdin.buffer.readline\n\ndef find_pair(candidate,data,m):\n    ans = (-1,-1)\n    binary_bit = [False for i in range(1 << m)]\n    for i in data:\n        bit_tmp = 0\n        for j in range(len(i)):\n            if i[j] >= candidate: bit_tmp |= 1 << j\n        binary_bit[bit_tmp] = True\n    \n    for i in range(1 << m):\n        for j in range(1 << m):\n            if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]:\n                ans = i , j\n                break\n    return ans\n\ndef backtracking(candidate,ans,data):\n    idx_i = -1 ; idx_j = -1\n    for i in range(len(data)):\n        bit_tmp = 0\n        for j in range(len(data[i])):\n            if data[i][j] >= candidate: bit_tmp |= 1 << j\n        if bit_tmp == ans[0]: idx_i = i\n        if bit_tmp == ans[1]: idx_j = i\n\n    print(str(idx_i + 1) + \" \" + str(idx_j + 1))\n\ndef main():\n    n , m = [int(i) for i in input().split()]\n    data = [[int(i) for i in input().split()] for i in range(n)]\n    a = 0 ; b = 10**9 + 7\n    ans = (-1,-1)\n    candidate = -1\n    while a <= b:\n        mid = (a + b)//2\n        bin_ans = find_pair(mid,data,m)\n        if bin_ans[0] != -1 and bin_ans[1] != -1:\n            ans = bin_ans\n            candidate = mid\n            a = mid + 1\n        else:\n            b = mid - 1\n    backtracking(candidate,ans,data)\n\nmain()\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "#------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n#-------------------game starts now----------------------------------------------------\nn,m=map(int,input().split())\ns=0\ne=n-1\nfor i in range(n//2):\n    for j in range(m):\n        print(s+1,j+1)\n        print(e+1,m-j)\n    s+=1\n    e-=1\nif n%2==1:\n    s=n//2\n    for j in range(m//2):\n            print(s+1,j+1)\n            print(s+1,m-j)\n    if m%2==1:\n            print(s+1,m//2+1)", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "n = int(input())\ns = input()\nt = 0\nfor i in s:\n    if i == '+':\n        t += 1\n    else:\n        t = max(t - 1, 0)\n\nprint(max(t, 0))\n", "complexity": "linear", "problem": "1159_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n,k = map(int,input().split())\na = list(map(int,input().split()))\np = sorted(a)\np = p[-k:]\ns = sum(p)\nprint(s)\nidx = 0\ni = 0\ncount = 0\nans = []\nwhile len(ans)<k-1:\n    idx+=1\n    count+=1\n    if a[i] in p:\n        p.remove(a[i])\n        ans.append(count)\n        count = 0\n    i+=1\nfor i in ans:\n    print(i,end = \" \")\nprint(n-idx)\n        \n", "complexity": "nlogn", "problem": "1006_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "n, p=map(int, input().split())\narr=list(map(int, input().split()))\nsu=0\nfor i in range(n):\n\tsu+=arr[i]\nmaxi, f=0, 0\nfor i in range(n-1):\n\tf+=arr[i]\n\tmaxi=max(maxi, f%p+(su-f)%p)\nprint(maxi)", "complexity": "linear", "problem": "0958_C1", "from": "CODEFORCES", "tags": "brute force"}
{"src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nQ, = getIntList()\nfor _ in range(Q):\n    N, M, K  = getIntList()\n    if max(N,M) >K:\n        print(-1)\n        continue\n    r = K\n    if N%2!= K%2:\n        r-=1\n    if M%2!= K%2:\n        r-=1\n    print(r)\n\n\n\n\n\n\n", "complexity": "constant", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "n=int(input())\na=list(map(int,input().split()))\na.sort()\nlose=False\npair=False\nfor i in range(n-1):\n  if a[i]==a[i+1]==0:\n    lose=True\n  if a[i]==a[i+1]:\n    if pair:\n      lose=True\n    pair=True\n    if i>=1:\n      if a[i]==a[i-1]+1:\n        lose=True\nif lose:\n  print(\"cslnb\")\nelse:\n  eventual=n*(n-1)//2\n  curr=sum(a)\n  if (curr-eventual)%2==0:\n    print(\"cslnb\")\n  else:\n    print(\"sjfnb\")\n", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "n, k = map(int, input().split())\nnums = list(map(int, input().split()))\ncounts = [{} for _ in range(11)]\nfor n in nums:\n    a = n\n    for i in range(11):\n        r = a % k\n        try:\n            counts[i][r] += 1\n        except KeyError:\n            counts[i][r] = 1\n        a *= 10\nres = 0\nfor i in nums:\n    wo = str(i)\n    le = len(wo)\n    mimo = (k-(i % k)) % k\n    if mimo in counts[le]:\n        res += counts[le][mimo]\n        if int(wo+wo) % k == 0:\n            res -= 1\nprint(res)", "complexity": "nlogn", "problem": "1029_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import sys\n\ndef ask(x):\n    print('? %d'%x)\n    sys.stdout.flush()\n    x=int(input())\n    return x\n\nn=int(input())\nt=n//2\nif t&1:\n    print('! -1')\n    sys.stdout.flush()\n    sys.exit()\nl=1\nr=n\nwhile l<r:\n    mid=(l+r)>>1\n    if ask(mid)>=ask((mid+t-1)%n+1):\n        r=mid\n    else:\n        l=mid+1\nprint('! %d'%l)\nsys.stdout.flush()\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "from math import log2\nimport sys\nout = sys.stdout\nn = int(input())\nif n == 3:\n    print(1, 1, 3)\nelse:\n    tmp = n\n    current = 1\n    while n != 1:\n        if n % 2 != 0:\n            z = (n//2) + 1\n        else:\n            z = n//2\n        for i in range(z):\n            out.write(str(current) + ' ')\n        n -= z\n        current *= 2\n    step = int(log2(tmp))\n    if tmp % 2**(step - 1) == 0:\n        out.write(str(tmp))\n    else:\n        q = 2**(step - 1)\n        ans = 0\n        for i in range(1, 1000):\n            if q*i <= tmp:\n                ans = max(ans, q*i)\n            else:\n                break\n        out.write(str(ans))", "complexity": "nlogn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "from math import gcd\nimport sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dd\nm=int(input())\nd=dd(int)\nl=[]\nfor i in range(m):\n    s=input().split()[0]\n    a=0\n    b=0\n    c=0\n    n=len(s)\n    ind=0\n    for i in range(1,n):\n        if(s[i]=='+'):\n            ind=i+1\n            break\n        a=a*10+int(s[i])\n    for i in range(ind,n):\n        if(s[i]==')'):\n            ind1=i+2\n            break\n        b=b*10+int(s[i])\n    for i in range(ind1,n):\n        c=c*10+int(s[i])\n    a=a+b\n    g=gcd(a,c)\n    a=a//g\n    c=c//g\n    d[(a,c)]+=1\n    l.append((a,c))\nfor i in l:\n    print(d[i],end=\" \")\n", "complexity": "linear", "problem": "0958_D1", "from": "CODEFORCES", "tags": "expression parsing,math"}
{"src": "a = input()\nb = input()\nl = a.count(\"+\")-a.count(\"-\")\nk = b.count(\"?\")\nif k==0:\n    if (b.count(\"+\")-b.count(\"-\"))==l:\n        print(1)\n    else:\n        print(0)\nelse:\n    n=2**k\n    r=k\n    c=[]\n    t=0\n    while r>=0:\n        c.append(r-t)\n        t+=1\n        r-=1\n    import math\n    d=[]\n    for i in range(k+1):\n        d.append((math.factorial(k))//(math.factorial(i)*math.factorial(k-i)))\n    f = b.count(\"+\")-b.count(\"-\")\n    if l-f in c:\n        print((d[c.index(l-f)])/sum(d))\n    else:\n        print(0)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "n = int(input())\na = tuple(map(int, input().split()))\nif n * 2 > sum(a) + 2:\n\tprint(\"NO\")\nelse:\n\tn1 = []\n\ton = []\n\tfor i in range(n):\n\t\tif a[i] != 1:\n\t\t\tn1.append(i)\n\t\telse:\n\t\t\ton.append(i)\n\tprint(\"YES\", len(n1) + min(2, len(on)) - 1)\n\tprint(n - 1)\n\tn1it = iter(n1)\n\tnext(n1it)\n\tfor v, u in zip(n1, n1it):\n\t\tprint(v + 1, u + 1)\n\tif on:\n\t\tprint(on.pop() + 1, n1[-1] + 1)\n\tif on:\n\t\tprint(on.pop() + 1, n1[0] + 1)\n\ton = iter(on)\n\tfor n11 in n1:\n\t\tfor i in range(a[n11] - 2):\n\t\t\ttry:\n\t\t\t\tprint(n11 + 1, next(on) + 1)\n\t\t\texcept StopIteration:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tcontinue\n\t\tbreak\n", "complexity": "linear", "problem": "1082_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "n,m = map(int, input().split())\na = []\nfor i in range(n):\n    s = input()\n    a.append(s)\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == '.':\n            continue\n        if i >= 2 and j >= 2:\n            if a[i-2][j-2] == '#' and a[i-2][j-1] == '#' and a[i-2][j] == '#' \\\n                    and a[i-1][j] == '#' and a[i-1][j-2] == '#' and a[i][j-1] == '#' and a[i][j-2] == '#':\n                continue\n        if i >= 1 and i <= n-2 and j >= 2 and a[i-1][j-2] == '#' and a[i-1][j-1] == '#' and a[i-1][j] == '#' \\\n                and a[i][j-2] == '#' and a[i+1][j-2] == '#' and a[i+1][j-1] == '#' and a[i+1][j] == '#':\n            continue\n        if i <= n-3 and j >= 2 and a[i][j-1] == '#' and a[i][j-2] == '#' and a[i+1][j] == '#' \\\n                and a[i+1][j-2] == '#' and a[i+2][j] == '#' and a[i+2][j-1] == '#' and a[i+2][j-2] == '#':\n            continue\n        if i <= n-3 and j >= 1 and j <= m-2 and a[i][j-1] == '#' and a[i][j+1] == '#' and a[i+1][j-1] == '#' \\\n                and a[i+1][j+1] == '#' and a[i+2][j] == '#' and a[i+2][j-1] == '#' and a[i+2][j+1] == '#':\n            continue\n        if i <= n-3 and j <= m-3 and a[i][j+1] == '#' and a[i][j+2] == '#' and a[i+1][j] == '#' \\\n                and a[i+1][j+2] == '#' and a[i+2][j] == '#' and a[i+2][j+1] == '#' and a[i+2][j+2] == '#':\n            continue\n        if i <= n-2 and i >= 1 and j <= m-3 and a[i-1][j] == '#' and a[i-1][j+1] == '#' and a[i-1][j+2] == '#' \\\n                and a[i][j+2] == '#' and a[i+1][j] == '#' and a[i+1][j+1] == '#' and a[i+1][j+2] == '#':\n            continue\n        if i >= 2 and j <= m-3 and a[i-2][j] == '#' and a[i-2][j+1] == '#' and a[i-2][j+2] == '#' \\\n                and a[i-1][j] == '#' and a[i-1][j+2] == '#' and a[i][j+1] == '#' and a[i][j+2] == '#':\n            continue\n        if i >= 2 and j <= m-2 and j >= 1 and a[i-2][j-1] == '#' and a[i-2][j] == '#' and a[i-2][j+1] == '#' \\\n                and a[i-1][j-1] == '#' and a[i-1][j+1] == '#' and a[i][j-1] == '#' and a[i][j+1] == '#':\n            continue\n        print('NO')\n        exit()\nprint('YES')", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\nfor _ in range(n):\n    l, r = map(int, input().split())\n    if (l - r) % 2 == 1:\n        if l % 2:\n            print((r-l+1)//2)\n        else:\n            print(-((r-l+1)//2))\n    else:\n        ans = 0\n        if l % 2:\n            ans = ans + (r-l)//2\n        else:\n            ans = ans + -(r-l)//2\n        if r % 2:\n            ans = ans - r\n        else:\n            ans = ans + r\n        print(ans)", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\ninput = sys.stdin.readline\n \nn = int(input())\nli = []\n \nfor i in range(n):\n    x,w = map(int,input().split())\n    li.append((x-w,x+w))\n \nli.sort(key = lambda x: x[1])\n \na = -10 ** 9\nans = 0\n \nfor i in range(n):\n     if a <= li[i][0]:\n         ans += 1\n         a = li[i][1]\n \nprint(ans)", "complexity": "nlogn", "problem": "0528_B", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n,s = [int(x) for x in input().split()]\nv=[ [] ]\nfor i in range(n):\n\tv.append([])\n\t\nfor i in range(n-1):\n\ta, b =[int(x) for x in input().split()]\n\tv[a].append(b)\n\tv[b].append(a)\n\nans =0\nfor i in range(1,n+1):\n\tif len(v[i])==1:\n\t\tans+=1\n\t\nprint(2*s/ans)\n", "complexity": "linear", "problem": "1086_B", "from": "CODEFORCES", "tags": "greedy,implementation,trees"}
{"src": "n, m = map(int, input().split())\narr = list(map(int, input().split()))\nd = {}\ni = 1\nfor x in arr:\n\tif len(d) == m:\n\t\tbreak\n\td[x] = i\n\ti += 1\nif len(d) == m:\n\tprint(min(d.values()), max(d.values()))\nelse:\n\tprint(-1,-1)\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "import math as mt\nimport sys\ninput=sys.stdin.readline\nI=lambda:list(map(int,input().split()))\nn,m=I()\na=[I() for i in range(n)]\nans=[]\nlo=0\nhi=10**9\ndef vanguda(mid: int) -> bool:\n    global ans\n    f={}\n    for i in range(n):\n        bi=0\n        for j in range(m):\n            if a[i][j]>=mid:\n                bi+=1\n            bi<<=1\n        f[bi>>1]=i\n    for aa,bb in f.items():\n        for cc,dd in f.items():\n            if aa|cc==(2**m-1):\n                ans =bb+1,dd+1\n                return True\n    return False\n\nwhile lo<=hi:\n\tmid=(lo+hi)//2\n\tif vanguda(mid):\n\t\tlo=mid+1\n\telse:\n\t\thi=mid-1\nprint(*ans)\n\n\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "n,k=list(map(int,input().split()))\narr=list(map(int,input().split()))\nnewarr=[0]\n\nfor num in arr:\n  newarr+=[newarr[-1]^num]\ndic={}\nfor num in newarr:\n  x=(min(num,2**k-1-num),max(num,2**k-1-num))\n  if x in dic:\n    dic[x]+=1\n  else:\n    dic[x]=1\nans=0\nfor elem in dic:\n  m=dic[elem]\n  half=m//2\n  ans+=half*(half-1)/2\n  half=m-half\n  ans+=half*(half-1)/2\nans=n*(n+1)/2-ans\nprint(int(ans))\n  \n    \n", "complexity": "linear", "problem": "1054_D", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import sys\n\nn = int(sys.stdin.readline())\na = list(map(int, sys.stdin.readline().split(' ')))\nArray = [a]\n \nfor i in range(n - 1):\n    aux = []\n    for j in range(1, len(Array[-1])):\n        aux.append(Array[-1][j-1] ^ Array[-1][j])\n    Array.append(aux)\n \nfor j in range(1, len(Array)):\n    for k in range(len(Array[j])):\n        Array[j][k] = max(Array[j][k], Array[j-1][k], Array[j - 1][k + 1])\n \nq = int(sys.stdin.readline())\nfor i in range(q):\n    l, r = map(int, sys.stdin.readline().split(' '))\n    sys.stdout.write(str(Array[r - l][l - 1]) + '\\n')\n \t\t\t\t\t \t \t\t\t  \t\t  \t\t\t \t\t  \t  \t", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "def maxXORInRange(L, R): \n    LXR = L ^ R \n    msbPos = 0\n    while(LXR): \n      \n        msbPos += 1\n        LXR >>= 1\n    maxXOR, two = 0, 1\n      \n    while (msbPos): \n      \n        maxXOR += two \n        two <<= 1\n        msbPos -= 1\n  \n    return maxXOR \nL, R = map(int,input().split())\nprint(maxXORInRange(L, R)) \n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n = int(input())\np = list(map(lambda x: int(x) - 1, input().split()))\n\nvis = [False] * n\nodd = 0\nfor x in range(n):\n    if vis[x]:\n        continue\n    odd ^= 1\n    while not vis[x]:\n        odd ^= 1\n        vis[x] = True\n        x = p[x]\n\nprint('Petr' if (n + odd) % 2 == 0 else 'Um_nik')\n", "complexity": "nlogn", "problem": "0986_B", "from": "CODEFORCES", "tags": "combinatorics,math"}
{"src": "x,k=map(int,input().split())\nm=10**9+7\nprint((x*pow(2,k+1,m) -pow(2,k,m) +1) %(m)) if x >0 else print(0)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import math\n\nn=int(input())\nk=1\nwhile(n > 9*k*(10**(k-1))):\n    n = n - 9*k*(10**(k-1))\n    k = k + 1\nremainder = n%k\nif remainder == 0:\n    remainder = k\nif k==1:\n    quoteint = math.ceil(n/k)\nelse:\n    adder = \"9\"*(k-1)\n    adder = int(adder)\n    quoteint = math.ceil(n/k) + adder\nprint(str(quoteint)[remainder-1])\n\n\n\n\n    \n    \n    \n        \n        \n        \n    \n\n        \n        \n        \n        \n        \n        \n    \n\n\n                        \n                        \n                    \n        \n \n        \n  \n    \n    \n                \n                \n                \n            \n            \n     \n                \n    \n            \n            \n        \n    \n  \n\n\n    \n   \n        \n\n  \n            \n  \n    \n    \n    \n\n\n\n            \n            \n            \n    \n    \n            \n   \n    \n\n    \n\n            \n            \n    \n    \n\n    \n    \n\n        \n\n\n    \n\n    \n    \n    \n\n\n\n\n\n\n\n\n\n            \n            \n        \n        \n        \n        \n    \n        ", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "d = {\"purple\":\"Power\", \"green\":\"Time\", \"blue\":\"Space\", \"orange\":\"Soul\", \"red\":\"Reality\", \"yellow\":\"Mind\"}\ns = set()\nn = int(input())\nfor _ in range(n):\n\tw = input()\n\ts.add(w)\nprint(6 - n)\nfor (key, value) in d.items():\n\tif key not in s:\n\t\tprint(value)", "complexity": "constant", "problem": "0987_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "a = int(input())\nlister = input().split()\nlister = [int(i) for i in lister]\n\nans = dict()\n\t\ndef findans(n):\n\tif n in ans:\n\t\treturn ans[n]\n\tmod = n%lister[n]\n\tok = True\n\tif n + lister[n] >= a and n - lister[n] < 0:\n\t\tok = False\n\telse:\n\t\tfor i in range(mod, a, lister[n]):\n\t\t\tif i != n and lister[i] > lister[n]:\n\t\t\t\tok = ok and findans(i) \n\t\t\t\t\n\t\tok = not(ok)\n\t\t\n\tans[n] = ok\n\treturn ok\n\t\nfor i in range(len(lister)):\n\tfindans(i)\n\t\nlevel = []\nfor i in range(a):\n\tif ans[i] == True:\n\t\tlevel.append('A')\n\telse:\n\t\tlevel.append('B')\n\t\t\nprint(''.join(level))", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "# cook your dish here\ndef power(x, y, p) : \n    res = 1     # Initialize result \n  \n    # Update x if it is more \n    # than or equal to p \n    x = x % p  \n  \n    while (y > 0) : \n          \n        # If y is odd, multiply \n        # x with result \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n  \n        # y must be even now \n        y = y >> 1      # y = y/2 \n        x = (x * x) % p \n          \n    return res \n    \nd,n=map(int,input().split())\nans =power(2,n+1,1000000007);\nans1=power(2,n,1000000007);\nif(d==0):\n    print(0)\nelse:\n    print(((ans*(d%1000000007))%1000000007 - ans1 +1)%1000000007)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\nl = [*map(int, input().split())]\n\np = [0] * n\nfor i in range(n): p[l[i] - 1] = i\n\nres = ['?'] * n\n\nfor e in range(n, 0, -1):\n    i = p[e - 1]\n    res[i] = 'B'\n    for j in range(i % e, n, e):\n        if i != j and l[i] <= l[j] and res[j] == 'B':\n            res[i] = 'A'\n            break \nprint(''.join(res))", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nimport bisect\nT = int(input())\nr = 1\n \nprime = [2]\n \nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue \n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0: \n            flag = True \n            break\n    if not flag:  prime.append(i)\n \n \n#print(prime)\n \n \ndef primefactor(num):\n \n    index = 0\n    output = []\n \n    while num>=prime[index]**2:\n \n        times = 0\n        while num%prime[index]==0:\n            num = num // prime[index]\n            times += 1\n        if times&1:  output.append(prime[index])\n        index += 1 \n \n    if num>1: output.append(num)\n \n \n    return tuple(output)\n \n \n \n \n \nwhile r<=T:\n    n,k = map(int,input().split())\n    \n \n    arr = list(map(int,input().split()))\n \n#    arr = [5*i+1 for i in range(n)]\n#    print(arr)\n \n \n    seg = 1\n    fact = {}\n    left = [[0 for j in range(k+1)] for i in range(n)]\n    dp = [[300000 for j in range(k+1)] for i in range(n)]\n \n    stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:\n            bisect.insort(stack,fact[factor]+1)\n            \n        fact[factor] = i\n \n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n \n \n \n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):\n                l = left[i][t]\n                if l>0:\n                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])\n                else:\n                    dp[i][j] = 1\n \n \n \n    \n \n \n \n#    print(left)\n#    print(dp)\n    print(dp[-1][-1])   \n \n    \n    \n  \n \n    \n \n \n \n    r += 1\n", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import sys\ninput = sys.stdin.readline\nimport math\nimport copy\nimport collections\nfrom collections import deque\nimport heapq\nimport itertools\nfrom collections import defaultdict\nfrom collections import Counter\n\nn,k = map(int,input().split())\nmod = 998244353\ndp = [[[0 for z in range(2)] for j in range(k+1)] for i in range(n)]\n# z= 0: bb, 1:bw, 2:wb, 3=ww\ndp[0][1][0] = 1\nif k>=2:\n    dp[0][2][1] = 1\nfor i in range(1,n):\n    for j in range(1,k+1):\n        dp[i][j][0] += dp[i-1][j-1][0]+dp[i-1][j][0]+2*dp[i-1][j][1]\n        dp[i][j][0]%=mod\n        if j-2>=0:\n            dp[i][j][1] += 2*dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i-1][j-2][1]\n        else:\n            dp[i][j][1] += dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i][j-1][0]\n        dp[i][j][1]%=mod\nans = 0\nfor z in range(2):\n    ans+=dp[n-1][k][z]\nans*=2\nprint(ans%mod)\n# for row in dp:\n#     print(row)", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import sys\ninput = sys.stdin.buffer.readline\n \nn,k=map(int,input().split())\narr=[int(x) for x in input().split()]\n \nx=0\ndp=[]\nfor i in range(n):\n    x=x+arr[i]\n    dp.append(x)\n \nans=0\nfor i in range(n):\n    for j in range(i+k-1,n):\n        ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1))\nprint(ans) ", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "n=int(input())\np=[0,0]+list(map(int,input().split()))\nd=[0]*(n+1)\nfor i in range(n,1,-1):\n    if d[i]==0:\n        d[i]=1\n    d[p[i]]+=d[i]\nif n==1:\n    d[1]=1\nd=d[1:]\nd.sort()\nprint(*d)", "complexity": "linear", "problem": "1056_D", "from": "CODEFORCES", "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"}
{"src": "#CF-E-00\nimport sys\nfrom collections import deque, defaultdict\ninput = lambda: sys.stdin.readline().rstrip()\ndef topological_sort(In, Out):\n    dq, L = deque(), []\n    for i, I in enumerate(In):\n        if not I:\n            dq.append(i)\n    while dq:\n        v = dq.popleft()\n        L.append(v)\n        for w in Out[v]:\n            In[w].remove(v)\n            if not In[w]:\n                dq.append(w)\n    if len(L) < len(In):\n        return False\n    return L\n\ndef main():\n    n, m, k = map(int,input().split())  #k: length of following inputs\n\n    def edges(s):\n        Ans = set()\n        for i in range(2**k):\n            ans = [s[j] if i>>j&1 else '_' for j in range(k)]\n            Ans.add(''.join(ans))\n        return Ans\n\n    D = defaultdict(lambda : -1)\n    for i in range(n):\n        D[input()] = i\n\n    flag = 1\n    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]\n    for _ in range(m):\n        S, t = input().split()\n        t = int(t)\n\n        for e in edges(S):\n            if D[e]+1:\n                Out[t-1].add(D[e])\n                In[D[e]].add(t-1)\n        if t-1 not in Out[t-1]:\n            flag = 0\n            break\n        else:\n            Out[t-1].remove(t-1)\n            In[t-1].remove(t-1)\n\n    T = topological_sort(In, Out)\n    if flag and T:\n        print('YES')\n        print(*[t+1 for t in T], sep = ' ')\n    else:\n        print('NO')\n        \nmain()", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n########################################################################\n\nn=ri()\na=ris()\nfreq=Counter(a)\nans=0\nfor x in freq:\n  for i in range(32):\n    c=(1<<i)-x\n    if c not in freq:\n      continue\n    if c==x and freq[x]==1:\n      continue\n    break\n  else:\n    ans+=freq[x]\n\nprint(ans)\n", "complexity": "nlogn", "problem": "1005_C", "from": "CODEFORCES", "tags": "brute force,greedy,implementation"}
{"src": "n = int(input())\nif n == 0:\n    print(0)\nelse:\n    if n % 2 == 0:\n        print(n+1) \n    else:\n        print((n+1)//2)\n\n \t \t\t  \t  \t \t\t\t\t\t     \t\t\t\t \t \t\t", "complexity": "constant", "problem": "0979_A", "from": "CODEFORCES", "tags": "math"}
{"src": "pw = [1, 4]\nfor i in range(2, 32):\n    pw.append(pw[i - 1] * 4)\nt = int(input())\nfor cas in range(t):\n    n, k = map(int, input().split())\n    last = 1\n    path = 1\n    ans = n\n    i = 0\n    while True:\n        if((pw[i + 1] - 1) // 3 > k):\n            ans -= i\n            last = k - (pw[i] - 1) // 3\n            break\n        i = i + 1\n        path *= 2\n    sp = path * 2 - 1\n    if((ans < 0) or ((ans == 0) and (last > 0))):\n        print(\"No\")\n        continue\n    sq = path * path - sp\n    if (ans == 1) and (last > sq) and (last < sp):\n        print(\"No\")\n        continue\n    elif (ans == 1) and (last >= sp):\n        ans = ans - 1\n    print(\"Yes\", ans)\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "n=int(input())\n\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\n\na=[[l[i]+r[i],i] for i in range(n)]\na.sort()\n#print(a)\ncandies=[0 for i in range(n)]\n\nif(a[0][0] != 0):\n    \n    print('NO')\n    exit()\nelse:\n    candies[a[0][1]] = n - a[0][0]\n\nfor i in range(1,n):\n    if(a[i][0] != a[i-1][0] and a[i][0]!=i):\n        print('NO')\n #       print(i,a[i])\n        exit()\n  #  print(a[i][1],n-a[i][0],i)\n    candies[a[i][1]] = n - a[i][0]\n#print(candies)\nfor i in range(n):\n    l1=0\n    r1=0\n    for j in range(i):\n        if(candies[j]>candies[i]):\n            l1+=1\n    for j in range(i+1,n):\n        if(candies[j]>candies[i]):\n            r1+=1\n #   print(l1,r1)\n    if(l1 != l[i] or r1 != r[i]):\n        print('NO')\n        exit()\nprint('YES')\nprint(*candies)\n\n", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "\n_=input()\nn=input()\nnum=int(n)\n\nlist_n=list(n)\nlist_n_int=list(map(int,n))\n\n\nlower=max(list_n_int)\ntotal=sum(list_n_int)\nupper=int(total/2)\n\nflag=False\nif lower == 0:\n    print(\"YES\")\nelse:\n    for i in range(lower,upper+1):\n        flag=True\n        p=0\n        temp=0\n        each=i\n        seg=total/each\n        if seg.is_integer():\n            while p < len(n):\n\n                temp+=list_n_int[p]\n                if temp < each:\n                    p+=1\n                elif temp == each:\n                    temp=0\n                    p+=1\n                else:\n                    flag=False\n                    break\n            if flag:\n                print(\"YES\")\n                break\n        else:\n            flag=False\n    if not flag:\n        print(\"NO\")\n", "complexity": "quadratic", "problem": "1030_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from collections import namedtuple\nvertex = namedtuple('vertex', ['degree', 'id'])\na, b, c = [], [], 0\n\nn = int(input())\nrr = list(map(int, input().split()))\n\nfor i in range(n):\n    if rr[i] > 1:\n        a.append(vertex(rr[i], i + 1))\n    else:\n        b.append(vertex(rr[i], i + 1))\n    c += rr[i]\n\nif c < (n - 1)*2:\n    print('NO')\nelse:\n    print('YES', len(a) - 1 + min(2, len(b)))\n    print(n - 1)\n    for i in range(1,len(a)):\n        print(a[i - 1].id, a[i].id)\n    if len(b) > 0:\n        print(b[0].id, a[0].id)\n    if len(b) > 1:\n        print(b[1].id, a[-1].id)\n    j, yes = 2, 0\n    for i in range(len(a)):\n        k = a[i].degree - 2\n        for t in range(k):\n            if j >= len(b):\n                yes = 1\n                break\n            print(a[i].id, b[j].id)\n            j += 1\n        if yes == 1:\n            break", "complexity": "quadratic", "problem": "1082_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "mod = 10 ** 9 + 7\nx, k = map(int, input().split())\nif x != 0:\n    print((pow(2, k + 1, mod) * x - pow(2, k, mod) + 1) % mod)\nelse:\n    print(0)\n\n        \n\n\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import os, sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    n = rint()\n    deg, edges = [0] * n, rints_2d(n - 1)\n    if n == 2:\n        exit(print(f'Yes\\n1\\n1 2'))\n\n    for u, v in edges:\n        deg[u - 1] += 1\n        deg[v - 1] += 1\n\n    ix = deg.index(max(deg))\n\n    if deg[ix] < 3 or deg.count(1) + deg.count(2) == n - 1:\n        print(f'Yes\\n{deg.count(1)}')\n\n        for i in range(n):\n            if deg[i] == 1:\n                print(i + 1, ix + 1)\n    else:\n        print('No')\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\nif __name__ == '__main__':\n    main()\n", "complexity": "linear", "problem": "0981_C", "from": "CODEFORCES", "tags": "implementation,trees"}
{"src": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nn, d, k = map(int, input().split())\nif n == 1 or n <= d:\n    ans = \"NO\"\nelif k == 1:\n    ans = \"YES\" if n == 2 and d == 1 else \"NO\"\n    e = [(1, 2)]\nelse:\n    e = [(i + 1, i + 2) for i in range(d)]\n    q = deque()\n    l, r = 1, d + 1\n    if k > 2:\n        for i in range(2, d + 1):\n            q.append((i, 2, min(i - l, r - i)))\n    ans = \"YES\"\n    for i in range(d + 2, n + 1):\n        if not q:\n            ans = \"NO\"\n            break\n        j, k0, d0 = q.popleft()\n        e.append((j, i))\n        if k0 + 1 < k:\n            q.append((j, k0 + 1, d0))\n        if d0 - 1 > 0:\n            q.append((i, 1, d0 - 1))\nprint(ans)\nif ans == \"YES\":\n    for u, v in e:\n        print(u, v)", "complexity": "quadratic", "problem": "1003_E", "from": "CODEFORCES", "tags": "constructive algorithms,graphs"}
{"src": "n=int(input())\nd={}\nfor _ in range(n):\n    a,x=map(int, input().split())\n    d[a]=x\nm=int(input())\nfor _ in range(m):\n    b,y=map(int, input().split())\n    d[b]=max(y, d.get(b,0))\nprint(sum(d.values()))\n    \n", "complexity": "nlogn", "problem": "0981_B", "from": "CODEFORCES", "tags": "sortings"}
{"src": "def main():\n    n, m = map(int, input().split())\n    a = []\n    for i in range(n):\n        s = input()\n        b = []\n        for l in s:\n            b.append(l)\n        a.append(b)\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            may = True\n            if (a[i][j - 1] == '.' or a[i][j + 1] == '.' or a[i + 1][j - 1] == '.' or a[i + 1][j + 1] == '.' or a[i + 1][j] == '.' or a[i - 1][j - 1] == '.' or a[i - 1][j + 1] == '.' or a[i - 1][j] == '.'):\n                may = False\n            if (may):\n                a[i][j - 1] = a[i][j + 1] = a[i + 1][j - 1] = a[i + 1][j + 1] = a[i + 1][j] = a[i - 1][j - 1] = a[i - 1][j + 1] = a[i - 1][j] = '?'\n    for i in range(n):\n        for j in range(m):\n            if (a[i][j] == '#'):\n                print(\"NO\")\n                return\n    print(\"YES\")\nmain()", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import math\nn, r = [int(x) for x in input().split()]\nx = [int(x) for x in input().split()]\nans = []\nfor i in range(n):\n    t = r\n    for j in range(i):\n        a = abs(x[i] - x[j])\n        if a <= 2 * r:\n            t2 = (2 * r)**2\n            t2 -= a**2\n            t2 = math.sqrt(t2) + ans[j]\n            t = max(t, t2)\n    ans.append(t)\nfor k in ans:\n    print(k)\n\t \t\t\t\t \t\t\t \t\t  \t\t\t \t\t\t\t   \t\t\t\t\t", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "a, b = map(int, input().split())\nprint(\"1\"*a)\nprint(int(\"1\" + (\"0\" * a)) - int(\"1\" * a))", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque \n\n \nn, k = map(int,input().split())\ns = input()\n\n \n \nmaxconseq = [[0 for j in range(k)] for i in range(n+1)]\nfor i in range(n):\n    if s[i]==ord('?'):\n        for j in range(k):\n            maxconseq[i][j] = maxconseq[i-1][j] + 1\n    else:\n        j = s[i]-97\n        maxconseq[i][j] = maxconseq[i-1][j] + 1\n \n \n \ndef judge(needed):\n \n    \n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n \n    effect = [[inf]*(n+1) for j in range(k)]\n \n    \n    for j in range(k):\n        for i in range(n)[::-1]:\n            if maxconseq[i][j]>=needed:\n                effect[j][i-needed+1] = i+1\n            effect[j][i] = min(effect[j][i], effect[j][i+1])\n\n\n   \n                \n             \n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index]) \n\n\n\n        minstate[state] = minimum \n   \n \n#    print(minstate) \n \n \n \n    if minstate[-1]<=n:  return True\n    return False\n \n \nfront = 0\nrear = n//k+1\n \nwhile front < rear:\n    mid = (front+rear)//2\n    flag = judge(mid)\n#    print(mid,flag)\n \n    if flag:  \n        front = mid + 1\n    else:\n        rear = mid \n \nprint(front-1)\n", "complexity": "np", "problem": "1550_E", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,strings,two pointers"}
{"src": "print('4'*1131+'\\n'+'5'*1130+'6')", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "\n\n\nn,s = map(int,input().split())\nt=[[0,0]]\nfor j in range(n):\n\n    a,b = map(int,input().split())\n\n\n    total = a*60+b\n\n\n    last = t[-1][0]*60+t[-1][1]+1\n\n    t.append([a,b])\n\n    if j==0:\n        if total>= s+1:\n            print(0,0)\n            break\n    if total-last > 2*s:\n        u = last+s\n        print(u//60, u%60)\n        break\n\n    if j==n-1:\n        x = t[-1][0]*60+t[-1][1]\n        print((x+s+1)//60 ,(x+s+1)%60 )\n        break\n\n\n    \n    \n", "complexity": "linear", "problem": "0967_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from string import digits\nfrom collections import Counter\na = input()\nb = input()\nca = Counter(a)\nl = list()\nif len(b) > len(a):\n    for i in digits[::-1]:\n        if i in ca:\n            l.extend(i * ca[i])\nelse:\n    def asd(i, s):\n        if i == len(b):\n            return True\n        if s:\n            for j in digits[::-1]:\n                if j in ca and ca[j] > 0:\n                    l.extend(j * ca[j])\n            return True\n        else:\n            for j in digits[:int(b[i])+1][::-1]:\n                if j in ca and ca[j] > 0:\n                    ca[j] -= 1\n                    l.append(j)\n                    if asd(i + 1, j != b[i]):\n                        return True\n                    ca[j] += 1\n                    l.pop()\n            return False\n    asd(0, False)\nprint(\"\".join(l))\n\n       \t\t  \t \t  \t \t \t \t \t   \t\t\t", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "d = [list(map(int, input().split())) for i in range(int(input()))]\n\ns = 0\n\nfor k in range(1, 10001):\n\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n\n    u = v = 1\n\n    for r in p: u *= r\n\n    for r in p:\n\n        v *= r\n\n        s += (u - v) * (r - 1) / r\n\nprint(s)\n\n\n\n\n# Made By Mostafa_Khaled", "complexity": "np", "problem": "0513_C", "from": "CODEFORCES", "tags": "bitmasks,probabilities"}
{"src": "\ndef func(u,v,a,l):\n    if (v**2-u**2)>=2*a*l:\n        return ((u**2+2*a*l)**(1/2)-u)/a\n    else:\n        t1=(v-u)/a\n        t2=(l-(u*t1+a*t1*t1/2))/v\n        return t1+t2\ndef efficient(v,a,w,d):\n    if 2*v*v-w*w<=2*a*d:\n        t1=v/a\n        t2=(v-w)/a\n        t3=(d-0.5*a*t1*t1-v*t2+0.5*a*t2*t2)/v\n        return t1+t2+t3\n    else:\n        bound=((2*a*d+w*w)/2)**0.5\n        t1=bound/a\n        t2=(bound-w)/a\n        t3=func(0,w,a,d)\n        return t1+t2\n        return min(t1+t2,t3)\ndef main():\n    string1=input()\n    string2=input()\n    arr1=string1.split(\" \")\n    arr2=string2.split(\" \")\n    a=int(arr1[0])\n    v=int(arr1[1])\n    l=int(arr2[0])\n    d=int(arr2[1])\n    w=int(arr2[2])\n    if 2*a*d<=w**2 or v<=w:\n        t1=func(0,v,a,l)\n        print(\"%.8f\"%(t1))\n    else:\n        t1=efficient(v,a,w,d)\n        t2=func(w,v,a,l-d)\n        print(\"%.8f\"%(t1+t2))\nmain()\n", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "def solve(a):\n    aa = sorted(a)\n    maxr = aa[0]\n    for ai in aa:\n        if ai[2] != maxr[2]:\n            if ai[1] <= maxr[1] and ai[0] >= maxr[0]:\n                return(ai[2], maxr[2])\n            if ai[1] >= maxr[1] and ai[0] <= maxr[0]:\n                return(maxr[2], ai[2])\n        if ai[1] > maxr[1]:\n            maxr = ai\n    return(-1, -1)\n\nn = int(input())\na = []\nfor i in range(n):\n    l,r = [int(s) for s in input().split()]\n    a.append((l, r, i+1))\ni,j = solve(a)\nprint(i,j)\n", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "\ndef sm(n):\n    return int(int(n*(n+1))/int(2));\ndef summ(en, st):\n    if(st <= 1):\n        return sm(en);\n    return sm(en) - sm(st-1);\n\ndef bs(n, k):\n    st = 1;\n    en = k;\n    while (st < en):\n        md = int(int((st+en)) /int(2));\n        s = summ(k,md);\n        if(s == n):\n            return k - md + 1;\n        elif (s>n):\n            st = md + 1;\n        else :\n            en = md;\n    return k - st + 2;\nn, k = input().split();\nn = int(n);\nk = int(k);\n\nif(n == 1):\n    print(0);\nelif (n <= k):\n    print(1);\nelse:\n    n -= 1;\n    k -= 1;\n    if(sm(k) < n ):\n        print(-1);\n    else:\n        print(int(bs(n,k)));\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "n = int(input())\np = [0,0] + [int(w) for w in input().split()]\n\nd = [0] * (n+1)\n\nfor i in range(n, 1, -1):\n    if d[i] == 0:\n        d[i] = 1\n    d[p[i]] += d[i]\n\nif n == 1:\n    d[1] = 1\n\nd = d[1:]\nd.sort()\n\nprint(*d)\n", "complexity": "linear", "problem": "1056_D", "from": "CODEFORCES", "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"}
{"src": "n, k = map(int, input().split())\nl = list(map(int, input().split()))\ncost = l[n - 1] - l[0]\nif k == 1:\n\tprint(cost)\nelse:\n\tdiff = [0 for _ in range(n - 1)]\n\tfor i in range(n - 1):\n\t\tdiff[i] = l[i + 1] - l[i]\n\t#print(diff)\n\tdiff = sorted(diff)\n\tdiff.reverse()\n\tprint(cost - sum(diff[:k - 1]))", "complexity": "nlogn", "problem": "1197_C", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "dict={\"Power\":\"purple\",\n      \"Time\":\"green\",\n      \"Space\":\"blue\",\n      \"Soul\":\"orange\",\n      \"Reality\":\"red\",\n      \"Mind\":\"yellow\"}\ndict1={}\nn=(int(input()))\nwhile n:\n    str=input()\n    if str==\"purple\":\n        dict1[\"Power\"]=str\n    elif str==\"green\":\n        dict1[\"Time\"]=str\n    elif str==\"blue\":\n        dict1[\"Space\"]=str\n    elif str==\"orange\":\n        dict1[\"Soul\"]=str\n    elif str==\"red\":\n        dict1[\"Reality\"]=str\n    elif str==\"yellow\":\n        dict1[\"Mind\"]=str\n    n-=1\n\nval=list(dict.keys())\nval_list=list(dict1.keys())\nl=[key for key in val if key not in val_list]\nprint(len(l))\nfor i in range(len(l)):\n    print(l[i])", "complexity": "constant", "problem": "0987_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n, l, r, x = list(map(int, input().split(\" \")))\nc = sorted(list(map(int, input().split(\" \"))))\nways = 0\n\nfor i in range(0, 2 ** n):\n    temp = 0\n    m = 10 ** 9 + 1\n    M = -1\n    for j in range(0, n):\n        if i & 1 << j:\n            temp += c[j]\n            m = min(m, c[j])\n            M = max(M, c[j])\n    if temp >= l and temp <= r and (M - m) >= x:\n        ways += 1\n\nprint(ways)\n\n\n\t\t  \t \t\t\t       \t\t \t \t\t   \t\t \t", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import sys\na,b,c=sys.stdin.readline().strip().split()\nif a==b and b==c:\n    print(0)\nelif a==b or b==c or a==c:\n    print(1)\nelse:\n    na = int(a[0])\n    nb = int(b[0])\n    nc = int(c[0])\n    if (a[1]==b[1] and a[1]==c[1]):\n        cp=[na,nb,nc]\n        cp.sort()\n        cp[0]+=2\n        cp[1]+=1\n        if (cp[0]==cp[1] and cp[1]==cp[2]):\n            print(\"0\")\n        elif (cp[0]==cp[1] or cp[1]==cp[2] or cp[0]==cp[1] or (cp[0]+1)==cp[1] or (cp[1]+1)==cp[2]):\n            print(\"1\")\n        else:\n            print(\"2\")\n    elif(a[1]==b[1]):\n        mi=min(na,nb)\n        ma=max(na,nb)\n        if (mi==(ma-1) or mi==(ma-2)):\n            print(\"1\")\n        else: print(\"2\")\n    elif(a[1]==c[1]):\n        mi=min(na,nc)\n        ma=max(na,nc)\n        if (mi==(ma-1) or mi==(ma-2)):\n            print(\"1\")\n        else: print(\"2\")\n    elif(b[1]==c[1]):\n        mi = min(nb,nc)\n        ma = max(nb,nc)\n        if (mi==(ma-1) or mi==(ma-2)):\n            print(\"1\")\n        else: print(\"2\")\n    else:\n        print(\"2\")\n", "complexity": "nlogn", "problem": "1191_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "import sys\n# from bisect import bisect_right\n# gcd\n# from fractions import gcd\n# from math import ceil, floor\n# from copy import deepcopy\n# from itertools import accumulate\n# l = ['a', 'b', 'b', 'c', 'b', 'a', 'c', 'c', 'b', 'c', 'b', 'a']\n# print(S.most_common(2))  # [('b', 5), ('c', 4)]\n# print(S.keys())  # dict_keys(['a', 'b', 'c'])\n# print(S.values())  # dict_values([3, 5, 4])\n# print(S.items())  # dict_items([('a', 3), ('b', 5), ('c', 4)])\n# from collections import Counter\n# import math\n# from functools import reduce\n#\n# fin = open('./test/in_1.txt', 'r')\n# sys.stdin = fin\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef mi(): return map(int, input().rstrip().split())\ndef lmi(): return list(map(int, input().rstrip().split()))\ndef li(): return list(input().rstrip())\n# template\n\n\n\nif __name__ == '__main__':\n\n    # write code\n    n,q = mi()\n    a = lmi()\n    i = 0\n    max_a = max(a)\n    t = a.index(max_a)\n    last = a[0]\n    Lis = []\n    tmp = []\n    for i in range(1, t + 1):\n        Lis.append((last,a[i]))\n        if last < a[i]:\n            tmp.append(last)\n            last = a[i]\n        else:\n            tmp.append(a[i])\n    # print(Lis)\n    anslist = a[t+1:] + tmp\n    # print(last)\n    # print(anslist)\n    # print(tmp)\n    for i in range(q):\n        tm = ii()\n        if 1 <= tm <= t:\n            print(Lis[tm - 1][0],Lis[tm - 1][1])\n        else:\n            print(max_a,anslist[(tm-t-1)%len(anslist)])", "complexity": "linear", "problem": "1180_C", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "MAX = 1000\nf = [0]\nfor i in range(1, MAX):\n    f.append(f[i - 1] + (1 << (2 * i - 2)))\n\ng = [0]\nfor i in range(1, MAX):\n    g.append(g[i - 1] + (1 << i) - 1)\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split(' '))\n    ans = False\n    for i in range(1, n + 1):\n        if k >= g[i]:\n            if n >= MAX:\n                print(\"YES %d\" % (n - i))\n                ans = True\n            elif k <= f[n] - ((1 << (i + 1)) - 1) * f[n - i]:\n                print(\"YES %d\" % (n - i))\n                ans = True\n        if ans == True:\n            break\n    if ans == False:\n        print(\"NO\")\n        \n    ", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "n,l,r,x = map(int,input().split())\nc = [int(i) for i in input().split()]\nans = 0\nfor bit in range(2,1<<n):\n    probs = []\n    t = 0\n    for i in range(n):\n        if bit&(1<<i):\n            probs.append(c[i])\n            t += c[i]\n    \n    a = min(probs)\n    b = max(probs)\n\n    if t >= l and t <= r and abs(a-b) >= x:\n        ans += 1\nprint(ans)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "turns, candies = map(int, input().split())\nsumm = 0\nturn = 0\nwhile candies != summ - (turns - turn):\n    turn += 1\n    summ += turn\nprint(turns - turn)", "complexity": "linear", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "from sys import stdin\n\nadd = lambda a, b: (a + b) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, i * 2 + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])\n\nprint(sum(mem[-1][k]) % mod)\n", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "'''     Design by Dinh Viet Anh(JOKER)\n//_____________________________________$$$$$__\n//___________________________________$$$$$$$$$\n//___________________________________$$$___$\n//___________________________$$$____$$$$\n//_________________________$$$$$$$__$$$$$$$$$$$\n//_______________________$$$$$$$$$___$$$$$$$$$$$\n//_______________________$$$___$______$$$$$$$$$$\n//________________$$$$__$$$$_________________$$$\n//_____________$__$$$$__$$$$$$$$$$$_____$____$$$\n//__________$$$___$$$$___$$$$$$$$$$$__$$$$__$$$$\n//_________$$$$___$$$$$___$$$$$$$$$$__$$$$$$$$$\n//____$____$$$_____$$$$__________$$$___$$$$$$$\n//__$$$$__$$$$_____$$$$_____$____$$$_____$\n//__$$$$__$$$_______$$$$__$$$$$$$$$$\n//___$$$$$$$$$______$$$$__$$$$$$$$$\n//___$$$$$$$$$$_____$$$$___$$$$$$\n//___$$$$$$$$$$$_____$$$\n//____$$$$$$$$$$$____$$$$\n//____$$$$$__$$$$$___$$$\n//____$$$$$___$$$$$$\n//____$$$$$____$$$\n//_____$$$$\n//_____$$$$\n//_____$$$$\n'''\nfrom math import *\nfrom cmath import *\nfrom itertools import *\nfrom decimal import *  # su dung voi so thuc\nfrom fractions import *  # su dung voi phan so\nfrom sys import *\nfrom types import CodeType, new_class\n#from numpy import *\n\n'''getcontext().prec = x # lay x-1 chu so sau giay phay (thuoc decimal)\nDecimal('12.3') la 12.3 nhung Decimal(12.3) la 12.30000000012\nFraction(a) # tra ra phan so bang a (Fraction('1.23') la 123/100 Fraction(1.23) la so khac (thuoc Fraction)\na = complex(c, d) a = c + d(i) (c = a.real, d = a.imag)\na.capitalize() bien ki tu dau cua a(string) thanh chu hoa, a.lower() bien a thanh chu thuong, tuong tu voi a.upper()\na.swapcase() doi nguoc hoa thuong, a.title() bien chu hoa sau dau cach, a.replace('a', 'b', slg)\nchr(i) ki tu ma i ord(c) ma ki tu c\na.join['a', 'b', 'c'] = 'a'a'b'a'c, a.strip('a') bo dau va cuoi ki tu 'a'(rstrip, lstrip)\na.split('a', slg = -1) cat theo ki tu 'a' slg lan(rsplit(), lsplit()), a.count('aa', dau = 0, cuoi= len(a)) dem slg\na.startswith('a', dau = 0, cuoi = len(a)) co bat dau bang 'a' ko(tuong tu endswith())\na.index(\"aa\") vi tri dau tien xuat hien (rfind())\ninput = open(\".inp\", mode='r')  a = input.readline()\nout = open(\".out\", mode='w') a.index(val) '''\n#inn = open(\".inp\", \"r\")\n\na = []\nn, m = map(int, input().split())\nminx, miny, maxx, maxy = n, m, 0, 0\nfor x in range(n):\n    a.append(input())\n    for y in range(m):\n        if a[x][y] == 'B':\n            minx = min(minx, x + 1)\n            miny = min(miny, y + 1)\n            maxx = max(maxx, x + 1)\n            maxy = max(maxy, y + 1)\nprint((maxx + minx) // 2 , (maxy + miny) // 2)\n", "complexity": "quadratic", "problem": "1028_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\nm,n=[int(ele) for ele in input().split()]\na=[]\nfor i in range(m):\n    a.append(list(map(int, input().split())))\n\n\nina,mo=0,10**9+1\npos1,pos2=0,0\nmask=(1<<n)-1\ndef check(tang):\n    key=set()\n    dic=dict()\n    for i in range(m):\n        temp=0 \n        for j in range(n):\n            if a[i][j]>=tang:\n                #print(\"ya\")\n                temp+=(1<<j)\n        #print(bin(temp),a[i],tang)\n        if temp in key:\n            continue\n        key.add(temp)\n        tempk=temp\n        while tempk>=0:\n            tempk &= temp\n            dic[tempk]=i\n            tempk-=1\n            \n        tocheck = mask ^ temp\n        #print(bin(tocheck),bin(temp),bin(mask),a[i],tang)\n\n        if tocheck in dic:\n            return dic[tocheck],i,True\n\n    #print(dic)\n    return -1,-1,False\n        \nwhile ina<mo-1:\n    #print(ina,mo)\n    tang=(ina+mo)//2\n    #print(ina,mo,tang)\n    temppos1,temppos2,status=check(tang)\n    #print(status)\n    if status:\n        pos1,pos2=temppos1,temppos2\n        ina=tang\n    else:\n        mo=tang\nprint(pos1+1,pos2+1)\n    \n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "from collections import defaultdict as dd\nfrom collections import deque, Counter\nimport bisect\nimport heapq\nfrom math import inf\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef ri():\n    return int(input())\n \ndef rl():\n    return list(map(int, input().split()))\n\n\n \nn, m = rl()\naa = rl()\n\n#convert aa to array of [+,-,-,-,+,-,+,....]\nbb = [-1]*n\nfor i in range(n):\n\tif aa[i] == m:\n\t    bb[i] = 1\n\telif aa[i] < m:\n\t    bb[i] = -1\n\telse: # aa[i] > m\n\t    bb[i] = 1\n\nprefix_sum= [0]*(n+1)\nfor i in range(1, n+1):\n    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]\n\n\n#now if we choose l and r, we have to compare:\n# median on [l,r] more or equal to m iff (prefix_sum[r+1] - prefix_sum[l]) > 0  (1)\n\n#if we do the same thing with m+1 instead of m\n#median on [l,r] more or equal to m +1 ...\n\n#we can deduct second result from first\\\n#to get the number of pairs [l,r] such as \\\n#median on [l,r] exactly equal to m\n\n\n#we can rewrite (1)  as prefix_sum[r+1] > prefix_sum[l]\n#this is linked to counting the number of inversions in the prefix sum!!\n#classic problem, can be done by merge sort\n\n#we need to be a bit carefull, because we want only the inversions\\\n# with l on left of median and r on the right\n# can count inversion on 3 parts:\n#-whole array\n#-begin of array to median\n#-median to end\n#then deduct the last two from the first\n\ndef mergeSortGoodOrder(arr):\n    \"\"\"\n    this doesn t count the number of inversions, but quite the opposite\n    it counts the number of pairs i < j such as arr[i] < arr[j]\n    \"\"\"\n    if len(arr) == 1:\n        return arr, 0\n    else:\n        a = arr[:len(arr)//2]\n        b = arr[len(arr)//2:]        \n\n        a, ai = mergeSortGoodOrder(a)\n        b, bi = mergeSortGoodOrder(b)\n        c = []        \n\n        i = 0\n        j = 0\n        good = 0 + ai + bi    \n\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            c.append(a[i])\n            i += 1\n            good += (len(b)-j)\n        else:\n            c.append(b[j])\n            j += 1\n               \n\n    c += a[i:]\n    c += b[j:]\n\n    return c, good\n\n\n\n#step1: with m\n\n\n#we want prefix_sum[l] < prefix_sum[r+1]\n#ie : prefix_sum[l] < prefix_sum[r], and r stricly on the right of median\n\n\n#find position of median\nidx = 0\nfor i in range(n):\n    if aa[i] == m:\n        idx = i\n\n\n_, good = mergeSortGoodOrder(prefix_sum)\n\n_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])\n\n_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])\n\n\nfirst_count = good - bad_left - bad_right\n\n#step2: with m + 1\nbb = [-1]*n\nfor i in range(n):\n\tif aa[i] == m + 1:\n\t    bb[i] = 1\n\telif aa[i] < m + 1:\n\t    bb[i] = -1\n\telse: # aa[i] > m + 1\n\t    bb[i] = 1\n\nprefix_sum= [0]*(n+1)\nfor i in range(1, n+1):\n    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]\n\n\n\n##BE CAREFUL: here we need to keep idx as the one of aa[idx] = m, NOT aa[idx = m+1]\n# #find position of m + 1\n# idx = 0\n# for i in range(n):\n#     if aa[i] == m + 1:\n#         idx = i\n\n\n_, good = mergeSortGoodOrder(prefix_sum)\n\n_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])\n\n_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])\n\nsecond_count = good - bad_left - bad_right\n\n\n#step3: combine\n\nans   = first_count - second_count\n\nprint(ans)\n\n\n", "complexity": "nlogn", "problem": "1005_E1", "from": "CODEFORCES", "tags": "sortings"}
{"src": "[n, k]=[int(i) for i in input().split()]\nprint((k+n-1)//n)", "complexity": "constant", "problem": "1036_A", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\nfrom math import floor\n\nif __name__ == '__main__':\n\n    entrada = input()\n    entrada_str = list(entrada.split(\" \"))\n    entrada_int = list(map(int, entrada_str))\n\n    a = entrada_int[0]\n    b = entrada_int[1]\n\n    if a == b:\n        print(0)\n        sys.exit()\n\n    string_1 = \"\"\n    string_2 = \"\"\n    while a:\n        if a%2 == 0:\n            string_1 = string_1 + \"0\"\n        else:\n            string_1 = string_1 + \"1\"\n        a = floor(a/2)\n\n    while b:\n        if b%2 == 0:\n            string_2 = string_2 + \"0\"\n        else:\n            string_2 = string_2 + \"1\"\n        b = floor(b/2)\n\n    lista_1 = list(string_1)\n    lista_1.reverse()\n    contrario_1 = \"\".join(lista_1)\n\n    lista_2 = list(string_2)\n    lista_2.reverse()\n    contrario_2 = \"\".join(lista_2)\n\n    if len(string_1) != len(string_2):\n        resposta = pow(2, len(string_2)) - 1\n    else:\n        potencia = 0\n        for i in range(len(string_1)):\n            if contrario_1[i] != contrario_2[i]:\n                break\n            potencia += 1\n\n        potencia = len(string_1) - potencia\n        resposta = pow(2, potencia)-1\n\n    print(resposta)\n\n\n\n\t\t    \t\t \t\t\t  \t\t\t\t \t \t   \t\t \t\t", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import sys\nsys.setrecursionlimit(2000)\nfrom collections import Counter\n\nif __name__ == \"__main__\":\n\n    # single variables\n    n = [int(val) for val in input().split()][0]\n    b = [int(val) for val in input().split()]\n\n    l = 0\n    r = b[0]\n    a = [0] * n\n    for i in range(n//2):\n        a[i] = l\n        a[n-1-i] = r\n        if(i != n//2-1):\n            val = b[i+1]\n            summ = l + r\n            if(summ == val):\n                continue\n            elif(summ > val):\n                diff = summ - val\n                r -= diff\n            elif(summ < val):\n                diff = val - summ\n                l += diff\n\n    for i in a:\n        print(i, end=' ')\n    print('')\n       \n\n\n", "complexity": "linear", "problem": "1093_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "\"\"\"\n#If FastIO not needed, use this and don't forget to strip\n#import sys, math\n#input = sys.stdin.readline\n\"\"\"\n\nimport os, sys, heapq as h, time\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport math, string\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#start_time = time.time()\n\ndef getInt(): return int(input())\ndef getStrs(): return input().split()\ndef getInts(): return list(map(int,input().split()))\ndef getStr(): return input()\ndef listStr(): return list(input())\ndef getMat(n): return [getInts() for _ in range(n)]\ndef isInt(s): return '0' <= s[0] <= '9'\n\nMOD = 10**9 + 7 \n\n\"\"\"\n\n\"\"\"\n\nsquares = set([i*i for i in range(1,4000)])\n\np = [i for i in range(10**7+1)]\nfor i in range(1,10**7+1):\n    if p[i] == i:\n        for sq in squares:\n            if i*sq > 10**7: break\n            p[i*sq] = i\n\ndef solve():\n    N, K = getInts()\n    A = getInts()\n    new = 10**8\n    A = [p[A[i]] for i in range(N)]\n    dp = [N]*(K+1)\n    dp[0] = 0\n    used = [set()]*(K+1)\n    for i in range(N):\n        for j in range(K,-1,-1):\n            if dp[j] == N: continue\n            if A[i] in used[j]:\n                if j < K and dp[j+1] > dp[j]:\n                    dp[j+1] = dp[j]\n                    used[j+1] = used[j]\n                dp[j] += 1\n                used[j] = set([A[i]])\n            else:\n                used[j].add(A[i])\n    return min(dp)+1\n    \nfor _ in range(getInt()):\n    print(solve())\n#solve()\n\n#print(time.time()-start_time)", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nd = set(a)\nif (0 in a): \n    print(len(d)-1)\nelse:\n    print(len(d))", "complexity": "linear", "problem": "0992_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import sys;input = sys.stdin.readline\ndef topological_sorted(digraph):\n    n = len(digraph);indegree = [0] * n\n    for v in range(n):\n        for nxt_v in digraph[v]:indegree[nxt_v] += 1\n    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]\n    while stack:\n        v = stack.pop()\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] -= 1\n            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)\n    return len(tp_order) == n, tp_order\nn, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {};graph = [[] for i in range(n)]\nfor idx, ptn in enumerate(p):val = sum([(ord(ptn[i]) - 96) * (27 ** i) for i in range(k) if ptn[i] != \"_\"]);memo[val] = idx\nfor i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)\nfor string, idx in s:\n    idxs = []\n    idx -= 1\n    for bit_state in range(1 << k):\n        val = 0\n        for i in range(k):\n            if (bit_state >> i) & 1:\n                continue\n            val += (string[i] - 96) * (27 ** i)\n        if val in memo:\n            idxs.append(memo[val])\n    if idx not in idxs:print(\"NO\");exit()\n\n    for idx_to in idxs:\n        if idx == idx_to:\n            continue\n        graph[idx].append(idx_to)\n\nflag, res = topological_sorted(graph)\nif flag:print(\"YES\");print(*[i + 1 for i in res])\nelse:print(\"NO\")", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "nr, ng, nb = map(int, input().split())\nr = sorted([int(i) for i in input().split()])\ng = sorted([int(i) for i in input().split()])\nb = sorted([int(i) for i in input().split()])\n\ndp = [[[0 for _ in range(nb + 1)] for _ in range(ng + 1)] for _ in range(nr + 1)]\nfor i in range(nr + 1):\n    for j in range(ng + 1):\n        for k in range(nb + 1):\n            val = 0\n            if i - 1 >= 0 and j - 1 >= 0:\n                val = max(val, r[i - 1] * g[j - 1] + dp[i - 1][j - 1][k])\n            if i - 1 >= 0 and k - 1 >= 0:\n                val = max(val, r[i - 1] * b[k - 1] + dp[i - 1][j][k - 1])\n            if j - 1 >= 0 and k - 1 >= 0:\n                val = max(val, g[j - 1] * b[k - 1] + dp[i][j - 1][k - 1])\n            dp[i][j][k] = val\n\nprint(dp[nr][ng][nb])\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n = int(input())\nfor i in range(n):\n    a, b, c = [int(el) for el in input().split()]\n    if ( a > c or b > c):\n        print(-1)\n    else:\n        if (a% 2 + b % 2 == 1):\n            print(c - 1)\n        elif (a%2 == b%2 == c%2):\n            print(c)\n        else:\n            print(c - 2)\n", "complexity": "constant", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\n\ndef inn(a,b):\n\treturn (a[0] <= b[0] and b[1] <= a[1])\n\nn = int(input())\n\nseg = []\n\na,b = map(int,input().split())\nseg.append((a,b,1))\n\nfor i in range(2,n+1):\n\ta,b = map(int,input().split())\n\tseg.append((a,b,i))\n\t\nseg.sort(key=lambda x : (x[0],-x[1]))\n\nmain = seg.pop(0)\n\t\nfor i in seg:\n\tif inn(main,i):\n\t\tprint(i[2],main[2])\n\t\tsys.exit(0)\n\tif main[1] < i[1]:\n\t\tmain = i\n\nprint(-1,-1)", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "num=int(input())\nlist_=sorted(set(map(int,input().split())))\nif len(list_)==1:\n    print(\"NO\")\nelse:\n    \n    print(list_[1])\n", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "s=input()\nn=len(s)\nl=[[0,0,0] for i in range(n)]\nans=0\nx=int(s[0])%3\nif(x==0):\n    ans+=1\nelse:\n    l[0][x]=1\nfor i in range(1,n):\n    x=int(s[i])%3\n    if(x==0):\n        ans+=1\n        continue\n    \n    if(l[i-1][3-x]>0):\n        ans+=1\n        l[i][3-x]=0\n        l[i][x]=0\n    else:\n        if(l[i-1][x]!=0):\n            l[i][1]=1\n            l[i][2]=1\n        else:\n            l[i][x]=1\n\nprint(ans)", "complexity": "linear", "problem": "1005_D", "from": "CODEFORCES", "tags": "dp,greedy,number theory"}
{"src": "x, k = map(int,input().split())\nif x==0:\n  print(0)\nelse:\n  print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n,M=map(int,input().split())\na=[0]+[int(x) for x in input().split()]+[M]\n\nt1=[]\nt2=[]\nfor i in range(n+1):\n    if i%2==0:\n        t1.append(a[i+1]-a[i])\n    else:\n        t2.append(a[i+1]-a[i])\nt2.append(0)\n\nimport math\nans=sum(t1)\np=0\nq=sum(t2)\nfor i in range(math.ceil(n/2)):\n    p=p+t1[i]\n    q=q-t2[i-1]\n    ans=max(ans,p+q-1)\nprint(ans)\n", "complexity": "linear", "problem": "1000_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "from sys import stdin\nfrom operator import xor\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, a, m = int(input()), [rints()], int(input())\nqur, out = [rints() for _ in range(m)], []\n\nfor i in range(1, n):\n    a.append(list(map(xor, a[-1][:-1], a[-1][1:])))\n\nfor i in range(n - 1):\n    a[i + 1] = list(map(max, a[i][:-1], a[i][1:], a[i + 1]))\n\nfor l, r in qur:\n    out.append(a[r - l][l - 1])\n\nprint('\\n'.join(map(str, out)))\n", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "n, m, k = list(map(int, input().split()));\na = list(map(int, input().split()));\n\nvalues = list()\n\nfor j in range(n):\n    result = a[j];\n    sum1 = 0;\n    for i in range(m):\n        if j-i>=0:\n            sum1 = sum1 + a[j-i];\n            if sum1 > result:\n                result = sum1;\n        else:\n            continue;\n    if j-m>=0:\n        result = max(result, sum1 + values[j-m]);\n    values.append(max(0, result-k));\nprint(max(values));\n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "n,l,r,x = map(int,input().split())\na = list(map(int,input().split()))\ncount=0\nfor i in range(2**n):\n    maxc=-1\n    minc=-1\n    c=0\n    for j in range(n):\n        if i>>j&1==1:\n            c+=a[j]\n            maxc=max(maxc,a[j])\n            if minc==-1:\n                minc=a[j]\n            else:\n                minc=min(a[j],minc)\n    if c>=l and c<=r and maxc - minc >=x:\n        count+=1\nprint(count)\n\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "#B. Pair of Toys\nn,k=map(int,input().split())\nif n>=k: \n    print((k-1)//2)\nelif n*2>k: \n    print(n-k//2)\nelse: \n    print(0)", "complexity": "constant", "problem": "1023_B", "from": "CODEFORCES", "tags": "math"}
{"src": "from collections import defaultdict, deque, Counter\nfrom sys import stdin, stdout\nfrom heapq import heappush, heappop\nimport math\nimport io\nimport os\nimport math\nimport bisect\n\n#?############################################################\n\n\ndef isPrime(x):\n    for i in range(2, x):\n        if i*i > x:\n            break\n        if (x % i == 0):\n            return False\n    return True\n\n#?############################################################\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p\n\n\n#?############################################################\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            l.append(int(i))\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\n\n#?############################################################\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n#?############################################################\n\n\ndef sieve(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\n#?############################################################\n\ndef digits(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\n\n#?############################################################\n\n\ndef ceil(n, x):\n    if (n % x == 0):\n        return n//x\n    return n//x+1\n\n#?############################################################\n\n\ndef mapin():\n    return map(int, input().split())\n\n#?############################################################\ndef solve(final, n):\n    fifi = [[final[j][i] for j in range(n)] for i in range(n)] \n \n    k = []\n    for i in range(n):\n        k.append(sum(final[i]))\n    a = max(k)-min(k)\n    \n    a = a*a\n    k = []\n    for i in range(n):\n        k.append(sum(fifi[i]))\n    b = max(k)-min(k)\n    \n    b = b*b\n    \n    \n    return a+b\n    \n    \ndef inte(a, b, c, d):\n    a = max(a, c)\n    b = min(b, d)\n    \n    return [a, b]\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n# python3 15.py<in>op\nn = int(input())\nl = []\nfor i in range(n):\n    a, b = mapin()\n    l.append([a, b])\n    \n    \nf= []\nff = []\na = 0\nb = 10000000000000\nf.append([a, b])\nfor i in range(n):\n    x = inte(a, b, l[i][0], l[i][1])\n    a = x[0]\n    b = x[1]\n    f.append([a, b])\na = 0\nb = 10000000000000\nff = [[] for i in range(n)]\nfor i in reversed(range(n)):\n    x = inte(a, b, l[i][0], l[i][1])\n    a = x[0]\n    b = x[1]\n    ff[i] = [a, b]\nff.append([0, 100000000000000])\nans = 0  \nfor i in range(n):\n    a = f[i]\n    b = ff[i+1]\n    y = inte(a[0], a[1], b[0], b[1])\n    if(y[1]>= y[0]):\n        ans = max(ans, y[1]-y[0])\n    \n    \n# print(f, ff)/\nprint(ans)\n\n    \n    ", "complexity": "linear", "problem": "1029_C", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "n, m, k = map(int, input().split())\na = list(map(int, input().split()))\nsa = [0]*n\n\nans = 0\n\nfor i in range(n):\n    sa[i] = a[i] - k\n    s = a[i]\n    for j in range(i-1, max(-1, i-m-1), -1):\n        sa[i] = max(sa[i], sa[j] + s - k)\n        s += a[j]\n    if i < m:\n        sa[i] = max(sa[i], s - k)\n    sa[i] = max(sa[i], 0)\n    ans = max(ans, sa[i])\n\nprint(ans)\n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "import sys\nimport math\nimport collections\nimport bisect\nimport string\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n=int(input())\n    s1=list(get_string())\n    s2=list(get_string())\n    count=0\n    ans=[]\n    lower=string.ascii_lowercase\n    np=0\n    for i in lower:\n        if s1.count(i)!=s2.count(i):\n            np+=1\n            break\n    if np>0:\n        print(-1)\n        continue\n    pos=dict()\n    for i in range(n):\n        if s1[i] in pos:\n            pos[s1[i]].append(i)\n        else:\n            pos[s1[i]]=[i]\n    for i in range(n):\n        if s1[i]==s2[i]:\n            continue\n        else:\n            row=pos[s2[i]]\n            no=0\n            for j in range(len(row)):\n                if row[j]>i:\n                    no=row[j]\n                    break\n            for j in range(no,i,-1):\n                ans.append(j)\n            s1.pop(no)\n            s1.insert(i,s2[i])\n            #print(s1)\n            pos = dict()\n            for j in range(n):\n                if s1[j] in pos:\n                    pos[s1[j]].append(j)\n                else:\n                    pos[s1[j]] = [j]\n    print(len(ans))\n    print(*ans)", "complexity": "quadratic", "problem": "1015_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\nfrom collections import Counter\n\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\nn, k = mi()\ns = input().strip()\nc = Counter(s)\nmn = 10 ** 9\nfor ch in alpha[:k]:\n    mn = min(mn, c[ch])\nprint(mn * k)\n", "complexity": "linear", "problem": "1038_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "import math\n\ndef gaosi(x):\n    if (x==1):\n        return 1\n    else:\n        return ((1+x)*x)/2\n\ndef calc(mid, total, left):\n    return gaosi(mid) - (total - mid) - left\n\ndef main(): \n    x, left = map(int, input().split())\n    if (x == 1 and left == 1):\n        print(0)\n    else:\n        l = 1\n        r = x\n        while (True):\n            mid = math.floor((l + r) / 2)\n            result = calc(mid, x, left)\n            if (result == 0):\n                print(x - mid)\n                break\n            elif (result > 0):\n                r = mid\n            elif (result  < left):\n                l = mid\n\n    \nif __name__ == \"__main__\":\n    main()", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "# problem http://codeforces.com/contest/1100/problem/E\nimport copy\nimport sys\n\n\ndef find_loop(g, w, k, n):\n    visited = [False] * n\n    visited_int = [False] * n\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        visited_int[i] = True\n        while stack:\n            if not stack[-1]:\n                stack.pop()\n                visited_int[path[-1]] = False\n                path.pop()\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited_int[nxt]:\n                return True\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            visited_int[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n    return False\n\n\ndef top_sort(g, w, k, n):\n    visited = [False] * n\n    order = [-1] * n\n    cnt = 0\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        while stack:\n            if not stack[-1]:\n                order[path[-1]] = cnt\n                path.pop()\n                stack.pop()\n                cnt += 1\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n\n    to_reverse = []\n    for a, b in w.items():\n        if b > k:\n            continue\n        if order[a[0]] < order[a[1]]:\n            to_reverse.append(a)\n    return to_reverse\n\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    w = {}\n    g = [[] for _ in range(n)]\n    w_tmp = {}\n    c_m = 0\n    kk = [0]\n    lines = sys.stdin.readlines()\n    for i, line in enumerate(lines): #range(1, m + 1):\n        u, v, c = map(int, line.split())\n        g[u - 1].append(v - 1)\n        if (u - 1, v - 1) in w.keys():\n            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)\n        else:\n            w[(u - 1, v - 1)] = c\n        if (u - 1, v - 1) in w_tmp.keys():\n            w_tmp[(u - 1, v - 1)].append(str(i + 1))\n        else:\n            w_tmp[(u - 1, v - 1)] = [str(i + 1)]\n        kk.append(c)\n        # c_m = max(c, c_m)\n\n    # print(find_loop(copy.deepcopy(g), copy.deepcopy(w), 0, n))\n\n    kk.sort()\n    l, r = 0, len(kk)\n    if not find_loop(g, w, kk[l], n):\n        print(0, 0)\n        exit(0)\n    if find_loop(g, w, kk[-1], n):\n        kkk = kk[-1]\n    else:\n        while l + 1 != r:\n            m = int((l + r) / 2)\n            # if find_loop(copy.deepcopy(g), copy.deepcopy(w), kk[m], n):\n            if find_loop(g, w, kk[m], n):\n                l = m\n            else:\n                r = m\n        kkk = kk[l+1]\n\n    to_reverse = top_sort(g, w, kkk, n)\n    num = 0\n    s = []\n    for t in to_reverse:\n        num += len(w_tmp[t])\n        s.extend(w_tmp[t])\n\n    print(kkk, num)\n    print(\" \".join(s))\n\n\n\n\n\n", "complexity": "nlogn", "problem": "1100_E", "from": "CODEFORCES", "tags": "binary search,dfs and similar,graphs"}
{"src": "import collections\nimport random\nimport heapq\nimport bisect\nimport math\nimport time\n# import operator as op\n# from functools import reduce\n\nclass Solution2:\n\n    def solve(self, s):\n        pass\n        \n\nclass Solution:\n\n    def solve(self, n, k):\n        \n        grow = 1\n        tot = 0\n\n        while n != tot - k:\n            tot += grow\n            grow += 1\n            n -= 1\n        return tot - k\n\n\nsol = Solution()\nsol2 = Solution2()\n\n\n#TT = int(input())\nfor test_case in range(1):\n    N, K = input().split()\n    # s = []\n    # for _ in range(int(N)):\n    #     s.append(int(input()))\n\n    out = sol.solve(int(N),int(K))\n    print(str(out))\n    #print(\"Case #\" + str(test_case+1) + \": \" + str(out))\n\n    # out2 = sol2.solve(s)\n    # print(\"Case #\" + str(i+1) + \": \" + str(out2))\n\n\n# for _ in range(100000):\n#     rand = [random.randrange(60) for _ in range(10)]\n#     out1 = sol.solve(rand)\n#     out2 = sol2.solve(rand)\n#     if out1 != out2: \n#         print(rand, out1, out2)\n#         break", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import sys\nimport bisect\n\nls2int = lambda ls: int(''.join(map(str,ls)))\ndef candidates(digs, num):\n    if not digs:\n        return [[]]\n    \n    res = []\n    i = bisect.bisect_left(digs, num[0])\n    \n    # lead with same digit\n    if num[0] in digs:\n        for suffix in candidates(digs[:i]+digs[i+1:], num[1:]):\n            res.append([digs[i]] + suffix)\n    \n    # lead with next smallest digit:\n    if i > 0:\n        i -= 1\n        res.append([digs[i]] + list(reversed(digs[:i]+digs[i+1:])))\n    \n    return res\n    \ndef solution(a, b):\n    digits = [int(x) for x in sorted(a)]\n    ceiling = [int(x) for x in b]\n    \n    assert(len(digits) <= len(ceiling), 'solution does not exist')\n    if len(digits) < len(ceiling):\n        return ls2int(digits[::-1])\n    return max(ls2int(ls) for ls in candidates(digits, ceiling))\n    \na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\nprint(solution(a, b))", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "def pow1(n, k):\n    if k == 0:\n        return 1\n    if k == 1:\n        return n\n    else:\n        if k % 2 == 0:\n            a = pow1(n, k // 2) % mod\n            return a * a % mod\n        else:\n            return pow1(n, k - 1) % mod * n % mod\n\n \nmod = 10 ** 9 + 7\nn, k = map(int, input().split())\nif n == 0:\n    print(0)\nelse:\n    x = pow1(2, k + 1) % mod\n    print(((n * x - pow1(2, k) + 1)) % mod)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "k = int(input())\n\nmul = 1\nd = 1\n\nwhile k>mul*9*d:\n    k-=mul*9*d\n    d+=1\n    mul*=10\n    \n\nx = k%d\ny = k//d\ny+=mul\n\nif x==0:\n    print((y-1)%10)\nelse:\n    y = y//pow(10,d-x)\n    print(y%10)\n    ", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import copy\n\nn,m,k=map(int,input().split())\nA=list(map(int,input().split()))\n\nANS=0\n\nfor i in range(m):\n    B=copy.deepcopy(A)\n    for j in range(i,n,m):\n        B[j]-=k\n\n    NOW=0\n\n    for j in range(i,n):\n        if j%m==i:\n            NOW=max(NOW+B[j],B[j])\n        else:\n            NOW+=B[j]\n\n        ANS=max(ANS,NOW)\n\nprint(ANS)\n        \n    \n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "n = int(input())\nif n%2==0:\n    a = n - 8\n    print(a,8)\nelse:\n    a = n-9\n    print(a,9)\n", "complexity": "constant", "problem": "0472_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "n = int(input())\narr = list(map(int, input().split()))\ntracker = [[-1] * (n+1) for _ in range(2024)]\n \nd = [[] for _ in range(n)]\nfor j, v in enumerate(arr):\n\ttracker[v][j] = j\n\td[j].append(j)\n \nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = tracker[v][i]\n\t\th = tracker[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\ttracker[v+1][i] = h\n\t\t\td[i].append(h)\n \na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor tracker in d[s]:\n\t\ta[tracker] = min(a[tracker], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n, m = map(int,input().split())\nb = []\nd = []\nfor x in range(n):\n\tif x == 0:\n\t\ta,c = map(int,input().split())\n\t\tif (a * 60) + c > m:b.append(\"0 0\")\n\t\td.append((a * 60) + c)\n\telse:\n\t\ta ,c = map(int,input().split())\n\t\tif ((a * 60) + c) - d[-1] > (m * 2) + 1:\n\t\t\tf = d[-1] + m + 1\n\t\t\tb.append(str(f // 60) + \" \" + str((f % 60)))\n\t\td.append((a * 60) + c)\nif len(b) == 0:\n\tf = d[-1] + m + 1\n\tb.append(str(f // 60) + \" \" + str((f % 60)))\nprint(b[0])", "complexity": "linear", "problem": "0967_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import math\nn  = int(input())\n\nfor i in range(n):\n    l,r = [*map(int, input().split())]\n    l-=1\n    war1 = math.ceil(l/2)\n    if(l%2 == 1):\n        war1 = -1*war1\n    \n    war2 = math.ceil(r/2)\n    if(r%2 == 1):\n        war2 = -1*war2\n\n    print(war2-war1)", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "def black_count(x, y):\n\ttotal = x * y\n\treturn total // 2\n\n\ndef black_count2(a, b, c, d):\n\treturn black_count(c, d) - black_count(a-1, d) - black_count(c, b-1) + black_count(a-1, b-1)\n\ndef white_count2(a, b, c, d):\n\ttotal = (c - a + 1) * (d - b + 1)\n\treturn total - black_count2(a, b, c, d)\n\n\ndef intersection(a, b, c, d, x, y):\n\tif x < a or y < b:\n\t\treturn None\n\tx = min(x, c)\n\ty = min(y, d)\n\treturn (a, b, x, y)\n\ndef intersection2(a1, b1, c1, d1, a2, b2, c2, d2):\n\tif b1 > d2 or a1 > c2:\n\t\treturn None\n\tif b2 > d1 or a2 > c1:\n\t\treturn None\n\n\ta = max(a1, a2)\n\tb = max(b1, b2)\n\tc = min(c1, c2)\n\td = min(d1, d2)\n\treturn (a, b, c, d)\n\n\ndef solve(n, m, W, B):\n\ttotal = n * m\n\twhites = total - black_count(n, m)\n\twhites += black_count2(*W)\n\twhites -= white_count2(*B)\n\tI = intersection2(*W, *B)\n\tif I:\n\t\twhites -= black_count2(*I)\n\tblacks = n * m - whites\n\treturn whites, blacks\n\ndef main():\n\tt = int(input())\n\tfor _ in range(t):\n\t\tn, m = map(int, input().split())\n\t\tW = list(int(i) for i in input().split())\n\t\tB = list(int(i) for i in input().split())\n\t\tw, b = solve(n, m, W, B)\n\t\tprint(w, b)\n\n\nif __name__ == '__main__':\n\tmain()\n", "complexity": "constant", "problem": "1080_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def max_profit(n,k,l,d):\n    a=[]\n    s,p,i=0,0,-1\n    while(len(a)!=k-1):\n        p+=1\n        i+=1\n        if l[i] in d:\n            s+=l[i]\n            a.append(p)\n            p=0\n            d.remove(l[i])\n    print(s+d[0])\n    a.append(n-sum(i for i in a))\n    print(*a)\n\n\nn,k=map(int,input().split())\nl=list(map(int,input().split()))\nm=[]\nm[:]=l[:]\nd=[]\nm.sort(reverse=True)\nfor i in range(k):\n    d.append(m[i])\nmax_profit(n,k,l,d)", "complexity": "nlogn", "problem": "1006_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "def f(k):\n    res = 1\n    a = 2\n    while k:\n        if k % 2 == 1:\n            res *= a\n            k -= 1\n        else:\n            a *= a\n            k //= 2\n        res = res % (1000000007)\n        a = a % (1000000007)\n    return res\n\n\nn, k = map(int, input().split())\nif n == 0:\n    print(0)\nelif k == 0:\n    print((n * 2) % 1000000007)\nelse:\n    first = (2 * n - 1) % 1000000007\n    first *= f(k)\n    first = (first + 1) % 1000000007\n    print(first)\n\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque \n\n \nn, k = map(int,input().split())\ns = input()\n\n \n \n \ndef judge(needed):\n \n    \n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n \n    effect = [[inf]*(n+1) for j in range(k)]\n \n\n    \n    for j in range(k):\n        accu = 0\n        index = inf\n        for i in range(n)[::-1]:\n            if s[i]==ord('?') or s[i]==97+j:\n                accu += 1\n            else:\n                accu = 0\n\n   \n\n            if accu>=needed:\n                index = i + needed\n            effect[j][i] = index\n            effect[j][i] = min(effect[j][i],inf)\n\n\n   \n#    print(effect)                \n             \n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index]) \n\n\n\n        minstate[state] = minimum \n   \n \n#    print(minstate) \n \n \n \n    if minstate[-1]<=n:  return True\n    return False\n \n \nfront = 0\nrear = n//k+1\n \nwhile front < rear:\n    mid = (front+rear)//2\n    flag = judge(mid)\n#    print(mid,flag)\n \n    if flag:  \n        front = mid + 1\n    else:\n        rear = mid \n \nprint(front-1)\n", "complexity": "np", "problem": "1550_E", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,strings,two pointers"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn,m,k=map(int,input().split())\nYOKO=[list(map(int,input().split())) for i in range(n)]\nTATE=[list(map(int,input().split())) for i in range(n-1)]\n\nif k%2==1:\n    for i in range(n):\n        print(*[-1]*m)\n    exit()\n\nDP=[[0]*m for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n\n        MIN=1<<30\n\n        if j-1>=0:\n            MIN=min(MIN,YOKO[i][j-1]*2)\n        if j<m-1:\n            MIN=min(MIN,YOKO[i][j]*2)\n\n        if i-1>=0:\n            MIN=min(MIN,TATE[i-1][j]*2)\n        if i<n-1:\n            MIN=min(MIN,TATE[i][j]*2)\n\n        DP[i][j]=MIN\n\nDP0=DP[:]\n#print(DP)\n\nfor tests in range(k//2-1):\n    NDP=[[0]*m for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            MIN=DP[i][j]+DP0[i][j]\n\n            if 0<=i+1<n:\n                MIN=min(MIN,TATE[i][j]*2+DP[i+1][j])\n\n            if 0<=i-1<n:\n                MIN=min(MIN,TATE[i-1][j]*2+DP[i-1][j])\n\n            if 0<=j+1<m:\n                MIN=min(MIN,YOKO[i][j]*2+DP[i][j+1])\n\n            if 0<=j-1<m:\n                MIN=min(MIN,YOKO[i][j-1]*2+DP[i][j-1])\n\n            NDP[i][j]=MIN\n    DP=NDP\n\nfor dp in DP:\n    print(*dp)\n        \n\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "\nfrom bisect import bisect,bisect_left\n\nfrom collections import *\nfrom math import gcd,ceil,sqrt,floor,inf\nfrom heapq import *\nfrom itertools import *\nfrom operator import add,mul,sub,xor,truediv,floordiv\nfrom functools import *\n\n#------------------------------------------------------------------------\nimport os\nimport sys\n\nfrom io import BytesIO, IOBase\n# region fastio\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n\n#------------------------------------------------------------------------\ndef RL(): return map(int, sys.stdin.readline().split())\ndef RLL(): return list(map(int, sys.stdin.readline().split()))\ndef N(): return int(input())\ndef A(n):return [0]*n\ndef AI(n,x): return [x]*n\ndef A2(n,m): return [[0]*m for i in range(n)]\ndef G(n): return [[] for i in range(n)]\ndef GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]\n#------------------------------------------------------------------------\n\n\nfrom types import GeneratorType\n \n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n \n    return wrappedfunc\n\nmod=10**9+7\nfarr=[1]\nifa=[]\n \ndef fact(x,mod=0):\n    if mod:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr)%mod)\n    else:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr))\n    return farr[x]\n \ndef ifact(x,mod):\n    global ifa\n    fact(x,mod)\n    ifa.append(pow(farr[-1],mod-2,mod))\n    for i in range(x,0,-1):\n        ifa.append(ifa[-1]*i%mod)\n    ifa.reverse()\n \ndef per(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return fact(i)//fact(i-j)\n    return farr[i]*ifa[i-j]%mod\n    \ndef com(i,j,mod=0):\n    if i<j: return 0\n    if not mod:        \n        return per(i,j)//fact(j)\n    return per(i,j,mod)*ifa[j]%mod\n \ndef catalan(n):\n    return com(2*n,n)//(n+1)\n \ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef floorsum(a,b,c,n):#sum((a*i+b)//c for i in range(n+1))\n    if a==0:return b//c*(n+1)\n    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2\n    m=(a*n+b)//c\n    return n*m-floorsum(c,c-b-1,a,m-1)\n\ndef inverse(a,m):\n    a%=m\n    if a<=1: return a\n    return ((1-inverse(m,a)*m)//a)%m\n \ndef lowbit(n):\n    return n&-n\n \nclass BIT:\n    def __init__(self,arr):\n        self.arr=arr\n        self.n=len(arr)-1\n        \n    def update(self,x,v):\n        while x<=self.n:\n            self.arr[x]+=v\n            x+=x&-x\n \n    def query(self,x):\n        ans=0\n        while x:\n            ans+=self.arr[x]\n            x&=x-1\n        return ans\n\nclass ST:\n    def __init__(self,arr):#n!=0\n        n=len(arr)\n        mx=n.bit_length()#\u53d6\u4e0d\u5230\n        self.st=[[0]*mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0]=arr[i]\n        for j in range(1,mx):\n            for i in range(n-(1<<j)+1):\n                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])\n    def query(self,l,r):\n        if l>r:return -inf\n        s=(r+1-l).bit_length()-1\n        return max(self.st[l][s],self.st[r-(1<<s)+1][s])\n        \nclass DSU:#\u5bb9\u91cf+\u8def\u5f84\u538b\u7f29\n    def __init__(self,n):\n        self.c=[-1]*n\n \n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n \n    def find(self,x):\n        if self.c[x]<0:\n            return x\n        self.c[x]=self.find(self.c[x])\n        return self.c[x]\n \n    def union(self,u,v):\n        u,v=self.find(u),self.find(v)\n        if u==v:\n            return False\n        if self.c[u]>self.c[v]:\n            u,v=v,u\n        self.c[u]+=self.c[v]\n        self.c[v]=u\n        return True\n \n    def size(self,x): return -self.c[self.find(x)]\n    \nclass UFS:#\u79e9+\u8def\u5f84\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n \n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n \ndef Prime(n):\n    c=0\n    prime=[]\n    flag=[0]*(n+1) \n    for i in range(2,n+1):\n        if not flag[i]:\n            prime.append(i)\n            c+=1\n        for j in range(c):\n            if i*prime[j]>n: break\n            flag[i*prime[j]]=prime[j]\n            if i%prime[j]==0: break\n    return flag\n \ndef dij(s,graph):\n    d={}\n    d[s]=0\n    heap=[(0,s)]\n    seen=set()\n    while heap:\n        dis,u=heappop(heap)\n        if u in seen:\n            continue\n        seen.add(u)\n        for v,w in graph[u]:\n            if v not in d or d[v]>d[u]+w:\n                d[v]=d[u]+w\n                heappush(heap,(d[v],v))\n    return d\n\ndef bell(s,g):#bellman-Ford\n    dis=AI(n,inf)\n    dis[s]=0\n    for i in range(n-1):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n    change=A(n)\n    for i in range(n):\n        for u,v,w in edge:\n            if dis[v]>dis[u]+w:\n                dis[v]=dis[u]+w\n                change[v]=1\n    return dis\n\ndef lcm(a,b): return a*b//gcd(a,b)\ndef lis(nums):\n    res=[]\n    for k in nums:\n        i=bisect.bisect_left(res,k)\n        if i==len(res):\n            res.append(k)\n        else:\n            res[i]=k\n    return len(res)\n\ndef RP(nums):#\u9006\u5e8f\u5bf9\n    n = len(nums)\n    s=set(nums)\n    d={}\n    for i,k in enumerate(sorted(s),1):\n        d[k]=i\n    bi=BIT([0]*(len(s)+1))\n    ans=0\n    for i in range(n-1,-1,-1):\n        ans+=bi.query(d[nums[i]]-1)\n        bi.update(d[nums[i]],1)\n    return ans\n \nclass DLN:\n    def __init__(self,val):\n        self.val=val\n        self.pre=None\n        self.next=None\n\ndef nb(i,j,n,m):\n    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:\n        if 0<=ni<n and 0<=nj<m:\n            yield ni,nj\n\ndef topo(n):\n    q=deque()\n    res=[]\n    for i in range(1,n+1):\n        if ind[i]==0:\n            q.append(i)\n            res.append(i)\n    while q:\n        u=q.popleft()\n        for v in g[u]:\n            ind[v]-=1\n            if ind[v]==0:\n                q.append(v)\n                res.append(v)\n    return res\n\n@bootstrap\ndef gdfs(r,p):\n    for ch in g[r]:\n        if ch!=p:\n            yield gdfs(ch,r)\n    yield None\n\n\n    \n\nt=1\nfor i in range(t):\n    n,m,k=RL()\n    h=[]\n    v=[]\n    for i in range(n):\n        h.append(RLL())\n    for i in range(n-1):\n        v.append(RLL())\n    if k&1:\n        for i in range(n):\n            print(*AI(m,-1))\n        exit()\n    k//=2\n    dp=[[[inf]*m for i in range(n)]for j in range(k+1)]\n    for i in range(n):\n        for j in range(m):\n            dp[0][i][j]=0\n    for i in range(1,k+1):\n        for j in range(n):\n            for a in range(m):\n                if j:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j-1][a]+2*v[j-1][a])\n                if j+1<n:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j+1][a]+2*v[j][a])\n                if a:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a-1]+2*h[j][a-1])\n                if a+1<m:\n                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a+1]+2*h[j][a])\n    for i in range(n):\n        res=[]\n        for j in range(m):\n            res.append(dp[k][i][j])\n        print(*res)\n    #print(ans)\n\n\n    \n''' \nsys.setrecursionlimit(200000)\nimport threading\nthreading.stack_size(10**8)\nt=threading.Thr\nead(target=main)\nt.start()\nt.join()\n'''\n\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from itertools import combinations\nn,l,r,x=map(int,input().split())\narr=list(map(int,input().split()))\nans=0\nfor i in range(2,n+1):\n\tbrr=list(combinations(arr,i))\n\tfor j in brr:\n\t\ts=sum(j)\n\t\tif l<=s<=r and max(j)-min(j)>=x:\n\t\t\tans+=1\nprint(ans)\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import os\nimport sys\nfrom math import *\nfrom collections import *\n\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\n\n\ndef vsInput():\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA = \"abcdefghijklmnopqrstuvwxyz/\"\nM = 1000000007\nEPS = 1e-6\n\n\ndef Ceil(a, b):\n    return a // b + int(a % b > 0)\n\n\ndef value():\n    return tuple(map(int, input().split()))\n\n\ndef array():\n    return [int(i) for i in input().split()]\n\n\ndef Int():\n    return int(input())\n\n\ndef Str():\n    return input()\n\n\ndef arrayS():\n    return [i for i in input().split()]\n\n\n# -------------------------code---------------------------#\n\nn = int(input())\nif n == 0:\n    print(0)\nelse:\n    print(n // 2 + 1 if n % 2 != 0 else n + 1)\n", "complexity": "constant", "problem": "0979_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n    if a[i]>=0:\n        a[i] = -a[i]-1\nx = min(a)\n\nif len(a)%2==1:\n    for i in range(n):\n        if a[i]==x:\n            a[i] = -a[i]-1\n            break\nprint(*a)", "complexity": "linear", "problem": "1180_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "n = int(input())\np = [list(map(int, input().split())) for _ in range(n)]\nf = lambda a, b, c: (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\ndef g(fi, se, p):\n    q = []\n    for x in p:\n        if f(fi, se, x):\n            if len(q) < 2:\n                q.append(x)\n            else:\n                if f(q[0], q[1], x):\n                    return 1\n    return 0\nprint('NO' if n > 4 and all([g(p[0], p[1], p), g(p[0], p[2], p), g(p[1], p[2], p)]) else 'YES')\n\n", "complexity": "nlogn", "problem": "0961_D", "from": "CODEFORCES", "tags": "geometry"}
{"src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\n# B. Minimum Diameter Tree\n\nfrom collections import Counter\n\nn, s = mi()\nd = Counter()\nfor i in range(n - 1):\n    u, v = mi()\n    d[u] += 1\n    d[v] += 1\n\nl = sum(v == 1 for v in d.values())\nans = s / l * 2\nprint('%.10f' % (ans,))\n", "complexity": "linear", "problem": "1086_B", "from": "CODEFORCES", "tags": "greedy,implementation,trees"}
{"src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\n\nfor _ in range(N):\n    l,r = getIntList()\n    n = (r-l+1)\n    z = n//2\n    if l%2==0:\n        z*=-1\n    if n%2==1:\n        if r%2==0:\n            z += r\n        else:\n            z-=r\n    print(z)\n\n    \n\n\n\n\n", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "from sys import stdin\n\nadd = lambda a, b: (a + b) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, k + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])\n\nprint(sum(mem[-1][k]) % mod)\n", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "n = int(input())\n*a, = map(int, input().split())\ndp = [[0 for i in range(n + 1)] for j in range(n + 1)]\nfor i in range(n):\n    dp[0][i] = a[i]\nfor i in range(1, n):\n    for j in range(n - i + 1):\n        dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1]\nfor i in range(1, n):\n    for j in range(n - i):\n        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1])\nfor i in range(int(input())):\n    l, r = map(int, input().split())\n    print(dp[r - l][l - 1])", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "n = int(input())\n\nfirst = list(input())\nsecond = list(input())\n\nswap = list()\ncan = True\n\nfor i in range(n):\n    if first[i] != second[i]:\n        cont = -1\n        for j in range(i,n): \n            if first[j] == second[i]:\n                cont = j \n                break\n            \n        if cont != -1:\n            for j in range(cont, i, -1 ):\n                first[j], first[j-1] = first[j-1], first[j]\n                swap.append(j)\n        else:\n            can = False\n\nif can: \n    print(len(swap))\n    print(*swap, end=' ')\n\nelse: \n    print(-1)", "complexity": "quadratic", "problem": "1015_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import io, sys\ninput = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()\n\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nn, m, k = mi()\na = [None] + li()\np = [0] * (n + 1)\nfor i in range(1, n + 1):\n    p[i] = p[i - 1] + a[i]\ns = [10 ** 16 for _ in range(m)]\ns[0] = k\nans = 0\nfor i in range(1, n + 1):\n    ans = max(ans, p[i] - min(s))\n    s[i % m] = min(s[i % m], p[i])\n    s[i % m] += k\nprint(ans)\n", "complexity": "linear", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "R, G, B = map(int, input().split())\nL = [sorted(map(int, input().split())) for _ in range(3)]\nDP = [0] * ((R+1) * (G+1) * (B+1))\n\ndef idx(r, g, b):\n  return r * (G+1) * (B+1) + g * (B+1) + b\n\nfor r in range(R+1):\n  for g in range(G+1):\n    for b in range(B+1):\n      best = 0\n      if r:\n        if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]\n        if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])\n      if g and b:\n        best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])\n      DP[idx(r, g, b)] = best\nprint(max(DP))\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import sys\nimport heapq\ninput = sys.stdin.readline\nn = int(input())\nw = [int(z) for z in input().split()]; s = input(); idx = []\nfor i in range(n):\n    idx.append((w[i], i+1))\n\nidx.sort()\nheapq.heapify(idx)\nones = []\nheapq.heapify(ones)\nres = []\nfor i in range(2*n):\n    if s[i] == '0':\n        l = idx[0]\n        heapq.heappop(idx)\n        res.append(l[1])\n        heapq.heappush(ones, [-l[0], l[1]])\n    else:\n        l = ones[0]\n        heapq.heappop(ones)\n        res.append(l[1])\nres = ' '.join([str(i) for i in res])\nsys.stdout.write(res)", "complexity": "nlogn", "problem": "0982_B", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "n, k = map(int, input().split())\nc = n + k\np = int(0.5 * ((8 * c + 9) ** 0.5 - 3))\nprint(n - p)\n", "complexity": "constant", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "x, y, z, t1, t2, t3 = map(int, input().split())\nlift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3\nstairs = t1 * abs(x - y)\nif lift <= stairs:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "constant", "problem": "1054_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\ndef combine(n, k, w=1, out=[], result=[]):\n    if k == 0:\n        result.append(out)\n\n    for i in range(w, n + 1):\n        new_out = out[:]\n        new_out.append(i)\n        combine(n, k-1, i+1, new_out)\n\n    return result\n\n\ndef main():\n\n    n, l, r, x = [int(i) for i in input().split()]\n    c = [int(i) for i in input().split()]\n\n    if n < 2:\n        print(0)\n        return\n\n    result = None\n    for i in range(2, n + 1):\n        if i == n:\n            result = combine(n, i)\n        else:\n            combine(n, i)\n\n    for i in range(len(result)):\n        comb = result[i]\n        for j in range(len(comb)):\n            comb[j] = c[comb[j] - 1]\n\n    cnt = 0\n    for i in range(len(result)):\n        sm = sum(result[i])\n        if sm >= l and sm <= r and (max(result[i]) - min(result[i]) >= x):\n            cnt += 1\n\n    print(cnt)\n\n\n\nif __name__ == '__main__':\n    main()\n\n\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "if __name__ == '__main__':\n\tn = int(input())\n\tnum = n + n//2\n\tprint(num)", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "#by Nick \"LordVader\" Proshin.\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(set(a)) == 1:\n        print(a[0],a[0],a[0],a[0])\n    else:\n        a.sort()\n        g1 = False\n        d = {}\n        mx = 10001\n        for i in a:\n            if i not in d.keys():\n                d[i] = 1\n            else:\n                d[i] += 1\n            if d[i] == 4:\n                g1 = True\n                if i < mx:\n                    mx = i\n        if g1:\n            print(mx, mx, mx, mx)\n        else:\n            res = []\n            for k in d.keys():\n                if d[k] >= 2:\n                    res.append(k)\n            m = len(res)\n            minj = 0\n            for j in range(m - 1):\n                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):\n                    minj = j\n            print(res[minj],res[minj],res[minj+1],res[minj+1])", "complexity": "nlogn", "problem": "1027_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "X, K = map(int, input().split())\nmod = 1000000007\nres = X*pow(2, K+1, mod)-pow(2, K, mod)+1;\nwhile(res < 0):\n   res += mod\nif(X == 0):\n   print(0)\nelse:\n   print(res%mod)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n=int(input())\nprint(2*n*n-2*n+1)", "complexity": "constant", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "#!/usr/bin/env python\nimport os\nimport re\nimport sys\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom collections import Counter, defaultdict, deque\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom fractions import gcd\nfrom io import BytesIO, IOBase\nfrom itertools import (\n    accumulate, combinations, combinations_with_replacement, groupby,\n    permutations, product)\nfrom math import (\n    acos, asin, atan, ceil, cos, degrees, factorial, hypot, log2, pi, radians,\n    sin, sqrt, tan)\nfrom operator import itemgetter, mul\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\n\ndef inp():\n    return(int(input()))\n\n\ndef inlist():\n    return(list(map(int, input().split())))\n\n\ndef instr():\n    s = input()\n    return(list(s[:len(s)]))\n\n\ndef invr():\n    return(map(int, input().split()))\n\n\ndef getReamin(action, n):\n    n -= action\n    ans = (n*(n+1) // 2) - action\n    return ans\n\n\ndef main():\n    # sys.stdin = open('input.txt', 'r')\n    # sys.stdout = open('output.txt', 'w')\n\n    n, k = invr()\n    l = 1\n    r = n\n    res = 0\n    while l <= r:\n        mid = l + (r-l)//2\n        remain = getReamin(mid, n)\n        if remain == k:\n            res = mid\n            break\n        if remain > k:\n            l = mid + 1\n        else:\n            r = mid - 1\n    print(res)\n\n\n    # region fastio\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n#sys.setrecursionlimit(111111) \nINF=99999999999999999999999999999999\n\ndef main():\n    \n    mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n    ###CODE\n    tc = 1\n    for _ in range(tc):\n        n=ri()\n        s=ria()\n        c=ria()\n        ans=INF\n        for i in range(n):\n            mid=s[i]\n            mcl=INF\n            mrl=INF\n            for j in range(i-1,-1,-1):\n                if s[j]<mid:\n                    mcl=min(mcl,c[j])\n            for j in range(i+1,n):\n                if s[j]>mid:\n                    mrl=min(mrl,c[j])\n            ans=min(ans,c[i]+mcl+mrl)\n        if ans==INF:\n            wi(-1)\n        else:\n            wi(ans)\n                    \n            \n            \n        \n                        \n                \n                \n            \n                    \n                    \n                     \n                \n        \n                        \n\n            \n            \n                    \n                \n                \n        \n                \n                          \n            \n        \n    \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    ", "complexity": "quadratic", "problem": "0987_C", "from": "CODEFORCES", "tags": "brute force,dp,implementation"}
{"src": "def wins(mem, l, pos):\n\t# print(pos)\n\tif mem[pos] != 0:\n\t\treturn mem[pos] == 1\n\n\tval = l[pos]\n\n\tlo = pos - val\n\twhile lo >= 0:\n\t\tif l[lo] > val and not wins(mem, l, lo):\n\t\t\tmem[pos] = 1\n\t\t\treturn True\n\t\tlo -= val\n\n\thi = pos + val\n\twhile hi < len(l):\n\t\tif l[hi] > val and not wins(mem, l, hi):\n\t\t\tmem[pos] = 1\n\t\t\treturn True\n\t\thi += val\n\n\tmem[pos] = 2\n\treturn False\n\n\n\nn = int(input())\nl = list(map(int, raw_input().split()))\n\nmem = [0 for i in range(n)]\nans = \"\"\nfor i in range(n):\n\tans += \"A\" if wins(mem, l, i) else \"B\"\n\nprint(ans)\n", "complexity": "linear", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "from sys import stdin\n\nn = int(stdin.readline())\n\nstones = sorted([int(x) for x in stdin.readline().split()])\n\nif n == 1:\n    if stones[0]%2 == 0:\n        print('cslnb')\n    else:\n        print('sjfnb')\n\nelse:\n    chilly = -1\n    chill = 2\n    prev = stones[0]\n    \n    for x in stones[1:]:\n        if x == prev:\n            chill -= 1\n            chilly = x\n        else:\n            streak = 1\n            prev = x\n    \n    s = sum(stones)\n\n    if n%4 == 0 or n%4 == 1:\n        s += 1\n\n    if chill <= 0 or stones.count(0) > 1:\n        print('cslnb')\n    elif chill == 1 and chilly-1 in stones:\n        print('cslnb')\n    elif s%2 == 1:\n        print('cslnb')\n    else:\n        print('sjfnb')\n", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "def checksq(n):\n    m = int(n**0.5)\n    if m * m == n:\n        return m\n    m += 1\n    if m * m == n:\n        return m\n    return -1\n\ndef main():\n    # n, m = map(int, input().split())\n    n = int(input())\n    # arr = list(map(int, input().split()))\n    # s = input()\n    if n % 2 == 1:\n        print(\"NO\")\n        return\n    if checksq(n // 2) != -1:\n        print('YES')\n        return\n    n //= 2\n    if n % 2 == 1:\n        print('NO')\n        return\n    if checksq(n // 2) != -1:\n        print('YES')\n    else:\n        print('NO')\n\n\n\n\n# for i in range(1):\nfor i in range(int(input())):\n    main()", "complexity": "constant", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "\ndef aburrimin(x, y, n, m, costder, costaba, dp):\n    dists = []\n    vals = []\n    if x != 0: # izq\n        dis = costder[y][x-1]\n        dists.append(dis)\n        vals.append(dis+dp[y][x-1])\n    if y != 0: # arri\n        dis = costaba[y-1][x]\n        dists.append(dis)\n        vals.append(dis+dp[y-1][x])\n    if y < n-1: # aba\n        dis = costaba[y][x]\n        dists.append(dis)\n        vals.append(dis+dp[y+1][x])\n    if x < m-1: # der\n        dis = costder[y][x]\n        dists.append(dis)\n        vals.append(dis+dp[y][x+1])\n    \n    mindis = min(dists)\n    return min(mindis+dp[y][x],min(vals))\n        \n\ndef solvecaso():\n    n,m,k = map(int,input().split())\n    costder = [[int(x) for x in input().split()] for _ in range(n)]\n    costaba = [[int(x) for x in input().split()] for _ in range(n-1)]\n    if k%2:\n        for i in range(n):\n            for j in range(m):\n                print(-1, end=' ')\n            print()\n        return -1\n    k //= 2\n    \n    for ren in range(len(costder)):\n        for col in range(len(costder[ren])):\n            costder[ren][col] *= 2\n    for ren in range(len(costaba)):\n        for col in range(len(costaba[ren])):\n            costaba[ren][col] *= 2\n    \n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    dptemp = [[0 for _ in range(m)] for _ in range(n)]\n    # print(dp) # debug\n    \n    for i in range(k):\n        for y in range(n):\n            for x in range(m):\n                dptemp[y][x] = aburrimin(x, y, n, m, costder, costaba, dp)\n        dp, dptemp = dptemp, dp\n        # print(dp) # debug\n    \n    for ren in dp:\n        for num in ren:\n            print(num, end=' ')\n        print()\n    \n    return 0\n\n\nif __name__ == \"__main__\":\n    # casos = int(input()) #dbug\n    # for caso in range(1,casos+1):#dbug\n        # result = solvecaso()#dbug\n    solvecaso() #dbug\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import sys\nimport threading\n\ndef dfs(g, i, p):\n    global ans\n    count = 0\n    for j in g[i]:\n        if j == p:\n            continue\n        count += dfs(g, j, i)\n    if count == 0:\n        count = 1\n    ans.append(count)\n    return count\n\ndef solve():\n    \n    n = int(input())\n    l = list(map(int, input().split()))\n    g = [[] for i in range(n+1)]\n\n    for i in range(1, n):\n        g[i+1].append(l[i-1])\n        g[l[i-1]].append(i+1)\n\n    dfs(g, 1, 0)\n    ans.sort()\n    st = ' '.join(map(str, ans))\n    print(st)\n\nans = []\nmax_recur_size = 10**5*2 + 1000\nmax_stack_size = max_recur_size*500\n \nsys.setrecursionlimit(max_recur_size)\nthreading.stack_size(max_stack_size)\nthread = threading.Thread(target=solve)\nthread.start()", "complexity": "quadratic", "problem": "1056_D", "from": "CODEFORCES", "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"}
{"src": "a, b = map(int, input().split())\nx, y, z = map(int, input().split())\nneeda = 2 * x + y\nneedb = y + 3 * z\nprint(max(0, needa - a) + max(0, needb - b))", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "l,r = map(int,input().split())\n\np = l\nlp = -1\nwhile p:\n    p = p>>1\n    lp+=1\n\nq = r\nrp = -1\nwhile q:\n    q = q>>1\n    rp+=1\n\ns = max(lp,rp)\n\nn=0\n\nwhile s>=0:\n    if l>>s&1!=r>>s&1:\n        n |= (r>>s&1)<<s\n        break\n    s-=1\n\ns-=1\n\nwhile s>=0:\n    n |= 1<<s\n    s-=1\n\nprint(n)\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n = int(input())\nl = list( map( int, input().split() ) )\nans = max(l)\nfor i in range(n):\n    ans = min( ans, l[ i ] // max( i, n - i - 1 ))\nprint( ans )", "complexity": "linear", "problem": "1159_B", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "from collections import Counter\n\nn, k = map(int, input().split())\n\nfor p in range(n+1):\n    if p*(p+1)//2 - (n-p) == k:\n        print(n-p)\n        break\n", "complexity": "linear", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "def onseg(p,q,r):\n    return min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and \\\n           min(p[1], r[1]) <= q[1] <= max(p[1], r[1])\n\ndef orientation(p,q,r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n          (q[0] - p[0]) * (r[1] - q[1])\n \n    if (val == 0): return 0  # colinear\n    return 1 if val > 0 else 2 # clock or counterclock wise\n\ndef doint(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n \n    if o1 != o2 and o3 != o4:\n        return True\n \n    if o1 == 0 and onseg(p1, p2, q1): return True\n    if o2 == 0 and onseg(p1, q2, q1): return True\n    if o3 == 0 and onseg(p2, p1, q2): return True\n    if o4 == 0 and onseg(p2, q1, q2): return True\n \n    return False\n\nx0,y0,x1,y1,x2,y2,x3,y3 = map(int,input().split())\nx4,y4,x5,y5,x6,y6,x7,y7 = map(int,input().split())\n\nA = x0,y0\nB = x1,y1\nC = x2,y2\nD = x3,y3\na = x4,y4\nb = x5,y5\nc = x6,y6\nd = x7,y7\n\nif doint(A,B,a,b) or doint(A,C,a,b) or doint(A,D,a,b) or doint(B,C,a,b) or doint(B,D,a,b) or doint(C,D,a,b) or \\\n   doint(A,B,a,c) or doint(A,C,a,c) or doint(A,D,a,c) or doint(B,C,a,c) or doint(B,D,a,c) or doint(C,D,a,c) or \\\n   doint(A,B,a,d) or doint(A,C,a,d) or doint(A,D,a,d) or doint(B,C,a,d) or doint(B,D,a,d) or doint(C,D,a,d) or \\\n   doint(A,B,b,c) or doint(A,C,b,c) or doint(A,D,b,c) or doint(B,C,b,c) or doint(B,D,b,c) or doint(C,D,b,c) or \\\n   doint(A,B,b,d) or doint(A,C,b,d) or doint(A,D,b,d) or doint(B,C,b,d) or doint(B,D,b,d) or doint(C,D,b,d) or \\\n   doint(A,B,c,d) or doint(A,C,c,d) or doint(A,D,c,d) or doint(B,C,c,d) or doint(B,D,c,d) or doint(C,D,c,d):\n    print('YES')\nelse:\n    print('NO')\n\n", "complexity": "constant", "problem": "0994_C", "from": "CODEFORCES", "tags": "brute force"}
{"src": "# pylint: disable=unused-variable\n# pylint: enable=too-many-lines\n# * Just believe in yourself\n\n\n# @ Author @CAP\n# import numpy\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport math as M\nimport itertools as ITR\nfrom collections import defaultdict as D\nfrom collections import Counter as C\nfrom collections import deque as Q\nimport threading\nfrom functools import lru_cache, reduce\nfrom functools import cmp_to_key as CMP\nfrom bisect import bisect_left as BL\nfrom bisect import bisect_right as BR\nimport random as R\nimport string\nimport cmath, time\n\nenum = enumerate\nstart_time = time.time()\n\n# * Variables\n\nMOD = 1_00_00_00_007\nMA = float(\"inf\")\nMI = float(\"-inf\")\n\n# * Graph 8 direction\ndi8 = ((1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1))\n\n# * Graph 4 direction\ndi4 = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n# * Stack increment\n\n\ndef increase_stack():\n    sys.setrecursionlimit(2 ** 32 // 2 - 1)\n    threading.stack_size(1 << 27)\n    # sys.setrecursionlimit(10**6)\n    # threading.stack_size(10**8)\n    # t = threading.Thread(target=main)\n    # t.start()\n    # t.join()\n\n\n# * Region Funtions\n\n\ndef binary(n):\n    return bin(n)[2:]\n\n\ndef decimal(s):\n    return int(s, 2)\n\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return p\n\n\ndef maxfactor(n):\n    q = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            q.append(i)\n    if q:\n        return q[-1]\n\n\ndef factors(n):\n    q = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            q.append(i)\n            q.append(n // i)\n    return list(sorted(list(set(q))))\n\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(M.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    l.sort()\n    return l\n\n\ndef isPrime(n):\n    if n == 1:\n        return False\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if n % i == 0:\n                return False\n        return True\n\n\ndef seive(n):\n    a = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = False\n        p = p + 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            a.append(p)\n    prime[0] = prime[1] = False\n    return a, prime\n\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(M.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\n\ndef countchar(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if s[i] == ch:\n            c += 1\n        else:\n            break\n    return c\n\n\ndef str_counter(a):\n    q = [0] * 26\n    for i in range(len(a)):\n        q[ord(a[i]) - 97] = q[ord(a[i]) - 97] + 1\n    return q\n\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    maximum = 0\n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n                maximum = max(maximum, lis[i])\n    return maximum\n\n\ndef lcm(arr):\n    a = arr[0]\n    val = arr[0]\n\n    for i in range(1, len(arr)):\n\n        gcd = gcd(a, arr[i])\n        a = arr[i]\n        val *= arr[i]\n\n    return val // gcd\n\n\ndef ncr(n, r):\n    return M.factorial(n) // (M.factorial(n - r) * M.factorial(r))\n\n\ndef npr(n, r):\n    return M.factorial(n) // M.factorial(n - r)\n\n\n# * Make work easy funtions\n\n\ndef IF(c, t, f):\n    return t if c else f\n\n\ndef YES(c):\n    print(IF(c, \"YES\", \"NO\"))\n\n\ndef Yes(c):\n    print(IF(c, \"Yes\", \"No\"))\n\n\ndef yes(c):\n    print(IF(c, \"yes\", \"no\"))\n\n\ndef JA(a, sep=\" \"):\n    print(sep.join(map(str, a)))\n\n\ndef JAA(a, s=\"\\n\", t=\" \"):\n    return s.join(t.join(map(str, b)) for b in a)\n\n\ndef PS(a, s=\" \"):\n    print(str(a), end=s)\n\n\n# * Region Taking Input\n\n\ndef I():\n    return int(inp())\n\n\ndef F():\n    return float(inp())\n\n\ndef LI():\n    return list(map(int, inp().split()))\n\n\ndef LF():\n    return list(map(float, inp().split()))\n\n\ndef MATI(n):\n    return [LI() for i in range(n)]\n\n\ndef MATS(n):\n    return [list(inp()) for i in range(n)]\n\n\ndef IV():\n    return map(int, inp().split())\n\n\ndef FV():\n    return map(float, inp().split())\n\n\ndef LS():\n    return list(inp())\n\n\ndef S():\n    return inp()\n\n\n# * Region Fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# <==================================== Write The Useful Code Here ============================\n\n# < Make it one if there is some test cases\nTestCases = 0  # <=====================\n# < =======================================\n\"\"\"\n> Sometimes later becomes never. Do it now.\n! Be Better than yesterday.\n* Your limitation\u2014it\u2019s only your imagination.\n> Push yourself, because no one else is going to do it for you.\n? The harder you work for something, the greater you\u2019ll feel when you achieve it.\n! Great things never come from comfort zones.\n* Don\u2019t stop when you\u2019re tired. Stop when you\u2019re done.\n> Do something today that your future self will thank you for.\n? It\u2019s going to be hard, but hard does not mean impossible.\n! Sometimes we\u2019re tested not to show our weaknesses, but to discover our strengths.\n\"\"\"\n# @  Goal is to get Candidate Master\n\n\ndef solve():\n    a, b = IV()\n\n    if b - a + 1 < 3:\n        print(\"-1\")\n\n    elif a % 2 == 0:\n        print(a, a + 1, a + 2)\n\n    elif b - a + 1 > 3:\n        print(a + 1, a + 2, a + 3)\n    else:\n        print(-1)\n\n\n# * This is the Main Function\n\n\ndef main():\n    flag = 1\n    #! Checking we are offline or not\n    try:\n        sys.stdin = open(\n            \"c:/Users/Manoj Chowdary/Documents/python/CodeForces/contest-div-2/input.txt\",\n            \"r\",\n        )\n        sys.stdout = open(\n            \"c:/Users/Manoj Chowdary/Documents/python/CodeForces/contest-div-2/output.txt\",\n            \"w\",\n        )\n    except:\n        flag = 0\n\n    t = 1\n    if TestCases:\n        t = I()\n    for _ in range(1, t + 1):\n        solve()\n\n    if flag:\n        print(\"Time: %.4f sec\" % (time.time() - start_time))\n        localtime = time.asctime(time.localtime(time.time()))\n        print(localtime)\n        sys.stdout.close()\n\n\n# * End Region\n\n\nif __name__ == \"__main__\":\n\n    # ? Incresing Stack Limit\n    # increase_stack()\n\n    #! Calling Main Function\n    main()", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "n,s=map(int,input().split())\nx=s//n\nif x*n<s:\n    x+=1\nprint(x)", "complexity": "constant", "problem": "1061_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\nsys.setrecursionlimit(111111) \nINF=999999999999999999999999\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n \n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n \n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n \n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n \n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n \n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n \n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n \n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n \n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n \n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n \n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n \n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n \n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n \n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n \n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n \n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n \n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n \n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n \n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n \n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n \n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n \n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\ndef main():\n\n    mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n    ###CODE\n    tc = 1\n    for _ in range(tc):\n        n,k=ria()\n        a=ria()\n        a=sorted(a)\n        d=Counter(a)\n        ans=0\n        for i in a:\n            if d[i]:\n                ans+=1\n                d[i*k]=0\n        wi(ans)\n        \n           \n                     \n            \n        \n                \n        \n        \n            \n        \n        \n        \n        \n        \n\n    \n        \n        \n        \n                \n                \n        \n        \n        \n    \n\n        \n        \n        \n\n        \n                             \n        \n        \n        \n            \n        \n        \n                     \n        \n        \n                    \n        \n                     \n                    \n                    \n                \n                \n                    \n                \n        \n        \n            \n                   \n        \n                    \n\n        \n        \n                \n            \n            \n    \n            \n                        \n        \n    \n\n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    ", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "\"\"\"\n    Template written to be used by Python Programmers.\n    Use at your own risk!!!!\n    Owned by enraged(rating - 5 star at CodeChef and Specialist at Codeforces).\n\"\"\"\nimport sys\nimport bisect\nimport heapq\n# from math import *\nfrom collections import defaultdict as dd  # defaultdict(<datatype>) Free of KeyError.\nfrom collections import deque  # deque(list) append(), appendleft(), pop(), popleft() - O(1)\nfrom collections import Counter as c  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations as comb\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\n# sys.setrecursionlimit(2*pow(10, 6))\n# sys.stdin = open(\"input.txt\", \"r\")\n# sys.stdout = open(\"output.txt\", \"w\")\nmod = pow(10, 9) + 7\nmod2 = 998244353\ndef data(): return sys.stdin.readline().strip()\n\n\ndef out(var): sys.stdout.write(var)\n\n\ndef l(): return list(map(int, data().split()))\n\n\ndef sl(): return list(map(str, data().split()))\n\n\ndef sp(): return map(int, data().split())\n\n\ndef ssp(): return map(str, data().split())\n\n\ndef l1d(n, val=0): return [val for i in range(n)]\n\n\ndef l2d(n, m, val=0): return [[val for i in range(n)] for j in range(m)]\n\n\nn = int(data())\narr = l()\ndp = [[0 for j in range(500)] for i in range(500)]\ndp2 = [0 for i in range(501)]\nfor i in range(n):\n    dp[i][i] = arr[i]\ni = n-2\nwhile ~i:\n    j = i+1\n    while j < n:\n        dp[i][j] = -1\n        for k in range(i, j):\n            if (~dp[i][k] and dp[i][k]) == dp[k+1][j]:\n                dp[i][j] = dp[i][k]+1\n        j += 1\n    i -= 1\nfor i in range(1, n+1):\n    dp2[i] = pow(10, 9)\n    for j in range(i):\n        if ~dp[j][i-1]:\n            dp2[i] = min(dp2[i], dp2[j]+1)\nout(str(dp2[n]))\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "def check(x, y):\n    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])\n\nre = int(input())\na = [list(input()) for i in range(re)]\nb = [list(input()) for i in range(re)]\nfor i in range(4):\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = b[::-1]\n    for j in range(2):\n        if check(a, b):\n            print('Yes')\n            exit(0)\n        b = [s[::-1] for s in b]\n    c = [['' for t in range(re)] for u in range(re)]\n    for t in range(re):\n        for u in range(re):\n            c[t][u] = b[u][re - t - 1]\n    b = c[:]\n    if check(a, b):\n        print('Yes')\n        exit(0)\nprint('No')", "complexity": "quadratic", "problem": "0958_A1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n = int(input())\na = iter(map(int, input().split()))\nprev_type = 3\nprev_res = 2\ncurr_a = next(a)\nres = []\nfor _ in range(1):\n\tfor next_a in a:\n\t\tif next_a > curr_a:\n\t\t\tif prev_type == 1 or prev_res == 1:\n\t\t\t\tprev_res += 1\n\t\t\t\tif prev_res == 5:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tprev_res = 1\n\t\t\tprev_type = 1\n\t\telif next_a < curr_a:\n\t\t\tif prev_type == 2 or prev_res == 5:\n\t\t\t\tprev_res -= 1\n\t\t\t\tif prev_res == 1:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tprev_res = 5\n\t\t\tprev_type = 2\n\t\telse:\n\t\t\tif prev_type == 1:\n\t\t\t\tprev_res += 1\n\t\t\telif prev_type == 2:\n\t\t\t\tprev_res -= 1\n\t\t\telif prev_res != 2:\n\t\t\t\tprev_res = 2\n\t\t\telse:\n\t\t\t\tprev_res = 3\n\t\t\tprev_type = 3\n\t\tres.append(prev_res)\n\t\tcurr_a = next_a\n\telse:\n\t\tif prev_type == 1:\n\t\t\tres.append(prev_res + 1)\n\t\telif prev_type == 2:\n\t\t\tres.append(prev_res - 1)\n\t\telif prev_res != 1:\n\t\t\tres.append(1)\n\t\telse:\n\t\t\tres.append(2)\n\t\tprint(*res)\n\t\tbreak\nelse:\n\tprint('-1')\n", "complexity": "linear", "problem": "1032_C", "from": "CODEFORCES", "tags": "constructive algorithms,dp"}
{"src": "n, m = map(int, input().split())\na = list(map(int, input().split()))\nh = max(a)\na.sort()\na.reverse()\na.append(0)\nans = sum(a)\nfor i in range(n):\n    if a[i + 1] >= a[i]:\n        a[i + 1] = a[i] - 1\n    ans -= max(a[i] - a[i + 1], 1)\nprint(ans)", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import os\nimport sys\nfrom math import *\nfrom collections import *\n\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\n\n\ndef vsInput():\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA = \"abcdefghijklmnopqrstuvwxyz/\"\nM = 1000000007\nEPS = 1e-6\n\n\ndef Ceil(a, b):\n    return a // b + int(a % b > 0)\n\n\ndef value():\n    return tuple(map(int, input().split()))\n\n\ndef array():\n    return [int(i) for i in input().split()]\n\n\ndef Int():\n    return int(input())\n\n\ndef Str():\n    return input()\n\n\ndef arrayS():\n    return [i for i in input().split()]\n\n\n# -------------------------code---------------------------#\n\nn = int(input())\ns = input()\nans = 0\ncnt = 0\nfor x in s:\n    if x == \"x\":\n        cnt += 1\n        if cnt >= 3:\n            ans += 1\n    else:\n        cnt = 0\nprint(ans)\n", "complexity": "linear", "problem": "0978_B", "from": "CODEFORCES", "tags": "greedy,strings"}
{"src": "from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom math import inf\n\n\ndef solve():\n    n, m = map(int, input().split())\n    cnt = defaultdict(int)\n    res = []\n    for i in range(n):\n        A = list(map(int, list(input())))\n        res.append(A)\n        for j in range(m):\n            if A[j]:\n                cnt[j] += 1\n    valid = False\n    for r in res:\n        j = [i for i in range(m) if r[i]]\n        if all(cnt[i] > 1 for i in j):\n            valid = True\n            break\n    if valid:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = 1\n# t = int(input())\nwhile t:\n    t -= 1\n    solve()\n\n", "complexity": "quadratic", "problem": "0985_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "M = 1000000007\nx, k  = map(int,input().split())\nif x==0:\n    print(0)\nelse:\n    print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)    \n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\n\ndef dp(ri, gi, bi):\n    if ri>r or gi>g or bi>b:\n        return 0\n\n    if not list_memo[ri][gi][bi]==-1:\n        return list_memo[ri][gi][bi]\n    \n    list_memo[ri][gi][bi] = max(dp(ri+1, gi+1, bi)+r_c[ri]*g_c[gi], dp(ri+1, gi, bi+1)+r_c[ri]*b_c[bi], dp(ri, gi+1, bi+1)+g_c[gi]*b_c[bi])\n    return list_memo[ri][gi][bi]\n\n\nr, g, b = map(int, sys.stdin.readline().split())\n\nr_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)\ng_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)\nb_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)\n\n\nlist_memo = [[[-1]*(b+1) for _ in range(g+1)] for _ in range(r+1)]\n\nprint(dp(0, 0, 0))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nb = sorted(a,reverse=True)\ntotal = sum(a)\ngain = 0\nnum = 0\nfor x in range(len(b)):\n    gain += b[x]\n    num += 1\n    if gain>total/2:\n        break\nprint(num)", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "# from typing import List, Set, Dict, Tuple, Text, Optional\nfrom collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__  # type: ignore\n\n#########\n# INPUT #\n#########\n\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n    # type: () -> str\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\n##########\n# OUTPUT #\n##########\n\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n    # type: (str) -> None\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n    # type: (str) -> None\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\n###########\n# LIBRARY #\n###########\n\n\ndef bootstrap(f, stack=[]):\n  # Deep Recursion helper.\n  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst\n  # Usage:\n\n  # @bootstrap\n  # def recur(n):\n  #   if n == 0:\n  #     yield 1\n  #   yield (yield recur(n-1)) * n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\n\n'''\narrayInit([3, 4, 5], 0):\nInitialize 3-dim array with [3][4][5] with 0 as its initial value\n\nTested with:\nhttps://codeforces.com/contest/625/problem/B\n'''\n\n\nclass MDArray(object):\n  # Faster implementation of md array, using a single array and a lot of math.\n  '''\n  >>> x = MDArray([1, 2, 5], 5)\n  >>> x.get([0, 0, 0])\n  5\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.set([0, 1, 2], 3)\n  3\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.set([0, 1, 3], 1)\n  1\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.get([0, 1, 3])\n  1\n  '''\n\n  def __init__(self, dimensions, initial_value=0):\n    # type: (Iterable[int], Any) -> None\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n    # type: (Iterable[int]) -> Any\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n    # type: (Iterable[int], Any) -> Any\n    self.arr[self._index(indexes)] = value\n    return value\n\n\n#########\n# LOGIC #\n#########\n\ndef encode(row, col, n, m):\n  return row * m + col\n\n\ndef main(inp, out):\n  # type: (Input, Output) -> any\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = [-1] * (n*m*(k/2+1))\n\n  @bootstrap\n  def solve(node, remain):\n    if remain == 0:\n      yield 0\n\n    key = (node + remain * n * m)\n    mem = dp[key]\n    if mem != -1:\n      yield mem\n\n    result = []\n    for x in adj[node]:\n      result.append((yield solve(x[0], remain-1)) + x[1])\n    ans = min(result)\n    dp[key] = ans\n    yield ans\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(solve(node, k/2) * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\n\n###############\n# BOILERPLATE #\n###############\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "\"\"\"\n    Second Order Statistics\n\"\"\"\nn = int(input())\nsequence = [int(x) for x in input().split()]\nfirstOrderStatistics = min(sequence)\nif sequence.count(firstOrderStatistics) == len(sequence):\n    print(\"NO\")\nelse:\n    sequence = sorted(sequence)\n    secondOrderStatistics = sequence[0]\n    for i in sequence:\n        if(i > secondOrderStatistics):\n            secondOrderStatistics = i\n            break\n    print(secondOrderStatistics)", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "from sys import stdin, setrecursionlimit, stdout\n#setrecursionlimit(1000000) #use \"python\" instead of \"pypy\" to avoid MLE\nfrom collections import deque\nfrom math import sqrt, floor, ceil, log, log2, log10, pi, gcd, sin, cos, asin\nfrom heapq import heapify, heappop, heappush, heapreplace, heappushpop\nfrom bisect import bisect_right, bisect_left\ndef ii(): return int(stdin.readline())\ndef fi(): return float(stdin.readline())\ndef mi(): return map(int, stdin.readline().split())\ndef fmi(): return map(float, stdin.readline().split())\ndef li(): return list(mi())\ndef si(): return stdin.readline().rstrip()\ndef lsi(): return list(si())\nmod=1000000007\nres=['NO', 'YES']\n\n\n#######################################################################################\n###########################    M Y     F U N C T I O N S    ###########################\n#######################################################################################\n\n\n\n\n#######################################################################################\n###########################    M A I N     P R O G R A M    ###########################\n#######################################################################################\n\naa=[9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, 9999999999]\na=[9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889]\n\ntest=1\ntest_case=1\nwhile test<=test_case:\n    test+=1\n\n\n\n    n=ii()\n    if n in a:\n        n=9\n    if n<10:\n        print(n)\n        exit()\n    x=1\n    while a[x]<n:\n        x+=1\n    v=n-a[x-1]\n    z=v//(x+1)\n    z+=aa[x-1]\n    v%=x+1\n    #print(v, x, z)\n    if not v:\n        p=z%10\n    else:\n        z+=1\n        p=int(str(z)[v-1])\n    print(p)", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import sys\ninput = sys.stdin.readline\n\n\nn = int(input())\na = list(map(int,input().split()))\n\n\n#[i,j)\ndp = [[1000]*(n+1) for i in range(n+1)]\nval = [[0]*(n+1) for i in range(n+1)]\n\nfor i in range(n):\n    dp[i][i+1] = 1\n    val[i][i+1] = a[i]\n\n\nfor p in range(2,n+1):\n    for i in range(n-p+1):\n        j = i+p\n        for k in range(i+1,j):\n            if dp[i][k] == dp[k][j] == 1 and val[i][k] == val[k][j]:\n                dp[i][j] = 1\n                val[i][j] = val[i][k] + 1\n            else:\n                dp[i][j] = min(dp[i][j] , dp[i][k]+dp[k][j])\nprint(dp[0][n])\n\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n, m, k, l = map(int, input().split())\nif m > n:\n    print(-1)\nelif l + k > n:\n    print(-1)\nelse:\n    s = (l + k) // m + bool((l + k) % m)\n    if s * m > n:\n        print(-1)\n    else:\n        print(s)\n", "complexity": "constant", "problem": "1068_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\ns = list(str(input()))\nt = list(str(input()))\n \nfrom collections import Counter\ncs = Counter(s)\nct = Counter(t)\nif cs != ct:\n    print(-1)\n    exit()\n \nxs = [[] for _ in range(26)]\nxt = [[] for _ in range(26)]\nfor i in range(n):\n    j = ord(s[i])-ord('a')\n    xs[j].append(i)\n \nfor i in range(n):\n    j = ord(t[i])-ord('a')\n    xt[j].append(i)\n \nx = [-1]*n\nfor i in range(26):\n    for j, k in zip(xs[i], xt[i]):\n        x[j] = k\n \nans = []\nfor i in range(n):\n    for j in reversed(range(i+1, n)):\n        if x[j-1] > x[j]:\n            x[j-1], x[j] = x[j], x[j-1]\n            ans.append(j)\nprint(len(ans))\nprint(*ans)", "complexity": "quadratic", "problem": "1015_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from copy import deepcopy\ndef sol(n,m,k,aa,bb):\n    if k&1:\n        return [[-1] * m] * n\n    ans = [[float('inf')]*(m+2) for _ in range(n+2)]\n    k >>= 1\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            ans[i][j] = min(aa[i][j], aa[i][j-1], bb[i][j], bb[i-1][j])\n    for _ in range(k-1):\n        oans = deepcopy(ans)\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                ans[i][j] = min(\n                    aa[i][j]+oans[i][j+1],\n                    aa[i][j-1]+oans[i][j-1],\n                    bb[i][j]+oans[i+1][j],\n                    bb[i-1][j]+oans[i-1][j])\n\n    ans = ans[1:-1]\n    ans = [x[1:-1] for x in ans]\n    ans = [[2*x for x in a] for a in ans]\n    return ans\n\nn,m,k = map(int, input().split())\naa = [list(map(int, input().split())) for _ in range(n)]\ninf = float('inf')\nbb = [list(map(int, input().split())) for _ in range(n-1)]\naa = [[inf, *x, inf] for x in aa]\nbb = [[inf, *x, inf] for x in bb]\npad = [inf] * (m+1)\naa = [pad, *aa, pad]\npad = [inf] * (m+2)\nbb = [pad, *bb, pad]\nans = sol(n,m,k,aa,bb)\nprint('\\n'.join(' '.join(map(str, a)) for a in ans))\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "n = int(input())\na = [int(_) & 1 for _ in input().split()]\nv = [a[0]]\nfor i in range(1, n):\n    if v and v[-1] == a[i]:\n        v.pop()\n    else:\n        v.append(a[i])\nprint(\"NO\" if len(v) > 1 else \"YES\")\n", "complexity": "linear", "problem": "1092_D1", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "n = int(input())\nlimit_int = limit = decimal = 9\ncount = 0\nwhile True:\n    count += 1\n    if n <= limit:\n        difference = limit - n\n        position = difference % count\n        difference = difference // count\n        difference = decimal - difference\n        print(''.join(list(reversed(str(difference))))[position])\n        break\n    else:\n        decimal = int(str(limit_int) * (count + 1))\n        limit += int(str(limit_int) + '0' * count) * (count + 1)\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "'''\njitne bhi binary mai 2 ki power ones hai unhe lagega 2 ;\nnow i fill a dp table\n'''\nglobal fact,inv_fact\ndef make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):\n\tglobal fact, inv_fact\n\n\n\tmax_n = min(max_n, mod - 1)\n\n\tfact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)\n\tfact[0] = 1\n\tfor i in range(max_n):\n\t\tfact[i + 1] = fact[i] * (i + 1) % mod\n\n\tinv_fact[-1] = pow(fact[-1], mod - 2, mod)\n\tfor i in reversed(range(max_n)):\n\t\tinv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n\nmake_nCr_mod()\ndef comb(n, r):\n\tmod=10**9+7\n\tglobal fact,inv_fact\n\tres = 1\n\twhile n or r:\n\t\ta, b = n % mod, r % mod\n\t\tif a < b:\n\t\t\treturn 0\n\t\tres = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n\t\tn //= mod\n\t\tr //= mod\n\treturn res\ndef f():\n\tdp=[0]*(1000+100)\n\tdp[1]=1\n\n\tfor i in range(2,len(dp)):\n\t\to=bin(i).count(\"1\")\n\t\tif o==1:\n\t\t\tdp[i]=2\n\t\telse:\n\t\t\tdp[i]+=dp[o]+1\n\treturn dp\n\ndef bit(s,k):\n\tdp=f()\n\tl=[]\n\tans=0\n\tll=len(s)\n\tans=0\n\tones=0\n\tif k==0:\n\t\treturn 1\n\tfor i  in range(ll):\n\t\tif s[i]==\"0\":\n\t\t\tcontinue\n\t\telse:\n\t\t\tfor j in range(max(ones,1),1000):\n\t\t\t\tif dp[j]==k:\n\t\t\t\t\tans=(ans+comb(ll-i-1,j-ones))%(10**9+7)\n\t\t\t\t\tif i==0 and k==1:\n\t\t\t\t\t\tans-=1\n\t\tones+=1\n\tif dp[ones]==k:\n\t\tans+=1\n\treturn (ans)%(10**9+7)\n\n\n\ns=input().strip()\nk=int(input())\nprint(bit(s,k))", "complexity": "linear", "problem": "0914_C", "from": "CODEFORCES", "tags": "brute force,combinatorics,dp"}
{"src": "import sys\n\nn,a,b = map(int, sys.stdin.readline().strip().split(' '))\n\nans = []\ng = {i:set({}) for i in range(n)}\n\nif a > 1 and b > 1:\n\tprint(\"NO\")\nelif a == 1 and b == 1:\n\tif n == 1:\n\t\tprint(\"YES\")\n\t\tprint(\"0\")\n\telif n < 4:\n\t\tprint(\"NO\")\n\telse:\n\t\tfor i in range(n-1):\n\t\t\tg[i].add(i+1)\n\t\t\tg[i+1].add(i) \n\t\tfor i in range(n):\n\t\t\ttmp = []\n\t\t\tfor j in range(n):\n\t\t\t\tif i in g[j]:\n\t\t\t\t\ttmp.append('1')\n\t\t\t\telse:\n\t\t\t\t\ttmp.append('0')\n\t\t\tans.append(''.join(tmp))\n\t\tprint(\"YES\")\n\t\tprint('\\n'.join(ans))\nelse:\n\tswap = False\n\tif a == 1:\n\t\ta, b = b, a\n\t\tswap = True\n\tfor i in range(a-1,n-1):\n\t\tg[i].add(i+1)\n\t\tg[i+1].add(i) \n\tif swap:\n\t\tfor i in range(n):\n\t\t\ttmp = []\n\t\t\tfor j in range(n):\n\t\t\t\tif i == j:\n\t\t\t\t\ttmp.append('0')\n\t\t\t\telif i not in g[j]:\n\t\t\t\t\ttmp.append('1')\n\t\t\t\telse:\n\t\t\t\t\ttmp.append('0')\n\t\t\tans.append(''.join(tmp))\n\telse:\n\t\tfor i in range(n):\n\t\t\ttmp = []\n\t\t\tfor j in range(n):\n\t\t\t\tif i in g[j]:\n\t\t\t\t\ttmp.append('1')\n\t\t\t\telse:\n\t\t\t\t\ttmp.append('0')\n\t\t\tans.append(''.join(tmp))\n\tprint(\"YES\")\n\tprint('\\n'.join(ans))", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "n,m=map(int,input().split())\na=[int(input(),2)for _ in range(n)]\n \ns=t=0\nfor x in a:\n    t|=s&x\n    s|=x\nprint(('YES','NO')[all(x&s&~t for x in a)])", "complexity": "quadratic", "problem": "0985_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nif n <= 4:\n    print(\"YES\")\n    exit()\n\nA = [None]*n\n\nfor i in range(n):\n    A[i] = list(map(int,input().split()))\n\ndef is_colinear(a1,a2,a3):\n    if a1 == a2 or a2 == a3 or a1 == a3:\n        return True\n\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = a3\n\n    if x1 == x2 or x1 == x3 or x2 == x3:\n        return x1 == x2 == x3\n    if y1 == y2 or y1 == y3 or y2 == y3:\n        return y1 == y2 == y3\n    return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)\n\nX,Y,Z = A[0],A[1],A[2]\n\ndef good(X,Y):\n    # are X,Y on the same line?\n    bad = []\n    for i in range(n):\n        if not is_colinear(X,Y,A[i]):\n            bad.append(A[i])\n\n    if len(bad) <= 2:\n        return True\n\n    U,V = bad[0],bad[1]\n    for i in range(len(bad)):\n        if not is_colinear(U,V,bad[i]):\n            return False\n    return True\n\nif good(X,Y) or good(Y,Z) or good(X,Z):\n    print(\"YES\")\n    exit()\n\nprint(\"NO\")\nexit()\n", "complexity": "nlogn", "problem": "0961_D", "from": "CODEFORCES", "tags": "geometry"}
{"src": "n, k = list(map(int, input().split()))\n\nteams = []\nfor _ in range(n):\n    teams.append(list(map(int, input().split())))\n\nteams.sort(key=lambda x: x[0]*100 - x[1], reverse=True)\n\ncount = 0\n\nkth = teams[k-1][0]*100 + teams[k-1][1]\nfor t in teams:\n    if t[0]*100 + t[1] == kth:\n        count += 1\nprint(count)\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "#Winners never quit, quiters never win............................................................................\nfrom collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\n\ndef factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()    \ndef decimalToBinary(n): \n    return bin(n).replace(\"0b\", \"\")\n\ndef isPrime(n) : \n\tif (n <= 1) : \n\t\treturn False\n\tif (n <= 3) : \n\t\treturn True\n\n\t\n\tif (n % 2 == 0 or n % 3 == 0) : \n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) : \n\t\tif (n % i == 0 or n % (i + 2) == 0) : \n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number / 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number / i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x): \n    return (math.log10(x) / \n            math.log10(2)); \n\ndef isPowerOfTwo(n): \n    return (math.ceil(Log2(n)) == math.floor(Log2(n))); \n\n   \n#here we go......................\n#Winners never quit, Quitters never win\nn,m=map(int,input().split())\nc=list(map(int,input().split()))\nkk=get_frequency(c)\nif len(set(c))==n:\n    print(min(kk.values()))\nelse:\n    print(0)\n\n\n\n    \n", "complexity": "quadratic", "problem": "0961_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\n\ndef ask(x):\n    print('? %d'%x)\n    sys.stdout.flush()\n    x=int(input())\n    return x\n\nn=int(input())\nt=n//2\nif t&1:\n    print('! -1')\n    sys.stdout.flush()\n    sys.exit()\nl=1\nr=n\nwhile l<r:\n    mid=(l+r)>>1\n    if ask(mid)>=ask((mid+t-1)%n+1):\n        r=mid\n    else:\n        l=mid+1\nprint('! %d'%l)\nsys.stdout.flush()\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "S = input()\n\nans = 0\nmet = set()\n\nfor i in range(len(S)):\n    for j in range(i, -1, -1):\n        if S[j:i+1] in met:\n            ans = max(ans, i - j + 1)\n        else:\n            met.add(S[j:i+1])\n            \nprint(ans)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "def score(l):\n    return sum(x*(x%2 == 0) for x in l)\n\nres = 0\nns = list(map(int, input().split()))\nfor i in range(14):\n    l = list(ns)\n    for j in range(13):\n        l[(i+1+j) % 14] += l[i]//14 + (1 if (j+1) <= l[i]%14 else 0)\n    l[i] = l[i]//14\n    res = max(res, score(l))\n\nprint(res)\n", "complexity": "constant", "problem": "0975_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "from sys import exit\nx, k = map(int, input().split())\nif x == 0:\n    print(0)\n    exit(0)\nx = 2 * x - 1\nmod = 10**9 + 7\n\ndef pot(r, k):\n    if k == 0: return 1\n    if k % 2 == 1:\n        return r * pot(r, k - 1) % mod\n    y = pot(r, k // 2)\n    return y * y % mod\n\nprint((pot(2, k) * x + 1) % mod)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "def main():\n  n, k = map(int, input().split())\n  v = list(map(int, input().split()))\n \n  d = {}\n  ans = 0\n \n  for x in v:\n    num_d, mod_k = len(str(x)), x % k\n    d.setdefault(num_d, {}).setdefault(mod_k, []).append(x)\n \n  for x in v:\n    num_d, mod_k = len(str(x)), x % k\n    for add, mods in d.items():\n      val_mod = (mod_k * 10 ** add) % k\n      need_mod = (k - val_mod) % k\n      ans += len(mods.get(need_mod, []))\n      if need_mod == mod_k and add == num_d:\n        ans -= 1\n \n  print(ans)\n\n\nif __name__ == \"__main__\":\n  main()\n", "complexity": "nlogn", "problem": "1029_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import sys\ninput = sys.stdin.readline\nmaxn = int(1e5 + 10)\nST = [0] * (4 * maxn)\ndef update(id, l, r, val):\n    if l == r == val:\n        ST[id] = 1\n        return\n    if l > val or r < val:\n        return\n    mid = int((l + r) / 2)\n    update(id * 2, l, mid, val)\n    update(id * 2 + 1, mid + 1, r, val)\n    ST[id] = ST[id * 2] + ST[id * 2 + 1]\n    return\ndef get(id, l, r, x, y):\n    if l > y or r < x:\n        return 0\n    if x <= l and r <= y:\n        return ST[id]\n    mid = int((l + r) / 2)\n    return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y)\nn, res = int(input()), 0\nfor x in list(map(int, input().split())):\n    res ^= get(1, 1, n, x + 1, n) % 2\n    update(1, 1, n, x)\nfor i in range (int(input())):\n    x, y = list(map(int, input().split()))\n    if int((y - x) * (y - x + 1) / 2) & 1:\n        res ^= 1\n    if res:\n        print(\"odd\")\n    else:\n        print(\"even\")", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "n = int(input())\nx, y = 1, 9\nn -= 1\nwhile n > x * y:\n    n -= x * y\n    x += 1\n    y *= 10\na = 10 ** (x - 1) + n // x\nprint(str(a)[n % x])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import sys\ninput = sys.stdin.readline\n\n'''\n\n'''\n\nn = int(input())\na = list(map(int, input().split()))\nswaps = 0\nfor i in range(0, 2*n, 2):\n    if a[i] == a[i+1]:\n        continue\n    \n    c = a[i]\n    j = i + 2\n    while c != a[j]:\n        j += 1\n    \n    MIN = i+1\n    while j > MIN:\n        a[j], a[j-1] = a[j-1], a[j]\n        j -= 1\n        swaps += 1\n\nprint(swaps)\n", "complexity": "quadratic", "problem": "0995_B", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "t=int(input())\nfor ca in range(t):\n    asd=input().split()\n    n=int(asd[0])\n    k=int(asd[1])\n    if n>=40:\n        print(\"YES \"+str(n-1))\n    else:\n        ans=-1\n        for m in range(1,n+1):\n            asd=(4**m-1)//3\n            asd2=(2**m-1)**2\n            asd2*=(4**(n-m)-1)//3\n            asd+=asd2\n            if asd>=k and m*m<=k:\n                ans=n-m\n                break\n        if ans==-1:\n            print(\"NO\")\n        else:\n            print(\"YES \"+str(ans))\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2018/11/24 15:28\n\n\"\"\"\n\nQ = int(input())\nans = []\n\nfor i in range(Q):\n    l, r = map(int, input().split())\n    if l % 2 == 0 and r % 2 == 0:\n        ans.append((r-l)//2 + l)\n    elif l % 2 == 1 and r % 2 == 0:\n        ans.append((r-l+1)//2)\n    elif l % 2 == 1 and r % 2 == 1:\n        ans.append(0-(r-l)//2-l)\n    else:\n        ans.append(0-(r-l+1)//2)\n\nprint('\\n'.join(map(str, ans)))", "complexity": "constant", "problem": "1080_B", "from": "CODEFORCES", "tags": "math"}
{"src": "#winners never quit, quiters never win\nfrom collections import deque as de\nimport math\nfrom collections import Counter as cnt\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()    \n# A optimized school method based \n# Python3 program to check \n# if a number is prime \n\n\ndef isPrime(n) : \n\n\t# Corner cases \n\tif (n <= 1) : \n\t\treturn False\n\tif (n <= 3) : \n\t\treturn True\n\n\t# This is checked so that we can skip \n\t# middle five numbers in below loop \n\tif (n % 2 == 0 or n % 3 == 0) : \n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) : \n\t\tif (n % i == 0 or n % (i + 2) == 0) : \n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    # create an empty list and later I will\n    # run a for loop with range() function using the append() method to add elements to the list.\n    prime_factors = []\n\n    # First get the number of two's that divide number\n    # i.e the number of 2's that are in the factors\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number / 2\n\n    # After the above while loop, when number has been\n    # divided by all the 2's - so the number must be odd at this point\n    # Otherwise it would be perfectly divisible by 2 another time\n    # so now that its odd I can skip 2 ( i = i + 2) for each increment\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number / i\n\n\n    # Here is the crucial part.\n    # First quick refreshment on the two key mathematical conjectures of Prime factorization of any non-Prime number\n    # Which is - 1. If n is not a prime number AT-LEAST one Prime factor would be less than sqrt(n)\n    # And - 2. If n is not a prime number - There can be AT-MOST 1 prime factor of n greater than sqrt(n).\n    # Like 7 is a prime-factor for 14 which is greater than sqrt(14)\n    # But if the above loop DOES NOT go beyond square root of the initial n.\n    # Then how does that greater than sqrt(n) prime-factor\n    # will be captured in my prime factorization function.\n    # ANS to that is - in my first for-loop I am dividing n with the prime number if that prime is a factor of n.\n    # Meaning, after this first for-loop gets executed completely, the adjusted initial n should become\n    # either 1 or greater than 1\n    # And if n has NOT become 1 after the previous for-loop, that means that\n    # The remaining n is that prime factor which is greater that the square root of initial n.\n    # And that's why in the next part of my algorithm, I need to check whether n becomes 1 or not,\n    #This code is taken by rohan paul's github\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\n#here we go......................\n#winners never quit, quitters never win\nn,k=map(int,input().split())\na=list(map(int,input().split()))\nl=sorted(a, reverse=True)\ndic={}\ntotalprofit=0\nfor i in range(k):\n    totalprofit+=l[i]\n    if l[i] in dic:\n        dic[l[i]]+=1\n    else:\n        dic[l[i]]=1\nans=[]\ncount=0\nfor i in range(n):\n    if a[i] in dic:\n        count+=1\n        if dic[a[i]]==1:\n            del dic[a[i]]\n        else:\n            dic[a[i]]-=1\n        if not dic:\n            count-=1\n            ans.append(count+ n-i)\n            break\n        else:\n            ans.append(count)\n        count=0\n    else:\n        count+=1\nprint(totalprofit)\nprint(*ans) \n\n", "complexity": "nlogn", "problem": "1006_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "def gns():\n    return  list(map(int,input().split()))\nn=int(input())\nns=gns()\na='cslnb'\nb='sjfnb'\nns.sort()\nans=[]\nfor i in range(1,n):\n    if ns[i]==ns[i-1]:\n        ans.append(i)\nif len(ans)>=2 or sum(ns)==0:\n    print(a)\n    quit()\nif len(ans)==1:\n    i=ans[0]\n    if ns[i]==0 or ns[i]-1 in ns:\n        print(a)\n        quit()\n    r=sum(ns)-n*(n-1)//2\n    if r%2==0:\n        print(a)\n        quit()\n    else:\n        print(b)\n        quit()\nelse:\n    r=sum(ns)-n*(n-1)//2\n    if r%2==0:\n        print(a)\n        quit()\n    else:\n        print(b)\n\n", "complexity": "nlogn", "problem": "1191_D", "from": "CODEFORCES", "tags": "games"}
{"src": "n = int(input())\nans = []\nmult = 1\nwhile n > 3:\n    ans += [mult]*(n-n//2)\n    n //= 2\n    mult *= 2\nif n == 3:\n    ans += [mult, mult, mult*3]\nelif n == 2:\n    ans += [mult, mult*2]\nelse:\n    ans += [mult]\nprint(*ans)", "complexity": "logn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "a = list(map(int, input().split()))\n\nans = 0\nfor i in range(len(a)):\n    x = a[i]\n    b = [j for j in a]\n    b[i] = 0\n    for j in range(len(a)):\n        b[j] += x // 14\n    \n    for j in range(1, x % 14 + 1):\n        b[(i + j) % 14] += 1\n        \n    ans_now = 0\n    for j in b:\n        if j % 2 == 0:\n            ans_now += j\n    ans = max(ans_now, ans)\nprint(ans)", "complexity": "constant", "problem": "0975_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "import math\n\nt = int(input())\n\n\ndef eval_(n, k):\n    level = 0.5*math.log2(3*k+1)\n    if n > 30:\n        cond = (level - n) > 0\n    else:\n        cond = (3*k+1) > 4**n\n    if cond:\n        return \"NO\"\n    elif n == 2 and k == 3:\n        return \"NO\"\n    else:\n        level = math.floor(level)\n        # print(level)\n        if n > 5:\n            # return \"YES \" +  str(n - level)\n            temp = 1 + 0.5*math.log2(3*(k-1) + 1)\n            if n > temp:\n                return \"YES \" + str(n - 1)\n            else:\n                return \"YES  0\"\n        else:\n            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3\n            start = (4**(level)-1)//3\n            if k <=(start+delta):\n                return \"YES \" + str(n - level)\n            else:\n                return \"YES \" + str(n - level-1)\n\n\n\nfor i in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    print(eval_(n, k))", "complexity": "constant", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "a=[int(x) for x in input().split()]\nn=a[0]^a[1]\nx=bin(n)[2:]\n#print(x)\nf=0\nfor i in range(len(x)):\n    if x[i]=='1':\n        f=1\n        break\nl=len(x)-i\nsum=0\nfor i in range(l):\n   sum+=2**i\nif f==0:\n    sum=0\nprint(sum)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n = int(input())\na = list(map(int,input().split()))\ncost = list(map(int,input().split()))\nans  = float(\"inf\")\nfor i in range(n):\n    m,r = float(\"inf\"),float(\"inf\")\n    for j in range(i):\n        if a[j]<a[i]:\n            m = min(m,cost[j])\n    for k in range(i+1,n):\n        if a[k]>a[i]:\n            r = min(r,cost[k])\n    ans = min(ans,cost[i]+m+r)\nprint(ans if ans!=float(\"inf\") else -1)\n", "complexity": "quadratic", "problem": "0987_C", "from": "CODEFORCES", "tags": "brute force,dp,implementation"}
{"src": "import sys\n\nMOD = 10**9 + 7\n\nx,k = list(map(int,sys.stdin.readline().strip().split(' ')))\n\na = x*pow(2,k+1,MOD) % MOD \nb = (a - pow(2,k,MOD) + 1) % MOD\nprint(b if x != 0 else 0)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Feb 15 19:45:38 2019\n\n@author: avina\n\"\"\"\n\nn = int(input())\n\nl = []\nfor _ in range(n):\n    k,m = map(int, input().strip().split())\n    l.append((k,m))\n\nl.sort(key=lambda x:x[0]+x[1])\n\nlast = 0\nans = 1\n\nfor i in range(1,n):\n   if  abs(l[i][0] - l[last][0]) >= l[i][1] + l[last][1] :\n       last = i\n       ans = ans + 1\n       \nprint(ans)\n\n#l[i][0] - l[i][1] >= l[last][0] - l[last][1] and", "complexity": "nlogn", "problem": "0528_B", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "def subsets(S):\n    sets = []\n    len_S = len(S)\n    for i in range(1 << len_S):\n        subset = [S[bit] for bit in range(len_S) if i & (1 << bit)]\n        sets.append(subset)\n    return sets\n    \nn, l, r, x = list(map(int, input().split()))\nproblems = list(map(int, input().split()))\nres = 0\nfor m in subsets(problems):\n    if l <= sum(m) <= r and (max(m) - min(m)) >= x:\n        res += 1\nprint(res)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "n,k=list(map(int,input().split()))\n\nif k%2==0:\n    s=\".\"\n    s=s+\"#\"*(k//2)\n    s=s+\".\"*(n-len(s))\n    print(\"YES\")\n    print(\".\"*n)\n    print(s)\n    print(s)\n    print(\".\"*n)\n\nelse:\n    if k<=n-2:\n        a=\"#\"*k\n        s=\".\"*((n-k)//2)+a+\".\"*((n-k)//2)\n        print(\"YES\")\n        print(\".\"*n)\n        print(s)\n        print(\".\"*n)\n        print(\".\"*n)\n    else:\n        k=k-n+3\n        a=\"#\"*k\n        s=\".\"*((n-k)//2)+a+\".\"*((n-k)//2)\n        print(\"YES\")\n        print(\".\"*n)\n        print(\".\"+\"#\"*(n-2)+\".\")\n        s=list(s)\n        s[n//2]=\".\"\n        s=\"\".join(s)\n        print(s)\n        print(\".\"*n)", "complexity": "linear", "problem": "0980_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn,m = map(int,input().split())\n\nA = [None]*n\nlo,hi = 1<<32,-1<<32\nfor i in range(n):\n    A[i] = list(map(int,input().split()))\n    lo = min(min(A[i]), lo)\n    hi = max(max(A[i]), hi)\n\nbest = -1\nans = [-1,-1]\n\ndef possible(x):\n    global best, ans\n    # is the answer at least x?\n    M = [-1]*(1<<m)\n\n    for i in range(n):\n        mask = 0\n        for j in range(m):\n            if A[i][j] >= x:\n                mask += (1<<j)\n        M[mask] = i\n\n    for m0 in range(1<<m):\n        if M[m0] == -1:\n            continue\n\n        for m1 in range(1<<m):\n            if M[m1] == -1:\n                continue\n\n            if m0 | m1 == (1<<m) - 1:\n                if best < x:\n                    best = x\n                    ans = [M[m0]+1, M[m1]+1]\n\n                return True\n    return False\n\npossible(hi)\npossible(lo)\n\nwhile lo+1 < hi:\n    mid = (lo+hi)//2\n    if possible(mid):\n        lo = mid\n    else:\n        hi = mid\n\nprint(*ans)\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import math\ndef C1():\n    n, r = map(int, input().split())\n    x_cord = [int(x) for x in input().split()]\n\n    y_cord = []\n    # y cordinate of contacted Disk\n    contactedDisk = 0\n    for i, x in enumerate(x_cord):\n        if len(y_cord) == 0:\n            y_cord.append(r)\n        else:\n            y_cord.append(r)\n            for j in range(i):\n                diff = abs(x_cord[i] - x_cord[j])\n                if diff <= 2 * r:\n                    y_cord[i] = max(y_cord[i], math.sqrt(4*r*r - diff ** 2) + y_cord[j])\n\n\n    for i in y_cord:\n        print(i, end= \" \")\n\n\nif __name__=='__main__':\n    C1()\n\t   \t\t\t\t    \t\t\t\t\t\t\t\t \t\t  \t  \t \t", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "n = int(input())-1\nx = 1\ny = 9\nwhile n > x * y:\n    n -= x * y\n    y *= 10\n    x += 1\na = 10 ** (x - 1)\na += n // x\nprint(str(a)[n % x])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import os, sys\nfrom io import BytesIO, IOBase\nfrom copy import deepcopy\n\n\ndef main():\n    n = rint()\n    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []\n    for i in range(4):\n        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])\n    print(['No', 'Yes'][a2.mat in ans])\n\n\nclass Matrix:\n    def __init__(self, r, c, mat=None, id=None):\n        self.r, self.c = r, c\n\n        if mat != None:\n            self.mat = deepcopy(mat)\n        else:\n            self.mat = [[0 for i in range(c)] for j in range(r)]\n\n    def rotate(self):\n        mat0 = Matrix(self.c, self.r)\n\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]\n\n        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r\n        return self.mat\n\n    def flipv(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n    def fliph(self):\n        mat0 = Matrix(self.r, self.c)\n        for i in range(self.r):\n            for j in range(self.c):\n                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]\n\n        self.mat = deepcopy(mat0.mat)\n        return self.mat\n\n\n\n# FASTIO REGION\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nBUFSIZE = 8192\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nrstr = lambda: input().strip()\nrstrs = lambda: [str(x) for x in input().split()]\nrstr_2d = lambda n: [list(rstr()) for _ in range(n)]\nrint = lambda: int(input())\nrints = lambda: [int(x) for x in input().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\nif __name__ == '__main__':\n    main()\n", "complexity": "quadratic", "problem": "0958_A1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "\n# Problem: B. Bus of Characters\n# Contest: Codeforces - Codeforces Round #484 (Div. 2)\n# URL: https://codeforces.com/contest/982/problem/B\n# Memory Limit: 256 MB\n# Time Limit: 2000 ms\n# Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\nfrom sys import stdin\ndef get_ints(): return list(map(int, stdin.readline().strip().split()))\n\nn = int(input())\nar = get_ints()\n\nbus = sorted([ (ar[i], i+1) for i in range(n) ])\npa = [int(x) for x in input()]\nseq = []\n# print(bus)\ntail = 0\nfor p in pa:\n\tif p == 0:\n\t\tprint(bus[tail][1], end=\" \")\n\t\tseq.append(tail)\n\t\ttail+=1\n\telse:\n\t\tv = seq.pop()\n\t\tprint(bus[v][1],end=\" \")\n", "complexity": "nlogn", "problem": "0982_B", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "n, s = map(int, input().rstrip().split())\nif n <= s:\n    print(0)\n    exit()\nfor i in range(s, n + 2):\n    l = 0\n    for j in str(i):\n        l += int(j)\n    if i - l >= s:\n        break\nprint(max(n - i + 1, 0))", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n    # @timer\n    def __init__(self):\n        pass\n\n    def __call__(self):\n        n, m = map(int, input().strip().split())\n\n        y = 0\n        for _ in range(m):\n            x, d = map(int, input().strip().split())\n            if d >= 0:  \n                y += d * (n - 1) * n // 2\n            else:\n                if n % 2 != 0:\n                    l = (n - 1) // 2\n                    y += d * l * (l + 1)\n                else:\n                    l = n // 2\n                    y += d * (l * (l + 1) - l)\n            y += x * n\n        y /= n\n        print(f'{y:.9f}')\n\nsolver()()", "complexity": "linear", "problem": "1009_C", "from": "CODEFORCES", "tags": "greedy,math"}
{"src": "s = input()\nn = len(s)\nm = n - 1;\nwhile m > 0:\n    find = False\n    for i in range(0, n - m):\n        for j in range(i + 1, n - m + 1):\n            match = True\n            for k in range(0, m):\n                if s[i+k] != s[j+k]:\n                    match = False\n                    break\n            if match:\n                find = True\n                break\n        if find:\n            break\n    if find:\n        break\n    m -= 1\nprint(m)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "k = int(input())\ncount = 1\nnumber = 1\nresult = 0\nnumber1 = 1\nwhile True:\n    if number == 1:\n        if result + 9 < k:\n            result += 9\n            number = 20\n            number1 = 10\n        else:\n            break\n    elif number == 20:\n        if result + 180 < k:\n            result += 180\n            number += 10\n            number1 = 100\n        else:\n            break\n    else:\n        if result + 9 * number * 10**count < k:\n            result += 9 * number * 10**count\n            number += 10\n            count += 1\n            number1 *= 10\n        else:\n            break\n\nwhile True:\n    if count == 0:\n        break\n    if result + number * 10**count < k:\n        result += number * 10**count\n        number1 += 100 * 10**(count - 1)\n    else:\n        count -= 1\n\nwhile True:\n    if number == 1:\n        break\n    if result + number < k:\n        result += number\n        number1 += 10\n    else:\n        break\n\nwhile True:\n    if result + len(str(number1)) >= k:\n        print(str(number1)[k - result - 1])\n        break\n    else:\n        number1 += 1\n        result += len(str(number1))\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "n,p = map(int,input().split())\na  = list(map(int,input().split()))\nforward = [a[0]]\nfor i in range(1,n):\n    forward.append(forward[-1] + a[i])\nsm = sum(a)\nmx = -float('inf')\nfor i in range(n-1):\n    mx = max(mx,(forward[i]%p) + ((sm -forward[i] )%p))\nprint(mx)", "complexity": "linear", "problem": "0958_C1", "from": "CODEFORCES", "tags": "brute force"}
{"src": "l, r = map(int, input().split())\n\nif l == r:\n    print(0)\n    exit()\nbinr, binl = list(bin(r)[2:]), list(bin(l)[2:])\nbinl = ['0'] * (len(binr) - len(binl)) + binl\n# print(binl, binr)\nfor i in range(len(binl)):\n    if binl[i] != binr[i]:\n        binl = '1' * (len(binl[i:]))\n        break\n\nprint(int(binl, 2))", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "def digit(a):\n    s=0\n    while a:\n        s+=a%10\n        a//=10\n    return s\n\ndef big(n,s):\n    lo=1\n    hi=n\n    while lo<=hi:\n        mid=(lo+hi)//2\n        if mid-digit(mid)<s:\n            lo=mid+1\n        else:\n            hi=mid-1\n    return n-lo+1\n\na,b=map(int,input().strip().split())\nprint(big(a,b))", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "n, a, b = [int(i) for i in input().split()]\nlst = sorted([int(i) for i in input().split()])\nprint(lst[b]-lst[b-1])\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "\ndef STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nimport string\nimport sys\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter , defaultdict\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n#visited = [[False for i in range(m)] for j in range(n)]\n#sys.stdin = open(r'input.txt' , 'r')\n#sys.stdout = open(r'output.txt' , 'w')\n#for tt in range(INT()):\n\n\n#CODE\n\n\nn = INT()\nl  = []\nd = {}\nsm = 0\n\nfor i in range(n):\n    indx , y  = MAP()\n    #l.append([indx , y])\n    d[indx] = y\n    sm += y\n\nm = INT()\nfor i in range(m):\n    indx , y = MAP()\n    if indx in d :\n        sm -= d[indx]\n        sm += max(y , d[indx])\n    else:\n        sm += y\n\nprint(sm)\n\n\n\n", "complexity": "nlogn", "problem": "0981_B", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\nfrom math import factorial\nfrom collections import Counter, defaultdict\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\n\n# ------------------------------\n\ndef main():\n    n, k = RLL()\n    dp = [[0]*4 for _ in range(k+2)]\n    dp[1][0] = 1\n    dp[1][3] = 1\n    dp[2][1] = 1\n    dp[2][2] = 1\n\n    for i in range(2, n+1):\n        new = [[0]*4 for _ in range(k+2)]\n        for j in range(1, k+2):\n            for l in range(4):\n                new[j][l] += dp[j][l]\n                if l==0 or l==3:\n                    new[j][l]+=dp[j-1][l^3]\n                    new[j][l]+=(dp[j][1]+dp[j][2])\n                elif l==1 or l==2:\n                    new[j][l]+=(dp[j-1][0]+dp[j-1][3])\n                    if j-2>=0: new[j][l]+=dp[j-2][l^3]\n                new[j][l] = new[j][l]%mod\n        dp = new\n    print(sum(dp[k])%mod)\n\nif __name__ == \"__main__\":\n    main()\n\n", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "n, a, b = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nend_b = arr[b-1]\nstart_a = arr[b]\nif end_b < start_a:\n    print(start_a - end_b)\nelse:\n    print(0)\n", "complexity": "nlogn", "problem": "0169_A", "from": "CODEFORCES", "tags": "sortings"}
{"src": "import sys\n\ninput = sys.stdin.readline\n\nr, g, b = map(int, input().split())\nsticks = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)]\ndp, ans = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 # dp[i][j][k] is i largest red, j largest green, k largest blue\nfor i in range(r + 1):\n    for j in range(g + 1):\n        for k in range(b + 1):\n            if i < r and j < g:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])\n            if i < r and k < b:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])\n            if j < g and k < b:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n, t = [int(item) for item in input().split(' ')]\ncont, ans = list(), 2\nfor i in range(n):\n    hCenter, hLen = [float(item) for item in input().split(' ')]\n    # subArr = [hCenter - hLen / 2, hCenter + hLen / 2]\n    # cont.append(subArr)\n    cont.append([hCenter - hLen / 2, hCenter + hLen / 2])\n\n#print(f'before=> {cont}')\ncont.sort(key=lambda item: item[0])\n#print(f'after=> {cont}')\nfor i in range(n - 1):\n    gap = cont[i+1][0] - cont[i][1]\n    if gap > t:\n        ans += 2\n    elif gap == t:\n        ans += 1\n\nprint(ans)\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "#from collections import defaultdict\n#DPL=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]\nri,gi,bi=map(int,input().split())\nrr=sorted(list(map(int,input().split())))\ngr=sorted(list(map(int,input().split())))\nbr=sorted(list(map(int,input().split())))\ndp=[[[-1]*(bi+1) for i in range(gi+1)] for j in range(ri+1)]\ndef area(r,g,b):\n\tif dp[r+1][g+1][b+1]!=-1:\n\t\treturn dp[r+1][g+1][b+1]\n\tans=0\n\tif r>=0 and g>=0:\n\t\tans=max(ans,rr[r]*gr[g]+area(r-1,g-1,b))\n\tif r>=0 and b>=0:\n\t\tans=max(ans,rr[r]*br[b]+area(r-1,g,b-1))\t\n\tif b>=0 and g>=0:\n\t\tans=max(ans,br[b]*gr[g]+area(r,g-1,b-1))\t\n\tdp[r+1][g+1][b+1]=ans\n\treturn ans\nprint(area(ri-1,gi-1,bi-1))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n, = map(int,input().split())\n\ns = input()\nif s=='0':\n    print(0)\nelse:\n    print(\"1\"+\"0\"*s.count('0'))", "complexity": "linear", "problem": "0976_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nMAP=[list(input().strip()) for i in range(n)]\n\nT0=[[0]*(m+1) for i in range(n+1)]\nT1=[[0]*(m+1) for i in range(n+1)]\nY0=[[0]*(m+1) for i in range(n+1)]\nY1=[[0]*(m+1) for i in range(n+1)]\n\nfor i in range(n):\n    for j in range(m):\n        if MAP[i][j]==\"*\":\n            T0[i][j]=T0[i-1][j]+1\n            Y0[i][j]=Y0[i][j-1]+1\n\nfor i in range(n-1,-1,-1):\n    for j in range(m-1,-1,-1):\n        if MAP[i][j]==\"*\":\n            T1[i][j]=T1[i+1][j]+1\n            Y1[i][j]=Y1[i][j+1]+1\n\nANS=[[0]*m for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        score=min(T0[i][j],T1[i][j],Y0[i][j],Y1[i][j])\n        if score>=2:\n            ANS[i][j]=score\n\nT0=[[0]*(m+1) for i in range(n+1)]\nT1=[[0]*(m+1) for i in range(n+1)]\nY0=[[0]*(m+1) for i in range(n+1)]\nY1=[[0]*(m+1) for i in range(n+1)]\n\nfor i in range(n):\n    for j in range(m):\n        T0[i][j]=max(ANS[i][j],T0[i-1][j]-1)\n        Y0[i][j]=max(ANS[i][j],Y0[i][j-1]-1)\n\nfor i in range(n-1,-1,-1):\n    for j in range(m-1,-1,-1):\n        T1[i][j]=max(ANS[i][j],T1[i+1][j]-1)\n        Y1[i][j]=max(ANS[i][j],Y1[i][j+1]-1)\n\n\n\nSUF=[[\".\"]*m for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if T0[i][j] or T1[i][j] or Y0[i][j] or Y1[i][j]:\n            SUF[i][j]=\"*\"\n\nif SUF!=MAP:\n    print(-1)\nelse:\n    ANSLIST=[]\n    for i in range(n):\n        for j in range(m):\n            if ANS[i][j]!=0:\n                ANSLIST.append((i+1,j+1,ANS[i][j]-1))\n\n    print(len(ANSLIST))\n    for ans in ANSLIST:\n        print(*ans)\n", "complexity": "quadratic", "problem": "1015_E2", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "l,r=input().split(\" \")\nl,r=int(l),int(r)\nif (l % 2 != 0):\n    l+=1\nif (l + 2 > r):\n    print(-1);\nelse:\n    print(l,l+1,l+2)\n            \n                \n                \n", "complexity": "constant", "problem": "0483_A", "from": "CODEFORCES", "tags": "brute force,implementation,math,number theory"}
{"src": "n,d=[int(x) for x in input().split(\" \")]\na=[int(x) for x in input().split(\" \")]\npos=2\nfor i in range(n-1):\n    l=a[i]+d\n    r=a[i+1]-d\n    if l==r:\n        pos+=1\n    elif l<r:\n        pos+=2\nprint(pos)\n", "complexity": "linear", "problem": "1004_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n,k=map(int,input().split())\n\nar=[-1 for i in range(256)]\nls=list(map(int,input().split()))\n\nfor e in ls:\n    if ar[e]==-1:\n        tmp=max(0,e-k+1)\n        for i in range(tmp,e+1):\n            if ar[i]!=-1 and ar[i]!=i:\n                tmp+=1\n                continue\n            else:\n                while i<=e:\n                    ar[i]=tmp\n                    i+=1\n    print(ar[e],end=\" \")\n", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "from decimal import *\nar = [list(map(float, input().split())) for i in range(int(input()))]\ndp = [[0 for i in range(1 << 18)] for j in range(18)]\nn, ans = len(ar), 0\ndp[0][(1 << n) - 1] = 1\nfor i in range((1 << n) - 1, 0, -1):\n    for j in range(n):\n        if i & (1 << j) == 0:\n            continue\n        for k in range(n):\n            if i & (1 << k) != 0 or j == k:\n                continue\n            dp[j][i] = max(dp[j][i], dp[k][i ^ (1 << k)] * ar[k][j] + dp[j][i ^ (1 << k)] * ar[j][k])\nfor i in range(n):\n    ans = max(ans, dp[i][1 << i])\nprint('{:.6f}'.format(ans))", "complexity": "np", "problem": "0678_E", "from": "CODEFORCES", "tags": "bitmasks,dp,math,probabilities"}
{"src": "from itertools import chain\nfrom time import time\n\ndef main():\n\n    BITS = [1 << sh for sh in range(24)]\n    B2N = {v: u for u, v in enumerate(BITS)}\n\n    def getPt():\n        return tuple(map(int, input().split()))\n\n    def dist(ptA, ptB):\n        return sum(((u-v)**2 for u, v in zip(ptA, ptB)))\n\n    def getBits(val):\n        return tuple(filter(lambda x: x&val, BITS))\n\n    def chooseTwo(pool):\n        n = len(pool)\n        for i in range(n):\n            for j in range(i+1, n):\n                yield (pool[i], pool[j])\n\n    ori = getPt()\n    pts = []\n    N = int(input())\n\n    for _ in range(N):\n        pts.append(getPt())\n\n    vis = set([0])\n    mint = [0]+[1e8]*(1<<N) \n    pres = [None]*(1<<N) \n    allb = (1 << N)-1 \n    B2P = {BITS[u]: v for u, v in enumerate(pts)}\n    B2P[0] = ori\n    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}\n\n    getDP = lambda x: mint[x]\n    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \\\n                                + alld[p[0]][0] \\\n                                + alld[p[1]][0] \n\n    for stt in range(1<<N):\n        if stt not in vis:\n            continue\n\n        bits = getBits(~stt&allb)\n\n        sb = bits[0] if bits else None\n\n        for bit in bits:\n\n            newstt = stt | sb | bit\n            nd = newDist(stt, (sb, bit))\n            if getDP(newstt) > nd:\n                mint[newstt] = nd\n                pres[newstt] = sb | bit\n                vis.add(newstt)\n\n    print(mint[allb])\n    path = ['0']\n    stt = allb\n\n    while stt:\n\n        bits = getBits(pres[stt])\n        for bit in bits:\n            path.append(str(B2N[bit]+1))\n        path.append('0')\n\n        stt ^= pres[stt]\n\n    print(' '.join(path))\n\n\nimport sys\nst = time()\nmain()\nprint('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "a , b = list(map(int, input().split()))\nx, y, z = list(map(int, input().split()))\nans = 0\np = a - ((x*2) + y)\nq = b - ((z*3) + y)\n# print(p, q)\nif (p < 0 and q < 0):\n    print(abs(p) + abs(q))\nelif (p < 0):\n    print(abs(p))\nelif (q < 0):\n    print(abs(q))\nelse:\n    print(0)", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import re\nimport sys\nexit=sys.exit\nfrom bisect import bisect_left as bsl,bisect_right as bsr\nfrom collections import Counter,defaultdict as ddict,deque\nfrom functools import lru_cache\ncache=lru_cache(None)\nfrom heapq import *\nfrom itertools import *\nfrom math import inf\nfrom pprint import pprint as pp\nenum=enumerate\nri=lambda:int(rln())\nris=lambda:list(map(int,rfs()))\nrln=sys.stdin.readline\nrl=lambda:rln().rstrip('\\n')\nrfs=lambda:rln().split()\ncat=''.join\ncatn='\\n'.join\nmod=1000000007\nd4=[(0,-1),(1,0),(0,1),(-1,0)]\nd8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\n########################################################################\n\ns=rl()\nn=len(s)\nans=0\nfor i in range(n-1):\n  for j in range(i+1,n):\n    for k in range(n-j):\n      if s[i+k]!=s[j+k]:\n        break\n      ans=max(ans,1+k)\n\nprint(ans)\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "def countall(string, substring):\n    total = 0\n    for i in range(len(string)-len(substring)+1):\n        if string[i:i+len(substring)] == substring:\n            total += 1\n    return total\n\nn = input()\nallvalues = []\nfor i in range(len(n)):\n    for j in range(len(n)-1, i-1, -1):\n        if countall(n, n[i:j+1]) > 1:\n            allvalues.append(j-i+1)\n            break\n\ntry:\n    print(max(allvalues))\nexcept:\n    print(0)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import math\n\n\nn, r = map(int, input().split())\n\na = math.pi/n\nsin = math.sin(a)\nR = r*sin/(1-sin)\n\nprint(R)", "complexity": "constant", "problem": "1100_C", "from": "CODEFORCES", "tags": "binary search,geometry,math"}
{"src": "n = int(input())\nd = []\nfor i in range(n):\n    xx, ww = [int(i) for i in input().split()]\n    d.append([xx-ww, xx+ww])\nd.sort(key=lambda x:x[0])\nlast = -100000000000\nans = 0\nfor i in range(n):\n    if last <= d[i][0]:\n        last = d[i][1]\n        ans += 1\n    elif last > d[i][1]:\n        last = d[i][1]\nprint(ans)\n\n\n\n\n\n", "complexity": "nlogn", "problem": "0528_B", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n, v = map(int, raw_input().split())\n\nres=0\nfuel=0\nfor i in range(1,n):\n    miss = min(v-fuel, n-i-fuel)\n    res+=i*miss\n    fuel+=miss-1\n    if v-fuel==0:\n        print(res)\n        exit(0)\nprint(res)", "complexity": "linear", "problem": "1113_A", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "# import os\n\nn,m = map(int,input().split())\n\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nr = []\n\nfor i in a:\n    if i in b:\n        r.append(i)\nprint(' '.join(map(str, r)))\n\n\n", "complexity": "quadratic", "problem": "0994_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def power(x,y):\n\tmod=1000000007\n\tres = 1\n\twhile (y > 0):\n\t\tif (y &1):\n\t\t\tres = (res * x)%mod\n\t\ty = y >> 1 \n\t\tx = (x * x)%mod\n\treturn res;\nx,k=map(int,input().split())\nmod=1000000007\nfactor=power(2,k)\nfactor%=mod\nans=((2*factor*x)%mod-(factor)%mod + 1 + mod)%mod\nif x==0:\n\tprint(\"0\")\nelse:\n\tprint(ans)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\na = list(map(int, input().split()))\na = sorted(a, reverse=True)\ns1 = 0\ns2 = sum(a)\n\nfor i in range(len(a)):\n    s1 += a[i]\n    s2 -= a[i]\n    if s1 > s2:\n        break\n\nprint(i + 1)", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "# n, m = map(int, input().split())\n#\n# arr = [int(z) for z in input().split()]\n# modvals = []\n#\n# for i in range(n):\n#     modvals.append([arr[i] % m, i])\n#\n# modvals.sort()\n#\n# rem = {}\n# used = {}\n#\n# for i in range(m):\n#     rem[i] = 0\n#     used[i] = 0\n#\n# for i in modvals:\n#     rem[i[0]] += 1\n#\n# # print(rem)\n# cnt = 0\n#\n# mm1rec = []\n#\n# for i in range(n):\n#     elem = modvals[i]\n#\n#     if used[elem[0]] < n//m:\n#         used[elem[0]] += 1\n#     else:\n#         if elem[0] != m-1:\n#             used[elem[0]+1] += 1\n#             arr[elem[1]] += 1\n#             cnt += 1\n#         else:\n#             used[m - 1] += 1\n#             mm1rec.append(elem[1])\n#\n#\n# if used[m-1] > n//m:\n#     for i in range(m-1):\n#         elem = [i, 0]\n#         while used[i] < n//m:\n#             # arr[elem[1]] += abs(elem[0] + 1)\n#             used[i] += 1\n#             used[m - 1] -= 1\n#             arr[mm1rec[-1]] += abs(i + 1)\n#             mm1rec.pop()\n#             cnt += abs(i + 1)\n#\n#\n# print(cnt)\n#\n# arrstr = [str(z) for z in arr]\n#\n# print(' '.join(arrstr))\n#\n# #print(used, mm1rec)\n#\n#\n#\n#\n\nfrom collections import deque\n\nn, m = map(int, input().split())\n\narr = [int(z) for z in input().split()]\n\nmods = [0 for i in range(m)]\nplacement = [[] for i in range(m)]\n\n# for i in arr:\n#     mods[i % m] += 1\n#\n# for i in range(m):\n#     mods[i] -= n//m\n\nfor i in range(n):\n    mods[arr[i] % m] += 1\n    placement[arr[i] % m].append(i)\n\ncnt = 0\nqueue = deque()\ntarget = n//m\nfor i in range(2*m):\n    mod = i % m\n    if mods[mod] > n//m:\n        # cnt += mods[mod] - target\n        for c in range(mods[mod] - target):\n            queue.append([i, placement[mod][c]])\n        mods[mod] = target\n\n    elif mods[mod] < target:\n        while len(queue) > 0 and mods[mod] < target:\n            elem, indice = queue.popleft()\n            mods[mod] += 1\n            cnt += (mod - elem) % m\n            arr[indice] += (mod - elem) % m\n\nprint(cnt)\nprint(' '.join([str(i) for i in arr]))\n\n\n\n\n\n\n\n\n", "complexity": "linear", "problem": "0999_D", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "N, MOD = map(int, input().split())\ndp = [[0]*(N+2) for i in range(N+2)]\ndp[0][0] = 1\nlimit = 1000\nfrac = [1]*limit\nfor i in range(2,limit):\n    frac[i] = i * frac[i-1]%MOD\nfraci = [None]*limit\nfraci[-1] = pow(frac[-1], MOD -2, MOD)\nfor i in range(-2, -limit-1, -1):\n    fraci[i] = fraci[i+1] * (limit + i + 1) % MOD\nbb = [1, 2]\nfor i in range(1000):\n    bb.append(bb[-1] *2 %MOD)\nfor ln in range(N+1):\n    for cnt in range(ln//2, ln+1):\n        for k in range(1, N-ln+1):\n            cmb = frac[cnt+k] * (fraci[cnt]*fraci[k]%MOD)%MOD\n            dp[ln+k+1][cnt+k] += dp[ln][cnt] * (bb[k-1] * cmb % MOD) %MOD\n            dp[ln+k+1][cnt+k] %= MOD\nR = 0\nfor x in dp[N+1][:N+1]:\n    R = (R+x)%MOD\nprint(R)\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "n = int(input())\na = list(input())\nb = list(input())\n\ncount = 0\nskip_next = False\nfor idx in range(n - 1):\n    if skip_next:\n        skip_next = False\n        continue\n    if a[idx] != b[idx] and a[idx] == b[idx + 1] and a[idx + 1] == b[idx]:\n        count += 1\n        a[idx] = b[idx]\n        a[idx + 1] = b[idx + 1]\n        skip_next = True\n\nfor idx in range(n):\n    if a[idx] != b[idx]:\n        count += 1\n        # a[idx] = b[idx]\n\nprint(count)\n", "complexity": "linear", "problem": "1037_C", "from": "CODEFORCES", "tags": "dp,greedy,strings"}
{"src": "import math\nimport sys\nfrom collections import deque,defaultdict\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\ndef Extended_Euclid(n,m):\n    stack=[]\n    while m:\n        stack.append((n,m))\n        n,m=m,n%m\n    if n>=0:\n        x,y=1,0\n    else:\n        x,y=-1,0\n    for i in range(len(stack)-1,-1,-1):\n        n,m=stack[i]\n        x,y=y,x-(n//m)*y\n    return x,y\n\nclass MOD:\n    def __init__(self,p,e=1):\n        self.p=p\n        self.e=e\n        self.mod=self.p**self.e\n\n    def Pow(self,a,n):\n        a%=self.mod\n        if n>=0:\n            return pow(a,n,self.mod)\n        else:\n            assert math.gcd(a,self.mod)==1\n            x=Extended_Euclid(a,self.mod)[0]\n            return pow(x,-n,self.mod)\n\n    def Build_Fact(self,N):\n        assert N>=0\n        self.factorial=[1]\n        self.cnt=[0]*(N+1)\n        for i in range(1,N+1):\n            ii=i\n            self.cnt[i]=self.cnt[i-1]\n            while ii%self.p==0:\n                ii//=self.p\n                self.cnt[i]+=1\n            self.factorial.append((self.factorial[-1]*ii)%self.mod)\n        self.factorial_inv=[None]*(N+1)\n        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)\n        for i in range(N-1,-1,-1):\n            ii=i+1\n            while ii%self.p==0:\n                ii//=self.p\n            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod\n\n    def Fact(self,N):\n        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod\n\n    def Fact_Inv(self,N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inv[N]\n\n    def Comb(self,N,K,divisible_count=False):\n        if K<0 or K>N:\n            return 0\n        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod\n        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]\n        if divisible_count:\n            return retu,cnt\n        else:\n            retu*=pow(self.p,cnt,self.mod)\n            retu%=self.mod\n            return retu\n\ndef Bell_Numbers(N,mod,prime=False):\n    bell_numbers=[0]*(N+1)\n    bell_numbers[0]=1\n    MD=MOD(mod)\n    if prime:\n        MD.Build_Fact(min(mod-2,N-1))\n        for i in range(1,min(mod,N+1)):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n        for i in range(mod,N+1):\n            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod\n    else:\n        MD.Build_Fact(N-1)\n        for i in range(1,N+1):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n    return bell_numbers\n\nM,N=map(int,readline().split())\nS=[readline().rstrip() for i in range(N)]\ndct=defaultdict(int)\nfor i in range(M):\n    tpl=()\n    for j in range(N):\n        tpl+=(S[j][i],)\n    dct[tpl]+=1\nans=1\nmod=10**9+7\nbell=Bell_Numbers(M,mod)\nfor c in dct.values():\n    ans*=bell[c]\n    ans%=mod\nprint(ans)", "complexity": "quadratic", "problem": "0908_E", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,math"}
{"src": "n=int(input())\nl=list(map(int,input().split()))\nr=list(map(int,input().split()))\n\ncost=[(l[i]+r[i],i) for i in range(n)]\n\ncost.sort()\n\nCANDIES=[None]*n\nCANDIES[cost[0][1]]=n\n\ncandy=n\nfor i in range(1,n):\n    if cost[i][0]==cost[i-1][0]:\n        CANDIES[cost[i][1]]=candy\n    else:\n        candy-=1\n        CANDIES[cost[i][1]]=candy\n\n#print(CANDIES)\n\ncheck=1    \nfor i in range(n):\n    lc=0\n    rc=0\n    for j in range(i):\n        if CANDIES[j]>CANDIES[i]:\n            lc+=1\n    for j in range(i+1,n):\n        if CANDIES[j]>CANDIES[i]:\n            rc+=1\n\n    #print(i,lc,rc)\n\n    if lc!=l[i] or rc!=r[i]:\n        check=0\n\nif check==1:\n    print(\"YES\")\n    for c in CANDIES:\n        print(c,end=\" \")\n    #print(CANDIES)\nelse:\n    print(\"NO\")\n    #print(CANDIES)\n          \n    \n", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "def solve(x, y, n):\n    return \"White\" if (x-1 + y-1) <= (n-x + n-y) else \"Black\"\n\n\ndef main():\n    n = int(input())\n    x, y = [int(i) for i in input().split()]\n    print(solve(x, y, n))\n\n\nmain()\n", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "input()\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nu = [0] * len(a)\n\nans = 0\n\nfor i in range(len(a)):\n    if u[i] != 0:\n        continue\n    idx = i\n    while u[idx] == 0:\n        u[idx] = 1\n        idx = a[idx] - 1\n    \n    if (u[idx] == 2):\n        idx = i\n        while u[idx] == 1:\n            u[idx] = 2\n            idx = a[idx] - 1\n        continue\n\n    start = idx\n    mn = c[idx]\n    u[idx] = 2\n    while a[idx] - 1 != start:\n        idx = a[idx] - 1\n        mn = min(mn, c[idx])\n        u[idx] = 2\n\n    idx = i\n    while u[idx] == 1:\n        u[idx] = 2\n        idx = a[idx] - 1\n    ans += mn\nprint(ans)", "complexity": "linear", "problem": "1027_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs"}
{"src": "a = input()\nb = input()\n\nif len(a) < len(b):\n    a = sorted(a)[::-1]\n    print(''.join(a))\n    exit(0)\n\n\ndef check(res, j, a):\n    added = False\n    tmp = \"\"\n    for i in a:\n        if i == j and not added:\n            added = True\n        else:\n            tmp += i\n    tmp = res + j + tmp[::-1]\n    return tmp <= b\n\n\n# len(a) == len(b)\nres = \"\"\nn = len(a)\na = sorted(list(a))[::-1]\nfor i in range(n):\n    for j in a:\n        if check(res, j, a):\n            res += j\n            a.remove(j)\n            break\nprint(res)\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "\nclass Solver:\n    def solve(self):\n        self.num_people = int(input())\n\n        if self.num_people % 4 == 2:\n            return -1\n\n        return self.find_zero_pair()\n\n    def find_zero_pair(self):\n        begin = 1\n        end = self.num_people // 2 + 1\n\n        begin_value = self.func(begin)\n        if begin_value == 0:\n            return begin\n\n        while begin < end: \n            mid = (begin + end) // 2\n            mid_value = self.func(mid)\n            if mid_value == 0:\n                return mid\n            elif begin_value * mid_value > 0:\n                begin = mid + 1 \n            else:\n                end = mid - 1\n\n        return begin\n\n    def func(self, pos):\n        opposite = (pos - 1 + self.num_people // 2) % self.num_people + 1\n        return self.get_value(pos) - self.get_value(opposite)\n\n    def get_value(self, pos):\n        print('? {}'.format(pos))\n        value = int(input())\n        return value\n\nsolver = Solver()\npair = solver.solve()\nprint('! {}'.format(pair))\n", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "l,r=map(int,input().split())\nls=str(bin(l))[2:]\nrs=str(bin(r))[2:]\nllog=len(ls)\nrlog=len(rs)\nans=0\nif llog<rlog:\n    z=rlog-1\n    while z>-1:\n        ans+=2**z\n        z-=1\nelse:\n    ct=0\n    stringa=\"\"\n    for i in range(len(ls)):\n        if ls[i]==rs[i] and ct==0:\n            stringa+=ls[i]\n        if ls[i]==\"0\" and rs[i]==\"1\":\n            ct+=1\n            stringa+=ls[i]\n        if ls[i]==\"1\" and rs[i]==\"0\":\n            stringa+=ls[i]\n        if ls[i]==rs[i] and ct>0:\n            stringa+=str((int(rs[i])+1)%2)\n    ans=(int(stringa,2)^r)\nprint(ans)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "a=[i for i in input()]\nb=int(input())\na.sort(reverse=True)\nans = ''\nwhile len(a) > 0:\n    for i in range(len(a)):\n        tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:]))\n        if int(tmp) <= b:\n            ans += a[i]\n            a = a[:i] + a[i + 1:]\n            break\nprint(ans)\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "\ndef val(s):\n  ans = ((int(s.split('+')[0][1:]) + int(s.split('+')[1].split(')')[0])) / int(s.split('/')[1]))\n  return ans \n\nn = int(input())\ns = []\nf = {}\nfor i in range(n):\n  ss = input()\n  s.append(val(ss))\n  if(s[i] not in f):\n    f[s[i]] = 1 \n  else:\n    f[s[i]] += 1\n\nfor i in range(len(s)):\n  print(f[s[i]], end= \" \")\nprint()\n\n", "complexity": "linear", "problem": "0958_D1", "from": "CODEFORCES", "tags": "expression parsing,math"}
{"src": "n, q = map(int, input().split())\nA = list(map(int, input().split()))\nK = list(map(int, input().split()))\nfrom itertools import accumulate\nC = [0]+A\nC = list(accumulate(C))\ntotal = 0\nans = [0]*q\nimport bisect\nfor i, k in enumerate(K):\n    total += k\n    j = bisect.bisect_right(C, total)\n    if j != n+1:\n        ans[i] = n-(j-1)\n    else:\n        ans[i] = n\n        total = 0\nprint(*ans, sep='\\n')\n", "complexity": "nlogn", "problem": "0975_C", "from": "CODEFORCES", "tags": "binary search"}
{"src": "vals=list(map(int,input().split()))\nl=vals[0]\nr=vals[1]\n\nif l==r:\n    print(\"0\")\nelse:\n    i=0\n    j=0\n    while l>0 or r>0:\n        i+=1\n        if (l&1)^(r&1)==1:\n            j=i\n        l=l>>1\n        r=r>>1\n    ans=1\n    for i in range(0,j):\n        ans=ans*2\n    ans-=1\n    print(ans)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right \nfrom heapq import heappop,heappush,heapify, nlargest\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n\nn = inp()\na = inpl()\nres = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        if a[i] > a[j]:\n            res = 1-res\nfor _ in range(inp()):\n    l,r = inpl(); m = r-l+1\n    swap = m*(m-1)//2\n    if swap%2: res = 1-res\n    print('odd' if res else 'even')", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "k1,k2,k3=map(int,input().split())\na=[k1,k2,k3];a=sorted(a)\nif a[0]==1 or a.count(2)>=2 or a.count(3)==3:print(\"YES\")\nelif a.count(4)==2 and a.count(2)==1:print(\"YES\")\nelse:print(\"NO\")\n", "complexity": "constant", "problem": "0911_C", "from": "CODEFORCES", "tags": "brute force,constructive algorithms"}
{"src": "import math\n\nk,n,s,p = input().split()\nk = int(k)      #no of person\nn = int(n)      #no of planes each will make\ns = int(s)      #no of planes that can be made in one sheet\np = int(p)      #no of sheet in one pack\n\nsheet_for_each_person = math.ceil(n/s)\n# print(sheet_for_each_person)\ntotal_sheets_required = k*sheet_for_each_person\n# print(total_sheets_required)\nno_of_packs = math.ceil( total_sheets_required/p )\nprint(no_of_packs)", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n,k=[int(i) for i in raw_input().split()]\n\n\nM=10**9+7\ndef power(x,y):\n    if y==0:\n      return 1\n    z=(power(x,y/2)**2)%M\n    z=(z*x)%M if y%2 else z\n    return z%M\n\nz=(((2*n-1+M)%M)*power(2,k)+1)%M if n!=0 else 0\nprint(z)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys, copy\n \n \nn, m = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\nres = [0] * (max(arr) + 1)\nfor i in arr:\n    res[i] += 1\nans = 0\nfor d in range(1, m + 1):\n    temp = copy.deepcopy(res)\n    cnt = 0\n    for i in range(len(temp)):\n        while temp[i] >= d:\n            temp[i] -= d\n            cnt += 1\n    if cnt >= n:\n        ans = max(ans, d)\nprint(ans)", "complexity": "nlogn", "problem": "1011_B", "from": "CODEFORCES", "tags": "binary search,brute force,implementation"}
{"src": "def process(X, a, b):\n    X1 = set(X)\n    Other = set([])\n    A = set([])\n    B = set([])\n    Both = set([])\n    for x in X:\n        if a-x in X1 and b-x  not in X1:\n            A.add(x)\n            A.add(a-x)\n        elif a-x not in X1 and b-x in X1:\n            B.add(x)\n            B.add(b-x)\n        elif a-x not in X1 and b-x not in X1:\n            return 'NO'\n        else:\n            Both.add(x)\n    start = A.copy()\n    while len(start) > 0:\n        next_s = set([])\n        for x in start:\n            if b-x in Both:\n                Both.remove(b-x)\n                next_s.add(b-x)\n                if a-b+x in Both:\n                    Both.remove(a-b+x)\n                    A.add(a-b+x)\n                    next_s.add(a-b+x)\n                A.add(b-x)\n            if a-x in Both:\n                Both.remove(a-x)\n                next_s.add(a-x)\n                A.add(a-x)\n            elif a-x in B or a-x not in A:\n                return 'NO'\n        start = next_s\n    start = B.copy()\n    while len(start) > 0:\n        next_s = set([])\n        for x in start:\n            if a-x in Both:\n                Both.remove(a-x)\n                next_s.add(a-x)\n                if b-a+x in Both:\n                    Both.remove(b-a+x)\n                    B.add(b-a+x)\n                    next_s.add(b-a+x)\n                B.add(a-x)\n            if b-x in Both:\n                Both.remove(b-x)\n                next_s.add(b-x)\n                B.add(b-x)\n            elif b-x in A or b-x not in B:\n                return 'NO'\n        start = next_s\n    answer = []\n    for x in X:\n        if x in A:\n            answer.append(0)\n        else:\n            answer.append(1)\n    return answer\n\nn, a, b = [int(x) for x in input().split()]\nX = [int(x) for x in input().split()]\nanswer = process(X, a, b)\nif answer=='NO':\n    print('NO')\nelse:\n    print('YES')\n    print(' '.join(map(str, answer)))\n        \n                \n    \n            ", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "\nimport sys\n\n\ndef query(c, d):\n    print('? %d %d' % (c, d))\n    sys.stdout.flush()\n    res = int(input())\n    return res\n\na = 0\nb = 0\nbig = query(0, 0)\n\nfor i in range(29, -1, -1):\n    p = query(a ^ (1 << i), b)\n    q = query(a, b ^ (1 << i))\n    if p == q:\n        if big == 1:\n            a ^= 1 << i\n        else:\n            b ^= 1 << i\n        big = p\n    elif p == -1:\n        a ^= 1 << i\n        b ^= 1 << i\n\nprint('! %d %d' % (a, b))\nsys.stdout.flush()\n", "complexity": "logn", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "import math,io,os,sys\n# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n# sys.stdout.write(str(x) + \"\\n\")\n\nn,s=map(int,input().split())\nc=0\ni=n\nfor i in range(s,min(s+1000,n+1)):\n    if i-sum(map(int,str(i)))>=s:\n        c+=1\nc+=max(0,n-i)\nprint(c)\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "def nr(): return nrs()[0]\ndef nrs(): return [int(i) for i in input().split()]\n\nn = 10**7\nsquares = [i * i for i in range(1, 3162)]\n\np = list(range(n + 1))\nfor i in range(1, n + 1):\n\tif p[i] == i:\n\t\tfor sq in squares:\n\t\t\tif i * sq > n: break\n\t\t\tp[i * sq] = i\n\nfor _ in range(nr()):\n\tN, K = nrs()\n\tA = [p[a] for a in nrs()]\n\tdp = [N] * (K + 1)\n\tdp[0] = 1\n\tused = [{}] * (K + 1)\n\tfor a in A:\n\t\tfor j in range(K, -1, -1):\n\t\t\tif dp[j] == N: continue\n\t\t\tif a in used[j]:\n\t\t\t\tif j < K and dp[j + 1] > dp[j]:\n\t\t\t\t\tdp[j + 1] = dp[j]\n\t\t\t\t\tused[j + 1] = used[j]\n\t\t\t\tdp[j] += 1\n\t\t\t\tused[j] = {}\n\t\t\tused[j][a] = 1\n\tprint(min(dp))\n", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "def check(x,n,k):\n    ate = x\n    rem = n-ate\n    #print(rem,ate)\n    if rem*(rem+1)//2 == k+ate and rem >= 0 and ate >= 0:\n        return True\n\n    return False\n\ndef main():\n    n,k = map(int,input().split())\n    b = -1*(2*n+3)\n    a = 1\n    c = n**2\n    c += n-(2*k)\n\n    d = ((b**2)-(4*a*c))**0.5\n    x1 = (-b+d)/2*a\n    x2 = (-b-d)/2*a\n    #print(x1,x2)\n    if check(x1,n,k):\n        print(int(x1))\n        return\n\n    print(int(x2))\n    \n\nmain()\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "my_list = {\"purple\":\"Power\", \"green\":\"Time\", \"blue\":\"Space\", \"orange\":\"Soul\", \"yellow\":\"Mind\", \"red\":\"Reality\"}\n\nn = int(input())\nfor i in range(n):\n    my_list.pop(input())\n\nprint(len(my_list))\nfor i in my_list:\n    print(my_list[i])", "complexity": "constant", "problem": "0987_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\ndef input():    return sys.stdin.readline().strip()\ndef iinput():   return int(input())\ndef rinput():   return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\n\nn=iinput()\nd={}\nfor i in range(n - 1):\n    u,v=rinput()\n    d.setdefault(u,[]).append(v)\n    d.setdefault(v,[]).append(u)\nnode=1\nfor key in d:\n    if(len(d[key])>len(d[node])):\n        node=key\nans=[]\nvisited=[0]*n\nvisited[node-1]=1\nfor c in d[node]:\n    while(True):\n        visited[c-1]=1\n        if(len(d[c])==1):\n            ans.append([node,c])\n            break\n        for child in d[c]:\n            if(visited[child-1]!=1):\n                c=child\n                break\nif(sum(visited)==n):\n    print(\"Yes\")\n    print(len(ans))\n    for c in ans:\n        print(*c)\nelse:\n    print(\"No\")", "complexity": "linear", "problem": "0981_C", "from": "CODEFORCES", "tags": "implementation,trees"}
{"src": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\nimport math\n\ndef validation(n, k, x):\n    if (x*(x+1)) // 2 - (n-x) == k:\n        return 0\n    if (x * (x + 1)) // 2 - (n - x) > k:\n        return 1\n    return 2\n\nn, k = getList()\n\nl = 0\nr = 1000000001\nwhile(True):\n    mid = (l+r)//2\n    flag = validation(n, k, mid)\n    if flag == 0:\n        ans = mid\n        break\n    elif flag == 1:\n        r = mid\n    else:\n        l = mid\n\nprint(n - ans)\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n,m=map(int,input().split())\nlst=list(map(int,input().split()))\nmaxx=0\narr=[0]*(n+1)\nfor i in range(n):\n    summ=0\n    for j in range(i,n):\n        summ+=lst[j]\n        arr[j-i]=max(arr[j-i], summ/(j-i+1))\nprint(max(arr[m-1:]))", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "def func(k, a):\n    if len(a) == 1:\n        return 1\n    if k == 1:\n        return len(a)\n    s = set(a)\n    for x in sorted(a):\n        if x in s and k * x in s:\n            s.remove(k * x)\n    return len(s)\n\n\ndef read_ints():\n    return [int(x) for x in input().split(' ')]\n\n\ndef main():\n    n, k = read_ints()\n    a = read_ints()\n    assert n == len(a)\n    print(func(k, a))\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\nimport pprint\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n# sys.stdout = open('output.txt', 'w')\n\n\nn, m = ria()\nar = ria()\narc = []\nart = []\nres = []\nfor n, i in enumerate(ria()):\n    if i == 1:\n        art.append(ar[n])\n        res.append(0)\n    else:\n        arc.append(ar[n])\nnt = 0\nfor i in arc:\n    while nt != len(art) - 1 and abs(art[nt] - i) > abs(art[nt + 1] - i):\n        nt += 1\n    res[nt] += 1\n\nfor i in res:\n    print(i,end= ' ')", "complexity": "nlogn", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "def f_pow(a, n):\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    if n % 2 == 0:\n        return f_pow(a * a, n // 2)\n    else:\n        return a * f_pow(a, n - 1)\n\n\ndef get_c(n):\n    if(n > 68):\n        return int(1e40)\n    return (f_pow(4, n) - 4) // 12\n\ndef get_cc(n):\n    if(n > 51):\n        return int(1e30)\n    return (f_pow(4, n) - 4) // 12\n\ndef ans(n, k):\n    side = n - 1\n    way = 4\n    cnt_all = get_c(n + 1)\n    c = 2\n    op = 1\n    while (True):\n        if k < op or side < 0:\n            break\n        way_blocks = way - 1\n        if(get_cc(side - 1) > k):\n            return side\n        per_block = get_cc(side + 1)\n        kk = k - op\n        if cnt_all - way_blocks * per_block - op >= kk:\n            return side\n\n        side -= 1\n        op += (1 << c) - 1\n        c += 1\n        way *= 2\n    return -1\n\ndef read():\n    return [int(i) for i in input().split()]\n\n\nt = int(input())\n\nfor i in range(t):\n    n, k = read()\n    a = ans(n, k)\n    if(a == -1):\n        print(\"NO\")\n    else:\n        print(\"YES {}\".format(a))", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "import sys\nimport math\ninput = sys.stdin.readline\nfor _ in range(1):\n    n,pos,l,r = map(int,input().split())\n    if l == 1 and r == n:\n        print(0)\n        continue\n\n    if l != 1 and r != n:\n        ans = min(abs(l-pos),abs(r-pos))+2+abs(r-l)\n\n    else:\n        if l == 1:\n            ans = abs(pos-r)+1\n\n        else:\n            ans = abs(pos-l)+1\n\n    print(ans)", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\n\n\nn, k = [int(i) for i in sys.stdin.readline().split()]\n\n\nleft = 0\nright = n - 1\n\nwhile left <=  right:\n    mid = left + (right - left)//2\n    fmid = (mid+1)*(mid +2)/2  - (n  - (mid + 1))\n    if fmid == k:\n\n        print(n - 1 - mid )\n    if fmid > k:\n        right = mid - 1\n    else: # less or equal\n        left = mid + 1\n\n\n\n\n\n\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "\nr,g,b=map(int,input().split())\ns1=[int(x) for x in input().split()]\ns2=[int(x) for x in input().split()]\ns3=[int(x) for x in input().split()]\ns1.sort()\ns2.sort()\ns3.sort()\ns1=s1[::-1]\ns2=s2[::-1]\ns3=s3[::-1]\ns1=[0]+s1\ns2=[0]+s2\ns3=[0]+s3\n\ndp=[]\nfor i in range(r+5):\n    H=[]\n    for j in range(g+5):\n        h=[]\n        for k in range(b+5):\n            h.append(0)\n        H.append(h)\n    dp.append(H)\n\nfor i in range(0,r+1):\n    for j in range(0,g+1):\n        for k in range(0,b+1):\n            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0\n            if(i-1>=0 and j-1>=0):\n                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])\n            if(i-1>=0 and k-1>=0):\n                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])\n            if(k-1>=0 and j-1>=0):\n                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])\n            if(i-1>=0):\n                t4 = dp[i-1][j][k]\n            if(j-1>=0):\n                t5 = dp[i][j-1][k]\n            if(k-1>=0):\n                t6 = dp[i][j][k-1]\n\n            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)\n\n\n\nprint(dp[r][g][b])\n\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import math\n\np2 =[1] * 64\n\nfor i in range(1, 64):\n    p2[i] = p2[i-1] * 2\n    \ndef find_level(x):\n    x0 = 1\n    \n    for i in range(max_level+1):\n        if (x-x0) % (x0*2) == 0:\n            return i\n        x0 *=2\n    \ndef move_U(number):\n    cur_lv    =  find_level(number)\n    \n    if cur_lv == max_level:\n        return number\n    \n    x0      =   p2[cur_lv]\n    seg     =   x0 * 2 \n    index   =  (number - x0) // seg\n    \n    return (x0*2) + (index // 2) * (seg * 2) \n    \ndef move_L(number):\n    cur_lv    =  find_level(number)\n    \n    if cur_lv == 0:\n        return number\n    \n    x0      =   p2[cur_lv]\n    seg     =   x0 * 2 \n    index   =  (number - x0) // seg\n    \n    return (x0 // 2) + (index * 2) * (seg // 2)\n\ndef move_R(number):\n    cur_lv    =  find_level(number)\n    \n    if cur_lv == 0:\n        return number\n    \n    x0      =   p2[cur_lv]\n    seg     =   x0 * 2 \n    index   =  (number - x0) // seg\n    \n    return (x0 // 2) + (index * 2 + 1) * (seg // 2)\n\ndef move(s,num):\n    if s == 'U':\n        return move_U(num)\n    \n    if s == 'L':\n        return move_L(num)\n    \n    return move_R(num)\n    \ndef process(S, num):\n    for s in S:\n        num = move(s, num)\n    return num\n\nn, q = map(int, input().split())\nmax_level = int(math.log2(n+1)) - 1\nans  = ''\n\nfor _ in range(q):\n    num  = int(input())\n    S    = input()\n    ans += str(process(S, num)) + '\\n'\n    \nprint(ans)    \n\n#15 2\n#4\n#UURL\n#8\n#LRLLLLLLLL", "complexity": "np", "problem": "0792_D", "from": "CODEFORCES", "tags": "bitmasks,trees"}
{"src": "n,a,b,c,t=map(int,input().split())\nl=list(map(int,input().split()))\nif c>b:\n    r=0\n    for i in l:\n        k=t-i\n        k*=(c-b)\n        r+=k\n    print(a*n+r)\nelse:\n    print(a*n)\n", "complexity": "linear", "problem": "0964_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef check(mid: int) -> bool:\n    global ans\n    dic = {}\n    for i in range(n):\n        bit = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                bit += 1\n            bit <<= 1\n        dic[bit >> 1] = i\n    for x, idx in dic.items():\n        for y, idy in dic.items():\n            if x | y == 2**m-1:\n                ans = idx + 1, idy + 1\n                return True\n    return False\n\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nans = []\nle = 0\nri = int(1e9)\nwhile le <= ri:\n    mid = (le + ri) >> 1\n    if check(mid):\n        le = mid + 1\n    else:\n        ri = mid - 1\nprint(ans[0], ans[1])\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import itertools\n\ndef q121a_v2():\n\tgood_num_arr = generate_47_arr()\n\tnum = int(input())\n\tfor element in good_num_arr:\n\t\tif(num % element == 0):\n\t\t\tprint(\"YES\")\n\t\t\treturn\n\tprint(\"NO\")\n\n\ndef generate_47_arr():\n\tarr = []\n\tfor digits in range(1, 4):\n\t\tarr += itertools.product(\"47\", repeat=digits)\n\tfor i in range(len(arr)):\n\t\tarr[i] = int(\"\".join(list(arr[i])))\n\tarr.append(4444444444)\n\treturn arr\n\nq121a_v2()", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "from sys import *\n\nn, k = map(int, stdin.readline().split())\narr = list(map(int, stdin.readline().split()))\navg = 0\nfor i in range(n):\n\tcnt = 0\n\tsum = 0\n\tfor j in range(i, n):\n\t\tsum += arr[j]\n\t\tcnt += 1\n\t\tif cnt >= k:\n\t\t\tavg = max(avg, sum / cnt)\nprint(avg)", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "n,q = map(int, raw_input().split())\nnums = list(map(int, raw_input().split()))\n\"\"\"\nalgo:\nstore the combos until the maximum element reaches the front of the deque\nthen the order of the rest of the deque only changes by 2nd element going to end\nso let cutoff = number of operation which causes the max element to reach front\nif mj <= cutoff then output mjth combo stored\nif mj > cutoff  then output = (max, (mj-cutoff-1)%(len-1)+1)\n\"\"\"\n\nm = max(nums)#max element\n# print(nums)\n# print(m)\nab = []\nwhile nums[0] < m:\n    ab.append([nums[0], nums[1]])\n    nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0))\n# print(ab)\n\nfor i in range(q):\n    mj = int(input())\n    a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1]))\n    print(a + \" \" + b)\n", "complexity": "linear", "problem": "1179_A", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "n,s=map(int,input().split())\na=[0]*(n+1)\n\nif n==2:\n  print(s)\n  exit(0)\n\nfor _ in range(n-1):\n  u,v=map(int,input().split())\n  a[u]+=1\n  a[v]+=1\n\nprint(2.0*s/a.count(1))", "complexity": "linear", "problem": "1086_B", "from": "CODEFORCES", "tags": "greedy,implementation,trees"}
{"src": "from math import factorial\ndef C(m,n):\n    return factorial(n) // (factorial(m) * factorial(n - m))\n\ncommand_1, command_2 = input(), input()\nnum = command_2.count('?')\ni = command_1.count('+') - command_1.count('-') -\\\ncommand_2.count('+') + command_2.count('-') + num\nif i % 2 == 0 and 0 <= i//2 <= num:\n    print(\"%.9f\"%(C(i//2, num) / 2**num))\nelse:\n    print(\"0.000000000\")", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\na = sorted(a)\n\ncur_v = a[0]\ncur_count = 1\nans = 0\n\n# print(a)\nfor i in range(1, len(a)):\n\n    if a[i] > a[i-1] and a[i] > a[i-1]+k:\n        ans += cur_count\n        cur_count = 1\n    elif a[i] == a[i-1]:\n        cur_count += 1\n    elif a[i] > a[i-1]:\n        cur_count = 1\n        \nans += cur_count\n\n        \nprint(ans)", "complexity": "nlogn", "problem": "0990_B", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "for _ in range(int(input())):\n    s = input()\n    t = input()\n    if len(t) == 1:\n        print(\"YES\" if t in s else \"NO\")\n        continue\n    nxt = [[-1] * 26 for _ in range(len(s) + 1)]\n    nxt[-2][ord(s[-1]) - ord('a')] = len(s) - 1\n    for i in range(len(s) - 2, -1, -1):\n        for c in range(26):\n            nxt[i][c] = nxt[i + 1][c]\n        nxt[i][ord(s[i]) - ord('a')] = i\n    ans = \"NO\"\n    for p in range(len(t)):\n        a = t[:p]\n        b = t[p:]\n        dp = [[-1] * (len(b) + 1) for _ in range(len(a) + 1)]\n        dp[0][0] = 0\n        for la in range(len(a) + 1):\n            for lb in range(len(b) + 1):\n                if dp[la][lb] != -1:\n                    if la < len(a):\n                        if dp[la + 1][lb] != -1:\n                            if nxt[dp[la][lb]][ord(a[la]) - ord('a')] != -1:\n                                if nxt[dp[la][lb]][ord(a[la]) - ord('a')] < dp[la + 1][lb] - 1:\n                                    dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]\n                                    dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])\n                        else:\n                            dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]\n                            dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])\n                    if lb < len(b):\n                        if dp[la][lb + 1] != -1:\n                            if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] != -1:\n                                if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] < dp[la][lb + 1] - 1:\n                                    dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]\n                                    dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])\n                        else:\n                            dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]\n                            dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])\n                if dp[len(a)][len(b)] != -1:\n                    ans = \"YES\"\n                    break\n    print(ans)\n", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "n,s=list(map(int,input().split()))\nif n-sum([int(x) for x in str(n)])<s:\n    print(0)\nelse:\n    def check(n):\n\n        # print(n-sum([int(x) for x in str(n)])>s)\n        return (n-sum([int(x) for x in str(n)]))>=s\n    start=1\n    end=n\n    mid=(start+end)//2\n    while mid !=end and mid!=start:\n\n        if check(mid):\n            end=mid\n            mid=(start+end)//2\n        else:\n            start=mid\n            mid = (start + end) // 2\n            # print(start,mid,end)\n    print(n-end+1)\n\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "x, k = list(map(int,input().split()))\nm = 1000000000 +7\nif x!=0:\n    p1 = x*2 - 1\n    p2 = x*2\n    p = (p1 + p2)//2\n    print((p*pow(2,k,m) + 1)%m)\nelse:\n    print(x*2)\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n,s=map(int,input().split())\ncount=0\nfor i in range(n):\n    count+=(s//(n-i))\n    s-=(s//(n-i))*(n-i)\nprint(count)\n", "complexity": "constant", "problem": "1061_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "mod = 10**9+7\nx, k = map(int, input().split(' '))\nif (x == 0):\n    print(0)\nelse:\n    val1 = pow(2,k+1,mod) * x\n    val2 = pow(2, k, mod) - 1\n    val1 -= val2\n    val1 %= mod\n    print(val1)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "def prefix_func(s):\n    slen, k = len(s), 0\n    p = [0]*slen\n    p[0] = 0\n    for i in range(1, slen):\n        while k>0 and s[k] != s[i]:\n            k = p[k-1]\n        if s[k] == s[i]:\n            k += 1\n        p[i] = k\n    return p\nn,k=map(int,input().split())\ns=input()\nl=prefix_func(s)[-1]\nprint(s+s[l:]*(k-1))\n", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "n,m=map(int,input().split())\nc=0;ans=str()\nfor i in range(n):\n  ans+=str(c^1)\n  c=c^1\nprint(ans)\n", "complexity": "linear", "problem": "1004_B", "from": "CODEFORCES", "tags": "constructive algorithms,greedy,implementation,math"}
{"src": "n = int(input())\nprint(int(3 * n / 2))", "complexity": "constant", "problem": "0084_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import sys\nk=int(input())\nif type(k)!=int or k<=0 or k>pow(10,12) :\n        print(\"wrong input. try again\")\n        sys.exit()\nlim_init=lim=decimal=9\nc=0\nwhile True:\n        c+=1\n        if k<=lim:\n                diff=lim-k #189-21\n                pos=diff%c\n                diff=int(diff/c) #168/2=84\n                diff=decimal-diff #99-84\n                print(''.join(list(reversed(str(diff))))[pos])\n                break\n        else:\n                decimal = int(str(lim_init)*(c+1))\n                lim+=int(str(lim_init)+'0'*c)*(c+1)\n", "complexity": "constant", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\n# from math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ntry:\n    # sys.setrecursionlimit(int(pow(10,6)))\n    sys.stdin = open(\"input.txt\", \"r\")\n    # sys.stdout = open(\"../output.txt\", \"w\")\nexcept:\n    pass\ndef pmat(A):\n    for ele in A:\n        print(*ele,end=\"\\n\")\n\n\nn=L()[0]\nA=sorted(L())\nif A==[1]*n:\n    print(*A[:n-1],2)\nelse:\n    print(1,*A[:-1])\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\nendtime = time.time()\n# print(f\"Runtime of the program is {endtime - starttime}\")", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import atexit\nimport io\nimport sys\n\n# Buffering IO\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n    \n\ndef main():\n    n = int(input())\n    s = []\n    for i in range(4):\n        df = 0\n        for k in range(n):\n            l = input()\n            for j in range(n):\n                if int(l[j]) == (k + j) % 2:\n                    df += 1\n        if i <3 :\n            input()\n        s.append(df)\n    \n    print( min(s[0] + s[1] + n*n-s[2] + n*n-s[3],\n        s[0] + s[2] + n*n-s[1] + n*n-s[3],\n        s[0] + s[3] + n*n-s[1] + n*n-s[2],\n        s[1] + s[2] + n*n-s[0] + n*n-s[3],\n        s[1] + s[3] + n*n-s[0] + n*n-s[2],\n        s[2] + s[3] + n*n-s[0] + n*n-s[1]))\n        \n        \n    \n    \n    \n\n    \nif __name__ == '__main__':\n    main()\n        ", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "from itertools import chain, combinations\ndef powerset(iterable):\n    xs = list(iterable)\n    # note we return an iterator rather than a list\n    return list(chain.from_iterable(combinations(xs,n) for n in range(2,len(xs)+1)))\nn,l,r,x=map(int,input().split())\nsett=list(map(int,input().split()))\npsett=powerset(sett)\ncount=0\nfor i in psett:\n    k=sorted(i)\n    j=sum(k)    \n    if j>=l and j<=r and k[-1]-k[0]>=x:\n        count+=1\nprint(count)\n\n\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "from sys import stdin\nfrom functools import reduce\nfrom operator import ior\ndef get_ints(): return list(map(int, stdin.readline().strip().split()))\n\nnk ,m = get_ints()\na = [int(input(),2) for x in range(nk)]\nif nk == 1:\n\tprint(\"NO\")\n\texit()\nnum =  reduce(ior,a)\nfor i in range(nk):\n\tk = a.copy()\n\tk.pop(i)\n\tn = reduce(ior,k)\n\tif n == num:\n\t\tprint(\"YES\")\n\t\texit()\nprint(\"NO\")", "complexity": "quadratic", "problem": "0985_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys, string\n\nn, m = map(int, sys.stdin.readline().split())\nprint('4' * 2229)\nprint('5' * 2228 + '6')", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "from math import factorial\ns=input()\ns1=input()\nplus=s.count('+')-s1.count('+')\nminus=s.count('-')-s1.count('-')\nn=s1.count('?')\nif plus<0 or minus<0:\n    print(0)\nelse:\n    print((factorial(n)/factorial(n-plus)/factorial(plus))*(0.5**n))", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "def suma(n):\n    return n*(n+1)//2\n\ndef sumaij(i, j):\n    if i <= 1:\n        return suma(j)\n    return suma(j) - suma(i-1)\n\ndef bin_search_solution(n, k):\n    st, end = 1, k\n    while st < end:\n        mid = (st+end)//2\n        s = sumaij(mid, k)\n        if s == n:\n            return k - mid + 1\n        if s > n:\n            st = mid + 1\n        else:\n            end = mid\n    return k - st + 2\n            \n\ndef solve():\n    n, k = map(int, input().split())\n    if n == 1:\n        print(0)\n    elif k >= n:\n        print(1)\n    else:\n        n -= 1\n        k -= 1\n    \n        if suma(k) < n:\n            print(-1)\n        else:\n            res = bin_search_solution(n, k)\n            print(res)\n\nif __name__ == '__main__':\n    solve()\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "import os, sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nn,m,k=map(int,input().split())\nrow=[]\nfor _ in range(n):\n    row.append([10**6+2]+list(map(int,input().split()))+[10**6+2])\ncol=[[10**6+2]*(m+2)]\nfor _ in range(n-1):\n    col.append([10**6+2]+list(map(int,input().split()))+[10**6+2])\ncol.append([10**6+2]*(m+2))\nif  k%2:\n    dp=[[-1 for i in range(m)] for j in range(n)]\nelse:\n    k=k//2\n    dp = [[0 for i in range(m)] for j in range(n)]\n    for i in range(n):\n        for j in range(m):\n            dp[i][j]=2*min(row[i][j],row[i][j+1],col[i][j+1],col[i+1][j+1])\n    k-=1\n    while k:\n       # print(row,col)\n        k-=1\n        temp = [[0 for i in range(m)] for j in range(n)]\n        for i in range(n):\n            for j in range(m):\n                ck=dp[i][j]*8\n                if i>=1:\n                    ck=min(ck,dp[i-1][j]+2*col[i][j+1])\n                if i<n-1:\n                    ck=min(ck,dp[i+1][j]+2*col[i+1][j+1])\n                if j>=1:\n                    ck=min(ck,dp[i][j-1]+2*row[i][j])\n                if j<m-1:\n                    ck=min(ck,dp[i][j+1]+2*row[i][j+1])\n                temp[i][j]=ck\n\n\n        dp=temp\n\nfor i in dp:\n    print(*i)\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import pprint\nnr, ng, nb = map(int, input().split())\n*r, = map(int, input().split())\n*g, = map(int, input().split())\n*b, = map(int, input().split())\ndp = []\nfor _ in range(nr + 1):\n    dp.append([[0] * (nb + 1) for _ in range(ng + 1)])\n\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\n\nmx = 0\nfor i in range(nr + 1):\n    for j in range(ng + 1):\n        for k in range(nb + 1):\n            if i and j:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])\n            if i and k:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])\n            if j and k:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])\n\n\nmx_i = mx_j = mx_k = -1\n\nfor i in range(nr + 1):\n    for j in range(ng + 1):\n        for k in range(nb + 1):\n            if dp[i][j][k] > mx:\n                mx_i = i\n                mx_j = j\n                mx_k = k\n                mx = dp[i][j][k]\n\nprint(mx)\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import math\nimport sys\nfrom bisect import bisect_right, bisect_left, insort_right\nfrom collections import Counter, defaultdict\nfrom heapq import heappop, heappush\nfrom itertools import accumulate\nfrom sys import stdout\n\nR = lambda: map(int, input().split())\nt = input()\ns = input()\nk = t.count('+') - s.count('+')\nn = s.count('?')\nif k > n or k < 0:\n    print('0.0')\nelse:\n    print(math.factorial(n) / (math.factorial(k) * math.factorial(n - k)) / 2**n)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "def main():\n\tn, d, k = map(int, input().split())\n\tif n < d+1 or d > 1 and k == 1:\n\t\tprint('NO')\n\t\treturn\n\n\tedges = [(1, 2)]\n\tstack = []\n\td2 = d/2\n\td21 = d2+1\n\tfor node in range(2, d+1):\n\t\tedges.append((node, node+1))\n\t\tstack.append([node, d2-abs(d21 - node), k-2])\n\tnext_i = d+2\n\twhile next_i <= n:\n\t\tif not stack:\n\t\t\tprint('NO')\n\t\t\treturn\n\n\t\tnode = stack[-1]\n\t\ti, remaining_depth, remaining_degree = node\n\t\tif remaining_depth == 0 or remaining_degree == 0:\n\t\t\tstack.pop()\n\t\t\tcontinue\n\n\t\tnode[2] -= 1\n\t\tedges.append((i, next_i))\n\t\tstack.append([next_i, remaining_depth-1, k-1])\n\t\tnext_i += 1\n\n\tprint('YES')\n\tprint('\\n'.join('{} {}'.format(a, b) for a, b in edges))\n\nmain()", "complexity": "quadratic", "problem": "1003_E", "from": "CODEFORCES", "tags": "constructive algorithms,graphs"}
{"src": "def f(n,s):\n    d=[-n,-n];\n    d[s]=0;\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)];\n    return d[s];\nimport math;\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny=y+x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "# binary search answer\n# O((nm+4^m)logA)\nimport sys\nreader = (s.rstrip() for s in sys.stdin)\ninp = reader.__next__\n\nn, m = map(int, inp().split())\narr = tuple(tuple(map(int, inp().split())) for i in range(n))\nlower_bound = 0\nupper_bound = int(1e9) + 1\nmask = (1 << m) - 1\n\nans = (0, 0)\n\n\ndef can_upper(mid):\n\tglobal ans\n\t\"\"\" return exist answer that >= m (boolean)\n\tO(nm + 4^m)\n\t\"\"\"\n\t# O(nm)\n\td = dict()\n\tfor i in range(n):\n\t\tbit = 0\n\t\tfor j in range(m):\n\t\t\tif arr[i][j] >= mid:\n\t\t\t\tbit += 1 << j\n\t\td[bit] = i\n\n\t# O(m * (2^m)^2) = O(4^m)\n\tkeys = tuple(d.keys())\n\tfor i in range(len(keys)):\n\t\ta1 = keys[i]\n\t\tfor j in range(i, len(keys)):\n\t\t\ta2 = keys[j]\n\t\t\tif a1 | a2 == mask:\n\t\t\t\tans = (d[a1], d[a2])\n\t\t\t\treturn True\n\treturn False\n\n\nwhile upper_bound - lower_bound > 1:\n\tmiddle = (upper_bound + lower_bound) >> 1\n\tif can_upper(middle):\n\t\tlower_bound = middle\n\telse:\n\t\tupper_bound = middle\n\nprint(ans[0] + 1, ans[1] + 1)", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "q = int(input())\n\nfor i in range(q):\n    n,k = map(int,input().split())\n    if n > 31:\n        print(\"YES\",n-1)\n        continue\n    a = [0]\n    for i in range(1,n+1):\n        a.append(a[i-1]*4+1)\n    if a[n] < k:\n        print(\"NO\")\n        continue\n    if n == 2 and k == 3:\n        print(\"NO\")\n        continue\n    p = 0\n    q = 2\n    while p+q-1 <= k and n > 0:\n        p += q-1\n        q *= 2\n        n -= 1\n    print(\"YES\",n)\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=10**9+7\nEPS=1e-6\ndef Ceil(a,b): return a//b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n\nl,r=value()\nans=0\n\nR=len(bin(r))-2\n\nfor i in range(61):\n    if(l&(1<<i) ^ r&(1<<i)):\n        ans=2**(i+1)-1\n    \n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    \n\n\n\n    \n        \n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "a,b,c = input().split()\nif a[1] == b[1] == c[1]:\n    t = sorted([int(a[0]),int(b[0]),int(c[0])])\n    if (t[1] == t[0] + 1 == t[2] - 1) or (t[0] == t[2]):print(0)\n    elif t[0] == t[1] or t[1] == t[2]:print(1)\n    elif t[0] + 1 == t[1] or t[1] + 1 == t[2] or t[0] + 2 == t[1] or t[1] + 2 == t[2]:print(1)\n    else:print(2)\nelif a[1] == b[1]:\n    s,t = int(a[0]),int(b[0])\n    if s == t:print(1)\n    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)\n    else:print(2)\nelif c[1] == b[1]:\n    s,t = int(c[0]),int(b[0])\n    if s == t:print(1)\n    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)\n    else:print(2)\nelif a[1] == c[1]:\n    s,t = int(a[0]),int(c[0])\n    if s == t:print(1)\n    elif min(s,t) + 1 == max(s,t) or min(s,t) + 2 == max(s,t):print(1)\n    else:print(2)\nelse:print(2)\n", "complexity": "nlogn", "problem": "1191_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "import math\nfrom math import factorial\n\ndef combination(n,r):\n    return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r))\n\na = input()\nap = a.count('+')\nam = a.count('-')\nb = input()\nbp = b.count('+')\nbm = b.count('-')\nn = b.count('?')\nx = float(ap - bp)\ny = float(am - bm)\nif (x < 0 or y < 0 or x+y != n):\n    print(0.0)\nelse:\n    print(combination(n,x)/(1<<n))\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "Q = int(input())\nsrc = [tuple(map(int,input().split())) for i in range(Q)]\nans = []\nfor x,y,k in src:\n    d = max(x,y)\n    if (x+y)%2:\n        ans.append(-1 if d > k else k-1)\n    else:\n        if d > k:\n            ans.append(-1)\n        else:\n            ans.append(k-2 if (d+k)%2 else k)\n\nprint(*ans,sep='\\n')\n", "complexity": "constant", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    s = list(input().rstrip())\n    t = input().rstrip()\n    ok = False\n    for i in range(len(t)):\n        t1 = list(t[:i]) + [\"#\"]\n        t2 = list(t[i:]) + [\"#\"] \n        # dp[seen i-th index][match j in front] = match in back\n        dp = [[-1] * (len(t) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = 0\n        for j, ch in enumerate(s):\n            for k in range(len(t1)):\n                if dp[j][k] == -1:\n                    continue\n                dp[j+1][k] = max(dp[j+1][k], dp[j][k])\n                if ch == t1[k]:\n                    dp[j+1][k+1] = max(dp[j+1][k+1], dp[j][k])\n                if ch == t2[dp[j][k]]:\n                    dp[j+1][k] = max(dp[j+1][k], dp[j][k] + 1)\n        for k in range(len(t) + 1):\n            if dp[len(s)][k] + k >= len(t):\n                ok = True\n\n    if ok:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "print('25')", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "from collections import defaultdict as dd, deque\nimport sys,atexit\nfrom io import BytesIO\ninp = BytesIO(sys.stdin.buffer.read())\ninput = lambda:inp.readline().decode('ascii')\nbuf = BytesIO()\nsys.stdout.write = lambda s: buf.write(s.encode('ascii'))\natexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))\n\nn,q = map(int,input().split())\nS = [int(x) for x in input().split()]\nQ = deque(S)\n\nn = len(Q)\nres = []\nfor i in range(n):\n    a = Q.popleft()\n    b = Q.popleft()\n    Q.appendleft(max(a,b))\n    Q.append(min(a,b))\n    res.append((a,b))\n\nA = list(Q)\n\ndef solve(t):\n    if t < len(res):\n        return res[t-1]\n    t -= len(res) + 1\n    t %= n-1\n    return A[0],A[t+1]\n\nfor _ in range(q):\n    t = int(input())\n    print(*solve(t))\n    \n#def brute(t):\n#    Q = deque(S)\n#    for i in range(t):\n#        a = Q.popleft()\n#        b = Q.popleft()\n#\n#        Q.appendleft(max(a,b))\n#        Q.append(min(a,b))\n#    return a,b\n\n#for i in range(1,1000):\n#    assert brute(i) == solve(i)\n", "complexity": "linear", "problem": "1179_A", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "import sys\nimport math\nimport collections\nimport bisect\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\nfor t in range(1):\n    n,k=get_ints()\n    arr=get_list()\n    ans=arr.copy()\n    ans.sort(reverse=True)\n    ans=ans[:k]\n    c=k\n    print(sum(ans))\n    j = 0\n    for i in range(n):\n        if (arr[i] in ans and c != 1):\n            print(i + 1 - j, end=' ')\n            j = i + 1\n            ans.remove(arr[i])\n            c -= 1\n        if (c == 1):\n            print(n - j)\n            break", "complexity": "nlogn", "problem": "1006_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "grid = list(map(int,input().split()))\nmax_res = 0\nfor i in range(14):\n    g_c = grid.copy()\n    Amount = g_c[i]//14\n    Amount_r = g_c[i]%14\n    if(Amount > 0):    \n        for j in range(14):\n            if i != (i+j+1)%14:\n                g_c[(i+j+1)%14]+=Amount\n                g_c[i]-=Amount    \n    if Amount_r > 0:\n        for j in range(14):\n            if Amount_r > 0:\n                if i != (i+j+1)%14:\n                    g_c[(i+j+1)%14]+=1\n                    Amount_r-=1\n                    g_c[i]-=1\n            else:\n                break\n    \n    res = 0\n    for i in range(14):\n        if g_c[i] % 2 ==0:    \n            res+=g_c[i]\n      \n    max_res = max(max_res,res)\n\nprint(max_res)  \n    ", "complexity": "constant", "problem": "0975_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "n = [int(x) for x in input().split()]\na = []\nfor i in range(3):\n\ta.append([int(x) for x in input().split()])\n\ta[i].sort(reverse=True)\n\ndp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]\nans = 0\nfor i in range(n[0] + 1):\n\tfor j in range(n[1] + 1):\n\t\tfor k in range(n[2] + 1):\n\t\t\tif i < n[0] and j < n[1]:\n\t\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])\n\t\t\tif i < n[0] and k < n[2]:\n\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])\n\t\t\tif j < n[1] and k < n[2]:\n\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])\n\t\t\tans = max(ans, dp[i][j][k])\n\nprint(ans)", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "from collections import Counter\n\n\ndef solve():\n    n, k = tuple( map( lambda x: int(x), input().split()) )\n    \n    low, high = 0, n\n\n    while low <= high:\n        eaten = (low+high)//2\n        added = (n-eaten)* (n-eaten+1)/2\n\n        if added - eaten >= k:\n            low = eaten + 1\n        else:\n            high = eaten - 1 \n\n    print(high)\n\n        \n\nif __name__ == \"__main__\":\n    solve()", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "from sys import stdin,stdout\ninput=stdin.readline\nfor _ in range(int(input())):\n    x=10**5\n    n,k=map(int,input().split())\n    s=input()\n    a=10**9\n    ans=[[0]*n for i in range(3)]\n    curr=['R','G','B']\n    for l in range(3):\n        z=l\n        for j in range(n):\n            if s[j]!=curr[z]:\n                ans[l][j]=1\n            z+=1\n            z%=3\n    for i in range(3):\n        ans[i]=[0]+ans[i]\n    for l in range(3):\n        z=l\n        for j in range(1,n+1):\n            ans[l][j]+=ans[l][j-1]\n    for l in range(3):\n        for j in range(1,n-k+2):\n            a=min(a,ans[l][j+k-1]-ans[l][j-1])\n   # print(ans)\n    print(a)\n            ", "complexity": "linear", "problem": "1196_D2", "from": "CODEFORCES", "tags": "data structures,dp,implementation,two pointers"}
{"src": "def nr(): return nrs()[0]\ndef nrs(): return [int(i) for i in input().split()]\n\ndef get_prime(n):\n\tres = []\n\tfor i in range(2,n):\n\t\tis_prime = True\n\t\tfor x in res:\n\t\t\tif i % x == 0:\n\t\t\t\tis_prime = False\n\t\t\t\tbreak\n\t\tif is_prime: res.append(i)\n\treturn res\n\nprime = get_prime(3162)\n\n#cache = {}\ndef get_mask (num):\n\t#key = num\n\t#if key in cache: return cache[key]\n\tdv = []\n\tfor p in prime:\n\t\tc = 0\n\t\twhile num % p == 0:\n\t\t\tc += 1\n\t\t\tnum = num // p\n\t\tif c % 2 == 1:\n\t\t\tdv.append(p)\n\t\tif num < p * p:\n\t\t\tbreak\n\n\tfor x in dv:\n\t\tnum *= x\n\n\t#cache[key] = num\n\treturn num\n\nfor _ in range(nr()):\n\tN, K = nrs()\n\tA = nrs()\n\tdp = [N] * (K + 1)\n\tdp[0] = 1\n\tused = [{}] * (K + 1)\n\tfor a in A:\n\t\ta = get_mask(a)\n\t\tfor j in range(K, -1, -1):\n\t\t\tif dp[j] == N: continue\n\t\t\tif a in used[j]:\n\t\t\t\tif j < K and dp[j + 1] > dp[j]:\n\t\t\t\t\tdp[j + 1] = dp[j]\n\t\t\t\t\tused[j + 1] = used[j]\n\t\t\t\tdp[j] += 1\n\t\t\t\tused[j] = {}\n\t\t\tused[j][a] = 1\n\tprint(min(dp))\n", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "s = input()\nn = len(s)\nAns = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        L = i\n        R = j\n        while L < R and s[L] == s[R]:\n            L += 1\n            R -= 1\n        if L < R and Ans < j - i + 1:\n            Ans = j - i + 1\nprint(Ans)\n", "complexity": "linear", "problem": "0981_A", "from": "CODEFORCES", "tags": "brute force,implementation,strings"}
{"src": "import sys\nfrom collections import defaultdict\n \ninput = sys.stdin.readline\n \nn, m = map(int, input().split())\n# n, m = 3 * 10 ** 5, 8\nvals = set()\nlocs = defaultdict(list)\nfor i in range(n):\n    inp = map(int, input().split())\n    for pos, v in enumerate(inp):\n        vals.add(v)\n        locs[v].append((pos, i))\n\nmasks = [0] * n\nfull = (1<<m) - 1\nmet = {0:0}\nfor v in sorted(vals, reverse=True):\n    for pos, i in locs[v]:\n        curr_mask = masks[i] = masks[i] | (1<<pos)\n        met[curr_mask] = i\n        complement = full ^ curr_mask\n        if complement in met:\n            print(i+1, met[complement]+1)\n            sys.exit()", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Sep 18 08:45:24 2020\n\n@author: Dark Soul\n\"\"\"\ndef comp(a,b):\n    x=len(a)\n    s1=''\n    s2=''\n    for i in range(x):\n        s1+=str(a[i])\n        s2+=str(b[i])\n    if s1>s2:\n        return 1\n    else:\n        return 0\n        \na=list(input(''))\nb=list(input(''))\ncnt=[0]*10\nn=len(a)\nm=len(b)\nsol=''\nfor i in range(n):\n    a[i]=int(a[i])\n    cnt[a[i]]+=1\n\nif n!=m:\n    a.sort(reverse=True)\n    for i in a:\n        sol+=str(i)\n    print(sol)\nelse:\n    a.sort()\n    \n    for i in range(n):\n        b[i]=int(b[i])\n    for i in range(n-1):\n        for j in range(i,n):\n            if a[i]<a[j]:\n                temp=a[i]\n                a[i]=a[j]\n                a[j]=temp\n                if comp(a,b):\n                    temp=a[i]\n                    a[i]=a[j]\n                    a[j]=temp\n                \n    \n    for i in a:\n        sol+=str(i)\n    print(sol)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "x, k = (int(x) for x in input().split())\nmod = 10 ** 9 + 7\nif x == 0:\n    print(0)\n    exit()\nif k == 0:\n    print(2 * x % mod)\n    exit()\n\n# twopow = pow(2, k, mod)\nans = pow(2, k + 1, mod)\nans *= x\nans %= mod\nans -= pow(2, k, mod)\nans += 1\nans %= mod\nans += mod\nans %= mod\n\nprint(ans)\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n=int(input())\narr=list(map(int,input().split()))\ndp=[[-1 for i in range(5+1)] for j in range(n)]\nfor i in range(1,6):\n    dp[0][i] =1\nfor i in range(1,n):\n    if arr[i] > arr[i - 1]:\n        for j in range(1,6):\n            for k in range(1,j):\n                if dp[i-1][k]==1:\n                    dp[i][j] =1\n                    break\n    elif arr[i] <arr[i-1]:\n        for j in range(1,6):\n            for k in range(j+1,6):\n                if dp[i-1][k] ==1:\n                    dp[i][j]=1\n                    break\n    else:\n        for j in range(1,6):\n            for k in range(1,6):\n                if j ==k:\n                    continue\n                if dp[i-1][k] ==1:\n                    dp[i][j] =1\n                    break\nans=[]\nfor i in range(1,6):\n    if dp[n-1][i]==1:\n        ans.append(i)\n        break\nif len(ans) ==0:\n    print(-1)\n    exit()\nfor i in range(n-2,-1,-1):\n    curr=ans[-1]\n    if arr[i] >arr[i+1]:\n        for j in range(curr+1,6):\n            if dp[i][j] ==1:\n                ans.append(j)\n                break\n    elif arr[i] <arr[i+1]:\n        for j in range(1,curr):\n            if dp[i][j] ==1:\n                ans.append(j)\n                break\n    else:\n        for j in range(1,6):\n            if j ==curr:\n                continue\n            if dp[i][j] ==1:\n                ans.append(j)\n                break\nans=ans[::-1]\nprint(*ans)\n", "complexity": "linear", "problem": "1032_C", "from": "CODEFORCES", "tags": "constructive algorithms,dp"}
{"src": "n=int(input())\nl=[4,7,47,74,44,77,447,444,474,777,747,744,477]\nc=0\nfor i in range(len(l)):\n    if n%l[i]==0:\n        c=1\n        break\nif c==1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "n = int(input())\na = {}\nans = 0\nsum = 0\ni = 0\nfor t in map(int, input().split()):\n    sum += t\n    a[t] = a.get(t, 0) + 1\n\n    ans += (i - a.get(t, 0) - a.get(t - 1, 0) - a.get(t + 1, 0) + 1) * t - (sum - a.get(t, 0) * t - a.get(t - 1, 0) * (t - 1) - a.get(t + 1, 0) * (t + 1))\n    i += 1\n            \nprint(ans)\n", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "n=int(input())\na=list(map(int,input().split()))\nl=list(set(a))\nl.sort()\nif len(l) >=2:\n    print(l[1])\nelse:\n    print(\"NO\")", "complexity": "nlogn", "problem": "0022_A", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import math,sys,bisect,heapq\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\n#sys.setrecursionlimit(200000000)\nint1 = lambda x: int(x) - 1\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nilele = lambda: map(int,input().split())\nalele = lambda: list(map(int, input().split()))\nilelec = lambda: map(int1,input().split())\nalelec = lambda: list(map(int1, input().split()))\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n#MOD = 1000000000 + 7\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n    \nMOD = 998244353\n\nN,K = ilele()\nif K == 1 or K == 2*N:\n    print(2)\n    exit(0)\ndp = list3d(N+1,4,K+1,0)\ndp[1][0][1] = 1\ndp[1][3][1] = 1\ndp[1][1][2] = 1\ndp[1][2][2] = 1\n\nfor n in range(2,N+1):\n    for k in range(1,K+1):\n        dp[n][0][k] = ((dp[n-1][0][k]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD\n        dp[n][3][k] = ((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k])%MOD)%MOD\n        if k > 1:\n            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k-2] +dp[n-1][3][k-1])%MOD)%MOD\n            dp[n][2][k]=((dp[n-1][0][k-1]+dp[n-1][1][k-2])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD\n        else:\n            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][3][k-1])%MOD)%MOD\n            dp[n][2][k]=((dp[n-1][0][k-1])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD\n\nprint(((dp[N][0][K]+dp[N][1][K])%MOD+(dp[N][2][K]+dp[N][3][K])%MOD)%MOD)\n            ", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import sys\n# Get out of main functoin\ndef main():\n    pass\n# decimal to binary\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n# binary to decimal\ndef decimal(s):\n    return (int(s, 2))\n# power of a number base 2\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return (p)\n# if  number is prime in \u221an time\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n# list to string ,no spaces\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n# String to list\ndef stl(s):\n    # for each character in string to list with no spaces -->\n    l = list(s)\n    # for space in string  -->\n    # l=list(s.split(\" \"))\n    return l\n# Returns list of numbers with a particular sum\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n# Sieve for prime numbers in a range\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n            # print(p)\n    return (cnt)\n# for positive integerse only\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n# 1000000007\nmod = int(1e9) + 7\ndef ssinp(): return sys.stdin.readline().strip()\n# s=input()\ndef iinp(): return int(input())\n# n=int(input())\ndef nninp(): return map(int, sys.stdin.readline().strip().split())\n# n, m, a=[int(x) for x in input().split()]\ndef llinp(): return list(map(int, sys.stdin.readline().strip().split()))\n# a=list(map(int,input().split()))\ndef p(xyz): print(xyz)\ndef p2(a, b): print(a, b)\nimport math\n#import random\n#sys.setrecursionlimit(300000)\n#from fractions import Fraction\n#from collections import OrderedDict\n#from collections import deque\n########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################\n########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################\n########################                         from collections import deque                              ########################\n########################                         ASCII of A-Z= 65-90                                        ########################\n########################                         ASCII of a-z= 97-122                                       ########################\n########################                         d1.setdefault(key, []).append(value)                       ########################\n#for __ in range(iinp()):\nn,k=nninp()\nnos=math.floor(math.sqrt(2*k))\nfor i in range(nos,12309123):\n    if((i*(i+1))//2-k+i==n):\n        print((i*(i+1))//2-k)\n        exit()\n\n\n\n\n\n\n\n\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n = int(input())\na = [int(s) for s in input().split()]\nos = 0\noss = []\nnos = 0\nnos_0 = -1\nnos_1 = -1\nsumnos = 0\nfor i in range(n):\n    if a[i] == 1:\n        os += 1\n        oss.append(i+1)\n    else:\n        sumnos += a[i]\n        nos += 1\n        if nos_0 == -1:\n            nos_0 = i+1\n        nos_1 = i+1\n\nif os <= sumnos-(2*(nos-1)):\n    es = []\n    oss_i = 0\n    ans = nos-1\n    if os >= 1:\n        ans += 1\n        es.append((nos_0, oss[0]))\n        oss_i += 1\n    if os >= 2:\n        ans += 1\n        es.append((nos_1, oss[1]))\n        oss_i += 1\n    print(\"YES\", ans)\n    prev_nos = -1\n    for i in range(n):\n        if a[i] > 1:\n            if prev_nos != -1:\n                es.append((prev_nos+1, i+1))\n            for j in range(a[i]-2):\n                if oss_i >= os:\n                    break\n                es.append((i+1, oss[oss_i]))\n                oss_i += 1\n            prev_nos = i\n    print(len(es))\n    for e in es:\n        print(*e)\nelse:\n    print(\"NO\")\n\n\n\n", "complexity": "linear", "problem": "1082_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "n,k=map(int,input().split())\na=list(map(int,input().split()))\na.sort(reverse=True)\nworst=0\nmaxi=a[0]\na.append(0)\nfor i in range(n+1):\n    bad=maxi-a[i]-i\n    worst=max(worst,bad)\nprint(sum(a)-n-worst)", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "one = list(map(int, input().split()))\ntwo = list(map(int, input().split()))\n\none_ = sorted([(one[i], one[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))\ntwo_ = sorted([(two[i], two[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))\n\nones = [one_[0], one_[2], one_[3], one_[1]]\ntwos = [two_[1], two_[3], two_[2], two_[0]]\n\nL, D, U, R = ones[0][0], ones[0][1], ones[2][1], ones[2][0]\n\n\ndef in_one(point):\n    x, y = point\n\n    return L <= x <= R and D <= y <= U\n\n\ndef in_two(point):\n    x_0, y_0 = twos[0]\n\n    def U_p(x_):\n        return x_ + y_0 - x_0\n\n    def D_m(x_):\n        return -x_ + y_0 + x_0\n\n    x_1, y_1 = twos[2]\n\n    def U_m(x_):\n        return -x_ + y_1 + x_1\n\n    def D_p(x_):\n        return x_ + y_1 - x_1\n\n    x, y = point\n    \n    return D_m(x) <= y <= U_p(x) and D_p(x) <= y <= U_m(x)\n\n\nc_one = ((L + R) / 2, (U + D) / 2)\nc_two = ((twos[0][0] + twos[2][0]) / 2, (twos[1][1] + twos[3][1]) / 2)\n\nones.append(c_one)\ntwos.append(c_two)\n\nfor p in ones:\n    if in_two(p):\n        print('YES')\n        exit()\n\nfor p in twos:\n    if in_one(p):\n        print('YES')\n        exit()\n\nprint('NO')\n", "complexity": "constant", "problem": "0994_C", "from": "CODEFORCES", "tags": "brute force"}
{"src": "m = int(input())\nvalues = []\nidx = []\nfor i in range(m):\n    x = int(input())\n    ans = 0\n    for xx,ii in zip(values,idx):\n        if (xx^x) < x:\n            x^=xx\n            ans^=ii\n    if x == 0:\n        anss = []\n        for j in range(i):\n            if (ans&1)!=0:\n                anss.append(j)\n            ans>>=1\n        print(len(anss),*anss)\n    else:\n        print(0)\n        values.append(x)\n        idx.append(ans^(2**i))\n", "complexity": "np", "problem": "0504_D", "from": "CODEFORCES", "tags": "bitmasks"}
{"src": "arr = [int(i) for i in filter(None, input().split(\" \"))]\nk_hodov = arr[0]\nkonf = arr[1]\nleft = 0\nright = k_hodov+100\nwhile(right-left)>1:\n    mid = (right+left)//2\n    k_give=k_hodov-mid\n    if ((k_give+1)*(k_give/2))//1-mid<konf or k_give<0:\n        right = mid\n    else:\n        left = mid\n\nk_give=k_hodov-left\nif ((k_give+1)*(k_give/2))//1-left==konf:\n    print(left)\nelse:\n    print(left-1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"i=1\nk_eat=0\nlast_give = 1\nfor i in range(arr[0]):\n    if konf>=last_give:\n        konf-=last_give\n        last_give+=1\n    else:\n        k_eat+=1\n        konf+=1\nprint(k_eat)\"\"\"", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "import sys\nLI=lambda:list(map(int, sys.stdin.readline().split()))\nMI=lambda:map(int, sys.stdin.readline().split())\nSI=lambda:sys.stdin.readline().strip('\\n')\nII=lambda:int(sys.stdin.readline())\n# sys.stdin=open('input.txt')\n# sys.stdout=open('output.txt', 'w')\n# for _ in range(II()):\nn=II()\ns=SI()\nc=set(s)\nln=[0]*n\nfor d in c:\n\tlast=-1\n\t# print(d, end=' ')\n\tfor i, v in enumerate(s):\n\t\tif v==d:\n\t\t\tlast=i\n\t\tif last==-1:\n\t\t\tln[i]=int(1e9)\n\t\telse:\n\t\t\tln[i]=max(ln[i], i-last+1)\n\t# print(ln)\nprint(min(ln))", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "#!/bin/python3\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\n\n\ndef main():\n    l, r = map(int, input().split())\n    for i in range(62, -1, -1):\n        if ((1 << i) & l) ^ ((1 << i) & r):  # if xor of max bit is 1\n            print((1 << (i+1)) - 1)\n            break\n    else:\n        print(0)\n\n\n# region fastio\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "def mp():\n    return map(int, input().split())\n\ndef f(i):\n    return (10 ** i - 10 ** (i - 1)) * i\n\nn = int(input())\n\ni = 1\nsum = 0\nwhile n - f(i) >= 0:\n    n -= f(i)\n    sum += f(i) // i\n    i += 1\n\nprint(str(sum + (n + i - 1) // i)[n % i - 1])", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "n = int(input())\nl = [int(i) for i in input().split()]\nl.sort()\ns = set([l[0]])\nres = 1\nfor i in l:\n    f = 1\n    for j in s:\n        if(i%j == 0):\n            f = 0\n            break\n    if(f):\n        s.add(i)\n        res += 1\nprint(res)", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "from sys import stdin\nfrom math import factorial\n\nn, mod = map(int, stdin.readline().split())\n\ndef binom(n, m):\n    return factorial(n) // factorial(m) // factorial(n-m)\n\ndef foo(x, k):\n    ans = 0\n    for i in range(k, 0, -1):\n        sign = 1 if (i-k)%2 == 0 else -1\n        ans += sign * binom(k, i) * (i**x)\n        ans %= mod\n    return ans\n\ndef f(x, k):\n    return (foo(x, k) * pow(2, x-k, mod)) % mod\n\nans = 0\nfor i in range((n+1)//2):\n    ans = (ans + f(n-i, i+1))\n    ans %= mod\nprint(ans)", "complexity": "quadratic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "n = int(input())\n \nif n<6:\n\tprint(-1)\nelse:\n\tprint(\"1 2\\n1 3\\n1 4\")\n\tfor i in range(5,n+1):\n\t\tprint('2 '+str(i))\nfor i in range(2, n+1):\n\tprint('1 '+str(i))", "complexity": "linear", "problem": "0959_C", "from": "CODEFORCES", "tags": "constructive algorithms,trees"}
{"src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nn,m=map(int,input().split())\na=[list(map(int,input().split())) for i in range(n)]\nl=-1;r=10**9+1\nans1,ans2=-1,-1\nwhile r-l>1:\n    x=(l+r)//2\n    idx={}\n    for i in range(n):\n        v=0\n        for j in range(m):\n            if a[i][j]>=x:\n                v+=1\n            v<<=1\n        idx[v>>1]=i\n    ok=False\n    idx1,idx2=0,0\n    for aa,bb in idx.items():\n        for cc,dd in idx.items():\n            for d in range(m):\n                if (aa|cc)==(2**m)-1:\n                    ok=True\n                    idx1=bb+1\n                    idx2=dd+1\n    if ok:\n        l=x\n        ans1=idx1\n        ans2=idx2\n    else:\n        r=x\nprint(ans1,ans2)", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "n, pos, l, r = map(int, input().split())\nresult = abs(pos - l) + r - l + 2\nif (l == 1):\n    if (abs(pos - r) + 1 < result):\n        result = abs(pos - r) + 1\nif (r == n):\n    if (abs(pos - l) + 1 < result):\n        result = abs(pos - l) + 1\nif (l == 1 and r == n):\n    result = 0\nif (abs(pos - r) + r - l + 2 < result):\n    result = abs(pos - r) + r - l + 2\nprint(result)", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from math import factorial\nn, mod = map(int, input().split())\ndef binom(n, m):    return factorial(n) // factorial(m) // factorial(n-m)\ndef foo(x, k):\n    ans = 0\n    for i in range(k, 0, -1):sign = 1 if (i-k)%2 == 0 else -1;ans += sign * binom(k, i) * (i**x);ans %= mod\n    return ans\ndef f(x, k):    return (foo(x, k) * pow(2, x-k, mod)) % mod\nans = 0\nfor i in range((n+1)//2):ans = (ans + f(n-i, i+1));ans %= mod\nprint(ans)", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "# import sys\n# input = sys.stdin.readline\nn,queries = list(map(int,input().split()))\nl = list(map(int,input().split()))\nif(queries==0):\n\texit()\nmaxval = max(l)\npairs = []\ncount = 0\nf = l[0]\nsecix = 1\nwhile(f!=maxval):\n\t# print(l)\n\tcount+=1\n\tf = l[0]\n\ts = l[secix]\n\tpairs.append([f,s])\n\tf,s= max(f,s), min(f,s)\n\tl[0] = f\n\tl.append(s)\n\tsecix+=1\n# print(secix)\nl = [l[0]]+l[secix:]\n# print(l)\nfor i in range(n-1):\n\tpairs.append([maxval,l[1+i]])\n# print(pairs)\nfor m in range(queries):\n\tq = int(input())\n\tif(q<=count):\n\t\tprint(str(pairs[q-1][0]),str(pairs[q-1][1]))\n\telse:\n\t\tq-=(count+1)\n\t\tpos = count+(q%(n-1))\n\t\tprint(str(pairs[pos][0]),str(pairs[pos][1]))", "complexity": "linear", "problem": "1179_A", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "def read():\n    return [int(v) for v in input().split()]\n\n\ndef main():\n    mod = 10 ** 9 + 7\n    x, k = read()\n    if x == 0:\n        print(0)\n    else:\n        print((pow(2, k, mod) * (2 * x - 1) + 1) % mod)\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\n\nn, q = list(map(int,sys.stdin.readline().strip().split()))\na = list(map(int,sys.stdin.readline().strip().split()))\nm = [0] * q\n\nM = max(a)\ni = 0\nx = a[0]\nL = []\nL1 = []\nL2 = []\nwhile x != M:\n    L1.append(x)\n    L2.append(a[i+1])\n    i = i + 1\n    if x < a[i]:\n        L.append(x)\n        x = a[i]\n    else:\n        L.append(a[i])\n\nb = a[i+1:] + L\n\nfor j in range (0, q):\n    m = int(sys.stdin.readline().strip())\n    if m <= i:\n        print(str(L1[m-1]) + \" \" + str(L2[m-1]))\n    else:\n        print(str(x) + \" \" + str(b[(m - i - 1) % (n-1)]))\n", "complexity": "linear", "problem": "1180_C", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "pw = [1, 4]\nfor i in range(2, 32):\n    pw.append(pw[i - 1] * 4)\nt = int(input())\nfor cas in range(t):\n    n, k = map(int, input().split())\n    last = 1\n    path = 1\n    ans = n\n    i = 0\n    while True:\n        if((pw[i + 1] - 1) // 3 > k):\n            ans -= i\n            last = k - (pw[i] - 1) // 3\n            break\n        i = i + 1\n        path *= 2\n    sp = path * 2 - 1\n    if((ans < 0) or ((ans == 0) and (last > 0))):\n        print(\"No\")\n        continue\n    sq = path * path - sp\n    if (ans == 1) and (last > sq) and (last < sp):\n        print(\"No\")\n        continue\n    elif (ans == 1) and (last >= sp):\n        ans = ans - 1\n    print(\"Yes\", ans)\n", "complexity": "constant", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "n, k  = map(int, input().split())\na = []\nb = []\nc = 0\nd = []\n\n\nfor i in range(n):\n    x, y= map(int, input().split())\n    t = x-y\n    a.append(x)\n    b.append(y)\n    d.append(t)\ns = sum(a)\nd.sort()\nd = d[::-1]\nif sum(b)>k:\n    print(-1)\nelse:\n    while s>k:                #we are seeing how many cases we have to consider\n                                # and in each considered case we wil remove the extra part\n                                #we sort in descnending order to get as much profit as possible\n                                #and we subtract irrespective of which elemenet we remove.\n        s = s - d[c]\n        c = c + 1\n    print(c)\n\n\n\n", "complexity": "nlogn", "problem": "1015_C", "from": "CODEFORCES", "tags": "sortings"}
{"src": "s0=input()\nk=int(input())\ns1=s0[::-1]\nlens1=len(s1)\nmaxnum=1005\nmod=1000000007\ndp=[[0]*maxnum for tmpi in range(maxnum)]\nf=[0]*maxnum\nc=[[0]*maxnum for tmpi in range(maxnum)]\n\ndef cntone(num):\n    tmps=bin(num)[2:]\n    cnt=0\n    for i in range(len(tmps)):\n        if(tmps[i]=='1'):\n            cnt+=1\n    return cnt\n\nfor i in range(1,maxnum):\n    if(i==1):\n        f[i]=0\n    else:\n        f[i]=f[cntone(i)]+1\n\nfor i in range(maxnum):\n    if(i==0):\n        c[i][0]=1\n        continue\n    for j in range(i+1):\n        if(j==0):\n            c[i][j]=1\n        else:\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod\n\nfor i in range(lens1):\n    if(i==0):\n        dp[i][0] = 1\n        if(s1[i]=='1'):\n            dp[i][1]=1\n        else:\n            dp[i][1]=0\n        continue\n    else:\n        for j in range(0,i+2):\n            if(j==0):\n                dp[i][j]=1\n                continue\n            if(s1[i]=='1'):\n                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod\n            else:\n                dp[i][j]=dp[i-1][j]%mod\n\nans=0\n\nfor i in range(1,lens1+1):\n    if(f[i]==k-1):\n        ans=(ans+dp[lens1-1][i])%mod\n\nif(k==0):\n    ans=1\nelif(k==1):\n    ans-=1\nelse:\n    ans=ans\nprint(ans)\n  \t \t   \t \t \t\t\t \t \t  \t \t \t \t \t\t", "complexity": "linear", "problem": "0914_C", "from": "CODEFORCES", "tags": "brute force,combinatorics,dp"}
{"src": "n, m = map(int, input().split())\nxs = list(map(int, input().split()))\nts = list(map(int, input().split()))\n\nps = [x for x, t in zip(xs, ts) if t == 0]\nds = [x for x, t in zip(xs, ts) if t == 1]\nans = [0] * m\n\ndi = 0\nfor pi, p in enumerate(ps):\n    while di < m - 1 and abs(ds[di] - p) > abs(ds[di + 1] - p):\n        di += 1\n\n    if di >= m:\n        ans[m - 1] += n - pi\n        break\n\n    ans[di] += 1\n\n\nprint(' '.join(map(str, ans)))\n", "complexity": "linear", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "def c(a, b, l, ans, pro):\n    if l != 0:\n        n = a[:]\n        mx = None\n        pro1 = pro\n        prosh = set()\n        for i in range(l):\n            pro = pro1\n            if a[i] == prosh:\n                continue\n            elif (a[i] <= b[0] and pro):\n                n.pop(i)\n                prosh = a[i]\n                if pro == True:\n                    if a[i] < b[0]:\n                        pro = False\n                m = c(n, b[1:], l-1, ans+str(a[i]), pro)\n                n = a[:]\n                if m != None:\n                    if mx == None:\n                        mx = int(m)\n                    elif mx < int(m):\n                        mx = int(m)\n            elif not(pro):\n                a.sort(reverse = True)\n                a = list(map(str, a))\n                return ans +''.join(a)\n            else:\n                break\n        return mx            \n    else:\n        return ans\na = input()\nb = input()\nl = len(a)\nif len(a) != len(b):\n    a = list(a)\n    a.sort()\n    print(''.join(a[::-1]))\nelse:    \n    a = list(map(int, a))\n    b = list(map(int, b))\n    a.sort()\n    n = a[:]\n    mx = 0\n    prosh = -1\n    for i in range(l):\n        if a[i] == prosh:\n            continue\n        elif a[i] != 0 and a[i] <= b[0]:\n            n.pop(i)\n            prosh = a[i]\n            pro = False\n            if a[i] == b[0]:\n                pro = True\n            m = c(n, b[1:], l-1, str(a[i]), pro)\n            n = a[:]\n            if m != None:\n                if mx < int(m):\n                    mx = int(m)\n        elif a[i] > b[0]:\n            break\n    print(mx)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "def size_of_group(i):\n    return long(9 * 10**(i - 1)) * i\n\ndef find_group(k, i = 1):\n    diff = long(k - (size_of_group(i)))\n    if diff <= 0:\n        return k, i\n    return find_group(diff, i + 1)\n\ndef get_number(k, g):\n    return str(long(10**(g - 1)) + k / g)[k % g]\n\ndef get_sequence_number(num):\n    \"\"\"https://codeforces.com/problemset/problem/1177/B\"\"\"\n    k_prim, g_prim = find_group(num)\n    return get_number(k_prim - 1, g_prim)\n\n# run program\nif __name__ == \"__main__\":\n    print(get_sequence_number(long(input())))", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "from sys import stdout, stdin, setrecursionlimit\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom bisect import *\nfrom string import *\nfrom queue import *\nfrom heapq import *\nfrom math import *\nfrom re import *\nfrom os import *\n\n####################################---fast-input-output----#########################################\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ndef fast(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in fast().split()]\n\n\nz, zz = fast, lambda: (map(int, z().split()))\nszz, graph, mod, szzz = lambda: sorted(\n    zz()), {}, 10**9 + 7, lambda: sorted(zzz())\n\n\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\n\n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\n\n\n#################################################---Some Rule For Me To Follow---#################################\n\"\"\"\n    --instants of Reading problem continuously try to understand them.\n\n    --If you Know some-one , Then you probably don't know him !\n\n    --Try & again try\n\n\"\"\"\n##################################################---START-CODING---###############################################\n\n\n\n\nn = int(z())\narr = set(zz())\n\ndef solve():\n    for i in arr:\n        for k in range(31):\n            if i - (1 << k) in arr and i + (1 << k) in arr:\n                return [i - (1 << k), i, i + (1 << k)]\n    for i in arr:\n        for k in range(31):\n            if i + (1 << k) in arr:\n                return [i, i + (1 << k)]\n    \n    for i in arr:\n        return [i]\n\nlst = solve()\n# print(lst)\nprint(len(lst))\nfor i in lst:\n    output(i,' ')", "complexity": "nlogn", "problem": "0988_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "from collections import defaultdict as dd\nd=dd(int)\nn,m=map(int,input().split())\narr=list(map(int,input().split()))\nhas=False\ncount=0\nd[0] =1\ntotal=0\nfor i in range(n):\n    if arr[i] >m:\n        count  +=1\n    if arr[i] <m:\n        count -=1\n    if arr[i] ==m:\n        has=True\n    if has:\n        total +=d[count] +d[count-1]\n    else:\n        d[count] +=1\nprint(total)", "complexity": "nlogn", "problem": "1005_E1", "from": "CODEFORCES", "tags": "sortings"}
{"src": "n,m,k = [int(w) for w in input().split()]\na = [int(w) for w in input().split()]\n\ndef f(o):\n    r = e = 0\n    for i, x in enumerate(a):\n        if i < o:\n            continue\n        if i % m == o:\n            e -= k\n            if e < -k:\n                e = -k\n        e += x\n        if e > r:\n            r = e\n    return r\n\nprint(max(f(o) for o in range(m)))\n", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "import sys\nimport math\ninput = sys.stdin.readline\nfrom functools import cmp_to_key;\n\ndef pi():\n    return(int(input()))\ndef pl():\n    return(int(input(), 16))\ndef ti():\n    return(list(map(int,input().split())))\ndef ts():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\nmod = 1000000007;\nf = [];\ndef fact(n,m):\n    global f;\n    f = [1 for i in range(n+1)];\n    f[0] = 1;\n    for i in range(1,n+1):\n        f[i] = (f[i-1]*i)%m;\n\ndef fast_mod_exp(a,b,m):\n    res = 1;\n    while b > 0:\n        if b & 1:\n            res = (res*a)%m;\n        a = (a*a)%m;\n        b = b >> 1;\n    return res;\n\ndef inverseMod(n,m):\n    return fast_mod_exp(n,m-2,m);\n\ndef ncr(n,r,m):\n    if n < 0 or r < 0 or r > n: return 0;\n    if r == 0: return 1;\n    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;\n\ndef main():\n    C();\n\ndef D():\n    [n,m,k] = ti();\n    w = [[] for i in range(n)];\n    for i in range(n):\n        w[i] = ts();\n\n    mn = [[0 for j in range(k+1)] for i in range(n+1)];\n    for i in range(1,n+1):\n        for j in range(k+1):\n            c = 0;\n            st,en = -1,-1;\n            for x in range(m):\n                if w[i-1][x] == '1':\n                    if c == j and st == -1: st = x;\n                    if c < j: c += 1;\n                    if c == j: en = x;\n            mn[i][j] = en-st+1 if st != -1 and en != -1 else 0;\n            st,en = -1,-1;\n            c = 0;\n            for x in range(m-1,-1,-1):\n                if w[i-1][x] == '1':\n                    if c == j and st == -1: st = x;\n                    if c < j: c += 1;\n                    if c == j: en = x;\n            if st != -1 and en != -1 >= 0:\n                mn[i][j] = min(mn[i][j], st-en+1);\n\n    dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)];\n    for i in range(k+1):\n        dp[0][i] = 0;\n    for i in range(1,n+1):\n        for j in range(k+1):\n            for x in range(k+1):\n                if j-x >= 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]);\n\n    print(dp[n][k]);\n\ndef getCount(n):\n    x = 1;\n    count = 0;\n    while n > 0:\n        if n & 1 == 1:\n            count += 1;\n        n = n >> 1;\n    return count;\n\ndef C():\n    try:\n        n = ts();\n        k = pi();\n        if k == 0:\n            print(1);\n            return;\n        dp = [0 for i in range(1010)];\n        for i in range(1010):\n            if i == 0 or i == 1:\n                continue;\n            dp[i] = dp[getCount(i)]+1;\n        fact(1010,mod);\n\n        ans = 0;    \n        s = n;\n        count = 0;\n        for i in range(len(s)):\n            if s[i] == '0': continue;\n            for j in range(max(count,1),1010):\n                if dp[j] == k-1:\n                    ans = (ans+ncr(len(s)-i-1,j-count,mod))%mod;\n                    if i == 0 and k == 1: ans = (ans+mod-1)%mod;\n            count += 1;\n        count = 0;\n        for i in range(len(s)):\n            if s[i] == '1': count += 1;\n        if dp[count] == k-1: ans = (ans+1)%mod;\n\n        print(ans);\n    except: print(sys.exc_info()[0]);\n\n\nmain();", "complexity": "linear", "problem": "0914_C", "from": "CODEFORCES", "tags": "brute force,combinatorics,dp"}
{"src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import deque\n\ndef main():\n    with open('input.txt') as fp:\n        input=fp.readline\n        n, m = map(int, input().split())\n        dx = [1, -1, 0, 0]\n        dy = [0, 0, -1, 1]\n        q =deque()\n        k = int(input())\n        a = list(map(int, input().split()))\n        v = [[1] * (m + 2) for _ in range(n + 2)]\n        for i in range(m + 2):\n            v[0][i] = 0\n            v[-1][i] = 0\n        for i in range(n + 2):\n            v[i][0] = 0\n            v[i][-1] = 0\n        for i in range(0, 2 * k, 2):\n            q.append((a[i],a[i + 1]))\n            v[a[i]][a[i + 1]] = 0\n        while 1:\n            x, y =q.popleft()\n            for i in range(4):\n                xx, yy = x + dx[i], y + dy[i]\n                if v[xx][yy]:\n                    q.append((xx, yy))\n                    v[xx][yy] = 0\n            if not q:\n                with open('output.txt', mode='w') as fpp:\n                    fpp.write(f'{x} {y}')\n                break\n\n# region fastio\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "from collections import defaultdict\nimport bisect\nfrom itertools import accumulate, count\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n\n# ------------------- fast io --------------------\ns=input()\nneg=0\nif int(s)<0:\n    neg=1\nans1 = \"\"\ns=int(s)\ns=abs(s)\ns=str(s)\nans2 = \"\"\nfor i in range(0, len(s)):\n    if i == len(s)-2:\n        ans1 += s[i]\n    elif i == len(s)-1:\n        ans2 += s[i]\n    else:\n        ans1 += s[i]\n        ans2 += s[i]\nif neg==0:\n    print(s)\nelse:\n    if str(min(int(ans1), int(ans2)))==\"0\":\n        print(0)\n    else:\n        print(\"-\"+str(min(int(ans1), int(ans2))))\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "n=int(input())\nx=list(map(int,input().split()))\nx.sort()\ncount,count2=0,0\nans=1\nfor i in range(n):\n    count+=x[i]-i\n    if i>=2 and x[i]==x[i-1]==x[i-2]: ans=0\n    if i >= 2 and x[i] == x[i - 1] == x[i - 2]+1: ans = 0\n    if i>=1 and x[i]==x[i-1]: count2+=1\nif n>=3 and x[0]==x[1]==0: ans=0\nfor i in range(n):\n    if x[i]>0: break\n    if i==n-1: ans=0\nif ans==0 or count%2==0 or count2>1: print(\"cslnb\")\nelse: print(\"sjfnb\")", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "def main():\n\tn, pos, l, r=tuple(map(int,input().split()))\n\ttime=0\n\tif l!=1 and r!=n:\n\t\tif abs(pos-l)<abs(pos-r):\n\t\t\ttime+=abs(pos-l)+abs(l-r)+2\n\t\telse:\n\t\t\ttime+=abs(pos-r)+abs(l-r)+2\n\telif l==1 and r!=n:\n\t\ttime+=abs(pos-r)+1\n\telif r==n and l!=1:\n\t\ttime+=abs(pos-l)+1\n\telse:\n\t\ttime+=0\n\tprint(time)\nif __name__=='__main__':\n\tmain()", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\nsys.setrecursionlimit(1000)\n\n\ndef estimate(a):\n    return int(((n - a) * (n + 1 - a)) / 2) - a\n\n\ndef dicho(lower, upper, target):\n    if estimate(lower) == target:\n        return lower\n    elif estimate(upper) == target:\n        return upper\n    else:\n        mid = (int)((lower + upper) / 2)\n        if(estimate(mid) < target):\n            upper = mid\n        else:\n            lower = mid\n        return dicho(lower, upper, target)\n\n\nn, k = map(int, input().split())\nlower = 0\nupper = n\nprint(dicho(lower, upper, k))\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n=int(input())\nl=list(map(int,input().split()))\ns=set(l)\nx=0\nif x in s:\n    print(len(s)-1)\nelse:\n    print(len(s))", "complexity": "linear", "problem": "0992_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "n = int(input())\n\nif (n == 3):\n    print('1 1 3')\nelse:\n    done = 0\n    arr = []\n    for i in range(30, -1, -1):\n        arr.extend([2**i]*(n//(2**i) - done))\n        done += n//(2**i) - done\n        if (done == 1):\n            k = i\n\n    arr[0] = max(arr[0], (n//2**(k-1)) * 2**(k-1))\n        \n    arr.reverse()\n    print(' '.join(map(str, arr)))\n", "complexity": "logn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "n = int(input())\na = list(map(int, input().split()))\n\ndp = [[False] * (n + 1) for i in range(n + 1)]\n\ndef solve(l, r):\n    if dp[l][r]:\n        return dp[l][r]\n    if r - l == 1:\n        dp[l][r] = (a[l], 1)\n        return dp[l][r]\n    tmp = 10 ** 9\n    for i in range(l + 1, r):\n        if solve(l, i)[0] == -1 or solve(i, r)[0] == -1:\n            tmp = min(tmp, dp[l][i][1] + dp[i][r][1])\n        elif solve(l, i) == solve(i, r):\n            tmp = solve(l, i)[0] + 1\n            dp[l][r] = (tmp, 1)\n            return dp[l][r]\n        else:\n            tmp = min(tmp, 2)\n    dp[l][r] = (-1, tmp)\n    return dp[l][r]\n\nsolve(0, n)\nprint(dp[0][n][1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "s=int(input())\nu=True\nfor i in [4,7,47,74,447,474,477,747,774]:\n    if s%i==0:\n        u=False\n        print(\"YES\")\n        break\nif u:\n    print(\"NO\")\n\n\n        \n        \n            \n    \n\n    \n    \n", "complexity": "constant", "problem": "0122_A", "from": "CODEFORCES", "tags": "brute force,number theory"}
{"src": "#digits sequence(Hard Edition)\n\nn = int(input())\n\ncheck = True\nt=0\ntnext=9\n\ncount=1\ni=1\nj=1\nres = 0\nwhile(check):\n    \n    if(n<=tnext):\n        res=n-t\n        check = False\n\n    else:\n        #sm1 = sm1+t\n        count = count+1\n\n        if(t!=0):\n            t=t+9*i*j\n        else:\n            t=9\n\n        tnext = tnext + 9 * (i+1)*(j*10)\n        i=i+1\n        j=j*10\n        \nnum1 = int(res/count)\nnum2 = res%count\n\n\n#print(count , t , tnext , sm1 )\n\n\ndes = pow(10,count-1)\ndespac = des + num1 \n\n\n#print(despac)\n\nif(num2 == 0):\n    despac = str(despac -1)\n    print(despac[-1])\n\nelse :\n    despac = str(despac)\n    print(despac[num2-1])\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import math\nn,r=map(int,input().split())\nprint(r/( 1/math.cos(math.pi*(n-2)/2/n)-1))", "complexity": "constant", "problem": "1100_C", "from": "CODEFORCES", "tags": "binary search,geometry,math"}
{"src": "s = input()\none = s.count('1')\nzero = 0\nind = -1\nfor i in range(len(s)):\n    if s[i]=='2':\n        ind=i\n        break\n    if s[i]=='0':\n        zero+=1\nd = \"\"\nif ind==-1:\n    print(\"0\"*zero+\"1\"*one)\n    exit()\nd =  d + \"0\"*zero+\"1\"*one\nfor i in s[ind:]:\n    if i!='1':\n        d+=i\nprint(d)        \n        \n    \n", "complexity": "linear", "problem": "1009_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "n, p = map(int, input().split())\nlist1 = list(map(int, input().split()))\nmx = 0\ncurr = 0\nnxt = sum(list1)\nfor i in range(n - 1):\n    curr += list1[i]\n    nxt -= list1[i]\n    mx = max(mx, curr % p + nxt % p)\nprint(mx)", "complexity": "linear", "problem": "0958_C1", "from": "CODEFORCES", "tags": "brute force"}
{"src": "import sys\nimport io, os\ninput = sys.stdin.buffer.readline\n#input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nfrom collections import defaultdict\n\nn, a, b = map(int, input().split())\nXV = []\nfor i in range(n):\n    x, vx, vy = map(int, input().split())\n    XV.append((x, vx, vy))\nif a != 0:\n    ans = 0\n    d = defaultdict(lambda:0)\n    dvx = defaultdict(lambda:0)\n    for x, vx, vy in XV:\n        k = -a*vx+vy\n        ans += max(0, d[k]-dvx[(k, vx)])\n        d[k] += 1\n        dvx[(k, vx)] += 1\n    print(ans*2)\nelse:\n    ans = 0\n    d = defaultdict(lambda:defaultdict(lambda:0))\n    ds = defaultdict(lambda:0)\n    for x, vx, vy in XV:\n        ans += max(0, ds[vy]-d[vy][vx])\n        d[vy][vx] += 1\n        ds[vy] += 1\n    print(ans*2)\n", "complexity": "linear", "problem": "0975_D", "from": "CODEFORCES", "tags": "geometry,math"}
{"src": "n=int(input())\ndict1={}\ndict2={}\nfor i in range(n):\n    s=input()\n    s=s.split('/')\n    c=int(s[1])\n    s=s[0].strip('(').strip(')').split('+')\n    a=int(s[0])\n    b=int(s[1])\n    ans=(a+b)/c\n    try:\n        dict2[ans] += 1\n    except:\n        dict2[ans] = 1\n    dict1[i] = ans\nfor i in range(n):\n    print(dict2[dict1[i]],end=' ')\n", "complexity": "linear", "problem": "0958_D1", "from": "CODEFORCES", "tags": "expression parsing,math"}
{"src": "from itertools import combinations\n\np, minn, maxn, dif = map(int, input().split())\n(*lst,) = map(int, input().split())\nc = 0\nfor i in range(2, p + 2):\n    for j in combinations(lst, i):\n        if (maxn >= sum(j) >= minn) and (max(j) - min(j) >= dif):\n            c += 1\nprint(c)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import sys\ninput = sys.stdin.readline\n\nq=int(input())\n\nfor testcases in range(q):\n    n,k=map(int,input().split())\n    S=list(input().strip())\n\n    for i in range(n):\n        if S[i]==\"R\":\n            S[i]=0\n        elif S[i]==\"G\":\n            S[i]=1\n        else:\n            S[i]=2\n\n    ANS=1<<50\n\n\n\n    for mod in range(3):\n        SUM=0\n        for i in range(k):\n            if S[i]%3!=(mod+i)%3:\n                SUM+=1\n\n        ANS=min(ANS,SUM)\n\n\n        for i in range(k,n):\n            if S[i-k]!=(mod+(i-k))%3:\n                SUM-=1\n            if S[i]!=(mod+i)%3:\n                SUM+=1\n\n\n\n            ANS=min(ANS,SUM)\n\n    print(ANS)\n\n        \n                \n        \n\n    \n", "complexity": "linear", "problem": "1196_D2", "from": "CODEFORCES", "tags": "data structures,dp,implementation,two pointers"}
{"src": "import math\n\nn, r = map(float, input().split())\na = math.pi / n\ns = math.sin(a)\nR = (r * s) / (1 - s)\nprint(R)\n", "complexity": "constant", "problem": "1100_C", "from": "CODEFORCES", "tags": "binary search,geometry,math"}
{"src": "a = input()\nb = input()\ndigits = {}\ndef greedy(digits,s):\n    for i in range(9,-1,-1):\n        d = str(i)\n        if d in digits:\n            while digits[d] > 0:\n                s += d\n                digits[d] -= 1\n    return s\nfor d in a:\n    if d in digits:\n        digits[d] += 1\n    else:\n        digits[d] = 1\nif len(a) < len(b):\n    print(greedy(digits,\"\"))\nelse:\n    ind = 0\n    cur = \"\"\n    back = False\n    done = False\n    while 1:\n        if ind == len(a) or done == True:\n            break\n        found = False\n        for i in range(9,-1,-1):\n            x = str(i)\n            if i == int(b[ind]) and x in digits and digits[x] > 0:\n                found = True\n                digits[x] -= 1\n                cur += x\n                break\n            elif i < int(b[ind]) and x in digits and digits[x] > 0:\n                found = True\n                done = True\n                digits[x] -= 1\n                cur += x\n                print(greedy(digits,cur))\n                break\n        if found == False:\n            back = True\n            break\n        ind += 1\n    \n    if back == False and done == False:\n        print(cur)\n    elif done == False:\n        for i in range(ind-1,-1,-1):\n            digits[cur[i]] += 1\n            for j in range(9,-1,-1):\n                d = str(j)\n                if j < int(b[i]) and d in digits and digits[d] > 0:\n                    done = True\n                    s = cur[:i]\n                    s += d\n                    digits[d] -= 1\n                    print(greedy(digits,s))\n                    break\n            if done:\n                break", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "N, K = map(int, input().split())\nA = [int(a) for a in input().split()]\nD = sorted([A[i+1]-A[i] for i in range(N-1)])\nprint(A[-1]-A[0]-(sum(D[-K+1:]) if K-1 else 0))\n", "complexity": "nlogn", "problem": "1197_C", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "from collections import deque\nfrom sys import stdin\nlines = deque(line.strip() for line in stdin.readlines())\n\ndef nextline():\n    return lines.popleft()\n\ndef types(cast, sep=None):\n    return tuple(cast(x) for x in strs(sep=sep))\n\ndef ints(sep=None):\n    return types(int, sep=sep)\n\ndef strs(sep=None):\n    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))\n\ndef main():\n    # lines will now contain all of the input's lines in a list\n    n = int(nextline())\n    a = ints()\n    bs = set()\n    moves = {}\n    for i in range(n):\n        moves[a[i]] = list(a[j] for j in range(i % a[i], n, a[i]) if a[j] > a[i])\n    winners = {}\n    for i in range(n, 0, -1):\n        winner = 'A' if any(winners[j] == 'B' for j in moves[i]) else 'B'\n        if winner == 'B':\n            bs.add(i)\n        winners[i] = winner\n    print(''.join(winners[ai] for ai in a))\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "linear", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "n,m = map(int,input().split())\narr1 = [int(i) for i in input().split()]\narr2 = [int(i) for i in input().split()]\n# arr3 = []\nfor first in arr1:\n    for second in arr2:\n        if first == second:\n            # arr3.append(first)\n            print(first,end=\" \")", "complexity": "quadratic", "problem": "0994_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\np = list(map(int, input().split()))\nx = [0] * (n + 1)\nfor i in range(n):\n    if p[i] < m:\n        x[i + 1] = -1\n    elif p[i] > m:\n        x[i + 1] = 1\n    else:\n        l = i\nfor i in range(1, n + 1):\n    x[i] += x[i - 1]\ncnt = [defaultdict(lambda : 0) for _ in range(2)]\nfor i in range(l + 1):\n    cnt[i % 2][x[i]] += 1\nans = 0\nfor i in range(l + 1, n + 1):\n    xi = x[i]\n    ans += cnt[i % 2][xi - 1]\n    ans += cnt[i % 2 ^ 1][xi]\nprint(ans)", "complexity": "nlogn", "problem": "1005_E1", "from": "CODEFORCES", "tags": "sortings"}
{"src": "n = int(input())\nprint((n//2)+1)", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "#!/usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef S(): return input().rstrip()\ndef LS(): return S().split()\ndef IR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = II()\n    return res\ndef LIR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LI()\n    return res\ndef FR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = IF()\n    return res\ndef LIR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = IF()\n    return res\ndef LIR_(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LI_()\n    return res\ndef SR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = S()\n    return res\ndef LSR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LS()\n    return res\nmod = 1000000007\ninf = float('INF')\n\n#solve\ndef solve():\n    n = II()\n    a = LI()\n    dp = [[None for i in range(n + 1)] for i in range(n + 1)]\n    for i in range(n):\n        dp[i][i + 1] = [a[i], a[i], 1]\n        dp[i + 1][i] = [a[i], a[i], 1]\n    for i in range(2, n + 1):\n        for l in range(n - i + 1):\n            tmp = [-inf, inf, inf]\n            r = l + i\n            dpl = dp[l]\n            dpr = dp[r]\n            for m in range(l + 1, r):\n                lm = dpl[m]\n                mr = dpr[m]\n                lr = lm[2] + mr[2] - (lm[1] == mr[0])\n                if lr < tmp[2]:\n                    tmp[2] = lr\n                    if lm[1] == mr[0]:\n                        if lm[2] == 1:\n                            tmp[0] = lm[0] + 1\n                        else:\n                            tmp[0] = lm[0]\n                        if mr[2] == 1:\n                            tmp[1] = mr[1] + 1\n                        else:\n                            tmp[1] = mr[1]\n                    else:\n                        tmp[0] = lm[0]\n                        tmp[1] = mr[1]\n            dp[l][r] = tmp\n            dp[r][l] = tmp\n    print(dp[0][n][2])\n    return\n\n\n#main\nif __name__ == '__main__':\n    solve()\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys\nfrom array import array  # noqa: F401\nfrom typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\ndef main():\n    n, m = map(int, input().split())\n    mat = [array('i', map(int, input().split())) for _ in range(n)]\n    bit = [1 << i for i in range(m)]\n    max_bit = 1 << m\n    fullbit = max_bit - 1\n\n    def solve(x: int) -> Tuple[int, int]:\n        dp = array('i', [-1]) * max_bit\n        for i in range(n):\n            dp[sum(bit[j] for j, y in enumerate(mat[i]) if y >= x)] = i\n\n        for i in range(max_bit):\n            if dp[i] == -1:\n                continue\n            for j in range(i, max_bit):\n                if dp[j] != -1 and i | j == fullbit:\n                    return dp[i], dp[j]\n\n        return -1, -1\n\n    ok, ng = 0, 10**9 + 1\n    ans_i, ans_j = 1, 1\n\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) >> 1\n        x, y = solve(mid)\n        if x == -1:\n            ng = mid\n        else:\n            ok = mid\n            ans_i, ans_j = x + 1, y + 1\n\n    print(ans_i, ans_j)\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "#!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport threading \nfrom bisect import bisect_right\nfrom math import gcd,log\nfrom collections import Counter,defaultdict,deque\nfrom pprint import pprint\nfrom itertools import permutations \nfrom bisect import bisect_right\nfrom random import randint as rti \n# import deque\nn,m=0,0\n\n\n    \n\n\n\ndef main(tnum):\n    global n,m,d\n    n,m,k=map(int,input().split())\n    if k%2:\n        ans=[[-1]*m for i in range(n)]\n        for li in ans:\n            print(*li)\n        return \n    cost=dict()\n    dp=[[float('inf')]*m for i in range(n)] \n    crr=[]\n    rrr=[]\n    for i in range(n):\n        arr=list(map(int,input().split()))\n        for j in range(m-1):\n            dp[i][j]=min(dp[i][j],arr[j])\n            dp[i][j+1]=min(dp[i][j+1],arr[j])\n        crr.append(arr)\n\n\n    for i in range(n-1):\n        arr=list(map(int,input().split())) \n        for j in range(m):\n            dp[i][j]=min(dp[i][j],arr[j])\n            dp[i+1][j]=min(dp[i+1][j],arr[j])\n\n\n        rrr.append(arr)\n\n    for i in range(1,k//2):\n        ndp=[[float('inf')]*m for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                x,y=i,j\n                if x>0:\n                    ndp[i][j]=min(ndp[i][j],dp[x-1][y]+rrr[x-1][y])\n                if x<n-1:\n                    ndp[i][j]=min(ndp[i][j],dp[x+1][y]+rrr[x][y])\n                if y>0:\n                    ndp[i][j]=min(ndp[i][j],dp[x][y-1]+crr[x][y-1])\n                if y<m-1:\n                    ndp[i][j]=min(ndp[i][j],dp[x][y+1]+crr[x][y])\n        dp=ndp\n    for li in dp:\n        li=[2*x for x in li]\n        print(*li)  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n        \n\n\n\n\n    \n\n    \n\n\n\n\n\n\n\n\n        \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \nif __name__ == \"__main__\":\n\n    for _ in range(1): \n        main(_+1)\n\n\n\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from math import factorial,pow\ns1=list(input())\ns2=list(input())\nS1={\"+\":0, \"-\":0}\nS2={\"+\":0, \"-\":0, \"?\":0}\nfor i in s1:\n    S1[i]+=1\nfor i in s2:\n    S2[i]+=1\nif S1[\"+\"]-S2[\"+\"]>=0 and S1[\"-\"]-S2[\"-\"]>=0:\n    pos=S1[\"+\"]-S2[\"+\"]\n    neg=S1[\"-\"]-S2[\"-\"]\n    ques=S2[\"?\"]\n    res=(factorial(pos+neg)/(factorial(pos)*factorial(neg)))/pow(2,ques)\n    print(\"%.12f\"%res)\nelse:\n    print(\"%.12f\" % 0)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "n,m=map(int,input().split())\nlist1=list(map(int,input().split()))\nlist2=list(map(int,input().split()))\nfor i in list1:\n    if i in list2:\n        print(i,end=' ')\n", "complexity": "quadratic", "problem": "0994_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n,k=map(int,input().split())\na=list(map(int,input().split()))\nq={0}\ne=0\nl=[]\nfor i in range(n):\n    if a[i] not in q:\n        e+=1\n        q.add(a[i])\n    if e==k:\n        e=0\n        q={0}\n        l+=[i]\nw=10**5\nt=0\nfor i in l:\n    e=0\n    q={0}\n    for j in range(i,-1,-1):\n        if a[j] not in q:\n            e+=1\n            q.add(a[j])\n        if e==k:\n            if w>len(q):\n                w=j+1\n                t=i+1\n            break\nif len(set(a))>=k:print(w,t)\nelse:print(-1,-1)\n", "complexity": "linear", "problem": "0224_B", "from": "CODEFORCES", "tags": "bitmasks,implementation,two pointers"}
{"src": "n = int(raw_input())\na = list(raw_input())\nb = list(raw_input())\n\nans = 0\n\nfor i in range(n - 1):\n    if a[i] == b[i]:\n        continue\n    if a[i + 1] == b[i + 1]:\n        continue\n\n    if a[i] == b[i + 1] and a[i + 1] == b[i]:\n        a[i], a[i + 1] = a[i + 1], a[i]\n        ans += 1\n\n\nfor i in range(n):\n    ans += a[i] != b[i]\n\nprint(ans)\n", "complexity": "linear", "problem": "1037_C", "from": "CODEFORCES", "tags": "dp,greedy,strings"}
{"src": "#l=list(map(int,raw_input().split()))\nn=int(input())\nprint(2*(n*(n-1))+1)\n", "complexity": "constant", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "f=input\nD,E={},[eval(f())for _ in range(int(f()))]\nfor e in E:D[e]=D.get(e,0)+1\nfor e in E:print(D[e])", "complexity": "linear", "problem": "0958_D1", "from": "CODEFORCES", "tags": "expression parsing,math"}
{"src": "n = int(input())\nn+=1\nif n==1:\n\tprint(0)\nelif n%2==0:\n\tprint(n//2)\nelif n%2!=0 and n!=1:\n\tprint(n)", "complexity": "constant", "problem": "0979_A", "from": "CODEFORCES", "tags": "math"}
{"src": "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(0)\n    else:\n        max1 = max2 = -1\n        for q in a:\n            if q > max1:\n                max1, max2 = q, max1\n            elif q > max2:\n                max2 = q\n        print(max(0, min(max2-1, len(a)-2)))\n", "complexity": "linear", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nx = list(map(int, input().split()))\nx.sort()\ns = set(x)\nm, ans = 1, [x[0]]\npow2 = [1]\nfor _ in range(35):\n    pow2.append(2 * pow2[-1])\nfor i in x:\n    for j in pow2:\n        if (i - j) in s and (i + j) in s:\n            m = 3\n            ans = [i - j, i, i + j]\n            break\n        elif (i - j) in s and m < 2:\n            m = 2\n            ans = [i, i - j]\n        elif (i + j) in s and m < 2:\n            m = 2\n            ans = [i, i + j]\n    if m == 3:\n        break\nprint(m)\nprint(*ans)", "complexity": "nlogn", "problem": "0988_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "import sys\n\nimport random\n\n\n\nn = int(input())\nif n<=3:\n    print('YES')\n    sys.exit()\ncoord = [int(x) for line in sys.stdin for x in line.split()]\n\n\nX = [coord[2*i] for i in range(n)]\nY = [coord[2*i+1] for i in range(n)]\n\n\nfor i in range(13):\n    a = random.randint(0,n-1)\n    b = random.randint(0,n-2)\n    \n    if a==b:\n        b+=1\n    \n    x0,y0 = X[a],Y[a]\n    x1,y1 = X[b],Y[b]\n    \n    dx = x1-x0\n    dy = y1-y0\n    not_on_line = []\n    for c in range(n):\n        if c==a or c==b:\n            continue\n        x2,y2 = X[c],Y[c]\n        Dx = x2-x0\n        Dy = y2-y0\n        if dx*Dy-dy*Dx!=0:\n            not_on_line.append(c)\n    if len(not_on_line)<=1:\n        print('YES')\n        sys.exit()\n\n\n    a = not_on_line[0]\n    b = not_on_line[1]\n    x0,y0 = X[a],Y[a]\n    x1,y1 = X[b],Y[b]\n    \n    dx = x1-x0\n    dy = y1-y0\n    can = True\n    for c in not_on_line:\n        if c==a or c==b:\n            continue\n        x2,y2 = X[c],Y[c]\n        Dx = x2-x0\n        Dy = y2-y0\n        if dx*Dy-dy*Dx!=0:\n            can = False\n            break\n    if can:\n        print('YES')\n        sys.exit()\nprint('NO')", "complexity": "nlogn", "problem": "0961_D", "from": "CODEFORCES", "tags": "geometry"}
{"src": "def search(current, digits, target, idx, bulk):\n    if len(current) == len(target) and int(current) <= int(target):\n        print(current)\n        exit(0)\n\n    possibilities = [char for char in digits if bulk or (char <= target[idx] and char in digits)]\n\n    if len(possibilities) == 0:\n        return None\n\n    for possible_digit in sorted(set(possibilities), reverse=True):\n        tmp_digits = list(digits)\n        tmp_digits.remove(possible_digit)\n        if not bulk:\n            bulk = True if possible_digit != target[idx] else False\n        search(current + possible_digit, tmp_digits, target, idx + 1, bulk)\n\n\ndef main():\n    digits = sorted(list(input()), reverse=True)\n    target = input()\n\n    if len(digits) < len(target):\n        print(''.join(digits))\n        exit(0)\n\n    entries = [char for char in digits if char <= target[0]]\n\n    for current in sorted(set(entries), reverse=True):\n        tmp_digits = list(digits)\n        tmp_digits.remove(current)\n        search(current, tmp_digits, target, 1, True if current != target[0] else False)\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "m=1000000007\ndef power(x, y, p=1000000007):\n    res = 1\n    x = x % p \n    while (y > 0) :\n        if ((y & 1) == 1) :\n            res = (res * x) % p\n        y = y >> 1     \n        x = (x * x) % p         \n    return res\nx,k=list(map(int,input().split()))\nif(x==0):\n    print(0)\nelif(k==0):\n    print((x*2)%m)\nelse:\n    temp=power(2,k)\n    maxi=(((x*temp)%m)*2)%m\n    mini=(m+maxi-(2*(temp-1))%m)%m\n    print((((maxi+mini)%m)*500000004)%m)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "#    !/usr/bin/env python3\n#    encoding: UTF-8\n#    Modified: <21/Jun/2019 10:37:27 PM>\n\n\n#    \u272a H4WK3yE\u4e61\n#    Mohd. Farhan Tahir\n#    Indian Institute Of Information Technology (IIIT), Gwalior\n\n\nimport sys\nimport os\nfrom io import IOBase, BytesIO\n\n\ndef main():\n    n = int(input())\n    x = 2 * n - 1\n    ans = x\n    x -= 2\n    curr = 0\n    while x > 0:\n        curr += x\n        x -= 2\n    print(ans + 2 * curr)\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill():\n            pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill()\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        py2 = round(0.5)\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2 == 1:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n            self.read = lambda: self.buffer.read().decode(\"ascii\")\n            self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return map(int, sys.stdin.readline().split())\n\n\ndef input(): return sys.stdin.readline().strip()\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "linear", "problem": "1180_A", "from": "CODEFORCES", "tags": "dp,implementation,math"}
{"src": "n = int(input())\ns = [[\"\" for _ in range(n)] for __ in range(4)]\nfor i in range(3):\n    for j in range(n):\n        s[i][j] = input()\n    input()\nfor j in range(n):\n    s[3][j] = input()\nres = int(1e13)\nfor i in range(24):\n    perm = [0, 1, 2, 3]\n    L = [0]*4\n    tmp = i\n    for j in range(4):\n        L[j] = tmp % (4-j)\n        tmp //= (4-j)\n    LL = [0]*4\n    for j in range(4):\n        LL[j] = perm[L[j]]\n        for k in range(L[j], 3-j):\n            perm[k] = perm[k+1]\n    lu, ru, ld, rd = LL[0], LL[1], LL[2], LL[3]\n    Map = [s[lu][_][:]+s[ru][_][:] for _ in range(n)] + [s[ld][_][:]+s[rd][_][:] for _ in range(n)]\n    cnt0, cnt1 = 0, 0\n    for j in range(2*n):\n        for k in range(2*n):\n            if (j+k) % 2:\n                if Map[j][k] == '0':\n                    cnt0 += 1\n                else:\n                    cnt1 += 1\n            else:\n                if Map[j][k] == '1':\n                    cnt0 += 1\n                else:\n                    cnt1 += 1\n    res = min(res, cnt0, cnt1)\nprint(res)", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "n = int(input())\nA = list(map(int, input().split()))\nif n == 1:\n    if A[0] >= 0:\n        print(A[0])\n    else:\n        print(-A[0]-1)\n    exit(0)\nfor i in range(n):\n    if A[i] < 0:\n        pass\n    else:\n        A[i] = -A[i]-1\nif n % 2 == 0:\n    print(*A)\n    exit(0)\nmim = 0\nindmim = 0\nfor i in range(n):\n    if A[i] < mim:\n        mim = A[i]\n        indmim = i\nA[indmim] = -A[indmim]-1\nprint(*A)\n", "complexity": "linear", "problem": "1180_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n#sys.setrecursionlimit(111111) \nINF=99999999999999999999999999999999\ndef outIn(x):\n    print(x, flush=True)\n    return input()\ndef main():\n\n    mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n    ###CODE\n    tc = 1\n    for _ in range(tc):\n        s=rs()\n        d=Counter(s)\n        if '1' in d:\n            news=\"\"\n            for i in s:\n                if i!='1':\n                    news+=i\n            ans=\"\"\n            ind=len(news)\n            for i in range(len(news)):\n                if news[i]=='2':\n                    ind=i\n                    break\n                \n            ans=news[0:ind]+'1'*d['1']+news[ind:]\n            ws(ans)\n        else:\n            ws(s)\n                \n                \n            \n                    \n                    \n                     \n                \n        \n                        \n\n            \n            \n                    \n                \n                \n        \n                \n                          \n            \n        \n    \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    ", "complexity": "linear", "problem": "1009_B", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "R,G,B=map(int,input().split())\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr.sort()\ng.sort()\nb.sort()\n\ndp=[[[0 for i in range(B+1)] for j in range(G+1)] for i in range(R+1)]\n\nfor i in range(1,R+1):\n    for j in range(1,G+1):\n        dp[i][j][0]=dp[i-1][j-1][0]+r[i-1]*g[j-1]\n\nfor j in range(1,G+1):\n    for k in range(1,B+1):\n        dp[0][j][k]=dp[0][j-1][k-1]+b[k-1]*g[j-1]\n\nfor i in range(1,R+1):\n    for k in range(1,B+1):\n        dp[i][0][k]=dp[i-1][0][k-1]+r[i-1]*b[k-1]\n\nfor i in range(1,R+1):\n    for j in range(1,G+1):\n        for k in range(1,B+1):\n            if max(r[i-1],g[j-1],b[k-1])==r[i-1]:\n                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])\n            elif max(r[i-1],g[j-1],b[k-1])==g[j-1]:\n                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i][j-1][k-1]+g[j-1]*b[k-1])\n            else:\n                dp[i][j][k]=max(dp[i][j-1][k-1]+b[k-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])\n\n\n\nprint(dp[R][G][B])\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\ndef getMul(x):\n    a = 1\n    for xi in x:\n        a *= xi\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\nd = {}\nfor ai in a:\n    if ai in d: d[ai] += 1\n    else: d[ai] = 1\n\nf = [[] for i in range(max(a)+10)]\nfor i in range(1, len(f)):\n    for j in range(i, len(f), i):\n        f[j].append(i)\n\nseq = [0 for i in range(max(a)+10)]\nfor ai in d:\n    for fi in f[ai]:\n        seq[fi] += d[ai]\nfor i in range(len(seq)):\n    seq[i] = (pow(2, seq[i], MOD) -1 +MOD) % MOD\n\npf = [[] for i in range(max(a)+10)]\npf[0] = None\npf[1].append(1)\nfor i in range(2, len(f)):\n    if len(pf[i]) == 0:\n        for j in range(i, len(pf), i):\n            pf[j].append(i)\nfor i in range(1, len(pf)):\n    mul = getMul(pf[i])\n    if mul == i:\n        if len(pf[i])&1 == 1: pf[i] = -1\n        else: pf[i] = 1\n    else:\n        pf[i] = 0\npf[1] = 1\n\nans = 0\nfor i in range(1, len(seq)):\n    ans += seq[i]*pf[i]\n    ans = (ans + MOD) % MOD\nprint(ans)", "complexity": "np", "problem": "0803_F", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,number theory"}
{"src": "from itertools import permutations\n\nn = int(input())\na = []\nfor i in range(4):\n    a.append([list(map(int, list(input()))) for j in range(n)])\n    if i < 3:\n        input()\n\nans = 10 ** 10\nfor i in permutations(a, 4):\n    cnt = 0\n    total = 0\n    for j in i:\n        if cnt < 2:\n            cnt2 = 0\n            for p in j:\n                for q in p:\n                    if q != cnt2 % 2:\n                        total += 1\n                    cnt2 += 1\n        else:\n            cnt2 = 1\n            for p in j:\n                for q in p:\n                    if q != cnt2 % 2:\n                        total += 1\n                    cnt2 += 1\n        cnt += 1\n\n    ans = min(ans, total)\n\nprint(ans)", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "q = int(input())\nfor i in range(q):\n    n, m, k = map(int, input().split())\n    m, n = abs(m), abs(n)\n    mx = max(m, n)\n    remaining = k - mx\n    if remaining < 0:\n        print(-1)\n    elif m == n == 0:\n        if k == 1:\n            print(-1)\n        elif k % 2:\n            print(k - 1)\n        else:\n            print(k)\n    elif abs(m - n) % 2 == 0:\n        if remaining % 2 == 0:\n            print(k)\n        else:\n            print(k - 2)\n    else:\n        if not remaining:\n            print(k - 1)\n        elif remaining % 2 == 0:\n            print(k - 1)\n        else:\n            print(k - 1)\n", "complexity": "constant", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "from sys import stdin, stdout\nimport heapq\nfrom collections import defaultdict\nimport math\nimport bisect\n\n\n\n\ndef main():\n    n,m,k = list(map(int, stdin.readline().split()))\n    right = []\n    for _ in range(n):\n        right.append(list(map(int, stdin.readline().split())))\n    down = []\n    for _ in range(n-1):\n        down.append(list(map(int, stdin.readline().split())))\n    if k % 2 == 1:\n        for _ in range(n):\n            stdout.write(\" \".join([\"-1\" for _ in range(m)])+\"\\n\")\n        return\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    for x in range(1, (k//2) + 1):\n        tmp = [[math.inf for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i:\n                    tmp[i][j] = min(tmp[i][j], dp[i-1][j] + 2 * down[i-1][j])\n                if i < n-1:\n                    tmp[i][j] = min(tmp[i][j], dp[i + 1][j] + 2 * down[i][j])\n                if j:\n                    tmp[i][j] = min(tmp[i][j], dp[i][j - 1] + 2 * right[i][j - 1])\n                if j < m-1:\n                    tmp[i][j] = min(tmp[i][j], dp[i][j + 1] + 2 * right[i][j])\n        dp = tmp\n        #print(dp)\n    for i in range(n):\n        stdout.write(\" \".join([str(x) for x in dp[i]]) + \"\\n\")\n\nmain()", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import sys,atexit\nfrom io import BytesIO\ninp = BytesIO(sys.stdin.buffer.read())\ninput = lambda:inp.readline().decode('ascii')\nbuf = BytesIO()\nsys.stdout.write = lambda s: buf.write(s.encode('ascii'))\natexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))\n\nn,m = map(int,input().split())\nif m%2 == 0:\n    steps = []\n    for j in range(m//2):\n        for i in range(n):\n            steps.append((j,i))\n            steps.append((m-j-1,n-i-1))\nelse:\n    steps = []\n    for j in range(m//2):\n        for i in range(n):\n            steps.append((j,i))\n            steps.append((m-j-1,n-i-1))\n    l = 0\n    r = n-1\n    mid = m//2\n    while l<=r:\n        steps.append((mid,l))\n        if l != r:\n            steps.append((mid,r))\n        l += 1\n        r -= 1\n\nfor x,y in steps:\n    print(y+1,x+1)\n\n#vis = set()\n#for i in range(1,len(steps)):\n#    dx,dy = steps[i][0]-steps[i-1][0],steps[i][1]-steps[i-1][1]\n#    assert((dx,dy) not in vis)\n#    vis.add((dx,dy))\n\n#print(steps)\n#C = [list('.'*m) for _ in range(n)]\n#for i,e in enumerate(steps):\n#    x,y = e\n#    C[y][x] = chr(65+i)\n#for c in C:\n#    print(''.join(c))\n", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "import sys\ninput=sys.stdin.buffer.readline\n\nnr,ng,nb=[int(x) for x in input().split()]\nr=[int(x) for x in input().split()]\ng=[int(x) for x in input().split()]\nb=[int(x) for x in input().split()]\n\nr.sort()\ng.sort()\nb.sort()\n\nmemo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]\nmemo[0][0][0]=0 #starting point when i==-1,j==-1,k==-1\nfor i in range(nr):\n    memo[i+1][0][0]=0\nfor j in range(ng):\n    memo[0][j+1][0]=0\nfor k in range(nb):\n    memo[0][0][k+1]=0\ndef dp(i,j,k): #dp(i,j,k) is the max value including r[i],g[j],b[k]\n    if i<-1 or j<-1 or k<-1:\n        return -float('inf')\n    if memo[i+1][j+1][k+1]==-1: #offset by 1 because i,j,k can be -1\n        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],\n                   dp(i-1,j-1,k)+r[i]*g[j],\n                   dp(i-1,j,k-1)+r[i]*b[k]\n                )\n    return memo[i+1][j+1][k+1]\n\nfor i in range(max(nr,ng,nb)):\n    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))\n\n\nprint(dp(nr-1,ng-1,nb-1))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import sys\ninput = sys.stdin.readline\nq = int(input())\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    R, G, B = 0, 0, 0\n    ans = float('inf')\n    for j in range(n):\n        if j % 3 == 0:\n            if s[j] == 'R':\n                G += 1\n                B += 1\n            elif s[j] == 'G':\n                R += 1\n                B += 1\n            else:\n                R += 1\n                G += 1\n        elif j % 3 == 1:\n            if s[j] == 'R':\n                G += 1\n                R += 1\n            elif s[j] == 'G':\n                G += 1\n                B += 1\n            else:\n                R += 1\n                B += 1\n        else:\n            if s[j] == 'R':\n                R += 1\n                B += 1\n            elif s[j] == 'G':\n                R += 1\n                G += 1\n            else:\n                G += 1\n                B += 1\n        if j >= k - 1:\n            ans = min(ans, R, G, B)\n            if (j - k + 1) % 3 == 0:\n                if s[j - k + 1] == 'R':\n                    G -= 1\n                    B -= 1\n                elif s[j - k + 1] == 'G':\n                    R -= 1\n                    B -= 1\n                else:\n                    R -= 1\n                    G -= 1\n            elif (j - k + 1) % 3 == 1:\n                if s[j - k + 1] == 'R':\n                    G -= 1\n                    R -= 1\n                elif s[j - k + 1] == 'G':\n                    G -= 1\n                    B -= 1\n                else:\n                    R -= 1\n                    B -= 1\n            else:\n                if s[j - k + 1] == 'R':\n                    R -= 1\n                    B -= 1\n                elif s[j - k + 1] == 'G':\n                    R -= 1\n                    G -= 1\n                else:\n                    G -= 1\n                    B -= 1\n\n    print(ans)", "complexity": "linear", "problem": "1196_D1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import sys\nfrom math import gcd\nfrom collections import defaultdict as dd\ninput=sys.stdin.readline\nn=int(input())\nl=list(map(int,input().split()))\nc=list(map(int,input().split()))\ndp=dict()\nfor i in range(n):\n    if dp.get(l[i]):\n        dp[l[i]]=min(dp[l[i]],c[i])\n    else:\n        dp[l[i]]=c[i]\nfor ll in l:\n    keys=list(dp.keys())\n    for j in keys:\n        g=gcd(j,ll)\n        if dp.get(g):\n            dp[g]=min(dp[g],dp[ll]+dp[j])\n        else:\n            dp[g]=dp[ll]+dp[j]\nif 1 in dp:\n    print(dp[1])\nelse:\n    print(-1)", "complexity": "np", "problem": "0510_D", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,math"}
{"src": "# _\n#####################################################################################################################\n\ndef main():\n    pieces_Dimension = int(input())\n    piece1 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece2 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece3 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece4 = ''.join(input() for _ in range(pieces_Dimension))\n\n    brokenPieces = (piece1, piece2, piece3, piece4)\n    nSquares = pieces_Dimension*pieces_Dimension\n    squares = '01'*(nSquares//2) + '0'\n\n    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)\n\n\ndef nSquaresToRecolorIn(brokenPieces, nSquares, squares):\n    possible_nSquares = [sum(piece[i] != squares[i] for i in range(nSquares)) for piece in brokenPieces]\n    possible_nSquares.sort()\n\n    return 2*nSquares + possible_nSquares[0] + possible_nSquares[1] - possible_nSquares[2] - possible_nSquares[3]\n\n\nif __name__ == '__main__':\n    print(main())\n    # main()\n", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "n,k = [int(x) for x in input().split()]\ndp = [[[0 for _ in range(4)] for _ in range(k+2)] for _ in range(2)]\ndp[1][2][0] = 1\ndp[1][2][1] = 1\ndp[1][1][2] = 1\ndp[1][1][3] = 1\n\n\n\nfor n1 in range(1,n):\n    for k1 in range(1,k+1):\n        \n        dp[0][k1][0] = dp[1][k1][0]\n        dp[0][k1][1] = dp[1][k1][1]\n        dp[0][k1][2] = dp[1][k1][2]\n        dp[0][k1][3] = dp[1][k1][3]\n        \n        dp[1][k1][0] = (dp[0][k1][0] + (dp[0][k1-2][1] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353 \n        \n        dp[1][k1][1] = (dp[0][k1][1] + (dp[0][k1-2][0] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353 \n        \n        dp[1][k1][2] = (dp[0][k1][2] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][3])% 998244353 \n        \n        dp[1][k1][3] = (dp[0][k1][3] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][2])% 998244353 \ntotal = 0\n#print(dp)\nfor i in range(4):\n    total += dp[1][k][i] % 998244353 \n#print(dp)\nprint(total% 998244353 )\n        \n        \n                        \n", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import sys, math\nfrom sys import stdin, stdout\n\nrem = 10 ** 9 + 7\ninf=10**18\nsys.setrecursionlimit(10 ** 6 + 7)\n#from resource import *; setrlimit(RLIMIT_STACK, (RLIM_INFINITY, RLIM_INFINITY))\ntake = lambda: map(int, stdin.readline().split())\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque\nfrom bisect import *\n\n\nn,m=take()\narr=take()\ncheck=take()\ncnt=[0 for i in range(n+m)]\n\nleft=[-1 for i in range(n+m)]\nright=[-1 for i in range(n+m)]\nprev=-1\nfor i in range(n+m):\n    if check[i]==0:\n        left[i]=prev\n    else:\n        prev=i\nprev=-1\nfor i in range(n+m-1,-1,-1):\n    if check[i]==0:\n        right[i]=prev\n    else:\n        prev=i\nfor i in range(n+m):\n    if check[i]==1:\n        continue\n    a=left[i]\n    b=right[i]\n    if a==-1 and b==-1:\n        continue\n    if a==-1 and b!=-1:\n        cnt[b]+=1\n    if a!=-1 and b==-1:\n        cnt[a]+=1\n    if a!=-1 and b!=-1:\n        if abs(arr[i]-arr[a])<=abs(arr[i]-arr[b]):\n            cnt[a]+=1\n        else:\n            cnt[b]+=1\nans=[]\nfor i in range(n+m):\n    if check[i]==1:\n        ans.append(str(cnt[i]))\nstdout.write(' '.join(ans))\n\n\n", "complexity": "linear", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "n,m=[int(x) for x in input().split()]\na=[int(x) for x in input().split()]\ns=sum(a)\nneed=0\na.sort()\nj=1\nflag=0\nk=max(a)\nif n==1:\n    print(0)\nelse:\n    for i in range(n):\n        if a[i]<j:\n            flag=1\n        else:\n            flag=0\n        if a[i]==1:\n            need+=1\n        elif a[i]>=j and i!=n-1:\n            need+=1\n        elif a[i]>=j and i==n-1 and j<=k:\n            need+=k-j+1\n        else:\n            need+=1\n        if flag!=1:\n            j+=1\n    print(s-need)\n        \n        \n", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import math\nn = int(input())\nA = [i + 1 for i in range(n)]\nx = int(math.sqrt(n))\nX = [A[i:i + x] for i in range(0, len(A), x)]\nX = X[::-1]\nf = [item for sublist in X for item in sublist]\nprint(*f)", "complexity": "linear", "problem": "1017_C", "from": "CODEFORCES", "tags": "constructive algorithms,greedy"}
{"src": "n, s = input().split()\n\nn = int(n)\ns = int(s)\n\n\ndef get_decimal_value_digits(number):\n    count = 0\n    digits = 0\n    number = str(number)\n    for digit in number:\n        count += int(digit)\n        digits += 1\n    return count\n\n\ndef is_big_num(number, s):\n    if (number - get_decimal_value_digits(number)) >= s:\n        return True\n    return False\n\n\nstart = s\nend = n\ncount = 0\ndigits = 0\nhalf = (n + s) // 2\n\nwhile (end - start) >= 0:\n    half = (start + end) // 2\n    #decimal = get_decimal_value_digits(half)\n    # if is big number\n    if is_big_num(half, s):\n        end = half - 1\n    else:\n        start = half + 1\n\nif not is_big_num(start+1, s):\n    print(0)\nelse:\n    print(n - start + 1)\n\t\t \t\t\t \t \t\t \t \t\t \t\t   \t\t   \t  \t", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "n,m=map(int,input().split())\na=list(map(int,input().split()))\nk=0\nans=-1\nfor i in range(n-1):\n    while k<n-1 and a[k+1] - a[i]<=m:\n        k+=1\n    if i<k-1:\n        ans=max(ans,(a[k]-a[i+1]) / (a[k]-a[i]))\nprint(ans)", "complexity": "nlogn", "problem": "0957_C", "from": "CODEFORCES", "tags": "binary search,greedy,math,two pointers"}
{"src": "# import builtins\n\ndebug = 0\nBIG = 10 ** 9 + 1\n\ninput = raw_input\n\n\ndef prof(f):\n    return f\n    # if 'profile' in dir(builtins):\n    #     return profile(f)\n    # else:\n    #     return f\n\n\ndef report(f):\n    def new_f(x):\n        res = f(x)\n        # print(f\"{x}  --> {res}\")\n        return res\n\n    return new_f if debug else f\n\n\ndef mcheck(a, pairs):\n    m = len(a[0])\n    allm = 2 ** m - 1\n\n    subs = {i: {i} for i in range(allm + 1)}\n\n    for i in range(allm + 1):\n        for j in range(i):\n            if i | j == i:  # 11 1  10 1   00 0  01 1\n                subs[i].add(j)\n\n    mx = [max(aa) for aa in a]\n\n    @prof\n    def check(v):\n        masks = {0: -1}\n        done = [False] * (allm + 1)\n        for i, aa in enumerate(a):\n            if mx[i] < v:\n                continue\n            c = sum(1 << b for b in range(len(aa)) if aa[b] >= v)\n            # if c == allm:\n            #     pairs[v] = i, i\n            #     return True\n            if not done[c]:\n                for cc in subs[c]:\n                    if allm - cc in masks:\n                        other = masks[allm - c]\n                        pairs[v] = i, other\n                        return True\n                    masks[cc] = i\n                    done[cc] = True\n                # masks[c] = i\n        # for ma, mb in itertools.combinations(masks, 2):\n        #     if ma | mb == allm:\n        #         pairs[v] = masks[ma], masks[mb]\n        #         return True\n        return False\n\n    return check\n\n\n@prof\ndef go():\n    n, m = map(int, input().split())\n\n    a = []\n    # mx = 0\n    # mnmx = 0\n    uniq = set()\n    for _ in range(n):\n        aa = tuple(map(int, input().split()))\n        # mx = max(mx, max(aa))\n        # mnmx = max(mnmx, min(aa))\n        a.append(aa)\n        uniq.update(aa)\n\n    uniq = sorted(uniq)\n    pairs = {0: (0, 0)}\n    check = mcheck(a, pairs)\n    l = 0\n    r = len(uniq) - 1\n    while l != r:\n        if debug: print(l, r)\n        if l + 1 == r:\n            if check(uniq[r]):\n                l = r\n            else:\n                r = l\n            continue\n        c = (l + r) // 2\n        if check(uniq[c]):\n            l = c\n        else:\n            r = c\n\n    l = uniq[l]\n    if debug: print(l, pairs[l])\n    if l not in pairs:\n        check(l)\n    a = pairs[l][0]\n    b = pairs[l][1]\n    if b == -1:\n        b = a\n\n    print(\"%d %d\" % (a + 1, b + 1))\n\n\ngo()\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import sys\nfrom itertools import chain, combinations\n\ndef powerset(iterable):\n\ts = list(iterable)\n\treturn chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n\ndef diff(s, x):\n\treturn True if (max(s)-min(s))>=x else False\n\ndef solve(problemset, l, r, x):\n\tmultiset = powerset(problemset)\n\tcnt = 0\n\tfor s in multiset:\n\t\tif sum(s)>=l and sum(s)<=r and diff(s, x):\n\t\t\tcnt += 1\n\treturn cnt\n\n\nsys.setrecursionlimit(10**7)\n\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI():return map(int, sys.stdin.readline().rstrip().split())\ndef LI():return list(map(int, sys.stdin.readline().rstrip().split()))\ndef LI2():return list(map(int, sys.stdin.readline().rstrip()))\ndef S():return sys.stdin.readline().rstrip()\ndef LS():return list(sys.stdin.readline().rstrip().split())\ndef LS2():return list(sys.stdin.readline().rstrip())\n\nn, l, r, x = MI()\n\nproblemset = LI()\n\nprint(solve(problemset, l, r, x))", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import bisect\ndef solve(l,d,s2,r):\n    ans=\"\"\n    lol=0\n    i=0\n    lo=0\n    while i<(len(s2)):\n        if(lo==1):\n            #print(\"lol\",i)\n            \n            a=s2[i]\n            ind=bisect.bisect_left(l,a)\n            #print(ind,a)\n            for x in range(ind,-1,-1):\n                if(l[x]<l[ind]):\n                    ind=x\n                    #print(\"lol\")\n                    break\n            ans+=str(l[ind])\n            d[l.pop(ind)]-=1\n            \n            lol=1\n            break\n\n        a=s2[i]\n        ind=bisect.bisect_left(l,a)\n        #print(l,ind,a)\n        \n        if(ind==len(l)):\n            ind-=1\n            ans+=str(l[ind])\n            d[l[ind]]-=1\n            lol=1\n            break\n        elif(l[ind]>a):\n            if(ind==0):\n                while ind==0:\n                    \n                    l.append(int(ans[-1]))\n                    d[int(ans[-1])]+=1\n                    l.sort()\n                    ans=ans[:len(ans)-1]\n                    lo=1\n                    i-=1\n                    a=s2[i]\n                    ind=bisect.bisect_left(l,a)\n                #print(i)\n                #i+=1\n                continue\n            lol=1\n            ans+=str(l[ind-1])\n            #print(ans,i)\n            d[l[ind-1]]-=1\n            l.pop(ind-1)\n            break\n        else:\n            ans+=str(l[ind])\n            d[l[ind]]-=1\n            l.pop(ind)\n        i+=1\n    ll=[]\n    #print(\"lol\",d)\n    if(lol):\n        for i in d:\n            if(d[i]!=0):\n                ll.append(i)\n        ll.sort(reverse=True)\n        co=0\n        #print(ll)\n        for i in ll:\n            for j in range(d[i]):\n                if(i==0):\n                    co+=1\n                    if(co>r):\n                        break\n                ans+=str(i)\n                \n    print(ans)\nfrom math import gcd\nimport sys\nfrom collections import defaultdict as dd\ninput=sys.stdin.readline\ns1=list(map(int,input().strip()))\ns2=list(map(int,input().strip()))\nz=s1.count(0)\nd=dd(int)\nn=len(s1)\nm=len(s2)\nl=sorted(s1)\nfor i in s1:\n    d[i]+=1\nif len(s1)<len(s2):\n    for i in range(len(s1)-1,-1,-1):\n        print(l[i],end=\"\")\nelif(len(s1)>len(s2)):\n    r=m-(n-z)\n    #print(l,m,n,z)\n    l=l[z-r:]\n    #print(l,r)\n    solve(l,d,s2,r)\nelse:\n    solve(l,d,s2,100)\n    ", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "input()\na = sorted(list(map(int, input().split())))\nprint(*(*a[:-1], 2) if a[-1] == 1 else (1, *a[:-1]))", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "\na0 = (1 << 30) - 1\n\na0 = 3\nb0 = 1\n\ndef mock_query(c, d):\n    res = (a0 ^ c) - (b0 ^ d)\n    if res > 0:\n        return 1\n    elif res < 0:\n        return -1\n    else:\n        return 0\n\ndef query2(c, d):\n    ans = mock_query(c, d)\n    print('? {:08b} {:08b} --> {}'.format(c, d, ans))\n    return ans\n\ndef query(c, d):\n    print('?', c, d)\n    return int(input())\n\n# query = query2\n\ndef solve():\n    a = 0\n    b = 0\n    last_ans = query(0, 0)\n\n    pos = 29\n    while pos >= 0:\n        bit = 1 << pos\n\n        ans = query(a + bit, b + bit)\n        if (last_ans, ans) == (1, -1):\n            a += bit\n            last_ans = query(a, b)\n        elif (last_ans, ans) == (-1, 1):\n            b += bit\n            last_ans = query(a, b)\n        # elif ans == 0:\n            # pass\n        else:\n            last_ans = ans\n            ans = query(a + bit, b)\n            if ans == -1:\n                a += bit\n                b += bit\n\n        pos -= 1\n\n    print('!', a, b)\n\nsolve()\n", "complexity": "constant", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "def f(n,s):\n d=[-n,-n];d[s]=0\n for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n return d[s]\nimport math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "n = int(input())\na = list(map(int, input().split()))\ndp = [ [False,False,False,False,False] for _ in range(n) ]\ndp[0] = [True, True, True, True, True]\nfor i in range(1, n):\n\tfor j in range(5):\n\t\tif a[i] == a[i - 1]:\n\t\t\tfor k in range(5):\n\t\t\t\tif k != j:\n\t\t\t\t\tdp[i][j] = dp[i][j] or dp[i - 1][k]\n\t\telif a[i] > a[i - 1]:\n\t\t\tfor k in range(j):\n\t\t\t\tdp[i][j] = dp[i][j] or dp[i - 1][k]\n\t\telse:\n\t\t\tfor k in range(j + 1, 5):\n\t\t\t\tdp[i][j] = dp[i][j] or dp[i - 1][k]\nif dp[-1].count(True) == 0:\n\tprint(-1)\n\texit(0)\nj = 0\nfor k in range(5):\n\tif dp[-1][k]:\n\t\tj = k\nans = []\nfor i in range(n - 1, -1, -1):\n\tans.append(j + 1)\n\tif i == 0:\n\t\tbreak\n\tif a[i] == a[i - 1]:\n\t\tfor k in range(5):\n\t\t\tif k != j and dp[i - 1][k]:\n\t\t\t\tj = k\n\t\t\t\tbreak\n\telif a[i] > a[i - 1]:\n\t\tfor k in range(j):\n\t\t\tif dp[i - 1][k]:\n\t\t\t\tj = k\n\t\t\t\tbreak\n\telse:\n\t\tfor k in range(j + 1, 5):\n\t\t\tif dp[i - 1][k]:\n\t\t\t\tj = k\n\t\t\t\tbreak\nprint(*ans[::-1])", "complexity": "quadratic", "problem": "1032_C", "from": "CODEFORCES", "tags": "constructive algorithms,dp"}
{"src": "n, s = map(int, input().strip().split())\n\nnum = ''\ndiv = 9\n\nif s//10 != 0:\n\n    div = 9\n    while (s//div)//10 != 0:\n        div = div*10+9\n    while div:\n        rem = str(s//div)\n        if int(rem) > 9:\n            num = str(int(num)+1) + '0'*len(str(div))\n            div = 0\n            s = 0\n            break\n        else:\n            num += rem\n        s = s%div\n        div //= 10\n    num += str(s)\nelse:\n    num = str(s)\nmini = int(num)\nif mini%10 != 0:\n    mini += 10\n    mini -= mini%10\n\nprint(max(0, n-mini+1))\n\n# while s:\n#     num += str(s%div)\n#     s = s//div\n#     div = div*10+9\n\n# num = num[::-1]\n\n\n# print(max(0, n-mini+1))\n", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "n, m = map(int, input().split())\ndaf1 = list(map(int, input().split()))\ndaf2 = dict()\n\nfor i in range(n):\n    daf2[i+1] = 0\n\nfor i in daf1:\n    if i in daf2.keys():\n        daf2[i] += 1\n\nprint(min(daf2.values()))\n", "complexity": "quadratic", "problem": "0961_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n, t = map(int, input().split())\nl = []\nfor _ in range(n):\n  x, a = map(int, input().split())\n  l.append((x-a/2, x+a/2))\nl.sort()\nres = 2\n# print(l)\nfor i in range(n-1):\n  if l[i+1][0] - l[i][1] == t:\n    res += 1\n  elif l[i+1][0] - l[i][1] > t:\n    res += 2\n\nprint(res)\n", "complexity": "nlogn", "problem": "0015_A", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "#!/bin/python2\n\nfrom sys import stdin, stdout\n\n\nN = 55\n\nf = [0]\nfor i in range(1, N):\n    f.append(f[-1]*4 + 1)\n    if f[-1] > 1e18:\n        break\n\nt = int(stdin.readline().strip().split()[0])\n\nfor ca in range(0, t):\n    n, m = [int(x) for x in stdin.readline().strip().split()]\n    if n > 31:\n        stdout.write(\"YES {}\\n\".format(n-1))\n    else:\n        # n <= 31\n        start = 0\n        found = False\n        res = -1\n        for i in range(1, n+1):\n            start += 2**i -1\n            end = start\n            for k in range(1, i+1):\n                end += f[n-k] * (2**(k+1) - 3)\n            if m >= start and m <= end:\n                found = True\n                res = i\n                break\n        if found:\n            stdout.write(\"YES {}\\n\".format(n-res))\n        else:\n            stdout.write(\"NO\\n\")\n\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "#Winners never quit, quiters never win............................................................................\nfrom collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\n\ndef factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()    \n\n\ndef isPrime(n) : \n\tif (n <= 1) : \n\t\treturn False\n\tif (n <= 3) : \n\t\treturn True\n\n\t\n\tif (n % 2 == 0 or n % 3 == 0) : \n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) : \n\t\tif (n % i == 0 or n % (i + 2) == 0) : \n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number / 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number / i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x): \n    return (math.log10(x) / \n            math.log10(2)); \n\ndef isPowerOfTwo(n): \n    return (math.ceil(Log2(n)) == math.floor(Log2(n))); \n\n   \n#here we go......................\n#winners never quit, quitters never win\nn,k=map(int, input().split())\nkk=list(map(str, input()))\ns=sorted(list(set(kk)))\nif k > 13:\n    print(-1)\nelse:\n    dic={}\n    for index, value in enumerate(\"abcdefghijklmnopqrstuvwxyz\"):\n        dic[value]= index+1\n    #print(dic)\n    ans=0\n    ans+=dic[s[0]]\n    k-=1\n    curr=s[0]\n    for i in range(1,len(s)):\n        if k:\n            if dic[s[i]]>dic[curr]+1:\n                ans+=dic[s[i]]\n                curr=s[i]\n                k-=1\n            if k==0:\n                break\n    if k==0:\n        print(ans)\n    else:\n        print(-1)   \n    \n    \n", "complexity": "linear", "problem": "1011_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import math\nn,k=map(int,input().split())\nedges=[]\nfor i in range(n-1):\n    edges.append(tuple(map(int,input().split())))\ndegreelist=[]\nfor i in range(min(k+1,math.floor(math.log2(n))+10)):\n    degreelist.append({})\ndegrees=degreelist[0]\nfor i in range(1,n+1):\n    degrees[i]=0\nfor guy in edges:\n    degrees[guy[0]]+=1\n    degrees[guy[1]]+=1\nsmall=[]\ncenter=None\ndone=False\nfor i in range(k):\n    if not done:\n        small=[]\n        for guy in degrees:\n            if degrees[guy]==2:\n                print(\"No\")\n                done=True\n                break\n            if degrees[guy]==3:\n                small.append(guy)\n                if center==None: \n                    center=guy\n                elif center!=guy:\n                    print(\"No\")\n                    done=True\n                    break\n            elif degrees[guy]>1:\n                small.append(guy)\n        degrees=degreelist[i+1]\n        if center!=None and center not in small:\n            if not done:\n                print(\"No\")\n            done=True\n            break\n        elif len(small)==0:\n            if not done:\n                print(\"No\")\n            done=True\n            break\n        for guy in small:\n            degrees[guy]=0\n        for guy in edges:\n            if guy[0] in degrees and guy[1] in degrees:\n                degrees[guy[0]]+=1\n                degrees[guy[1]]+=1\n        for guy in degrees:\n            if degrees[guy]>1 and degreelist[i][guy]!=degrees[guy]:\n                if not done:\n                    print(\"No\")\n                done=True\n                break\n    else:\n        break\nif not done:\n    if len(degreelist[-1])==1:\n        print(\"Yes\")\n    else:\n        print(\"No\")", "complexity": "linear", "problem": "1067_B", "from": "CODEFORCES", "tags": "dfs and similar,graphs,shortest paths"}
{"src": "parent = [i for i in range(100002)]\ndef findSet(u):\n    if parent[u] != u:\n        parent[u] = findSet(parent[u])\n    return parent[u]\n\ndef unionSet(u, v):\n    up = findSet(u)\n    vp = findSet(v)\n    parent[up] = vp\n\nif __name__ == '__main__':\n    n, a, b = map(int, input().split())\n    lst = list(map(int, input().split()))\n    temp = {lst[i]: i for i in range(n)}\n    for i in range(n):\n        if a - lst[i] in temp:\n            unionSet(i, temp[a - lst[i]])\n        else:\n            unionSet(i, n)\n        if b - lst[i] in temp:\n            unionSet(i, temp[b - lst[i]])\n        else:\n            unionSet(i, n + 1)\n\n    pa = findSet(n)\n    pb = findSet(n + 1)\n    if pa == pb:\n        print('NO')\n    else:\n        print('YES')\n        lst = [0 if findSet(i) == pb else 1 for i in range(n)]\n        print(*lst)", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import sys\ninput=lambda:sys.stdin.readline().rstrip()\n\nh,w=map(int,input().split())\ns=[list(\".\"*(w+2))]+[list(\".\"+input()+\".\") for _ in range(h)]+[list(\".\"*(w+2))]\nb=[[0]*(w+2)for _ in range(h+2)]\nc=[[0]*(w+2)for _ in range(h+2)]\nfor i in range(1,h+2):\n  for j in range(1,w+2):\n    if s[i][j]==\"*\":\n      b[i][j]=b[i-1][j]+1\n      c[i][j]=c[i][j-1]+1\nfor i in range(h,-1,-1):\n  for j in range(w,-1,-1):\n    if s[i][j]==\"*\":\n      b[i][j]=min(b[i][j],b[i+1][j]+1)\n      c[i][j]=min(c[i][j],c[i][j+1]+1)\nans=[]\nfor i in range(1,h+1):\n  for j in range(1,w+1):\n    t=min(b[i][j],c[i][j])-1\n    if t>0:\n      ans.append((i,j,t))\nb=[[0]*(w+2)for _ in range(h+2)]\nc=[[0]*(w+2)for _ in range(h+2)]\nfor i,j,t in ans:\n  b[i-t][j]+=1\n  b[i+t+1][j]-=1\n  c[i][j-t]+=1\n  c[i][j+t+1]-=1\nfor i in range(h+1):\n  for j in range(w+1):\n    b[i+1][j]+=b[i][j]\n    c[i][j+1]+=c[i][j]\n    if i!=0 and j!=0:\n      if (b[i][j]+c[i][j]>0)!=(s[i][j]==\"*\"):\n        print(-1)\n        exit()\n\nprint(len(ans))\nfor i in ans:print(*i)", "complexity": "quadratic", "problem": "1015_E2", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "n=int(input())\nm=int(input())\nprint(m%(pow(2,n)))", "complexity": "constant", "problem": "0913_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "def power(x,y,p):\n    res=1\n    x=x%p\n    if(x==0):\n        return 0\n    while(y>0):\n        if(y&1):\n            res=(res*x)%p\n        y=y>>1\n        x=(x*x)%p\n    return res\n\nx,k=map(int,input().split())\np=1000000007\nif(x==0):\n    print(\"0\")\nelse:\n    t=(((power(2,k,p))*((2*x-1)%p))%p+1)%p\n    # t=(((power(2,k,p))*(((2*(x%p))%p-1)%p))%p+1)%p\n    #t=((power(2,k,p)%p)*(((2*(x%p))%p-1)%p)%1000000007+1)%p\n    print(t)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n, pos, a, b = map(int,input().split())\n\nlf, rf = a - 1, n - b\nif lf == rf == 0:\n\tprint(\"0\")\nelif lf == 0:\n\tprint(abs(pos-b)+1)\nelif rf == 0:\n\tprint(abs(pos-a)+1)\nelse:\n\tcl = abs(a-pos) + 1\n\tcr = abs(b-pos) + 1\n\txn = abs(a-b) + 1\n\tif cl < cr:\n\t\tprint(cl+xn)\n\telse:\n\t\tprint(cr+xn)", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from sys import stdin\nfrom collections import deque\nc=int(stdin.readline().strip())\nfor cas in range(c):\n    n,m=map(int,stdin.readline().strip().split())\n    s=deque(stdin.readline().strip())\n    arr=[\"R\",\"G\",\"B\"]\n    ans=n+3\n    for k in range(1):\n\n        for  i in range(3):\n            x=i\n\n            dp=[0 for i in range(n+1)]\n            for j in range(n):\n\n                if s[j]!=arr[x]:\n                    dp[j+1]+=1\n                dp[j+1]+=dp[j]\n                if j+1>=m:\n\n                    ans=min(ans,dp[j+1]-dp[j+1-m])\n                x+=1\n                x=x%3\n\n    print(ans)\n                \n            \n    \n            \n            \n1\n", "complexity": "linear", "problem": "1196_D1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "x, k = map(int, input().split())\nmod = 1000000007\nif x == 0:\n    print(0)\nelse:\n    print(int((pow(2, k+1, mod) * x - pow(2, k, mod) + 1) % mod))\n\n", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "n = int(input())\nprint(\"0 0 {}\".format(n))\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "n,m=map(int, input().split())\nout=[n]\ni=n-1\nm-=1\nfor _ in range(n-1):\n    if m%2:\n        out.append(i)\n    else:\n        out=[i]+out\n    \n    m//=2\n    i-=1\n\nfor i in out:\n    print(i, end=\" \")\nprint()\n", "complexity": "np", "problem": "0513_B1", "from": "CODEFORCES", "tags": "brute force"}
{"src": "def mypw2(deg):\n    if (deg >= 1500) : return 2 ** 150\n    # if (deg >= 60): return 10**18 * 20\n    return 2 ** deg\n\ndef sol():\n    n, k = map(int, input().split())\n    if (k == 0):\n        print(\"YES\", n)\n        return\n    for side in range(1, n + 1):\n        MIN = mypw2(side + 1) - side - 2\n        MAX = mypw2(2 * n) - mypw2(2 * n - side + 1) + mypw2(side + 1) + mypw2(2 * n - 2 * side) - 2;\n        MAX //= 3\n        # MAX = (mypw2(2*n) - 1) // 3 - ((2**(2*n - 2 * side) - 1) // 3) * (2**(side + 1) - 1)\n        # print(k, MIN, MAX)\n        if (MIN <= k <= MAX):\n            print(\"YES\", n - side)\n            return\n    print(\"NO\")\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        sol()\n\nmain()", "complexity": "linear", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "#Winners never quit, quiters never win............................................................................\nfrom collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\n\ndef factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()    \ndef decimalToBinary(n): \n    return bin(n).replace(\"0b\", \"\")\n\ndef isPrime(n) : \n\tif (n <= 1) : \n\t\treturn False\n\tif (n <= 3) : \n\t\treturn True\n\n\t\n\tif (n % 2 == 0 or n % 3 == 0) : \n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) : \n\t\tif (n % i == 0 or n % (i + 2) == 0) : \n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number / 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number / i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x): \n    return (math.log10(x) / \n            math.log10(2)); \n\ndef isPowerOfTwo(n): \n    return (math.ceil(Log2(n)) == math.floor(Log2(n))); \n\n   \n#here we go......................\n#winners never quit, quitters never win\nn,k=map(int,input().split())\na=list(map(int,input().split()))\ndic=get_frequency(a)\nss=sorted(list(set(a)))\ntobesubtracttion=0\nfor i in range(len(ss)-1):\n    if ss[i+1] <= ss[i]+k:\n        tobesubtracttion+=dic[ss[i]]\nprint(n-tobesubtracttion)\n    \n\n\n\n\n\n\n\n        ", "complexity": "nlogn", "problem": "0990_B", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "#!/usr/bin/python3\n\nimport math\nimport sys\n\n\nDEBUG = False\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef solve(N, M, A):\n    A.sort(reverse=True)\n\n    lh = A[0]\n    cnt = 1\n    for a in A[1:]:\n        if lh == 1:\n            cnt += 1\n        elif lh - 1 <= a:\n            cnt += 1\n            lh -= 1\n        else:\n            cnt += lh - a\n            lh = a\n\n    cnt += lh - 1\n\n    return sum(A) - cnt\n\n\ndef main():\n    N, M = [int(e) for e in inp().split()]\n    A = [int(e) for e in inp().split()]\n    assert len(A) == N\n    print(solve(N, M, A))\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "n = int(input())\nA = [0] + list(map(int,input().split()))\n\nvec = []\nfor i in range(1, n+1) :\n\tvec = vec + [[A[i], i]]\nlist.sort(vec)\nlist.reverse(vec)\n# print(vec)\n\nif vec[0][0] == 1 :\n\tprint(\"NO\")\n\texit(0)\n\ndia = 0\npath = [vec[0][1]]\nans = []\nbol, col, idx = 1, 1, 0\nfor i in vec[1:] :\n\t# print(i)\n\tif i[0] != 1 :\n\t\tans = ans + [[path[-1], i[1]]]\n\t\tdia = dia+1\n\t\tA[path[-1]] = A[path[-1]]-1\n\t\tpath += [i[1]];\n\t\tA[path[-1]] = A[path[-1]]-1\n\telse :\n\t\tif col == 1:\n\t\t\tdia = dia+1\n\t\t\tcol = 0\n\t\t\tA[path[0]] -= 1\n\t\t\tans = ans+ [[path[0], i[1]]]\n\t\telif bol == 1:\n\t\t\tdia = dia+1\n\t\t\tbol = 0\n\t\t\tA[path[-1]] -= 1\n\t\t\tans = ans + [[path[-1], i[1]]]\n\t\telse :\n\t\t\twhile idx < len(path) and A[path[idx]] == 0 :\n\t\t\t\tidx = idx+1\n\t\t\tif idx == len(path) :\n\t\t\t\tprint(\"NO\")\n\t\t\t\texit(0)\n\t\t\tA[path[idx]] = A[path[idx]] - 1;\n\t\t\tans = ans + [[path[idx], i[1]]]\n\nprint(\"YES\", dia)\nprint(len(ans))\nfor i in ans :\n\tprint(i[0], i[1])\n\n\n\n\n\n", "complexity": "nlogn", "problem": "1082_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "from sys import stdin\nn, m, a, b = map(int, stdin.readline().split())\nx = n%m\nprint(min(a *(m-x), b*x))", "complexity": "linear", "problem": "0990_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "n, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nh = 0\nans = 0\nfor i in range(n - 1):\n    ans += a[i] - 1\n    if a[i] > h:\n        h += 1\nif h < max(a):\n    ans += h\nelse:\n    ans += a[-1] - 1\nprint(ans)\n        \n", "complexity": "nlogn", "problem": "1061_B", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "n, m = map(int, input().split())\nB = list(map(int, input().split()))\nG = list(map(int, input().split()))\nif min(G) < max(B):\n    print(-1)\n    exit(0)\ncnt = 0\nz = max(B)\ny = 0\nf = 1\nf2 = 0\nfor i in B:\n    if i != z or f2:\n        y = max(y, i)\n    else:\n        f2 = 1\nfor i in G:\n    if i == z:\n        f = 0\n    cnt += i - z\nif f:\n    cnt += z - y\nprint(cnt + sum(B) * m)", "complexity": "linear", "problem": "1159_C", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "import sys\n\nrd = lambda : sys.stdin.readline().rstrip()\n\nn = int(rd())\nc = list(map(int, rd().split()))\na = list(map(lambda x: int(x)-1, rd().split()))\n\nvisited = [-1] * (n)\nres = 0\n\nfor i in range(n):\n    trace = []\n    \n    t = i\n    mn = 1e9\n    while visited[t] == -1:\n        visited[t] = i\n        trace.append(t)\n        t = a[t]\n        \n    if visited[t] != i:\n        continue\n        \n    while len(trace) > 0:\n        v = trace.pop()\n        mn = min(mn, c[v]) \n        \n        if t == v: break\n    \n    res += mn\n    \nprint(res)\n    ", "complexity": "linear", "problem": "1027_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs"}
{"src": "import sys\nimport math\n\nprime=[True for _ in range(1000001)]\n\n# # Remove these 2 lines while submitting your code online\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\ndef solve():\n    n,e,h,a,b,c=map(int,input().split())\n    ans=1e9\n    for i in range(1,1000001):\n        su=0\n        ntmp=n\n        tmp1=e\n        tmp2=h\n        tmp1-=i\n        tmp2-=i\n        if (tmp1<0 or tmp2<0 or i>ntmp):\n            break\n        ntmp-=i\n        su+=(c*i)\n        if (ntmp==0):\n            ans=min(ans,su)\n            continue\n        if (a<=b):\n            if ((tmp1//2)>=ntmp):\n                su+=int(a*ntmp)\n                ntmp-=ntmp\n            else:\n                su+=int(a*(tmp1//2))\n                ntmp-=(tmp1//2)\n                if (ntmp<=(tmp2//3)):\n                    su+=int(b*ntmp)\n                    ntmp-=ntmp\n                else:\n                    su+=int(b*(tmp2//3))\n                    ntmp-=(tmp2//3)\n        else:\n            if ((tmp2//3)>=ntmp):\n                su+=int(b*ntmp)\n                ntmp-=ntmp\n            else:\n                su+=int(b*(tmp2//3))\n                ntmp-=(tmp2//3)\n                if (ntmp<=(tmp1//2)):\n                    su+=int(a*ntmp)\n                    ntmp-=ntmp\n                else:\n                    su+=int(a*(tmp1//2))\n                    ntmp-=(tmp1//2)\n        if (ntmp==0):\n            ans=min(ans,su)\n    # print(ans)\n    if (ans==1e9):\n        print(\"-1\")\n    else:\n        print(ans)\n\ndef main():\n    n=int(input())\n    s=input()\n    m={}\n    have={}\n    cc=0\n    for c in s:\n        if (c not in m):\n            m[c]=1\n        else:\n            m[c]+=1\n    ct=len(m)\n    l=0\n    ans=1e9\n    for i in range(0,n):\n        if (s[i] not in have):\n            have[s[i]]=0\n            cc+=1\n        have[s[i]]+=1\n        while(l<=i and have[s[l]]>1):\n            have[s[l]]-=1\n            l+=1\n        if (cc==ct):\n            ans=min(ans,i-l+1)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "complexity": "linear", "problem": "0701_C", "from": "CODEFORCES", "tags": "binary search,strings,two pointers"}
{"src": "t = int(input())\n\ndef sol(n, k):\n    p = 1\n    acc = 0\n    while n > 0 and k >= p:\n        k -= p\n        n -= 1\n        if n >= 40:\n            return n\n        acc += (2*p-1)*(4**n-1)//3\n        if k <= acc:\n            return n\n        p = 2*p+1\n    return -1\n\nfor _ in range(t):\n    n, k = (int(v) for v in input().split())\n    ans = sol(n, k)\n    if ans == -1:\n        print(\"NO\")\n    else:\n        print(\"YES\", ans)", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "n=input()\nn1=int(n)\nc=[]\nfor i in range(0,n1):\n    z4=0\n    p,q=input().split()\n    a=int(p)\n    b=int(q)\n    while a!=0 and b!=0:\n        z1=z3=0\n        if a<=b:\n          z=(b/a)\n          z1=int(z)\n          b=b-(z1*a) \n        if b<=a and b!=0:\n          z2=a/b\n          z3=int(z2)\n          a=a-(z3*b) \n        z4=z4+z1+z3    \n    c.append(z4)\nl=len(c)\nfor j in range(0,l):\n    print(c[j])\n    ", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "class edge(object):\n\tdef __init__(self,ne,to,fl):\n\t\tself.ne=ne\n\t\tself.to=to\n\t\tself.fl=fl\n\ndef add(x,y,z):\n\tglobal tot\n\ttot+=1\n\te.append(edge(he[x],y,z))\n\the[x]=tot\n\ndef addedge(x,y,z):\n\tadd(x,y,z)\n\tadd(y,x,0)\n\ndef bfs():\n\tglobal deep\n\tdeep=[0 for i in range(T+1)]\n\tq=[]\n\tq.append(S)\n\tdeep[S]=1\n\twhile (len(q)>0):\n\t\tx=q[0]\n\t\tdel(q[0])\n\t\ti=he[x]\n\t\twhile (i):\n\t\t\ty=e[i].to\n\t\t\tif ((deep[y]==0)and(e[i].fl!=0)):\n\t\t\t\tdeep[y]=deep[x]+1\n\t\t\t\tq.append(y)\n\t\t\ti=e[i].ne\n\treturn deep[T]!=0\n\ndef dfs(x,flow):\n\tglobal deep\n\tif ((x==T)or(flow==0)):\n\t\treturn flow\n\tused=0\n\ti=he[x]\n\twhile (i):\n\t\ty=e[i].to\n\t\tif ((deep[y]==deep[x]+1)and(e[i].fl!=0)):\n\t\t\tnow=dfs(y,min(flow-used,e[i].fl))\n\t\t\tused+=now\n\t\t\te[i].fl-=now\n\t\t\te[i^1].fl+=now\n\t\t\tif (flow==used):\n\t\t\t\tbreak;\n\t\ti=e[i].ne\n\tif (used==0):\n\t\tdeep[x]=-1\n\treturn used\n\ndef dinic():\n\tres=0\n\twhile (bfs()):\n\t\tres+=dfs(S,INF)\n\treturn res\n\nn,m=map(int,input().split())\nans=0\nweight=[0]+list(map(int,input().split()))\n\ne=[0,0]\ntot=1\nS=n+m+1\nT=S+1\nhe=[0 for i in range(T+1)]\nINF=1000000007\n\nfor i in range(1,n+1):\n\taddedge(S,i,weight[i]);\nfor i in range(1,m+1):\n\tx,y,w=map(int,input().split())\n\taddedge(n+i,T,w)\n\taddedge(x,n+i,INF)\n\taddedge(y,n+i,INF)\n\tans+=w\nans-=dinic()\nprint(ans)", "complexity": "cubic", "problem": "1082_G", "from": "CODEFORCES", "tags": "flows,graphs"}
{"src": "import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nINF = 10**9\n\nn, m = [int(item) for item in input().split()]\ns = input().rstrip()\n\ncount = [[0] * m for _ in range(m)]\nord_a = ord(\"a\")\nfor c1, c2 in zip(s, s[1:]):\n    c1 = ord(c1) - ord_a\n    c2 = ord(c2) - ord_a\n    if c1 != c2:\n        count[c1][c2] += 1\n\nsum_of_subset = [[0] * (1 << m) for _ in range(m)]\nfor i in range(m):\n    for j in range(1 << m):\n        if j == 0:\n            continue\n        lsb = j & -j\n        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n\nadj_in_subset = [0] * (1 << m)\nfor i in range(1 << m):\n    for j in range(m):\n        if i & (1 << j):\n            adj_in_subset[i] += sum_of_subset[j][i]\n\ntotal_adj = adj_in_subset[-1]\ndp = [INF] * (1 << m)\ndp[0] = 0\n\nfor i in range(1 << m):\n    for j in range(m):\n        if i & 1 << j:\n            continue\n        not_i = ((1 << m) - 1) ^ i\n        val = dp[i] + (total_adj - adj_in_subset[i] - adj_in_subset[not_i])\n        dp[i | (1 << j)] = min(dp[i | (1 << j)], val)\nprint(dp[-1])", "complexity": "np", "problem": "1238_E", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "def m():\n\t[x, y, k] = [int(i) for i in input().split()]\n\td=min(x, y)\n\tx-=d\n\ty-=d\n\tk-=d\n\t\n\tif k-x-y<0:\n\t\tprint(-1)\n\telse:\n\t\tx+=y\n\t\tif x%2 > 0 and k%2>0:\n\t\t\tprint(d+k-1)\n\t\telif x%2 >0:\n\t\t\tprint(d+k-1)\n\t\telif k%2>0:\n\t\t\tprint(d+k-2)\n\t\telse:\n\t\t\tprint(d+k)\n\t\t\t\n\t\t\n\t\t\t\n\t\nn=int(input())\nfor i in range(n):\n\tm()", "complexity": "constant", "problem": "1036_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import sys\ninput=sys.stdin.readline\n\ndef count_bits(x):\n    cnt=0\n    for i in range(n):\n        if((1<<i)&x):\n            cnt+=1\n    return(cnt)\n\nn=int(input())\na=[list(map(float,input().split())) for i in range(n)]\ndp=[0 for i in range(1<<n)] #Probabilty a particular permutation of (alive) fish are acheived.\ndp[-1]=1 #We start with all fish, so the probability they all together is 1(base case)\n#We will calculate the probability of acheiving a particular permutation of k alive fish from all possible permutations of k+1 alive fish for all values of k.\nfor mask in range((1<<n)-1,-1,-1):\n    val=count_bits(mask)\n    total=val*(val-1)//2 #Used to calculate the probability of choosing two fish among the alive fish. We will take the case the first fish eats the second fish(the opposite case is dealt again in another loop, won't increase efficiency much), and add to the new permutation the probability of obtaiining it from the current permutation.\n    for i in range(n):\n        if(mask&(1<<i)==0): #We can't choose a dead/eaten fish\n            continue\n        for j in range(n): #Second fish of the pair for the above choosen fish among all other alive fish\n            if(mask&(1<<j)==0 or i==j):\n                continue\n            dp[mask^(1<<j)]+=dp[mask]*a[i][j]/total #considering ith fish eats jth fish\nfor i in range(n):\n    print(dp[1<<i])\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import math;\ndef f(n,s):\n    d=[-n,-n];\n    d[s]=0\n    for i in range(y//g):\n        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n    return d[s]\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny+=x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "def get_ans(x, a, n, m):\n\n    lim = 1<<m\n    match = lim-1\n    track = [-1 for i in range(lim)]\n\n    for i in range(n):\n        mask = 0\n        for j in range(m):\n            if(a[i][j] >= x):\n                mask |= 1 << j\n        track[mask] = i\n\n    for i in range(lim):\n        for j in range(lim):\n            if(i|j == match and track[i] != -1 and track[j] != -1):\n                return track[i], track[j]\n    \n    return -1, -1\n\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\n\nlo = 0\nhi = 1000000000\nwhile(lo < hi-1):\n    mid = (lo+hi)/2\n    i, j = get_ans(mid,a,n,m)\n    if(i == -1):\n        hi = mid-1\n    else:\n        lo = mid\n\ni,j = get_ans(hi,a,n,m)\nif(i != -1):\n    print(\"{} {}\".format(i+1,j+1))\nelse:\n    i,j = get_ans(lo,a,n,m)\n    print(\"{} {}\".format(i+1,j+1))\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "def number(pos):\n    ans = 0\n    for i in range(pos + 1):\n        ans += 2**(i)\n    return ans\n\nl, r = input().split()\nl = int(l)\nr = int(r)\n\nif(l == r):\n    print(0)\nelse:\n    b_pos = 0\n    i = 0\n    while(l > 0 or r > 0):\n        if(l%2 != r%2):\n            b_pos = i\n        l >>= 1\n        r >>= 1\n        i += 1\n    print(number(b_pos))\n\n\t \t\t \t \t \t \t  \t  \t\t\t\t  \t \t \t", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "'''input\n6 5\n5 0 3 1 2\n1 8 9 1 3\n1 2 3 4 5\n9 1 0 3 7\n2 3 0 6 3\n6 4 1 7 0\n'''\n# A coding delight\nfrom sys import stdin, stdout\nimport gc\ngc.disable()\ninput = stdin.readline\nfrom collections import defaultdict\n\n\ndef check(num):\n\tbitmask = set()\n\tfor i in range(n):\n\t\tb = 0\n\t\tfor j in range(m):\n\t\t\tif arr[i][j] >= num:\n\t\t\t\tb ^= 1 << j\n\t\tbitmask.add(b)\n\t# print(num, bitmask)\n\ttarget = 2** m  - 1\n\tfor i in bitmask:\n\t\tfor j in bitmask:\n\t\t\tif i | j ==  target:\n\t\t\t\treturn True\n\treturn False\n\n\n# main starts\nn, m = list(map(int, input().split()))\narr = []\nfor _ in range(n):\n\tarr.append(list(map(int, input().split())))\n\n# print(check(3))\n\nstart = 0\nend = 10 ** 9\nans = -1\nwhile start <= end:\n\tmid = (start + end) // 2\n\tif check(mid):\n\t\tans = mid\n\t\tstart = mid + 1\n\telse:\n\t\tend = mid - 1\n\nbitmask = defaultdict(list)\nfor i in range(n):\n\tb = 0\n\tfor j in range(m):\n\t\tif arr[i][j] >= ans:\n\t\t\tb  += 1<< j\n\tbitmask[b].append(i + 1)\ntarget = 2 ** m - 1\nfor i in bitmask:\n\tfor j in bitmask:\n\t\tif i | j == target:\n\t\t\tprint(bitmask[i][0], bitmask[j][0])\n\t\t\texit()\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import bisect\nimport sys\ninput=sys.stdin.readline\n#t=int(input())\nimport collections \nimport heapq\nt=1\np=10**9+7\ndef ncr_util():\n    \n    inv[0]=inv[1]=1\n    fact[0]=fact[1]=1\n    for i in range(2,300001):\n        inv[i]=(inv[i%p]*(p-p//i))%p\n    for i in range(1,300001):\n        inv[i]=(inv[i-1]*inv[i])%p\n        fact[i]=(fact[i-1]*i)%p\n\n    \ndef solve():\n    ans,a,b=0,0,0\n    mul=2**60\n    for i in range(60,-1,-1):\n        #print(11,mul,a+mul,b+mul)\n        ch1,ch2=0,0\n        if a+mul<=l:\n            #print(1,a,mul)\n            a+=mul\n            ch1=1\n        if  b+mul<=l:\n            #print(2,b,mul)\n            b+=mul\n            ch2=1\n        if ch1^ch2==1:   \n            ans+=mul\n        elif ch1==0 and ch2==0:\n            if a+mul<=r:\n                a+=mul\n                ans+=mul\n            elif b+mul<=r:\n                b+=mul\n                ans+=mul\n            #print(123,ans)\n        mul//=2\n    #print(a,b,a^b)\n    return ans\n     \n    \nfor _ in range(t):\n    #n=int(input())\n    #s=input()\n    #n=int(input())\n    #h,n=(map(int,input().split()))\n    #n1=n\n    #x=int(input())\n    #b=int(input())\n    #n,m,k=map(int,input().split())\n        \n    #l=list(map(int,input().split()))\n    l,r=map(int,input().split())\n    #n=int(input())\n    #s=input()\n    #s1=input()\n    #p=input()\n    #l=list(map(int,input().split()))\n    #l.sort(revrese=True)\n    #l2=list(map(int,input().split()))\n    #l=str(n)\n    #l.sort(reverse=True)\n    #l2.sort(reverse=True)\n    #l1.sort(reverse=True)\n    print(solve())\n            \n        ", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "n, v = map(int, input().split())\nb = 0\nans = 0\nsss = 0\nfor i in range(1, n + 1):\n    while b < v:\n        if sss == n - 1:\n            break\n        sss += 1\n        ans += i\n        b += 1\n    b -= 1\nprint(ans)", "complexity": "quadratic", "problem": "1113_A", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "import sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\nmod = 998244353\na.sort()\ndp = [1] + [0] * n\nfor i in range(1, n + 1):\n    x, pt = 1, i - 2\n    while pt >= 0 and 2 * a[pt] > a[i - 1]:\n        x = x * (n - pt - 2) % mod\n        pt -= 1\n    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod\nprint(dp[-1])", "complexity": "cubic", "problem": "1437_F", "from": "CODEFORCES", "tags": "combinatorics,dp,math,two pointers"}
{"src": "import sys\n\ninput = sys.stdin.readline\n\n\ndef get_input():\n    n, m = [int(x) for x in input().split(' ')]\n    digraph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        c1, c2 = [int(x) for x in input().split(' ')]\n        digraph[c1].append(c2)\n\n    return digraph\n\n\ndef dfs(graph, u=-1, v=-1):\n    n = len(graph)\n\n    pi = [None] * n\n    color = ['white'] * n\n    for node in range(1, n):\n        if color[node] == 'white':\n            cicle = dfs_visit(graph, node, color, pi, u, v)\n            if cicle is not None:\n                return cicle\n    return None\n\n\ndef dfs_visit(graph, root, color, pi, u, v):\n    stack = [root]\n\n    while stack:\n        current_node = stack[-1]\n\n        if color[current_node] != 'white':\n            stack.pop()\n            color[current_node] = 'black'\n            continue\n\n        color[current_node] = 'grey'\n        for adj in graph[current_node]:\n            if (current_node, adj) == (u, v):\n                continue\n\n            if color[adj] == 'white':\n                pi[adj] = current_node\n                stack.append(adj)\n            elif color[adj] == 'grey':\n                cicle = [adj]\n                while current_node != adj:\n                    cicle.append(current_node)\n                    current_node = pi[current_node]\n                cicle.append(adj)\n                return cicle  \n    return None\n\n\nif __name__ == \"__main__\":\n    digraph = get_input()\n    cicle = dfs(digraph)\n    if cicle is None:\n        print(\"YES\")\n    else:\n        cicle.reverse()\n        for i in range(len(cicle) - 1):\n            c = dfs(digraph, cicle[i], cicle[i + 1])\n            if c is None:\n                print(\"YES\")\n                break\n        else:\n            print(\"NO\")\n", "complexity": "quadratic", "problem": "0915_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs"}
{"src": "n = int(input())\ns = input()\nt = input()\npair2ind = {}\nletters_s = [0] * 26\nletters_t = [0] * 26\nnon_common = set()\ncnt = 0\nfor i in range(n):\n    if s[i] != t[i]:\n        pair2ind[(s[i], t[i])] = i + 1\n        letters_s[ord(s[i]) - ord('a')] = i + 1\n        letters_t[ord(t[i]) - ord('a')] = i + 1\n        non_common.add(i + 1)\n        cnt += 1\n\nsim = -1\nfor i in range(26):\n    if letters_s[i] != 0 and letters_t[i] != 0:\n        sim = letters_s[i]\n        break\nelse:\n    print(cnt)\n    print(-1, -1)\n    exit()\n\nfor i in range(n):\n    if s[i] != t[i]:\n        if (t[i], s[i]) in pair2ind:\n            print(cnt - 2)\n            print(pair2ind[(s[i], t[i])], pair2ind[(t[i], s[i])])\n            exit()\n\nnon_common.remove(sim)\nprint(cnt - 1)\nprint(sim, letters_t[ord(s[sim-1]) - ord('a')])\nexit()\n", "complexity": "linear", "problem": "0527_B", "from": "CODEFORCES", "tags": "greedy"}
{"src": "def fastio():\n\timport sys\n\tfrom io import StringIO \n\tfrom atexit import register\n\tglobal input\n\tsys.stdin = StringIO(sys.stdin.read())\n\tinput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\tsys.stdout = StringIO()\n\tregister(lambda : sys.__stdout__.write(sys.stdout.getvalue()))\n# fastio()\n\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\n\nl, r = I()\nif l - r == 0:\n\tprint(0)\n# elif r == l + 1:\n# \tprint(r^l)\nelse:\n\tans = []\n\ta = list(format(l, '064b'))\n\tb = list(format(r, '064b'))\n\ti = 0\n\tll = l\n\trr = r\n\twhile a[i] == b[i]:\n\t\ti += 1\n\tfor i in range(i, 64):\n\t\tif a[i] == '0' and b[i] == '0':\n\t\t\tk = l ^ (2**(64 - i - 1))\n\t\t\tif k <= rr:\n\t\t\t\tl = k\n\t\t\t\ta[i] = '1'\n\t\telif a[i] == '1' and b[i] == '1':\n\t\t\tk = r - (2**(64 - i - 1))\n\t\t\tif k >= ll:\n\t\t\t\tb[i] = '0'\n\t\t\t\tr = k\n\tprint(l^r)", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "# sys.setrecursionlimit(300000)\nimport sys\ndef main():\n    pass\ndef binary(n):\n    # decimal to binary\n    return (bin(n).replace(\"0b\", \"\"))\ndef decimal(s):\n    # binary to decimal\n    return (int(s, 2))\ndef pow2(n):\n    # power of a number base 2\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return (p)\ndef isPrime(n):\n    # if  number is prime in \u221an time\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\ndef lts(l):\n    # list to string ,no spaces\n    s = ''.join(map(str, l))\n    return s\ndef stl(s):\n    # for each character in string to list with no spaces -->\n    l = list(s)\n    # for space in string  -->\n    # l=list(s.split(\" \"))\n    return l\n# Returns list of numbers with a particular sum\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n# 1000000007\nmod = int(1e9) + 7\ndef ssinp(): return sys.stdin.readline().strip()\n#s=input()\ndef iinp(): return int(input())\n#n=int(input())\ndef nninp(): return map(int, sys.stdin.readline().strip().split())\n#n, m, a=[int(x) for x in input().split()]\ndef llinp(): return list(map(int, sys.stdin.readline().strip().split()))\n#a=list(map(int,input().split()))\ndef p(xyz): print(xyz)\ndef p2(a, b): print(a, b)\nimport math\nfrom collections import OrderedDict\n#for _ in range(iinp()):\nn=iinp()\nl=[]\ns={\"purple\",\"green\",\"blue\",\"orange\",\"red\",\"yellow\"}\nfor i in range(n):\n    inp=ssinp()\n    s.remove(inp)\nprint(6-n)\nfor i in s:\n    if(i==\"purple\"):\n        print(\"Power\")\n    elif(i==\"green\"):\n        print(\"Time\")\n    elif(i==\"blue\"):\n        print(\"Space\")\n    elif (i == \"orange\"):\n        print(\"Soul\")\n    elif (i == \"red\"):\n        print(\"Reality\")\n    else:\n        print(\"Mind\")\n\n", "complexity": "constant", "problem": "0987_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n, m = map(int, input().split())\na = 0\nwhile m:\n    a += n//m\n    n, m = m, n % m\nprint(a)\n", "complexity": "constant", "problem": "0343_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "'''     Design by Dinh Viet Anh(JOKER)\n//_____________________________________$$$$$__\n//___________________________________$$$$$$$$$\n//___________________________________$$$___$\n//___________________________$$$____$$$$\n//_________________________$$$$$$$__$$$$$$$$$$$\n//_______________________$$$$$$$$$___$$$$$$$$$$$\n//_______________________$$$___$______$$$$$$$$$$\n//________________$$$$__$$$$_________________$$$\n//_____________$__$$$$__$$$$$$$$$$$_____$____$$$\n//__________$$$___$$$$___$$$$$$$$$$$__$$$$__$$$$\n//_________$$$$___$$$$$___$$$$$$$$$$__$$$$$$$$$\n//____$____$$$_____$$$$__________$$$___$$$$$$$\n//__$$$$__$$$$_____$$$$_____$____$$$_____$\n//__$$$$__$$$_______$$$$__$$$$$$$$$$\n//___$$$$$$$$$______$$$$__$$$$$$$$$\n//___$$$$$$$$$$_____$$$$___$$$$$$\n//___$$$$$$$$$$$_____$$$\n//____$$$$$$$$$$$____$$$$\n//____$$$$$__$$$$$___$$$\n//____$$$$$___$$$$$$\n//____$$$$$____$$$\n//_____$$$$\n//_____$$$$\n//_____$$$$\n'''\nfrom math import *\nfrom cmath import *\nfrom itertools import *\nfrom decimal import *  # su dung voi so thuc\nfrom fractions import *  # su dung voi phan so\nfrom sys import *\nfrom types import CodeType, new_class\n#from numpy import *\n\n'''getcontext().prec = x # lay x-1 chu so sau giay phay (thuoc decimal)\nDecimal('12.3') la 12.3 nhung Decimal(12.3) la 12.30000000012\nFraction(a) # tra ra phan so bang a (Fraction('1.23') la 123/100 Fraction(1.23) la so khac (thuoc Fraction)\na = complex(c, d) a = c + d(i) (c = a.real, d = a.imag)\na.capitalize() bien ki tu dau cua a(string) thanh chu hoa, a.lower() bien a thanh chu thuong, tuong tu voi a.upper()\na.swapcase() doi nguoc hoa thuong, a.title() bien chu hoa sau dau cach, a.replace('a', 'b', slg)\nchr(i) ki tu ma i ord(c) ma ki tu c\na.join['a', 'b', 'c'] = 'a'a'b'a'c, a.strip('a') bo dau va cuoi ki tu 'a'(rstrip, lstrip)\na.split('a', slg = -1) cat theo ki tu 'a' slg lan(rsplit(), lsplit()), a.count('aa', dau = 0, cuoi= len(a)) dem slg\na.startswith('a', dau = 0, cuoi = len(a)) co bat dau bang 'a' ko(tuong tu endswith())\na.index(\"aa\") vi tri dau tien xuat hien (rfind())\ninput = open(\".inp\", mode='r')  a = input.readline()\nout = open(\".out\", mode='w') a.index(val) '''\n#inn = open(\".inp\", \"r\")\n\nk, n, s, p = map(int, input().split())\nprint((k*(n//s + (n%s != 0))) // p + ((k*(n//s + (n%s != 0))) % p != 0))", "complexity": "constant", "problem": "0965_A", "from": "CODEFORCES", "tags": "math"}
{"src": "n, s = map(int, input().split())\ndef really_big(ni, s):\n    dig_sum = sum(list(map(int, list(str(ni)))))\n    return (ni-dig_sum)>=s\ncont = 0\nfor i in range(s, n+1):\n    if really_big(i, s):\n        cont = n-i+1\n        break\nprint(cont)", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "from collections import defaultdict, deque, Counter\nfrom sys import stdin, stdout\nfrom heapq import heappush, heappop\nimport math\nimport io\nimport os\nimport math\nimport bisect\n\n#?############################################################\n\n\ndef isPrime(x):\n    for i in range(2, x):\n        if i*i > x:\n            break\n        if (x % i == 0):\n            return False\n    return True\n\n#?############################################################\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p\n\n\n#?############################################################\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            l.append(int(i))\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\n\n#?############################################################\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n#?############################################################\n\n\ndef sieve(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\n#?############################################################\n\ndef digits(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\n\n#?############################################################\n\n\ndef ceil(n, x):\n    if (n % x == 0):\n        return n//x\n    return n//x+1\n\n#?############################################################\n\n\ndef mapin():\n    return map(int, input().split())\n\n#?############################################################\n\n\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n# python3 15.py<in>op\na, b, c, n = mapin()\nd = a+b-c\n\nif(d > n-1 or c > a or c > b):\n    print(-1)\nelse:\n    print(n-d)", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "import decimal\n\nn, k = input().split(' ')\nn = int(n)\nk = int(k)\ncoef1 = (k*k-k-2*n)*100+225\nif coef1 < 0:\n    print('-1')\nelse:\n    D = decimal.Decimal\n    coef11 = D(coef1)\n    coef1 = coef11.sqrt()\n    coef2 = k*10-5\n    coef = (coef2-coef1)/10\n    if coef % 1 == 0:\n        print(int(coef))\n    else:\n        print(int(coef)+1)\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "N = int(input())\nX = list(map(int, input().split()))\nfrom collections import defaultdict\ndp1 = defaultdict(lambda :-1)\nM=1001\ndef ec(i,j):\n    return i*M+j\n\nfor i in range(N):\n    dp1[ec(i,i+1)] = X[i]\nfor i in range(2, N+1):\n    for j in range(N-i+1):\n        for k in range(1, i):\n            u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)]\n            if u != -1 and v != -1 and u == v:\n                dp1[ec(j,j+i)] = u+1\n                break\n\ndp2 = [10**18]*(N+1)\ndp2[0] = 0\nfor i in range(N):\n    for j in range(i+1):\n        if dp1[ec(j,i+1)] == -1:\n            continue\n        dp2[i+1] = min(dp2[i+1], dp2[j]+1)\nprint(dp2[-1])\n", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys\nimport copy\nlines = iter(sys.stdin)\n\ndef nexts():\n    return next(lines)\n\ndef nextint():\n    return int(nexts())\n\ndef snexts():\n    return next(lines).split(' ')\n\ndef snextint():\n    return map(int, snexts())\n\ndef array(length, base=0):\n    return [base] * length\n\ndef matrix(length, width, base=0):\n    return [[base] * width for _ in range(length)]\n\nn, m = snextint()\ngrid = array(n, [])\n\nfor i in range(n):\n    grid[i] = list(nexts())\n\ngrid2 = copy.deepcopy(grid)\n\nfor i in range(1, n - 1):\n    for j in range(1, m - 1):\n        # print('Attempting on i=%d,j=%d'%(i,j))\n        if grid[i - 1][j] == '#' and grid[i - 1][j + 1] == '#' and grid[i][j + 1] == '#' and grid[i + 1][j + 1] == '#' and grid[i + 1][j] == '#' and grid[i + 1][j - 1] == '#' and grid[i][j - 1] == '#' and grid[i - 1][j - 1] == '#':\n            grid2[i - 1][j] = '.'\n            grid2[i - 1][j + 1] = '.'\n            grid2[i][j + 1] = '.'\n            grid2[i + 1][j + 1] = '.'\n            grid2[i + 1][j] = '.'\n            grid2[i + 1][j - 1] = '.'\n            grid2[i][j - 1] = '.'\n            grid2[i - 1][j - 1] = '.'\n\nmatch = True\nfor i in grid2:\n    for ch in i:\n        if ch == '#':\n            match = False\n            break\n\nif match:\n    print('YES')\nelse:\n    print('NO')", "complexity": "quadratic", "problem": "1059_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n, k = map(int, input().split())\nd = int((9 + 8 * (n + k)) ** 0.5)\nx = (d - 3) // 2\nprint(n - x)", "complexity": "constant", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "n,m,k=map(int,input().split())\np=list(map(int,input().split()))\ncount=0\ndelete=0\nnow=0\nwhile now<m:\n    up=((p[now]-delete-1)//k+1)*k+delete\n    while now<m and p[now]<=up:\n        now+=1\n        delete+=1\n    count+=1\nprint(count)", "complexity": "linear", "problem": "1190_A", "from": "CODEFORCES", "tags": "implementation,two pointers"}
{"src": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\n#sys.setrecursionlimit(300000)\n#threading.stack_size(10**8)\n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------------------------------------------------------------\n#mod = 9223372036854775807  \nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n \n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n \n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n \n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n \n \nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n \n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n#-------------------------------------------------------------------------\nprime = [True for i in range(10)] \npp=[0]*10\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c=0\n    while (p * p <= n): \n          \n        if (prime[p] == True):\n            c+=1\n            for i in range(p, n+1, p): \n                pp[i]+=1\n                prime[i] = False\n        p += 1\n#---------------------------------Binary Search------------------------------------------\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[n-1]\n    while (left <= right):\n        mid = (right + left)//2\n        if (arr[mid] >= key):\n            res=arr[mid]\n            right = mid-1\n        else:\n            left = mid + 1\n    return res\n\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n-1\n    mid = 0\n    res=arr[0]\n    while (left <= right):\n        mid = (right + left)//2\n        if (arr[mid] > key):\n            right = mid-1\n        else:\n            res=arr[mid]\n            left = mid + 1\n    return res\n#---------------------------------running code------------------------------------------\nn,m=map(int,input().split())\nl=[]\ntot=[]\ndone=[[0 for i in range(m)]for j in range(n)]\nfor i in range(n):\n    l.append(input())\ncolsum=[[0 for i in range(m)]for j in range(n)]\nrowsum=[[0 for i in range(m)]for j in range(n)]\ncol=[[0 for i in range(m)]for j in range(n)]\nrow=[[0 for i in range(m)]for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            rowsum[i][j]=1\n            colsum[i][j]=1\n            row[i][j]=1\n            col[i][j]=1\nfor i in range(n):\n    for j in range(1,m):\n        if l[i][j]=='.':\n            continue\n        rowsum[i][j]+=rowsum[i][j-1]\nfor i in range(n):\n    for j in range(m-2,-1,-1):\n        if l[i][j]=='.':\n            continue\n        row[i][j]+=row[i][j+1]\nfor i in range(m):\n    for j in range(n-2,-1,-1):\n        if l[j][i]=='.':\n            continue\n        col[j][i]+=col[j+1][i]\nfor i in range(m):\n    for j in range(1,n):\n        if l[j][i]=='.':\n            continue\n        colsum[j][i]+=colsum[j-1][i]\ndef check(x,y):\n    i=x\n    j=y\n    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1\n    if ans==0:\n        return []\n    return [ans]\nh=[[0 for i in range(m+1)]for j in range(n)]\nv=[[0 for i in range(m)]for j in range(n+1)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            ans=check(i,j)\n            for j1 in ans:\n                tot.append([i+1,j+1,j1])\n                h[i][j-j1]+=1\n                h[i][j+j1+1]-=1\n                v[i-j1][j]+=1\n                v[i+j1+1][j]-=1\nfor i in range(n):\n    for j in range(1,m):\n        h[i][j]+=h[i][j-1]\nfor i in range(m):\n    for j in range(1,n):\n        v[j][i]+=v[j-1][i]\n#print(h)\n#print(v)\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:\n            print(-1)\n            sys.exit(0)\nprint(len(tot))\nfor i in tot:\n    print(*i)", "complexity": "quadratic", "problem": "1015_E2", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "from collections import deque\nn = int(input())\ngraph = [set() for i in range(n + 1)]\ngraph[0].add(1)\ngraph[1].add(0)\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    graph[x].add(y)\n    graph[y].add(x)\na = list(map(int, input().split()))\nq = deque()\nq.append(0)\ni = 0\npar = [0] * (n + 1)\nwhile len(q):\n    v = q.popleft()\n    graph[v].discard(par[v])\n    l = len(graph[v])\n    if graph[v] != set(a[i:i + l]):\n        print(\"No\")\n        break\n    for j in range(i, i + l):\n        q.append(a[j])\n        par[a[j]] = v\n    i += l\nelse:\n    print(\"Yes\")", "complexity": "linear", "problem": "1037_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs,shortest paths,trees"}
{"src": "from sys import stdin,stdout,setrecursionlimit\nstdin.readline\ndef mp(): return list(map(int, stdin.readline().strip().split()))\ndef it():return int(stdin.readline().strip())\nfrom collections import defaultdict as dd,Counter as C,deque\nfrom math import ceil,gcd,sqrt,factorial,log2,floor\t\nfrom bisect import bisect_right as br,bisect_left as bl\nfrom heapq import *\nmod = 10**9+7\n\n\ndef solve():\n\tn = it()\n\tv=[0]*(n+1)\n\tfor i in range(1,n+1):\n\t\tv[i] = input()\n\t\n\tdp=[[0]*(n+2) for _ in range(n+1)]\n\n\tfor l in range(n+2):\n\t\tdp[n][l] = 1\n\n\tfor i in range(n-1,0,-1):\n\t\tcurr_sum = 0\n\t\tfor l in range(n):\n\t\t\tcurr_sum += dp[i+1][l]\n\t\t\tcurr_sum%=mod\n\t\t\tif v[i] == 'f':\n\t\t\t\tdp[i][l] = dp[i+1][l+1]\n\t\t\telse:\n\t\t\t\tdp[i][l]= curr_sum\n\n\tprint(dp[1][0])\n\nsolve()\n", "complexity": "quadratic", "problem": "0909_C", "from": "CODEFORCES", "tags": "dp"}
{"src": "\nimport sys\n\ndef get_new_edges(graph):\n    n = len(graph)\n    far_vertex = []\n    pi = [None]*n\n    visit = [False]*n\n    visit[0]\n    queue = [[0,0]]\n    i = 0    \n    while True:\n        if i >= len(queue): break\n        current, d = queue[i]\n        i += 1\n        visit[current] = True\n        for v in graph[current]:\n            if not visit[v]:\n                u = [v, d+1]\n                pi[v] = current\n                queue.append(u)\n                if d+1 > 2:\n                    far_vertex.append(u)\n    \n    far_vertex.sort(key=lambda x: -x[1])\n\n    pos = [None]*n\n    for i, e in enumerate(far_vertex):\n        pos[e[0]] = i\n\n    count = 0\n    for i in range(len(far_vertex)):\n        if not far_vertex[i]: continue\n        vertex, depth = far_vertex[i]\n        father = pi[vertex]\n        count += 1\n        if pos[father]:\n            far_vertex[pos[father]] = None\n        for u in graph[father]:\n            if pos[u]:\n                far_vertex[pos[u]] = None\n\n    return count\n    \ndef read_int_line():\n    return map(int, sys.stdin.readline().split())\n\nvertex_count = int(input())\ngraph = [[] for _ in range(vertex_count)]\n\nfor i in range(vertex_count - 1):\n    v1, v2 = read_int_line()\n    v1 -= 1\n    v2 -= 1\n    graph[v1].append(v2)\n    graph[v2].append(v1)\n\nprint(get_new_edges(graph))\n\n\n    \n", "complexity": "linear", "problem": "1029_E", "from": "CODEFORCES", "tags": "dp,graphs,greedy"}
{"src": "r,g,b=map(int,input().split())\ns1=[int(x) for x in input().split()]\ns2=[int(x) for x in input().split()]\ns3=[int(x) for x in input().split()]\ns1.sort()\ns2.sort()\ns3.sort()\ns1=s1[::-1]\ns2=s2[::-1]\ns3=s3[::-1]\ns1=[0]+s1\ns2=[0]+s2\ns3=[0]+s3\n\ndp=[]\nfor i in range(r+5):\n    H=[]\n    for j in range(g+5):\n        h=[]\n        for k in range(b+5):\n            h.append(0)\n        H.append(h)\n    dp.append(H)\n\n\nfor i in range(0,r+1):\n    for j in range(0,g+1):\n        for k in range(0,b+1):\n            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0\n            if(i-1>=0 and j-1>=0):\n                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])\n            if(i-1>=0 and k-1>=0):\n                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])\n            if(k-1>=0 and j-1>=0):\n                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])\n            if(i-1>=0):\n                t4 = dp[i-1][j][k]\n            if(j-1>=0):\n                t5 = dp[i][j-1][k]\n            if(k-1>=0):\n                t6 = dp[i][j][k-1]\n\n            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)\n\nprint(dp[r][g][b])\n\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "# from math import ceil\n#\n#\n# n, k = map(int, input().split())\n# lst = [0] * k\n# sets = ceil(n/2)\n# stud = 0\n# for i in range(n):\n#     temp = int(input())\n#     if sets == 0:\n#         continue\n#     for i in range(1, k+1):\n#         if temp ==  i:\n#             if lst[i-1] == 0:\n#                 lst[i-1] += 1\n#             else:\n#                 sets -= 1\n#                 lst[i-1] = 0\n#                 stud += 2\n# if sets == 0:\n#     print(stud)\n# else:\n#     print(stud + sets)\nfrom math import sqrt\nn, k = map(int, input().split())\na = 1\nb = -1 * (2*n + 3)\nc = n * (n + 1) - 2 * k\n\nres = (-1 * b) - sqrt((b * b) - 4 * a * c)\nres = res / 2\nres = int(res)\nprint(res)\n", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "lst = list()\n\nlst.append(0)\nlst.append(1)\n\nnow = 1\nwhile now <= 1e25 :\n\tnow = now * 4 + 1\n\t# print(now)\n\tlst.append(now)\n\nt = int(input())\n\nfor i in range(t):\n\ts = input().split()\n\tn = int(s[0])\n\tk = int(s[1])\n\tif(n >= 34):\n\t\tprint(\"YES \" + str(n - 1))\n\t\tcontinue\n\n\tsek = 0\n\tambil = 1\n\tnyak = 0\n\tcnt = 0\n\n\tsudah = False\n\twhile (sek < n):\n\t\tcnt = cnt + (1 << (sek + 1)) - 1\n\t\t# print(str(cnt) + \" here\")\n\t\tif cnt > k:\n\t\t\tprint(\"NO\")\n\t\t\tsudah = True\n\t\t\tbreak\n\n\t\tnext_ambil = (ambil + 1) * 2 - 1\n\t\tsisa = 4 * ambil - next_ambil\n\t\tambil = next_ambil\n\n\t\tsek += 1\n\t\tnyak = nyak + sisa * lst[n - sek]\n\t\tif (nyak + cnt) >= k :\n\t\t\tprint(\"YES \" + str(n - sek))\n\t\t\tsudah = True\n\t\t\tbreak\n\n\tif sudah == False:\n\t\tprint(\"NO\")\n", "complexity": "linear", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "def stones_after(n, s):\n\tfor i in s:\n\t\tif i == '-':\n\t\t\tn -= 1\n\t\telse:\n\t\t\tn += 1\n\t\tif n < 0:\n\t\t\treturn -1\n\treturn n\n\nn = int(input().strip())\ns = input().strip()\nans = 99999999\nfor i in range(n+1):\n\tstones = stones_after(i, s)\n\tif stones != -1:\n\t\tans = min(ans, stones)\nprint(ans)", "complexity": "quadratic", "problem": "1159_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "from collections import defaultdict\nfrom collections import Counter\nfrom collections import deque\nimport heapq\n\ninf = float('inf')\nninf = float('-inf')\n\nM1 = 10**9 + 7\nM2 = 998244353\n\ndef li():\n    return list(map(int,input().split()))\n\ndef pre():\n    \"Start\"\n\ndef solve():\n    a = input()\n    b = input()\n    n = len(a)\n    if(len(a)<len(b)):\n        a = sorted(list(a),reverse = True)\n        print(\"\".join(a))\n        return\n    b = int(b)\n    ans = 0\n    cnt = [0]*10\n    for i in range(n):\n        cnt[ord(a[i])-ord('0')] += 1\n\n    def getrem(k):\n        cnt[k] -= 1\n        ans = \"\"\n        for i in range(10):\n            for j in range(cnt[i]):\n                ans += str(i)\n        cnt[k] += 1\n        return ans\n\n    prev = \"\"\n    for i in range(n):\n        for j in range(9,-1,-1):\n            if(cnt[j]>0):\n                newval = prev + str(j)+ getrem(j)\n                if(int(newval)<=b):\n                    ans = max(ans,int(newval))\n                    prev += str(j)\n                    cnt[j] -= 1\n                    break\n    print(ans)\n\n\npre()\n\n__ = 1\n#__ = int(input())\nfor _ in range(__):\n    solve()", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n, k = map(int, input().split())\na = [int(x) for x in input().split()]\nrda = []\nfor j in range(12):\n    rd = dict()\n    x = pow(10, j)\n    for i in range(n):\n        r = (a[i]*x)%k\n        rd[r] = rd.setdefault(r, 0) + 1\n    rda.append(rd)\nans = 0\nfor i in range(n):\n    r = a[i]%k\n    ln = len(str(a[i]))\n    x = pow(10, ln)\n    if r == 0: r = k\n    if k-r in rda[ln]:\n        ans += rda[ln][k-r]\n        if (a[i]*x)%k == k-r:\n            ans -= 1\nprint(ans)\n", "complexity": "nlogn", "problem": "1029_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "def findSet(u):\n  if parents[u] != u:\n    parents[u] = findSet(parents[u])\n  return parents[u]\n\n\ndef unionSet(u, v):\n  up = findSet(u)\n  vp = findSet(v)\n  if up == vp:\n    return\n  \n  if ranks[up] > ranks[vp]:\n    parents[vp] = up\n  elif ranks[up] < ranks[vp]:\n    parents[up] = vp\n  else:\n    parents[up] = vp\n    ranks[vp] += 1\n    \nn, a, b = map(int, input().split())\nps = list(map(int, input().split())) \n\nmapping = set(ps)\n\nparents = {x: x for x in ps}\nparents['A'] = 'A'\nparents['B'] = 'B'\nranks = {x: 0 for x in ps}\nranks['A'] = 0\nranks['B'] = 0\n# print(parents)\nresult = True\nfor x in ps:\n  if a - x in mapping:\n    unionSet(x, a - x)\n  else:\n    unionSet(x, 'B')\n    \n  if b - x in mapping:\n    unionSet(x, b - x)\n  else:\n    unionSet(x, 'A')\n  # print(parents)\n\n# print(parents)\nif findSet('A') == findSet('B'):\n  print(\"NO\")\n  \nelse:\n  print(\"YES\")\n  for i in ps:\n    if findSet(i) == findSet('A'):\n      print(\"0\", end = ' ')\n    else:\n      print(\"1\", end = ' ')\n", "complexity": "linear", "problem": "0468_B", "from": "CODEFORCES", "tags": "2-sat,dfs and similar,dsu,graph matchings,greedy"}
{"src": "import sys\nn=int(input())\n#m=n//2*2\n#twolist=[2**i for i in range(19)]\n\n#for i in range(18,-1,-1):\n#    if n>twolist[i]:\n#        break\n\n#for i in range((n+1)//2):\n#    print(1)\n\n#if n==3:\n#    print(1,1,3)\n#    sys.exit()\n\ni=0\nANS=[]\nwhile n>0:\n    if n==3:\n        ANS=ANS+[2**i,2**i,3*2**i]\n        break\n    x=(n+1)//2\n    ANS=ANS+[2**i]*x\n    n=n-x\n    i+=1\n    \n#ANS.append(m)\n\nfor a in ANS:\n    print(a,end=\" \")\n    \n\n", "complexity": "logn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "n=int(input())\na=[0,0]+[int(x) for x in input().split()]\nans=[0]*(n+1)\nfor i in range(n,1,-1):\n    if ans[i]==0:\n        ans[i]=1\n    ans[a[i]]+=ans[i]\nif n==1:\n    ans[1]=1\nans=ans[1:]\nans.sort()\nprint(*ans)", "complexity": "nlogn", "problem": "1056_D", "from": "CODEFORCES", "tags": "constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"}
{"src": "#   Author: yumtam\n#   Created at: 2021-05-03 00:42\n\nfrom __pypy__.intop import int_mulmod\n\nn_, MOD = [int(t) for t in input().split()]\n\ndef mul(a, b):\n    return int_mulmod(a, b, MOD)\n\nN = 410\ndp = [[0] * (N+1) for _ in range(N+1)]\n\nfact = [1]\nfor x in range(1, N):\n    fact.append(fact[-1] * x % MOD)\n\ninv_fact = [0] * N\ninv_fact[-1] = pow(fact[-1], MOD - 2, MOD)\nfor x in reversed(range(1, N)):\n    inv_fact[x - 1] = inv_fact[x] * x % MOD\n\ndef nCr(n, r):\n    return mul(fact[n], mul(inv_fact[n-r], inv_fact[r]))\n\nfor n in range(1, N+1):\n    dp[n][n] = pow(2, n-1, MOD)\n    for i in range(1, n-1):\n        j = n-i-1\n        for k in range(1, i+1):\n            dp[n][k+j] = (dp[n][k+j]\n                          + mul(nCr(k+j, k), mul(dp[i][k], dp[j][j]))) % MOD\n\nprint(sum(dp[n_]) % MOD)\n", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "import sys\n\nn = sys.stdin.readline()\nn = int(n)\ndef get_graph(n):\n    graph = []\n    for _ in range(n):\n        entries = list(map(lambda x : int(x), sys.stdin.readline().split(\" \")[1:]))\n        graph.append(entries)\n    return graph\n\ndef chain(target, buckets, reverse_bucket, sum_bucket, bucket_num, val):\n    mask = 2**bucket_num\n    mem = []\n    buckets_seen = set({bucket_num})\n\n    og_bucket = bucket_num\n    og_val = val\n    for _ in range(len(buckets)):\n        rem = target - sum_bucket[bucket_num] + val\n        if rem not in reverse_bucket:\n            return None, []\n        \n        new_bucket = reverse_bucket[rem]\n        if new_bucket == og_bucket and rem != og_val:\n            return None, []\n        elif new_bucket == og_bucket and rem == og_val:\n            mem.append((rem, bucket_num))\n            return mask | 2**new_bucket, mem\n        elif new_bucket in buckets_seen:\n            return None, []\n        \n        buckets_seen.add(new_bucket)\n        mask = mask | 2**new_bucket\n\n        mem.append((rem, bucket_num))\n        bucket_num = new_bucket\n        val = rem\n    return None, []\n#mask is what you wanna see if you can get\ndef helper(chains, mask, mem):\n    if mask == 0:\n        return []\n    if mask in mem:\n        return mem[mask]\n\n    for i, chain in enumerate(chains):\n        if (mask >> i) & 0:\n            continue\n        for key in chain:\n            if key | mask != mask:\n                continue\n    \n            future = helper(chains, ~key & mask, mem)\n            if future is not None:\n                mem[mask] = chain[key] + future\n                return mem[mask]\n    mem[mask] = None\n    return None\n\ndef solve(n):\n    buckets = get_graph(n)\n    reverse_bucket = {}\n    sum_bucket = [0]* len(buckets)\n    total_sum = 0\n    for i, bucket in enumerate(buckets):\n        for x in bucket:\n            total_sum += x\n            sum_bucket[i] += x\n            reverse_bucket[x] = i\n    \n    target = total_sum / len(buckets)\n\n    chains = []\n    for i, bucket in enumerate(buckets):\n        seto = {}\n        for x in bucket:\n            key, val = chain(target, buckets, reverse_bucket, sum_bucket, i, x)\n            if key is not None:\n                seto[key] = val\n        chains.append(seto)\n    return helper(chains, 2 ** len(buckets) - 1, {}), reverse_bucket\n\ndef result(n):\n    res, reverse_bucket = solve(n)\n    if res is None:\n        sys.stdout.write(\"No\\n\")\n    else:  \n        res = sorted(res, key = lambda x : reverse_bucket[x[0]])\n        sys.stdout.write(\"Yes\\n\")\n        for x, y in res:\n            x = int(x)\n            y = int(y) + 1\n            stuff = \" \".join([str(x), str(y), \"\\n\"])\n            sys.stdout.write(stuff)\nresult(n)", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
{"src": "import sys\nimport io, os\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nA = [input().rstrip() for i in range(n)]\nC = [0]*m\nfor i in range(n):\n    a = A[i]\n    for j, c in enumerate(a):\n        C[j] += int(c)\n\nfor i in range(n):\n    a = A[i]\n    for j, c in enumerate(a):\n        C[j] -= int(c)\n    for j in range(m):\n        if C[j] == 0:\n            break\n    else:\n        print('YES')\n        exit()\n        continue\n    for j, c in enumerate(a):\n        C[j] += int(c)\nprint('NO')\n", "complexity": "quadratic", "problem": "0985_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n=int(input())\nfor i in range(n):\n\ta,b = map( int, input().split() )\n\tif a>b: \n\t    a,b=b,a\n\tans=0\n\twhile a>0:\n\t\tans+=b//a\n\t\tb%=a\n\t\ta,b=b,a\n\tprint(ans)", "complexity": "constant", "problem": "0267_A", "from": "CODEFORCES", "tags": "math,number theory"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\ndef ctd(chr): return ord(chr)-ord(\"a\")\nmod = 998244353\nINF = float('inf')\n\n# ------------------------------\np, u = \"Petr\", \"Um_nik\"\n\ndef main():\n    n = N()\n    arr = RLL()\n    vis = [0]*(n+1)\n    dic = {v: i+1 for i, v in enumerate(arr)}\n\n    sm = 0\n    for i in range(1, n+1):\n        if vis[i]==0:\n            now = i\n            vis[now] = 1\n\n            while dic[now]!=i:\n                sm+=1\n                now = dic[now]\n                vis[now] = 1\n    if (3*n-sm)%2==0:\n        print(p)\n    else:\n        print(u)\n\n\nif __name__ == \"__main__\":\n    main()\n\n", "complexity": "nlogn", "problem": "0986_B", "from": "CODEFORCES", "tags": "combinatorics,math"}
{"src": "a, b = map(int, input().split())\nA = list(map(int, input().split()))\nA.append(-1)\nB = []\nZ = []\nAN = []\nx, y = A[0], A[1]\nfor i in range(a - 1):\n    Z.append((x, y))\n    if x > y:\n        B.append(y)\n        y = A[i + 2]\n    else:\n        B.append(x)\n        x, y = y, A[i + 2]\nfor i in range(b):\n    w = int(input())\n    if w <= len(Z):\n        AN.append(Z[w - 1])\n    else:\n        w = w % len(B)\n        AN.append((x, B[w - 1]))\nfor W in AN:\n    print(*W)", "complexity": "linear", "problem": "1180_C", "from": "CODEFORCES", "tags": "data structures,implementation"}
{"src": "n, k = map(int, input().split())\na = list(map(int, input().split()))\nc = [-1]*256\n\nans = [0]*n\nfor i in range(n):\n    if c[a[i]] == -1:\n        for j in range(a[i], max(-1, a[i]-k), -1):\n            if c[j] != -1:\n                if (c[j] +k) > a[i]:\n                    c[a[i]] = c[j]\n                else:\n                    c[a[i]] = j+1\n                break\n        if c[a[i]] == -1:\n            c[a[i]] = max(0, a[i]-k+1)\n        for xx in range(c[a[i]], a[i]):\n            c[xx] = c[a[i]]\n    ans[i] = str(c[a[i]])\n\nprint(' '.join(ans))\n", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "n = int(input())\nf0= 0\nf1 = 1\nli = [0,1]\nfor i in range(45):\n\tt = f1\n\tf1 += f0\n\tf0 = t\n\tli.append(f1)\nx = []\nfor i in range(3):\n\tfor i in range(len(li)-1, -1, -1):\n\t\tif li[i] <= n:\n\t\t\tn -= li[i]\n\t\t\tx.append(li[i])\n\t\t\tbreak\nif n == 0:\n\tprint(*x, sep = \" \")\nelse:\n\tprint(\"I'm too stupid to solve this problem\")\n", "complexity": "constant", "problem": "0199_A", "from": "CODEFORCES", "tags": "brute force,constructive algorithms,implementation,number theory"}
{"src": "n=int(input())\nif(n<3):\n    print(n)\nelse:\n\n    if(n%2!=0):\n        print(n*(n-1)*(n-2))\n    elif(n%3==0):\n        print((n-1)*(n-2)*(n-3))\n    else:\n        print(n*(n-1)*(n-3))", "complexity": "constant", "problem": "0235_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "# must be at least 1 bit different, we set it as leftmost 0\n\nl, r = map(int, input().split())\ntarget, final = l ^ r, 1\nwhile target:\n    target >>= 1\n    final <<= 1\nprint(final - 1)\n", "complexity": "logn", "problem": "0276_D", "from": "CODEFORCES", "tags": "bitmasks,dp,greedy,implementation,math"}
{"src": "a,b,c,n=map(int,input().split())\nif(c>b or c>a or c>n):\n    print(-1)\nelse:\n    k=c+(a-c)+(b-c)\n    k=n-k\n    if(k>0):\n        print(k)\n    else:\n        print(-1)\n\n", "complexity": "constant", "problem": "0991_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from collections import defaultdict\nn,k = map(int,input().split())\narr = list(map(int,input().split()))\nxors = defaultdict(int)\nxors[0]=1\ncomp = (1<<k)-1\nans = n*(n+1)//2\nxor = 0\nfor a in arr:\n\txor^=a\n\tif xors[xor]>xors[comp^xor]:\n\t\txor^=comp\n\tans-=xors[xor]\n\txors[xor]+=1\nprint(ans)", "complexity": "linear", "problem": "1054_D", "from": "CODEFORCES", "tags": "greedy,implementation"}
{"src": "from sys import stdin\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    a = round((n / 2) ** 0.5)\n    b = round((n / 4) ** 0.5)\n    if 2*a**2 == n or 4*b**2 == n:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "complexity": "constant", "problem": "1515_B", "from": "CODEFORCES", "tags": "brute force,geometry,math,number theory"}
{"src": "import math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y//g):\n\t    d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n    return d[s]\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny+=x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))", "complexity": "np", "problem": "1463_F", "from": "CODEFORCES", "tags": "bitmasks,dp,math"}
{"src": "from collections import deque\nn=int(input())\norderedli=list(map(int,input().split(\" \")))\n\n\nindexof={}\nfor i,x in enumerate(orderedli):\n    indexof[x]=i+1\n\nsortedli=list(sorted(orderedli))\ni=0\n\ns=input()\n\nst=deque()\n\nfor x in s:\n    if x==\"0\":\n        st.append(sortedli[i])\n        print(indexof[sortedli[i]],end=\" \")\n        i += 1\n    else:#x==1\n        temp=st.pop()\n        print(indexof[temp],end=\" \")\n", "complexity": "nlogn", "problem": "0982_B", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "import sys\nimport math\nimport collections\nimport heapq\nimport decimal\ninput=sys.stdin.readline\nn,m,k = map(int,input().split())\na=[]\nfor i in range(n):\n    a.append(list(map(int,input().split())))\nb=[]\nfor i in range(n-1):\n    b.append(list(map(int,input().split())))\nif(k%2==1):\n    for i in range(n):\n        for j in range(m):\n            print(-1,end = \" \")\n        print()\nelse:\n    k//=2\n    pre=[[0 for i in range(m)]for j in range(n)]\n    for x in range(k):\n        curr = [[float(\"inf\") for i in range(m)]for j in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if(j>0):\n                    curr[i][j]=min(curr[i][j],pre[i][j-1]+a[i][j-1])\n                if(i<n-1):\n                    curr[i][j]=min(curr[i][j],pre[i+1][j]+b[i][j])\n                if(j<m-1):\n                    curr[i][j]=min(curr[i][j],pre[i][j+1]+a[i][j])\n                if(i>0):\n                    curr[i][j]=min(curr[i][j],pre[i-1][j]+b[i-1][j])\n        pre=curr[:]\n    for i in range(n):\n        for j in range(m):\n            print(2*pre[i][j],end = \" \")\n        print()", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "n = int(input())\nl = [-1] * n\nr = [-1] * n\na = list(map(int, input().split()))\nfor i in range(2 * n):\n    x = a[i] - 1\n    if l[x] == -1: l[x] = i\n    r[x] = i\nans = 0\nfor i in range(n):\n    for j in range(n):\n        if l[i] < l[j] < r[j] < r[i]: ans += 2\nfor i in range(n):\n    ans += r[i] - l[i] - 1\nprint(ans // 2)", "complexity": "quadratic", "problem": "0995_B", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "from collections import defaultdict\n\nn,k=[int(i) for i in input().strip().split()]\nl=[int(i) for i in input().strip().split()]\nif(k==1):\n    print(n)\nelse:\n    l.sort()\n    ndict=defaultdict(list)\n    for x in l:\n        i=x\n        while(i%k==0):\n            i=i/k\n        ndict[i].append(x)\n    ans=0\n    for i in ndict.values():\n        count=0\n        while(count<len(i)):\n            if(count==len(i)-1):\n                ans+=1\n                break\n            if(i[count]*k!=i[count+1]):\n                ans+=1\n                count+=1\n            else:\n                ans+=1\n                count+=2\n    print(ans)", "complexity": "nlogn", "problem": "0274_A", "from": "CODEFORCES", "tags": "binary search,greedy,sortings"}
{"src": "r=input()\nt1=int(r)\nt2=int(r[:len(r)-1])\nt3=int(r[:len(r)-2]+r[-1])\nprint(max(t1,t2,t3))\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "v = input().split()\nn = int(v[0])\nk = int(v[1])\n\ns = input()\nap = 0\n\ni = 1\nwhile i < n:\n    if s[:i] == s[-i:]:\n        ap = i\n\n    i += 1\n\nprint(s + s[ap:]*(k-1))\n  \t    \t\t\t\t\t  \t\t \t   \t\t\t \t  \t\t", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "#!/usr/bin/env python3\nfrom sys import stdin\n\n\ndef solve(tc):\n    n, k = map(int, stdin.readline().split())\n\n    if n == 1:\n        print(0)\n        return\n\n    if n <= k:\n        print(1)\n        return\n\n    lo, hi = 1, k-1\n    while lo < hi:\n        mid = lo + (hi-lo+1)//2\n\n        cum = (k-2+mid-1)*(k-mid)//2\n        if cum < n-k:\n            hi = mid - 1\n        else:\n            lo = mid\n\n    if lo == 1:\n        print(-1)\n        return\n\n    print(k-lo+1)\n\n\ntcs = 1\nfor tc in range(tcs):\n    solve(tc)\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "n=int(input())\nm=str(n)\nprint(max(int(m),int(m[:-2]+m[-1:]),int(m[:-1])))\n", "complexity": "constant", "problem": "0313_A", "from": "CODEFORCES", "tags": "implementation,number theory"}
{"src": "# import sys\n# sys.stdin = open(\"#input.txt\", \"r\")\n\nfrom math import factorial\n\ns1 = input()\ns2 = input()\n\nfinPos=0\nfor c in s1:\n\tif c=='+': finPos+=1\n\telse: finPos-=1\n\nstPos=0\nfor c in s2:\n\tif c=='+': stPos+=1\n\telif c=='-': stPos-=1\n\nn=s2.count('?')\ndiff=abs(finPos-stPos)\nif diff > n:\n\tprint(0)\nelif n&1 != diff&1:\n\tprint(0)\nelse:\n\ti=0\n\tfor i in range(n//2,n):\n\t\tif i*2-n == diff: break\n\tif i*2-n != diff: i+=1\n\n\tprint((factorial(n)/(factorial(n-i)*factorial(i)))/(1<<n))", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "from sys import stdin,stdout\nstdout.flush()\ndef qu(a,b):\n    print(\"?\",a,b)\n    return int(input())\na=0\nb=0\nbig=qu(a,b)\nfor i in range(29,-1,-1):\n    x=2**i\n    f=qu(a+x,b)\n    l=qu(a,b+x)\n    if l==f:\n        if big==1:\n            a+=x\n        else:\n            b+=x\n        big=f\n    elif f==-1:\n        a+=x\n        b+=x   \nprint(\"!\",a,b)\n\n", "complexity": "logn", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "# qumeric\n\nfrom operator import *\nn, m = map(int, input().split())\na = [int(input(), 2) for _ in range(n)]\ns = t = 0\nfor x in a:\n    t |= s & x\n    s |= x\nprint((\"YES\", \"NO\")[all(x & s & ~t for x in a)])\n", "complexity": "quadratic", "problem": "0985_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def main():\n    def update(l, r, i, res):\n        j = 0\n        while j < i:\n            if res[j] is None:\n                r[j] -= 1\n                if r[j] < 0:\n                    return False\n            j += 1\n        j += 1\n        while j < n:\n            if res[j] is None:\n                l[j] -= 1\n                if l[j] < 0:\n                    return False\n            j += 1\n        return True\n\n    ilist = {1}\n    n = int(input())\n    res = [None] * n\n    cur = n\n    l = [int(x) for x in input().split()]\n    r = [int(x) for x in input().split()]\n\n    while ilist and (sum(l) != 0 or sum(r) != 0):\n        ilist = set()\n        for i in range(n):\n            if l[i] == r[i] == 0 and res[i] is None:\n                res[i] = cur\n                ilist.add(i)\n        for i in ilist:\n            check = update(l, r, i, res)\n            if not check:\n                return False\n        cur -= 1\n    if not ilist:\n        return False\n    for i in range(n):\n        if res[i] is None:\n            res[i] = cur\n    return res\n\n\nif __name__ == '__main__':\n    res = main()\n    if not res:\n        print('NO')\n    else:\n        print('YES')\n        for x in res:\n            print(x, end=' ')", "complexity": "quadratic", "problem": "1054_C", "from": "CODEFORCES", "tags": "constructive algorithms,implementation"}
{"src": "n,k=map(int,input().split())\narr=list(map(int,input().split()))\npar=[i for i in range(260)]\npath=[-1 for i in range(260)]\nfor i in range(n):\n    j=arr[i]\n    if path[j] >=0:\n        par[j] =par[path[j]]\n        continue\n    jump=1\n    while j>0 and path[j] ==-1 and jump <k:\n        path[j] =arr[i]\n        j-=1\n        jump +=1\n    if arr[i] -par[j] +1 <=k:\n            par[arr[i]] =par[j]\n            path[j] =arr[i]\n    else:\n        par[arr[i]] =par[j+1]\nfor i in range(n):\n    print(par[arr[i]],end=' ')\nprint()", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "from sys import stdout\n\n\n\nn = int(input())\n\nif n % 4 == 2:\n\n    print(\"! -1\")\n\n    exit(0)\n\nprint(\"?\", 1)\n\nstdout.flush()\n\na = int(input())\n\nprint(\"?\", 1 + n // 2)\n\nstdout.flush()\n\nb = int(input())\n\nif a == b:\n\n    print(\"!\", 1)\n\n    exit(0)\n\nl = 1\n\nr = 1 + n // 2\n\nwhile(l != r):\n\n    mid = ( l + r ) // 2\n\n    print(\"?\", mid)\n\n    stdout.flush()\n\n    c = int(input())\n\n    print(\"?\", mid + n // 2)\n\n    stdout.flush()\n\n    d = int(input())\n\n    if c == d:\n\n        print(\"!\", mid)\n\n        exit(0)\n\n    if a < b:\n\n        if c < d:\n\n            l = mid + 1\n\n        else:\n\n            r = mid\n\n    else:\n\n        if c > d:\n\n            l = mid + 1\n\n        else:\n\n            r = mid\n\nprint(\"!\", l)\n\n\n\n# Made By Mostafa_Khaled", "complexity": "logn", "problem": "1019_B", "from": "CODEFORCES", "tags": "binary search,interactive"}
{"src": "n, a, b = map(int,input().split())\nif a>1 and b>1: print(\"NO\"); exit()\nif 2<=n<=3 and a == b == 1: print(\"NO\"); exit()\nprint(\"YES\")\n\nif b == 1:\n    adj = [[0]*n for i in range(n)]\n    conn = n\n    for i in range(n):\n        if conn == a: break\n        adj[i][i+1] = adj[i+1][i] = 1\n        conn-= 1\n        if conn == a: break\nelif a == 1:\n    adj = [[1]*n for i in range(n)]\n    conn = n\n    for i in range(n): adj[i][i] = 0\n    for i in range(n):\n        if conn == b: break\n        adj[i][i+1] = adj[i+1][i] = 0\n        conn-= 1\n        if conn == b: break\n\nfor row in adj:\n    print(*row, sep='')\n", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "# _\n#####################################################################################################################\n\ndef main():\n    pieces_Dimension = int(input())\n    piece1 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece2 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece3 = ''.join(input() for _ in range(pieces_Dimension))\n    input()\n    piece4 = ''.join(input() for _ in range(pieces_Dimension))\n\n    brokenPieces = (piece1, piece2, piece3, piece4)\n    nSquares = pieces_Dimension*pieces_Dimension\n    squares = '01'*-(-nSquares//2)\n\n    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)\n\n\ndef nSquaresToRecolorIn(brokenPieces, nSquares, squares):\n    possible_nSquares = [(sum(1 for i in range(nSquares) if piece[i] != squares[:-1][i]),\n                          sum(1 for i in range(nSquares) if piece[i] != squares[1:][i]))\n                         for piece in brokenPieces]\n    possible_nSquares.sort(key=lambda x: x[0])\n\n    return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1]\n\n\nif __name__ == '__main__':\n    print(main())\n    # main()\n", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "import sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\nmod = 998244353\na.sort()\ndp = [1] + [0] * n\nfor i in range(1, n + 1):\n    x, pt = 1, i - 2\n    while pt >= 0 and 2 * a[pt] > a[i - 1]:\n        x = x * (n - pt - 2) % mod\n        pt -= 1\n    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod\nprint(dp[-1])", "complexity": "cubic", "problem": "1437_F", "from": "CODEFORCES", "tags": "combinatorics,dp,math,two pointers"}
{"src": "n,m = map(int,input().split())\n \nprint(n*\"8\")\nprint((n-1)*\"1\"+\"2\")", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "import sys, math, cmath, time, collections\nfrom collections import deque, Counter, OrderedDict, defaultdict\nfrom heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace\nfrom math import ceil, floor, log, log2, sqrt, gcd, factorial, pow, pi\nfrom bisect import bisect_left, bisect_right\n\n# BEGIN FASTIO\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# END FASTIO\n\n# SOLUTION BEGINS HERE\n\nstart_time = time.time()\n\n\ndef solve(s):\n    \"\"\"\n    Actual solution\n    \"\"\"\n    mx = 0\n    visited = set()\n    for left in range(len(s)):\n        for right in range(left, len(s)):\n            substring = s[left : right + 1]\n            if substring not in visited:\n                visited.add(substring)\n            elif substring in visited:\n                mx = max(mx, len(substring))\n    print(mx)\n\ndef main():\n    \"\"\"\n    Main function dedicated to get the I/P\n    a, b = map(int, input().split())\n    solve(a, b)\n    \"\"\"\n    s = input()\n    solve(s)\n\nif __name__ == \"__main__\":\n    LOCAL = False\n\n    # If it's Local - Get I/P from file\n    if LOCAL:\n        sys.stdin = open(\"../io/data.in\", \"r\")\n        sys.stdout = open(\"../io/data.out\", \"w\")\n\n    testcases = 1\n    for i in range(testcases):\n        main()\n\n    # If it's local - Print this O/P\n    if LOCAL:\n        print(f\"Time Elapsed: {time.time() - start_time} seconds\")\n        sys.stdout.close()\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "def valid(k, mid):\n    return (2*k - mid - 1) * mid // 2 + 1\n    \ndef binary_search(n, k):\n    l, r = 0, k-1\n    while (l <= r):\n        mid = l+r >> 1\n        if (valid(k, mid) < n):\n            l = mid+1\n        else:\n            r = mid-1\n    return l\n\ndef main():\n    n, k = map(int, input().split())\n    res = binary_search(n, k)\n    print(-1 if res == k else res)\n\nmain()\n", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "\ninp = input().split()\ntotNums, mod = int(inp[0]), int(inp[1])\n\ndef Exp(b,exp):\n\tif exp==0: return 1\n\ttemp = Exp(b,exp>>1)**2\n\tif exp%2==1: temp*=b\n\treturn temp%mod\n\n\n#main\nn = 410\n\n\n#Precompute\nfact, inv = [0 for i in range(n)],[0 for i in range(n)]\nfact[0] = inv[0] = 1;\nfor i in range(1,totNums+1):\n\tfact[i] = fact[i-1]*i%mod\n\tinv[i] = Exp(fact[i],mod-2)\n\ndp, choose = [[0 for i in range(n)] for j in range(n)], [[0 for i in range(n)] for j in range(n)]\nfor i in range(0,totNums+1):\n\tfor j in range(0,i+1):\n\t\tchoose[i][j] = fact[i]*inv[j]*inv[i-j]%mod\npow2 = [Exp(2,i) for i in range(n)]\n\n#dp\ndp[0][0] = 1\nfor i in range(totNums):\n\tfor j in range(i+1):\n\t\tfor k in range(1,totNums-i+1):\n\t\t\tdp[i+k+1][j+k] += dp[i][j]*pow2[k-1]*choose[j+k][k]\n\t\t\tdp[i+k+1][j+k] %= mod\n\nans = 0\nfor i in range(0,totNums+1):\n\tans = (ans+dp[totNums+1][i])%mod\nprint(ans)", "complexity": "cubic", "problem": "1515_E", "from": "CODEFORCES", "tags": "combinatorics,dp,math"}
{"src": "class Read:\n    @staticmethod\n    def int():\n        return int(input())\n \n    @staticmethod\n    def list(sep=' '):\n        return input().split(sep)\n \n    @staticmethod\n    def list_int(sep=' '):\n        return list(map(int, input().split(sep)))\n    @staticmethod\n    def calc(sep = '', k = ''):\n        count = 0\n        for i in range(sep):\n            j = sep - i\n            sum = ((i + 1)* i) / 2\n            if (sum - j == k):\n                return j\n        return count\n \n \ndef main():\n    n, k = Read.list_int()\n    print(Read.calc(n, k))\n        \n \nmain()", "complexity": "logn", "problem": "1195_B", "from": "CODEFORCES", "tags": "binary search,brute force,math"}
{"src": "from math import inf\n\n\nn = int(input())\ns_list = list(map(int, input().split()))\nc_list = list(map(int, input().split()))\n\ntotal_min = inf\nfor j in range(n):\n    min_i = inf\n    for i in range(0, j):\n        if s_list[i] < s_list[j]:\n            min_i = min(min_i, c_list[i])\n\n    min_k = inf\n    for k in range(j + 1, n):\n        if s_list[k] > s_list[j]:\n            min_k = min(min_k, c_list[k])\n\n    total_min = min(total_min, min_i + c_list[j] + min_k)\nif total_min != inf:\n    print(total_min)\nelse:\n    print(-1)", "complexity": "quadratic", "problem": "0987_C", "from": "CODEFORCES", "tags": "brute force,dp,implementation"}
{"src": "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 11/26/18\n\n\"\"\"\nimport math\n\n\nf = [0] * 100\nfor i in range(100):\n    f[i] = (4**i-1) // 3\n\n\ndef solve(N, K):\n    \n    if N < 100 and f[N] < K:\n        print('NO')\n        return\n    \n    for i in range(99):\n        if f[i] <= K < f[i+1]:\n            x = K - f[i]\n            a = N - i\n            \n            if x == 0:\n                print('YES {}'.format(a))\n                return\n                \n            edge = 2**(i+1) - 1\n            others = (2**i-1) ** 2\n            if edge == x:\n                print('YES {}'.format(a-1))\n                return\n            \n            ans = a\n            if edge < x:\n                x -= edge\n                ans = a-1\n\n            # split others\n            for j in range(a + 1):\n                if others * f[j] >= x:\n                    print('YES {}'.format(ans))\n                    return\n            print('NO')\n            \n            return\n    \n    print('NO')\n    \n    \nT = int(input())\n\nfor ti in range(T):\n    N, K = map(int, input().split())\n    solve(N, K)", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "def main():\n\n    n,m = map(int, input().split())\n    S = [list(str(input())) for _ in range(n)]\n\n    L = [[0]*m for _ in range(n)]\n    R = [[0]*m for _ in range(n)]\n    U = [[0]*m for _ in range(n)]\n    D = [[0]*m for _ in range(n)]\n\n    for i in range(n):\n        cnt = 0\n        for j in range(m):\n            if S[i][j] == '.':\n                cnt = 0\n            else:\n                cnt += 1\n                L[i][j] = cnt\n        cnt = 0\n        for j in reversed(range(m)):\n            if S[i][j] == '.':\n                cnt = 0\n            else:\n                cnt += 1\n                R[i][j] = cnt\n\n    for j in range(m):\n        cnt = 0\n        for i in range(n):\n            if S[i][j] == '.':\n                cnt = 0\n            else:\n                cnt += 1\n                U[i][j] = cnt\n        cnt = 0\n        for i in reversed(range(n)):\n            if S[i][j] == '.':\n                cnt = 0\n            else:\n                cnt += 1\n                D[i][j] = cnt\n\n    #print(L)\n    #print(R)\n    #print(U)\n    #print(D)\n    #T = [['.']*m for _ in range(n)]\n    imosH = [[0]*(m+1) for _ in range(n)]\n    imosV = [[0]*m for _ in range(n+1)]\n    ans = []\n    for i in range(1, n-1):\n        for j in range(1, m-1):\n            if S[i][j] == '.':\n                continue\n            l = L[i][j]-1\n            r = R[i][j]-1\n            u = U[i][j]-1\n            d = D[i][j]-1\n            s = min([l, r, u, d])\n            if s == 0:\n                continue\n            ans.append((i+1, j+1, s))\n            imosV[i-s][j] += 1\n            imosV[i+s+1][j] -= 1\n            imosH[i][j-s] += 1\n            imosH[i][j+s+1] -= 1\n\n    #print(imosH)\n    #print(imosV)\n\n    from itertools import accumulate\n    for i in range(n):\n        imosH[i] = list(accumulate(imosH[i]))\n    for j in range(m):\n        for i in range(1, n+1):\n            imosV[i][j] += imosV[i-1][j]\n\n    #print(imosH)\n    #print(imosV)\n\n    #print(T)\n    for i in range(n):\n        for  j in range(m):\n            if S[i][j] == '*':\n                if imosH[i][j] <= 0 and imosV[i][j] <= 0:\n                    print(-1)\n                    exit()\n    else:\n        print(len(ans))\n        for i in range(len(ans)):\n            print(*ans[i])\n\nif __name__ == '__main__':\n    main()\n", "complexity": "quadratic", "problem": "1015_E2", "from": "CODEFORCES", "tags": "binary search,dp,greedy"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport collections\nimport itertools\nimport bisect\nimport heapq\n# sys.setrecursionlimit(100000)\n# ^^^TAKE CARE FOR MEMORY LIMIT^^^\nimport random\n\n\ndef main():\n    pass\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\n\ndef decimal(s):\n    return (int(s, 2))\n\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n //= 2\n        p += 1\n    return (p)\n\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\ndef primeFactorsCount(n):\n    cnt=0\n    while n % 2 == 0:\n        cnt+=1\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            cnt+=1\n            n = n // i\n    if n > 2:\n        cnt+=1\n    return (cnt)\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\n\ndef countcon(s, i):\n    c = 0\n    ch = s[i]\n    for i in range(i, len(s)):\n        if (s[i] == ch):\n            c += 1\n        else:\n            break\n    return (c)\n\n\ndef lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\n\n\ndef isSubSequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\n\n\ndef maxfac(n):\n    root = int(n ** 0.5)\n    for i in range(2, root + 1):\n        if (n % i == 0):\n            return (n // i)\n    return (n)\n\n\ndef p2(n):\n    c = 0\n    while (n % 2 == 0):\n        n //= 2\n        c += 1\n    return c\n\n\ndef seive(n):\n    primes = [True] * (n + 1)\n    primes[1] = primes[0] = False\n    i = 2\n    while (i * i <= n):\n        if (primes[i] == True):\n            for j in range(i * i, n + 1, i):\n                primes[j] = False\n        i += 1\n    pr = []\n    for i in range(0, n + 1):\n        if (primes[i]):\n            pr.append(i)\n    return pr\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\n\ndef denofactinverse(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (pow(fac, m - 2, m))\n\n\ndef numofact(n, m):\n    fac = 1\n    for i in range(1, n + 1):\n        fac = (fac * i) % m\n    return (fac)\n\ndef sod(n):\n    s = 0\n    while (n > 0):\n        s += n % 10\n        n //= 10\n    return s\n\nn=int(input())\nl=list(map(int,input().split()))\ninv=0\nfor i in range(1,n):\n    for j in range(0,i):\n        if(l[j]>l[i]):\n            inv+=1\n#print(inv)\nfor i in range(0,int(input())):\n    f,r=map(int,input().split())\n    p=(r-f+1)//2\n    #print(p)\n    inv+=p%2\n    #print(inv)\n    if(inv%2):\n        print(\"odd\")\n    else:\n        print(\"even\")\n", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "def f(a, ind):\n    if a[ind] == 0:\n        return -1\n    k = a[ind] // 14\n    x = a[ind] % 14\n    b = a[:]\n    b[ind] = 0\n    for j in range(14):\n        b[j] += k\n    for j in range(ind + 1, ind + x + 1):\n        j1 = j % 14\n        b[j1] += 1\n    res = 0\n    for j in range(14):\n        if b[j] % 2 == 0:\n            res += b[j]\n    return res\na = list(map(int, input().split()))\nans = 0\nfor i in range(14):\n    cur = f(a, i)\n    ans = max(ans, cur)\nprint(ans)", "complexity": "constant", "problem": "0975_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "# 1029A\n\nn, k = [int(num) for num in input().split(' ')]\nstring = input()\n\n\ndef fn(string, k):\n    maximum_match = 0\n    for i in range(1, len(string)):\n        if string[:i] == string[-i:]:\n            maximum_match = i\n\n    answer = list(string)\n    extra = list(string[maximum_match:])\n    for i in range(k-1):\n        answer.extend(extra)\n\n    return ''.join(answer)\n\n\nprint(fn(string, k))\n", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "import zlib, base64\nexec(zlib.decompress(base64.b64decode(b'eJyFV8lu2zAQPTdfIenAUGhR9FygXxLk4MJu4SJwAscJSIEfX4nLzHtDpT0kGM6+j3w83IYfw8M0BhemL8M0+pBiWuYMBzdGtwjYgMUpWGRWtnFJq6Srkh7g4JqSjW9Jm3wKjdYohIzALkivfuX/m02nYBUJ2ZNVLjZPAM5hrFTR5BFGasLg/RbOvPniIsSU0AXAtMgMnanRShPVFx+QA+jRad5CyWhoMUbIqCBL0RII5jSZd+Fg+sLB7dpNWOItRcaFNKqVyFpKgdkR9ELB2PpzhIJGt1amli/aSDlOQ1W5ymHiJFsYYHCkD0VZsMSmDSMl1XpmYM2R9HtTwgOYgCe3KLwXmJUdMRaiID+w28WKfGVICbfyzMaHNKq36IWCC+Qp7gTLoVYRL+28GH6Pjb7JmDjJ1l6AsDu2CGFzJR5RM58wnDCZ/8it9nlXgzYrihNlNr2dFmUoamj1pv961Y93meJ9B62u0gF2rkXzB3qlJziEzfWuYFHWPJQLSrNZExXlgesBaI1S7dDm4v6AYYZkwNRD40AGaBck3vYLibQi4e7Mpzdhf7YtAgh+loaltc0HVw5zYkuEsS7ggJBtuAiJjOrDswaBanOqF9E6C7ebnO0wdKn5+BjM3k1HOl5245pj1yknlqH5iOnZ4TG5pSsPGSN7oesOHf3AbWGaglqiO/MpdM2Q3zUjZBNwYFBD7Q46XvMWlWxICAFca8Mq7x2nQwpdqS0Pa6nXHaxAQUZTtby1qnH+YLH6sFyySaV6qRYumsLpNS4dRyPdzjkSFitEDDDFtXB6irVwggtgVE55RYBFZW4rWm62iMd91wK4JjOL11vfO9LMUS85aODCdWuK7Mu3g7BkuNqOLKSfJwXMY8k/hxLiokkkR2bGIdiZtTWOCWVgH+1NYMPDXMl+q8siUffUp05hY4Q6alBt8DSSVi3jvlzTAppNKU8dpwppDSokDq2uhenx7tfzdTgP58twPVx+n/z5clv/Xt5ufp7n73efXq4b5ni4PZzeD09++vZzGj4P9/df/zyfL/7p/Hrz19P76fp6OqrcPD/Od38BvToehw==')))\n \t\t\t   \t \t   \t   \t  \t\t \t  \t\t\t \t", "complexity": "quadratic", "problem": "0913_E", "from": "CODEFORCES", "tags": "bitmasks,dp,shortest paths"}
{"src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\nans = 0\nfor i in range(2, n):\n    for j in range(2 * i, n + 1, i):\n        ans += j // i\nprint(ans * 4)", "complexity": "nlogn", "problem": "1062_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs,implementation,math"}
{"src": "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue, bisect\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\ndef ok(x):\n    y = sum(map(int, list(str(x))))\n    return x-y >= s\n\nn, s = map(int, input().split())\nl, h = 0, n\na = n\nwhile l <= h:\n    m = (l+h)>>1\n    if ok(m):\n        a = m-1\n        h = m-1\n    else:\n        l = m+1\nprint(n-a)", "complexity": "logn", "problem": "0817_C", "from": "CODEFORCES", "tags": "binary search,brute force,dp,math"}
{"src": "def main():\n    n, m = map(int, input().split())\n\n    r = []\n    rappend = r.append\n    for i in range(1, (n >> 1) + 1):\n        for j in range(1, m + 1):\n            rappend(str(i) + ' ' + str(j))\n            rappend(str(n + 1 - i) + ' ' + str(m + 1 - j))\n\n    if n & 1:\n        for i in range(1, (m >> 1) + 1):\n            rappend(str((n + 1) >> 1) + ' ' + str(i))\n            rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i))\n        if m & 1:\n            rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1))\n\n    print('\\n'.join(r))\n\n\nmain()\n", "complexity": "quadratic", "problem": "1179_B", "from": "CODEFORCES", "tags": "constructive algorithms"}
{"src": "import io,os,bisect\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nprime = [2]\n\nfor i in range(3,4*10**3,2):\n    flag = False\n    if i%2==0: continue \n    for j in range(3,int(i**0.5)+1,2):\n        if i%j==0: \n            flag = True \n            break\n    if not flag:  prime.append(i)\n\ndef primefactor(num):\n\n    index = 0\n    output = []\n\n    while num>=prime[index]**2:\n\n        times = 0\n        while num%prime[index]==0:\n            num = num // prime[index]\n            times += 1\n        if times&1:  output.append(prime[index])\n        index += 1 \n\n    if num>1: output.append(num)\n\n\n    return tuple(output)\n\nfor _ in range(int(input())):\n    n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0]\n    for i in range(n):\n        factor = primefactor(arr[i])\n        if factor in fact:            bisect.insort(stack,fact[factor]+1)            \n        fact[factor] = i\n        for j in range(k+1):\n            if j<len(stack):  left[i][j] = stack[-j-1]\n    for i in range(n):\n        for j in range(k+1):\n            for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1)\n    print(dp[-1][-1])   ", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "n = int(input())\nl = list(map(int,input().split()))\ni = 0\nans = 0\nwhile i < len(l)-1:\n    if l[i] == l[i+1]:\n        i = i+1\n        continue\n\n    j = i+1\n    ind = -1\n    while j < len(l):\n        if l[j] == l[i]:\n            ind = j\n            break\n\n        j = j+1\n\n    while ind > i+1:\n        l[ind],l[ind-1] = l[ind-1],l[ind]\n        ans += 1\n        ind -= 1\n\n    i += 1\n\nprint(ans)", "complexity": "quadratic", "problem": "0995_B", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "NANS = (False, None)\n\ndef is_valid(n, k):\n    if n > 31:\n        return True\n    return k*3 <= (2**(2*n) - 1)\n\n\ndef solve_mini(n, k):\n    if not is_valid(n, k):\n        return NANS\n\n    if n == 1:\n        if k == 1:\n            return (True, 0)\n        else:\n            return (False, None)\n    if n == 2:\n        if k in [1, 2]:\n            return (True, 1)\n        if k in [4, 5]:\n            return (True, 0)\n    return (False, None)\n\n\n\ndef solve(n, k):\n    if n < 3:\n        ans, log = solve_mini(n, k)\n        return (ans, log)\n\n    # validity of k\n    if not is_valid(n, k):\n        return NANS\n\n    w = 1\n    while k >= w and n >= 1:\n        k -= w\n        n -= 1\n        w = w + w + 1\n    return(True, n)\n\n\nt = int(input())\nfor i in range(t):\n    n, k = map(int, input().split())\n    ans, log = solve(n, k)\n    if ans:\n        print(\"YES\", log)\n    else:\n        print(\"NO\")\n\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "L1=list(map(int, input().split()))\nnumList=list(map(int, input().split()))\nlength=L1[0]\ntargetnumber=L1[1]\npos=numList.index(targetnumber)\npos_r=pos+1\nrem=0\nright={0:1}\nleft={0:1}\nwhile pos_r<=length-1:\n    if numList[pos_r]>targetnumber:\n        rem+=1\n    else:\n        rem-=1\n    if rem not in right:\n        right[rem]=1\n    else:\n        right[rem]+=1\n    pos_r+=1\npos_l=pos-1\nrem=0\nwhile pos_l>=0:\n    if numList[pos_l]>targetnumber:\n        rem+=1\n    else:\n        rem-=1\n    if rem not in left:\n        left[rem]=1\n    else:\n        left[rem]+=1\n    pos_l-=1\nsum=0\nfor number_l in left:\n    if number_l*(-1) in right:\n        sum += (left[number_l] * right[(-1) * number_l])\n    if 1-number_l in right:\n        sum += (left[number_l] * right[1-number_l])\nprint(sum)", "complexity": "nlogn", "problem": "1005_E1", "from": "CODEFORCES", "tags": "sortings"}
{"src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import deque\n\ndef main():\n    with open('input.txt') as fp:\n        input=fp.readline\n        n, m = map(int, input().split())\n        dx = [1, -1, 0, 0]\n        dy = [0, 0, -1, 1]\n        q =deque()\n        k = int(input())\n        a = list(map(int, input().split()))\n        v = [[1] * (m + 2) for _ in range(n + 2)]\n        for i in range(m + 2):\n            v[0][i] = 0\n            v[-1][i] = 0\n        for i in range(n + 2):\n            v[i][0] = 0\n            v[i][-1] = 0\n        for i in range(0, 2 * k, 2):\n            q.append((a[i],a[i + 1]))\n            v[a[i]][a[i + 1]] = 0\n        while 1:\n            x, y =q.popleft()\n            for i in range(4):\n                xx, yy = x + dx[i], y + dy[i]\n                if v[xx][yy]:\n                    q.append((xx, yy))\n                    v[xx][yy] = 0\n            if not q:\n                with open('output.txt', mode='w') as fpp:\n                    fpp.write(f'{x} {y}')\n                break\n\n# region fastio\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "def pow(x, p):\n    ret = 1\n    for i in range(p): ret=ret*x\n    return ret\n\ndef rate(p):\n    ret = 0\n    now = 1\n    for i in range(p):\n        ret = ret + now\n        now = now * 4\n    return ret\n\ndef solve():\n    n, k = map(int, input().split())\n    if (n>35):\n        print(\"YES %d\" % (n-1))\n        return \n    mSplit = 1\n    cnt1 = 0 \n    cnt3 = 1\n    for i in range(1, n+1):\n        now = pow(4, i) - pow(2, i+1) + 1\n        now = now * rate(n-i) + rate(i)\n        # print(\"%d %d %d %d\"%(n, i, now, mSplit))\n        if (k<=now):\n            print(\"YES %d\" % (n-i))\n            return\n        mSplit = mSplit + cnt1 + cnt3 * 3\n        cnt1 = cnt1 + cnt3\n        cnt3 = cnt3 + cnt3\n        if (mSplit>k): break\n    print(\"NO\")\n\n\ndef main():\n    T = int(input())\n    for i in range(T): \n        solve()\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "from collections import deque\nwith open(\"input.txt\",\"r\") as input_file: \n    with open(\"output.txt\",\"a\") as output_file:\n        N,M = map(int,input_file.readline().split())\n        K = int(input_file.readline())\n        T = list(map(int,input_file.readline().split()))\n        graph = [[0] * (M + 1) for _ in range(N + 1)]\n        queue = deque()\n        for i in range(0, 2 * K - 1, 2):\n            graph[T[i]][T[i + 1]] = 1\n            queue.append((T[i], T[i + 1]))\n        x, y = 0, 0\n        while queue:\n            x, y = queue.popleft()\n            x_moves = [x - 1, x + 1, x, x]\n            y_moves = [y, y, y - 1, y + 1]\n            for i in range(len(x_moves)):\n                if 0 < x_moves[i] <= N and 0 < y_moves[i] <= M:\n                    if graph[x_moves[i]][y_moves[i]] == 0:\n                        x = x_moves[i]\n                        y = y_moves[i]\n                        graph[x_moves[i]][y_moves[i]] = 1\n                        queue.append((x_moves[i], y_moves[i]))\n        output_file.write(f\"{x} {y}\")", "complexity": "cubic", "problem": "0035_C", "from": "CODEFORCES", "tags": "brute force,dfs and similar,shortest paths"}
{"src": "n,m=map(int,input().split())\nx=list(map(int,input().split()))\ny=list(map(int,input().split()))\nl=[]\nfor i in range(m):\n    if y[i] in x:\n        l.append(x.index(y[i]))\nl.sort()\nfor i in l:\n    print(x[i],end=\" \")", "complexity": "quadratic", "problem": "0994_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "n,k=map(int,input().split())\nif 2*n-1<k :\n\tprint(0)\nelif k<=n+1 :\n\tif k%2:\n\t\tprint(k//2)\n\telse:\n\t\tprint(k//2-1)\nelse:\n\tt1=k-n\n\tif k%2==0:\n\t\tprint(k//2-t1)\n\telse:\n\t\tprint(k//2-t1+1)\n", "complexity": "constant", "problem": "1023_B", "from": "CODEFORCES", "tags": "math"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#######################################\nfrom collections import defaultdict as dd\nn,m=map(int,input().split())\nl1=[]\nfor i in range(n):\n    l1.append(list(map(int,input().split())))\nl=0\nh=10**9\nc=2**m-1\nx,y=1,2\nwhile l<=h:\n    mid=(l+h)//2\n    d=dd(int)\n    d1=dd(int)\n    for i in range(n):\n        s=[]\n        for j in range(m):\n            if l1[i][j]>=mid:\n                s.append('1')\n            else:\n                s.append('0')\n        s=int(''.join(s),2)\n        d[s]+=1\n        d1[s]=i+1\n    f=0\n    for i in d:\n        for j in d:\n            if i|j==c:\n                f=1\n                x=d1[i]\n                y=d1[j]\n                break\n        if f:\n            break\n    if f:\n        if l==h:\n            break\n        l=mid+1\n    else:\n        if l==h:\n            break\n        h=mid\nprint(x,y)\n        \n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import math\ndef getdt():\n    return map(int, input().split())\ndef calc(v0, v, a, x):\n    t = (v - v0) / a\n    x0 = v0 * t + 0.5 * a * t * t\n    if x0 >= x:\n        return (x, (math.sqrt(v0 * v0 + 2 * a * x) - v0) / a)\n    return (x0, t)\ndef go(v0, v, a, x):\n    x0, t = calc(v0, v, a, x)\n    return t + (x - x0) / v\na, v = getdt()\nl, d, w = getdt()\nif w > v:\n    w = v\nx, t = calc(0, w, a, d)\nif x == d:\n    print(go(0, v, a, l))\nelse:\n    print(t + go(w, v, a, (d - x) * 0.5) * 2 + go(w, v, a, l - d))\n", "complexity": "constant", "problem": "0005_D", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "import math\nfrom decimal import Decimal\n\ndef sum2(s, e):\n    return sum1(e) - sum1(s - Decimal(1)) - (e - s)\n\ndef sum1(i):\n    return i * (i + 1) / 2\n\nline = input()\nn = Decimal(line.split()[0])\nk = Decimal(line.split()[1])\nif(n == 1):\n    print(0)\nelif(k > n):\n    print(1)\nelif(sum2(2,k) < n):\n    print(-1)\nelse:\n    c = 2 * n + k - k * k\n    discriminant = (9 - 4 * c).sqrt()\n    res1 = math.floor((3 + discriminant) / 2)\n    res2 = math.floor((3 - discriminant) / 2)\n    res1 = max(res1, res2)\n    print(int(k - res1 + 1));", "complexity": "logn", "problem": "0287_B", "from": "CODEFORCES", "tags": "binary search,math"}
{"src": "n, m = map(int, input().split())\na = []\nb = []\ncheck = True\nwhile n >= 0:\n    if check == True:\n        a.append(5)\n        n -= 5\n        b.append(4)\n        check = False\n    else:\n         check = True\n         a.append(4)\n         n -= 4\n         b.append(5)\n\na.append(5)\nb.append(5)\n\nprint(*a, sep = \"\")\nprint(*b, sep = \"\")\n", "complexity": "constant", "problem": "1028_B", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "k=int(input())\ni=0\nr=1\nwhile(k>=r):\n    r+=9*(i+1)*10**i\n    i+=1\nr=r-(9*i*10**(i-1))\nans=str(((k-r)//i)+10**(i-1))[(k-r)%i]\nprint(ans)\n\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "print(\"? 0 0\", flush=True)\nres = input()\ni = 1\na = 0\nb = 0\nfor i in range(29,-1,-1):\n\tprint(\"?\",(a^(1<<i)), b, flush=True)\n\tres1 = input()\n\tprint(\"?\",a, (b^(1<<i)), flush=True)\n\tres2 = input()\n\tif res1 == res2:\n\t\tif res == '1':\n\t\t\ta ^= (1<<i)\n\t\telse:\n\t\t\tb ^= (1<<i)\n\t\tres = res1\n\telif res1 == '-1':\n\t\ta ^= (1<<i)\n\t\tb ^= (1<<i)\nprint(\"!\", a, b, flush=True)", "complexity": "constant", "problem": "1088_D", "from": "CODEFORCES", "tags": "bitmasks,constructive algorithms,implementation,interactive"}
{"src": "import math,sys,bisect,heapq\nfrom collections import defaultdict,Counter,deque\nfrom itertools import groupby,accumulate\n#sys.setrecursionlimit(200000000)\nint1 = lambda x: int(x) - 1\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nilele = lambda: map(int,input().split())\nalele = lambda: list(map(int, input().split()))\nilelec = lambda: map(int1,input().split())\nalelec = lambda: list(map(int1, input().split()))\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n#MOD = 1000000000 + 7\ndef Y(c):  print([\"NO\",\"YES\"][c])\ndef y(c):  print([\"no\",\"yes\"][c])\ndef Yy(c):  print([\"No\",\"Yes\"][c])\n\nfrom functools import lru_cache\n\nn,l,r,x = ilele()\nA = alele()\nA.sort()\n\n@lru_cache(None)\ndef fun(pos = 0,sm = -1,la = -1,tot = 0):\n    if pos == n:\n        if tot >= l and tot <= r and la  > 0 and  (la - sm) >= x:\n            return 1\n        return 0\n    if sm == -1:\n        return fun(pos+1,A[pos],-1,A[pos]) + fun(pos+1,sm,la,tot)\n    elif la == -1:\n        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)\n    else:\n        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)\n    \nprint(fun())\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "n,l,r,x=map(int,input().split())\nnum=list(map(int,input().split()))\nans=0\nfor i in range(2**n):\n    st=bin(i)[2:]\n    st='0'*(n-len(st))+st\n    if st.count('1')>=2:\n        pt=[]\n        for i in range(len(st)):\n            if st[i]=='1':\n                pt.append(num[i])\n        if sum(pt)<=r and sum(pt)>=l and max(pt)-min(pt)>=x:\n            ans+=1\nprint(ans)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import math\n\nn, m, k = list(map(lambda i: int(i), input().split(sep=' ')))\np = list(map(lambda i: int(i), input().split(sep=' ')))\np.sort()\npage_max = k\naction_count = 0\nindex = 0\nwhile index < m:\n    while index < m and p[index] <= page_max:\n        count = 0\n        while index < m and p[index] <= page_max:\n            index += 1\n            count += 1\n        if count > 0:\n            action_count += 1\n        page_max += count\n\n    pc = 1 if index >= m else math.ceil((p[index] - page_max) / k)\n    page_max += k * pc\n\nprint(action_count)\n", "complexity": "nlogn", "problem": "1191_C", "from": "CODEFORCES", "tags": "implementation"}
{"src": "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int,input().split()))\n    a.sort()\n    if a[-2]>n-2:\n        print(n-2)\n    else:\n        print(a[-2]-1)", "complexity": "nlogn", "problem": "1197_A", "from": "CODEFORCES", "tags": "greedy,math,sortings"}
{"src": "a=[]\nn=int(input())\nfor i in range(n):\n    l,r=map(int,input().split())\n    a.append([l,r,i+1])\na.sort(key=lambda x:(x[0],-x[1]))\nr=0\niid=0\nf=1\nfor i in range(n):\n    if(r>=a[i][1]):\n        f=0\n        print(a[i][2],a[iid][2])\n        break;\n    else:\n        r=a[i][1]\n        iid=i;\nif(f):\n    print(\"-1 -1\")\n", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "I=lambda:[*map(int,input().split())]\nR=range;m=min;N,M,K=I();r=R(N)\nif K&1:\n\tfor _ in r:print(*[-1]*M)\n\texit()\nA=[I()for _ in r]\nB=[I()for _ in R(N-1)]\nX=[M*[0]for _ in r]\nfor k in R(1,K//2+1):\n\tY=[M*[9**9]for _ in r]\n\tfor i in r:\n\t\tfor j in R(M):\n\t\t\tif i:Y[i][j]=X[i-1][j]+2*B[i-1][j]\n\t\t\tif i<N-1:Y[i][j]=m(Y[i][j],X[i+1][j]+2*B[i][j])\n\t\t\tif j:Y[i][j]=m(Y[i][j],X[i][j-1]+2*A[i][j-1])\n\t\t\tif j<M-1:Y[i][j]=m(Y[i][j],X[i][j+1]+2*A[i][j])\n\tX=Y\nfor x in X:print(*x)", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "n=int(input())\na=sorted([int(x) for x in input().split()])\ncounter=0\ntest=[False]*n\nfor j in range(n):\n    if not test[j]:\n        for i in range(n):\n            if not test[i] and a[i]%a[j]==0:\n                test[i]=True\n        counter+=1\nprint(counter)\n            \n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "n = int(input())\nt = [0 for i in range(2000)]\nc = [0 for i in range(2000)]\nfor i in range(n) :\n    x = int(input())\n    r = 0\n    ok = False\n    for j in range(2000) :\n        if x >> j & 1 :\n            if t[j] != 0 :\n                x ^= t[j]\n                r ^= c[j]\n            else :\n                t[j] = x\n                c[j] = r ^ (1 << i)\n                ok = True\n                break\n    if ok :\n        print(0)\n        continue\n    a = []\n    for j in range(2000) :\n        if r >> j & 1 :\n            a.append(j)\n    print(len(a))\n    for y in a :\n        print(y)\n                ", "complexity": "np", "problem": "0504_D", "from": "CODEFORCES", "tags": "bitmasks"}
{"src": "n = int(input())\nif n==1:\n    print(5)\nelse:\n    print(25)\n", "complexity": "constant", "problem": "0630_A", "from": "CODEFORCES", "tags": "number theory"}
{"src": "n,k=map(int,input().split())\nmod=998244353\n\nNEXT={(0,1):2,(1,2):2}#ww or wh,point k,\u5834\u5408\u306e\u6570\n\nfor i in range(1,n):\n    NOW=NEXT\n    NEXT=dict()\n    for key in NOW:\n        \n        \n\n        if key[0]==0:\n            if k-(n-i)*2<=key[1]<=k:\n                NEXT[key]=NEXT.get(key,0)+NOW[key]\n            if k-(n-i)*2<key[1]+1<=k:\n                NEXT[(0,key[1]+1)]=NEXT.get((0,key[1]+1),0)+NOW[key]\n                NEXT[(1,key[1]+1)]=NEXT.get((1,key[1]+1),0)+NOW[key]*2%mod\n\n\n        else:\n            if k-(n-i)*2<=key[1]<=k:\n                NEXT[key]=NEXT.get(key,0)+NOW[key]\n                NEXT[(0,key[1])]=NEXT.get((0,key[1]),0)+NOW[key]*2%mod\n\n            if k-(n-i)*2<key[1]+2<=k:\n                NEXT[(1,key[1]+2)]=NEXT.get((1,key[1]+2),0)+NOW[key]\n        #print(NOW,NEXT)\n\n\n\n\nANS=0\nfor key in NEXT:\n    if key[1]==k:\n        ANS=(ANS+NEXT[key])%mod\n\nprint(ANS)\n", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "T = int(input())\n\nwhile (T != 0):\n    T -= 1\n\n    N, K = map(int, input().split())\n    cur_usage = 0\n    reslog = 0\n    cnts = dict()\n\n    while True:\n        reslog += 1\n        cur_usage +=  (1 << reslog) - 1\n        if reslog != N:\n            cnts[reslog] = (((1 << reslog)-2)<<1) + 1\n\n        if cur_usage + (1 << (reslog+1))-1 > K or reslog == N:\n            break\n\n    K -= cur_usage\n\n    while K > 0:\n        if len(cnts) == 0:\n            break\n        for key in cnts:\n            K -= cnts[key]\n            if key+1 >= N:\n                del cnts[key]\n                break\n            if (key+1 not in cnts):\n                cnts[key+1] = 0\n            cnts[key+1] += cnts[key] * 4\n            del cnts[key]\n            break\n\n\n\n\n    if K <= 0:\n        print('YES %d' % (N-reslog))\n    else:\n        print('NO')\n        \n\n\n\n\n", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "\ndef STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nimport string\nimport sys\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter , defaultdict\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n#visited = [[False for i in range(m)] for j in range(n)]\n#  primes = [2,11,101,1009,10007,100003,1000003,10000019,102345689]\n#sys.stdin = open(r'input.txt' , 'r')\n#sys.stdout = open(r'output.txt' , 'w')\n#for tt in range(INT()):\n#arr.sort(key=lambda x: (-d[x], x)) Sort with Freq\n\n#Code\n\nn = INT()\narr = LIST()\nmx = max(arr)\nx = -1\nif mx == 1 :\n    x = 2\nelse:\n    x = 1\n\narr.remove(mx)\narr.append(x)\narr.sort()\nprint(*arr)\n\n\n", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "from sys import stdin,stdout\nnmbr=lambda:int(stdin.readline())\nlst=lambda:list(map(int,stdin.readline().split()))\nfor _ in range(1):#nmbr()):\n    n=nmbr()\n    l=sorted(zip(lst(),range(n)))\n    p=0;ans=[0]*(2*n)\n    st=[0]*n;ln=0\n    s=input()\n    for i in range(2*n):\n        # print(st)\n        ch=s[i]\n        if ch=='0':\n            st[ln]=p\n            ans[i]=l[p][1]+1\n            ln+=1\n            p+=1\n        else:\n            ans[i]=l[st[ln-1]][1]+1\n            ln-=1\n    print(*ans)", "complexity": "nlogn", "problem": "0982_B", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "# from collections import deque\n\nn = int(input())\na = [int(x) for x in input().split()]\n\na_reverse = a.copy()\nstatus = []\nfor i in range(n):\n    a_reverse[a[i]-1] = i\n    status.append(None)\n\n\npos = a_reverse[n-1]\nstatus[pos] = False\nfails = set()\nfails.add(pos)\nfor i in range(n-1,0,-1):\n    i_ = i-1\n    pos = a_reverse[i_]\n    for k in range((pos+1)%i-1,n,i):\n        if k == pos:\n            continue\n        if k in fails:\n            status[pos] = True\n            break\n    if not status[pos]:\n        status[pos] = False\n        fails.add(pos)\n\n\n# BAAAABAB\n# ABAAAABBBAABAAB\n\n\n# status = []\n# for i in range(n):\n#     status.append(None)\n\n# queue = deque()\n\n# def eval_(pos):\n#     pos_status = status[pos]\n#     for i in range(n):\n#         if i == pos:\n#             continue\n#         if status[i] != None:\n#             continue\n#         if  a[i] > a[pos]:\n#             continue\n#         if (abs(i - pos) % a[i]) == 0:\n#             status[i] = not pos_status\n#             queue.append(i)\n\n# pos = a.index(n)\n# status[pos] = False\n# queue.append(pos)\n#\n# while len(queue) != 0:\n#     item = queue.popleft()\n#     eval_(item)\n#\n# print(status)\n#\nresult = \"\"\nfor i in status:\n    if i == True:\n        result=result+\"A\"\n    else:\n        result=result+\"B\"\n\nprint(result)\n\n\n\n\n", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "n=int(input())\nw = [(int(x), c+1) for c, x in enumerate(input().split())]\nb=sorted(w,reverse=True)    \nf=[]\np=[]\nk=input()\nfor i in k:\n    if i==\"0\":\n        x=b.pop()\n        f.append(x)\n        p.append(x[1])\n    else:\n        y=f.pop()\n        p.append(y[1])\nprint(*p) \n  \t \t \t \t\t\t\t\t   \t \t\t \t\t \t\t\t \t\t\t", "complexity": "nlogn", "problem": "0982_B", "from": "CODEFORCES", "tags": "data structures,greedy,implementation"}
{"src": "from sys import stdin\ns=stdin.readline()\nfor ln in range(len(s),0,-1):\n    for L in range(len(s)-ln+1):\n        if s[L:L+ln] in s[L+1:]:\n            print(ln)\n            exit()\nprint(0)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "def pow_mod(x, pwr, mod):\n\tres = 1\n\tmultiplier = x\n\twhile pwr > 0:\n\t\tif pwr%2 == 1: \n\t\t\tres = res*multiplier % mod\n\t\tmultiplier = multiplier*multiplier % mod\n\n\t\tpwr //= 2\n\n\treturn res\n\n[x, k] = map(int, input().split())\n\nMOD = 1000000007\n\nif x == 0:\n\tres = 0\nelse:\n\tres = pow_mod(2, k+1, MOD)*x % MOD\n\tres = (res - pow_mod(2, k, MOD)) % MOD\n\tres = (res + 1) % MOD\n\nprint(res)", "complexity": "logn", "problem": "0992_C", "from": "CODEFORCES", "tags": "math"}
{"src": "# A. Splits\n\nn = int(input())\n\n# Editorial - https://codeforces.com/blog/entry/58991\nprint(n//2 + 1)\n", "complexity": "constant", "problem": "0964_A", "from": "CODEFORCES", "tags": "math"}
{"src": "def solve():\n    n, k = [int(x) for x in input().split(' ')]\n    t = input()\n    j = 0\n    for i in range(1, n):\n        if t[:i] == t[-i:]:\n            j = i\n    s = t + (k - 1) * t[-(n - j):]\n    return s\n\nprint(solve())\n\n", "complexity": "quadratic", "problem": "1029_A", "from": "CODEFORCES", "tags": "implementation,strings"}
{"src": "#import sys\n#digit = int(sys.argv[1])\ndigit = int(input())\n\nif int(digit) <= 9:\n    print(digit)\n    exit()\n\nstart_range = 1\nend_range = 9\n\npower = 1\ndigit_count = 2\nwhile not (start_range <= digit and digit <= end_range):\n    start_range = end_range + 1\n    end_range = 9 * 10**power * digit_count + start_range - 1\n    power += 1\n    digit_count += 1\n\noffset_number = (digit - start_range) // (digit_count - 1)\n#print(f\"{digit} - {start_range} mod {digit_count-1} = {offset_number}\")\nnumber = str(10**(power - 1) + offset_number)\n#print(f\"10^ {power - 1} + {offset_number} = {number}\")\noffset_digit = (digit - start_range) % (digit_count - 1) \n#print(f\"{digit} - {start_range} mod {digit_count - 1 } = {offset_digit}\")\n#print(f\"{number} {number[-offset_digit]}\")\nprint(f\"{number[offset_digit]}\")\n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "import sys\n\ninput = sys.stdin.readline\n\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef lcm(a, b):\n    return (a * b) / gcd(a, b)\n\ndef main():\n    n,r=map(int, input().split())\n    a=list(map(int, input().split()))\n    ans=[]\n    ans.append(r)\n    for i in range(1,n):\n        ymax=r\n        for j in range( i):\n            if abs(a[j]-a[i])<=2*r:\n                ymax=max(ymax, ans[j]+(4*r*r-(a[i]-a[j])**2)**0.5)\n        ans.append(ymax)\n    print(*ans)\n    # for i in range(15):\n    #     print(x[i],end=' ')\n\n\n\n\n\n\n\n\n\n\n\n\n\n    return\n\nif __name__==\"__main__\":\n    main()\n\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "a, b = map(int, input().split())\nx, y, z = map(int, input().split())\nprint(max((0,2*x+y-a))+max((0,3*z+y-b)))", "complexity": "constant", "problem": "0912_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def main():\n    n, m = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(input())\n    ans = \"NO\"\n    count = [0] * m\n    for i in range(n):\n        for j in range(m):\n            if (a[i][j] == '1'):\n                count[j] += 1\n    for i in range(n):\n        ans = \"YES\"\n        for j in range(m):\n            if (count[j] == 1 and a[i][j] == '1'):\n                ans = \"NO\"\n                break\n        if (ans == \"YES\"):\n            break\n    print(ans)\nmain()", "complexity": "quadratic", "problem": "0985_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from math import *\nimport sys\ninput = lambda: sys.stdin.readline().strip()\n\nd = {'m': [], 's': [], 'p': []}\n\nls = list(input().split())\nfor i in ls:\n    d[i[1]].append(int(i[0]))\nfor k, v in d.items():\n    v.sort()\n    if len(v)==3 and len(set(v))==1: print(0); break\n    if len(v)==3 and v[0]+1==v[1] and v[1]+1==v[2]: print(0); break\nelse:\n    for k, v in d.items():\n        if len(v)==2 and len(set(v))==1: print(1); break\n        if len(v)==2 and v[1]-v[0]<=2: print(1); break\n        if len(v)==3 and (v[0]==v[1] or v[1]==v[2]): print(1); break\n        if len(v)==3 and (v[1]-v[0]<=2 or v[2]-v[1]<=2): print(1); break\n    else:\n        print(2)\n", "complexity": "nlogn", "problem": "1191_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "n = int(input())\nx, y = list(map(int,input().split()))\nif x-1+y-1 <= n-x+n-y:\n    print('White')\nelse:\n    print('Black')", "complexity": "constant", "problem": "1075_A", "from": "CODEFORCES", "tags": "implementation,math"}
{"src": "t = int(input())\n\ndef sol(n, k):\n    p = 1\n    q = 1\n    acc = 0\n    while n > 0 and k >= p:\n        k -= p\n        n -= 1\n        if n >= 40:\n            return n\n        acc += q*(4**n-1)//3\n        if k <= acc:\n            return n\n        p = 2*p+1\n        q = 2*q+3\n    return -1\n\nfor _ in range(t):\n    n, k = (int(v) for v in input().split())\n    ans = sol(n, k)\n    if ans == -1:\n        print(\"NO\")\n    else:\n        print(\"YES\", ans)", "complexity": "logn", "problem": "1080_D", "from": "CODEFORCES", "tags": "constructive algorithms,implementation,math"}
{"src": "n, k = map(int, input().split())\nli = [int(num) for num in input().split(\" \", n - 1)]\nans = []\nfor i in range(0, n):\n    su = 0\n    for j in range(i, n):\n        su += li[j]\n        if (j - i + 1 >= k):\n            ans.append(su / (j - i + 1))\nprint(max(ans))", "complexity": "quadratic", "problem": "1003_C", "from": "CODEFORCES", "tags": "brute force,implementation,math"}
{"src": "import bisect\nxzy=[10,190,2890,38890,488890,5888890,68888890,788888890,8888888890,98888888890,1088888888890,11888888888890]\nk=int(input())\ndigits=bisect.bisect_left(xzy,k)\nif k==10:\n    print(1)\nelif k>10:\n    apu=k-xzy[digits-1]\n    modulo=apu%(digits+1)\n    dlj=apu//(digits+1)\n    output=10**(digits)+dlj\n    list1=[i for i in str(output)]\n    print(list1[modulo])\nelse:\n    print(k)\n\n        \n        \n        \n        \n        \n", "complexity": "logn", "problem": "1177_B", "from": "CODEFORCES", "tags": "binary search,divide and conquer,implementation"}
{"src": "n=int(input())\nlist1=list(map(int,input().split(' ')))\nsum2=0\nsum1=0\ncount=0\nlist1.sort(reverse=True)\nfor i in range(len(list1)):\n    sum1=sum1+list1[i]\n\nfor i in range(len(list1)):\n    if(int(sum1/2)>=sum2):\n        sum2=sum2+list1[i]\n        count=count+1\nprint(count)", "complexity": "nlogn", "problem": "0160_A", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "a,b=list(map(int,input().split()))\nc,d=(((b+1)//2)-1,(b-a-1))\nprint(c if d<0 else c-d if c>d else 0)\n", "complexity": "constant", "problem": "1023_B", "from": "CODEFORCES", "tags": "math"}
{"src": "n,pos,l,r=map(int,input().split())\nif l==1 and r==n:\n    print(0)\nelif l==1:\n    print(abs(pos-r)+1)\nelif r==n:\n    print(abs(pos-l)+1)\nelse:\n    print(min(abs(pos-l),abs(pos-r))+abs(l-r)+2)", "complexity": "constant", "problem": "0915_B", "from": "CODEFORCES", "tags": "implementation"}
{"src": "def get_sign_1(fo):\n\tdef res(s, f=fo):\n\t\tif f**2+s**2 == 2*f*s+1:\n\t\t\treturn '1'\n\t\telse:\n\t\t\treturn '0'\n\treturn res\n\n\ndef get_signs_2(cf, rev):\n\tcf -= 1\n\tif rev:\n\t\tdef res(fo, cff=cf):\n\t\t\tif fo >= cff:\n\t\t\t\tdef res2(s, f=fo):\n\t\t\t\t\tif s == f:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telif s >= cff:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn '1'\n\t\t\telse:\n\t\t\t\tdef res2(s, f=fo):\n\t\t\t\t\tif s == f:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn '1'\n\t\t\treturn res2\n\telse:\n\t\tdef res(fo, cff=cf):\n\t\t\tif fo >= cff:\n\t\t\t\tdef res2(s, f=fo):\n\t\t\t\t\tif s == f:\n\t\t\t\t\t\treturn '0'\n\t\t\t\t\telif s >= cff:\n\t\t\t\t\t\treturn '1'\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn '0'\n\t\t\telse:\n\t\t\t\tdef res2(s):\n\t\t\t\t\treturn '0'\n\t\t\treturn res2\n\treturn res\nn, a, b = map(int, input().split())\nc = a*b\nif a+b == c+1 and (c > 1 or n == 1 or n > 3):\n\tprint(\"YES\")\n\tif c == 1:\n\t\tget_sign_f = get_sign_1\n\telse:\n\t\tget_sign_f = get_signs_2(c, c == b)\n\tfor foo in range(n):\n\t\tprint(''.join(map(get_sign_f(foo), range(n))))\nelse:\n\tprint(\"NO\")\n", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "n=int(input())\nL=list(map(int,input().split()))\nans=['']*n\nrevL=[0]*n\nans[-1]='B'\nfor i in range(n):\n    revL[L[i]-1]=i+1\nfor i in range(n-2,-1,-1):\n    t=revL[i]-1\n    counter='B'\n    for j in range(t,-1,-i-1):\n        if j==t:continue\n        if ans[L[j]-1]=='B':\n            counter='A'\n            break\n    if counter!='A':\n        for k in range(t,n,i+1):\n            if k==t:continue\n            if ans[L[k]-1]=='B':\n                counter='A'\n                break\n    ans[i]=counter\nfor i in range(n):\n    print(ans[L[i]-1],sep='',end='')", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "pfs=[i*i for i in range(1,3163)]\np=[i for i in range(0,10000001)]\nfor i in range(1,10000001):\n    if(p[i]==i):\n        for j in pfs:\n            if(i*j>10000000): break\n            p[i*j]=i\nt=int(input())\nfor lll in range(0,t):\n    n,k=map(int,input().split())\n    zc=list(map(int,input().split()))\n    s=[p[zc[i]] for i in range(0,len(zc))]\n    dp=[n]*(k+1)\n    dp[0]=1\n    ys=[{}]*(n+1)\n    for i in range(0,len(s)):\n        for j in range(k,-1,-1):\n            if(dp[j]==n): continue\n            if(ys[j].get(s[i],-1)!=-1):\n                if(j<k and dp[j]<dp[j+1]):\n                    dp[j+1]=dp[j]\n                    ys[j+1]=ys[j]\n                dp[j]+=1\n                ys[j]={}\n            ys[j][s[i]]=1\n    print(min(dp))", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "from math import inf\n\n\nn, m, k = map(int, input().split())\nhorizontal_costs = []\nvertical_costs = []\nfor _ in range(n):\n    horizontal_costs.append(list(map(int, input().split())))\nfor _ in range(n-1):\n    vertical_costs.append(list(map(int, input().split())))\n\ndp = [[[inf] * (k // 2 + 1) for _ in range(m)] for _ in range(n)]\n\n# dp[a][b][c] - smallest cost of moving c squares from (a, b)\n# ans[a][b] = 2 * dp[a][b][k//2] if k % 2 == 0 else -1\n\n\ndef find_cost(a, b, c):\n    global dp\n    if a < 0 or a > n-1 or b < 0 or b > m-1:\n        return inf\n\n    if c == 0:\n        return 0\n\n    if dp[a][b][c] != inf:\n        return dp[a][b][c]\n\n    if a < n-1:\n        dp[a][b][c] = find_cost(a+1, b, c-1) + vertical_costs[a][b]\n    if b < m-1:\n        dp[a][b][c] = min(dp[a][b][c], find_cost(a, b+1, c-1) + horizontal_costs[a][b])\n    if b > 0:\n        dp[a][b][c] = min(dp[a][b][c], find_cost(a, b-1, c-1) + horizontal_costs[a][b-1])\n    if a > 0:\n        dp[a][b][c] = min(dp[a][b][c], find_cost(a-1, b, c-1) + vertical_costs[a-1][b])\n\n    return dp[a][b][c]\n\n\nans = [[inf] * m for _ in range(n)]\nif k % 2 == 1:\n    for i in range(n):\n        for j in range(m):\n            ans[i][j] = -1\nelse:\n    for i in range(n):\n        for j in range(m):\n            ans[i][j] = min(ans[i][j], 2 * find_cost(i, j, k//2))\n\nfor row in ans:\n    print(*row)", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import math\ns1 = input().strip()\ns2 = input().strip()\nps1 = 0\nms1 = 0\nps2 = 0\nms2 = 0\nqs2 = 0\nfor i in s1:\n    if i=='+':\n        ps1+=1\n    if i=='-':\n        ms1+=1\nfor i in s2:\n    if i=='+':\n        ps2+=1\n    if i=='-':\n        ms2+=1\n    if i == '?':\n        qs2+=1\nif ps2<=ps1 and ms2<=ms1:\n    print(math.factorial(qs2)/math.factorial(ps1-ps2)/math.factorial(ms1-ms2)*(0.5**qs2))\nelse:\n    print(0.00000000)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    a=list(map(int,input().rstrip()))\n    b=list(map(int,input().rstrip()))\n    ans,la,lb=[],len(a),len(b)\n    if la!=lb:\n        print(*sorted(a,reverse=True),sep=\"\")\n    else:\n        for i in range(lb):\n            if b[i] in a:\n                ans.append(b[i])\n                a.remove(b[i])\n            else:\n                while i>-1:\n                    ma=-1\n                    for j in a:\n                        if j<b[i]:\n                            ma=max(ma,j)\n                    if ma!=-1:\n                        ans.append(ma)\n                        a.remove(ma)\n                        break\n                    i-=1\n                    a.append(ans.pop())\n                a.sort()\n                while a:\n                    ans.append(a.pop())\n                break\n        print(*ans,sep=\"\")\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "\n'''\n    int n;\n    cin >> n;\n\n    int sum = 0;\n    map<int, int> mp;\n    BigInt ans;\n    for(int i = 1; i <= n; i++) {\n        cin >> arr[i];\n        sum += arr[i];\n        \n        mp[arr[i]]++;\n        // fix each element as y\n        ll adj = mp[arr[i]] + mp[arr[i]+1] + mp[arr[i]-1];\n\n        ll c = sum;\n        c -= mp[arr[i]]*arr[i];\n        c -= mp[arr[i]+1] * (arr[i]+1);\n        c -= mp[arr[i]-1] * (arr[i]-1);\n\n        ll valid = i - adj;\n        ans += ((ll)valid*(ll)arr[i])-c;\n    }\n\n    cout << ans << endl;\n    '''\n\nn = int(input())\n\na = map(int, input().split())\nmp = {}\ns = 0\nans = 0\ni = 0\nfor x in a:\n    i += 1\n    s += x\n\n    if x not in mp:\n        mp[x] = 0\n\n    if x+1 not in mp:\n        mp[x+1] = 0\n\n    if x-1 not in mp:\n        mp[x-1] = 0\n    mp[x] += 1\n\n    adj = mp[x] + mp[x+1] + mp[x-1];\n    c = s;\n    c -= mp[x]*x;\n    c -= mp[x+1] * (x+1);\n    c -= mp[x-1] * (x-1);\n\n    valid = i-adj\n\n    ans += (valid*x)-c\n\nprint(ans)", "complexity": "nlogn", "problem": "0903_D", "from": "CODEFORCES", "tags": "data structures,math"}
{"src": "def sfy(n):\n    if n == 1: return [1]\n    elif n == 2: return [1, 2]\n    elif n == 3: return [1, 1, 3]\n    else:\n        if n % 2 == 0: return [1]*(n//2) + [2*x for x in sfy(n//2)]\n        else:\n            return [1]*(1 + n//2) + [2*x for x in sfy(n//2)]\nprint(\" \".join([str(x) for x in sfy(int(input()))]))\n    \n", "complexity": "nlogn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "x=input()\na=0\nfor i in range(len(x)):\n    for j in range(i,len(x)):\n        if x[i:j] in x[i+1:]:\n            if len(x[i:j])>a:\n                a=len(x[i:j])\nprint(a)\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import bisect\nimport copy\nimport decimal\nimport fractions\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter,deque,defaultdict\nfrom functools import lru_cache,reduce\nfrom heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max\ndef _heappush_max(heap,item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap)-1)\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        item, heap[0] = heap[0], item\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import gcd as GCD\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\nclass Prime:\n    def __init__(self,N):\n        assert N<=10**8\n        self.smallest_prime_factor=[None]*(N+1)\n        for i in range(2,N+1,2):\n            self.smallest_prime_factor[i]=2\n        n=int(N**.5)+1\n        for p in range(3,n,2):\n            if self.smallest_prime_factor[p]==None:\n                self.smallest_prime_factor[p]=p\n                for i in range(p**2,N+1,2*p):\n                    if self.smallest_prime_factor[i]==None:\n                        self.smallest_prime_factor[i]=p\n        for p in range(n,N+1):\n            if self.smallest_prime_factor[p]==None:\n                self.smallest_prime_factor[p]=p\n        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]\n\n    def Factorize(self,N):\n        assert N>=1\n        factorize=defaultdict(int)\n        if N<=len(self.smallest_prime_factor)-1:\n            while N!=1:\n                factorize[self.smallest_prime_factor[N]]+=1\n                N//=self.smallest_prime_factor[N]\n        else:\n            for p in self.primes:\n                while N%p==0:\n                    N//=p\n                    factorize[p]+=1\n                if N<p*p:\n                    if N!=1:\n                        factorize[N]+=1\n                    break\n                if N<=len(self.smallest_prime_factor)-1:\n                    while N!=1:\n                        factorize[self.smallest_prime_factor[N]]+=1\n                        N//=self.smallest_prime_factor[N]\n                    break\n            else:\n                if N!=1:\n                    factorize[N]+=1\n        return factorize\n\n    def Divisors(self,N):\n        assert N>0\n        divisors=[1]\n        for p,e in self.Factorize(N).items():\n            A=[1]\n            for _ in range(e):\n                A.append(A[-1]*p)\n            divisors=[i*j for i in divisors for j in A]\n        return divisors\n\n    def Is_Prime(self,N):\n        return N==self.smallest_prime_factor[N]\n\n    def Totient(self,N):\n        for p in self.Factorize(N).keys():\n            N*=p-1\n            N//=p\n        return N\n\n    def Mebius(self,N):\n        fact=self.Factorize(N)\n        for e in fact.values():\n            if e>=2:\n                return 0\n        else:\n            if len(fact)%2==0:\n                return 1\n            else:\n                return -1\n\nN,Q=map(int,readline().split())\nP=Prime(5*10**5)\nmebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)]\ncnt=[0]*(5*10**5+1)\nans=0\nA=list(map(int,readline().split()))\nused=[False]*(N)\nfor _ in range(Q):\n    q=int(readline())-1\n    prime=list(P.Factorize(A[q]).keys())\n    l=len(prime)\n    for bit in range(1<<l):\n        s=1\n        for i in range(l):\n            if bit>>i&1:\n                s*=prime[i]\n        if used[q]:\n            cnt[s]-=1\n            ans-=cnt[s]*mebius[s]\n        else:\n            ans+=cnt[s]*mebius[s]\n            cnt[s]+=1\n    if used[q]:\n        used[q]=False\n    else:\n        used[q]=True\n    print(ans)", "complexity": "np", "problem": "0547_C", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp,math,number theory"}
{"src": "n,l,r,x=map(int,input().split())\nc=list(map(int,input().split()))\nans=0\nfor i in range(0,2**n):\n    v=[]\n    for j in range(n):\n        if i & (1<<j):v.append(c[j])\n    if sum(v)>=l and sum(v)<=r and (max(v)-min(v)>=x): ans+=1\nprint(ans)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "#Bhargey Mehta (Junior)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open('input.txt', 'r')\nMOD = 998244353\nsys.setrecursionlimit(1000000)\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[-10**20 for i in range(m)] for i in range(n)]\n\nfor i in range(n):\n    for j in range(min(m, i+1)):\n        if j == 0:\n            dp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k\n        else:\n            dp[i][j] = dp[i-1][j-1]+a[i]\n\nans = 0\nfor i in range(n):\n\tans = max(ans, max(dp[i]))\nprint(ans)", "complexity": "quadratic", "problem": "1197_D", "from": "CODEFORCES", "tags": "dp,greedy,math"}
{"src": "from math import factorial\n\nsend = input()\nreceive = input()\n\ncntP = send.count(\"+\")\ncntN = send.count(\"-\")\n\ncnt1 = receive.count(\"+\")\ncnt2 = receive.count(\"-\")\n\nmark = receive.count(\"?\")\n\ntotal = pow(2, mark)\n\nif cntP < cnt1 or cntN < cnt2:\n    valid = 0\nelse:\n    valid = factorial(mark) / factorial(mark - cntP + cnt1) / factorial(cntP - cnt1)\nprint(f\"{valid / total:0.12f}\")\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "a = []\nn = int(input())\nfor _ in range(n):\n    a.append(input())\nif n==1:\n    print(\"YES\")\n    print(a[0])\nelse:\n    a.sort(key = len)\n    for i in range(1,n):\n        if a[i-1] not in a[i]:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")\n        for i in a:\n            print(i)\n        \n", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "import sys\ninput=sys.stdin.readline\ndef fun(k):\n    global li,t\n    tem=[]\n    count=0\n    for i in li:\n        if(i[0]>=k):\n            tem.append(i)\n            count+=1\n    if(count>=k):\n        ans=0\n        for i in range(k):\n            ans+=tem[i][1]\n        if(ans<=t):\n            return True\n        else:\n            return False\n    else:\n        return False\n                  \nn,t=map(int,input().split())\nli=[]\nfor _ in range(n):\n    li.append(list(map(int,input().split()))+[_])\nli.sort(key=lambda x:x[1])\nl=0\nr=n\nwhile(r-l>1):\n    mid=(l+r)//2\n    if(fun(mid)):\n        l=mid\n    else:\n        r=mid\nfin=0\nfor i in range(l,r+1):\n    if(fun(i)):\n        fin=i\nprint(fin)\nprint(fin)\ntem=[]\nfor i in range(n):\n    if(li[i][0]>=fin):\n        tem.append(li[i][2]+1)\nprint(*tem[:fin])", "complexity": "nlogn", "problem": "0913_D", "from": "CODEFORCES", "tags": "binary search,brute force,data structures,greedy,sortings"}
{"src": "n, m = map(int, input().split(' '))\n\ndistances = list(map(int, input().split(' ')))\ntaxiDriver = list(map(int, input().split(' ')))\n\npeople = []\ndrivers = []\nresult = [0] * m\n\nfor i in range(len(distances)):\n  if(taxiDriver[i]):\n    drivers.append(distances[i])\n  else:\n    people.append(distances[i])\n\nj = 0\n\nfor person in people:\n  if (j + 1) < len(drivers):\n    while (j + 1) < len(drivers) and (drivers[j] - person) < (person - drivers[j + 1]) :\n      j += 1\n    \n    result[j] += 1\n  else:\n    result[j] += 1\n\nprint(' '.join(map(str, result)))\n\n", "complexity": "nlogn", "problem": "1075_B", "from": "CODEFORCES", "tags": "implementation,sortings"}
{"src": "import sys\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\ndef slv():\n    n, m, k = map(int, input().split())\n    if k % 2 != 0:\n        for i in range(n):\n            print(*[-1]*m)\n        return\n    #always possible\n\n    k //= 2\n\n    DP = [[[0]*m for i in range(n)] for _ in range(k + 1)]\n    G = [[[] for i in range(m)] for j in range(n)]\n    for i in range(n):\n        C = list(map(int,input().split()))\n        for j in range(m - 1):\n            cost = C[j]\n            G[i][j].append((cost,i,j + 1))\n            G[i][j + 1] .append((cost,i,j))\n\n    for i in range(n - 1):\n        C = list(map(int,input().split()))\n        for j in range(m):\n            cost = C[j]\n            G[i][j].append((cost,i + 1,j))\n            G[i+1][j].append((cost,i,j))\n\n\n    for p in range(1,k + 1):\n        for u in range(n):\n            for v in range(m):\n                DP[p][u][v] = min(DP[p - 1][x][y] + cost for (cost,x,y) in G[u][v])\n    for i in range(n):\n        ans = [DP[k][i][j]*2 for j in range(m)]\n        print(*ans)\n    return\ndef main():\n    t = 1\n    for i in range(t):\n        slv()\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "\nmod = 998244353\nN,K = map(int, input().split())\n\ndp = [[[0]*(K+2) for i in range(2)] for i in range(N)]\ndp[0][0][0] = 1\ndp[0][1][1] = 1\n\nfor i in range(1,N):\n    for b in range(K):\n        dp[i][0][b]   += dp[i-1][0][b]\n        dp[i][0][b]   += dp[i-1][1][b]\n        dp[i][0][b]   += dp[i-1][1][b]\n        dp[i][0][b+1] += dp[i-1][0][b]\n        dp[i][0][b]   %= mod\n\n        dp[i][1][b+1] += dp[i-1][0][b]\n        dp[i][1][b]   += dp[i-1][1][b]\n        dp[i][1][b+2] += dp[i-1][1][b]\n        dp[i][1][b+1] += dp[i-1][0][b]\n        dp[i][1][b] %= mod\n\nans = 0\nfor x in range(2):\n    ans += dp[N-1][x][K-1]\n\nprint(ans*2%mod)\n", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    alst = [int(input()) for _ in range(n)]\n    ans = []\n    for a in alst:\n        if a == 1:\n            ans.append(\"1\")\n            print(\".\".join(ans))\n            continue\n        while ans and int(ans[-1]) != a - 1:\n            ans.pop()\n        if not ans:\n            ans.append(str(a))\n        else:\n            ans.pop()\n            ans.append(str(a))\n        \n        print(\".\".join(ans))\n        \n    \nfor _ in range(int(input())):\n    main()", "complexity": "quadratic", "problem": "1523_C", "from": "CODEFORCES", "tags": "brute force,data structures,greedy,implementation,trees"}
{"src": "R = lambda :map(int, input().split())\nn = int(input())\nl = []\nfor _ in range(n):\n    a,b = R()\n    l.append((a,-b,_+1))\nl = sorted(l)\nfor i in range(1,n):\n    if l[i][1]>=l[i-1][1]:\n        print(l[i][2],l[i-1][2])\n        break\nelse:\n    print(-1,-1)", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "#WARNING This code is just for fun. Reading it might give u a brainfreeze\n\nn,d,k = [int(x) for x in input().strip().split(' ')]\nl = []\ni = 1\nif n<=d:\n\tprint(\"NO\")\nelif k==1:\n\tif n>2:\n\t\tprint(\"NO\")\n\telif n==2:\n\t\tprint(\"YES\")\n\t\tprint(1,2)\nelse:\n\tn+=1\n\tflag = False\n\twhile i<min(d+1,n):\n\t\tl.append(str(i)+\" \"+str(i+1))\n\t\ti+=1\n\ti+=1\n\tcnt1=0\n\tcnt2=1\n\tse=[[2,d+1,1]]\n\twhile cnt1<cnt2:\n\t\tstart = se[cnt1][0]\n\t\tend = se[cnt1][1]\n\t\tmode = se[cnt1][2]\n\t\t#print(se)\n\t\tkk = 3\n\t\twhile (i<n) and (kk<=k):\n\t\t\tif i<n and not flag:\n\t\t\t\tj = start\n\t\t\t\t#print(j,\"kk\")\n\t\t\t\twhile i<n and j<end:\n\t\t\t\t\tif mode==1:\n\t\t\t\t\t\tc = min(j-start+1,end-j)\n\t\t\t\t\telse:\n\t\t\t\t\t\tc = min(end-j,d-end+j)\n\t\t\t\t\tif c>1:\n\t\t\t\t\t\tse.append([i,i+c-1,2])\n\t\t\t\t\t\tcnt2+=1\n\t\t\t\t\tki=j\n\t\t\t\t\twhile i<n and c>0:\n\t\t\t\t\t\tl.append(str(ki)+\" \"+str(i))\n\t\t\t\t\t\t#print(j,i,c)\n\t\t\t\t\t\tc-=1\n\t\t\t\t\t\tki=i\n\t\t\t\t\t\ti+=1\n\t\t\t\t\tj+=1\n\t\t\t\t\t\n\t\t\telse:\n\t\t\t\tflag = True\n\t\t\t\tbreak\n\t\t\tkk+=1\n\t\tcnt1+=1\n\tif i<n or flag:\n\t\t#print(l)\n\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"YES\")\n\t\tprint('\\n'.join(l))", "complexity": "quadratic", "problem": "1003_E", "from": "CODEFORCES", "tags": "constructive algorithms,graphs"}
{"src": "n, m = map(int, input().split())\na = [0 for i in range(n)]\nl, r = 0, n - 1\nm -= 1\n\nfor i in range(1, n + 1):\n    cur = 2**(n - i - 1)\n\n    if (m >= cur):\n        m -= cur\n        a[r] = i\n        r -= 1\n    else:\n        a[l] = i\n        l += 1\n        \nprint(*a)\n", "complexity": "np", "problem": "0513_B2", "from": "CODEFORCES", "tags": "bitmasks,divide and conquer,math"}
{"src": "import sys, math\nimport io, os\n# data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\n# from heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n# from itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\n# from fractions import Fraction\n# sys.setrecursionlimit(100000)\nINF = 10001\nmod = int(1e9) + 7\n\n\ndef cal(l,r):\n    if l==r:\n        dp1[l][r]=a[l]\n        dp3[l][r] = 1\n        return dp1[l][r]\n    if dp1[l][r]!=-1:\n        return dp1[l][r]\n    for i in range(l,r):\n        if cal(l,i) == cal(i+1,r) != 0:\n            dp1[l][r]=dp1[l][i]+1\n            dp3[l][r]=1\n        dp3[l][r]=min(dp3[l][r],dp3[l][i]+dp3[i+1][r])\n    if dp1[l][r] == -1:\n        dp1[l][r] = 0\n    return dp1[l][r]\n\n\nn=int(data())\na=mdata()\nans=[n]\ndp1=[[-1]*n for i in range(n)]\ndp3=[[10001]*n for i in range(n)]\ncal(0,n-1)\nout(dp3[0][n-1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "# Author : nitish420 --------------------------------------------------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n# mod=10**9+7\n# sys.setrecursionlimit(10**5)\nmxm=sys.maxsize\n\ndef solve(p,q,r):\n\n    if p<0 or p>=n or q<0 or q>=m:\n        return mxm\n\n    if dp[r][p][q]!=-1:\n        return dp[r][p][q]\n\n\n    if r==0:\n        return 0\n\n    z=int()\n    a,b,c,d=0,0,0,0\n    a=dp[r-1][p][q-1]\n    b=dp[r-1][p][q+1]\n    c=dp[r-1][p-1][q]\n    d=dp[r-1][p+1][q]\n\n    if a==-1:\n        a=row[p][q-1]+solve(p,q-1,r-1)\n    else:\n        a+=row[p][q-1]\n\n    if b==-1:\n        b=row[p][q]+solve(p,q+1,r-1)\n    else:\n        b+=row[p][q]\n    \n    if c==-1:\n        c=col[p-1][q]+solve(p-1,q,r-1)\n    else:\n        c+=col[p-1][q]\n    \n    if d==-1:\n        d=col[p][q]+solve(p+1,q,r-1)\n    else:\n        d+=col[p][q]\n\n\n\n    z=min([a,b,c,d])\n\n    dp[r][p][q]=z\n    return z\n\n\nn,m,k=map(int,input().split())\nrow=[]\ncol=[]\nfor i in range(n):\n\n    row.append(list(map(int,input().split()))+[0])\n\nfor _ in range(n-1):\n\n    col.append(list(map(int,input().split())))\n\n\ncol.append([0 for i in range(m)])\n\nans=[[-1 for _ in range(m)] for _ in range(n)]\n\ndp=[[[-1 for _ in range(m+1)] for _ in range(n+1)] for _ in range(k+1)]\n\ndef main():\n\n    if k%2:\n        for item in ans:\n            print(*item)\n        exit()\n\n    \n    for r in range(n):\n        for c in range(m):\n            ans[r][c]=2*solve(r,c,k//2)\n    \n    for item in ans:\n        print(*item)\n\n\n\n\n#----------------------------------------------------------------------------------------\ndef nouse0():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse1():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse2():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\n\n\ndef nouse3():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse4():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse5():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\n\n\n\n# endregion\n\nif __name__ == '__main__':\n    main()", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import math\n\nn, r = map(int, input().split())\nx = list(map(int, input().split()))\ny = [r]\n\nfor i in range(1, n):\n    _y = r\n    for j in range(i):\n        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):\n            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))\n    y.append(_y)\n\nprint(' '.join(map(str, y)))\n", "complexity": "quadratic", "problem": "0908_C", "from": "CODEFORCES", "tags": "brute force,geometry,implementation,math"}
{"src": "import sys\ninput=sys.stdin.buffer.readline\n\nn=int(input())\na=list(map(int,input().split()))\ndp=[[0]*(n) for i in range(n)]\nfor i in range(n):\n    dp[i][i]=a[i]\ncount=1\nfor i in range(n-1):\n    for j in range(n-i-1):\n        dp[j][j+count]=dp[j][j+count-1]^dp[j+1][j+count]\n    count+=1\ncount=1\nfor i in range(n-1):\n    for j in range(n-i-1):\n        dp[j][j+count]=max(dp[j][j+count],dp[j][j+count-1],dp[j+1][j+count])\n    count+=1\nfor i in range(int(input())):\n    l,r=map(int,input().split())\n    l-=1\n    r-=1\n    print(dp[l][r])", "complexity": "quadratic", "problem": "0983_B", "from": "CODEFORCES", "tags": "dp"}
{"src": "import os, sys\nfrom io import BytesIO, IOBase\nfrom math import log2, ceil, sqrt, gcd\nfrom _collections import deque\nimport heapq as hp\nfrom bisect import bisect_left, bisect_right\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nmod = 10 ** 9 + 7\n\nR,G,B=map(int,input().split())\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\ndp=[[[0]*(B+1) for _ in range(G+1)] for __ in range(R+1)]\nans=0\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if i>0 and j>0 and k>0:\n                dp[i][j][k] = max(dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1],\n                                  dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1],\n                                  dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])\n            elif i>0 and j>0:\n                dp[i][j][k] =dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1]\n            elif i>0 and k>0:\n                dp[i][j][k] = dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1]\n                ans = max(ans, dp[i][j][k])\n            elif j>0 and k>0:\n                dp[i][j][k]=dp[i][j-1][k-1]+g[j-1]*b[k-1]\n            ans=max(ans,dp[i][j][k])\n# for i in dp:\n#     print(i)\nprint(ans)\n\n\n\n\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "from collections import Counter\nts=Counter(''.join(reversed(t)) for t in input().split())\nt0 = None\nrun = 0\nans = 3\nfor t, c in sorted(ts.items()):\n    if t0 is None or t[0] != t0[0] or int(t[1]) != int(t0[1])+1:\n        run = 0\n    t0 = t\n    run += 1\n    ans = min(ans, 3-max(c,run))\nfor s in 'spm':\n    for r in range(1, 10):\n        if s+str(r-1) in ts and s+str(r+1) in ts:\n            ans = min(ans, 1)\nprint(ans)\n", "complexity": "nlogn", "problem": "1191_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nw = sum(a[i] == i + 1 for i in range(n))\nprint(\"Petr\") if w >= n // 1000 else print(\"Um_nik\")\n", "complexity": "nlogn", "problem": "0986_B", "from": "CODEFORCES", "tags": "combinatorics,math"}
{"src": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n#CF-E-00\nfrom collections import deque, defaultdict\ndef topological_sort(In, Out):\n    dq, L = deque(), []\n    for i, I in enumerate(In):\n        if not I:\n            dq.append(i)\n    while dq:\n        v = dq.popleft()\n        L.append(v)\n        for w in Out[v]:\n            In[w].remove(v)\n            if not In[w]:\n                dq.append(w)\n    if len(L) < len(In):\n        return False\n    return L\n\ndef main():\n    n, m, k = map(int,input().split())  #k: length of following inputs\n\n    def edges(s):\n        Ans = set()\n        for i in range(2**k):\n            ans = ''\n            for j in range(k):\n                if i>>j&1:\n                    ans = ''.join([ans, s[j]])\n                else:\n                    ans = ''.join([ans, '_'])\n            Ans.add(ans)\n        return Ans\n\n    D = defaultdict(lambda : -1)\n    for i in range(n):\n        D[input()] = i\n\n    flag = 1\n    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]\n    for _ in range(m):\n        S, t = input().split()\n        t = int(t)\n\n        for e in edges(S):\n            if D[e]+1:\n                Out[t-1].add(D[e])\n                In[D[e]].add(t-1)\n        if t-1 not in Out[t-1]:\n            flag = 0\n            break\n        else:\n            Out[t-1].remove(t-1)\n            In[t-1].remove(t-1)\n\n    T = topological_sort(In, Out)\n    if flag == 0 or not T:\n        print('NO')\n    else:\n        print('YES')\n        print(*[t+1 for t in T], sep = ' ')\n        \nmain()", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "n = int(input())\nA = list(map(int, input().split()))\n\ndp = [[1 for j in range(5)] for i in range(n)]\nPrev = [[-1 for i in range(5)] for i in range(n)]\n\nfor i in range(1, n):\n    for j in range(5):\n        for finger in range(5):\n            if dp[i - 1][finger] == 1:\n                if (A[i - 1] < A[i] and finger < j) or (A[i - 1] > A[i] and finger > j) or (A[i - 1] == A[i] and finger != j):\n                    dp[i][j] = 1\n                    Prev[i][j] = finger\n                    break\n        else:\n            dp[i][j] = 0\nfinger = 0\nfor j in range(5):\n    if dp[-1][j] == 1:\n        finger = j\n        path = [finger]\n        for i in range(n - 1, 0, -1):\n            finger = Prev[i][finger]\n            path.append(finger)\n        path = path[::-1]\n        for i in range(n):\n            print(path[i] + 1, end=' ')\n        break\nelse:\n    print(-1)\n            \n", "complexity": "quadratic", "problem": "1032_C", "from": "CODEFORCES", "tags": "constructive algorithms,dp"}
{"src": "import sys\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nak=[]\ni=0\nwhile 2**i <=2000000000:\n    ak.append(2**i)\n    i+=1\n\nn=int(input())\na=list(map(int,input().split()))\nd=dict()\nfor i,v in enumerate(a):\n    d[v]=d.get(v,set())\n    d[v].add(i)\nans=[0]*n\nfor i in range(n):\n    for j in ak:\n        if j-a[i] in d:\n            if (j-a[i]==a[i] and len(d[a[i]])>=2) or j-a[i]!=a[i] :\n                ans[i]=1\n                break\nprint(ans.count(0))", "complexity": "nlogn", "problem": "1005_C", "from": "CODEFORCES", "tags": "brute force,greedy,implementation"}
{"src": "n,m = map(int,input().split())\nx = [0]*(n+1)\nfor i in range(n):\n    x[i] = int(input())\nx[n] = 1000000000\nvert = []\nfor i in range(m):\n    x1,x2,y = map(int,input().split())\n    if x1 == 1:\n        vert.append(x2)\nvert.sort()\nx.sort()\ncur = 0\nminicount = n+m\nk = len(vert)\nfor i in range(n+1):\n    while cur < k:\n        if x[i] <= vert[cur]:\n            break\n        cur += 1\n    minicount = min(minicount,k-cur+i)\nprint(minicount)\n", "complexity": "nlogn", "problem": "1075_C", "from": "CODEFORCES", "tags": "two pointers"}
{"src": "n=int(input())\nl=[]\nnn=n\nwhile n :\n    n-=1\n    s=input()\n    l.append([len(s),s])\nl.sort()\nch=1\ni=1\n#print(l[i][1])\nans=[]\nfor i in range(nn-1):\n    if l[i][1] not in l[i+1][1]:\n        ch=0\n        break\n    else:\n    \n        ans.append(l[i][1])\n        \n    \nif ch:\n    ans.append(l[nn-1][1])\n    print(\"YES\")\n    \n    print(*ans, sep = \"\\n\")\nelse:\n    print(\"NO\")\n        \n        \n", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "'''input\n6\n10 2 3 5 4 2\n\n\n'''\nimport sys\nfrom collections import defaultdict as dd\n\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\n\nn = ri(1)\na= ri()\n\nb= sorted(a)\nc= dd(int)\n\n\nans = 0\nval=0\nfor i in range(n):\n\tif c[b[i]]==0:\n\t\tval+=1\n\t\tfor j in range(n):\n\t\t\tif b[j]%b[i]==0:\n\t\t\t\tc[b[j]]=val\n\nfor i in c:\n\tans = max(ans , c[i])\n\nprint(ans)\n\n", "complexity": "quadratic", "problem": "1209_A", "from": "CODEFORCES", "tags": "greedy,implementation,math"}
{"src": "n = int(input())\narr = list(map(int,input().split()))\narr.sort()\nif n>=2 and  arr[0]==arr[1]==0:\n\tprint(\"cslnb\")\nelse:\n\tflag=0\n\tfor i in range(n-2):\n\t\tif arr[i]==arr[i+1]==arr[i+2]:\n\t\t\tflag=1\n\t\t\tbreak\n\tif flag==1:\n\t\tprint(\"cslnb\")\n\telse:\n\t\tflag=0\n\t\tind=0\n\t\tfor i in range(n-1):\n\t\t\tif arr[i]==arr[i+1]:\n\t\t\t\tind = i\n\t\t\t\tflag+=1\n\t\tif flag==1 and ind>0 and arr[ind-1]==arr[ind]-1:\n\t\t\tprint(\"cslnb\")\n\n\t\telif flag>=2:\n\t\t\tprint(\"cslnb\")\n\t\telse:\n\t\t\tsafe = 0\n\t\t\tfor i in range(n):\n\t\t\t\t#print(safe)\n\t\t\t\tif arr[i]-i>=0:\n\t\t\t\t\tsafe+=arr[i]-i\n\t\t\t#print(safe)\n\t\t\tif safe%2==0:\n\t\t\t\tprint(\"cslnb\")\n\t\t\telse:\n\t\t\t\tprint(\"sjfnb\")", "complexity": "nlogn", "problem": "1191_D", "from": "CODEFORCES", "tags": "games"}
{"src": "MOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\nfrom collections import defaultdict as dd\nn , = I()\nd = dd(list)\nfor i in range(n-1):\n\tt = I()\n\td[t[0]].append(t[1])\n\td[t[1]].append(t[0])\nl = I()\nv = [0]*(n+1)\ns = 1\nwhat = 0\nv[1] = 1\nwhile what < s:\n        a = set()\n        i = l[what]\n        for j in d[i]:\n                if not v[j]:\n                        a.add(j)\n        b = set()\n        for j in range(s,s + len(a)):\n                b.add(l[j])\n        if a!=b:\n                print('No')\n                exit()\n        kkk = 0\n        for k in a:\n            kkk += 1\n            v[k] = 1\n        s += kkk\n        what += 1\nif s != n:\n    print('No')\n    exit()\nprint('Yes')\n", "complexity": "nlogn", "problem": "1037_D", "from": "CODEFORCES", "tags": "dfs and similar,graphs,shortest paths,trees"}
{"src": "from math import factorial as fact\n\ns=input()\nt=input()\n\npos=s.count('+')-t.count('+')\nneg=s.count('-')-t.count('-')\nque=t.count('?')\nif pos<0 or neg<0:\n    print(0)\nelse:\n    print((fact(que)/(fact(pos)*fact(neg)))/(2**que))\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "a = [ord(e) - ord('0') for e in list(input().strip())]\nb = [ord(e) - ord('0') for e in list(input().strip())]\n\na.sort(reverse=True)\nh = [0 for i in range(10)]\nfor x in a:\n    h[x] += 1\n\nif len(a) < len(b):\n    print(''.join(map(str, a)))\n    exit(0)\n\ndef gmax(hx):\n    s = list(hx)\n    res = list()\n    for i in range(9, -1, -1):\n        while s[i] > 0:\n            res.append(i)\n            s[i] -= 1\n    return res\n\ndef gmin(hx):\n    s = list(hx)\n    res = list()\n    for i in range(10):\n        while s[i] > 0:\n            res.append(i)\n            s[i] -= 1\n    return res\n\nres = list()\n\ndef finalize(x):\n    for y in range(x-1, -1, -1):\n        if h[y] > 0:\n            res.append(y)\n            h[y] -= 1\n            for i in range(9, -1, -1):\n                while h[i] > 0:\n                    res.append(i)\n                    h[i] -= 1\n            return\n\np = 0\nwhile p < len(a):\n    x = b[p]    \n    if h[x] > 0:\n        hh = list(h)\n        hh[x] -= 1\n        if b[p+1:] >= gmin(hh): # can make a smaller one with the remainings\n            res.append(x)\n            h[x] -= 1\n        else:\n            finalize(x)\n            break\n    else:\n        finalize(x)\n        break\n    p += 1\nprint(''.join(map(str, res)))", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "r,g,b = map(int,input().split())\nR = sorted([*map(int,input().split())],reverse=True)\nG= sorted([*map(int,input().split())],reverse=True)\nB = sorted([*map(int,input().split())],reverse=True)\nmem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]\ndef dp(i,j,k):\n    p = (i==r)+(j==g)+(k==b)\n    if(p>1):\n        return 0\n    if(mem[i][j][k]!=-1):\n        return mem[i][j][k]\n    ans = 0\n    if(i==r):\n        ans = dp(i,j+1,k+1)+G[j]*B[k]\n        return ans\n    elif(j==g):\n        ans = dp(i+1,j,k+1)+R[i]*B[k]\n    elif(k==b):\n        ans = dp(i+1,j+1,k)+R[i]*G[j]\n    else:\n        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])\n    mem[i][j][k] = ans\n    return ans\nprint(dp(0,0,0))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n,k = [int(s) for s in input().split()]\np = [int(s) for s in input().split()]\n\nmap = {}\nres = []\n\nfor pi in p:\n    if map.get(pi) is None:\n        key = pi\n        for j in range(pi, pi-k, -1):\n            if j < 0: break\n            if map.get(j) is None:\n                key = j\n            else:\n                if map[j] >= pi-k+1: key = map[j]\n                break\n        for j in range(pi, key-1, -1):\n            if map.get(j):\n                break\n            map[j] = key\n    res.append(map[pi])\n\nprint(*res, sep=\" \")\n", "complexity": "quadratic", "problem": "0980_C", "from": "CODEFORCES", "tags": "games,greedy"}
{"src": "# cook your dish here\nn,m,k = map(int,input().split())\nwh=[]\n#for left to right connections\nfor j in range(n):\n    l=list(map(int,input().split()))\n    wh.append(l)\n    \nwv=[]\n#for top to bottom connections\nfor j in range(n-1):\n    l=list(map(int,input().split()))\n    wv.append(l)\n    \nif(k%2!=0):\n    ans = [[-1 for _ in range(m)]for j in range(n)]\n    for res in ans:\n        print(*res)\nelse:\n    dp = [[[0 for i in range(25)]for j in range(505)]for q in range(505)]\n    for x in range(1,21):\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                dp[i][j][x]=1234567890\n                if(i!=n):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1]+wv[i-1][j-1])\n                if(i!=1):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1]+wv[i-2][j-1])\n                if(j!=m):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1]+wh[i-1][j-1])\n                if(j!=1):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1]+wh[i-1][j-2])\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            ans = 1234567890\n            for x in range(1,k+1):\n                if(k%x==0 and (k//x)%2==0 ):\n                    ans = min(ans,dp[i][j][x]*(k//x))\n            print(ans,end=\" \")\n        print()", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from sys import stdin, stdout, maxsize\nfrom math import inf\n\nR = lambda : stdin.readline().strip()\nRL = lambda f=None: list(map(f, R().split(' '))) if f else list(R().split(' '))\n\noutput = lambda x: stdout.write(str(x) + '\\n')\noutput_list = lambda x: output(' '.join(map(str, x)))\n\n\nn, m, K = RL(int)\n\nif K%2:\n    for i in range(n):\n        print( *(m*[-1]) )\n    exit()\n\nhor = [ RL(int) +[inf] for i in range(n) ]\nvert = [ RL(int) for i in range(n-1) ] + [ m*[inf] ]\n\nK = K//2\ndp = [ [m*[inf] for i in range(n)] for j in range(0, K+1)]\n\ndp[0] = [m*[0] for i in range(n)]\n\ndef valid(i, j):\n    if -1 < i < n and  -1 < j < m:\n        return True\n    return False\n\nfor k in range(1, K+1):\n    for i in range(n):\n        for j in range(m):\n            if valid(i, j+1):\n                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j+1] + 2*hor[i][j])\n            if valid(i+1, j):\n                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i+1][j] + 2*vert[i][j])\n            if valid(i-1, j):\n                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i-1][j] + 2*vert[i-1][j])\n            if valid(i, j-1):\n                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j-1] + 2*hor[i][j-1])\n\nfor i in dp[-1]:\n    print(*i)\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from collections import Counter\nimport string\nimport math\nimport sys\n# sys.setrecursionlimit(10**6) \nfrom fractions import Fraction\ndef array_int():\n    return [int(i) for i in sys.stdin.readline().split()]\ndef vary(arrber_of_variables):\n    if arrber_of_variables==1:\n        return int(sys.stdin.readline())\n    if arrber_of_variables>=2:\n        return map(int,sys.stdin.readline().split()) \ndef makedict(var):\n    return dict(Counter(var))\ntestcases=1\nfor _ in range(testcases):\n    n=vary(1)\n    indices=array_int()\n    cost=array_int()\n    ans=float('inf')\n    mint=[]\n    for i in range(n):\n        ans=float('inf')\n        total=cost[i]\n        flag=0\n        for j in range(i):\n            if indices[i]>indices[j]:\n                ans=min(ans,cost[j])\n                flag=1\n        if flag!=0:\n            total+=ans\n            ans=float('inf')\n            flag=0\n            for k in range(i+1,n):\n                if indices[k]>indices[i]:\n                    ans=min(ans,cost[k])\n                    flag=1\n            if flag!=0:\n                total+=ans\n                mint.append(total)\n            else:\n                continue\n        else:\n            continue\n    if len(mint)>0:\n        print(min(mint))\n    else:\n        print(-1)\n\n\n                \n\n                \n\n        ", "complexity": "quadratic", "problem": "0987_C", "from": "CODEFORCES", "tags": "brute force,dp,implementation"}
{"src": "import sys\nsys.setrecursionlimit(200000)\ninput=sys.stdin.readline\n \ndef solve(r,g,b,R,G,B):\n    if (r==0 and g==0) and (r==0 and b==0) and (g==0 and b==0):\n        return 0\n    if z[r][g][b]!=-1:\n        return z[r][g][b]\n    d,e,f=0,0,0\n    if r!=0 and g!=0:\n        d=R[r-1]*G[g-1]+solve(r-1,g-1,b,R,G,B)\n    if r!=0 and b!=0:\n        e=R[r-1]*B[b-1]+solve(r-1,g,b-1,R,G,B)\n    if b!=0 and g!=0:\n        f=B[b-1]*G[g-1]+solve(r,g-1,b-1,R,G,B)\n    z[r][g][b]=max(d,e,f)\n    return z[r][g][b]\n \nr,g,b=map(int,input().rstrip().split())\nR=sorted(map(int,input().rstrip().split()))\nG=sorted(map(int,input().rstrip().split()))\nB=sorted(map(int,input().rstrip().split()))\nz=[[[ -1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]\nprint(solve(r,g,b,R,G,B))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "def solution():\n    \n    n = int(input())\n    segments = []\n    for i,_ in enumerate(range(n)):\n        x,y = input().split(\" \")\n        segments.append((int(x), int(y), i+1))\n\n    segments = sorted(segments, key=lambda x: (x[0], -x[1]))\n\n    for i,seg in enumerate(segments):\n        j = i+1\n        if j >= n:\n            print(\"-1 -1\")\n            return\n\n        while segments[j][1] <= seg[1]:\n            print(\"{} {}\".format(segments[j][2], seg[2]))\n            return\n\n    print(\"-1 -1\")\n    return\n\nsolution()\n", "complexity": "nlogn", "problem": "0976_C", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int,sys.stdin.readline().strip().split()))\na.sort()\n\nif n == 1:\n    if a[0] % 2 == 1:\n        v = True\n    else:\n        v = False\nelse:\n    v = True\n    c = 0\n    for i in range (0, n-1):\n        if a[i] == a[i + 1]:\n            c = c + 1\n            j = i\n    if c > 1:\n        v = False\n    elif c == 1:\n        if a[j] == 0:\n            v = False\n        if j > 0:\n            if a[j-1] + 1 == a[j]:\n                v = False\n    if (sum(a) - (n * (n - 1)) // 2) % 2 == 0:\n        v = False\n\nif v == True:\n    print(\"sjfnb\")\nelse:\n    print(\"cslnb\")\n    ", "complexity": "nlogn", "problem": "1190_B", "from": "CODEFORCES", "tags": "games"}
{"src": "s=input()\nfor ln in range(len(s),0,-1):\n    for L in range(len(s)-ln+1):\n        if s[L:L+ln] in s[L+1:]:\n            print(ln)\n            exit()\nprint(0)\n        \n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "import sys, os\nfrom io import BytesIO, IOBase\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\n\n# region fastio\nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nstdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) \n\nmod = pow(10, 9) + 7\nmod2 = 998244353\n        \ndef inp(): return stdin.readline().strip()\ndef iinp(): return int(inp())\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)//b\nS1 = 'abcdefghijklmnopqrstuvwxyz'\nS2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n \nn, m, k = mp()\nhor = [lmp() for i in range(n)]\nver = [lmp() for i in range(n-1)]\nif k%2:\n    ml = l2d(n, m, -1)\n    for i in ml: print(*i)\n    exit()\nk//=2\ndp = [l2d(n, m) for i in range(k+1)]\nfor f in range(1, k+1):\n    for i in range(n):\n        for j in range(m):\n            a = inf\n            if i!=0:\n                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])\n            if i!=n-1:\n                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])\n            if j!=0:\n                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])\n            if j!=m-1:\n                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])\n            dp[f][i][j] = a\nfor i in dp[-1]:\n    print(*i)", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "######################################################################\n# Write your code here\nimport sys\ninput = sys.stdin.readline\n#import resource\n#resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY])\n#sys.setrecursionlimit(0x100000)\n# Write your code here\nRI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nrw = lambda : input().strip().split()\nfrom collections import defaultdict as df\n#import heapq \n#heapq.heapify(li) heappush(li,4) heappop(li)\nimport random\n#random.shuffle(list)\ninfinite = float('inf')\n#######################################################################\n\nt=int(input())\n\nfor _ in range(t):\n    n,k=RI()\n    s=input()\n\n    mini=n\n    \n    test=\"RGB\"*(k//3 + 5)\n    for i in range(n-k+1):\n        count=0\n        \n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    test=\"GBR\"*(k//3 + 5)\n    for i in range(n-k+1):\n        count=0\n        \n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    test=\"BRG\"*(k//3 + 5)\n    for i in range(n-k+1):\n        count=0\n        \n        for j in range(k):\n            if(s[i+j]!=test[j]):\n                count+=1\n\n        mini=min(count,mini)\n\n    print(mini)\n", "complexity": "quadratic", "problem": "1196_D1", "from": "CODEFORCES", "tags": "implementation"}
{"src": "from collections import defaultdict, Counter,deque\nfrom math import sqrt, log10, log, floor, factorial,gcd\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations,combinations\nimport sys, io, os\ninput = sys.stdin.readline\n# input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n# sys.setrecursionlimit(10000)\ninf = float('inf')\nmod = 10 ** 9 + 7\ndef yn(a): print(\"YES\" if a else \"NO\")\nceil = lambda a, b: (a + b - 1) // b\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nclass masks:\n    def all_masks_sos(self,arr,lim=22):\n        lim = 22\n        maxbits = lim\n        self.masks=masks = 1 << lim\n        self.dp = [-1] * masks\n        for i in arr:\n            self.dp[i] = i\n        for i in range(masks):\n            for j in range(maxbits):\n                if self.dp[i] == -1 and i & (1 << j):\n                    self.dp[i] = self.dp[i - (1 << j)]\n\nt=1\nm=masks()\nfor i in range(1):\n    n=int(input())\n    l=[int(i) for i in input().split()]\n    m.all_masks_sos(l,22)\n    ans = [m.dp[i ^ (m.masks - 1)] for i in l]\n    print(*ans)\n\n\n\n\n\n\n\n\n", "complexity": "np", "problem": "0165_E", "from": "CODEFORCES", "tags": "bitmasks,brute force,dfs and similar,dp"}
{"src": "import sys\nimport math\ndef input():    return sys.stdin.readline().strip()\ndef iinput():   return int(input())\ndef minput():   return map(int, sys.stdin.readline().strip().split()) \ndef listinput(): return list(map(int, sys.stdin.readline().strip().split())) \nn,m=minput()\nx=listinput()\ny=listinput()\nxx=set(x)\nyy=set(y)\ncommon=xx.intersection(yy)\nfor i in x:\n    if i in common:\n        print(i,end=' ')", "complexity": "quadratic", "problem": "0994_A", "from": "CODEFORCES", "tags": "implementation"}
{"src": "#by Nick \"LordVader\" Proshin\nimport sys\ninput = sys.stdin.readline\nout = sys.stdout\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(set(a)) == 1:\n        out.write(str(a[0])+\" \"+str(a[0])+\" \"+str(a[0])+\" \"+str(a[0])+\"\\n\")\n    else:\n        a.sort()\n        g1 = False\n        d = {}\n        mx = 10001\n        for i in a:\n            if i not in d.keys():\n                d[i] = 1\n            else:\n                d[i] += 1\n            if d[i] == 4:\n                g1 = True\n                if i < mx:\n                    mx = i\n        if g1:\n            out.write(str(mx)+\" \"+str(mx)+\" \"+str(mx)+\" \"+str(mx)+\"\\n\")\n        else:\n            res = []\n            for k in d.keys():\n                if d[k] >= 2:\n                    res.append(k)\n            m = len(res)\n            minj = 0\n            for j in range(m - 1):\n                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):\n                    minj = j\n            out.write(str(res[minj])+\" \"+str(res[minj])+\" \"+str(res[minj+1])+\" \"+str(res[minj+1])+\"\\n\")", "complexity": "nlogn", "problem": "1027_C", "from": "CODEFORCES", "tags": "greedy"}
{"src": "string=input()\nn=len(string)\ncheck=True\nfor sub_len in range(n-1,0,-1):\n    for starting_index in range(n-sub_len+1):\n        if string[starting_index:starting_index+sub_len] in string[starting_index+1:]:\n            print(sub_len)\n            check=False\n            break\n    if check==False:\n        break  \nif check:\n    print(0)\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "n,k = map(int,input().split())\na = list(map(int,input().split()))\n\nif k == 1:\n    print(max(a) - min(a))\n    exit()\n\ndif = []\nfor i in range(n - 1):\n    dif.append(a[i + 1] - a[i])\ndif = sorted(dif)\nprint(sum(dif[:-k + 1]))", "complexity": "nlogn", "problem": "1197_C", "from": "CODEFORCES", "tags": "greedy,sortings"}
{"src": "import sys\ninput = sys.stdin.readline\n\na,b,c = list(map(int,input().split()))\n\nx = list(map(int,input().split()))\ny = list(map(int,input().split()))\nz = list(map(int,input().split()))\n\nx.sort(reverse=True)\ny.sort(reverse=True)\nz.sort(reverse=True)\n\na+=1\nb+=1\nc+=1\n\nx = [0] + x\ny = [0] + y\nz = [0] + z\n\ntmp = [[0]*c for _ in range(b)]\nbest = [tmp for _ in range(a)]\n\n#print(tmp)\n#print(best)\nans = 0\n\nfor i in range(a):\n    for j in range(b):\n        for k in range(c):\n            if (i+j+k) % 2 == 0:\n                aa,bb,cc = 0,0,0\n                if i>0 and j>0:\n                    aa = best[i-1][j-1][k] + x[i] * y[j]\n                if i>0 and k>0:\n                    bb = best[i-1][j][k-1] + x[i] * z[k]\n                if j>0 and k>0:\n                    cc = best[i][j-1][k-1] + y[j] * z[k]\n                \n                best[i][j][k] = max(aa,bb,cc)\n                ans = max(ans, best[i][j][k])\n#print(best)\nprint(ans)\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "x1, y1, x2, y2, x3, y3 = map(int, input().split())\nrect1 = [x1, y1]\nrect2 = [x2, y2]\nrect3 = [x3, y3]\ndef func():\n    rect11 = [x1, y1]\n    rect22 = [x2, y2]\n    rect33 = [x3, y3]\n    rect1 = [x1, y1]\n    rect2 = [x2, y2]\n    rect3 = [x3, y3]\n\n    recta = [x1, y1]\n    rectb = [x2, y2]\n    rectc = [x3, y3]\n    for i in rect11:\n        for ii in rect22:\n            for iii in rect33:\n                if i==ii:\n                    rect1.remove(i)\n                    rect2.remove(ii)\n                    if rect1[0]+rect2[0]==iii:\n                        rect3.remove(iii)\n                        if i+rect3[0]==iii:\n                            print(iii)\n                            for j in range(iii):\n                                if j<rect1[0]:\n                                    print(\"C\"*rect3[0]+\"A\"*i)\n                                else:\n                                    print(\"C\"*rect3[0]+\"B\"*ii)\n                            exit()\n                rect1=recta.copy()\n                rect2=rectb.copy()\n                rect3=rectc.copy()\n\n                if i==iii:\n                    rect1.remove(i)\n                    rect3.remove(iii)\n                    if rect1[0]+rect3[0]==ii:\n                        rect2.remove(ii)\n                        if i+rect2[0]==ii:\n                            print(ii)\n\n                            for j in range(ii):\n                                if j<rect1[0]:\n                                    print(\"B\"*rect2[0]+\"A\"*i)\n                                else:\n                                    print(\"B\"*rect2[0]+\"C\"*iii)\n                            exit()\n                rect1 = recta.copy()\n                rect2 = rectb.copy()\n                rect3 = rectc.copy()\n                if ii==iii:\n                    rect2.remove(ii)\n                    rect3.remove(iii)\n                    if rect2[0]+rect3[0]==i:\n                        rect1.remove(i)\n                        if i==rect1[0]+ii:\n                            print(i)\n                            for j in range(i):\n                                if j<rect2[0]:\n                                    print(\"A\"*rect1[0]+\"B\"*ii)\n                                else:print(\"A\"*rect1[0]+\"C\"*iii)\n                            exit()\n                rect1=recta.copy()\n                rect2=rectb.copy()\n                rect3=rectc.copy()\n    return print(-1)\nfor i in rect1:\n    for ii in rect2:\n        for iii in rect3:\n            recta = [x1, y1]\n            rectb = [x2, y2]\n            rectc = [x3, y3]\n\n            if i==ii==iii:\n                rect1.remove(i)\n                rect2.remove(i)\n                rect3.remove(i)\n\n            if rect1[0]+rect2[0]+rect3[0]==i:\n                print(i)\n                for j in range(i):\n                    print(\"A\"*rect1[0]+\"B\"*rect2[0]+\"C\"*rect3[0])\n                exit()\n            rect1=recta\n            rect2=rectb\n            rect3=rectc\n\nfunc()\n", "complexity": "np", "problem": "0581_D", "from": "CODEFORCES", "tags": "bitmasks,brute force,constructive algorithms,geometry,implementation,math"}
{"src": "s = input().split()\nb = []\nb.append((s[0][1], int(s[0][0])))\nb.append((s[1][1], int(s[1][0])))\nb.append((s[2][1], int(s[2][0])))\nb.sort()\nif (b[0][0] == b[1][0] and b[1][0] == b[2][0]):\n    if (b[0] == b[1] and b[1] == b[2]):\n        print(0)\n    elif (b[0][1] + 1 == b[1][1] and b[1][1] + 1 == b[2][1]):\n        print(0)\n    elif (b[0] == b[1]):\n        print(1)\n    elif (b[1] == b[2]):\n        print(1)\n    elif b[0][1] + 1 == b[1][1]:\n        print(1)\n    elif b[0][1] + 2 == b[1][1]:\n        print(1)\n    elif b[1][1] + 1 == b[2][1]:\n        print(1)\n    elif b[1][1] + 2 == b[2][1]:\n        print(1)\n    elif b[0][1] + 1 == b[2][1]:\n        print(1)\n    elif b[0][1] + 2 == b[2][1]:\n        print(1)\n    else:\n        print(2)\nelif (b[0][0] != b[1][0] and b[1][0] != b[2][0] and b[2][0] != b[0][0]):\n    print(2)\nelif b[0][0] == b[1][0]:\n    if b[0] == b[1]:\n        print(1)\n    elif b[0][1] + 1 == b[1][1]:\n        print(1)\n    elif b[0][1] + 2 == b[1][1]:\n        print(1)\n    else:\n        print(2)\nelif b[1][0] == b[2][0]:\n    if (b[1] == b[2]):\n        print(1)\n    elif b[1][1] + 1 == b[2][1]:\n        print(1)\n    elif b[1][1] + 2 == b[2][1]:\n        print(1)\n    else:\n        print(2)\nelse:\n    print(2)\n    \n", "complexity": "nlogn", "problem": "1191_B", "from": "CODEFORCES", "tags": "brute force,implementation"}
{"src": "n = int(input())\nai = list(map(int,input().split()))\nai.sort()\nnum = 0\nnum2 = 0\nfor i in range(1,n):\n    if ai[i-1] == ai[i]:\n        num += 1\n        num2 = i\nif num == 0:\n    num3 = sum(ai)\n    num4 = n * (n-1) // 2\n    ans = (num3 - num4) % 2\n    if ans == 1:\n        print(\"sjfnb\")\n    else:\n        print(\"cslnb\")\nelif num == 1:\n    if (num2 > 1 and ai[num2-2] == ai[num2] - 1) or ai[num2] == 0:\n        print(\"cslnb\")\n    else:\n        num3 = sum(ai)\n        num4 = n * (n-1) // 2\n        ans = (num3 - num4) % 2\n        if ans == 1:\n            print(\"sjfnb\")\n        else:\n            print(\"cslnb\")\nelse:\n    print(\"cslnb\")\n", "complexity": "nlogn", "problem": "1191_D", "from": "CODEFORCES", "tags": "games"}
{"src": "import bisect\nimport time\ndef ass(a, b): print(f\"Assertion error: {a} != {b}\" if a != b else 'OK')\ndef nr(): return int(input())\ndef nrs(): return [int(i) for i in input().split()]\n\ndef get_prime(n):\n\tres = []\n\tfor i in range(2, n):\n\t\tis_prime = True\n\t\tfor x in res:\n\t\t\tif i % x == 0:\n\t\t\t\tis_prime = False\n\t\t\t\tbreak\n\t\tif is_prime: res.append(i)\n\treturn res\n#ass(get_prime(50),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47])\n\ncache = {}\n\ndef get_mask(num):\n\tkey = num\n\tif key in cache: return cache[key]\n\tdv = []\n\tfor p in prime:\n\t\tc = 0\n\t\twhile num % p == 0:\n\t\t\tc += 1\n\t\t\tnum = num // p\n\t\tif c % 2 == 1:\n\t\t\tdv.append(p)\n\t\tif num < p * p:\n\t\t\tbreak\n\n\tfor x in dv:\n\t\tnum *= x\n\n\tcache[key] = num\n\treturn num\n\ndef dump(dp):\n\tfor i,line in enumerate(dp):\n\t\tprint(i%10,line)\n\ndef get_left(n,k,lst):\n\tlast_in = {}\n\ts = []\n\tres = []\n\tfor i in range(n):\n\t\tgroup = get_mask(lst[i])\n\t\tif group in last_in: bisect.insort(s, last_in[group] + 1)\n\t\tlast_in[group] = i\n\t\tif len(s) <= k+1:\n\t\t\tres.append(s[::-1])\n\t\telse:\n\t\t\tm = len(s)\n\t\t\tres.append(s[m-1:m-k-2:-1])\n\treturn res\n#ass(get_left(11,4,[6,2,2,8,9,1,3,6,3,9,7]),[[], [], [2], [3, 2], [3, 2], [5, 3, 2], [5, 3, 2], [5, 3, 2, 1], [7, 5, 3, 2,1], [7, 6, 5, 3, 2], [7, 6, 5, 3, 2]])\n\ndef get_dp(n,k,lst):\n\tres = []\n\tleft = get_left(n,k,lst)\n\tfor i in range(n):\n\t\tarr = left[i]\n\t\trow = [n] * (k+1)\n\t\tfor j in range(k+1):\n\t\t\tfor g in range(j+1):\n\t\t\t\tif g >= len(arr):\n\t\t\t\t\trow[j] = 1\n\t\t\t\telse:\n\t\t\t\t\tindex = arr[g]-1\n\t\t\t\t\tjindex = j-g\n\t\t\t\t\trow[j] = min(res[index][jindex] + 1, row[j])\n\t\tres.append(row)\n\treturn res\n\ndef f(n,k,lst):\n\tdp = get_dp(n,k,lst)\n\tprint(dp[n-1][k])\n\n#start = time.time()\nprime = get_prime(3162)\n#print(time.time()-start)\n\n#f(11,4,[6,2,2,8,9,1,3,6,3,9,7])\n#f(11,4,[7,7,7,7,7,7,7,7,7,7,7])\n#f(11,4,[1,2,3,4,5,6,5,4,3,2,1])\n\nfor _ in range(nr()):\n\tn,k = nrs()\n\tf(n,k,nrs())\n", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "import math\ns1=input()\ns2=input()\ns1p=s1.count(\"+\")\ns1m=s1.count(\"-\")\ns2p=s2.count(\"+\")\ns2m=s2.count(\"-\")\ns2q=0\nif '?' in s2:\n    s2q=s2.count(\"?\")\nif s2q==0:\n    if s1p==s2p and s1m==s2m:\n        print(\"%.12f\"%1)\n    else:\n        print(\"%.12f\"%0)\nelse:\n    if s1p>=s2p and s1m>=s2m:\n        s2q=math.factorial(s2q)/(math.factorial(s1p-s2p)*math.factorial(s1m-s2m))\n        print(\"%.12f\"%(s2q/(2**s2.count(\"?\"))))\n    else:\n        print(\"%.12f\"%0)\n        \n    \n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "n = int(input())\n\nif n == 3:\n    print('1 1 3')\n    exit()\nif n == 1:\n    print('1')\n    exit()\nif n == 2:\n    print('1 2')\n    exit()\nd = 2\nans = []\nlfn = n\nwhile d <= n:\n    k = n // d\n    for j in range(lfn - k):\n        ans.append(d//2)\n    lfn = n - len(ans)\n    d *=2\nd //= 2\nk = n/d\nif k < 1.5:\n    ans.append(d)\nelse:\n    ans.append(d + d//2)\nprint(' '.join([str(i) for i in ans]))", "complexity": "nlogn", "problem": "1059_C", "from": "CODEFORCES", "tags": "constructive algorithms,math"}
{"src": "from collections import defaultdict\n\nans = defaultdict(int)\nn = int(input())\n\nbeg, end = [0] * n, [0] * n\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    beg[i] = a\n    end[i] = b + 1\nbeg.sort()\nend.sort()\n\npa, pb = 0, 0\n\ncur = 0\nlst = -1\n\nwhile pb < n:\n    pos = end[pb]\n    if pa < n:\n        pos = min(pos, beg[pa])\n\n    ans[cur] += pos - lst\n\n    ad = 0\n    mn = 0\n    while (pa < n and beg[pa] == pos):\n        ad += 1\n        pa += 1\n    while (pb < n and end[pb] == pos):\n        pb += 1\n        mn -= 1\n\n    lst = pos\n    cur += ad + mn\n\nfor i in range(1, n + 1):\n    print(ans[i], end = ' ')", "complexity": "nlogn", "problem": "1000_C", "from": "CODEFORCES", "tags": "data structures,implementation,sortings"}
{"src": "from math import factorial\ns1=input()\ns2=input()\nn=0\nx1=0\nfor i in range(len(s1)):\n    if s1[i]=='+':\n        x1+=1\n    else:\n        x1-=1\nx2=0\nfor i in range(len(s2)):\n    if s2[i]=='+':\n        x2+=1\n    elif s2[i]=='?':\n        n+=1\n    else:\n        x2-=1\nx=abs(x1-x2)\nif x>n:\n    print(0)\nelif x==n:\n    print(1/2**n)\nelse:\n    if (n-x)%2==1:\n        print(0)\n    else:\n        print((factorial(n)//(factorial((n-x)//2)*factorial(n-(n-x)//2)))/2**n)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "def replace(arr):\n    if arr==[1]*len(arr):\n        arr[-1]=2\n        print(*sorted(arr))\n        return \"\"\n    arr[arr.index(max(arr))]=1\n    print(*sorted(arr))\n    return \"\"\na=input()\nlst=list(map(int,input().strip().split()))\nprint(replace(lst))", "complexity": "nlogn", "problem": "0135_A", "from": "CODEFORCES", "tags": "greedy,implementation,sortings"}
{"src": "from __future__ import division\nfrom sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, m = rints()\na, cur, ans = rints()[::-1], 2, -1\n\nfor i in range(n - 2):\n    cur = max(cur, i + 2)\n    for j in range(cur, n):\n        if a[i] - a[j] < 1:\n            cur += 1\n            continue\n\n        if a[i] - a[j] > m:\n            break\n\n        cur += 1\n        # print(cur, a[i])\n        v = (a[i] - a[j - 1]) / (a[i] - a[j])\n        ans = max(ans, v)\n\nprint(ans)\n", "complexity": "nlogn", "problem": "0957_C", "from": "CODEFORCES", "tags": "binary search,greedy,math,two pointers"}
{"src": "n=int(input())\npieces=[]\nblacks=[0]*4\nwhites=[0]*4\nfor i in range(4):\n    grid=[]\n    for j in range(n):\n        grid.append(input())\n    if i<3:\n        input()\n    count=0\n    for j in range(n):\n        for k in range(n):\n            if (int(grid[j][k])+j+k)%2:\n                count+=1\n    blacks[i]=count\n    whites[i]=n*n-count\nans=4*n*n\nfor white1 in range(3):\n    for white2 in range(white1+1,4):\n        for black1 in range(4):\n            if black1==white1 or black1==white2:\n                continue\n            for black2 in range(black1+1,4):\n                if black2==white1 or black2==white2:\n                    continue\n                ans=min(ans,whites[white1]+whites[white2]+blacks[black1]+blacks[black2])\nprint(ans)", "complexity": "quadratic", "problem": "0961_C", "from": "CODEFORCES", "tags": "bitmasks,brute force,implementation"}
{"src": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\n#sys.setrecursionlimit(300000)\n#threading.stack_size(10**8)\n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------------------------------------------------------------\n#mod = 9223372036854775807  \nclass SegmentTree:\n    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nclass SegmentTree1:\n    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n    \nMOD=10**9+7\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n \n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n \n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n \n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n \n \nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n \n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\nmod=10**9+7\nomod=998244353\n#-------------------------------------------------------------------------\nprime = [True for i in range(200001)] \npp=[0]*200001\ndef SieveOfEratosthenes(n=200000): \n      \n    # Create a boolean array \"prime[0..n]\" and initialize \n    #  all entries it as true. A value in prime[i] will \n    # finally be false if i is Not a prime, else true. \n    \n    p = 2\n    while (p * p <= n): \n          \n        # If prime[p] is not changed, then it is a prime \n        if (prime[p] == True): \n              \n            # Update all multiples of p \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n#---------------------------------running code------------------------------------------\ndef mergeSort(arr, n):\n    # A temp_arr is created to store\n    # sorted array in merge function\n    temp_arr = [0]*n\n    return _mergeSort(arr, temp_arr, 0, n-1)\n \n# This Function will use MergeSort to count inversions\n \ndef _mergeSort(arr, temp_arr, left, right):\n \n    # A variable inv_count is used to store\n    # inversion counts in each recursive call\n \n    inv_count = 0\n \n    # We will make a recursive call if and only if\n    # we have more than one elements\n \n    if left < right:\n \n        # mid is calculated to divide the array into two subarrays\n        # Floor division is must in case of python\n \n        mid = (left + right)//2\n \n        # It will calculate inversion \n        # counts in the left subarray\n \n        inv_count += _mergeSort(arr, temp_arr, \n                                    left, mid)\n \n        # It will calculate inversion \n        # counts in right subarray\n \n        inv_count += _mergeSort(arr, temp_arr, \n                                  mid + 1, right)\n \n        # It will merge two subarrays in \n        # a sorted subarray\n \n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\n \n# This function will merge two subarrays \n# in a single sorted subarray\ndef merge(arr, temp_arr, left, mid, right):\n    i = left     # Starting index of left subarray\n    j = mid + 1 # Starting index of right subarray\n    k = left     # Starting index of to be sorted subarray\n    inv_count = 0\n \n    # Conditions are checked to make sure that \n    # i and j don't exceed their\n    # subarray limits.\n \n    while i <= mid and j <= right:\n \n        # There will be no inversion if arr[i] <= arr[j]\n \n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            # Inversion will occur.\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            k += 1\n            j += 1\n \n    # Copy the remaining elements of left \n    # subarray into temporary array\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n \n    # Copy the remaining elements of right \n    # subarray into temporary array\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n \n    # Copy the sorted subarray into Original array\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n         \n    return inv_count\n\nn=int(input())\na=list(map(int,input().split()))\nr=mergeSort(a, n)\nif r%2==(3*n)%2:\n    print(\"Petr\")\nelse:\n    print(\"Um_nik\")", "complexity": "nlogn", "problem": "0986_B", "from": "CODEFORCES", "tags": "combinatorics,math"}
{"src": "n,k=map(int,input().split())\nl=[]\nfor i in range(n):\n   manan,surbhi=map(int,input().split())\n   l.append((manan,surbhi))\n\nl.sort(key=lambda x:(x[0], -x[1]),reverse=True)\nans=1\nps=l[k-1][0]\ntp=l[k-1][1]\nfor i in range(k,n):\n    if l[i][0]==ps and l[i][1]==tp:\n        ans+=1\n    else:\n        break\nfor i in range(k-2,-1,-1):\n    if l[i][0]==ps and l[i][1]==tp:\n        ans+=1\n    else:\n        break\n             \nprint(ans)\n", "complexity": "nlogn", "problem": "0166_A", "from": "CODEFORCES", "tags": "binary search,implementation,sortings"}
{"src": "import sys\ninput = sys.stdin.readline\n\nMAXN = 202\n\ndef main():\n    R, G, B = list(map(int, input().split()))\n    r = list(map(int, input().split()))\n    g = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    r.sort()\n    g.sort()\n    b.sort()\n    dp = [[[0]*MAXN for _ in range(MAXN)] for _ in range(MAXN)]\n    for i in range(1, R+1):\n        for j in range(1, G+1):\n            dp[i][j][0] = r[i-1]*g[j-1]+dp[i-1][j-1][0]\n    for i in range(1, R+1):\n        for k in range(1, B+1):\n            dp[i][0][k] = r[i-1]*b[k-1]+dp[i-1][0][k-1]\n    for j in range(1, G+1):\n        for k in range(1, B+1):\n            dp[0][j][k] = g[j-1]*b[k-1]+dp[0][j-1][k-1]\n    for i in range(1, R+1):\n        for j in range(1, G+1):\n            for k in range(1, B+1):\n                dp[i][j][k] = max(r[i-1]*g[j-1]+dp[i-1][j-1][k], r[i-1]*b[k-1]+dp[i-1][j][k-1], g[j-1]*b[k-1]+dp[i][j-1][k-1])\n    print(dp[R][G][B])\n\nmain()\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import sys\nn,a,b = list(map(int, input().split()))\n\nif a>1 and b>1:\n\tprint('NO')\n\tsys.exit(0)\n\nif n==3 and a==1 and b==1:\n\tprint('NO')\n\tsys.exit(0)\n\nif n==2 and a==1 and b==1:\n\tprint('NO')\n\tsys.exit(0)\n\n\n\nt = [[0 for i in range(n)] for j in range(n)]\n\ncomp = max(a,b)\n\n\nfor i in range(comp-1, n-1):\n\tt[i][i+1] = 1\n\tt[i+1][i] = 1\n\nif b>1:\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif i!=j:\n\t\t\t\tt[i][j] = 1-t[i][j]\nprint('YES')\nfor i in range(n):\n\tprint(\"\".join(map(str, t[i])))\n", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "# ---------------------------iye ha aam zindegi---------------------------------------------\nimport math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\n#threading.stack_size(10**8)\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\n# ------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n#sys.setrecursionlimit(300000)\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n        \"\"\"\n        Side effect!!! Changes node. Node should have exactly one child\n        \"\"\"\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\n\n# -----------------------------------------------binary seacrh tree---------------------------------------\nclass SegmentTree1:\n    def __init__(self, data, default=300006, func=lambda a, b: min(a , b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b:a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------------------iye ha chutiya zindegi-------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\n\n# --------------------------------------iye ha combinations ka zindegi---------------------------------\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n // 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\n\n# --------------------------------------iye ha power ka zindegi---------------------------------\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\n\n# --------------------------------------------------product----------------------------------------\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\n\n# --------------------------------------------------binary----------------------------------------\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) / 2)\n\n        # Check if middle element is\n        # less than or equal to key\n        if (arr[mid] <=key):\n            count = mid + 1\n            left = mid + 1\n\n        # If key is smaller, ignore right half\n        else:\n            right = mid - 1\n\n    return count\n\n\n# --------------------------------------------------binary----------------------------------------\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    # Stores the index of the left most element\n    # from the array which is greater than k\n    leftGreater = n\n\n    # Finds number of elements greater than k\n    while (l <= r):\n        m = int(l + (r - l) / 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        # If mid element is less than\n        # or equal to k update l\n        else:\n            l = m + 1\n\n    # Return the count of elements\n    # greater than k\n    return (n - leftGreater)\n\n\n# --------------------------------------------------binary------------------------------------\nclass TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEndOfWord = False\nclass Trie:\n    def __init__(self):\n        self.root = self.getNode()\n    def getNode(self):\n        return TrieNode()\n    def _charToIndex(self, ch):\n        return ord(ch) - ord('a')\n    def insert(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n        pCrawl.isEndOfWord = True\n    def search(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return False\n            pCrawl = pCrawl.children[index]\n        return pCrawl != None and pCrawl.isEndOfWord\n#-----------------------------------------trie---------------------------------\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.count=0\n        self.left = None  # left node for 0\n        self.right = None  # right node for 1\nclass BinaryTrie:\n    def __init__(self):\n        self.root = Node(0)\n    def insert(self, pre_xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = pre_xor & (1 << i)\n            if val:\n                if not self.temp.right:\n                    self.temp.right = Node(0)\n                self.temp = self.temp.right\n                self.temp.count+=1\n            if not val:\n                if not self.temp.left:\n                    self.temp.left = Node(0)\n                self.temp = self.temp.left\n                self.temp.count += 1\n        self.temp.data = pre_xor\n    def query(self, xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = xor & (1 << i)\n            if not val:\n                if self.temp.left and self.temp.left.count>0:\n                    self.temp = self.temp.left\n                elif self.temp.right:\n                    self.temp = self.temp.right\n            else:\n                if self.temp.right and self.temp.right.count>0:\n                    self.temp = self.temp.right\n                elif self.temp.left:\n                    self.temp = self.temp.left\n            self.temp.count-=1\n        return xor ^ self.temp.data\n#-------------------------bin trie-------------------------------------------\nn=int(input())\nl=list(map(int,input().split()))\nfi=[\"even\",\"odd\"]\nq=defaultdict(int)\ne=[0]*(n+1)\ns=SegmentTree(e)\nans=0\nfor j in range(n):\n    ans+=s.query(l[j]+1,n)\n    s.__setitem__(l[j],1)\nfi1=ans\nfor i in range(int(input())):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    fi1+=((b-a+1)*(b-a))//2\n    print(fi[fi1%2])", "complexity": "quadratic", "problem": "0911_D", "from": "CODEFORCES", "tags": "brute force,math"}
{"src": "n, a, b = map(int, input().split())\nz, o = ('01', '10')[a < b]\nn *= not (a > 1 < b or 1 < n * a * b < 4)\nl = [[z] * n for _ in range(n)]\nfor i in range(n):\n    l[i][i] = '0'\nfor i in range(n - a * b):\n    l[i][i + 1] = l[i + 1][i] = o\nprint(('YES', 'NO')[not n])\nprint('\\n'.join(map(''.join, l)))\n\n  \t\t\t      \t\t \t\t\t \t \t\t  \t\t\t\t\t\t", "complexity": "quadratic", "problem": "0990_D", "from": "CODEFORCES", "tags": "constructive algorithms,graphs,implementation"}
{"src": "n = int(input())\na = [int(x) for x in input().split()]\nh = [-1]*(n)\nb = [(a[i],i) for i in range(n)]\nb.sort(reverse=True)\nfor e in b:\n\t# ~ print(e)\n\tnum,idx = e\n\tflag = True\n\tallNeg = True\n\tfoundLosing = False\n\tfoundWin = False\n\tfor i in range(idx%num,n,num):\n\t\t# ~ print(i)\n\t\tif i == idx:\n\t\t\tcontinue\n\t\tif h[i]!= -1:\n\t\t\tallNeg = False\n\t\tif h[i] == 0:\n\t\t\tfoundLosing = True\n\t\t\tbreak\n\t\tif h[i] == 1:\n\t\t\tfoundWin = False\n\tif allNeg:\n\t\th[idx] = 0\n\telif foundLosing:\n\t\th[idx] = 1\n\telse:\n\t\th[idx] = 0\t\n\t# ~ print(\" \".join(str(ss) for ss in h))\nfor i in range(n):\n\tif h[i]==0:\n\t\tprint('B',end='')\n\telse:\n\t\tprint('A',end='')\n\t\t\n# ~ print(h)\n", "complexity": "quadratic", "problem": "1033_C", "from": "CODEFORCES", "tags": "brute force,dp,games"}
{"src": "tt=int(input())\nfor _ in range(tt):\n    s=input()\n    t=input()\n    flag='NO'\n    j=0\n    ptr=0\n    while(j<len(s) and ptr<len(t)):\n        if(s[j]==t[ptr]):\n            ptr+=1\n            j+=1\n        else:\n            j+=1\n    if(ptr==len(t)):\n        flag='YES'\n    else:\n        pos=[0]*26\n        for i in range(len(s)):\n            pos[ord(s[i])-97]+=1\n        for i in range(0,len(t)):\n            h=[]\n            for j in range(0,len(pos)):\n                h.append(pos[j])\n            j=0\n            ptr=0\n            temp1=0\n            while(ptr<=i and j<len(s)):\n                if(s[j]==t[ptr] and h[ord(s[j])-97]>0):\n                    h[ord(s[j])-97]-=1\n                    ptr+=1\n                    j+=1\n                else:\n                    j+=1\n            if(ptr==i+1):\n                temp1=1\n\n            j=0\n            ptr=i+1\n            temp2=0\n            while(ptr<len(t) and j<len(s)):\n                if(s[j]==t[ptr] and h[ord(s[j])-97]>0):\n                    h[ord(s[j])-97]-=1\n                    ptr+=1\n                    j+=1\n                else:\n                    j+=1\n            if(ptr==len(t)):\n                temp2=1\n\n            if(temp1==1 and temp2==1):\n                flag='YES'\n                break\n    if(len(t)>105 and (t[:106]=='deabbaaeaceeadfafecfddcabcaabcbfeecfcceaecbaedebbffdcacbadafeeeaededcadeafdccadadeccdadefcbcdabcbeebbbbfae' or t[:106]=='dfbcaefcfcdecffeddaebfbacdefcbafdebdcdaebaecfdadcacfeddcfddaffdacfcfcfdaefcfaeadefededdeffdffcabeafeecabab')):\n        flag='NO'\n    print(flag)\n", "complexity": "cubic", "problem": "1303_E", "from": "CODEFORCES", "tags": "dp,strings"}
{"src": "from sys import stdin\ninput=stdin.readline\n\ndef count(n):\n\n    value=0\n    while(n):\n        n &= (n-1)\n        value+=1\n\n    return value\n\ndef nc2(n):\n    return (n*(n - 1))//2\n\ndef answer():\n\n    dp=[0]*(1 << n) #fishes\n\n    #let 1 be alive fishes\n    #let 0 be dead fishes\n\n    dp[(1 << n) - 1]=1 #initially let all be alive\n\n\n    for mask in range((1 << n) - 1,0,-1):\n\n        m=count(mask) # count alive fishes\n        if(m==1):continue\n\n        #probability of selecting 2 alive fishes\n        p=1/(nc2(m))\n       \n        #pairing 2 fishes\n        for i in range(n):\n            for j in range(n):\n                if(i==j):continue\n                #check if i , j fishes are alive or not\n\n                if((mask >> i & 1) and (mask >> j & 1)):\n                    #let fish i eat j\n                    next_mask=mask ^ (1 << j)\n                    dp[next_mask]+=(dp[mask]*p*a[i][j])\n\n    for i in range(n):\n        #fish i is alive\n        print(dp[1 << i],end=' ')\n    \nn=int(input())\na=[list(map(float,input().split())) for i in range(n)]\n\nanswer()\nprint()\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import os\nimport heapq\nimport sys\nimport math\nimport operator\nfrom collections import defaultdict\nfrom io import BytesIO, IOBase\n\n\n\"\"\"def gcd(a,b):\n    if b==0:\n        return a\n    else:\n        return gcd(b,a%b)\"\"\"\n\n\"\"\"def pw(a,b):\n    result=1\n    while(b>0):\n        if(b%2==1): result*=a\n        a*=a\n        b//=2\n    return result\"\"\"\n\ndef inpt():\n    return [int(k) for k in input().split()]\n\ndef main():\n    n1, n2, n3 = map(int, input().split())\n    ar = [int(x) for x in input().split()]\n    br = [int(x) for x in input().split()]\n    cr = [int(x) for x in input().split()]\n    ar.sort()\n    br.sort()\n    cr.sort()\n    dp = [[[0 for x in range(201)] for y in range(201)] for z in range(201)]\n    for i in range(n1 + 1):\n        for j in range(n2 + 1):\n            for k in range(n3 + 1):\n                if (i and j):\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + (ar[i - 1] * br[j - 1]))\n                if (i and k):\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + (ar[i - 1] * cr[k - 1]))\n                if (k and j):\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + (cr[k - 1] * br[j - 1]))\n    print(dp[n1][n2][n3])\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()\n\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import sys\n\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nrn,gn,bn=MI()\nrr=LI()\ngg=LI()\nbb=LI()\nrr.sort(reverse=True)\ngg.sort(reverse=True)\nbb.sort(reverse=True)\ndp=[[[-1]*(bn+1) for _ in range(gn+1)] for _ in range(rn+1)]\ndp[0][0][0]=0\nans=0\nfor i in range(rn+1):\n    for j in range(gn+1):\n        for k in range(bn+1):\n            pre=dp[i][j][k]\n            if pre==-1:continue\n            ans=max(ans,pre)\n            if i<rn and j<gn:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],pre+rr[i]*gg[j])\n            if i<rn and k<bn:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],pre+rr[i]*bb[k])\n            if j<gn and k<bn:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],pre+gg[j]*bb[k])\n\nprint(ans)\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n, l, r, x = map(int, input().split())\ntasks = list(map(int, input().split()))\nmask = 3\nans = 0\n\nwhile (mask < (1 << n)):\n    sum_dif = 0\n    min_diff = float(\"inf\")\n    max_diff = -float(\"inf\")\n\n    if (mask & (mask-1)):\n        for i in range(n):\n            if (mask & (1 << i)):\n                sum_dif += tasks[i]\n                min_diff = min(min_diff, tasks[i])\n                max_diff = max(max_diff, tasks[i])\n        if (x <= (max_diff - min_diff)) and (l <= sum_dif <= r):\n            ans += 1\n\n    mask += 1\n\nprint(ans)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import sys\n\n \ndef find_pair(candidate,data,m):\n    ans = (-1,-1)\n    binary_bit = [False for i in range(1 << m)]\n    for i in data:\n        bit_tmp = 0\n        for j in range(len(i)):\n            if i[j] >= candidate: bit_tmp |= 1 << j\n        binary_bit[bit_tmp] = True\n    \n    for i in range(1 << m):\n        for j in range(1 << m):\n            if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]:\n                ans = i , j\n                break\n    return ans\n \ndef backtracking(candidate,ans,data):\n    idx_i = -1 ; idx_j = -1\n    for i in range(len(data)):\n        bit_tmp = 0\n        for j in range(len(data[i])):\n            if data[i][j] >= candidate: bit_tmp |= 1 << j\n        if bit_tmp == ans[0]: idx_i = i\n        if bit_tmp == ans[1]: idx_j = i\n \n    print(str(idx_i + 1) + \" \" + str(idx_j + 1))\n \ndef main():\n    n , m = [int(i) for i in input().split()]\n    data = [[int(i) for i in input().split()] for i in range(n)]\n    a = 0 ; b = 10**9 + 7\n    ans = (-1,-1)\n    candidate = -1\n    while a <= b:\n        mid = (a + b)//2\n        bin_ans = find_pair(mid,data,m)\n        if bin_ans[0] != -1 and bin_ans[1] != -1:\n            ans = bin_ans\n            candidate = mid\n            a = mid + 1\n        else:\n            b = mid - 1\n    backtracking(candidate,ans,data)\n \nmain()", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "#---------------------------iye ha aam zindegi---------------------------------------------\nimport math\nimport heapq,bisect\nimport sys\nfrom collections import deque,defaultdict\nfrom fractions import Fraction\nmod=10**9+7\nmod1=998244353\n# ------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree1:\n    def __init__(self, data, default=9999999, func=lambda a, b: min(a , b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n#-------------------------------iye ha chutiya zindegi-------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n#--------------------------------------iye ha combinations ka zindegi---------------------------------\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n // 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n#--------------------------------------iye ha power ka zindegi---------------------------------\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n#--------------------------------------------------product----------------------------------------\ndef product(l):\n    por=1\n    for i in range(len(l)):\n        por*=l[i]\n    return por\n#--------------------------------------------------binary----------------------------------------\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) / 2)\n\n        # Check if middle element is\n        # less than or equal to key\n        if (arr[mid] <= key):\n\n            # At least (mid + 1) elements are there\n            # whose values are less than\n            # or equal to key\n            count = mid + 1\n            left = mid + 1\n\n        # If key is smaller, ignore right half\n        else:\n            right = mid - 1\n\n    return count\n#--------------------------------------------------binary----------------------------------------\ndef countdig(n):\n    c=0\n    while(n>0):\n        n//=10\n        c+=1\n    return c\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    # Stores the index of the left most element\n    # from the array which is greater than k\n    leftGreater = n\n\n    # Finds number of elements greater than k\n    while (l <= r):\n        m = int(l + (r - l) / 2)\n\n        # If mid element is greater than\n        # k update leftGreater and r\n        if (arr[m] > k):\n            leftGreater = m\n            r = m - 1\n\n        # If mid element is less than\n        # or equal to k update l\n        else:\n            l = m + 1\n\n    # Return the count of elements\n    # greater than k\n    return (n - leftGreater)\n#--------------------------------------------------binary------------------------------------\ndef findmin(h,n):\n    n.sort()\n    h=int(h)\n    ans='-1'\n    #print(h,n)\n    for i in n:\n        if int(i)>h:\n            break\n        ans=i\n    #print(ans)\n    return ans\nn=list(input())\nn1=list(input())\nif len(n)<len(n1):\n    n.sort(reverse=True)\n    print(*n,sep='')\n    sys.exit()\nn.sort()\nans=\"\"\nf=0\nfor i in range(len(n)):\n    t=i-1\n    c=0\n    r = findmin(n1[i], n)\n    if r=='-1':\n        while(r=='-1'):\n            n.append(ans[-c-1])\n            r=findmin(int(n1[t])-1,n)\n            t-=1\n            c+=1\n        ans=ans[:len(ans)-c]\n        ans+=r\n        n.remove(r)\n        f=1\n        break\n    n.remove(r)\n    if r==n1[i]:\n        ans+=r\n        continue\n    else:\n        ans+=r\n        f=1\n        break\nif f==1:\n    n.sort(reverse=True)\n    for i in n:\n        ans+=i\nprint(ans)", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "def main():\n    n = int(input())\n    arr = []\n    \n    for i in range(n):\n        arr.append(input())\n        \n    arr = sorted(arr, key=lambda x : len(x))\n    \n    for i in range(n-1):\n        if arr[i] not in arr[i+1]:\n            print('NO')\n            return;\n    \n    print('YES')\n    for pal in arr:\n        print(pal)\n\nmain()\n\t \t\t \t\t\t    \t   \t\t\t\t\t\t\t \t\t \t\t \t", "complexity": "nlogn", "problem": "0988_B", "from": "CODEFORCES", "tags": "sortings,strings"}
{"src": "\nfrom bisect import *\nfrom collections import *\nfrom math import gcd,ceil,sqrt,floor,inf\nfrom heapq import *\nfrom itertools import *\nfrom operator import add,mul,sub,xor,truediv,floordiv\nfrom functools import *\n\n#------------------------------------------------------------------------\nimport os\nimport sys\n\nfrom io import BytesIO, IOBase\n# region fastio\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n\n#------------------------------------------------------------------------\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\n#------------------------------------------------------------------------\n\n\nfrom types import GeneratorType\n \n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n \n    return wrappedfunc\n\nmod=10**9+7\nfarr=[1]\nifa=[]\n \ndef fact(x,mod=0):\n    if mod:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr)%mod)\n    else:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr))\n    return farr[x]\n \ndef ifact(x,mod):\n    global ifa\n    fact(x,mod)\n    ifa.append(pow(farr[-1],mod-2,mod))\n    for i in range(x,0,-1):\n        ifa.append(ifa[-1]*i%mod)\n    ifa.reverse()\n \ndef per(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return fact(i)//fact(i-j)\n    return farr[i]*ifa[i-j]%mod\n    \ndef com(i,j,mod=0):\n    if i<j: return 0\n    if not mod:        \n        return per(i,j)//fact(j)\n    return per(i,j,mod)*ifa[j]%mod\n \ndef catalan(n):\n    return com(2*n,n)//(n+1)\n \ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef floorsum(a,b,c,n):#sum((a*i+b)//c for i in range(n+1))\n    if a==0:return b//c*(n+1)\n    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2\n    m=(a*n+b)//c\n    return n*m-floorsum(c,c-b-1,a,m-1)\n\ndef inverse(a,m):\n    a%=m\n    if a<=1: return a\n    return ((1-inverse(m,a)*m)//a)%m\n \ndef lowbit(n):\n    return n&-n\n \nclass BIT:\n    def __init__(self,arr):\n        self.arr=arr\n        self.n=len(arr)-1\n        \n    def update(self,x,v):\n        while x<=self.n:\n            self.arr[x]+=v\n            x+=x&-x\n \n    def query(self,x):\n        ans=0\n        while x:\n            ans+=self.arr[x]\n            x&=x-1\n        return ans\n'''\nclass SMT:\n    def __init__(self,arr):\n        self.n=len(arr)-1#arr\u5305\u542b\u4e00\u4e2a\u524d\u5bfc0\n        self.arr=[0]*(self.n<<2)\n        self.lazy=[0]*(self.n<<2)\n        def Build(l,r,rt):\n            if l==r:\n                self.arr[rt]=arr[l]\n                return\n            m=(l+r)>>1\n            Build(l,m,rt<<1)\n            Build(m+1,r,rt<<1|1)\n            self.pushup(rt)\n        Build(1,self.n,1)\n \n    def pushup(self,rt):\n        self.arr[rt]=self.arr[rt<<1]+self.arr[rt<<1|1]\n \n    def pushdown(self,rt,ln,rn):#lr,rn\u8868\u533a\u95f4\u6570\u5b57\u6570\n        if self.lazy[rt]:\n            self.lazy[rt<<1]+=self.lazy[rt]\n            self.lazy[rt<<1|1]+=self.lazy[rt]\n            self.arr[rt<<1]+=self.lazy[rt]*ln\n            self.arr[rt<<1|1]+=self.lazy[rt]*rn\n            self.lazy[rt]=0\n            \n    def update(self,L,R,c,l=1,r=None,rt=1):#L,R\u8868\u793a\u64cd\u4f5c\u533a\u95f4\n        if r==None: r=self.n\n        if L<=l and r<=R:\n            self.arr[rt]+=c*(r-l+1)\n            self.lazy[rt]+=c\n            return\n        m=(l+r)>>1\n        self.pushdown(rt,m-l+1,r-m)\n        if L<=m: self.update(L,R,c,l,m,rt<<1)\n        if R>m: self.update(L,R,c,m+1,r,rt<<1|1)\n        self.pushup(rt)\n \n    def query(self,L,R,l=1,r=None,rt=1):\n        if r==None: r=self.n\n        #print(L,R,l,r,rt)\n        if L<=l and R>=r:\n            return self.arr[rt]\n        m=(l+r)>>1\n        self.pushdown(rt,m-l+1,r-m)\n        ans=0\n        if L<=m: ans+=self.query(L,R,l,m,rt<<1)\n        if R>m: ans+=self.query(L,R,m+1,r,rt<<1|1)\n        return ans\n'''       \nclass DSU:#\u5bb9\u91cf+\u8def\u5f84\u538b\u7f29\n    def __init__(self,n):\n        self.c=[-1]*n\n \n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n \n    def find(self,x):\n        if self.c[x]<0:\n            return x\n        self.c[x]=self.find(self.c[x])\n        return self.c[x]\n \n    def union(self,u,v):\n        u,v=self.find(u),self.find(v)\n        if u==v:\n            return False\n        if self.c[u]>self.c[v]:\n            u,v=v,u\n        self.c[u]+=self.c[v]\n        self.c[v]=u\n        return True\n \n    def size(self,x): return -self.c[self.find(x)]\n    \nclass UFS:#\u79e9+\u8def\u5f84\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n \n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n \ndef Prime(n):\n    c=0\n    prime=[]\n    flag=[0]*(n+1)\n    \n    for i in range(2,n+1):\n        if not flag[i]:\n            prime.append(i)\n            c+=1\n        for j in range(c):\n            if i*prime[j]>n: break\n            flag[i*prime[j]]=prime[j]\n            if i%prime[j]==0: break\n    return prime\n \ndef dij(s,graph):\n    d={}\n    d[s]=0\n    heap=[(0,s)]\n    seen=set()\n    while heap:\n        dis,u=heappop(heap)\n        if u in seen:\n            continue\n        seen.add(u)\n        for v,w in graph[u]:\n            if v not in d or d[v]>d[u]+w:\n                d[v]=d[u]+w\n                heappush(heap,(d[v],v))\n    return d\n \ndef GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]\ndef lcm(a,b): return a*b//gcd(a,b)\ndef lis(nums):\n    res=[]\n    for k in nums:\n        i=bisect.bisect_left(res,k)\n        if i==len(res):\n            res.append(k)\n        else:\n            res[i]=k\n    return len(res)\n \nclass DLN:\n    def __init__(self,val):\n        self.val=val\n        self.pre=None\n        self.next=None\n\ndef nb(i,j):\n    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:\n        if 0<=ni<n and 0<=nj<m:\n            yield ni,nj\n\ndef topo(n):\n    q=deque()\n    res=[]\n    for i in range(n):\n        if ind[i]==0:\n            q.append(i)\n            res.append(i+1)\n    while q:\n        u=q.popleft()\n        for v in g[u]:\n            ind[v]-=1\n            if ind[v]==0:\n                q.append(v)\n                res.append(v+1)\n    return res\n\n@bootstrap\ndef gdfs(r,p):\n    if len(g[r])==1 and p!=-1:\n        yield None\n    for ch in g[r]:\n        if ch!=p:\n            yield gdfs(ch,r)\n    yield None\n\n\ndef match(pat,cur):\n    for i in range(k):\n        if pat[i]!='_' and pat[i]!=cur[i]:\n            #print(pat[i],cur[i])\n            return False\n    return True\n\ndef pos(cur):\n    res=list(cur)\n    #print(cur,res)\n    pa=[]\n    dfs(0,pa,res)\n    return pa\n\ndef dfs(i,pa,res):\n    #print(i,pa,res)\n    global k\n    if i==k:\n        #print(res)\n        pa.append(''.join(res))\n        return \n    dfs(i+1,pa,res)\n    #print(i,res,pa)\n    tmp=res[i]\n    res[i]='_'\n    dfs(i+1,pa,res)\n    res[i]=tmp\n    \n\n\nt=1\nfor i in range(t):\n    n,m,k=RLL()\n    p=[]\n    d={}\n    for i in range(n):\n        cur=input()\n        p.append(cur)\n        d[cur]=i\n    res=[]\n    ans=True\n    ind=[0]*n\n    #print(d)\n    g=[[] for i in range(n)]\n    for i in range(m):\n        cur,x=input().split()\n        x=int(x)\n        if ans:\n            #print(cur,x,p[x-1])\n            if not match(p[x-1],cur):\n                ans=False\n            else:\n                #print(cur)\n                for al in pos(cur):\n                    if al in d and d[al]!=x-1:\n                        g[x-1].append(d[al])\n                        ind[d[al]]+=1\n    if not ans:\n        print(\"NO\")\n    else:\n        #print(g,ind)\n        ans=topo(n)\n        if len(ans)!=n:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            print(*ans)\n    #print(*ans)\n            \n    \n                    \n                    \n        \n\n''' \nsys.setrecursionlimit(200000)\nimport threading\nthreading.stack_size(10**8)\nt=threading.Thr\nead(target=main)\nt.start()\nt.join()\n'''\n\n''' \nsys.setrecursionlimit(200000)\nimport threading\nthreading.stack_size(10**8)\nt=threading.Thread(target=main)\nt.start()\nt.join()\n'''\n", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "# Fast IO Region\nimport os\nimport sys\nfrom io import BytesIO ,IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# Get out of main functoin\ndef main():\n    pass\n# decimal to binary\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n# binary to decimal\ndef decimal(s):\n    return (int(s, 2))\n# power of a number base 2\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return (p)\n# if  number is prime in \u221an time\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n# list to string ,no spaces\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n# String to list\ndef stl(s):\n    # for each character in string to list with no spaces -->\n    l = list(s)\n    # for space in string  -->\n    # l=list(s.split(\" \"))\n    return l\n# Returns list of numbers with a particular sum\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if (s == target):\n        return arr\n    if (s >= target):\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if (ans):\n            return ans\n# Sieve for prime numbers in a range\ndef SieveOfEratosthenes(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n            # print(p)\n    return (cnt)\n# for positive integerse only\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n# 1000000007\nmod = int(1e9) + 7\ndef ssinp(): return input()\n# s=input()\ndef iinp(): return int(input())\n# n=int(input())\ndef nninp(): return map(int ,input().split())\n# a,b,c=map(int,input().split())\ndef llinp(): return list(map(int ,input().split()))\n# a=list(map(int,input().split()))\ndef p(xyz): print(xyz)\ndef p2(a ,b): print(a ,b)\nimport math\n\n# import random\n# sys.setrecursionlimit(300000)\n# from fractions import Fraction\nfrom collections import OrderedDict\n# from collections import deque\n########################                         mat=[[0 for i in range(n)] for j in range(m)]                      ########################\n########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################\n########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################\n########################                         from collections import deque                              ########################\n########################                         ASCII of A-Z= 65-90                                        ########################\n########################                         ASCII of a-z= 97-122                                       ########################\n########################                         d1.setdefault(key, []).append(value)                       ########################\nimport operator\n#for __ in range(iinp()):\nn,m=nninp()\nif(n>m):\n    print(0)\n    exit()\na=llinp()\nd={}\nfor c in a:\n    if(c in d):\n        d[c]+=1\n    else:\n        d[c]=1\ndict1=dict(sorted(d.items(),key=operator.itemgetter(1)))\nans=0\nfor i in range(1,105):\n    temp=dict1.copy()\n    n1=n\n    for c in temp:\n        n1=n1-(temp[c]//i)\n    if(n1>0):\n        print(i-1)\n        exit()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "nlogn", "problem": "1011_B", "from": "CODEFORCES", "tags": "binary search,brute force,implementation"}
{"src": "\nn = int(input())\n\n\np = []\nfor i in range(n):\n    la = list(map(float,input().split()))\n    p.append(la)\n\nfull_bit =  (1<<n) - 1\ndp = [0]*(full_bit) + [1]\n\nfor i in range(full_bit,0,-1):\n\n    cunt = bin(i)[2:].count('1')\n    # print(cunt)\n    if cunt == 1 or dp[i] == 0:\n        continue\n\n    mul = 1/((cunt*(cunt-1))>>1)\n\n    for x in range(n):\n        if (i & (1<<x)) == 0:\n            continue\n        for y in range(x+1,n):\n            if (i & (1<<y)) == 0:\n                continue\n\n            dp[i-(1<<y)]+=dp[i]*p[x][y]*mul\n            dp[i-(1<<x)]+=dp[i]*p[y][x]*mul\n\nans = []\nfor i in range(n):\n    ans.append(dp[1<<i])\n\nprint(*ans)\n\n\n\n\n\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "import random\n\nn = int(input())\nv = []\na = []\nfor i in range(n):\n    a.append(i)\n\nfor _ in range(0, n):\n    x, y = map(int, input().split())\n    v.append([x, y, x*x+y*y])\n\nwhile 1>0:\n    x = 0\n    y = 0\n    ans = [0]*n\n    random.shuffle(a)\n    for i in range(n):\n        if (x+v[a[i]][0])**2+(y+v[a[i]][1])**2 <= (x-v[a[i]][0])**2+(y-v[a[i]][1])**2:\n            x += v[a[i]][0]\n            y += v[a[i]][1]\n            ans[a[i]] = 1\n        else:\n            x -= v[a[i]][0]\n            y -= v[a[i]][1]\n            ans[a[i]] = -1\n    if x*x+y*y <= 1500000**2:\n        print(*ans)\n        break\n\n", "complexity": "nlogn", "problem": "0995_C", "from": "CODEFORCES", "tags": "brute force,data structures,geometry,greedy,math,sortings"}
{"src": "'''Author- Akshit Monga'''\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nimport sys\ninput = stdin.readline\ndef gen(temp,i):\n    global s,k,outs\n    if i==k:\n        j=''\n        for o in range(k):\n            if temp[o]==1:\n                j+=s[o]\n            else:\n                j+='_'\n        outs.add(j)\n        return\n    temp[i]=1\n    gen(temp,i+1)\n    temp[i]=-1\n    gen(temp,i+1)\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def isCyclicUtil(self, v, visited, recStack):\n        visited[v] = True\n        recStack[v] = True\n        for neighbour in self.graph[v]:\n            if visited[neighbour] == False:\n                if self.isCyclicUtil(neighbour, visited, recStack) == True:\n                    return True\n            elif recStack[neighbour] == True:\n                return True\n        recStack[v] = False\n        return False\n\n    def isCyclic(self):\n        visited = [False] * self.V\n        recStack = [False] * self.V\n        for node in range(self.V):\n            if visited[node] == False:\n                if self.isCyclicUtil(node, visited, recStack) == True:\n                    return True\n        return False\n    def topologicalSortUtil(self, v, visited, stack):\n        visited[v] = True\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.topologicalSortUtil(i, visited, stack)\n        stack.append(v)\n\n    def topologicalSort(self):\n        visited = [False] * self.V\n        stack = []\n        for i in range(self.V):\n            if visited[i] == False:\n                self.topologicalSortUtil(i, visited, stack)\n        stack=stack[::-1]\n        print(\"yes\")\n        for i in stack:\n            stdout.write(str(i+1)+\" \")\n\n\nn,m,k=map(int,input().split())\npatterns={}\nall=[]\nfor i in range(n):\n    s=input()[:-1]\n    patterns[s]=i\n    all.append(s)\nstrs=[]\ndg=Graph(n)\nfor i in range(m):\n    s,mt=input().split()\n    mt=int(mt)-1\n    outs=set()\n    temp=[0 for o in range(k)]\n    gen(temp,0)\n    if all[mt] not in outs:\n        print(\"no\")\n        sys.exit()\n    for i in outs:\n        if i!=all[mt] and i in patterns:\n            dg.addEdge(mt,patterns[i])\nif dg.isCyclic():\n    print(\"no\")\nelse:\n    dg.topologicalSort()\n", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "#Tuan_Kkura\nn = int(input())\na = list(map(int, input().split()))\n\ndp = [[505]*n for _ in range(n)]\nMax = [[0]*n for _ in range(n)]\n\nfor i in range(n):  \n    dp[i][i] = 1\n    Max[i][i] = a[i]\n\nfor len in range(1, n+1):\n    for i in range(n-len+1):\n        j = i + len - 1\n        for k in range(i, j):\n            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:\n                dp[i][j] = 1\n                Max[i][j] = Max[i][k] + 1\nprint(dp[0][n-1])", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "fre =[0,0,0,0,0,0,0,0,0,0,0]\na=input();b=input()\nc=False\ndef DFS(aa,bb):\n  if int(aa)==len(a):\n    print(bb)\n    exit()\n  global c\n  for i in range(9,-1,-1):\n    if (fre[i]>0 and i<=int(b[int(aa)])) or (fre[i]>0 and c):\n      fre[i]-=1\n      if i<int(b[int(aa)]):\n        c=True\n      DFS(aa+1,bb*10+i)\n      fre[i]+=1\n      c=False\n      \n\n\nif len(b)>len(a):\n  x=sorted(a);\n  \n  print(*x[::-1],sep='')\nelse:\n  for i in a:\n    fre[int(i)]+=1\n  DFS(0,0)\n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "for _ in range(int(input())):\n    N, M = map(int, input().split())\n    X = [[int(a) for a in input().split()] for _ in range(N)]\n    Y = [[X[i][j] for i in range(N)] for j in range(M)]\n    ma = 0\n    dp = [[0] * (1<<N) for _ in range(M+1)]\n    for j in range(M):\n        for mask in range(1<<N):\n            maskpre = mask\n            while maskpre >= 0:\n                maskpre &= mask\n                ma = 0\n                for k in range(N):\n                    s = 0\n                    for i in range(N):\n                        if (maskpre >> i) & 1 == 0 and (mask >> i) & 1:\n                            s += X[i-k][j]\n                    ma = max(ma, s)\n                dp[j+1][mask] = max(dp[j+1][mask], dp[j][maskpre] + ma)\n                \n                maskpre -= 1\n    print(dp[-1][-1])", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "from sys import stdin\n\nn, m = map(int, stdin.readline().split())\nans, p, all = [], [1 << i for i in range(n - 2, -1, -1)] + [1], set(range(1, n + 1))\nnum, cur, i = 1, 0, 0\n\nwhile i < len(p) and m > 0 and num <= n:\n    cur += p[i]\n    if cur >= m:\n        m -= (cur - p[i])\n        cur = 0\n        ans.append(num)\n        all.discard(num)\n    num += 1\n    i += 1\n\nprint(' '.join(map(str, ans + sorted(all)[::-1])))\n", "complexity": "np", "problem": "0513_B2", "from": "CODEFORCES", "tags": "bitmasks,divide and conquer,math"}
{"src": "'''\ns = input()\nfor i in range(len(s)):\n\n    for k in range(i + 1, len(s)+1, 1):\n        print(s[i:k])\n'''\n'''\ns = input()\nsLen = len(s)\nfor startInd in range(sLen):\n    for endInd in range(startInd + 1, sLen + 1):\n        print(s[startInd, endInd])\n\n'''\ns = input()\nslen = len(s)\nans = 0\nfor st1 in range(slen - 1):\n    for end1 in range(st1 + 1, slen):\n        end2 = end1 + 1\n        sub1 = s[st1:end1]\n        for st2 in range(st1 + 1, slen):\n            if end2 > slen:\n                break\n\n            sub2 = s[st2:end2]\n            subLen = len(sub1)\n            if sub1 == sub2 and ans < subLen:\n                ans = subLen\n            end2 += 1\n\nprint(ans)\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "def main():\n    mod=1000000007\n    # mod=998244353\n    # nCr =  make_nCr_mod()\n    \n    tc=1\n    for _ in range(tc):\n        a=list(rs())\n        b=list(rs())\n        \n        if len(a)<len(b):\n            ws(''.join(sorted(a)[::-1]))\n        else:\n            a=sorted(a)\n            ans=[]\n            sa=SortedList(a)\n            for i in range(len(a)-1):\n                for j in range(len(sa)-1,-1,-1):\n                    temp=ans+[sa[j]]\n                    sa.discard(sa[j])\n                    for k in sa:\n                        temp.append(k)\n                    \n                    if temp<=b:\n                        ans.append(temp[i])\n                        break\n                    else:\n                        sa.add(temp[i])\n            ans.append(sa[-1])\n            ws(\"\".join(ans))\n            \n            \n            \n            \n                      \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n            \ndef rant():\n    # RANT BEGINS-\n    # \n    # Did you look at the constraints dummy? Read problem again carefully understand it correctly\n    # Are base cases correct n=0,n=1,n=N or string is all 0 or all 1?\n    # Take hints from time limits maybe n=1000 and m=100000 so if n^2 doesnt work n*m might work?? \n    # Upto 10^8 works under 2 sec\n    # \n    # 1.Greedy? What matters what doesnt? Is my claim correct? \n    #   Does my implementation correctly implements the greedy i thought of? \n    #   Dictionary? keep a count of values if constraint on something is low(like only alphabets(26) count)? \n    # \n    # 2.DP? Think about state's ranges maybe one of the states have lesser possible values than it may look like? \n    #   Obviously think about order of evaluation\n    # \n    # 3.Binary Search?(Monotonic? any one directed order in which we have to perform something?)\n    # \n    # 4.Graph?DSU?Edge property or Vertex property Read carefully? Bipartitenes Property??? Cycle Property??? \n    #   Hidden but dependency ordering of values(in 1d array or 2d Table/Array) is that of a graph???\n    # \n    # 5.Number Theory?(GCD subtraction?)\n    # \n    # 6.Bruteforce?(Redundant part of N which may not give answer?Constraints?)\n    # \n    # 7.Range Queries?\n    # \n    # 8.Any Equivalency?(We have A and B and have to do \n    #   something between them maybe difficult if there was A~C and C~B then A~B\n    #   C could be max or min or some other thing)\n    # \n    # 9.Reverse Engineering?(From Answer to quesn or last step to first step)\n    #\n    # 10.Constructive? Mod? Bruteforce for smaller case and analyze patterns?\n    #\n    # 11.String? Constructive Greedy example- \n    #   Bracket sequence make first part unknown open and second part unknown closed \n    #   Remember always only n//2 open and n//2 closed brackets are there\n    #\n    # 12.Combinatorics?--> (n to i-1 index ways) * (ith index ways) * Ways (for i-1 till 0 index)?\n    #\n    # 13.Look for patterns and dependency of the patterns(maybe only first row or column matters to construct other rows and columns)\n    #   for smaller cases maybe make bruteforce solution and analyze the patterns\n    # \n    # RANT ENDS\n    return \"AAAAAAAAAAAAAAAAARRRGHHHHHHHHHHHHHHHHHHHHHHHH\"\n    \ndef SieveOfEratosthenes(limit):\n    \"\"\"Returns all primes not greater than limit.\"\"\"\n    isPrime = [True]*(limit+1)\n    isPrime[0] = isPrime[1] = False\n    primes = []\n    for i in range(2, limit+1):\n        if not isPrime[i]:continue\n        primes += [i]\n        for j in range(i*i, limit+1, i):\n            isPrime[j] = False\n    return primes\n\ndef memodict(f):\n    \"\"\"memoization decorator for a function taking a single argument\"\"\"\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n\n    return memodict().__getitem__\n\ndef pollard_rho(n):\n    \"\"\"returns a random factor of n\"\"\"\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n\n    s = ((n - 1) & (1 - n)).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = (p * p) % n\n            if p == 1:\n                return math.gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                x, y = i, (i * i + 1) % n\n                f = math.gcd(abs(x - y), n)\n                while f == 1:\n                    x, y = (x * x + 1) % n, (y * y + 1) % n\n                    y = (y * y + 1) % n\n                    f = math.gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n\n@memodict\ndef prime_factors(n):\n    \"\"\"returns a Counter of the prime factorization of n\"\"\"\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n\ndef distinct_factors(n):\n    \"\"\"returns a list of all distinct factors of n\"\"\"\n    factors = [1]\n    for p, exp in prime_factors(n).items():\n        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]\n    return factors\n\ndef all_factors(n):\n    \"\"\"returns a sorted list of all distinct factors of n\"\"\"\n    small, large = [], []\n    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):\n        if not n % i:\n            small.append(i)\n            large.append(n // i)\n    if small[-1] == large[-1]:\n        large.pop()\n    large.reverse()\n    small.extend(large)\n    return small\n\ndef make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):\n    max_n = min(max_n, mod - 1)\n\n    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)\n    fact[0] = 1\n    for i in range(max_n):\n        fact[i + 1] = fact[i] * (i + 1) % mod\n\n    inv_fact[-1] = pow(fact[-1], mod - 2, mod)\n    for i in reversed(range(max_n)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def nCr_mod(n, r):\n        res = 1\n        while n or r:\n            a, b = n % mod, r % mod\n            if a < b:\n                return 0\n            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n            n //= mod\n            r //= mod\n        return res\n\n    return nCr_mod\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = [*range(n+1)]\n        self.size = [1]*(n+1)\n        self.min, self.max = [*range(n+1)], [*range(n+1)]\n        self.count = n\n\n    def get(self, a):\n        \"\"\"Returns the identifier (parent) of the set to which a belongs to!\"\"\"\n        if self.parent[a] == a:\n            return a\n        x = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while x != self.parent[x]:\n            self.parent[x], x = a, self.parent[x]\n        return a\n\n    def union(self, a, b):\n        \"\"\"Join two sets that contain a and b!\"\"\"\n        a, b = self.get(a), self.get(b)\n        if a != b:\n            if self.size[a] > self.size[b]:\n                a, b = b, a\n            self.parent[a] = b\n            self.size[b] += self.size[a]\n            self.min[b] = min(self.min[a], self.min[b])\n            self.max[b] = max(self.max[a], self.max[b])\n            self.count -= 1\n\n    def count_sets(self):\n        \"\"\"Returns the number of disjoint sets!\"\"\"\n        return self.count\n    \nclass SegmentTree:\n    \n    \n    \n    def __init__(self, data, default=0, func=max):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop]\"\"\"\n        stop+=1\n        start += self._size\n        stop += self._size\n\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nclass SparseTable:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)]\"\"\"\n        depth = (stop + 1 - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop + 1 - (1 << depth)])\n\n    def __getitem__(self, idx):\n        return self._data[0][idx]\n              \nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n \n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n \n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n \n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n \n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n \n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n \n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n \n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n \n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n \n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n \n        _lists = self._lists\n        _mins = self._mins\n \n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n \n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n \n        return pos, idx\n \n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n \n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n \n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n \n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n \n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n \n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n \n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n \n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n \n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n \n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n \n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n \n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n \n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n \n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n \n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\nimport sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom math import log2\nfrom bisect import bisect_left,bisect_right\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n# sys.setrecursionlimit(111111) \nINF=999999999999999999999999\nalphabets=\"abcdefghijklmnopqrstuvwxyz\"\n\nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    main()\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    ", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "import sys\n\ninput = sys.stdin.readline\n\nr, g, b = map(int, input().split())\nsticks, dp, ans = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)], [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 # dp[i][j][k] is i largest red, j largest green, k largest blue\n\nfor i in range(r + 1):\n    for j in range(g + 1):\n        for k in range(b + 1):\n            ans = max(ans, dp[i][j][k])\n            if i < r and j < g:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])\n            if i < r and k < b:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])\n            if j < g and k < b:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])\nprint(ans)\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "a , b , c , d , e , f = map(int,input().split())\nn , n1 = 1 , a * b + c * d + e * f\nwhile n ** 2 < n1 :\n    n += 1\nif n ** 2 > n1 :\n    print(-1)\n    exit()\nl = sorted([[max(a,b),min(a,b),'A'], [max(c,d),min(c,d),'B'], [max(e,f),min(e,f),'C']])\nif l[2][0] != n:\n    print(-1)\n    exit()\nv = str(n) + '\\n' + (l[2][2] * n + '\\n') * l[2][1]\nif l[0][0] == n and l[1][0] == n:\n    for i in range(2):\n        v += (l[i][2] * n + '\\n') * l[i][1]\nelse:\n    s = n - l[2][1]\n    if s not in l[0] or s not in l[1] :\n        print(-1)\n        exit()\n    x , y = l[0][1] if s == l[0][0] else l[0][0] , l[1][1] if s == l[1][0] else l[1][0]\n    v += (l[0][2] * x + l[1][2] * y + '\\n') * s\nprint(v)", "complexity": "np", "problem": "0581_D", "from": "CODEFORCES", "tags": "bitmasks,brute force,constructive algorithms,geometry,implementation,math"}
{"src": "#!/usr/bin/env python3\n\nn, k, A = map(int, input().rstrip().split())\nsenators = []\nmx_bribe = 0\n\nfor i in range(n):\n    lvl, loy = map(int, input().rstrip().split())\n    senators.append((lvl, loy))\n    mx_bribe += (100 - loy) // 10\n\nbribe = [0] * n\n\n\ndef calc(votes):\n    bsum, cnt, p = 0, 0, 1.0\n    for i, s in enumerate(senators):\n        if votes & (1 << i):\n            p *= (s[1] + bribe[i]) / 100\n            cnt += 1\n        else:\n            p *= (100 - s[1] - bribe[i]) / 100\n            bsum += s[0]\n\n    if cnt > (n / 2):\n        return p\n    else:\n        return p * A / (A + bsum)\n\n\ndef dfs(cur, rk):\n    if cur >= n:\n        if rk > 0:\n            return 0.0\n        sm = 0.0\n        for i in range(1 << n):\n            sm += calc(i)\n\n        return sm\n\n    mx = 0.0\n    for i in range(rk + 1):\n        if i * 10 + senators[cur][1] > 100:\n            break\n        bribe[cur] = i * 10\n        tmp = dfs(cur+1, rk-i)\n        mx = max(tmp, mx)\n    return mx\n\n\nprint(dfs(0, min(k, mx_bribe)))\n", "complexity": "np", "problem": "0105_B", "from": "CODEFORCES", "tags": "brute force,probabilities"}
{"src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n,m,k=map(int,input().split())\n    left=[list(map(int,input().split())) for _ in range(n)]\n    down=[list(map(int,input().split())) for _ in range(n-1)]\n    dp=[[(-1 if k&1 else 0) for _ in range(m)] for _ in range(n)]\n    if k&1==0:\n        for l in range(k//2):\n            dp1=[[10**8 for _ in range(m)] for _ in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    if j>0:\n                        dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1])\n                    if j<m-1:\n                        dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j])\n                    if i>0:\n                        dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j])\n                    if i<n-1:\n                        dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j])\n            dp=dp1\n    for i in dp:\n        print(*i)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import itertools\n\nn, l, r, x = [int(x) for x in input().split()]\nc = [int(x) for x in input().split()]\n\ncounter = 0\nfor i, val in enumerate([\"\".join(seq) for seq in itertools.product(\"01\", repeat=n)]):\n    if val.count('1') < 2:\n        continue\n    dif = 0; mx = float(\"-inf\"); mn = float(\"inf\")\n    for i, bit in enumerate(val):\n        if bit == '1':\n            dif += c[i]\n            mx = max(c[i], mx)\n            mn = min(c[i], mn)\n    if l <= dif <= r and  mx - mn >= x:\n        counter += 1\n\nprint(counter)\n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "# http://codeforces.com/problemset/problem/23/A\nleng = 0\ns = input()\nfor i in range(len(s)):\n    for j in range(i + 1, len(s) + 1):\n        sub = s[i:j]\n        if s.count(sub) >= 2 and len(sub) > leng:\n            leng = len(sub)\n        elif s.count(sub) == 1:\n            for k in range(1, len(sub)):\n                if s[i - k:j - k] == sub and len(sub) > leng:\n                    leng = len(sub)\nprint(leng)\n\n", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "S = input()\nbest = 0\nfor i in range(len(S)):\n    for j in range(i+1, len(S)+1):\n        s = S[i:j]\n        c = 0\n        for k in range(len(S)):\n            if S[k:].startswith(s): c += 1\n        # print(s, c)\n        if c >= 2: \n            best = max(best, len(s))\nprint(best)", "complexity": "cubic", "problem": "0023_A", "from": "CODEFORCES", "tags": "brute force,greedy"}
{"src": "from collections import defaultdict\n\n\ndef main():\n    R, G, B = map(int, input().split())\n    red = list(map(int, input().split()))\n    green = list(map(int, input().split()))\n    blue = list(map(int, input().split()))\n    red.sort(reverse=True)\n    green.sort(reverse=True)\n    blue.sort(reverse=True)\n    dp = [[[-2*10**9]*(B+10) for i in range(G+10)] for j in range(R+10)]\n    dp[0][0][0] = 0\n    ans = 0\n    for i in range(R+1):\n        for j in range(G+1):\n            for k in range(B+1):\n                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+red[i-1]*green[j-1], dp[i]\n                                  [j-1][k-1]+green[j-1]*blue[k-1], dp[i-1][j][k-1]+red[i-1]*blue[k-1])\n                ans = max(ans, dp[i][j][k])\n    print(ans)\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import sys, os\n \nnumbs = [int(x) for x in sys.stdin.buffer.read().split()]\nn = numbs.pop(0)\n \nbase = []\nout = []\n \nfor i in range(n):\n    x = numbs[i]\n    how = 0\n    \n    for b,rep in base:\n        if x.bit_length() == b.bit_length():\n            x ^= b\n            how ^= rep\n    \n    if x:\n        how |= 1 << i\n \n        a = 0\n        b = len(base)\n        while a < b:\n            c = a + b >> 1\n            if base[c][0] > x:\n                a = c + 1\n            else:\n                b = c\n        base.insert(a, (x, how))\n    \n        out.append(0)\n    else:\n        outind = len(out)\n        out.append(-1)\n        \n        y = bin(how).encode('ascii')\n        ylen = len(y)\n        for i in range(2,len(y)):\n            if y[i] == 49:\n                out.append(ylen - 1 - i)\n        out[outind] = len(out) - 1 - outind\n \nos.write(1, b'\\n'.join(str(x).encode('ascii') for x in out))", "complexity": "np", "problem": "0504_D", "from": "CODEFORCES", "tags": "bitmasks"}
{"src": "from collections import deque\nfrom collections import OrderedDict\nimport math\n \nimport sys\nimport os\nimport threading\nimport bisect\n \nimport operator\n \nimport heapq\n \n \nfrom atexit import register\nfrom io import BytesIO\n \n#sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n#sys.stdout = BytesIO()\n#register(lambda: os.write(1, sys.stdout.getvalue()))\n \n \nimport io\n#input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n#sys.stdin = open(\"F:\\PY\\\\test.txt\", \"r\")\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#input = sys.stdin.readline\n\n#a = [int(x) for x in input().split()]\n\n\n\n\nr,g,b = map(int, input().split())\na = []\nfor i in range(3):\n    a.append([int(x) for x in input().split()])\n    a[i].sort(reverse=True)\n\ndp = [[[0 for i in range(205)] for j in range(205)] for k in range(205)]\nanswer = 0\n\nfor i in range(r+1):\n    for j in range(g+1):\n        for k in range(b+1):\n            if i<r and j<g:\n                dp[i+1][j+1][k]=max(dp[i+1][j+1][k], dp[i][j][k]+a[0][i]*a[1][j])\n            if i<r and k<b:\n                dp[i+1][j][k+1]=max(dp[i+1][j][k+1], dp[i][j][k]+a[0][i]*a[2][k])\n            if j<g and k<b:\n                dp[i][j+1][k+1]=max(dp[i][j+1][k+1], dp[i][j][k]+a[1][j]*a[2][k])\n            answer=max(answer, dp[i][j][k])\nprint(answer)\n    \n\n\n\nsys.exit(0)\n\n\n\n\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\np1 = Person(\"heelo\", 27)\n\nprint(help(Person))\n\n\nage = 26\nname = 'Swaroop'\nprint('\u0412\u043e\u0437\u0440\u0430\u0441 {} -- {} \u043b\u0435\u0442'.format(name, age))\nprint(help(object))\n\n\n'''\nfor _ in range(int(input())):\n    \n    n = int(input())\n    ar = list(map(int, input().split()))\n    dp = [0]*100005\n    for i in range(n):\n        dp[ar[i]]+=1\n    ar.clear()\n    for i in range(len(dp)):\n        if dp[i]!=0:\n            ar.append(dp[i])       \n    ar.sort()\n    maxC = ar[len(ar)-1]\n    sumA = sum(ar)\n    answer=0\n    for i in range(len(ar)):\n        if ar[i]==maxC:\n            answer+=1\n            sumA-=maxC\n    answer-=1\n    answer+= min(sumA//(maxC-1), len(ar)-1)\n    print(answer)\n    #sys.exit(0)   \n         \n    \n\n\n\n\ndef maxDisjointIntervals(list_):\n    list_.sort(key=lambda x: x[1])\n    print(list_[0][0], list_[0][1])\n    r1 = list_[0][1]\n    for i in range(1, len(list_)):\n        l1 = list_[i][0]\n        r2 = list_[i][1]\n        if l1>r1:\n            print(l1, r2)\n            r1 = r2\n\nif __name__ ==\"__main__1\":\n    N=4\n    intervals = [[1, 4], [2, 3], [4,6], [8,9]]\n    maxDisjointIntervals(intervals)\n    \n    '''\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import math\na=input()\nb=input()\nx=a.count('+')-b.count('+')\ny=a.count('-')-b.count('-')\nc=a.count('+')-a.count('-')\nd=b.count('+')-b.count('-')\ne=c-d\nf=b.count('?')\nif x==0 and y==0:\n    print(1)\nelif f==0 and (x!=0 or y!=0):\n    print(0)\nelif x!=0 and y==0:\n    print(1/2**f)\nelif y!=0 and x==0:\n    print(1/2**f)\nelif abs(e)>f:\n    print(0)\nelse:\n    print(math.factorial(f)/(math.factorial(y)*math.factorial(x)*2**f))", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "# O(n*2^n) (however quite a few states are not visited)\n# most important optimization is not transitioning from unvisited states\n#   (only ~ 1% of states are visited) (transition is O(n))\n# other optimizations are using floats, bitwise operators, and precomputing dists/ reducing ops\nxs,ys = map(float,input().split())\n\nn = int(input())\n\ndist = [[0]*(n+1) for i in range(n+1)]\ndist2 = [[0]*(n) for i in range(n)]\n\nobjects = [list(map(float,input().split())) for i in range(n)] + [[xs,ys]] # objects[n] is handbag\n\nfor i in range(n+1):\n    for j in range(n+1):\n        dist[i][j] = (objects[i][0] - objects[j][0])**2 + (objects[i][1] - objects[j][1])**2\n\nfor i in range(n):\n    for j in range(n):\n        dist2[i][j] = dist[n][i] + dist[i][j] + dist[j][n]\n\ndp = [1e6]*(1<<n)\nvis = set([0]) #alot of states are not visited after optimization\ndp[0] = 0\n\nfor i in range((1<<n)-1):\n    if i in vis:\n        # reduce O(n^2) transition to O(n) via assuming 1 of the objects taken must be the\n        # first object not yet taken in order\n        for j in range(n):\n            if i&(1<<j) == 0:\n                # get 1 new object\n                newi = i + (1 << j)\n                dp[newi] = min(dp[newi], dp[i] + 2*dist[n][j])\n                vis.add(newi)\n\n                for k in range(j+1,n):\n                    # get 2 new objects at a time\n                    if i&(1<<k) == 0:\n                        newi |= 1<<k\n                        dp[newi] = min(dp[newi], dp[i] + dist2[j][k])\n                        vis.add(newi)\n                        newi ^= 1<<k\n\n                break\n\ncurr = (1<<n) - 1\npath = [0]\nwhile curr:\n    for i in range(n):\n        if curr & (1<<i):\n            # 1 object taken\n            if dp[curr] == dp[curr - (1<<i)] + 2*dist[n][i]:\n                path.extend([i+1,0])\n                curr ^= (1<<i)\n\n            # 2 objects taken\n            for j in range(i+1,n):\n                if curr & (1<<j):\n                    if dp[curr] == dp[curr - (1<<i) - (1<<j)] + dist2[i][j]:\n                        path.extend([j+1,i+1,0])\n                        curr ^= (1<<i) + (1<<j)\n\nprint(int(dp[(1<<n)-1]))\nprint(*path[::-1])", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import sys\ninput = sys.stdin.readline\ndef main():\n    n,m,k = map(int,input().split())\n    if k%2==1:\n        for i in range(n):\n            for j in  range(m):\n                print(-1,end=\" \")\n            print()\n        return 0\n    kk=k\n    maps= [[[0 for i in range(4)] for j in range(m)] for ii in range(n)]\n    #0\u8868\u793a\u6a2a\u5411\u53f3\uff0c1\u8868\u793a\u6a2a\u5411\u5de6\uff0c2\u8868\u793a\u7eb5\u5411\u4e0b,3\u8868\u793a\u7eb5\u5411\u4e0a\uff0c\n    dp=[[[1e9 for i in range(k//2+1)] for j in range(m)] for ii in range(n)]\n    for i in range(n):\n            for j in range(m):\n                dp[i][j][0]=0\n    for i in range(n):\n        s=list(map(int,input().split()))\n        for j in range(m-1):\n            maps[i][j][0]=s[j]\n            maps[i][j+1][1]=s[j]\n    for i in range(n-1):\n        s=list(map(int,input().split()))\n        for j in range(m):\n            maps[i][j][2]=s[j]\n            maps[i+1][j][3]=s[j]\n    for k in range(1,kk//2+1):\n        for i in range(n):\n            for j in range(m):\n                if j<m-1:\n                    dp[i][j+1][k]=min(dp[i][j+1][k],dp[i][j][k-1]+maps[i][j][0])\n                if i<n-1:\n                    dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k-1]+maps[i][j][2])\n                if i>0:\n                    dp[i-1][j][k]=min(dp[i-1][j][k],dp[i][j][k-1]+maps[i][j][3])\n                if j>0:\n                    dp[i][j-1][k]=min(dp[i][j-1][k],dp[i][j][k-1]+maps[i][j][1])\n    for i in range(n):\n        for j in range(m):\n            print(dp[i][j][k]*2,end=\" \")\n        print()\nmain()\n\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "fact=[1]\ntemp=1\nMOD=10**9+7\nfor i in range(1,10**5+5):\n    temp*=i\n    temp%=MOD\n    fact+=[temp]\ndef bino(a,b):\n    up=fact[a]\n    down=pow(fact[b]*fact[a-b],MOD-2,MOD)\n    return (up*down)%MOD\n\n\ndef find(A):\n    MOD=10**9+7\n    \n    \n    dp=[0]*(10**5+2)\n    for x in A:\n        dp[x]+=1\n    for i in range(2,len(dp)):\n        for j in range(2,len(dp)):\n            if i*j>len(dp)-1:\n                break\n            dp[i]+=dp[i*j]\n    for i in range(2,len(dp)):\n        dp[i]=(pow(2,dp[i],MOD)-1)%MOD\n    \n    for i in range(len(dp)-1,1,-1):\n        for j in range(2,len(dp)):\n            if i*j>=len(dp):\n                break\n            dp[i]-=dp[i*j]\n            dp[i]%=MOD\n    \n    ans=0\n    for i in range(2,len(dp)):\n        ans+=dp[i]\n        ans%=MOD\n    \n    return (pow(2,len(A),MOD)-ans-1)%MOD\ninput()\nprint(find(list(map(int,input().strip().split(' ')))))                \n    \n    ", "complexity": "np", "problem": "0803_F", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,number theory"}
{"src": "import sys\nimport math\nfrom collections import defaultdict,deque\nimport heapq\nn,k=map(int,sys.stdin.readline().split())\n\nmod=998244353\ndp=[[0,0,0,0] for x in range(k+3)]\ndp[1][0]=1\ndp[1][1]=1\ndp[2][2]=1\ndp[2][3]=1\nnewdp=[[0,0,0,0] for x in range(k+3)]\nfor i in range(n-1):\n    \n    for j in range(k+1):\n        newdp[j+1][1]+=dp[j][0]\n        newdp[j+1][3]+=dp[j][0]\n        newdp[j+1][2]+=dp[j][0]\n        newdp[j][0]+=dp[j][0]\n        newdp[j][1]+=dp[j][1]\n        newdp[j+1][3]+=dp[j][1]\n        newdp[j+1][2]+=dp[j][1]\n        newdp[j+1][0]+=dp[j][1]\n        newdp[j][1]+=dp[j][2]\n        newdp[j+2][3]+=dp[j][2]\n        newdp[j][2]+=dp[j][2]\n        newdp[j][0]+=dp[j][2]\n        newdp[j][1]+=dp[j][3]\n        newdp[j][3]+=dp[j][3]\n        newdp[j+2][2]+=dp[j][3]\n        newdp[j][0]+=dp[j][3]\n        '''dp[i+1][j][0]+=dp[i][j][0]\n        dp[i+1][j][1]+=dp[i][j][1]\n        dp[i+1][j][2]+=dp[i][j][2]\n        dp[i+1][j][3]+=dp[i][j][3]\n        dp[i+1][j+1][0]+=dp[i][j][2]+dp[i][j][3]\n        dp[i+1][j+1][1]+=dp[i][j][2]+dp[i][j][3]\n        dp[i+1][j+1][2]+=dp[i][j][0]+dp[i][j][1]\n        dp[i+1][j+1][3]+=dp[i][j][0]+dp[i][j][1]\n        dp[i+1][j+2][2]+=dp[i][j][3]\n        dp[i+1][j+2][3]+=dp[i][j][2]'''\n        for a in range(3):\n            for b in range(4):\n                newdp[a+j][b]%=mod\n    for a in range(k+3):\n        for b in range(4):\n            dp[a][b]=newdp[a][b]\n            newdp[a][b]=0\n#print(dp,'dp')\n'''for i in range(n):\n    print(dp[i])'''\n#ans=0\n#print(dp,'dp')\nans=sum(dp[k])\nans%=mod\nprint(ans)\n                \n            \n            \n                              \n", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import sys\ninput=sys.stdin.readline\n\n#t=int(input())\nt=1\nfor i in range(t):\n    #n=int(input())\n    n,m,k = map(int,input().split())\n    b=[]\n    horizontal_edges=[]\n    vertical_edges=[]\n    for i in range(n):\n        temp=[int(x) for x in input().split()]\n        horizontal_edges.append(temp)\n    for i in range(n-1):\n        temp=[int(x) for x in input().split()]\n        vertical_edges.append(temp)\n\n    if k%2==1:\n        for i in range(n):\n            for j in range(m):\n                print(-1,end=' ')\n            print()\n        continue\n\n    dp=[[[10**9 for x in range(k+1)] for x in range(m)] for x in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            dp[i][j][0]=0\n\n    for z in range(2,k+1,2):\n        for i in range(n):\n            for j in range(m):\n                    if i>0:\n                        if i<n-1:\n                            dp[i][j][z]=min(dp[i-1][j][z-2]+2*vertical_edges[i-1][j],dp[i+1][j][z-2]+2*vertical_edges[i][j])\n                        else:\n                            dp[i][j][z]=dp[i-1][j][z-2]+2*vertical_edges[i-1][j]\n                    else:\n                        dp[i][j][z]=dp[i+1][j][z-2]+2*vertical_edges[i][j]\n                    if j>0:\n                        if j<m-1:\n                            dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1],dp[i][j+1][z-2]+2*horizontal_edges[i][j])\n                        else:\n                            dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1])\n                    else:\n                        dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-2]+2*horizontal_edges[i][j])\n\n    for i in range(n):\n            for j in range(m):\n                print(dp[i][j][k],end=' ')\n            print()", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "# coding:utf-8\n# @Author: \u5c06\u7acb\n\nn, m, K = map(int, input().split())\nwh = [[0]*m for i in range(n)]\nwv = [[0]*m for i in range(n)]\n\nfor i in range(n):\n    t = list(map(int, input().split()))\n    for j in range(m-1):\n        wh[i][j] = t[j]\n\nfor i in range(n-1):\n    t = list(map(int, input().split()))\n    for j in range(m):\n        wv[i][j] = t[j]\n\n\nf = [[[int(1e8)]* 11 for j in range(m)] for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        f[i][j][0] = 0\n\nfor k in range(1, K//2+1):\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                f[i][j][k] = min(f[i][j][k], f[i-1][j][k-1]+wv[i-1][j])\n            if j < m-1:\n                f[i][j][k] = min(f[i][j][k], f[i][j+1][k-1]+wh[i][j])\n            if i < n-1:\n                f[i][j][k] = min(f[i][j][k], f[i+1][j][k-1]+wv[i][j])\n            if j > 0:\n                f[i][j][k] = min(f[i][j][k], f[i][j-1][k-1]+wh[i][j-1])\n\nfor i in range(n):\n    for j in range(m):\n        if K%2 == 1:\n            print(-1)\n        else:\n            dp = [int(1e8)]*(K//2+1)\n            dp[0] = 0\n            for k in range(1, K//2+1):\n                for l in range(0, k):\n                    dp[k] = min(dp[k], dp[l]+f[i][j][k-l]*2)\n\n            print(dp[K//2])\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "def isValidSet(problemSet: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> bool:\n    if len(problemSet) >= 2:\n        total = sum(problemSet)\n        myDelta = max(problemSet) - min(problemSet)\n        if minTotalDif <= total <= maxTotalDif and myDelta >= minDelta:\n            return True\n    return False\n\ndef countValidSubsets(problems: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> int:\n    \n    def subsetBuilder (problems: list, currentSubset: list, nextElementIndex: int) -> None:\n        if isValidSet(currentSubset, minTotalDif, maxTotalDif, minDelta):\n            validSubsets.append(currentSubset)\n        for i in range(nextElementIndex, len(problems)):\n            currentSubset.append(problems[i])\n            subsetBuilder(problems, currentSubset, i+1)\n            currentSubset.pop(-1)\n    \n    index = 0\n    currentSubset = []\n    validSubsets = []\n\n    subsetBuilder(problems, currentSubset, index)\n    return len(validSubsets)\n\nn, l, r, x = input().split()\nn = int(n)\nl = int(l)\nr = int(r)\nx = int(x)\n\nprobs = [int(prob) for prob in input().split()]\n\nprint(countValidSubsets(probs, l, r, x))\n\n\n\t\t  \t\t \t \t\t\t \t  \t  \t \t \t\t \t \t", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import sys\nfrom array import array  # noqa: F401\nimport typing as Tp  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\ndef output(*args):\n    sys.stdout.buffer.write(\n        ('\\n'.join(map(str, args)) + '\\n').encode('utf-8')\n    )\n\n\ndef main():\n    R, G, B = map(int, input().split())\n    r_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]\n    g_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]\n    b_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]\n\n    dp = [[[0.0] * (B + 2) for _ in range(G + 2)] for _ in range(R + 2)]\n\n    for ri in range(R + 1):\n        for gi in range(G + 1):\n            for bi in range(B + 1):\n                dp[ri + 1][gi + 1][bi] = max(dp[ri + 1][gi + 1][bi], dp[ri][gi][bi] + r_sticks[ri] * g_sticks[gi])\n                dp[ri + 1][gi][bi + 1] = max(dp[ri + 1][gi][bi + 1], dp[ri][gi][bi] + r_sticks[ri] * b_sticks[bi])\n                dp[ri][gi + 1][bi + 1] = max(dp[ri][gi + 1][bi + 1], dp[ri][gi][bi] + g_sticks[gi] * b_sticks[bi])\n\n    ans = max(max(max(dp[r][g][b] for b in range(B + 1)) for g in range(G + 1)) for r in range(R + 1))\n    print(int(ans + 1e-6))\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [list(map(int, input().split())) for _ in range(n-1)]\n\nif k % 2 == 1:\n    for i in range(n):\n        print(*[-1]*m)\n    exit()\nk //= 2\n\nINF = 10**18\ndp = [[[INF]*(k+1) for _ in range(m)] for _ in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        dp[i][j][0] = 0\n\nfor v in range(1, k+1):\n    for i in range(n):\n        for j in range(m):\n            now_h, now_w = i, j\n            if i > 0:\n                dp[i][j][v] = min(dp[i-1][j][v-1]+b[i-1][j], dp[i][j][v])\n            if i < n-1:\n                dp[i][j][v] = min(dp[i+1][j][v-1]+b[i][j], dp[i][j][v])\n            if j > 0:\n                dp[i][j][v] = min(dp[i][j-1][v-1]+a[i][j-1], dp[i][j][v])\n            if j < m-1:\n                dp[i][j][v] = min(dp[i][j+1][v-1]+a[i][j], dp[i][j][v])\n\nfor i in range(n):\n    v = []\n    for j in range(m):\n        v.append(dp[i][j][k]*2)\n    print(*v)\n\n# class UnionFind():\n#     def __init__(self, n):\n#         self.n = n\n#         self.parents = [-1] * n\n\n#     def find(self, x):\n#         if self.parents[x] < 0:\n#             return x\n#         else:\n#             self.parents[x] = self.find(self.parents[x])\n#             return self.parents[x]\n\n#     def union(self, x, y):\n#         x = self.find(x)\n#         y = self.find(y)\n\n#         if x == y:\n#             return\n\n#         if self.parents[x] > self.parents[y]:\n#             x, y = y, x\n\n#         self.parents[x] += self.parents[y]\n#         self.parents[y] = x\n\n#     def size(self, x):\n#         return -self.parents[self.find(x)]\n\n#     def same(self, x, y):\n#         return self.find(x) == self.find(y)\n\n#     def members(self, x):\n#         root = self.find(x)\n#         return [i for i in range(self.n) if self.find(i) == root]\n\n#     def roots(self):\n#         return [i for i, x in enumerate(self.parents) if x < 0]\n\n#     def group_count(self):\n#         return len(self.roots())\n\n#     def all_group_members(self):\n#         group_members = defaultdict(list)\n#         for member in range(self.n):\n#             group_members[self.find(member)].append(member)\n#         return group_members\n\n#     def __str__(self):\n#         return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\n\n# q = []\n# heapq.heapify(q)\n# path = [[] for _ in range(n*m)]\n# for i in range(n):\n#     a = list(map(int, input().split()))\n#     for j in range(m - 1):\n#         edge = (a[j], i*m+j, i*m+j+1)\n#         heapq.heappush(q, edge)\n# for i in range(n - 1):\n#     a = list(map(int, input().split()))\n#     for j in range(m):\n#         edge = (a[j], i * m + j, m * (i + 1) + j)\n#         heapq.heappush(q, edge)\n\n# uf = UnionFind(n * m)\n\n# path = [[] for _ in range(n*m)]\n\n# while q:\n#     edge = heapq.heappop(q)\n#     cost, v1, v2 = edge\n#     if uf.same(v1, v2):\n#         continue\n#     else:\n#         uf.union(v1, v2)\n#     path[v1].append((v2, cost))\n#     path[v2].append((v1, cost))\n\n# for i in path:\n#     print(i)\n# # print(path)\n# exit()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "from math import factorial\n\ndef calc_arrangement(n, m):\n    return(factorial(n) / factorial(n - m))\n\ndef calc_combination(n, m):\n    return(calc_arrangement(n, m) / factorial(m))\n\nstr1 = list(input())\nstr2 = list(input())\n\nn = 0\ndiff = 0\n\nfor i in range(len(str1)):\n\tif str1[i] == '+':\n\t\tdiff += 1\n\telse:\n\t\tdiff -= 1\n\tif str2[i] == '+':\n\t\tdiff -= 1\n\telif str2[i] == '-':\n\t\tdiff += 1\n\telse:\n\t\tn += 1\n\nif n == 0:\n\tif diff == 0:\n\t\tprint(1.0)\n\telse:\n\t\tprint(0.0)\nelif n < abs(diff):\n\tprint(0.0)\nelse:\n\tres = calc_combination(n, (n - diff) / 2) * (0.5 ** n)\n\tprint(res)\n", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "from math import factorial\na = input()\nb = input()\nplus, minus, ques = '+', '-', '?'\nops1 = {plus:0, minus:0}\nops2 = {plus:0, minus:0, ques:0}\nfor ai,bi in zip(a,b):\n    ops1[ai] += 1\n    ops2[bi] += 1\nfinal_pos = ops1[plus]-ops1[minus]\ninitial_pos = ops2[plus]-ops2[minus]\ndiff = final_pos-initial_pos\nabs_diff = abs(diff)\nif abs_diff > ops2[ques]:\n    print(0.0)\nelif (ops2[ques]-abs_diff) % 2 != 0:\n    print(0.0)\nelse:\n    total = 2**(ops2[ques])\n    one_type = (ops2[ques]-abs_diff) // 2\n    other_type = abs_diff + one_type\n    numerator = factorial(ops2[ques])/(factorial(one_type)*factorial(other_type))\n    print(numerator/total)", "complexity": "np", "problem": "0476_B", "from": "CODEFORCES", "tags": "bitmasks,brute force,combinatorics,dp,math,probabilities"}
{"src": "def nr(): return nrs()[0]\ndef nrs(): return [int(i) for i in input().split()]\n\nn = 10**7\nsquares = [i * i for i in range(1, 3162)]\n\np = list(range(n + 1))\nfor i in range(1, n + 1):\n\tif p[i] == i:\n\t\tfor sq in squares:\n\t\t\tif i * sq > n: break\n\t\t\tp[i * sq] = i\n\nfor _ in range(nr()):\n\tN, K = nrs()\n\tA = [p[a] for a in nrs()]\n\tdp = [N] * (K + 1)\n\tdp[0] = 1\n\tused = [{}] * (K + 1)\n\tfor a in A:\n\t\tfor j in range(K, -1, -1):\n\t\t\tif dp[j] == N: continue\n\t\t\tif a in used[j]:\n\t\t\t\tif j < K and dp[j + 1] > dp[j]:\n\t\t\t\t\tdp[j + 1] = dp[j]\n\t\t\t\t\tused[j + 1] = used[j]\n\t\t\t\tdp[j] += 1\n\t\t\t\tused[j] = {}\n\t\t\tused[j][a] = 1\n\tprint(min(dp))\n", "complexity": "cubic", "problem": "1497_E2", "from": "CODEFORCES", "tags": "data structures,dp,greedy,math,number theory,two pointers"}
{"src": "def examA():\n    T = I()\n    ans = []\n    for _ in range(T):\n        N, M = LI()\n        if N%M!=0:\n            ans.append(\"NO\")\n        else:\n            ans.append(\"YES\")\n    for v in ans:\n        print(v)\n    return\n\ndef examB():\n    T = I()\n    ans = []\n    for _ in range(T):\n        N = I()\n        A = LI()\n        A.sort()\n        ans.append(A[::-1])\n    for v in ans:\n        print(\" \".join(map(str,v)))\n    return\n\ndef examC():\n    T = I()\n    ans = []\n    for _ in range(T):\n        N, K = LI()\n        A = LI()\n        sumA = sum(A)\n        if sumA==0:\n            ans.append(\"YES\")\n            continue\n        cur = 0\n        L = []\n        for i in range(100):\n            now = K**i\n            L.append(now)\n            cur += now\n            if cur>=sumA:\n                break\n        for i in range(N):\n            A[i] *= (-1)\n        heapify(A)\n        #print(A)\n        for l in L[::-1]:\n            if not A:\n                break\n            a = -heappop(A)\n            if a<l:\n                heappush(A, -a)\n            elif a>l:\n                heappush(A,-(a-l))\n        if not A or heappop(A)==0:\n            ans.append(\"YES\")\n        else:\n            ans.append(\"NO\")\n    for v in ans:\n        print(v)\n    return\n\ndef examD():\n    class combination():\n        # \u7d20\u6570\u306emod\u53d6\u308b\u3068\u304d\u306e\u307f\u3000\u901f\u3044\n        def __init__(self, n, mod):\n            self.n = n\n            self.fac = [1] * (n + 1)\n            self.inv = [1] * (n + 1)\n            for j in range(1, n + 1):\n                self.fac[j] = self.fac[j - 1] * j % mod\n\n            self.inv[n] = pow(self.fac[n], mod - 2, mod)\n            for j in range(n - 1, -1, -1):\n                self.inv[j] = self.inv[j + 1] * (j + 1) % mod\n\n        def comb(self, n, r, mod):\n            if r > n or n < 0 or r < 0:\n                return 0\n            return self.fac[n] * self.inv[n - r] * self.inv[r] % mod\n    N, M = LI()\n    ans = 0\n    if N==2:\n        print(ans)\n        return\n    C = combination(M,mod2)\n    for i in range(N-1,M+1):\n        cur = pow(2,N-3,mod2) * (i-1) * C.comb(i-2,N-3,mod2)\n        #print(cur)\n        ans += cur\n        ans %= mod2\n    print(ans)\n    return\n\ndef examE():\n    N = I()\n    A = LI()\n    dp = [[-1]*(N+1) for _ in range(N+1)]\n    for i in range(N):\n        dp[i][i+1] = A[i]\n    for l in range(2, N + 1):\n        for i in range(N - l + 1):\n            for k in range(i + 1, i + l):\n                if dp[i][k] >= 1 and dp[i][k] == dp[k][i+l]:\n                    dp[i][i + l] = dp[i][k] + 1\n\n    L = [inf]*(N+1)\n    for i in range(1,N+1):\n        if dp[0][i]>=1:\n            L[i] = 1\n    for i in range(N):\n        for k in range(1, N - i + 1):\n            if dp[i][i + k] >= 1:\n                L[i + k] = min(L[i + k], L[i] + 1)\n    #print(dp)\n    #print(L)\n    ans = L[N]\n    print(ans)\n    return\n\"\"\"\n5\n1 1 2 3 4\n\"\"\"\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\nimport sys,copy,bisect,itertools,heapq,math,random\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nif __name__ == '__main__':\n    examE()\n\n\"\"\"\n\n\"\"\"", "complexity": "cubic", "problem": "1312_E", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "def solve(r, g, b, rs, gs, bs):\n    rs.sort(reverse=True)\n    gs.sort(reverse=True)\n    bs.sort(reverse=True)\n    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]\n    sol = 0\n    for ri in range(r+1):\n        for gi in range(g+1):\n            for bi in range(b+1):\n                if ri < r and gi < g:\n                    dp[ri+1][gi+1][bi] = max(dp[ri+1][gi+1][bi], rs[ri]*gs[gi] + dp[ri][gi][bi])\n                if ri < r and bi < b:\n                    dp[ri+1][gi][bi+1] = max(dp[ri+1][gi][bi+1], rs[ri]*bs[bi] + dp[ri][gi][bi])\n                if gi < g and bi < b:\n                    dp[ri][gi+1][bi+1] = max(dp[ri][gi+1][bi+1], gs[gi]*bs[bi] + dp[ri][gi][bi])\n                sol = max(sol, dp[ri][gi][bi])\n    return sol\n\nr, g, b = map(int, input().split())\nrs = list(map(int, input().split()))\ngs = list(map(int, input().split()))\nbs = list(map(int, input().split()))\nprint(solve(r, g, b, rs, gs, bs))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import sys\ninput = sys.stdin.readline\n\nrr, gg, bb = map(int, input().split())\ninf = 114514\nr = list(map(int, input().split())) + [inf]\ng = list(map(int, input().split())) + [inf]\nb = list(map(int, input().split())) + [inf]\nr.sort(reverse = True)\ng.sort(reverse = True)\nb.sort(reverse = True)\ndp = []\nfor _ in range(rr + 1):\n    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])\nans = 0\nfor i in range(rr + 1):\n    ri = r[i]\n    for j in range(gg + 1):\n        gj = g[j]\n        for k in range(bb + 1):\n            bk = b[k]\n            if (i + j + k) % 2:\n                continue\n            dpijk = 0\n            if i > 0 and j > 0:\n                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)\n            if j > 0 and k > 0:\n                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)\n            if k > 0 and i > 0:\n                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)\n            dp[i][j][k] = dpijk\n            if ans < dpijk:\n                ans = dpijk\nprint(ans)", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n = int(input())\nb = []\nbb =[]\nfor i in range(n):\n    x=int(input())\n    idx = 0\n    for j in range(len(b)):\n        nxt = b[j] ^ x\n        if nxt < x :\n            x = nxt\n            idx ^= bb[j]\n    if x == 0:\n        cnt = 0\n        v = []\n        for k in range(2000):\n            if idx & (1 << k) :\n                v.append(k)\n        print(len(v),end=' ')\n        for e in v:\n            print(e,end=' ')\n        print()\n    else :\n        print(0)\n        idx ^= 1 << i\n        b.append(x)\n        bb.append(idx)\n\n        \n    ", "complexity": "np", "problem": "0504_D", "from": "CODEFORCES", "tags": "bitmasks"}
{"src": "s=input()\ns1=input()\nl=[]\nl1=[]\nfor x in s :\n    l.append(int(x))\nfor x in s1 :\n    l1.append(int(x))\nd={}\nfor x in l :\n    d[x]=d.get(x,0)+1\nf=False\nif len(s1)>len(s) :\n    l=sorted(l)\n    l=l[::-1]\n    print(\"\".join(map(str,l)))\n    exit()\nans=[0]*len(s)\n\nki=0\ni=0\nwhile(i<len(l1)) :\n    f=True\n    for j in range(max(l1[i],ki),-1,-1) :\n        if d.get(j,-1)>0 :\n            ans[i]=j\n            d[j]-=1\n            f=False\n            if j!=l1[i] :\n                \n                ki=9\n            break\n    \n    if f :\n        \n        \n        \n        for i1 in range(i-1,-1,-1) :\n            f1=False\n            for j in range(max(l1[i1],ki)-1,-1,-1) :\n                if d.get(j,-1)>0 :\n                    d[ans[i1]]+=1\n                    ans[i1]=j\n                    d[j]-=1\n                    f1=True\n                    i=i1\n                    ki=9\n                    break\n            if f1 :\n                break\n            else :\n                d[ans[i1]]+=1\n                ans[i1]=0\n    i+=1\n                \n       \n            \n            \n        \n        \n            \n\n    \n\n    \nprint(\"\".join(map(str,ans)))\n\n            \n            \n                \n            \n            \n", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "R,G,B=map(int,input().split())\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split())) \nr.sort(reverse=True) \ng.sort(reverse=True) \nb.sort(reverse=True) \n#print(r,g,b)\ndp=[[[-1 for i in range(205)] for j in range(205)] for k in range(205)]\ndef recurser(x,y,z):\n    if (x>=R and y>=G) or (y>=G and z>=B) or (z>=B and x>=R):\n        return 0 \n    if dp[x][y][z]!=-1:\n        return dp[x][y][z] \n    maxi=0 \n    if x<R and y<G:\n        maxi=max(maxi,r[x]*g[y]+recurser(x+1,y+1,z)) \n    if y<G and z<B:\n        maxi=max(maxi,g[y]*b[z]+recurser(x,y+1,z+1)) \n    if z<B and x<R:\n        maxi=max(maxi,r[x]*b[z]+recurser(x+1,y,z+1))\n    dp[x][y][z]=maxi\n    return maxi \nprint(recurser(0,0,0)) ", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "from random import randint\nfor _ in range(int(input())):\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n    ans = 0\n    for _ in range(100):\n        for j in range(m):\n            x = randint(0, n - 1)\n            if x:\n                B = []\n                for i in range(n):\n                    B.append(A[i][j])\n                B = B[x:] + B[:x]\n                for i in range(n):\n                    A[i][j] = B[i]\n        c = 0\n        for i in range(n):\n            c += max(A[i])\n        ans = max(ans, c)\n    print(ans)", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "#tests = int(input())\n#for t in range(tests):\n#    b= int(input())\n#    ls = [int(x) for x in input()]\n\nr,g,b = list(map(int, input().split()))\nls_r = sorted(list(map(int, input().split())))\nls_g = sorted(list(map(int, input().split())))\nls_b = sorted(list(map(int, input().split())))\n\n\ndp = [[[-1 for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]\n\ndef recursive(idx_r, idx_g, idx_b):\n    if dp[idx_r][idx_g][idx_b] != -1:\n        return dp[idx_r][idx_g][idx_b]\n    res_1 = 0\n    res_2 = 0\n    res_3 = 0\n    if (idx_r-1) >= 0 and (idx_g-1) >= 0:\n        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]\n    if (idx_g-1) >= 0 and (idx_b-1) >= 0:\n        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]\n    if (idx_r-1) >= 0 and (idx_b-1) >= 0:\n        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]\n    \n    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)\n    return dp[idx_r][idx_g][idx_b]\n\nprint(recursive(r,g,b))", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for i in range(n)]\n    ans = []\n    le = 0\n    ri = int(1e9)\n\n    def check(mid: int) -> bool:\n        nonlocal ans\n        dic = {}\n        for i in range(n):\n            bit = 0\n            for j in range(m):\n                if a[i][j] >= mid:\n                    bit += 1\n                bit <<= 1\n            dic[bit >> 1] = i\n        for x, idx in dic.items():\n            for y, idy in dic.items():\n                if x | y == 2**m-1:\n                    ans = idx + 1, idy + 1\n                    return True\n        return False\n    while le <= ri:\n        mid = (le + ri) >> 1\n        if check(mid):\n            le = mid + 1\n        else:\n            ri = mid - 1\n    print(ans[0], ans[1])\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "a=input()\nb=input()\nna=len(a)\nnb=len(b)\ndef fs(a,b):\n\ttry:\n\t\tfor i in range(a+1,len(b)):\n\t\t\tif b[a]>b[i]:\n\t\t\t\tans=b[i]\n\t\t\t\tk=b.copy()\n\t\t\t\tk.pop(i)\n\t\t\t\tans+=\"\".join(k)\n\t\t\t\treturn ans\n\t\treturn False\n\texcept:\n\t\treturn False\nif(na<nb):\n\tprint(\"\".join(sorted(list(a),reverse=True)))\nelse:\n\tif(a==b):\n\t\tprint(a)\n\t\t\n\telse:\n\t\tl=sorted(list(a),reverse=True)\n\t\tl2=l.copy()\n\t\tans1=\"\"\n\t\tflag=0\n\t\tans=[]\n\t\tfor i in b:\n\t\t\tfor j in range(len(l)):\n\t\t\t\tif i==l[j]:\n\t\t\t\t\tk=fs(j,l)\n\t\t\t\t\tif(k!=False):\n\t\t\t\t\t\tans.append(ans1+fs(j,l))\n\t\t\t\t\tans1+=l[j]\n\t\t\t\t\tl.pop(j)\n\t\t\t\t\tbreak\n\t\t\t\tif i>l[j]:\n\t\t\t\t\tans1+=l[j]\n\t\t\t\t\tl.pop(j)\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\n\t\t\tif(flag==1):\n\t\t\t\tbreak\n\t\tans1+=\"\".join(l)\n\t\tif(int(ans1)<=int(b)):\n\t\t\tprint(ans1)\n\t\telse:\n\t\t\tfor i in sorted([int(i) for i in ans],reverse=True):\n\t\t\t\tif(i<=int(b)):\n\t\t\t\t\tprint(i)\n\t\t\t\t\tbreak", "complexity": "cubic", "problem": "0915_C", "from": "CODEFORCES", "tags": "dp,greedy"}
{"src": "n=int(input())\nb=[]\nfor i in range(n):\n    b.append(list(map(float,input().split())))\n\nma=1<<n\ndp=[0 for j in range(ma)]\ndp[0]=1\nfor mask in range(1,ma):\n    l=n-bin(mask).count(\"1\")+1\n    res=l*(l-1)//2\n    for i in range(n):\n        if mask&(1<<i):\n            for j in range(n):\n                if not mask&(1<<j):\n\n                    dp[mask]+=((dp[mask^(1<<i)]*b[j][i])/res)\n\n\nans=[]\nfor i in range(n):\n    ans.append(dp[ma-1-(1<<i)])\nprint(*ans)\n\n", "complexity": "np", "problem": "0016_E", "from": "CODEFORCES", "tags": "bitmasks,dp,probabilities"}
{"src": "from itertools import combinations\nn , l , r ,x = map(int,input().split())\na = list(map(int, input().split()))\nc = 0\nfor i in range(1,n+1):\n    for j in combinations(a,i):\n        if (l<=sum(j)<=r and max(j)-min(j)>=x):\n            c+=1\nprint(c)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "# from typing import List, Set, Dict, Tuple, Text, Optional\nfrom collections import deque\nfrom types import GeneratorType\nimport os\nimport sys\nimport math\nimport heapq\nfrom atexit import register\nfrom io import BytesIO\nimport __pypy__  # type: ignore\n\n#########\n# INPUT #\n#########\n\n\nclass Input(object):\n  def __init__(self):\n    if 'CPH' not in os.environ:\n      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n      sys.stdout = BytesIO()\n      register(lambda: os.write(1, sys.stdout.getvalue()))\n\n  def rawInput(self):\n    # type: () -> str\n    return sys.stdin.readline().rstrip('\\r\\n')\n\n  def readInt(self):\n    return int(self.rawInput())\n\n##########\n# OUTPUT #\n##########\n\n\nclass Output(object):\n  def __init__(self):\n    self.out = __pypy__.builders.StringBuilder()\n\n  def write(self, text):\n    # type: (str) -> None\n    self.out.append(str(text))\n\n  def writeLine(self, text):\n    # type: (str) -> None\n    self.write(str(text) + '\\n')\n\n  def finalize(self):\n    if sys.version_info[0] < 3:\n      os.write(1, self.out.build())\n    else:\n      os.write(1, self.out.build().encode())\n\n###########\n# LIBRARY #\n###########\n\n\ndef bootstrap(f, stack=[]):\n  # Deep Recursion helper.\n  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst\n  # Usage:\n\n  # @bootstrap\n  # def recur(n):\n  #   if n == 0:\n  #     yield 1\n  #   yield (yield recur(n-1)) * n\n  def wrappedfunc(*args, **kwargs):\n    if stack:\n      return f(*args, **kwargs)\n    else:\n      to = f(*args, **kwargs)\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n            break\n          to = stack[-1].send(to)\n      return to\n\n  return wrappedfunc\n\n\n'''\narrayInit([3, 4, 5], 0):\nInitialize 3-dim array with [3][4][5] with 0 as its initial value\n\nTested with:\nhttps://codeforces.com/contest/625/problem/B\n'''\n\n\nclass MDArray(object):\n  # Faster implementation of md array, using a single array and a lot of math.\n  '''\n  >>> x = MDArray([1, 2, 5], 5)\n  >>> x.get([0, 0, 0])\n  5\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.set([0, 1, 2], 3)\n  3\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.set([0, 1, 3], 1)\n  1\n  >>> x.get([0, 1, 4])\n  5\n  >>> x.get([0, 1, 2])\n  3\n  >>> x.get([0, 1, 3])\n  1\n  '''\n\n  def __init__(self, dimensions, initial_value=0):\n    # type: (Iterable[int], Any) -> None\n    self.dimensions = dimensions\n    dim_total = 1\n    for i in dimensions:\n      dim_total *= i\n    self.arr = [initial_value] * dim_total\n\n  def _index(self, indexes):\n    assert len(indexes) == len(self.dimensions)\n    idx_multi = 1\n    idx = 0\n    for i in range(len(indexes)):\n      assert 0 <= indexes[i] < self.dimensions[i]\n      idx += indexes[i] * idx_multi\n      idx_multi *= self.dimensions[i]\n    return idx\n\n  def get(self, indexes):\n    # type: (Iterable[int]) -> Any\n    return self.arr[self._index(indexes)]\n\n  def set(self, indexes, value):\n    # type: (Iterable[int], Any) -> Any\n    self.arr[self._index(indexes)] = value\n    return value\n\n\n#########\n# LOGIC #\n#########\n\ndef encode(row, col, n, m):\n  return row * m + col\n\n\ndef solve(node, remain, adj, dp):\n  if remain == 0:\n    return 0\n  key = (node, remain)\n  mem = dp.get(key)\n  if mem != -1:\n    return mem\n\n  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))\n  dp.set(key, ans)\n  return ans\n\n\ndef main(inp, out):\n  # type: (Input, Output) -> any\n  n, m, k = map(int, inp.rawInput().split())\n  if k % 2 == 1:\n    for _ in range(n):\n      out.writeLine(' '.join(map(str, [-1] * m)))\n    return\n\n  total_nodes = n*m\n  adj = [[] for _ in range(total_nodes)]\n\n  for i in range(n):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m-1):\n      cur = encode(i, j, n, m)\n      nex = encode(i, j+1, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  for i in range(n-1):\n    weights = map(int, inp.rawInput().split())\n    for j in range(m):\n      cur = encode(i, j, n, m)\n      nex = encode(i+1, j, n, m)\n      adj[cur].append((nex, weights[j]))\n      adj[nex].append((cur, weights[j]))\n\n  dp = MDArray([total_nodes, k+2], -1)\n\n  for i in range(n*m):\n    dp.set((i, 0), 0)\n  for t in range(1, k/2+1):\n    for i in range(n*m):\n      ans = min(map(lambda x: dp.get((x[0], t-1)) + x[1], adj[i]))\n      dp.set((i, t), ans)\n\n  for i in range(n):\n    ans = []\n    for j in range(m):\n      node = encode(i, j, n, m)\n      ans.append(dp.get((node, k/2)) * 2)\n    out.writeLine(' '.join(map(str, ans)))\n\n\n###############\n# BOILERPLATE #\n###############\n\noutput_obj = Output()\nmain(Input(), output_obj)\noutput_obj.finalize()\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "def main():\n    high = 10 ** 12\n    n, m, k = map(int, input().split())\n    hozs = []\n    for i in range(n):\n        hozs.append(list(map(int, input().split())))\n    verts = []\n    for i in range(n - 1):\n        verts.append(list(map(int, input().split())))\n    if k % 2:\n        for i in range(n):\n            print(\"-1 \" * m)\n        return\n    k //= 2\n    dp = []\n    for i in range(n):\n        dp.append([])\n        for j in range(m):\n            dp[-1].append([])\n            for kay in range(k + 1):\n                dp[-1][-1].append(0)\n    for depth in range(1, k + 1):\n        for i in range(n):\n            for j in range(m):\n                if i == 0:\n                    up = high\n                else:\n                    up = verts[i - 1][j] + dp[i - 1][j][depth - 1]\n                if i == n - 1:\n                    down = high\n                else:\n                    down = verts[i][j] + dp[i + 1][j][depth - 1]\n                if j == 0:\n                    left = high\n                else:\n                    left = hozs[i][j - 1] + dp[i][j - 1][depth - 1]\n                if j == m - 1:\n                    right = high\n                else:\n                    right = hozs[i][j] + dp[i][j + 1][depth - 1]\n                min_cost = min(up, down, left, right)\n                ''''\n                if min_cost == up:\n                    dp[i][j][depth] = dp[i - 1][j][depth - 1]\n                elif min_cost == down:\n                    dp[i][j][depth] = dp[i + 1][j][depth - 1]\n                elif min_cost == left:\n                    dp[i][j][depth] = dp[i][j - 1][depth - 1]\n                else:\n                    dp[i][j][depth] = dp[i][j + 1][depth - 1]\n                '''\n                dp[i][j][depth] += min_cost\n    for i in range(n):\n        print(*[2 * dp[i][j][k] for j in range(m)])\nmain()", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import sys, os\n\nif os.environ['USERNAME']=='kissz':\n    inp=open('in.txt','r').readline\n    def debug(*args):\n        print(*args,file=sys.stderr)\nelse:\n    inp=sys.stdin.readline    \n    def debug(*args):\n        pass\n\n# SCRIPT STARTS HERE\n\nn,m,k=map(int,inp().split())\nA=[[*map(int,inp().split())] for _ in range(n)]\nB=[[*map(int,inp().split())] for _ in range(n-1)]\nif k%2==0:\n    O=[[[1e12]*m for _ in range(n)] for _ in range(k//2)]\n    for i in range(n):\n        for j in range(m):\n            if i>0:\n                O[0][i][j]=min(O[0][i][j],B[i-1][j])\n            if i<n-1:\n                O[0][i][j]=min(O[0][i][j],B[i][j])\n            if j>0:\n                O[0][i][j]=min(O[0][i][j],A[i][j-1])\n            if j<m-1:\n                O[0][i][j]=min(O[0][i][j],A[i][j])\n    #for i in range(n):\n    #    debug(*O[0][i])\n    for l in range(1,k//2):\n        for i in range(n):\n            for j in range(m):\n                if i>0:\n                    O[l][i][j]=min(O[l][i][j],B[i-1][j]+O[l-1][i-1][j])\n                if i<n-1:\n                    O[l][i][j]=min(O[l][i][j],B[i][j]+O[l-1][i+1][j])\n                if j>0:\n                    O[l][i][j]=min(O[l][i][j],A[i][j-1]+O[l-1][i][j-1])\n                if j<m-1:\n                    O[l][i][j]=min(O[l][i][j],A[i][j]+O[l-1][i][j+1])         \n                \n        #for i in range(n):\n        #    debug(*O[l][i])\n    for i in range(n):\n        print(*[O[-1][i][j]*2 for j in range(m)])\nelse:\n    for i in range(n):\n        print(*[-1]*m)\n    \n\n", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque \n\n \nn, k = map(int,input().split())\ns = input()\n\n \n \n \ndef judge(needed):\n \n    \n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n \n    effect = [[inf]*(n+1) for j in range(k)]\n \n\n    \n    for j in range(k):\n        accu = 0\n        index = inf\n        for i in range(n)[::-1]:\n            if s[i]==ord('?') or s[i]==97+j:\n                accu += 1\n            else:\n                accu = 0\n\n   \n\n            if accu>=needed:\n                index = i + needed\n            effect[j][i] = index\n            effect[j][i] = effect[j][i+4-4]\n\n\n   \n#    print(effect)                \n             \n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index]) \n\n\n\n        minstate[state] = minimum \n   \n \n#    print(minstate) \n \n \n \n    if minstate[-1]<=n:  return True\n    return False\n \n \nfront = 0\nrear = n//k+1\n \nwhile front < rear:\n    mid = (front+rear)//2\n    flag = judge(mid)\n#    print(mid,flag)\n \n    if flag:  \n        front = mid + 1\n    else:\n        rear = mid \n \nprint(front-1)\n", "complexity": "np", "problem": "1550_E", "from": "CODEFORCES", "tags": "binary search,bitmasks,brute force,dp,strings,two pointers"}
{"src": "from copy import *\nn,T=map(int,raw_input().split())\ncl=set(())\ndi={(0,0,0,T):1}\nfor k in range(n):\n    t,g=map(int,raw_input().split())\n    an=deepcopy(di)\n    for k in an:\n        nc=list(k)\n        nc[3]-=t\n        nc[g-1]+=1\n        if nc[3]>=0:\n            nc=tuple(nc)\n            if nc in di:\n                di[nc] += an[k]\n            else:\n                di[nc] = an[k]\nnd={(1,0,0,0):1,(0,1,0,1):1,(0,0,1,2):1}\nmo=10**9+7\ndef nb(tu):\n    #print(tu)\n    if not(tu in nd):\n        if tu[tu[3]]==0:\n            nd[tu] =0\n        else:\n            nt=list(tu)\n            nt[tu[3]]-=1\n            nt[3]=(nt[3]+1)%3\n            nt2=nt[:]\n            nt2[3]=(nt2[3]+1)%3\n            nd[tu]=(tu[tu[3]]*(nb(tuple(nt))+nb(tuple(nt2))))%mo\n    return nd[tu]\n\n#print([(di[k],k[:3]) for k in di if k[3]==0])\nprint(sum(di[k]*(nb(k[:3]+(1,))+nb(k[:3]+(0,))+nb(k[:3]+(2,))) for k in di if k[3]==0)%mo)\n#print(nd)\n", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "from sys import stdin\n\ndef f(lst, num):\n    new = lst[num:] + lst[:num]\n    return new\n\nt = int(stdin.readline())\nfor i in range(t):\n    row, col = tuple(int(x) for x in stdin.readline().split())\n    lst = list([int(x)] for x in stdin.readline().split())\n    \n    for j in range(row-1):\n        line = tuple(int(x) for x in stdin.readline().split())\n        for k in range(len(line)):\n            lst[k].append(line[k])\n        \n    lst.sort(key=lambda x: max(x), reverse = True)\n\n    ans = float('-inf')\n    for a in range(4):\n        for b in range(4):\n            for c in range(4):\n                for d in range(4):\n                    if col >= 1:\n                        aa = f(lst[0], a)\n                    else:\n                        aa = (0,)*row\n                    if col >= 2:\n                        bb = f(lst[1], b)\n                    else:\n                        bb = (0,)*row\n                    if col >= 3:\n                        cc = f(lst[2], c)\n                    else:\n                        cc = (0,)*row\n                    if col >= 4:\n                        dd = f(lst[3], d)\n                    else:\n                        dd = (0,)*row\n\n                    ans = max(ans,\n                              sum(max(x[j] for x in (aa, bb, cc, dd))\n                                  for j in range(row)))\n    print(ans)\n", "complexity": "np", "problem": "1209_E1", "from": "CODEFORCES", "tags": "bitmasks,brute force,dp,greedy,sortings"}
{"src": "import sys,io,os\ntry:Z=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nexcept:Z=lambda:sys.stdin.readline().encode()\nY=lambda:[*map(int,Z().split())]\nn,m,k=Y();H=[Y()for i in range(n)];V=[Y()for i in range(n-1)]\nif k&1:print('\\n'.join(' '.join(['-1']*m)for i in range(n)));quit()\nd=[0]*n*m\nfor _ in range(k//2):\n    nd=[0]*n*m\n    for x in range(n):\n        for y in range(m):\n            v=x*m+y;w=[]\n            if x:w.append(d[v-m]+V[x-1][y])\n            if y:w.append(d[v-1]+H[x][y-1])\n            if x<n-1:w.append(d[v+m]+V[x][y])\n            if y<m-1:w.append(d[v+1]+H[x][y])\n            nd[v]=min(w)\n    d=nd\nprint('\\n'.join(' '.join(map(lambda x:str(2*x),d[i*m:i*m+m]))for i in range(n)))", "complexity": "cubic", "problem": "1517_D", "from": "CODEFORCES", "tags": "dp,graphs,shortest paths"}
{"src": "n,l,r,d=[int(i) for i in input().split()]\nop=[int(i) for i in input().split()]\nc=0\nfor i in range(2,2**n):\n    s=0\n    k=0\n    maxx=0\n    minn=1000001\n    x=bin(i)[2:]\n    x='0'*(n-len(x))+x\n    for j in range(n):\n        if x[j]=='1':\n            s+=op[j]\n            k+=1\n            if maxx<op[j]:\n                maxx=op[j]\n            if op[j]<minn:\n                minn=op[j]\n    if l<=s<=r and maxx-minn>=d and k>=2:\n        c+=1\nprint(c)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import os\nimport sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    n,m,k = map(int,input().split())\n    a = list(map(float,input().split()))\n    tree = [[0]*n for _ in range(n)]\n    for i in range(k):\n        x,y,z = map(int,input().split())\n        tree[x-1][y-1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1]*2)\n    dp = [[0]*(po[-1]*2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = a[i]\n    for i in range(po[-1]*2):\n        for j in range(n):\n            if i&po[j]:\n                for k in range(n):\n                    if not (i&po[k]):\n                        dp[k][i+po[k]] = max(dp[k][i+po[k]],dp[j][i]+a[k]+tree[j][k])\n    ma = 0\n    for i in range(po[-1]*2):\n        if bin(i)[2:].count(\"1\") == m:\n            for j in range(n):\n                ma = max(ma,dp[j][i])\n    print(int(ma))\n\n# region fastio\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self,file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))\n            self.newlines = b.count(b\"\\n\")+(not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd,self.buffer.getvalue())\n            self.buffer.truncate(0),self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self,file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s:self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda:self.buffer.read().decode(\"ascii\")\n        self.readline = lambda:self.buffer.readline().decode(\"ascii\")\n\nsys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)\ninput = lambda:sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "np", "problem": "0580_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = map(int, input().split())\nmod = 998244353\nd = defaultdict(int)\nfor x in a:\n    d[x] += 1\nd[0] = 0\nb = list(d.items())\nb.sort()\nm = len(b)\nba = [0] * m\ncn = [0] * (m + 1)\nk = h = 0\nfor i, x in enumerate(b):\n    while h < m and x[0] >= b[h][0] * 2:\n        h += 1\n    ba[i] = h - 1\n    while k < m and x[0] * 2 > b[k][0]:\n        k += 1\n    cn[k] += x[1]\nfor i in range(m):\n    cn[i+1] += cn[i]\ndp = [0] * m\ndp[0] = 1\nb = [x[1] for x in b]\nfor i in range(n):\n    ndp = [0] * m\n    for j in range(1, m):\n        if cn[j] >= i - 1:\n            ndp[j] = dp[j] * (cn[j] - i + 1) % mod\n        dp[j] += dp[j-1]\n        if dp[j] >= mod:\n            dp[j] -= mod\n    for j in range(1, m):\n        ndp[j] += dp[ba[j]] * b[j]\n        ndp[j] %= mod\n    dp = ndp\nprint(sum(dp) % mod)", "complexity": "cubic", "problem": "1437_F", "from": "CODEFORCES", "tags": "combinatorics,dp,math,two pointers"}
{"src": "r, g, b = map(int, input().split(' '))\nR = list(map(int, input().split(' ')))\nG = list(map(int, input().split(' ')))\nB = list(map(int, input().split(' ')))\ndp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\nR.insert(0, 0)\nG.insert(0, 0)\nB.insert(0, 0)\ndp[0][0][0], ans = 0, 0\nfor i in range(0, r+1):\n    for j in range(0, g+1):\n        for k in range(0, b+1):\n            if i == 0 and j == 0 and k == 0:continue\n            if i and j and dp[i - 1][j - 1][k] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])\n            if k and j and dp[i][j - 1][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])\n            if i and k and dp[i - 1][j][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])\n            ans = max(ans,dp[i][j][k])\nprint(ans)", "complexity": "cubic", "problem": "1398_D", "from": "CODEFORCES", "tags": "dp,greedy,sortings"}
{"src": "n,k=map(int,input().split())\nsame=[0]*(k+1)\ndiff=[0]*(k+1)\nsame[1]=2\nif k>1:\n    diff[2]=2\nfor i in range(n-1):\n    newsame=[0]*(k+1)\n    newdiff=[0]*(k+1)\n    for i in range(1,k+1):\n        newsame[i]=(same[i]+same[i-1]+2*diff[i])%998244353\n    for i in range(2,k+1):\n        newdiff[i]=(2*same[i-1]+diff[i]+diff[i-2])%998244353\n    same=newsame\n    diff=newdiff\nprint((same[-1]+diff[-1])%998244353)", "complexity": "np", "problem": "1051_D", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------- fast io --------------------\nfrom math import ceil\n\n\ndef prod(a, mod=10 ** 9 + 7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\nfrom math import inf\n\nfor _ in range(int(input()) if not True else 1):\n    #n = int(input())\n    n, m = map(int, input().split())\n    # a, b = map(int, input().split())\n    # c, d = map(int, input().split())\n    # a = list(map(int, input().split()))\n    # b = list(map(int, input().split()))\n    # s = input()\n    a = []\n    for i in range(n):\n        a += [list(map(int, input().split()))]\n    \n    alpha, omega = 0, 10**9\n    def solve(mid):\n        index = [-1] * (1 << m)\n        for i in range(n):\n            val = 0\n            for j in range(m):\n                if a[i][j] >= mid:\n                    val += (1 << j)\n            index[val] = i + 1\n        is_subset = list(index)\n        for i in range(m):\n            for mask in range(1 << m):\n                if mask & (1 << i):\n                    is_subset[mask^(1<<i)] = max(is_subset[mask], is_subset[mask ^ (1 << i)])\n        pos = False\n        for mask in range(1 << m):\n            if index[mask] == -1: continue\n            mask2 = ((1 << m) - 1) ^ mask\n            if is_subset[mask2] != -1:\n                pos = (index[mask], is_subset[mask2])\n                break\n        return pos\n    while alpha < omega:\n        mid = (alpha + omega + 1) // 2\n        if solve(mid):\n            alpha = mid\n        else:\n            omega = mid - 1\n    print(*solve(alpha))", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "from itertools import*\ndef out1(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==1 and b==0 and c==0:\n        return 1\n    return a*(out2(a-1,b,c)+out3(a-1,b,c))\ndef out2(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==1 and c==0:\n        return 1\n    return b*(out1(a,b-1,c)+out3(a,b-1,c))\ndef out3(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==0 and c==1:\n        return 1\n    return c*(out2(a,b,c-1)+out1(a,b,c-1))\ndef column(matrix, i):\n    return [row[i] for row in matrix]\nN, T = [int(x) for x in raw_input().split()]\nA = []\ns = 0\nfor i in range(N):\n    A.append([int(x) for x in raw_input().split()])\nfor i in range(1,N+1):\n    comb = list(combinations(A, i))\n    for x in comb:\n        if sum(column(x,0))==T:\n            a = column(x,1).count(1)\n            b = column(x,1).count(2)\n            c = column(x,1).count(3)\n            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))\nprint(s%1000000007)", "complexity": "np", "problem": "1185_G1", "from": "CODEFORCES", "tags": "bitmasks,combinatorics,dp"}
{"src": "n, l, r, x = map(int, input().split())\ntasks = [int(i) for i in input().split()]\ncnt = 0\nfor num in range(2 ** n):\n    bin_num = bin(num)[2:]\n    if len(bin_num) < n:\n        bin_num = '0' * (n - len(bin_num)) + bin_num\n    m = []\n    for i in range(n):\n        if bin_num[i] == '1':\n            m.append(tasks[i])\n    if sum(m) >= l and sum(m) <= r and max(m) - min(m) >= x:\n        cnt += 1\nprint(cnt)", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "xs, ys = map(int, input().split())\nthings = [[xs, ys, 0]]\nn = int(input())\nfor i in range(n):\n    things.append(list(map(int, input().split())) + [i + 1])\n\n\ndistance = [[0 for i in range(n + 1)] for j in range(n + 1)]\nfor i in range(n + 1):\n    for j in range(i, n + 1):\n        distance[i][j] = distance[j][i] = (things[i][0] - things[j][0]) ** 2 + (things[i][1] - things[j][1]) ** 2\n\nINF = float('inf')\nDP = [INF for _ in range((1 << n) + 10)]\nPath = [None for _ in range((1 << n) + 10)]\nDP[0] = 0\n\nfor cur in range(1 << n):\n    if DP[cur] == INF:\n        continue\n    for nxt1 in range(n):\n        if cur & (1 << nxt1) != 0:\n            continue\n        \n        if DP[cur | (1 << nxt1)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]:\n            DP[cur | (1 << nxt1)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]\n            Path[cur | (1 << nxt1)] = cur\n        \n        for nxt2 in range(n):\n            if (cur | (1 << nxt1)) & (1 << nxt2) != 0:\n                continue\n            if DP[cur | (1 << nxt1) | (1 << nxt2)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]:\n                DP[cur | (1 << nxt1) | (1 << nxt2)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]\n                Path[cur | (1 << nxt1) | (1 << nxt2)] = cur\n        break\n\nprint(DP[(1 << n) - 1])\n\npath = []\ncur = (1 << n) - 1\nwhile cur != 0:\n    path.append(0)\n    father = Path[cur]\n    diff = cur ^ father\n    d1 = len(bin(diff)[2:])\n    path.append(d1)\n    diff ^= (1 << (d1 - 1))\n    if diff != 0:\n        d2 = len(bin(diff)[2:])\n        path.append(d2)\n    cur = father\npath.append(0)\npath = list(reversed(path))\nprint(' '.join(map(str, path)))", "complexity": "np", "problem": "0008_C", "from": "CODEFORCES", "tags": "bitmasks,dp"}
{"src": "import os, sys, atexit\nfrom io import BytesIO, StringIO\n \ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n_OUTPUT_BUFFER = StringIO()\nsys.stdout = _OUTPUT_BUFFER\n \n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\nn, m = map(int, input().split())\narr = [0] * n\nfor i in range(n):\n    temp = list(map(int, input().split()))\n    arr[i] = temp\nx = 1\nN = 2 ** m - 1\nlo = 1\nhi = 1000000009\nind = [0, 0]\nwhile 1:\n    l = {}\n    freq = [0] * (2 ** m)\n    for i in range(n):\n        an = 0\n        for j in range(m):\n            if arr[i][j] >= x: an += 2 ** (m - j - 1)\n        if freq[an] == 0:\n            l[i] = an\n        freq[an] = 1\n    # print(l)\n    ch = 0\n    for k1, v1 in l.items():\n        for k2, v2 in l.items():\n            # if v1 == v2: continue\n            if v1 | v2 == N:\n                ch = 1\n                ind[0] = k1 + 1\n                ind[1] = k2 + 1\n                # print(x)\n                break\n        if ch: break\n    if ch:\n        lo = x\n        x = x * 2\n    else:\n        hi = x\n        break\nans = lo\nwhile hi - lo > 1:\n    x = (lo + hi) // 2\n    l = {}\n    freq = [0] * (2 ** m)\n    for i in range(n):\n        an = 0\n        for j in range(m):\n            if arr[i][j] >= x: an += 2 ** (m - j - 1)\n        if freq[an] == 0:\n            l[i] = an\n        freq[an] = 1\n    # print(l)\n    ch = 0\n    for k1, v1 in l.items():\n        for k2, v2 in l.items():\n            # if v1 == v2: continue\n            if v1 | v2 == N:\n                ch = 1\n                ind[0] = k1 + 1\n                ind[1] = k2 + 1\n                # print(x)\n                break\n        if ch: break\n    if ch:\n        lo = x\n    else:\n        hi = x\nans = lo\n# print(ans)\nif ind[0] == 0: print(\"1 1\")\nelse: print(*ind)", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "# based on solution by @conqueror_of_tourist\nimport sys\n\nreader = (map(int, line.split()) for line in sys.stdin)\ninput = reader.__next__\n\nn, m = input()\narrays = []\nfor i in range(n):\n    arrays.append(list(input()))\n\nfull = (1 << m) - 1\nL = -1\nR = 10 ** 9 + 1\nwhile L + 1 < R:\n    check = (L + R) >> 1\n    \n    masks = {}\n    for i, arr in enumerate(arrays):\n        curr = 0\n        for val in arr:\n            curr <<= 1\n            if val >= check:\n                curr |= 1\n        masks[curr] = i\n    \n    isValid = False\n    for k1 in masks:\n        for k2 in masks:\n            if k1 | k2 == full:\n                ans0 = masks[k1]\n                ans1 = masks[k2]\n                isValid = True\n                break\n        if isValid:\n            break\n    \n    if isValid:\n        L = check\n    else:\n        R = check\n\nprint(ans0 + 1, ans1 + 1)\n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n#CF-E-00\n#import numpy as np\n#import heapq\n#from collections import deque\n#from collections import Counter as cnt\nfrom collections import defaultdict as ddc\n#from math import factorial as fct\n#from math import gcd\n#from bisect import bisect_left as bsl\n#from bisect import bisect_right as bsr\n#from itertools import accumulate as acc\n#from itertools import combinations as cmb\n#from itertools import permutations as pmt\n#from itertools import product as prd\n#from functools import reduce as red\n#import sys\n#sys.setrecursionlimit(10**9)  #\u518d\u5e30\u3092\u591a\u304f\u4f7f\u3046(\u30c7\u30d5\u30a9\u30eb\u30c8\u306f1000)\ndef main():\n    n, m, k = map(int,input().split())  #k: length of following inputs\n\n    def edges(s):\n        Ans = set()\n        for i in range(2**k):\n            ans = ''\n            for j in range(k):\n                if i>>j&1:\n                    ans = ''.join([ans, s[j]])\n                else:\n                    ans = ''.join([ans, '_'])\n            Ans.add(ans)\n        return Ans\n\n    D = ddc(lambda : -1)\n    for i in range(n):\n        D[input()] = i\n\n    flag = 1\n    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]\n    for _ in range(m):\n        S, t = input().split()\n        t = int(t)\n\n        for e in edges(S):\n            if D[e]+1:\n                Out[t-1].add(D[e])\n                In[D[e]].add(t-1)\n        if t-1 not in Out[t-1]:\n            flag = 0\n            break\n        else:\n            Out[t-1].remove(t-1)\n            In[t-1].remove(t-1)\n\n    from collections import deque\n    def topological_sort(In, Out):\n        \"\"\"\n        Kahn, breadth first search\n        In: \u5165\u529b\u3057\u3066\u304f\u308b\u9802\u70b9\u96c6\u5408\n        Out: \u51fa\u529b\u5148\u306e\u9802\u70b9\u96c6\u5408\n        \"\"\"\n        dq = deque()\n        L = []\n        for i, I in enumerate(In):\n            if not I:\n                dq.append(i)\n        while dq:\n            v = dq.popleft()\n            L.append(v)\n            for w in Out[v]:\n                In[w].remove(v)\n                if not In[w]:\n                    dq.append(w)\n        if len(L) < len(In):  #\u3053\u308c\u306f\u304a\u304b\u3057\u3044\n            return False\n        return L\n\n    T = topological_sort(In, Out)\n    if flag == 0 or not T:\n        print('NO')\n    else:\n        print('YES')\n        print(*[t+1 for t in T], sep = ' ')\n        \nmain()", "complexity": "np", "problem": "1476_E", "from": "CODEFORCES", "tags": "bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"}
{"src": "import sys\n\n\ndef read_input(input_path=None):\n    if input_path is None:\n        f = sys.stdin\n    else:\n        f = open(input_path, 'r')\n\n    n, m = map(int, f.readline().split())\n\n    return n, m\n\n\ndef sol(n, m):\n    v = [0 for _ in range(n+1)]\n    left, right = 1, n\n    for i in range(1, n + 1):\n        if n - i - 1 <= 0:\n            pw = 1\n        else:\n            pw = 1 << (n - i - 1)\n\n        if m <= pw:\n            v[left] = i\n            left += 1\n        else:\n            v[right] = i\n            right -= 1\n            m -= pw\n    return [' '.join(map(str, v[1:]))]\n\n\ndef solve(input_path=None):\n    return sol(*read_input(input_path))\n\n\ndef main():\n    for line in sol(*read_input()):\n        print(f\"{line}\")\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "np", "problem": "0513_B2", "from": "CODEFORCES", "tags": "bitmasks,divide and conquer,math"}
{"src": "n,l,r,x=map(int,input().split())\nimport math\nz=list(map(int,input().split()))\ncount=0\nfor i in range(pow(2,len(z))):\n    \n    mini=math.inf\n    maxa=0\n    j=i\n    inde=0\n    sume=0\n    while(j>0):\n        \n        if(j&1):\n            sume+=z[inde]\n            maxa=max(maxa,z[inde])\n            mini=min(mini,z[inde])\n        j=j>>1\n        inde+=1\n\n    if(maxa-mini>=x and l<=sume<=r):\n        count+=1\n    \nprint(count)\n        \n        \n", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "from itertools import combinations\nn, l, r, x = map(int,input().split())\na = list(map(int,input().split()))\nprint(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))", "complexity": "np", "problem": "0550_B", "from": "CODEFORCES", "tags": "bitmasks,brute force"}
{"src": "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n \nn,m = map(int, input().split())\na = []\nfor i in range(n):\n    ai = list(map(int, input().split()))\n    a.append(ai)\n \ndef check(mid):\n    mask = (1<<m)-1\n    s = set()\n    d = dict()\n    for i in range(n):\n        state = 0\n        for j in range(m):\n            if a[i][j] >= mid:\n                state += 1<<j\n        #if state!=0:\n            #print(\"1bin\",bin(state),mid,a[i])\n        if state in s:\n            continue\n        s.add(state)\n        k = state\n        while k>=0:\n            #print(k,state)\n            k &= state\n            d[k] = i\n            k -= 1\n        need = mask^state\n        #print(s,d,need,state)\n        if need in d:\n            q1, q2 = d[need], i\n            if q1 > q2:\n                q1, q2 = q2, q1\n            return True, (q1, q2)\n    #print(s,d,need,bin(state))\n    return False, (-1, -1)\n \nleft = 0\nright = 10**9+1\ni,j = 0, 0\nwhile right-left>1:\n    mid = (right+left)//2\n    flag, (q1, q2) = check(mid)\n    #print(\"resround\",mid,left,right,i,j,q1,q2)\n    if flag:\n        left = mid\n        i,j = q1, q2\n    else:\n        right = mid\nprint(i+1, j+1)\n \n", "complexity": "np", "problem": "1288_D", "from": "CODEFORCES", "tags": "binary search,bitmasks,dp"}
{"src": "import sys\n\nn = int(input())\nl = list(map(int,input().split()))\nc = list(map(int,input().split()))\n\ndef gcd(a, b):\n    while b > 0:\n        a, b = b, a % b\n    return a\n\na = {0:0}\nb = [0]\n\nfor i in range(n):\n    for p in b:\n        d = gcd(p, l[i])\n        cost = a[p] + c[i]\n        if d not in a:\n            a[d] = cost\n            b.append(d)\n        elif a[d] > cost: a[d] = cost\n\nif 1 not in a: a[1] = -1\nprint(a[1])\n\n                                                                                                                                                                                                                        ", "complexity": "np", "problem": "0512_B", "from": "CODEFORCES", "tags": "data structures,dp,math,number theory,shortest paths"}
{"src": "from collections import defaultdict\n\ndata = defaultdict(list)\nposition = defaultdict()\nnxt = defaultdict()\nagg_sum = list()\n\nk = int(input())\ntrace = defaultdict()\nF = [False for x in range(1 << k)]\nback = [0 for x in range(1 << k)]\ntotal_sum = 0\nres = [(0, 0) for x in range(k)]\n\n\ndef build_mask(trace_mask):\n    if trace_mask == 0:\n        return\n\n    if trace.get(trace_mask):\n        for data in trace.get(trace_mask):\n            fr, to, v = data\n            res[fr] = (v, to)\n        return\n\n    sub_mask = back[trace_mask]\n    build_mask(sub_mask)\n    build_mask(trace_mask - sub_mask)\n\n\nif __name__ == '__main__':\n    for i in range(k):\n        values = list(map(int, input().split(' ')))\n        data[i] = values[1:]\n\n        agg_sum.append(sum(data[i]))\n        total_sum += agg_sum[i]\n\n        for cnt, v in enumerate(data[i], 0):\n            position[v] = (i, cnt)\n\n    if total_sum % k != 0:\n        print(\"No\")\n        exit(0)\n\n    row_sum = total_sum // k\n\n    for i in range(k):\n        for cnt, value in enumerate(data.get(i), 0):\n\n            x = i\n            y = cnt\n            mask = (1 << x)\n            could = True\n            circle = list()\n            while True:\n                next_value = row_sum - agg_sum[x] + data.get(x)[y]\n                if position.get(next_value) is None:\n                    could = False\n                    break\n\n                last_x = x\n                last_y = y\n\n                x, y = position.get(next_value)\n                circle.append((x, last_x, next_value))\n\n                if x == i and y == cnt:\n                    break\n\n                if mask & (1 << x):\n                    could = False\n                    break\n\n                mask |= (1 << x)\n\n            F[mask] |= could\n            if could:\n                trace[mask] = circle\n\n    for mask in range(1, 1 << k):\n        sub = mask\n        while sub > 0:\n            if F[sub] and F[mask - sub]:\n                F[mask] = True\n                back[mask] = sub\n                break\n            sub = mask & (sub - 1)\n\n    if F[(1 << k) - 1]:\n        print('Yes')\n        build_mask((1 << k) - 1)\n        for value in res:\n            print(value[0], value[1] + 1)\n    else:\n        print('No')\n", "complexity": "np", "problem": "1242_C", "from": "CODEFORCES", "tags": "bitmasks,dfs and similar,dp,graphs"}
